US6000028A - Means and apparatus for maintaining condition codes in an unevaluated state - Google Patents
Means and apparatus for maintaining condition codes in an unevaluated state Download PDFInfo
- Publication number
- US6000028A US6000028A US08/593,286 US59328696A US6000028A US 6000028 A US6000028 A US 6000028A US 59328696 A US59328696 A US 59328696A US 6000028 A US6000028 A US 6000028A
- Authority
- US
- United States
- Prior art keywords
- instruction
- native
- pointer
- condition code
- code
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Lifetime
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/44—Arrangements for executing specific programs
- G06F9/455—Emulation; Interpretation; Software simulation, e.g. virtualisation or emulation of application or operating system execution engines
- G06F9/45504—Abstract machines for programme code execution, e.g. Java virtual machine [JVM], interpreters, emulators
Definitions
- This invention relates generally to computer systems and more particularly to execution of computer programs on non-native computer system architecture.
- computer systems which generally include a central processing unit, a main memory, and input-output device interconnected by a system bus are used to execute computer programs to perform some useful task.
- One type of computer program is an operating system which is used to interface the central processing unit to an application program.
- the aforementioned application program is a program used by a user of the computer system to perform the useful task.
- the operating system includes all of the software resources needed by the computer system to interface each of the hardware elements, to the computer system as well as to interface the application program to other programs on the computer system.
- the application programs can include programs such as spreadsheets, word processors, electronic mail, etc.
- the application program executes on the computer system under the control of the operating system.
- the operating system often includes routines or libraries which the application program uses in order to complete its execution.
- Computer architectures are varied, but common architectures include the so-called Alpha® architecture by Digital Equipment Corporation's assignee of the present invention, the so-called X86 architecture which is based upon the family of X86 microprocessors designed and built by Intel Corp., as well as others such as the Power PC® architecture designed and built by Motorola, IBM and Apple.
- Other architectures include the VAX® architecture by Digital Equipment Corporation and the PA-RISC® architecture by Hewlett Packard.
- programs written for one architecture are also written for a particular operating system which is supported on the architecture.
- the architecture supports the Windows NT® operating system by Microsoft Corporation, the Open VMS® operating system by Digital Equipment Corporation, and the UNIX operating system by Digital Equipment Corporation as well as others.
- application programs written for one architecture and a particular operating system can not directly execute on a different architecture and/or different operating system.
- New computer architectures are developed in order to provide significant performance improvements for the hardware associated with the architecture.
- the so-called Alpha® architecture based upon the 64 bit Alpha microprocessor is a RISC type architecture (Reduced Instruction Set Computer).
- versions of the Alpha microprocessor operate at clock speed of 300 MHz.
- an application program executes much faster with higher performance and thus provides to a user significant performance advantages.
- Porting is a viable solution for many applications.
- applications involved in the so-called enterprise computing field are excellent candidates for porting since the nature of the program and the nature of the customer are such that there is an expectation of a high level of support from the software vendor as well as from the owner of the architecture.
- on-line interpretation a software module called an “interpreter” interprets instructions from the application program written in the non-native instruction set and converts those instructions into instructions or routines which execute on the new architecture.
- the interpreter thus tests the instructions to determine the resources needed by the instruction and analyzes the instruction to determine the function of the instruction. From this testing the interpreter maps the instruction to a routine that performs the same function only written in instructions executable on the new architecture. After the routine is identified the routine is executed in the computer system to provide the equivalent function called for in the application program written in the non-native instruction set.
- static translator a software program called a translator receives an instruction in the old architecture, and for each instruction, provides an instruction sequence in the new architecture to accomplish what the original instruction does in the old architecture.
- Condition codes are maintained on an X86 machine to provide knowledge of the machine state in the subject architecture to the computer system.
- X86 machines utilize six condition codes. These codes are Carry (C), Negative (N), Zero (Z), Overflow (O), Parity (P), and a low nibble carry (A).
- C Carry
- N Negative
- Z Zero
- O Overflow
- P Parity
- A low nibble carry
- the instructions that modify the condition codes on an X86 machine fall into five categories which designate which condition code bits are modified as a result of the execution of the individual instructions.
- the first category all condition code bits are modified (ALL).
- the second category of instructions modify all but the Carry bit (ALL -- BUT -- C).
- the third category of instructions modify only the Carry bit (ONLY -- C) while the fourth category modifies only the Zero bit (ONLY -- Z).
- the final category of instructions modify only the Carry and Overflow bits (C -- AND -- O).
- the emulating environment should also maintain condition codes.
- a simplistic approach to emulating condition codes is to maintain, in memory or within the registers of the new architecture, a set of bits which would be used to emulate the X86 condition codes. These bits would be appropriately modified upon execution of each condition code modifying opcode just as the condition codes bits within the X86 architecture are modified.
- condition codes are not necessarily used each time they are altered. That is, execution of a subsequent condition code modifying opcode may overwrite the modifications to the condition codes made by a previous opcode before a subsequent instruction is executed which uses one or more of the condition codes. In a system updating the condition codes after each opcode is executed, a considerable amount of CPU time is wasted which, if avoided, could speed up the execution time of the application program. Moreover, as some instructions only modify a subset of the condition codes it would be an additional waste of CPU time to recompute the current state of each of the condition code bits after each opcode is executed.
- a method for maintaining a plurality of condition codes bits in an unevaluated state.
- the method includes the step of storing, in response to an execution of a condition code modifying instruction, a first table of methods, the methods providing access to evaluation routines which, when executed, modify one or all of the plurality of condition code bits and the step of providing a first pointer to the first table of methods.
- the method also includes the step of providing a second table of methods, which correspond to a previously executed condition code modifying instruction, the methods providing access to evaluation routines which, when executed, modify one or all of said plurality of condition code bits and the step of providing a second pointer to said second table of methods.
- FIG. 1 is a block diagram of a computer system
- FIG. 2 is a block diagram of a dual stage instruction conversion system including a run-time system and a background system;
- FIG. 3 is a block diagram of the run-time system portion of the instruction conversion system of FIG. 2;
- FIG. 3A is a flow chart depicting the steps performed at run-time to execute a non-native image on the system of FIG. 1;
- FIG. 4 is a more detailed block diagram of a binary translator used in the background system portion of the conversion system of FIG. 2;
- FIG. 5 is block diagram of a data structure representing a profile record structure
- FIG. 6 is a block diagram of a representative profile record of the profile record structure of FIG. 5;
- FIG. 7 a diagram showing a typical arrangement for a instruction for a complex instruction set computer (CISC);
- FIG. 8 is block diagram of a register file in the computer system of FIG. 1 showing assignment of registers corresponding to the non-native architecture
- FIG. 9 is a diagram showing a typical construct for one of the registers in the register file of FIG. 8
- FIG. 10 is a pictorial representation of connections of various data structures including a dispatch table to determine an equivalent routine for the interpreter;
- FIG. 11 is a pictorial representation of the process for activating an alternate dispatch table
- FIG. 12 is a diagram showing an arrangement of an entry from the dispatch table of FIG. 10;
- FIG. 13 is diagram showing a typical arrangement of condition codes of a CISC architecture which implements condition codes
- FIG. 14 is a block diagram of an arrangement to determine evaluation routines for condition codes
- FIG. 15 a block diagram of an arrangement to determine evaluation routines for current and previous values of condition codes
- FIGS. 16, 17 and 18 are a series of diagrams useful in understanding how condition codes are handled in the run-time system of FIG. 3;
- FIGS. 19 and 20 are diagrams showing relationship between address spaces
- FIG. 21 is a diagram of a context data structure used in the interpreter of FIG. 4;
- FIG. 22 is a block diagram of a pair of data structures stored in memory which represents a return address stack for a non-native image of a program as well as shadow stack for a native image of the program;
- FIG. 23 is a diagram showing the relationship between the data structures of FIG. 22 and execution of non-native and native routines with calls into corresponding non-native and native routines;
- FIG. 24 is a diagram of a data structure including translated or native-image routines and call address translation table
- FIG. 25 is a diagram depicting the relationship of the routine call tables in the translated image and the shadow stack to the on-line and background systems;
- FIG. 26 is a flow diagram of a typical application program instruction sequence used to illustrate aspects of the invention.
- FIG. 27 is a block diagram showing an example of an object
- FIG. 28 is a block diagram showing an example of cross process calling of object methods
- FIG. 29 is a block diagram showing an example of an interface structure
- FIG. 30 is a flow chart showing an example of steps leading to the use of an object in an object oriented service system
- FIG. 31 is a flow chart showing steps in an example embodiment of a method for intercepting functions to perform interface structure replacement
- FIG. 32 is a flow chart showing an example replacement interface structure
- FIG. 33 shows an example embodiment of a template for a jacket function
- FIG. 34 is a flow chart showing steps performed in an example embodiment of a PBJA jacket function when called from non-native code
- FIG. 35 is a flow chart showing steps performed by an example embodiment of a PBJA jacket function when called from native code
- FIG. 36 is a flow chart showing steps performed by an example embodiment of a PAJB jacket function when called from native code
- FIG. 37 is a flow chart showing steps performed by an example embodiment of a PAJB jacket function when called from non-native code
- FIG. 38 is a block diagram showing an example of a system for load time processing to support interception of functions which take a pointer to an object as a parameter;
- FIG. 39 is a flow chart showing an example of steps performed at run time to support interception of functions which take a pointer to an object as a parameter;
- FIG. 40 is a flow chart showing an example embodiment of steps performed during general function jacketing
- FIG. 41 is a flow chart showing steps to determine and use translation units when performing a binary translation
- FIG. 41A is a flow chart showing steps to form translation units of a non-native binary image
- FIG. 42 is a flow chart showing steps of flow path determination
- FIG. 42A is a flow chart showing steps to determine transfer of control target locations for an indirect transfer instruction
- FIG. 43 is a block diagram showing two types of entries included in the profile statistics.
- FIG. 44 is a flow chart showing steps for determining regions
- FIG. 45 is a block diagram of a list of code cells
- FIG. 46 is a diagram which shows the relationship between FIGS. 47 and 48;
- FIGS. 47 and 48 are block diagrams which illustrate an arrangement of local data flow analysis information
- FIG. 49 is a block diagram of an opcode table
- FIG. 50 is a block diagram of a data flow analysis arrangement illustrating the use of read-modify and modify-write fields of the basic block value (BBV) data structure of FIG. 47;
- BBV basic block value
- FIG. 51 is a block diagram which depicts the BBSC summary information field of FIG. 48;
- FIG. 52 is a block diagram of an arrangement comprising global data flow analysis information
- FIG. 53 is a more detailed block diagram of the global data flow connections of FIG. 52;
- FIG. 54 is a block diagram of the control flow edge (CFE) data structure
- FIG. 55 is a flowchart that sets forth steps of performing a global data flow analysis
- FIGS. 56A and 56B are flowcharts that set forth method steps for determining merge points during global data flow analysis
- FIG. 57 is a block diagram of a global data flow analysis arrangement illustrating a merge point.
- FIGS. 58A-58D are block diagrams depicting different variations of the binary image transformer
- FIG. 59 is a flow chart of steps of translating the binary image
- FIG. 60 a flow chart of the step for one method for selecting the translation unit to be processed
- FIG. 60A is a representation of a call graph used in the method steps of FIG. 60;
- FIG. 61 is a flow chart depicting an alternative method for selecting a translation unit to be processed
- FIG. 62A is a flow chart listing steps for forming an initial intermediate representation (IR) of a binary image
- FIG. 62B As a block diagram of a data structure illustrating a transformation of a source instruction to an IR with memory perands removed;
- FIG. 62C is a block diagram of a data structure used to indicate whether an IR instruction corresponds to a machine instruction which can generate an exception
- FIG. 63 is a flow chart showing steps for translating and optimizing an initial IR to produce the final IR for a given translation unit
- FIG. 64 is a flow chart showing steps for performing condition code processing
- FIG. 65A is a block diagram of a bit mask associated with an IR instruction code cell used to represent condition codes that can be affected by the corresponding IR instruction code cell;
- FIG. 65B is a block diagram which depicts an example transformation from source instructions comprising the first binary image as affected by condition code processing
- FIG. 66 is a flow chart depicting steps for register processing
- FIG. 67A is a block diagram which depicts a 32 bit register in an architecture which has partial register operands
- FIG. 67B is a block diagram which depicts a transformation of an initial IR as a result of register processing
- FIG. 68A is a block diagram which depicts a code pattern which is detected by early floating point optimization processing
- FIG. 68B is a block diagram which is a table indicating a replacement instruction for a specific code pattern detected in early floating point optimization processing
- FIG. 69 is a flow chart depicting steps for local basic block and global routine optimization processing
- FIG. 70 is a flow chart depicting steps of code selection and operand processing which place the IR in final form
- FIG. 70A is a flow chart depicting steps of intra image call processing
- FIG. 71A is a block diagram depicting a translated image comprising tables used in exception handling
- FIG. 71B is a block diagram depicting a table entry in a translator exception table.
- FIG. 71C is a block diagram depicting run time transfer of control when a translated image is executed and an exception occurs.
- a computer system 10 is shown to include a processor module 12 which has a high performance processor 12a.
- the computer system 10 further includes, in addition to the processor module 12, a main memory 14, an disk adaptor 15 and an I/O user interface 18, as well as a monitor 19 all coupled by a system bus 20, as shown.
- the processor 12a is a high performance microprocessor such as an Alpha® microprocessor manufactured by Digital Equipment Corporation, assignee of the present invention, or other high performance processor.
- the main memory 14 is comprised of dynamic random access memory and is used to store instructions and data for use by the microprocessor 12a on the processor module 12.
- the disk adaptor 15 is used to couple the system bus 20 to a disk bus which itself is coupled to disk storage device 17.
- the disk storage device 17 is here illustratively partitioned into a plurality of segments or blocks of data which are here represented for convenience as being self-contained and contiguous, but which may be scattered across the disk 17 and be non-contiguous.
- the disk 17 includes a first storage segment 17a storing an operating system for the computer system 10 as well as an application program stored in segment 17b.
- the application program stored in segment 17b is a non-native executable image. That is, the application program is comprised of instructions from a different instruction set than that used in the computer system 10 (i.e. a different computer architecture). Also the application program could have been written for a different operating system than that stored in 17a. Since the instructions provided in the program stored in segment 17b are different from the instruction set executed on the microprocessor 12a the program in segment 17b can not be directly executed on the system 10.
- the disk also includes a storage segment 17c which here represents an native executable image of the application program stored in segment 17b.
- This native image is generated in the computer system via a binary image conversion system (16, FIG. 2) which is here stored with the operating system in the segment 17a as will be described.
- the image stored in segment 17c corresponds to instructions which can be executed on the microprocessor 12a and thus conforms to the architecture of the computer system 10.
- profile statistics which are collected during execution of a portion of the non-native application program stored in 17b.
- the profile statistics are provided by execution of a run-time routine which converts non-native instructions into native instructions.
- These profile statistics are used in a background process to convert portions of the non-native image into a native image corresponding to the operation and function of those portions of the non-native application program.
- data which are used for the particular application program are also stored on the disk in segment 17e.
- the computer system 10 further includes an I/O user interface 18 which is here an interface used to couple a mouse 19a, for example, to the system bus 20 as well as a monitor 19.
- I/O user interface 18 is here an interface used to couple a mouse 19a, for example, to the system bus 20 as well as a monitor 19.
- the computer system 10 operates in a generally conventional manner. That is, at "power on”, selected portions (not numbered) of the operating system stored in segment 17a are loaded into main memory 14 and occupy a particular address space in main memory 14, such as, address space 14a. As a user of the computer system 10 executes application programs on the system 10, the application programs are run under the control of the operating system.
- a typical operating system represented by that stored in 17a is the so-called Windows NT® operating system of Microsoft Corporation Redmond, Washington.
- Windows NT® or other window type operating systems displayable images called "icons" are presented to a user on the monitor 19. These icons represent an executable command to initiate execution of a program. When pointed to by a cursor controlled by a mouse, for example, and clicked on this user action activates the command and causes the represented computer program to execute.
- the application program stored in segment 17b is written in a non native instruction set. That is, the instruction set of the application program is not the same as the instruction set of the computer system 10.
- the executable image of the application program stored in segment 17b is comprised of non-native instructions which can not be directly executed on the computer system 10.
- the non-native application has a corresponding icon (not shown) which is represented in the window provided by the operating system.
- Each non-native application image has a unique identification name (ID) or image key.
- the identification name or image key is included in the non-native image file and is a unique identifier for the non-native application image.
- a server process portion of the operating system determines the unique ID or key to the non-native application image.
- the ID number is generally assigned by concatenating together unique information of the file. Examples of the types of information include, the time stamp of the file, the file name, the file size and the date that the file was originally produced.
- the same non-native image if loaded a multiplicity of times on the computer system will have the same I.D. number.
- the statistics as well as the translated code associated with each one of the non-native images will be the union of all prior executions of the non-native images for each instance of the non-native application. Other arrangements are of course possible.
- a portion of the operating system recognizes the ID of the executable image represented by that icon as being comprised of instructions that are non-native to the instruction set and architecture of computer system 10.
- a software module called a loader in the operating system will recognize that the identification name (ID) of the file represented by the selected icon as being non-native to the architecture.
- the operating system initiates the execution of an instruction conversion program 16 or feeds the file instruction by an instruction to an instruction pre-processor.
- a loader can be provided which handles the non-native image by examining the image to determine all files, libraries and resources needed by the image. The loader will thus prepare the non-native image for execution. Part of the preparation is the initiation of the instruction conversion program 16 or alternatively instruction pre-processor, as will now be described.
- the binary image conversion system 16 is shown to include a run-time system 32 which is responsive to instructions provided from the disk segment 17b.
- the run-time system 32 can be implemented as software to emulate the non-native architecture or as a hardware preprocessor to convert the non-native instructions into native instructions.
- the run time system 32 consumes more disk space on disk 17 and occupies more main memory storage in main memory 14.
- the run time system 32 requires more chip space in the high performance microprocessor 12a.
- the run-time system will be described as a software implementation which operates in an execution address space 20 of the computer system 10.
- disk segment 17b stores instructions of an application program complied and/or written for an instruction set which is different from the instruction set of system 10.
- the run-time system 32 receives portions of a non-native executable image from segment 17b comprised of the non-native instructions.
- the run-time system 32 provides a native instruction or a native instruction routine comprised of a plurality of instructions which are executed by the computer system 10 to provide the same functionality as the non-native image. That is, the functionality called for in the instruction in the executable image of the non-native instruction set is equivalently provided by the routines determined by the run-time system 32.
- the run-time system executes the equivalent routines on the computer system 10. This provides the equivalent function to provide the same result in computer system 10 which implements the new architecture as would occur in a new or old computer system (not shown) implementing the non-native architecture.
- the run-time system 32 examines and tests the code from the segment 17b to determine what resources are used by the instruction and the function of the instruction.
- the run-time system 32 provides the equivalent instructions corresponding to the architecture of the computer system 10.
- profile data or statistics are collected in response to their execution.
- the profile statistics describe various execution characteristics of the instruction sequence.
- the run-time system 32 Prior to performing a conversion by the run time system 32, the run-time system 32 interrogates the server process 36 via a path 32a to determine from the server process whether there is a native image corresponding to the routine of the application program stored in segment 17b whose execution has just been requested by a user. If a native image does not exist (as would occur the first time the non-native image is executed), the run-time system initiates an interpretation process. If there is code in existence for the particular instruction reached in the application program, due to a prior execution in the run-time system and subsequent conversion by a background system, the run-time system 32 will request and execute the native code.
- native image code As mentioned, in general, the first time the application program 17b is executed by a user there will be no native image code in existence. As the program executes, however, native code will be generated by the background process in a manner to be described, and over time as substantial portions of the non-native image are executed, convertible portions of the non-native image will be converted by the background process into native image code. As native image code is generated, it is also stored in segment 17c in a manner that is transparent to the user.
- the native image file 17c contains an address correlation table which is used to track the segments of native code corresponding to segments of non-native code. This table is used at run time of the program in segment 17b to determine whether and which non-native segments have equivalent translated native segments.
- Translation into the native image is provided via a background system 34 which operates in one embodiment after the interpreter has finished execution of the instructions to provide translated code dependant upon the execution characteristics of the run-time converted instructions.
- the background system operates while there is a pause in CPU utilization by the run-time system 32.
- the background system can make translated code available to the run-time system 32 during execution to permit substitution of translated code for a subsequent occurrence of the non-native image during the current execution of the application program.
- the run-time system can be implemented as a preprocessor which provides the profile statistics for use by the background process.
- the background process can be implemented in hardware or software or a combination of both.
- the background system 34 receives the profile data generated by the run-time system 32. In accordance with the characteristics of the profile data, the background system 34 forms a native image of at least portions of the instructions of the non-native image stored in segment 17b of disk 17. A preferred arrangement is to have the background system implemented as a binary translator to produce translated code. The native image portions are stored in logical disk drive 17' for use if needed in subsequent executions of the application program from segment 17b.
- the logical disk drive 17' is a logical partition of the disk drive 17 and is here referred to as being a logical disk drive, because in general, it is transparent to the user, but it physically represents space storage such as segment 17c on the actual disk drive 17.
- the logical disk drive 17 could be a separate disk drive.
- the run-time system 32 and the background system are each under the control of the server process 36.
- the server process 36 is present throughout the operation of the computer system 10.
- the server process 36 is a software service process which, amongst other things, is used to schedule various transactions within and between the run-time 32 and background systems 34.
- the image translated code is stored on logical disk drive 17' in logical segment 17c' with the profile statistics being stored in logical segment 17d'. These locations correspond to segments 17c and 17d in FIG. 2.
- the run-time system will send a request to the server process 36 for native code corresponding to the non-native code currently in the run-time system 32.
- the translated code is code which was generated by a previous execution of the background system 34 in accordance with the profile statistics collected by execution of the routines furnished by the run-time system 32.
- the server process 36 supplies corresponding translated code (if any) to the run-time system 32. If there is translated code, the run-time system 32 will have the translated code execute in place of interpreting the code. Otherwise if there is no translated code, the run-time system 32 will interpret, translate, or otherwise convert the relevant portions of the non-native code currently executed in the computer system 10.
- the server process 36 controls inter alia the storage of the profile statistics. That is, the server process 36 will merge new (raw) statistics with previously stored merged statistics to provide a new merged profile. The server process will compare the new merged profile with the stored merger profile and will initiate a translation process in the background system 34 when there is a difference between the two statistics. The degree of difference needed to initiate execution is selectable. Such a difference indicates that heretofore never executed code was interpreted and executed in the run-time system. This process will be ongoing until all portions of the non-native image have been encountered by the user and all of the portions which can be translated by the background system 34 have been translated.
- the server process also determines the unique key or I.D. number to uniquely identify the non-native image stored in segment 17b.
- the attributes of the image comprising the I.D. include the file size, the date of creation of the image, the time stamp and so forth. This key is also used to identify the profile statistics with the non-native program.
- the background system 34 will, in general, translate nearly all instructions provided from the non-native applications stored in 17b. Certain types of instructions are preferably not translated. In general those instructions which are not translated are ones in which the execution of the instruction is not predictable. For example, instructions which are self modifying (i.e. are not in read only sections, that is, are on a writtable page) will not be translated. For these instructions the run-time system will execute them via the interpretation routines. Further, instructions for which in the non-native architecture there is no easily produced analog in the native architecture will not be translated. For example, in the X86 architecture of Intel, floating point instructions use a floating point control register to determine inter. alia. rounding modes etc. Although for many executions of the instructions the contents of the register may be in a normal state, this can not be guaranteed. Rather than have the translator determine the state it is more economical to handle these instructions in the interpreter.
- the run-time system 32 is shown to include an execution address space containing run-time system 32 which includes a run-time interpreter 44, a non-native loader 42 which is fed the ID corresponding to the non-native application image provided from segment 17b of the disk 17, a native image loader 43, native operating system dll's (dynamic link libraries) 45 and a return address stack management arrangement 20 (FIG. 22).
- the non-native loader 42 is similar to the native image loader 43 except it is capable of handling non-native images and interrogates the server process to determine whether there is any native code corresponding to the non-native code awaiting execution.
- the non-native loader 42 receives instructions corresponding to a non-native image of the application segment 46a and a native image of the application 46b corresponding to translated instructions provided from the background translator 34, and segment 46c corresponding to data.
- the non-native loader 42 is used to initially load the non-native file.
- the native loader 43 is used to initially load the native file if any.
- the native loader 43 determines whether an architecture number associated with the non-native image is a native or a non-native image. If the image is a native image execution continues as normal. If however the image is a non-native image, the native loader 43 calls the non-native loader 42 at step 50b. The non-native loader 42 loads the non-native image at step 50c and also recognizes that this architecture number associated with the program represents an application program written for a non-native instruction set. The non-native loader starts the binary image conversion system 16.
- the non-native loader 42 initially queries the server 36 at step 50d to respond with native code to accelerate execution of the image represented by the code stored in 17b. It should be appreciated that the function of the native loader 43 and the non-native loader 42 can be combined into a single loader.
- the server 36 responds at step 50e by indicating that there is no corresponding native image to execute in place of the non-native image. Therefore, the non-native loader 42 instructs the interpreter 44 to begin an interpretation at step 50f of the instructions from the non-native image.
- the interpreter 44 determines the length or number of bytes comprising the instruction, identifies the opcode portion of the instruction, and determines the resources needed by the instruction.
- the interpreter maps the non-native instruction to a native instruction or a native sequence of instructions based upon inter alia the opcode. These instructions are executed by the computer system 10 in the address space 20 (FIG. 3).
- the run-time interpreter 44 collects data resulting from the execution of the instructions as will be described in conjunction with FIG. 6. These "profile statistics" are stored by the server 36 on the logical disk drive 17'.
- the run-time interpreter 44 examines and analyzes the instructions to determine the proper native instruction sequence to replace for the non-native instructions provided from the executable image 46a. These native instructions as they are executed continue to generate profile statistics which are collected and stored in logical disk drive storage 17c'. This process continues until execution of the program 17b is terminated by the user.
- a background process 34 is initiated (not shown).
- the background process 34 could be initiated to steal execution cycles from the run-time process 32 or alternatively could be used to substitute into the run-time process translated native image code for routines which are subsequently called during execution of the program 17b, as explained above.
- the exact sequence of which the background processor is used in conjunction with the run-time processor is an implementation detail.
- the interpreter 44 will only provide interpreter code if the server process 36 does not return a native image equivalent of the sequence which is provided from the background process 34 as will be described.
- the native image loader 42 at step 50g loads the native code.
- the non-native image loader 42 is called at step 50h to fix up the image.
- the non-native image will provide address tables corresponding to inter alia variables in the non-native image which are needed in the execution of the native image. That is, at step 50h the native and non-native images are stitched together to enable the native image to use information in the non-native image.
- the native code is executed.
- the native code that is executed corresponds to one or more basic blocks or routines of instruction which terminate by a return statement.
- a jacketing routine 48 is used to jacket functions leaving the execution address space 20 to the native execution space of the computer process of computer system 10 as well as those arising from the native execution space of the computer processor 10 into the execution address space 20 as will be further described in conjunction with FIGS. 27-40.
- the server 36 determines, responsive to the profile statistics data provided from the server 36, via logical disk drive 17', whether to initiate a translation process in the background.
- the background system 34 translates only portions of the non-native instructions of the application program which were actually executed (via the interpreter 32) in responsive to a session invoking the program.
- the non-native image code is examined at 52 in the server and if the code is the type that should be translated, it is fed to the translator 54.
- the translated code 54 is also fed to an optimizer 58, and again, if the type of code is of a type which can be optimized, it is fed through to the optimizer 58 or else, the process exits or terminates to await the submission of new code from executed portions of the non-native image stored at 17b. Other, techniques for performing translation and translation/optimization will be described.
- either translated code is stored in segment 17b' or optimized translated code is stored in segment 17b'.
- the data structure 60 has records which contain information about the execution of a non-native architecture program when the program executes control transfer instructions.
- the profile record can include other information. That is, the profile records contain information about a target address encountered in the non-native image.
- the data structure 60 is shown to include two principal sections.
- the first section is a profile header section 62 which comprises an image key field 62a.
- the image key field 62a is used to store information regarding the ID or identification of the profile record.
- the information in this field 62a is used to associate the profile statistics with a corresponding non-native image and its associated translated code, if any.
- the image key field 62a corresponds to the image ID or key field as mentioned above.
- the profile header 62 also includes a version field 62b comprised of a major version field 62b' and a minor version field 62b".
- the major version field 62b' and minor version field 62b" are each here 16 bit or 2 bytes in length and their union provides a resulting 32 bit version field 62b.
- the version fields are used to keep track of which version of the interpreter was used to generate the profile statistics in the table and the profile file format.
- the profile file 60 also includes a plurality of raw profile records, here 64 a -64 n .
- Each of the profile records 64 a -64 n maintains information about run-time execution of control transfer instructions in the non-native image.
- Each of these records are variable length records as is each of the unique profile files 60.
- the interpreter 34 will place into the raw profile record information regarding the execution of the control transfer instruction.
- the information which is included in the raw profile record is as described below. Suffice it here to say, however, that the raw profile records are used by the server process to provide a profile record which is then used during translation of the associated routines in the background system.
- the raw profile record 64 n includes a profile record structure 66 including an address field 66a, a flag field 66b and a count field which tracks the number of indirect targets of control transfer 66c.
- the address field 66a contains the actual target address in the non-native image, as determined by the interpreter 44. This address is the actual target address of the instruction that caused a control transfer during execution of the non-native image.
- the address field 66a is generally the address length of the non-native architecture or here 32 bits or 4 bytes long.
- the flags field 66b contains the states of the flags at the target address.
- the flags field 66b is here 2 bytes or 16 bits long.
- the n -- direct field 66c is a counter field which keeps track of the number of indirect target or computed target addresses contained in the remainder of the profile record 64 n as will be described below.
- One field is a count field 70a which corresponds to either the number of times a control transfer occurred to the address contained in field 66a or a count branch taken field counter which keeps track of the number of times a branch was taken by the instruction corresponding to the address contained in field 66a.
- Fields 70b 0 -70b n correspond to addresses which are the targets of the control transfer and are cumulatively maintained in the profile record structure.
- the optional fields 70 are used to keep track or maintain a count of the targets of the control transfer instruction in the image.
- the count field 70a is either a control transfer field count of the number of times control was transferred to the target address or a branch taken field corresponding to the count of the number of times a conditional control transfer of a branch instruction was taken.
- the type of field 70a is determined by the flags field 66b being "ANDED" or masked with a value which tests the state of the associated flag. This test determines whether the target address was a result of a control transfer instruction or a branch instruction.
- This optional field is also a long word.
- the target of control transfer fields 70b 1 -70b n are the target addresses of the control transfer which occurred at the control transfer instruction. These fields keep track of the addresses for indirect transfers, that is, transfers to a run-time computed target address.
- the profile statistics are managed by the server process 36.
- the profile statistics are collected by the interpreter 44 during the course of execution of the emulated code.
- For each execution the server 36 searches for a profile record corresponding the target address.
- the server 36 merges the new run-time statistics with the existing statistics to produce a new profile file.
- the server 36 makes use of a software cache and hash table (not shown) to keep track of the profile records. For an address which needs to be looked up, the address is looked up in the cache in 4 different locations that is by using a four way associative cache (not shown). If the address is not there it is looked up in a conventional hash table.
- the information in the hash table is the count values for the fields.
- interpreter 44 interprets instructions of the so-called X86 architecture by Intel Corporation San Francisco, Calif.) into ALPHA instructions by Digital Equipment Corp. will be described.
- an X86 instruction 100 is shown to include as many as six different fields. These fields are an opcode 100a, an rm byte 100b, a scaled index and base (sib) byte 100c, a displacement 100d, any immediate data 100e, and any one of six types of prefixes 100f.
- the opcode 100a defines the task or operation which will be executed by the instruction 100.
- the rm byte 100b is an effective address specification and is used in conjunction with the opcode 100a to specify a general operand as a memory or register location and, in some cases, also participates in defining the operation.
- the sib byte 100c is used in conjunction with the rm byte 100b to provide additional flexibility in addressing memory locations.
- the displacement field 100d provides a displacement from the base register or from virtual zero of a segment.
- the immediate data field 100e provides immediate data to the opcode 100a.
- the prefixes 100f are located before the opcode 100a in the instruction 100.
- Possible prefixes 100f are a segment override which implements a second (or multiple) addressing space, a repeat specifier value to repeat a specific instruction n times, a lock assertion for synchronization in multiple CPU environments, an address size prefix which selects between 16 and 32 bit addressing, an operand size prefix which selects between 16 and 32 bit operands, and an opcode prefix which selects an alternative opcode set.
- opcode 100a From the opcode 100a it can be determined whether an rm byte 100b, an unconditional displacement, or the immediate data field is provided in the instruction 100. It can be determined from the rm byte 100b whether a sib byte 100c and/or a conditional displacement field 100d is included in the instruction 100. As all fields are not required by each Intel instruction 100, Intel instructions are not of a fixed length, but rather are of varying lengths.
- the run-time interpreter 44 (FIG. 3) is, in the preferred embodiment, implemented on a computer system 10 (FIG. 1) which conforms to the Alpha architecture.
- An Alpha architecture computer system operates using the Alpha instruction set which is comprised of fixed length instructions.
- the run-time interpreter 44 operates on a single Intel instruction at a time. For each Intel instruction a single Alpha instruction or multiple Alpha instructions forming a corresponding Alpha routine, is provided which is an operational equivalent to the Intel instruction.
- the run-time interpreter 44 should be capable of emulating the operation of the Intel or non-native memory, registers, condition codes and a program counter which, on a 32 bit Intel machine is referred to as an extended instruction pointer, EIP. In this way, a result of the execution of the instruction 100 is recorded accurately.
- EIP extended instruction pointer
- the run-time interpreter 44 uses the same memory space for data while executing Alpha routines corresponding to Intel instructions as is used when executing native Alpha instructions. This is possible because the strict standards to which Win32 software applications adhere allow for differences in calling conventions but not in the representation of the data. The maintenance of the Intel registers, condition codes and EIP are discussed below.
- a table 101 depicting Intel or non-native values assigned to the registers of computer system 10 is shown to include eight registers which are assigned to emulate the operation of the eight Intel integer registers, EAX 104a, EBX 104b, ECX 104c, EDX 104d, EDI 104e, ESI 104f, EBP 104g, and ESP 104h.
- a single register, CONTEXT 105 is assigned to serve as a pointer to the emulator state context maintained in memory which is used to manage each thread executing in a multitasking environment.
- An additional register, FSP 106 stores a floating point stack pointer for addressing an eight entry stack of floating operands.
- CCR 107a, CCS 107b, and CCD 107c are assigned to store information which allow condition code bits to be maintained in an unevaluated state by the run-time interpreter 44.
- the SHADOW 108 register provides a pointer to the shadow stack (as will be described) which maintains activation records for translated code.
- the SEGOFF 109 register maintains an offset from address zero in the native architecture memory permitting the native architecture to emulate multiple addressing spaces which are possible in the Intel architecture and other non-native architectures.
- Four additional registers T0 110a, T1 110b, T2 110c and T3 110d are assigned as temporary registers.
- the frame 112 register identifies the activation record at the most recent activation of the run-time interpreter 44.
- the Emulator's Return Address, ERA 114 register stores the return address when the run-time interpreter 44 calls a private sub-routine.
- the Effective Address, EA 116 register stores the result of evaluating an RM byte 100b and to specify a memory address to a memory access routine.
- NXTEIP 118a, NXTQ -- LO 118b, NXTQ -- HI 118c, NXTJMP 118d, Q0 118e, Q1 118f and QUAD 120 retain values which are used by the run-time interpreter 44 to identify a complete Intel instruction 100 from the instruction stream and to provide pipelining capabilities.
- the run-time interpreter 44 assembles an eight byte (64 bit) snapshot of the instruction stream beginning at the start of the current Intel instruction number. This quadword is retained in QUAD 120.
- the run-time interpreter 44 captures two quadwords of information from the instruction stream.
- the run-time interpreter 44 uses the address in the instruction stream identified by the next extended instruction pointer, NXTEIP 118a, as the starting address for the first quadword.
- NXTEIP 118a identifies a random byte in the instruction stream at which the next instruction to be executed begins.
- computer system 10 FIG. 1
- the quadword captured beginning at this quadword aligned address is stored in register Q0 118e. By executing the capture in this manner, the quadword stored in register Q0 118e will at least provide the low byte of the next instruction.
- the second quadword capture occurs at an address identified by NXTEIP 118a incremented by seven bytes.
- computer system 10 requires a quadword aligned address for this second capture. If the address identified by NXTEIP 118a incremented by seven bytes is not quadword aligned, the run-time interpreter 44 forces the three low order bits to zero thus forcing the address to be quadword aligned. From this quadword aligned address, the capture is performed and the quadword is stored in register Q1 118f.
- the quadword stored in register Q1 118f contains at least the high order byte of the quadword beginning at the next instruction as identified by NXTEIP 118a.
- the run-time interpreter 44 executes an instruction which, using the three low bits of NXTEIP 118a, determines a byte in register Q0 118e which is identified by NXTEIP 118a, whether or not this byte is quadword aligned.
- the data in register Q0 118e is copied to register NXTQ -- LO 118b and shifted right to locate the byte identified by NXTEIP 118a in the low order byte register NXTQ -- LO 118b.
- the high order bytes of NXTQ -- LO 118b which, after the shift, no longer contain valid information are zeroed.
- the three low bits of the address identified by NXTEIP 118a incremented by seven bytes is used to determine the high order byte of the quadword beginning at NXTEIP 118a.
- the data in register Q1 118f is copied to register NXTQ -- HI 118c shifted left to locate the byte identified by NXTEIP 118a incremented by seven bytes in the high order byte of register NXTQ -- HI 118c.
- the low order bytes of NXTQ -- HI 118c which no longer contain valid information as a result of the shift are zeroed.
- the result of ORing the contents of registers NXTQ -- LO 118b and NXTQ -- HI 118c is stored in QUAD 120.
- the low bit of QUAD 120 is shown to be aligned with an Extended Instruction Pointer, EIP 121.
- EIP 121 identifies a location in the instruction stream which corresponds to the beginning of the current instruction. As each instruction in the instruction stream is executed, the EIP 121 is incremented in the instruction stream to point to the beginning of the next instruction. QUAD 120, therefore, holds a quadword of information beginning at the byte identified by EIP 121.
- the interpreter uses the information contained in QUAD 120.
- the first byte of an Intel instruction is the opcode 100a as shown in FIG. 7.
- the run-time interpreter 44 extracts the first and second low bytes 120a, 120b of QUAD 1002 to provide a two byte instruction fragment 122. From this two byte instruction fragment 122, a corresponding Alpha routine a nd the length of the instruction 100 are determined.
- FIG. 10 an arrangement 130 to determine the length of the Intel instruction 100 and the corresponding Alpha routine which implements the operational equivalent of the Intel instruction 100, is shown.
- the arrangement 130 extracts the two low bytes 120a, 120b from QUAD 120 to provide the two byte instruction fragment 122.
- This two byte instruction fragment 122 is used as an index into a dispatch table 131 which resides in system memory 14 (FIG. 1).
- the dispatch table 131 is generated by a tool which identifies each instruction in the Intel instruction set such that the two byte instruction fragment 122 is sufficient information to identify the proper entry which corresponds to the current Intel instruction 100.
- the tool also provides the complete length of the Intel instruction 100 and includes this information in the dispatch table in the length field 131b along with the location of the Alpha routine which will provide the functional equivalent of the Intel instruction 100 in the address field 131a.
- the run-time interpreter 44 chooses among eight dispatch tables based upon the sequence of prefix elements 100f preceding the actual opcode 100a.
- an Intel instruction 100 may be comprised of multiple elements 100a-100f. Multiple dispatch tables are provided by run-time interpreter 44 to handle the different values and combination of values which can be selected by the prefix element 100f. As discussed above, three possible prefixes 100f are addressing size (16 or 32 bits), operand size (16 or 32 bits) and two byte opcode, which selects an alternative opcode set. Any one or combination of these prefixes 100f may be present in an Intel instruction 100.
- the addressing size prefix toggles between an addressing size for the Intel system which truncates address arithmetic to 16 bits or to 32 bits. Typically, the address size is 32 bits.
- the operand size prefix is similar wherein an operand expected by the system is 16 bits under a 16 bit operand size or 32 bits when the operand size is set for 32 bits. Here again, the typical operand size is 32 bits.
- the final prefix toggles between two alternative opcode sets. The first is a one byte opcode set and the second is a two byte opcode set. Here, a one byte opcode set is typically selected.
- a dispatch table similar to the dispatch table 131 in FIG. 10 is provided in system memory 14 for each of the eight possible combinations of prefixes 100f, the default dispatch table is dispatch table 131 having a 1 byte opcode with a 32 bit addressing size and a 32 bit operand size.
- dispatch table 131 In addition to an entry for each instruction, also included in dispatch table 131 is an entry for each prefix 100f and prefix 100f combination.
- the 32 bit entry 131j corresponding to a prefix 100f, activates a different dispatch table in memory 14 in which the subsequent opcode 100a in the instruction stream and its corresponding two byte instruction fragment 122 may be used to index the proper 32 bit entry 131i.
- a process for activating an alternate dispatch table 131' is shown to include extracting a two byte instruction fragment 122 from QUAD 120.
- the two byte instruction fragment 122 is used as an index into the dispatch table 131.
- the two byte instruction fragment 122 identifies an entry in the dispatch table 131j.
- the dispatch table entry 131j includes a native routine address 131a in memory 14 and the length 131b of the Intel instruction 100 which here, is 001 or one byte.
- the first byte of the two byte instruction fragment 122 is a prefix 100f to instruction 100 which selects 16 bit addressing.
- the native routine 132 identified by the native routine address 131a instructs the run-time interpreter 44 to activate the dispatch table 131' which corresponds to an instruction set implementing 16 bit addressing.
- the length 131b of the Intel instruction 100 is provided to the run-time interpreter 44 which increments EIP 121 one byte in QUAD 120 to identify the beginning of the next instruction.
- a new two byte instruction fragment 122' is extracted from QUAD beginning at the new location identified by EIP 121.
- This two byte instruction fragment 122' identifies an entry 131i' in dispatch table 131'. Again, the two portions of the dispatch table entry 131i' identify the native routine address 131a' in memory 14 of the native routine 134 which is the operational equivalent of the Intel instruction 100 and the length 131b' of instruction 100.
- the run-time interpreter 44 executes the native routine 134 which provides the operational equivalent of Intel instruction 100. Once complete, the on-line interpreter activates the default dispatch table 131 for 32 bit addressing and operands and one byte opcodes. While the run-time interpreter 44 is executing the native routine 134 for Intel instruction 100, the process just described allows the run-time interpreter 44 to identify the beginning of the subsequent instruction by incrementing EIP 121. In addition, the entry in the active dispatch table 131 which corresponds to the subsequent instruction is also identified. From this entry 131n, the address of the native routine 131na corresponding to the subsequent instruction as well as the length 131nb of the subsequent instruction are determined. This arrangement allows the on-line interpreter to operate in a pipelined fashion, executing multiple instructions in parallel.
- a 32 bit entry 131i from dispatch table 131 is shown to be divided into two sections, the first section 131a corresponding to bits 3-31 of the 32 bit entry 1012 and the second section 131b corresponding to bits 0-2 of the 32 bit entry.
- Bits 3-31, section 131a are used to address the Alpha routines which execute the operational equivalent of the Intel instruction 100 and bits 0-2 131b signify the length of the Intel instruction 100.
- the dispatch table targets are aligned on quadword boundaries. That is, the Alpha instructions which the entries in the dispatch table 131 point to and execute the operational equivalent of Intel instruction 100, are located in system memory 14 on quadword boundaries. In this way, bits 0-2 of the address of the Alpha instructions are always zero. As a result, bits 0-2 131b' may be used to convey additional information about the instruction as here, where these bits are used to signify the length of the instruction. As the addresses of the Alpha routines are always 000 in bits 0-2 field 131b', a full 32 bit address is recreated by appending these zeros to bits 3-31 1012a to provide a complete 32 bit address.
- bits 0-2 are used to increment EIP 121 so that EIP 121 is pointing to the beginning of the next instruction.
- QUAD 120 contains sufficient information to form a second, two byte instruction fragment 122 which may be used to index the current dispatch table to determine the corresponding Alpha routine for the next Intel instruction.
- This arrangement allows the run-time interpreter 44 to pipeline instructions and thus execute the application program more quickly and efficiently. While an Alpha routine is being accessed corresponding to a current instruction, the run-time interpreter 44 is able to determine the address and length of the next Intel instruction 100 in the instruction stream.
- a value of zero returned from bits 0-2 field 131b of the 32 bit entry 131i for the length of the Intel instruction 100 indicates that the instruction was longer than 6 bytes and hence, pipelining is not possible for this Intel instruction and accordingly, the EIP 121 is not incremented. It is then the responsibility of the Alpha routine to increment EIP 121 and to refill the pipeline.
- general purpose registers 135 of an Intel X86 machine are shown to include a single register, EFLAGS 135a, in which condition codes are maintained.
- This register, EFLAGS 135a maintains the six condition code bits, the Carry bit 136a (C), the Negative bit 136b (N), the Zero bit 136c (Z), the Overflow bit 136d (O), the Parity bit 136e (P), and the Low Nibble Carry bit 136f (A).
- Each of these bits may be cleared or set as a result of the execution of an Intel instruction 100.
- the run-time interpreter 44 also maintains, in an unevaluated state, the current state of the condition codes resulting from the execution of an Alpha routine which corresponds to the Intel instruction 100.
- condition code modifying instruction may be executed, thus overwriting the changes made to the condition code bits by a prior condition code modifying instruction, before the state of the condition codes is required by a subsequent instruction.
- condition code modifying instructions effect only a partial set of the condition code bits. Accordingly, a complete evaluation of the condition code bits after execution of every condition code modifying instruction would be wasteful at CPU time. Nevertheless, the state of the condition code bits needs to be readily ascertainable throughout the execution of the X86 image should the current state of the condition codes be required.
- the run-time interpreter 44 is shown to include a set of data storage locations 138, a table of methods 139, and evaluation routines 140 which are used to emulate the X86 condition codes during execution of an X86 image in computer system 10.
- the set of data storage locations 138 is shown to include three locations 138a, 138b, 138c which are updated upon execution of an instruction which would have modified the condition codes in an X86 system.
- the first location, data1 138a, and the second location, data2 138b, store data used in the execution of the instruction, for example, an operand and a result of the instruction. This information is used later during execution of the application program should it become necessary to evaluate the condition codes.
- the third location, pointer 138c contains a pointer to the table of methods 139 which is a dispatch table used to evaluate the condition codes should the system require the current value of the condition codes.
- the table of methods 1022 contains an entry for each of the eight predicates available in X86 conditional branches (and equivalent SETcc instructions), an entry to obtain the nibble carry, A 136f, bit and an entry to obtain a complete image at the EFLAGS 135a register.
- the set of methods includes one for each of the six condition codes.
- Each entry in the table of methods 139 identifies an evaluation routine 140 which evaluates the condition described in the method table entry.
- Data1 138a and data2 138b are provided to the evaluation routines to determine the state of the condition code bits should a subsequent instruction require the current state of the condition codes.
- the run-time interpreter 44 stores zero to two pieces of information from the instruction in the first two storage locations, data1 138a and data2 138b. These pieces of information, possibly an operand and a result of the operation, are used by the evaluation routines to compute the condition codes.
- pointer 138c a pointer is placed which, in accordance with the type of instruction which was executed, identifies the entry in the table of methods 139 which will identify the evaluation routines 140 which are to be called if and when the condition codes are evaluated.
- the table of methods 139 is specific to the type of instruction executed. That is, if the instruction modifies all of the condition codes, the table of methods includes an entry pointing to a routine for each of the six condition codes. If the instruction modifies only the C bit, the only entry in the table of methods 138 is a entry pointing to an evaluation routine which will evaluate the C bit. Other possibilities include instructions which modify all of the condition code bits except for the C bit (ALL -- BUT -- C) instructions which modify only the Z bit (ONLY -- Z) and instructions which modify only the C and O bits (C -- AND -- O). The table of methods 139 for instructions of these types would include entries pointing to routines which correspond to all but the C bit, only the Z bit and only the C and O bits respectively.
- Each entry in the table of methods 138 identifies a separate evaluation routine 140 which computes that specific condition code predicate or image of EFLAGS 135. Because these routines are only executed when necessary, the condition codes are maintained in an unevaluated state and accordingly, only minimally effect the execution speed of the application. Data1 138a and data2 138b are provided to the evaluation routine 1024 to determine the effect the instruction had, or should have had, on the condition codes.
- the run-time interpreter 44 uses the information provided in the data storage locations 138a and 138b, the table of methods 139 and the evaluation routines 140 to determine the current values of the condition code bits.
- an Intel instruction can modify all condition code bits, or a subset of those bits. If the current instruction which modified the condition code bits modifies only the C bit and the previous instruction modified all of the condition code bits it would be wasteful to gather the data necessary to evaluate all but the C bit and copy it into the table of methods 139 which is provided for the current C bit modifying instruction. As a result, the run-time interpreter 44 maintains information to evaluate the previous state of the condition code bits based upon a previous condition code modifying instruction as well as the current condition code modifying instruction.
- the interpreter is shown to include two sets of data storage locations 138 and 138', two corresponding tables of methods 139 and 139' and corresponding evaluation routines 140 and 140'.
- a first condition code evaluation grouping 137 corresponds to a current condition code modifying instruction and a second condition code evaluation grouping 137' corresponds to a previously executed condition code modifying instruction.
- a finite state machine FSM is provided which determines how the previous and current states of the condition codes are maintained.
- the states and transitions of the FSM are the five types of condition code updates: ALL -- BUT -- C, ONLY -- C, C -- AND -- O, ONLY -- Z and ALL. Each transition has associated with it one of three actions: replace, push or resolve.
- TABLE 1 describes the action taken to maintain the condition code bits. The action is contingent upon which condition code bits the current instruction will modify as well as which condition code bits were modified by a previously executed condition code modifying instruction. In addition, the actions have been carefully selected to provide an action for the transition which entails a minimal amount of work yet still provides the run-time interpreter 44 a complete up-to-date set of condition code bits at any time.
- a replace action the contents of the current condition code evaluation grouping are replaced by the values resulting from the next instruction. That is, the contents of the data storage locations 138, the corresponding table of methods 139 and the evaluation routines 140 are replaced with values which will enable the run-time interpreter 44 to evaluate the condition codes modified as a result of the next instruction.
- a replace action does not modify the contents of the previous condition code evaluation grouping.
- a replace action is appropriate when the set of condition code bits modified by the next condition code modifying instruction includes at least all of the condition code bits in the set of condition code bits modified by the most recent condition code modifying instruction.
- a push action however, replaces the contents of the previous condition code evaluation grouping 137' with the contents of the current condition code evaluation grouping 137.
- the current condition code evaluation grouping 137 is used to provide the necessary information to evaluate the condition code bits modified by the next instruction.
- a push action is appropriate when the set of condition code bits modified by the next condition code modifying instruction does not include all of the condition code bits in the set of condition code bits modified by the most recent condition code modifying instruction.
- a union of the two condition code bit sets results in a complete set of condition code bits.
- the final action is a resolve.
- the resolve is the most complicated of all the actions.
- the state of the condition codes as represented by the current and previous condition code evaluation groupings 137 and 137', is evaluated resulting in a complete set of condition code bits, or an ALL, in the current condition code evaluation grouping 137.
- a push is then performed for the next instruction.
- a resolve action is appropriate when more than two condition code evaluation groupings would be necessary to maintain a complete set of condition code bits.
- the first condition code evaluation grouping 137 maintains in an unevaluated state the state of the condition codes corresponding to the execution of a current instruction.
- the second condition code evaluation grouping 138 maintains in an unevaluated state the state of the condition codes corresponding to the execution of a previous instruction.
- the first set of data storage locations 138 here, registers CCR 107a, CCS 107b and CCD 107c retain three values.
- CCR 107a and CCS 107b contain data used by the current, non-native instruction such as an operand and a result of the instruction.
- CCD 107c contains a pointer to the dispatch table 139 provided to evaluate the state of the condition codes which are modified as a result of the execution of the current instruction.
- the second set of data storage locations 138' retain similar values corresponding to a previous condition code modifying instruction.
- each condition code evaluation grouping 137, 137' is shown to include a location in the respective table of methods 139, 139' which indicates the category of instruction which was executed. That is, whether the instruction modifies all of the condition code bits or a subset of the condition code bits. Using this value and the information in the FSM of TABLE I, the run-time interpreter 44 maintains in an unevaluated state, the complete set of condition code bits.
- the category location 139a of dispatch table 139 would indicate an ALL value. Accordingly, an entry for each of the six condition code bits is provided in dispatch table 139a to access evaluation routines 140 for each condition code bit.
- the category location 139a of the current dispatch table is accessed to determine the category of the previous instruction.
- the run-time interpreter 44 manipulates the contents of each condition code evaluation grouping 137, 137' accordingly.
- the category of the most recently executed instruction is ALL while the category of the next instruction is ONLY -- C.
- the action which is to be taken is a push.
- a push is an appropriate action because the set of bits modified by the next condition code modifying instruction, ⁇ C ⁇ , does not include all of the bits modified by the most recently executed condition code modifying instruction, ⁇ C, N, O, P, A ⁇ .
- a union at the two condition code bit sets results in a complete set of condition code bits, ⁇ C, N, Z, O, P, A ⁇ .
- the information retained in the current condition code evaluation grouping 137 is pushed or copied into the storage locations for the previous condition code evaluation grouping 137'. That is, the data in CCR 138a and CCS 138b are copied to data1 138a' and data2 138b' respectively and CCD 138c is copied to pptr 138c'.
- the current condition code evaluation grouping 137 is then used to store the data used to evaluate the C bit which is the only condition code bit modified by the next instruction. An example is provided below in conjunction with FIGS. 16 and 17 which describes a resolve action.
- a set of condition code state diagrams 150 includes a condition code state 152 diagram for a previously executed condition code modifying instruction, a condition code state 154 diagram for a most recently executed condition code modifying instruction and a condition code state 156 diagram for a next condition code modifying instruction.
- the previous condition code state 152 is ALL -- BUT -- C in which all but the C bit is modified.
- the most recent condition code state 154 is C -- AND -- O in which only the C and O bits are modified as a result of the execution of the most recently executed condition code modifying instruction.
- the next condition code state 156 is ONLY -- C in which only the C bit is modified.
- the most recent condition code state 154' diagram is shown to contain a complete set of condition code bits.
- the most recent condition code state 154' is ALL and the next condition code state 156' is an ONLY -- C.
- the appropriate action to be taken is a push when the most recent condition code state is ALL and the next condition code state is ONLY -- C. Accordingly, the run-time interpreter 44 can push the condition code information resulting from execution of the next instruction without losing any condition code bit information.
- condition code state 152" diagram is shown to indicate a complete set of condition code bits which was pushed from the most recent condition code state 154' in FIG. 17.
- the most recent condition code state 154" diagram of FIG. 18 now indicates execution of a condition code modifying instruction which modified only the C bit. As may be seen, all information relating to the most current state of each of the condition code bits has been preserved.
- FIG. 19 an implementation of multiple address spaces on an Intel machine is shown to include segments CS 160, DS 162, and SS 164 identifying address 0 166 of a first address space 168 and segment FS 170 identifying address 0 172 of a second address space 174.
- Data X 168i is located within the first address space 168 and data Y 174i is located within the second address space 174.
- first address space 168 and the second address space 174 exist independently from each other. Accordingly, there is no relationship between the location identified by segments CS 160, DS 162, and SS 164 and segment FS 170. Nor is there any relationship between the address of the location of data X 168i in the first address space 168 and address of the location of data Y 174i in the second address space 174.
- emulation of multiple address spaces on a native architecture is shown to include segments CS 160', DS 162', and SS 164' identifying address 0 166' of a first address space 168' and segment FS 170' identifying address 0 172' of a second address space 174' where segment FS 170' has an offset 175 from address 0 166' of the first address space 168'.
- the value of the offset 175 is stored in SEGOFF 109 (FIG. 8).
- the context data structure 180 is used by the run-time interpreter 44 to handle multitasking capabilities of the non-native software application.
- a snap-shot of the current state of the run-time interpreter 44 is saved in a context data structure 180.
- the context data structure 180 is used by the new thread to provide the run-time interpreter 44 executing in the new thread the state of the run-time interpreter 44 executing in the thread which initialized the new thread.
- Values which are saved in the context data structure 180 include the current condition code state in field 181.
- this field includes subfields (not shown) to provide copies of the values stored in registers CCR 138a, CCS 138b and CCD and 138c. Values are provided in field 182 to store the previous state of the condition code bits.
- the context data structure also includes copies of the integer registers EAX 104a, EBX 104b, ECS 104c, EDX 104d EDI 104e, ESI 104f, EBP 104g and ESP 104h in field 183.
- field 183 values for the six segments (seldomly used in WIN32 applications) are provided.
- the six segments, four of which are depicted in FIGS. 19 and 20 are cs, ds, es, fs, gs and ss.
- a copy of the floating stack pointer 106 (FIG. 8) is also provided in field 185 in addition to a starting value for the floating stack pointer as well as the floating stack entries.
- Field 186 of the context data structure 180 provides pointers to each of the eight possible dispatch tables. Exemplary dispatch tables 131 and 131' are depicted in FIGS. 10 and 11.
- the context data structure 180 also provides in field 187 the Extended Instruction Pointer, EIP 121.
- a repeat specifier value as designated by one of the possible prefixes 100f (FIG. 8), is provided in field 188. Values relating to the Emulator Return Address, ERA 114, register are stored in field 189. In fields 190 and 191 pointers used to maintain the profile table as well as pointers to portable math routines are also provided respectively. Values of selected constants are also provided in the context data structure 180 in field 192 while pointers to maintain a linked list of context data structures is provided in field 193.
- An additional aspect of a preferred embodiment includes structuring the order of the software which implements the run-time interpreter 44 such that critical blocks of the software code exist in a single cache block. In this way, the run-time interpreter 44 is able to execute more efficiently as the portions of the interpreter 44 which are executed most often are resident in the cache.
- a return address stack arrangement 210 is shown to include a non-native return address stack 211 and a shadow stack 212.
- the non-native return address stack 211 is an address stack which is produced as if the non-native image were executing in the non-native environment.
- the non-native return address stack 211 comprises a plurality of frames 219, each of said frames including a corresponding one of non-native return address fields 213a-213c, as well as fields 215a-215c for local storage, as shown.
- the non-native return address stored in locations 213a-213c corresponds to the routine return address that is pushed onto the stack by the program when it executes a call instruction. That is, the non-native program when executing in a native environment would place on the stack 211 a particular return address corresponding to the address space as if the non-native program was executing in its native environment.
- the return stack arrangement 210 also includes a shadow stack 212.
- the shadow stack 212 likewise is comprised of a plurality of frames 214, each of said frames 214 comprising a header field 216a-216c and corresponding or associated local storage fields 218a-218c.
- the return address arrangement 210 also includes a pair of stack pointers, one for the non-native return stack 211 and one for the shadow stack 212.
- the non-native return address stack pointer 217 also referred to as SP points to the bottom or most recent entry in the non-native return address stack.
- the non-native return address stack 211 has an initial address A 0 of ⁇ 7FFFFFFF>.
- the initial address of ⁇ 7FFFFFFFFF> insures that as the stack pointer SP is decremented, the largest stack pointer value will not be sign extended by an LDL instruction as will be described.
- the header portion 216a-216c of the shadow stack frames 214 here comprises four sub-fields.
- the first sub-field 220a also referred to as SP is the contents of the non-native stack pointer 17 corresponding to the return address in the non-native stack pointer for the particular shadow stack frame 214.
- the non-native stack pointer corresponds to the size of the emulated operating system.
- the non-native stack pointer 220a would comprise four bytes.
- the second entry 220b in the header 216a-216c is the non-native instruction pointer value 220b.
- the non-native instruction pointer is the address that is pushed onto the non-native return address stack 211. This address also comprises the same number of bytes as the number of bytes supported in the operating system. Thus, again for a 32 bit operating system, the number of bytes is 4.
- the third entry 20c in the header portion 216a-216c is a native return address field 220c.
- the native return address field 220c comprises the native return address which is placed on the shadow stack if a translated routine executes a call instruction. This corresponds to the address of the native instruction which is to resume execution in the translated routine after the called routine has completed.
- the fourth entry in the header 216a-216c is the native dynamic link 220d.
- the native dynamic link field is a pointer to the previous shadow frame header 214.
- the value stored in the field "dylnk" corresponds to the location of the next shadow frame header 216b.
- This value is preferably included in the shadow stack 212 to allow the shadow stack 212 to make provisions for a variable amount of local storage in fields 218a-218c. In situations where the local storage fields are not provided or their size is fixed, it is not necessary to have a dynamic link field.
- the local storage fields 215a-215c in the non-native register stack 211 comprises routine calls and routine arguments of the non-native system and is provided to faithfully replicate that which would occur in the non-native system were it being executed on its native architecture.
- the routine locals and routine arguments stored in the non-native return stack are passed to translated routines via the translation process described above and as will be further described in detail below.
- the non-native return address stack 211 is managed exactly as dictated by the non-native code being emulated in the interpreter 44.
- the interpreter 44 When the interpreter 44 is executing the non-native or non-native code of a particular thread, there is only one native frame on the shadow stack 212 for the interpreter. This permits the interpreter to transfer execution into translated code in the event that there is corresponding translated code to be executed.
- the interpreter does not push frames onto the shadow stack 212. Further, when transferring into and out of translated routines, the interpreter does not push data onto the native system stack. Rather, when transferring into and out of translated routines, shadow frames 214 are pushed onto the shadow stack 212 to record the state associated with the translated routines.
- the shadow stack 212 tends to be synchronous with the routine frames on the non-native return stack.
- calling jackets 48 FIG. 3 may cause another instance of the interpreter 44 to be produced if a callback is performed, and thus push another interpreter frame onto the non-native return address stack 211, once the jacketed operation has been completed this extra frame is removed from the non-native or non-native stack 211.
- the shadow frame 214 includes the space necessary for the translated routine's locals such as the spilled registers mentioned above, and the shadow frame header.
- the program 230 includes a routine A which has a plurality of instructions, one of which is a call to a routine B (call B) at 233.
- Routine B likewise, has a plurality of instructions with the last instruction being a return instruction RET.
- Program flow 230 represents a program flow for the non-native program executing in its native environment.
- routine A when the Call B instruction 233 is executed, it causes the next instruction at address A N to be pushed onto the non-native return address stack 211, as shown.
- the stack pointer for the non-native instruction stack 211 is incremented to the next value, thus pointing to the entry for A N .
- Routine B is called by routine A and executes its instructions causing at the last instruction (RET) a return which causes a pop from the non-native return address stack 211.
- RET last instruction
- the pop delivers the address A N on the location of the next instruction to be loaded into the program counter for execution.
- stored in field 220b is a copy of the non-native return address that was pushed on the non-native stack by the execution of the call instruction.
- the non-native return address is provided by the translated image and corresponds to the non-native call for the particular call in the native or translated image.
- the non-native extended instruction pointer has a value corresponding to A N .
- stored in field 220c is the value of the native return address A N '.
- the dynamic link is stored in field 220d which corresponds to the address of a preceding shadow stack frame header. A new dynamic link is produced by saving the value of the shadow stack pointer prior to allocating a new frame.
- In location 218 is provided local storage for allocated variables provided during the translation of the corresponding routines A' and B' from the translator as mentioned above.
- Both the interpreter 44 (FIG. 3) and the translator 54 (FIG. 4) use the shadow stack 212 for determining the next instruction to be executed upon the processing of a return instruction.
- a check is made to determine whether the code that followed the native call in the translator routine was well behaved.
- the first is that the non-native code was well behaved with respect to the depth in the non-native return address stack 211.
- the second assumption is that the code was well behaved with respect to the return address. If both of these conditions are not satisfied then the code following the translated call cannot be executed and the instruction flow has to revert back to the interpreter for continuing execution until such time as it encounters another call or return instruction or possibly a computed jump instruction.
- the second check is to determine whether the return address stored in location 220b corresponds to the return address stored in the location in the non-native return address stack 211 pointed to by the value of the SP pointer 217.
- This check thus determines that the return address for the non-native instruction is the same in the non-native stack 211 as well as the shadow stack 212. If this condition is not satisfied then the interpreter changed the value of the return address. If either condition is not satisfied, then execution is continued in the run-time interpreter 44 until such time as another call or return or computed jump instruction is encountered.
- a call address translation table 222 is produced during translation of non-native code. As shown the call translation table 222 is appended to the translated code as in field 221.
- the translated code 221 and the call address translation table 222 provide the image 17c referred to in FIG. 3.
- the table 222 includes a pair fields one field 223acorresponds to addresses or more particularly to address offsets from the starting address of calls for translated code routines and the other field 223b corresponds to address offsets to the corresponding starting address in the non-native architecture.
- the table 222 is here appended to the end of the translated image 221 as mentioned above.
- shadow stack 212 as well as a call address translation table as mentioned above is illustrated.
- table look-ups and shadow stack manipulations are used in the run-time interpreter 44 or a run-time translation system as well as in the execution of translated code.
- Table look-ups are used for each instance of a call instruction by the interpreter 44 or for each instance of execution of translated code.
- the shadow stack 212 is used during the processing of return instructions for the interpreter 44 as well as during execution of calls in the translated code.
- path 256b During execution of translated code there are two possibilities resulting from execution of a return instruction (RET).
- RET return instruction
- path 256a The first possibility shown as path 256b is that the afore-mentioned test or check is passed and thus the return instruction can safely return and continue execution of translated code.
- path 256a The second possibility shown as path 256a is that if either one of the two checks fails, then execution returns to the possibly updated address in the non-native stack and execution continues or proceeds within the interpreter 44 until such time as a call, computed jump or a second return instruction is encountered.
- the interpreter when the interpreter is executing native code in emulation mode, the interpreter likewise performs a check.
- a first path 258a would be if 1here is no corresponding translated code available to be used by the interpreter.
- the second path 258b would be taken if the interpreter encounters a return address in which there is a valid corresponding translated routine.
- the shadow stack 212 permits the interpreter to return to execution of translated code without requiring any corruptive or invasive modification of the non-native return address stack 211.
- the interpreter 44 will perform a table look-up which, if there is a corresponding translated routine, will permit the translated code to execute via path 252b. Other-wise, the interpreter 44 will continue execution via path 252a. Similarly, the translated code when it performs a call 254 will determine if there is a corresponding translated routine for the call and, if so, will permit execution via path 254b. Otherwise, control will be transferred back to the interpreter via path 254a.
- the first advantage is that since the shadow stack 212 provides storage for native return addresses and other information required in the native system, it is not necessary to place this information on the non-native return address stack 211. Thus, the non-native return address stack 211 is not violated or remains true to that which would occur during normal execution of the non-native program in the non-native architecture.
- maintaining a true uninterrupted non-native stack 211 permits a non-native exception handler to execute without any complex manipulation to remove native return addresses. In general, when an exception occurs during execution of the native instructions the exception handler in the native architecture only expects to encounter native architecture instruction addresses. And similarly a non-native exception handler only expects to encounter non-native instruction addresses.
- the shadow stack 212 being accessible to both the translated code and the interpreter 44 permits the interpreter to return control back to translated code since the interpreter can use the shadow stack to determine a valid native return address which will continue execution of translated code. Without the shadow stack 212, therefore, it would be necessary either to place the native return addresses onto the non-native return stack which is undesirable as mentioned above or to make the unit of translation be limited to a basic block. As will be described below this latter option is undesirable since it limits the opportunities for optimization of the translated code. Further, by having a non-native stack 211 and shadow stack 212, non-native return addresses can be separately managed from the native return addresses. This permits exception handlers for each image to properly handle problems which caused an exception since the exception handlers do not have to deal with return addresses associated with foreign code.
- a translated routine 260 can have a call 260a which in turn has other calls 261a to 261c to other translated routines such as 262a. Also in a translated routine 264, the routine can encounter a switch/jump instruction 264a which is a computed branch or jump to another routine such as routines 265a to 265c. Management of the shadow stack 212 in conjunction with execution of translated code, execution in an original interpreter and activation of a new interpreter will now be described.
- the stack pointer address is set at 7FFFFFFF, the largest stack pointer possible, a value which will not be extended by an LDL instruction. This frame is needed for interpreter processing of return instructions.
- the shadow stack frame return address field 220c is set equal to 1 (a non-zero value) but is never used.
- the shadow dynamic link field 220d is set equal to 0 to indicate that this is the initial or sentinel frame on the shadow stack.
- the shadow stack extended instruction pointer is set to 0 and is never used.
- interpreter operation that is, while the interpreter is executing instructions, it does not follow the stack pointer for the shadow stack. Thus, it does not push or place shadow frame entries onto the shadow stack 212 even if the interpreter interprets non-native calls that modify the non-native return address stack 211. If the interpreter encounters a non-native instruction call that calls a non-native instruction routine that has been translated, however, then the interpreter stores the instruction program counter onto the non-native return address stack 211 as in normal operation and into the shadow stack 212. The interpreter 44 also performs a jump to the translated routine's interpreter entry point. The translated routine returns to the interpreter 44 by jumping through one of its entry points as will be described below.
- Every translated routine has two entry points. One entry point is called when the interpreter calls it and the other one is called when another translated routine calls it. The entry points only differ in the additional prologue or preparation that is performed when the routine is entered from another translated routine.
- a translated routine is entered from another translated routine, the following occurs: The register which contains the native return address is stored into the return address field in the shadow stack for the particular shadow frame header by executing an instruction
- This instruction is executed before the shadow stack 212 is extended so that the return address in the shadow stack 212 is always valid for all shadow frames 214 except the top one. This arrangement is required when the shadow frames 214 are discarded as a result of an exception or because execution had to resume in the interpreter. Next the execution falls through to the interpreter entry point.
- a shadow frame is produced for the translated routine.
- the size of the frame is 16 plus bytes where 16 is the number of bytes needed to represent the header and the additional number of bytes are those used to represent the local storage associated with the translated routine.
- the shadow frame header dylink field 220d is set to the original stack pointer. The following instructions are executed:
- the shadow stack frame is produced using the above sequence.
- the previous shadow stack frame is located and the contents of the dynamic link are evaluated.
- the native code determines whether the non-native stack pointer and the instruction pointer are the same as expected by the caller. That is, the native code determines that the value of SP is equal to the contents of SP in the stack pointer 17 and the value of IP is equal to the value of the return address stored at the location pointed to by the stack pointer 17.
- the translated routine can return control to the return address stored in the caller's shadow frame (i.e., return control to another translated routine). If either of these checks fail however, then either the call was from the interpreter or the non-native stack has been modified. In either case, execution is resumed in the interpreter after a potential clean-up of the shadow stack 212.
- the following instructions are used to perform the two checks:
- T0, T1, T2 and T3 are available registers in the native architecture which would not interfere with the state of registers in the non-native system.
- the non-native return address is loaded into a register and 1the register is pushed onto the non-native return stack 211 and the non-native stack pointer is loaded into the non-native stack pointer field in the shadow stack 212.
- a jump to subroutine instruction is executed to the translated routine entry point placing the native return address in a register.
- the translated routine executes until the routine returns to its caller.
- the translated routine may never return to its caller, for example, if the translated routine detects that the non-native stack 211 has been modified. In this case, if the non-native stack 21. has been modified the interpreter 44 will be entered to clean up the shadow stack 212 and resume execution as mentioned above. If, however, the translated routine does return to its caller, the translated routine will have left the non-native state valid including the non-native stack pointer and will also have left the shadow stack 212 valid insuring that it is in synchronization with the non-native stack 211. Thus, the called translated routine can continue executing.
- a translated routine calls a routine that has not been translated, it then enters the interpreter.
- the non-native return address is passed to a register in the interpreter 44 and the contents of the register are pushed onto the non-native return address stack 211. This corresponds to the non-native return address.
- the contents of the register are also loaded into the non-native extended instruction pointer field in the shadow stack 212.
- the extended stack pointer 217 which points to the non-native return address just pushed onto the non-native return stack is itself loaded into the non-native extended stack pointer field 20a in the shadow stack 212.
- the non-native address of the routine being called is then loaded into the non-native instruction pointer and a jump to subroutine instruction is executed to the interpreter entry point.
- a look-up call entry is performed placing the native return address in stack pointer 217.
- the interpreter stores the stack pointer 217 in the native return address field 220c of the shadow stack 212 and executes until the interpret
- a translated routine calls a jacketed routine, the following occurs.
- a jump to subroutine instruction to the jacketed routine entry point is performed placing the non-native return address in the non-native stack pointer 217.
- the jacketed routine produces a native frame and executes the native routine. Since only operating system supplied entry points are jacketed, these are known to be well-behaved and thus will not alter their return address. Therefore, the non-native stack pointer or the non-native instruction pointer in the shadow stack are not saved and there is no check performed on them before returning from the jacketed routine.
- the jacketed routine performs a call back, then another interpreter activation native frame will be produced and a separate shadow stack will be managed.
- the interpreter activation native frame will be removed together with the now empty shadow stack.
- the jacketed call returns, it will remove its native frame leaving the stack frame pointing again to the top shadow frame of the previous interpreter activation.
- the jacketed routine may never return to its caller. For example, an exception may occur that causes the call back interpreter to be exited and non-native frames discarded. This will cause the shadow stack 212 to be cleaned up. If, however, it does return to its caller the jacketed routine will have left the non-native state valid including the non-native stack pointer 217. It will also have left the shadow stack 212 valid insuring that it is in sync with the non-native stack 211. Therefore, the caller translated routine can continue executing.
- a translated routine can also enter the interpreter due to an unknown indirect jump. If translated code performs a jump to a target that is not statically known, for example, indirect jump to a target not listed in the profile information, then the translated routine is abandoned and execution continues in the interpreter 44.
- the interpreter also makes decisions as to whether it can return to translated code.
- the interpreter also checks when interpreting a return instruction that returning to a translated routine is valid.
- the interpreter saves the current value of the non-native stack pointer that points to the non-native return address on the non-native stack 211 and pops the non-native return address from the non-native stack 211 into the non-native instruction pointer. If a Return N instruction is being performed then it also pops N number of argument bytes from the non-native stack 211.
- the interpreter checks the value of the non-native stack pointer and the non-native instruction pointer to determine that they are the same as those stored in the shadow stack frame 214.
- control can be returned safely to the return address which is stored in the shadow stack 212 and execution of translated code can resume. If they are not the same, then the shadow stack 212 needs to be cleaned-up and control returned to the interpreter. If no translated code exists in the shadow stack, then the sentinel shadow stack frame ensures that control remains in the interpreter and there is no need to clean up the shadow stack.
- the interpreter clean-up shadow stack frame routine is invoked on re-entry from translated code when it is detected that the shadow stack 212 is out of synchronization with the non-native stack 211.
- the clean up shadow stack frame routine discards orphaned shadow stack frames 214.
- the approach is to discard shadow stack frames 214 until the value of the extended stack pointer stored in the non-native extended stack pointer field 220a is greater than the value of the extended stack pointer.
- Object oriented programming systems support the definition and use of "objects.”
- An object in such a system is a data structure combined with a set of “methods” or “functions” available to manipulate the data stored within that data structure.
- an example of an object 300 including a first interface, Interface 1 300A, a second interface, Interface 2 300B and a third interface, IUnknown 300C.
- the interfaces to the object are drawn as plug-in jacks. When a client wishes to use the object 300, it must do so through one of the interfaces shown. The actual contents of the object being manipulated can only be accessed through one of the interfaces provided for that object.
- Each of the interfaces 300a and 300b are also objects themselves.
- FIG. 28 there is shown an example of a client 301a (which can be another process running on the system 10 or another system such as in a networked system not shown) accessing an interface of an object 302c.
- FIG. 28 shows the client 301a calling an object interface of the object 302c.
- the client 301a obtains a pointer 301f to an interface 301c of an object proxy 301b.
- Information regarding the interfaces of an object is obtained through a query function defined or provided by the service architecture.
- the function QueryInterface in the OLE® (Object Linking and Embedding product of Microsoft Redmond Wash.) service architecture is used for this purpose.
- the present system supports operations on objects that are either in-process, local or remote with respect to the client.
- the address space of the client is the set of all possible addresses provided by the operating system to the process in which the client executes.
- An in-process object therefore is an object located within the same address space as the client.
- a local object is an object located on the same computer system as the client, but not in the same address space.
- a remote object is an object that is located on a different computer system than that which the client is located on.
- the object being referenced is local or remote to the client.
- the interface 301c is an in-process implementation of the desired interface as part of an in-process object proxy 301b.
- the in-process implementation referenced by the client is the object implementation of the interface itself.
- the call by the client to the desired object interface is a local call to the object implementation of the interface.
- the client process 301 communicates with a server process 302 by an inter-process communication facility, for example a remote procedure call facility 301e.
- a client 301a which uses an interface 301c to access an object proxy 301b.
- the object proxy is further shown having a second interface 301d.
- the server process 302 is shown including an object 302c and a stub routine 302a which accesses the object 302c through an interface 302d.
- the stub routine 302a processes client requests received via the inter-process communication facility.
- the stub routine 302a further executes a local procedure call within the server process 302 to the object interface 302d.
- the object 302c is also shown having an interface 302e.
- the interfaces 302d and 302e include object functions which are used by the client 301a to operate on the data included in the object 302c itself.
- the client 301a accesses the object interface 302d by referencing the object proxy 301b through the interface 301c.
- the object proxy 301b uses the remote procedure call function 301e to send a message to the stub routine 302a.
- the stub routine 302a uses object functions within the interface 302d to operate on the actual object within the server process 302b.
- the stub routine 302a sends the results of operations on the object 302c back to the object proxy 301b through the remote procedure call utility 301e.
- the object proxy 301b returns the results of the operations on the object 302c to the client 301a through the interface 301c.
- the object proxy 301b takes all the arguments to that function of the interface 301c, and packages them in a portable data structure.
- the stub routine 302a in the server process 302 maintains an interface pointer to the object 302c and receives the call through the remote procedure process 301e.
- Stub routine 302a pushes the arguments from the call onto the server process stack as needed and makes the call to the implementation of the function called by the client in the actual object 302c through the interface 302d.
- the stub routine 302a packages the return values and any out-parameters and sends them back to the object proxy 301b.
- the object proxy 301b then unpacks the information and returns it to the client 301a.
- execution engine is an implementation of a computer architecture on which code for that computer architecture may be executed.
- a first example of an execution engine is a hardware implementation, such as a microprocessor or CPU implementing the processor architecture for which the code was designed and developed.
- a second example of an execution engine is a software emulation of a processor architecture, referred to as a "simulator” or an “emulator”.
- non-native program code is translated by interpreter software at run-time into code that is executable on the underlying hardware system and then executed on the underlying hardware system.
- the client process 301 and the server process 302 may be executing on execution engines for dissimilar architectures.
- the client process 301 may be executing on the system 10 in native mode, while the server process 302 may be executing in the interpreter 44 (or other emulation environment), or vice versa.
- the interface structure 307 provides an implementation of each of a plurality of member functions through an array of pointers to the member functions.
- the array of function pointers is referred to as the "vtable” or “virtual function table”.
- a pointer 303 is shown pointing to an interface object 304.
- the interface object 304 includes a pointer 304a to an interface function table 305 and a private object data region 304b.
- the interface function table 305 is shown having pointers 305a through 305f to functions 1 through 6.
- the pointers 305a through 305f in interface function table 305 point to implementations of the interface functions 306.
- the number of pointers shown here six (6) is for purposes of example only, and other numbers of functions may be used for various specific interfaces.
- interface functions 306 may be for an architecture dissimilar to the architecture which the execution engine of the user or client of the object supports.
- the interface function table 305 is shared among all instances of an interface object.
- an object allocates according to the object's internal implementation a second structure that contains private object data 304b for each interface instance.
- the first four bytes of interface object 304 are a 32-bit pointer to the interface function table 305, followed by whatever private data 304b the interface object has.
- the pointer 303 to the interface object 304 is thus a pointer to a pointer to the interface function table 305.
- interface pointer 303 accesses the object implementation of the interface methods, also referred to herein as the "interface member functions”.
- the client may not access the interface object's private data 304b.
- the elements of FIG. 29 are an example of a structure that C++ compilers may generate for a C++ object instance.
- a client To access an interface to an object, and thus apply the interface functions to an object instance, a client must obtain a pointer to the interface, for example interface pointer 303.
- step 307 an object is entered into a system registry.
- the system registry may for example be part of the operating system (not shown) of the computer system on which the client is executing.
- Step 307 may occur for example either at run time or at system build time. If the entry is made at build time, then the object is known by the system registry prior to the client starting up. This is known as "static registration”. Where the object class is established at run time and is known locally to the client process this is known as "dynamic registration". For example, dynamic registration is accomplished by a call to a dynamic registration service function, as in the OLE service architecture by use of the CoRegisterClassObject function.
- step 309 if the registration from step 307 is static, the registry is searched based on a user input to obtain a class identifier ("ClassId"). For example, a user may provide an input through a graphical user interface (GUI) indicating to the system that the registry should be searched for information regarding a previously registered object class. If the registration from step 307 is dynamic, then the ClassId of the object class is known by the client as a result of a call to the dynamic registration service function for the service architecture.
- GUI graphical user interface
- a client may have information regarding the object class in question included in an "include file" within the client's implementation in step 308.
- this information may be a class identifier for a particular class of objects which the client wishes to instantiate and access at run time.
- Step 308 occurs at compile time.
- the output of steps 307 and 309, or alternatively step 308, is a class identifier 310.
- the class identifier 310 is used by the client to obtain an instance of an object for the client to use.
- Step 311 shows an example embodiment of the steps required to obtain an object instance.
- a pointer is obtained to an interface used to create instances of the object identified by the class identifier 310.
- an interface known as IClassFactory is used to obtain instances of an object.
- a pointer to IClassFactory is obtained by calling the OLE service OleGetClassObject in substep 311a.
- the interface to IClassFactory is then used to create an object instance of a particular class identified by the class identifier 310.
- substep 311b the client creates an instance of the object by invoking a function of the interface obtained in substep 311a.
- the function invoked is IClassFactory::CreateInstance.
- the output of substep 311b is a pointer to an interface.
- the interface pointer is shown as 312 in FIG. 30.
- the interface pointer obtained is a pointer to the IUnknown interface, which is required to be present in all OLE object interfaces.
- the client uses the interface pointer to learn and invoke object methods on the instance of the object created in step 311.
- a client in order to use an object a client first obtains a class identifier, either through a registration system, or through compile time information such as include files.
- the next step necessary for a client to use an object is for the client to create an object instance. Once the object instance is created, for example, in step 311, a pointer to an interface of the object is then available to the client.
- the interface pointer is necessary for the client to access the object, since an object may only be accessed through one of its interfaces.
- that interface pointer may be used to invoke object methods on the object instance in step 313.
- steps in an example embodiment of a method for intercepting functions in order to perform interface structure replacement are shown.
- the steps are performed to replace the interface structure shown in FIG. 29 with a replacement interface structure shown in FIG. 32.
- the steps of FIG. 31 further perform general function jacketing with respect to the intercepted function.
- the steps of FIG. 31 are performed by the jacketing routine 48 (FIG. 3).
- the jacketing routine 48 detects a function call having an interface object pointer as a parameter.
- the set of function calls having an interface object pointer as a parameter is determined prior to run time.
- the set of function calls having an interface object pointer as a parameter, and which therefore are detected by the jacketing routine 48 in step 320 include all OLE Application Programming Interface calls (OLE APIs) and all calls to OLE Standard Interface functions.
- OLE APIs OLE Application Programming Interface calls
- the names of the OLE APIs and OLE Standard Interface functions are determined and passed to the jacketing routine 48 prior to run time. For example the names of the function calls having an interface object pointer as a parameter are built into the jacketing routine 48, for example at compile time through an include file.
- the names and descriptions of functions having an interface object pointer as a parameter may be determined from documentation available from the manufacturer, dealer or developer of the object based service architecture.
- the run time addresses of these functions are made available to the jacketing routine 48 and the jacketing routine 48 is invoked upon any transfer of control to one of these functions in step 320.
- function calls detected by the jacketing routine 48 in step 320 are those functions in the object service architecture which enter an object class into a system registry, functions which search the system registry and return a ClassId of an object class, or functions which create an object instance. These functions include those shown in FIG. 30 as 307, 309, and 311 respectively. Thus in step 320 functions which have an interface object pointer as a parameter are detected so that interface structure replacement can be performed. If a function call is intercepted in step 320 which does not take an interface object pointer as a parameter, no interface structure needs to be replaced and therefore no replacement is performed by the jacketing routine 48.
- the jacketing routine 48 determines how the interface object pointer parameter is used by the function call detected in step 320. The exact usage of the interface object pointer parameter for each function having an interface object pointer parameter is determined prior to run time and incorporated into the jacketing routine 48.
- the jacketing routine 48 may include a list of argument templates describing the format and use of arguments in the function calls intercepted in step 320. Such argument templates may for example be developed a priori from information regarding the function calls intercepted in step 320 contained in documentation or source code from the manufacturer, dealer or developer of the object based service architecture.
- the argument templates are developed at run time based on information obtained regarding the function calls intercepted in step 320 from a type information service provided by the object service architecture.
- each argument template describes whether the interface object pointer is an "input-only”, "input-output”, or "output-only” parameter.
- An input-only parameter is passed to the function, but is not modified or passed back from the function.
- An input-output parameter is passed to the function and replaced or modified before the function completes.
- an output-only parameter is written or passed back from the function call without regard to its input value.
- the jacketing routine determines whether the interface pointer parameter is input-only, input-output, or output-only, based on information in the argument template for the intercepted function.
- step 323 the jacketing routine 48 branches to step 324 if the interface pointer parameter is input-only or input-output. If the interface pointer parameter is not input-only or input-output, step 323 is followed by step 326. In step 324 the interface structure indicated by the interface pointer parameter is replaced with the replacement interface structure shown in FIG. 32.
- step 326 the original function detected in step 320 is called by the jacketing routine 48.
- general function jacketing is performed by the jacketing routine 48. General function jacketing is described in FIG. 40.
- the jacketing routine 48 branches to step 329 if the interface object pointer parameter was either output-only or input-output. If the interface object pointer parameter was not output only or input-output, then the jacket function 48 is done for this intercepted function after step 328. In step 329 the jacketing routine 48 replaces the interface structure of the interface pointed to by the interface object pointer parameter with the replacement interface structure shown in FIG. 32.
- FIG. 32 an example embodiment of the replacement interface structure provided by the jacketing routine 48 as described in steps 324 and 329 in FIG. 31 is shown.
- the example shown in FIG. 32 includes an interface pointer 334, pointing to the top of an interface object 336.
- the interface object 336 includes a pointer 336a to an interface function table, as well as private object data 336b.
- the pointer 336a points to the first of one or more jacket functions, for example 338d, within a replacement interface function table 338.
- the replacement interface function table 338 includes a pointer to the original function table 338a, a signature 338b indicating the processor architecture for which the object was originally created, an area 338c reserved for use by a system wide remote procedure call utility, a pointer 338d to a jacket function for function 1 in the original interface function table, and pointers 338e through 338h to jacket functions for other functions in the original interface function table.
- the pointer 338a to the original interface function table points to the top of the original interface function table shown as 340.
- the original interface function table contains pointers 340a through 340h to the object implementation of the interface functions 342.
- the replacement interface structure shown in FIG. 32 is used to replace the original interface structure based on the function interception described in connection with FIGS. 31, 38 and 39. Subsequent to replacement with the replacement interface structure, clients executing in a first architecture (Architecture A), for example system 10 on which the code is being executed, may invoke functions for objects implemented in a second architecture (Architecture B), for example non-native code. Similarly, non-native code may invoke functions for objects created in native code.
- the replacement interface structure shown in FIG. 32 allows for multi-code operation of object methods that is transparent to the user.
- the replacement interface structure signatures in the Interface Signatures Table are shown eLs character strings for purposes of example, and other encodings are possible.
- the left most column indicates the architecture of the execution engine from which an interface is referenced.
- the middle column shows the signature of the replacement interface function table for that interface.
- the signature in the middle column indicates the functionality of jacket functions pointed to by the replacement interface function table.
- the right most column indicates the processor architecture for which the interface and its object functions was originally created.
- the present system determines the processor architecture for which the interface was originally designed as follows: When a call is intercepted to a function having a parameter equal to a pointer to an interface object, the intercepting process of the present invention, for example the jacketing routine 48, determines whether the interface structure has already been replaced. This determination is made by checking the signature field in the interface structure. If the signature field contains either the string PAJB or PBJA, then the interface structure has been replaced, and no further replacement is performed.
- a replacement is performed.
- the replacing process determines the signature of the replacement interface structure based on the processor architecture of the execution engine from which the call having a parameter equal to an interface object pointer was made. If the call was made from an execution engine for Architecture A, and no replacement has previously been made, then the object interface functions were designed and developed for use on the execution engine for Architecture A. This follows because an object instance must initially be created in order for operations to be performed on object data within the instance, and object creation involves use of functions that are intercepted by the present system.
- the first two rows in the Interface Signatures Table show the case in which the processor architecture for which the interface was originally created is Architecture A.
- the middle column entries in those rows indicate that when a replacement interface function table is provided for an interface that was designed for Architecture A, the signature string for that replacement interface function table is "PAJB".
- the jacketing routine 48 in FIG. 3 writes a signature code of "PAJB" into the signature field of a replacement function table provided as described in steps 324 and 329 in FIG. 31.
- the signature code indicates the functionality of the jacket functions pointed to by the replacement interface function table. If the signature code in a replacement interface table is "PAJB" then if a subsequent reference is made to the interface object from code executing in an execution engine for Architecture B (as in the first row of the table), the call to the original interface function is jacketed (through general function jacketing) by the jacket function. If the reference to the object is made from code executing under the execution engine for Architecture A (as in the second row), then the original interface function is passed through to the execution engine for the code making the reference. Passing the original interface function through permits it to execute at maximum speed without general function jacketing overhead.
- PAJB is an acronym standing for "Pass Through A--Jacket B".
- the replacement interface signature is PBJA, an acronym for "Pass Through B, Jacket A".
- This interface signature is included in a replacement interface function table when the code environment the interface was designed for is Architecture B. If the interface is subsequently referenced by code executing on an Architecture B execution engine (as in the case shown by row three), then the jacket functions pointed to by entries in the replacement interface function table pass through the original function to the Architecture B execution engine in order that it may execute at maximum speed without unnecessary general function jacketing. If the interface is referenced from an Architecture A execution engine (as in row four), then the jacket function performs general function jacketing on the call to the original interface function in order that the original interface function may execute correctly.
- FIG. 33 there is shown an example design template for a jacket function.
- a pointer 350 to a jacket function is shown, corresponding to the pointers shown in FIG. 32 as elements 338d through 338h.
- the pointer 350 points to the entry point label From -- Table 352.
- Two other entry point labels are shown, specifically ARCHB 355 and 354 ARCHA.
- Multi-architecture instruction 353 (Instruction X) which is executable by execution engines for both Architecture A and Architecture B.
- the binary value of the multi-architecture instruction INSTX 353 is 0 ⁇ 23FFxxEB. In an Alpha system this binary value defines the following Alpha instruction:
- This "LOAD ADDRESS" instruction consumes 4 bytes and is an operation which has no effect (referred to as a "NO-OP") because it writes ("loads") register 31 generates no exceptions, and does not access memory.
- NO-OP no effect
- register 31 is hardwired to zero, and writes to register 31 have no effect. Accordingly the value of the bytes "xx" are not relevant when the instruction executed by the Alpha execution engine.
- the multi-architecture instruction INSTX 353 has no effect on the value of register 31, which is always zero. Control passes to the next instruction following the multi-architecture instruction INSTX 353 at the entry point label ARCHA 354.
- ARCHB is a predetermined byte offset for the "JUMP IMMEDIATE BYTE" instruction having opcode EB (hex).
- the predetermined byte offset is calculated to result in a jump to the entry point ARCHB.
- the instruction INSTX 353 When the instruction INSTX 353 is executed by an Architecture B (Intel) execution engine, it is an unconditional branch immediate instruction causing a branch of control to an instruction located at an offset from the current instruction address.
- the byte displacement for the branch is found in the next to lowest byte, and is shown for purposes of example as the "xx" bytes. Therefore the value of the "xx" bytes is made equal to the offset of the entry point ARCHB 355.
- the entry point ARCHB 355 is thus "xx" bytes lower (if the offset is negative), or "xx" higher (if the offset is positive) than the multi-architecture instruction 353.
- control After the multi-architecture instruction 353 is executed by the Architecture B execution engine, control is passed to the instruction located at the ARCHB entry point 355.
- the multi-architecture instruction Instruction X is one which generates an exception when executed by either the Architecture A or Architecture B execution engine.
- Instruction X may be an instruction which causes an access violation by attempting to access an out of bounds memory location.
- Instruction X may be a binary value containing an illegal instruction resulting in an illegal instruction exception.
- the exception handler(s) for the exception generated by Instruction X determines that the cause of the exception was attempted execution of Instruction X. The exception handler then determines which execution engine was executing at the time of the instruction. If the execution engine was for Architecture A, then the exception handler transfers control to the entry point ARCHA. If the execution engine was for Architecture B, then the exception handler transfers control to the entry point ARCHB.
- FIG. 34 shows steps performed by the code in a PBJA jacket function at the entry point ARCHB shown as element 355 in FIG. 33.
- the steps of FIG. 33 "pass through" the original call to the execution engine of the caller without performing general function jacketing.
- the code begins at the entry point ARCHB.
- the jacket function is therefore being called from code executing on an Architecture B execution engine.
- the processor architecture of the caller may be determined using a multi-architecture instruction as shown in FIG. 33.
- step 357 the jacket function determines whether the original function being called is one that takes an interface object pointer as either an input-only or input-output parameter (as in steps 320 through 323 in FIG. 31). This determination is made for example based on a predetermined list of functions which take an interface object pointer as a parameter, as well as associated argument templates for each of the listed functions describing how the arguments to the function are used.
- the argument template may be obtained at run time from an object type information service provided by the object based service architecture.
- the jacket function determines whether the signature field of the interface structure contains either PBJA or PAJB. If the signature field of the interface structure does not contain either PBJA or PAJB then the interface structure has not been replaced and replacement is performed. Accordingly if replacement is performed step 357 is followed by step 358. Otherwise, step 357 is followed by step 359. In step 358 the interface structure of the interface object pointer parameter is replaced with a PBJA replacement interface structure as shown in X+5.
- the signature is PBJA because the code making the reference is executing on the Architecture B execution engine, and therefore the interface was designed for execution on an Architecture B execution engine.
- step 359 the jacket function reads the pointer to the original function from the original function table.
- a pointer to the original function table is contained in the replacement interface function table.
- step 360 the jacket function calls the original function. No general function jacketing is performed in step 360.
- the jacket function determines whether there is an interface object pointer parameter to the original function that is either an output-only or input-output parameter (as in step 328 in FIG. 31). This determination is made for example based on a predetermined list of object methods or functions which take an interface object pointer as a parameter, as well as associated argument templates for each of the listed functions describing how the arguments to the function are used. For example where the object based service architecture for the system is OLE, then the list of OLE Standard Interface functions is used to construct the predetermined list of object methods having an interface object pointer as a parameter.
- the argument template may be obtained at run time from an object type information service provided by the object based service architecture.
- the jacket function determines whether the signature field of the interface structure contains either PBJA or PAJB. If the signature field of the interface structure contains either PBJA or PAJB then the interface structure has not been replaced and replacement is performed. Accordingly, if replacement is performed then step 361 is followed by step 362 in which the interface structure for the interface object pointer parameter is replaced by a PBJA replacement interface structure. Otherwise, step 361 is followed by step 363 which returns to the original caller.
- FIG. 35 shows the steps performed by a jacket function pointed to by a pointer in a replacement interface function table, where the replacement interface function table signature field value is "PBJA.” The steps are performed by software following the entry point ARCHA: as shown in FIG. 33.
- the software performs general function jacketing.
- General function jacketing is further described in connection with step 326 in FIG. 31 above.
- the label ARCHA: is shown as element 366 in FIG. 35.
- Step 368 the jacket function determines whether it is necessary to perform interface structure replacement.
- Step 368 determines whether interface structure replacement is necessary by determining whether any of the parameters to the function associated with the jacket function are pointers to interface objects, and are either input-only or input-output. This determination is made for example based on a predetermined list of standard interface functions which take an interface object pointer as a parameter, as well as associated argument templates for each of the listed functions describing how the arguments to the function are used.
- An example of the predetermined list of standard interface functions would include the OLE Standard Interface functions.
- the argument template may be obtained at run time from an object type information service provided by the object based service architecture.
- the jacket function determines whether the signature field of the interface structure contains either PBJA or PAJB. If the signature field of the interface structure does not contain either PBJA or PAJB then the interface structure has not been replaced and replacement is performed. Accordingly if replacement is performed step 368 is followed by step 369.
- step 369 the PBJA jacket function performs interface structure replacement, replacing the interface structure of the interface object pointed to the by the interface object pointer parameter with a replacement interface object structure as shown in FIG. 32, and having a signature value equal to "PAJB".
- the signature value is PAJB because the code referencing the interface was executing on an Architecture A execution engine.
- step 370 the PBJA jacket function reads the function pointer of the original function from the original function table.
- the original function table is accessed through a pointer to the original function table in the replacement interface function table.
- step 371 the PBJA jacket function calls and performs general function jacketing on the original function.
- the PBJA jacket function determines whether interface structure replacement is necessary as to any of the output parameters of the original function. Interface structure replacement is necessary for any interface object pointer parameters to the function that are output-only or input-output. This determination is made for example based on a predetermined list of standard interface functions which take an interface object pointer as a parameter, as well as associated argument templates for each of the listed functions describing how the arguments to the function are used.
- the argument template may be obtained at run time from an object type information service provided by the object based service architecture.
- the jacket function determines whether the signature field of the interface structure contains either PBJA or PAJB. If the signature field of the interface structure contains either PBJA or PAJB then the interface structure has not been replaced and replacement must be performed. Accordingly, if replacement must be performed then step 372 is followed by step 373. Otherwise step 372 is followed by Step 375.
- the PBJA jacket function performs interface structure replacement by replacing the interface structure of the object pointed to by the output interface object pointer parameter to the function with the replacement interface structure shown in FIG. 33, and including the signature "PBJA" into the signature field of the replacement interface function table.
- the signature is PBJA because the interface was returned (output) from an execution engine for Architecture B in step 371.
- control is passed to the original caller of the function.
- FIG. 36 shows the steps performed by a jacket function in a "PAJB" replacement interface structure.
- the steps are performed by software in a jacket function following the entry point ARCHA: as shown in FIG. 34.
- the entry point ARCHA: 380 is followed by step 381.
- PAJB jacket function determines whether interface structure replacement is necessary.
- Interface structure replacement is determined to be necessary at step 381 if the original function takes an interface object pointer as an input-only or input-output parameter. This determination is made for example based on a predetermined list of standard interface functions which take an interface object pointer as a parameter, as well as associated argument templates for each of the listed functions describing how the arguments to the function are used.
- the argument template may be obtained at run time from an object type information service provided by the object based service architecture.
- the jacket function determines whether the signature field of the interface structure contains either PBJA or PAJB. If the signature field of the interface structure does not contain either PBJA or PAJB then the interface structure has not been replaced and replacement is performed. If interface structure replacement is determined to be necessary in step 381, step 381 is followed by step 382. Otherwise step 381 is followed by step 383.
- the PAJB jacket function performs interface structure replacement by replacing the interface structure for the interface object pointer parameter with a replacement interface structure as shown in FIG. 32 having signature field value equal to "PAJB".
- the signature is PAJB because the interface was referenced from code executing on an Architecture A execution engine and the interface was determined to not have been previously replaced by examination of the signature field.
- the PAJB jacket function reads the function pointer to the original function from the original function table.
- the original function table is located through a pointer to the original function table contained in the replacement interface function table.
- step 384 the PAJB jacket function calls the original function. No general function jacketing is performed in step 384.
- the original function executes on the Architecture A execution engine.
- step 385 the PAJB jacket function determines whether interface structure replacement is necessary following the return of the call to the original function.
- the determination of step 385 is made by checking to see if the original function had an interface object pointer parameter that was either output-only or input-output. This determination is made for example based on a predetermined list of standard interface functions which take an interface object pointer as a parameter, as well as associated argument templates for each of the listed functions describing how the arguments to the function are used.
- the argument template may be obtained at run time from an object type information service provided by the object based service architecture.
- the jacket function determines whether the signature field of the interface structure contains either PBJA or PAJB. If the signature field of the interface structure contains either PBJA or PAJB then the interface structure has not been replaced and replacement must be performed. Accordingly, if replacement must be performed then step 385 is followed by step 386. Otherwise, step 385 is followed by a return 387 to the original caller.
- Step 386 the PAJB jacket function performs interface structure replacement by replacing the interface structure for the output interface object pointer parameter with a replacement interface structure as shown in FIG. 32 having a signature field value equal to "PAJB".
- the signature is PAJB because the interface had not been replaced and the code returning (outputting) the object pointer was executing on an Architecture A execution engine.
- FIG. 37 shows the steps of the code executed by a jacket function in a replacement interface structure having a signature field value equal to "PAJB", when a function in the interface is called from code executing under an execution engine for Architecture B.
- FIG. 37 includes steps performed by software stored following entry point ARCHB:.
- the PAJB jacket function determines whether interface structure replacement is necessary.
- the PAJB jacket function makes this determination by determining whether the originally called function includes a parameter that is an interface object pointer which is either an input-only or in-out parameter. This determination is made for example based on a predetermined list of standard functions which take an interface object pointer as a parameter, as well as associated argument templates for each of the listed functions describing how the arguments to the function are used.
- the argument template may be obtained at run time from an object type information service provided by the object based service architecture.
- the jacket function determines whether the signature field of the interface structure contains either PBJA or PAJB. If the signature field of the interface structure does not contain either PBJA or PAJB then the interface structure has not been replaced and replacement must be performed. Accordingly if replacement must be performed step 392 is followed by step 393. Otherwise step 392 is followed by step 394.
- step 393 the PAJB jacket function performs interface structure replacement by replacing the interface object structure pointed to by the interface object pointer parameter with a replacement interface structure as shown in FIG. 32 and having a signature field value equal to "PBJA".
- the signature is PBJA because the interface had not been replaced and the code making the reference to the interface was executing under the Architecture B execution engine.
- step 394 the PAJB jacket function obtains the function pointer to the original function from the original function table.
- the original function table is accessible to the PAJB jacket function through a pointer to the original function table found in the replacement function table.
- step 395 the PAJB jacket function performs general function jacketing and calls the original function for the interface.
- step 396 the PAJB jacket function determines whether interface structure replacement is necessary after the return of the original function. If the original function took as a parameter an interface object pointer that was either an output-only or input-output parameter, then interface structure replacement is necessary. This determination is made for example based on a predetermined list of standard interface functions which take an interface object pointer as a parameter, as well as associated argument templates for each of the listed functions describing how the arguments to the function are used. In an alternative embodiment, the argument template may be obtained at run time from an object type information service provided by the object based service architecture.
- the jacket function determines whether the signature field of the interface structure contains either PBJA or PAJB. If the signature field of the interface structure does not contain either PBJA or PAJB then the interface structure has not been replaced and replacement must be performed. Accordingly if replacement must be performed step 396 is followed by step 397. Otherwise step 396 is followed by step 399.
- Step 397 the PAJB jacket function performs interface structure replacement by replacing the interface structure for the interface pointed to by the interface object pointer parameter with a replacement interface structure as shown in FIG. 32 and having a signature field value equal to "PAJB".
- the signature is determined to be PAJB because the pointer to the interface object was returned (output) from the Architecture A execution engine.
- the system includes a loader 405 having inputs of a load address 400a, a predetermined function set 401, an address of a jacketing routine 402, and a code image to be loaded 403.
- the load address 400a is a location in memory where the code image is to be loaded.
- the function set 401 is a list of functions which take an interface object pointer as a parameter.
- the list 401 may be in symbolic or binary address form.
- the jacketing routine address 402 is for example an address of the program code implementing the jacketing routine 48 as shown in FIG. 3.
- the code image 403 is for example a non-native code image developed for an Architecture B, and including an import table 404.
- the import table 404 includes a list of functions or routines which are invoked from the image 403, but which are not implemented within the image 403.
- the loader 405 creates a loaded image 406 beginning at the load address 405 in memory.
- the loader 405 replaces the call address of all calls to functions contained within the function set 401 with a pointer 407 to the replacement code 408.
- the call addresses of functions contained in the function set 401 are for example contained within the import table 404.
- the replacement code 408 invokes a Native -- Call routine which is developed to execute under the Architecture B execution engine, and which passes control to an Architecture A execution engine.
- the Native -- Call routine further retrieves the Jacketing -- Routine -- Address 410 (from input jacketing routine address 402) and invokes the jacketing routine to execute on the Architecture A execution engine.
- the loaded image 406 is provided by the loader 405 such that each call to a function within the function set 401 is replaced with a call to Native -- Call, which in turn invokes the jacketing routine.
- FIG. 39 shows an example of steps performed at run time to support interception of functions known to take a pointer to an object.
- a loaded image such as for example shown as element 406 in FIG. 38, reaches a point in it execution where a call had originally been placed to a function taking a pointer to an object. Since the image is an Architecture B image, it is executing on an Architecture B execution engine at step 411.
- the original call was replaced at load time with a call to Native -- Call, followed by the Jacketing -- Routine -- Address as shown in replacement code 408 in FIG. 38.
- the Native -- Call routine is called and executed on the Architecture B execution engine.
- the Native -- Call routine gets the Jacketing -- Routine -- Address, and invokes the jacketing routine to run on the Architecture A execution engine.
- the jacketing routine is developed in native code, and accordingly executes advantageously fast on the hardware implemented Architecture A execution engine.
- the jacketing routine executes, for example performing the steps described in relation to FIG. 31.
- a Native -- Return routine is called, which returns control to the Architecture B execution engine at the return address following the Jacketing -- Routine -- Address in the loaded image.
- execution thus resumes on the Architecture B execution engine at the return address in the loaded image.
- FIG. 40 shows the steps performed to accomplish general function jacketing.
- argument conversion is performed.
- the arguments to the original function are converted and/or reordered to compensate for differences between the calling and argument conventions of the processor architecture of the execution engine from which the object function is being called and the architecture for which the original object function was designed. Call back addresses are also modified as necessary.
- the caller is executing on an Architecture A execution engine, and the called function is developed for Architecture B, and where Architecture A is the Alpha architecture, and Architecture B is an X86 architecture, the caller has placed the arguments into argument registers as is required by the ALPHA architecture.
- the X86 architecture requires arguments to be passed on the stack. Therefore during 415 in this case the arguments are moved from the registers of the Architecture A execution engine onto the Architecture B execution engine stack for processing by the Architecture B execution engine.
- step 415 floating point arguments are converted into the representation for Architecture B in step 415.
- Other example functionality for step 415 includes byte swapping where there is a different byte ordering required by Architecture A with respect to Architecture B.
- the original function is called on the execution engine for which it was developed.
- the address of the original function is passed to the Architecture B execution engine.
- Control is passed to the Architecture B execution engine at step 416 to execute the original function.
- step 417 result conversion is performed.
- the jacketing routine accommodates differences in return argument or result conventions between the calling architecture and the architecture on which the original object function was executed.
- the background optimizer 58 performs optimizations using a binary image as input. Generally, the optimizations reduce execution time and reduce system resource requirements. Optimizations are typically classified into the following four levels: peephole optimizations, basic block optimizations, procedural or global optimizations, and interprocedural optimizations. The number of assumptions regarding program structure generally increases with each level of optimization, peephole optimization assuming the least and interprocedural optimizations assuming the most regarding program structure.
- a peephole optimization uses a window of several instructions and tries to substitute a more optimal sequence of equivalent instructions.
- a basic block optimization is performed within a basic block of instructions.
- a basic block is a group of instructions in which the first instruction is an entry point to the basic block, the last instruction is an exit point of the basic block with a guarantee that no instruction between the first and last instructions is itself a control transfer.
- a procedural or global optimization is performed upon a group of instructions forming a procedure or routine.
- An interprocedural optimization is performed amongst or between procedures.
- a method for a procedural optimization assumes that a called routine is entered via a call instruction.
- the code corresponding to the called routine is executed via a routine call made from another routine to the called routine using a standard routine linkage, as typically defined in a calling standard.
- the called routine includes a beginning sequence of prologue instructions executed prior to the code comprising the routine body.
- a basic unit of translation analogous to a routine using image information available to the background optimizer is determined.
- the image information may include information comprising the binary image itself, and information ascertainable from the binary image and its execution.
- One problem is determining the general characteristics or parameters that define the basic unit of translation. Another problem is, given a binary image, determining an efficient method to collect or obtain values for the parameters. The values are used to determine basic units of translation comprising the binary image upon which procedural and interprocedural optimizations can be performed.
- the translation unit determiner 500 derives a unit of translation that is similar to the traditional notion of a routine.
- execution or run-time information is gathered by the run-time interpreter 44. Specifically, the run-time interpreter gathers execution information stored as profile statistics 17c while interpreting code.
- the optimizer or translator forms a unit of translation by determining a portion of the executed code that is analogous to a routine using the profile statistics 17c.
- the optimizer or translator can perform traditional procedural and interprocedural optimizations, such as register allocation, upon the portion of non-native executed code that is analogous to a routine.
- the optimizations are performed during the translation of non-native code to native code by the background system 34.
- the steps of FIG. 41 can be performed by a translator, an optimizer, or a combined unit performing the functional steps typically employed by both an optimizer and a translator depending on the particular implementation of the binary translation system. As will be discussed in the ordering of the steps comprising translation and/or optimization vary and affect whether the steps of FIG. 41 are performed by a translator, an optimizer, or a combined unit.
- Profile statistics include execution information about a non-native image executed in the run-time system 32. Typically, profile statistics are stored by and associated with each binary image.
- the run-time system 32 notifies the server 36 as to the location of the profile statistics 17b, for example in a particular file stored on disk, so that the server communicates the profile statistics to the background optimizer 58 included in the background system 34.
- the run-time interpreter classifies non-native machine instructions which are executed into two general classes based on execution flow control.
- the first class of instructions is a straight-line execution class and includes instructions that do not alter the flow of execution control.
- the next instruction executed is stored at a second memory address contiguously following the first instructions.
- An example is an ⁇ add ⁇ instruction or an instruction which loads a register with the contents stored at a memory address.
- the second class of instructions is a flow-alteration class and includes instructions that, either conditionally or unconditionally, alter the flow of execution control.
- Typical machine instructions included in the second class are conditional and unconditional branch instructions, and jump instructions.
- the interpreter gathers run-time information about instructions comprising the second class. The run-time information is stored as profile statistics in disk segment 17c by the run-time interpreter.
- An assumed property of a routine is that the code corresponding to the routine is entered via a routine call.
- One method of forming a unit of translation analogous to a routine uses a target address to which control is transferred upon execution of a routine CALL.
- the profile execution statistics gathered by the run-time interpreter include the target address to which control is transferred by a routine CALL, for example, from another code section.
- Detecting a transfer of control that is a routine CALL generally includes detecting the occurrence of a particular instruction that transfers control to another instruction and belongs to the flow-alteration class.
- a routine CALL is detected by the run-time system.
- a calling standard defines a routine CALL to include a series of three (3) machine instructions to load a register with a target address and subsequently transfer control to the target address.
- the last machine instruction in the series of instructions is an indirect jump instruction, such as "JMP @R27", belonging to the flow-alteration class. Instructions prior to the jump instruction load a general register, "R27", with the target address.
- the jump instruction, "JMP @R27” then uses the contents of the register to obtain the target address.
- the jump is "indirect” in that the register "R27" is not the target address. Rather, the register is a pointer in that the register contains the target address.
- the "JMP @R27” instruction is a flow-alteration instruction comprising the CALL and is detected by the run-time interpreter.
- the target address of the last machine instruction, e.g., "JMP @R27” is stored as an execution or run-time profile statistic 17c.
- the step of forming a translation unit 501b (FIG. 41) in the translation unit determiner 500 operates over the binary image to provide one or more translation units.
- determining a translation unit analogous to a routine begins by using a target address of a routine CALL as a starting point or entry point.
- the CALL entry point is read from the profile statistics 17c previously recorded by the run-time interpreter.
- the CALL entry point (also referred to as "entry point")is analogous to a routine entry point.
- a determination is made, as in step 504, as to whether there are any remaining CALL entry points. If there is a remaining CALL entry point, the execution control flow or flow path is traced, as in step 505.
- a flow path is a series of instructions that can be executed by the CPU depending on the evaluation of various run-time conditions affecting the evaluation.
- a flow path originates from the CALL entry point.
- the flow paths originating from the CALL entry point are traced by examining machine instructions beginning with the instruction located at the CALL starting point or entry point.
- an instruction transfers execution control to one or more target locations depending upon run-time conditions and values, the execution flow is also traced for each of these target locations.
- step 506 For all execution or flow paths originating from the entry point, bounded "regions" of code within the binary image associated with the current translation unit are determined, as in step 506. A translation unit is formed for each CALL entry point, until, at step 504, it is determined that all entry points have been processed. Subsequently, at step 507, translation units are merged, as needed, to form another combined translation unit.
- a translation unit comprises one or more unique regions of code.
- a region is defined as sequence of one or more machine instructions stored at consecutive non-native memory addresses. There are no "holes” or “breaks” in the memory area occupied by the machine instructions or code comprising a region. Parameters that characterize a region include, for example, a starting and an ending address representing the boundaries of the code associated with a region. Regions, translation units, and the interrelations between them will be discussed throughout in the following text.
- flow path determination commences by obtaining an entry point address that is a CALL target address from the profile statistics 17c.
- the current instruction located at the current address is examined, as in step 510, to determine if it transfers control to another address altering the current straight-line execution.
- a determination is made as to whether the current instruction belongs to the first or second aforementioned class of instructions.
- the instruction is also referred to as a transfer instruction.
- the transfer instruction is classified, at step 512, as either i) an indirect or computed transfer of control, or ii) a direct or program-counter relative (PC-relative) transfer of control.
- PC-relative program-counter relative
- An indirect transfer of control uses a dynamic run-time value to determine, as in step 514, its target address or addresses.
- a computed jump instruction such as "JMP @R5"
- the target address is determined at run-time using the value stored in the register "R5"when the jump "JMP" instruction is executed.
- the possible targets are determined using dynamic run-time information which typically changes with each execution of the jump instruction.
- Such dynamic information is included in the profile statistics 17c and is recorded by the run-time interpreter to determine the possible target(s) of the jump instruction. A method for determining the possible target locations is discussed in more detail in conjunction with FIG. 42A.
- the possible target location or locations can be determined, as in step 514, using offsets relative to the current instruction.
- the offset is included in the binary image and additional run-time information, such as with an indirect transfer of control, is not needed to determine the target locations.
- These targets are added to a cumulative work list of targets having flow paths to be traced. For example, a conditional branch instruction branches to a first address if a condition is true. If the condition is not true, the next consecutive instruction is executed. The first address is calculated by adding a fixed offset to the current program counter. The current program counter identifies a memory address of the current instruction.
- An example of a fixed offset is a byte offset encoded in the binary image at or near the current branch instruction.
- all possible targets can be determined using the current program counter (PC) and the offset included in the binary image.
- the possible target addresses in the foregoing example are the first address and the address of the next instruction consecutive to the current branch instruction.
- Each memory address to which control can be transferred is a target address (also referred to as "target” or “transfer location”). If there are multiple possible target or transfer locations, each execution path associated with each target is traced one at a time. As in step 516, the background optimizer 58 chooses one of the possible targets and continues tracing that branch of the flow path.
- Consecutive instructions in each flow path are sequentially examined until it is determined, as in step 518, that the current instruction is the last instruction in the current flow path, i.e., terminates the current flow path.
- a flow path terminates when one of several conditions is detected.
- a routine RETURN is detected, a flow path terminates.
- a routine RETURN is similar to a routine CALL in that it is typically dependent upon a machine instruction set defined for a particular computer system architecture. For example, a routine RETURN includes a particular machine instruction which terminates tracing of the current flow path branch.
- a flow path also terminates, as in step 518, when there is insufficient run-time execution information to enable tracing to continue.
- the current flow path terminates when the current instruction is an indirect transfer instruction having an indirect target for which no run-time information has been obtained. Steps 514 and 516 have just been executed and resulted in no targets being determined and, therefore, no target selected. For example, an instruction is classified as an indirect transfer of control which uses run-time information to determine the possible target(s).
- the run-time interpreter 44 records the various target addresses for the indirect transfer of control. However, if the instruction that accomplishes the indirect transfer of control is not executed, the run-time interpreter 44 is unable to determine and record associated run-time information in the profile statistics.
- the background optimizer terminates tracing the current execution path because it has insufficient run-time information, i.e., a null target.
- step 518 Upon determining in step 518 that the current flow path is terminates, another flow path or branch flow path is selected, at step 520, for example a branch flow path associated with another target determined at step 514 is selected from the work list.
- step 521 a determination is made as to whether there are any remaining instructions to be examined, i.e., whether all flow paths or branches thereof have terminated. If there are no remaining instructions determined in step 521, tracing flow paths for the current translation unit terminates. If at step 521 there are remaining instructions, another instruction is examined by advancing to the next instruction at step 522.
- the method of FIG. 42 determines all possible flow path extensions or branches originating from a main flow path with the currently selected CALL entry point. Each branch of the flow path associated with each target of transfer of control within a translation unit is traced until the branch terminates.
- step 514 of FIG. 42 uses run-time information stored as profile statistics 17c by the run-time interpreter.
- the profile statistics include, for an indirect transfer instruction stored at a non-native address, all target addresses to which control is transferred via the indirect transfer instruction.
- the non-native address of the transfer instruction is used to determine a hash key corresponding to the record entry in the hash table containing the non-native address and the associated target addresses.
- entries comprising the profile statistics 17c are searched to locate a record entry corresponding to a first non-native address of a current instruction, for which targets are being determined at step 514.
- the precise method of searching performed at step 524 is dependent upon the organization of the profile statistics 17c.
- the background optimizer 58 reads the target addresses and determines, as by adding the target addresses to a list, that the flow paths or branches associated with the target addresses need to be traced. Execution proceeds to step 516 in which a target, if any, is selected for tracing its associated flow path.
- the first entry type is a TARGET ADDRESS TYPE ENTRY 532 comprising a NON -- NATIVE -- TARGET -- ADDRESS tag 536, a CALL -- FLAG 538 and a COUNT 540.
- Each entry of this type comprises a unique non-native address 536 which is the target of a transfer of a control.
- a list of these entries is used to represent all the locations to which control has been transferred at run-time as recorded by the run-time interpreter in the profile statistics. Each entry is unique from every other entry of the list.
- the NON -- NATIVE -- TARGET -- ADDRESS 536 functions as an identification tag or search index when searching for an entry amongst the profile statistics, as previously described, for example when the profile statistics are organized in a hash table.
- the CALL -- FLAG 538 is a boolean flag set to TRUE when the associated NON -- NATIVE -- TARGET -- ADDRESS has been the target of a routine CALL. Otherwise, CALL -- FLAG is FALSE.
- COUNT 540 is an integer representing the total number of times control has been transferred to the associated NON -- NATIVE -- TARGET -- ADDRESS. For example, if an instruction set comprises four instructions that transfer control, COUNT represents the number of times the associated NON -- NATIVE -- TARGET -- ADDRESS has been the target address to which control has been transferred by the four instructions.
- the translation unit determiner 500 examines each entry of the list comprising TARGET -- ADDRESS -- TYPE -- ENTRIES.
- the background optimizer 58 would determine the CALL entry points, as used in step 503 of FIG. 41 and step 508 of FIG. 42, by examining the CALL -- FLAG field 538.
- a CALL entry point is one whose CALL -- FLAG is TRUE.
- the translation unit determiner 500 traces the execution or flow paths originating from each CALL entry point using the method steps of FIG. 42.
- the second entry type of FIG. 43 is an INDIRECT CONTROL TRANSFER TYPE ENTRY 534 comprising a NON-NATIVE -- ADDRESS -- OF -- INDIRECT -- TRANSFER -- INSTRUCTION tag 542, NUM -- UNIQUE -- TARGET -- ADDRESSES 544 and a TARGET -- ADDRESS -- LIST 546.
- An entry of this type is made for each indirect transfer of control.
- the NON -- NATIVE -- ADDRESS -- OF -- INDIRECT -- TRANSFER -- INSTRUCTION tag is the address at which the indirect transfer of control instruction is located, and, as described previously with the NON -- NATIVE -- TARGET -- ADDRESS 536, can be used to determine a corresponding entry in the profile statistics 17c.
- NUM -- UNIQUE -- TARGET -- ADDRESSES is an integer representing the number of unique values which have been a target address for the associated instruction stored at NON -- NATIVE -- ADDRESS -- OF -- INDIRECT -- TRANSFER -- INSTRUCTION.
- TARGET -- ADDRESS -- LIST is a list of non-native addresses. Each entry in the TARGET -- ADDRESS -- LIST represents a unique run-time value corresponding to a target address of the associated instruction stored at NON -- NATIVE -- ADDRESS -- OF -- INDIRECT -- TRANSFER -- INSTRUCTION.
- the indirect transfer instruction "JMP @R5" transfers control to the address designated by the contents of a register "R5".
- This instruction is located at address "X" and is executed five (5) times wherein each of the five times transfers control to a different target address.
- the run-time interpreter recorded 5 unique target address values to which control was transferred from this instruction.
- the INDIRECT CONTROL -- TRANSFER -- TYPE -- ENTRY corresponding to this indirect transfer instruction is as follows:
- a list of INDIRECT CONTROL -- TRANSFER -- TYPE -- ENTRIES represents indirect transfer instructions and associated run-time target addresses.
- An implementation including an indirect transfer list performs the method steps of FIG. 42A.
- the profile statistics are searched to determine if the NON -- NATIVE -- ADDRESS -- OF -- INDIRECT -- TRANSFER -- INSTRUCTION field of an entry, if any, corresponds to a first non-native address of an instruction.
- the search method and technique is dependent upon the organization of the profile statistics 17c.
- the optimizer 58 adds the associated target addresses from TARGET -- ADDRESS -- LIST to a list of target addresses whose associated execution paths need to be traced.
- regions comprising the translation unit are also determined. A region and its associated beginning and ending boundaries are determined while tracing the flow of execution, as in performing the method steps of FIG. 42.
- the regions are determined by tracing the execution flow of instructions as described by performing the steps of FIG. 42, examining each of the instructions, determining a relation of the current instruction to the previous instruction, and recording information.
- the current instruction located at a CALL entry defining the beginning of a translation unit is examined.
- a current region is initialized at step 550 with a starting address of the current instruction.
- the next instruction as from the instruction sequence produced by executing the method of FIG. 42, is examined.
- a determination is made at step 552 as to whether this is the last instruction in the translation unit, i.e., all flow paths have been traced. If there are more instructions, a determination is made, at step 554, as to whether the current instruction is contiguous with respect to the immediately preceding instruction examined.
- the address following the end of the previous instruction is recorded, as in step 556, as the ending address of the current region.
- the ending address is the address of the previous instruction plus an offset equal to the size of the previous instruction.
- a new current region is defined with the starting address corresponding to that of the current instruction.
- the starting and ending addresses of the new combined current region are determined by examining the address boundaries defined for the existing region and the previous current region.
- the address boundaries of the new combined current region generally define a region including the union of instructions in the existing region and the previous current region. For example, the starting address of the new combined current region of step 562 is the smaller of starting addresses of the existing current region and of the previous current region.
- next instruction is examined at step 564 and control proceeds to the top of the loop formed by step 552. According to the method previously described for tracing the execution flow as in FIG. 42, the next instruction will be contiguous to the current instruction if step 510 evaluates to "NO", and the current instruction is not the last instruction in the current flow path. Otherwise, the next instruction will not be contiguous with respect to the location of the current instruction.
- Each instruction comprising a flow path originating from the CALL entry point of the current translation unit is examined until, at step 552, it is determined that all instructions in the current translation unit have been examined. Subsequently, at step 566, the regions are merged.
- One way in which regions are merged is by examining the starting and ending boundary addresses of each region. If, through examination of boundary addresses, two regions are contiguous, the two regions are then merged to form a combined region. For example, if the ending boundary address of a first region is the starting boundary address of a second region, the first and second regions are combined to form a third combined region with a starting address of the first region and an ending address of the second region.
- the stream of instructions examined in the method of FIG. 44 are produced by executing the method steps of FIG. 42.
- the method steps of FIGS. 42 and 44 are integrated and performed in an implementation of the translation unit determiner 500 in one of a variety of ways. For example, prior to performing step 521, the translation unit determiner subsequently performs steps 554, and conditionally, steps 556 and 558, of FIG. 44.
- step 556 When recording an ending boundary address, as in step 556, there may be an existing boundary address as a consequence of step 562.
- An update to an existing boundary address should result in the larger of the new or existing value.
- a region does not get smaller. Rather, a region grows as more execution paths or branches are traced.
- "ENTRY -- 1" is a CALL entry point at which flow path tracing commences, as in step 508 of FIG. 42, with "X", “Y”, and “Z” being symbolic references to non-native addresses.
- "Z” is the address of a direct or PC-relative conditional transfer instruction which transfers control to the instruction at address "X” if the contents of "R1", register 1, is 10.
- "Y” refers to the instruction contiguously located following instruction "Z”.
- the method steps of FIGS. 42 and 44 are integrated so that the regions are being determined while tracing the flow paths. Specifically steps 554 through 562 of FIG. 43 are performed sequentially and immediately prior to step 521 of FIG. 42. However, in the following description only significant execution occurrences of steps 554-562 will be mentioned. Occurrences of ":” in the example pseudo-code above represent an instruction that neither transfers control nor terminates the current flow path.
- Step 510 A determination is made at step 510 that "BEQ" is a transfer instruction.
- Step 512 classifies "BEQ” as a PC-relative transfer instruction.
- no run-time information is needed from the profile statistics 17c.
- Two possible targets are determined as "X” and "Y”.
- the background optimizer selects "X” as the target whose flow path is currently being traced.
- Step 518 determines that the current instruction, the transfer instruction located at "Z", does not terminate the current flow path.
- Step 521 determines that there are more instructions in the current flow path and the current instruction is updated, at step 522, to the instruction located at "X".
- step 510 evaluates to "YES”. However, processing done by steps 512, 514, and 516 are moot when 518 evaluates to "YES”. Step 520 results in the current flow path being terminated. Step 520 selects the remaining flow path with the target address "Y”.
- Step 554 determines "X" is not contiguously located in memory with respect to "Z". "REGION -- 1" ends, at step 556, following the previous instruction located at address Z. A new current region, "REGION -- 2", is defined with the starting address of "X”, the current instruction.
- Step 521 evaluates to "YES” and the current instruction is updated, in step 522, to the instruction located at address "Y".
- Steps 510 and 518 evaluate to "NO”.
- Step 554 evaluates to "NO” since "Y" is not contiguously located in memory with respect to "X”.
- Step 556 causes "REGION -- 2" to have an ending address following the instruction at "X”. Another region, "REGION -- 3", is produced with a starting address of "Y”.
- Step 521 evaluates to "YES” and step 522 updates the current instruction to be the "RETURN” instruction located at address "X”.
- Step 554 evaluates to YES since "X" is contiguously located with respect to "Y”.
- Step 560 evaluates to "YES” since the current instruction's address, "X" is within the boundaries of another region, "REGION -- 2".
- Step 562 causes "REGION -- 2" and "REGION -- 3" to merge and become a combined region, an updated "REGION -- 2" with a starting address of "Y” and an ending address following the instruction located at address "X”.
- a translation unit comprises one or more unique regions. No region belongs to more than one translation unit. Therefore, when forming a translation unit and determining its boundaries, if two translation units have a common region, the two translation units are merged and considered a single translation unit.
- a "FORTRAN" routine having multiple entry points is an example of when two translation units are merged.
- the foregoing technique for forming translation units of a binary image affords a new and flexible way to determine a translation unit analogous to a routine enabling components of the background system 34, such as the background optimizer 58, to perform procedural and interprocedural optimizations in binary image translations.
- the methods of forming the translation units, as previously described, and binary image optimizations are performed in the background system which is further characterized in the following text. Therefore, translation unit formation and optimizations, which are typically computer resource intensive, are accomplished without adversely impacting the performance of a computer system.
- components of the background system 34 such as the background optimizer 58, employ techniques, such as optimizations, that are expensive in terms of computer resources, such as CPU or system memory usage, to produce optimized translated native code.
- components of the run-time system 32 cannot usually afford to employ such methods that are expensive because the run-time system is constrained to perform its activities such that system performance is not impacted, such as during a peak or heavy computer system usage time.
- a component of the background system can perform tasks during non-peak usage computer usage times when there is usually less contention with other system tasks for computer resources. Additionally, since the background system does not typically involve user interaction, it is not necessary to employ methods that emphasize performing optimizations and translations quickly. It is generally more important for the resulting native translation to perform better at run-time than for a method employed by the background system to produce a resulting native translation quickly.
- the foregoing methods described are flexible in that they can be used when performing a binary translation without placing restrictions and making undue assumptions regarding a binary image being translated. This flexibility allows the foregoing technique to be applied to generally to all binary images rather than restricting application of the foregoing translation unit determination technique for use with a small subset of binary images, such as those binary images satisfying a particular set of conditions or properties.
- the example in Appendix A includes pseudo code describing the foregoing technique for generating a set of Translation Units given an Execution Profile (Profile statistics).
- the set of Translation Units returned has the property that every location which is recorded as a call target in one of the execution profiles is also an entry point of exactly one of the Translation Units.
- any location in the binary image is covered by at most one Region in one Translation Unit.
- the method works by following the control flow of the binary image starting with the locations which were the targets of calls in an execution of the binary image. (This information in recorded in the Execution Profile.)
- the main loop of the method is in the routine find -- translation -- units.
- the routine build -- translation -- unit follows the control flow starting from a called location which is one of its parameters.
- Build -- translation -- unit follows the control flow using a work list to keep track of locations which are the targets of control transfers that remain to be explored.
- the method used by build -- translation -- unit is basically a standard graph walk.
- Build -- translation -- unit provides a database of regions built up while following the control flow.
- the interface to this database is described by the class Region -- Db.
- the set of region in this database have the property that together they cover all the locations for which the control flow has been followed and no two of the regions cover the same location. No location which has not been found to be reachable from a Translation Unit entry is covered by a region in the region database.
- the translation units are merged to maintain the property that no location is covered by the regions of more than one translation unit. Whenever two adjacent regions are found to belong to the same translation unit, they are merged to preserve the property that all the regions of a translation unit of as big as possible.
- the background translator reads instructions in the first instruction set comprising a translation unit from the binary image, builds an intermediate representation (IR) semantically equivalent to the instructions, and then modifies the IR to produce a final version of the IR that corresponds to instructions in the second instruction set.
- the first instruction set is associated with a complex instruction set computer or CISC.
- the second or resulting instruction set is associated with a reduced instruction set computer (RISC).
- RISC reduced instruction set computer
- Translating CISC instructions to RISC instructions typically includes "breaking down" one CISC instruction into one or more corresponding RISC instructions.
- the IR generally includes one or more units of the IR which correspond to the "broken-down" CISC instruction.
- the IR uses a code cell as a basic atomic unit for representing instructions in the IR.
- the IR comprises one or more code cells connected, such as in a linked list representation.
- the IR is semantically equivalent to the CISC instructions input to the background translator.
- code cells 600 include one or more code cells 602a-c.
- each code cell is a data structure has one or more fields.
- Code cell 602 includes an opcode field 604 corresponding to an operation upon one or more operands 606.
- the fields within a code cell and their uses may vary with implementation and the first and second instruction sets.
- the IR opcodes of the binary translator are a union of both the instructions from a first non-native instruction set or source instruction set and a second native instruction set or target instruction set.
- the code cells can include some pseudocode instructions which are instructions that are neither in the source nor the target instruction set. Rather, a pseudocode instruction is included in the IR representation to annotate the IR or support an intermediate state of the IR transformed from source to target instructions.
- the IR typically includes instructions in the source or non-native instruction set.
- the IR typically only comprises code cells of target or native instructions.
- the IR is transformed from its initial form comprising only source instructions to its final form comprising target instructions.
- the IR itself may comprise any combination of source, target or destination, and pseudocode instructions.
- the background system 34 in the embodiment of the code transformer 800 (FIGS. 58A to 71C) intermixes the steps of translation and optimization.
- the IR upon which an optimization may be performed can comprise any combination of source, target, and pseudocode instructions. Therefore, an optimization technique, such as data flow analysis, used in binary translation should be flexible enough to handle any form of the IR.
- a technique used in performing optimizations should be flexible enough to trade-off optimization execution time for storage space or memory as needed during the translation and optimization steps. For example, at one point global data flow information may be needed to perform an optimization, but local data flow information is not needed. The technique for performing the optimization should not incur additional overhead associated with the local data flow analysis, such as storage of the local data flow information, when only global data flow information is needed.
- the background optimizer 58 processes the list of code cells 600 to perform optimizations using a binary image as input. Generally, optimizations reduce execution time and reduce system resource requirements of a machine executable program.
- Data flow analysis In which information is gathered about data values or data definitions.
- Data flow analysis generally refers to examining a flow graph or flow of control within a routine and collecting information about what can be true at various points in the routine.
- control flow analysis Prior to performing data flow analysis, control flow analysis is typically performed which includes identifying one or more basic blocks comprising a routine, as mentioned above.
- Data flow analysis is a two level process including local and global data flow analysis information. Local data flow analysis produces information about what is true within a basic block, such as the data dependencies within a basic block.
- Global data flow analysis produces information about what is true between or amongst basic blocks, such as the data definition dependencies between basic blocks.
- the data structure 601 which is an instantiation of the IR 600 during translation of the non-native image is shown.
- the data structure 601 represents local data flow analysis information for the IR code cells as shown in 601a.
- the statements below correspond to opcodes, operands and other data as may be present in the code cells 601a.
- the digits in the left hand corner are for referencing the code cell in text which follows.
- the IR 601 is an intermediate version of an initial IR further transformed into a final IR as will be described below in conjunction with FIGS. 58A to 71C.
- the first statement (1) which corresponds to the first code cell adds the constant "1" to the contents of register "ax” and places the result in register "ax".
- the second statement (2) corresponding to the second code cell, loads the contents from memory location whose address is in register "mem1" into register "bx”.
- the third statement (3) corresponding to the third code cell, adds the constant "8" to the contents of register "ax” placing the results in register "mem1" indicating an address in main memory.
- the fourth statement (4) corresponding to the fourth code cell, compares the contents of register "ax" to the contents of register "bx".
- IR code cells 601a in the data structure 601.
- a basic block comprises four (4) code cells 618a-618d which respectively correspond to the four (4) IR code cells above.
- the data structure 601 includes, in addition to the IR code cell data structures 601a, a basic block (BB) data structure 609, basic block value (BBV) data structures 640a-640f, basic block state container (BBSC) data structures 628a to 628d and state container (SC) data structures 630a-d.
- the basic block value (BBV) 640a, BB basic block (BB) 609, and basic block state containers (BBSC) 628 will now be described in more detail.
- the BBV such as 640a
- the BBV is a data structure included in the IR and abstractly represents a data value, its definition (if any) and any references to that data value by instructions within the basic block.
- a BBV such as 640a comprises six fields, a read -- list -- head (READ -- LST) 656, a definition (DEF) 657, a BBSC pointer (BBSC) 658, a modify-write boolean (MOD.WRITE) 659, as well as two other fields, a read-modify pointer (RD.MOD.PTR) 660 and a pointer to the next BBV (BBV NEXT) 662.
- READ -- LST read -- list -- head
- DEF definition
- BBSC BBSC pointer
- MOD.WRITE modify-write boolean
- RD.MOD.PTR read-modify pointer
- BBV NEXT pointer to the next BBV
- the read -- list -- head 656 is a pointer to the first operand which does a read of the data value associated with a BBV.
- the definition field 657 is a pointer to the operand which does a write or defines a data value.
- the BBSC pointer 658 points to a BBSC that is associated with a state container. All BBVs associated with a particular state container within a given basic block are "threaded" on a linked list with its list head in the corresponding BBSC. That is, all BBVs associated with the particular state container are connected in a linked list where the n th element of the list points to the n th+1 element of the list. This connection is established by the BBV next field 662 which points to the next consecutive BBV associated with a state container.
- the remaining two fields, modify-write boolean 659 and read-modify pointer 600 will be discussed in following text in conjunction with other figures.
- a BBSC data structure such as 628a, comprises seven (7) fields: a USE LIST head (USELIST HEAD) field 664, a DEF LIST head (DEFLIST HEAD) field 666, an SC pointer (SC POINTER) 668, a BBV list head field (BBV LIST HEAD) 670, a BB pointer (BB POINTER) 671, a BBSC summary information (BBSC SUM INFO) 672 and a pointer to the next BBSC (BBSC NEXT) 673.
- the USE LIST head 664, DEF LIST head 666 and BBSC summary information 672 and are discussed later in conjunction with global data flow analysis.
- the SC pointer field 668 contains a pointer from the BBSC to the state container (SC) associated with the data values.
- the BBV list head field 670 contains a pointer to the first BBV associated with a state container.
- a BB pointer 671 contains a pointer from the BBSC to the basic block data structure or BB data structure with which this BBSC is associated.
- the BBSC next field 673 contains a pointer to the next BBSC associated with the basic block designated by field 671.
- BB data structure 609 Five (5) data fields comprise the basic block (BB) data structure 609 are also shown to include the Inst -- forward (INST -- FORWARD) field 674, Inst -- backward (INST -- BACKWARD) field 675 and BBSC head pointer (BBSC HEAD) field 676, as well as In -- CFE -- list (IN -- CFE -- LIST) 678 and Out -- CFE -- list (OUT -- CFE -- LIST) 679.
- the In -- CFE -- list is a pointer to the head of the list of control flow edges or CFEs into a basic block 609.
- the Out -- CFE -- list is a pointer to the head of a list of control flow edges out of a basic block 609.
- the Inst -- forward field is connected via a pointer 610 to the first code cell 618a of the basic block. Pointer 610 and connecting pointers 612a-612c enable a forward traversal of the linked list of code cells comprising the basic block 609. Similarly, the Inst -- backward field is connected to code cell 618d, which is the last code cell in the list, by pointer 614.
- BBSC basic block state containers
- a code cell in this IR comprises an opcode field and multiple operand fields.
- code cell 618a comprises an opcode field 620a and operand fields 622a, 624a and 626a.
- each of code cells 618b-618d each comprise an opcode field and three operand fields.
- the opcode comprising the opcode field 620 can be represented either as a textual mnemonic or as a numeric value associated with a certain instruction.
- An operand in this implementation can represent a literal, a register operand or a memory location.
- An operand such as 622a which is a literal is denoted in the diagram as a constant value stored within the operand field of the code cell.
- An operand can also correspond to a memory location or a register operand.
- an operand field of a code cell designates a register or memory operand by being associated with a basic block value (BBV) having a corresponding data definition.
- BBV basic block value
- field 626c is the third operand of code cell 618c.
- the third operand is associated with a register used to identify a main memory address through pointer 625c connecting field 626c with BBV2 for a register "mem1" 640e.
- each BBV provides direct connectivity to all corresponding code cells which define and reference the data value associated with the BBV.
- FIGS. 47 and 48 An example of a data value having two data definitions is shown in FIGS. 47 and 48.
- the second operand field 624a of code cell 618a references register "ax".
- Operand field 624a is associated with BBV1 of register "ax” through pointer 623a which connects the operand field 624a with BBV1 of register "ax” 640a.
- the second operand field is reading a value from register "ax" adding one (1) or incrementing it, and assigning the result back into register "ax”.
- the third operand field 626a writes the result to register "ax” producing a new data value by this reassignment of an incremented result to register "ax".
- a second BBV of register "ax” 640b is associated with the third operand field 626a of code cell 618a. This connection is denoted by pointer 625a.
- BBVs 640a-640f represent a general class of data values about state information that may be referenced or modified by an IR instruction.
- State information includes for example, registers, condition codes, and main memory locations. What comprises state information varies with implementation and the first instruction set being translated to a second instruction set.
- Each piece of state information is denoted by a state container (SC) as depicted by elements 630a-630d.
- Five pieces of state information are affected by IR code cells 618a-618d. Specifically, these pieces of state information are: register "ax" 630a, register “mem1" 630b, register “bx” 630c, condition codes (not shown) and main memory 630d.
- register "ax" 630a register "mem1" 630b
- register "bx” 630c register "bx” 630c
- condition codes not shown
- main memory 630d main memory 630d.
- main memory 601 In the IR data structure 601 all of main memory 601 is treated as a single piece of state information. For example, a modification (write) to any memory location is shown in the IR as a data interaction affecting a subsequent use (read) of any memory location.
- Other embodiments of the IR may divide main memory into multiple parts, each part being analogous to a different piece
- FIGS. 47 and 48 are a snapshot of the IR during binary translation prior to converting condition codes to state containers, as explained above.
- Each of the BBVs 640a through 640f is connected to the appropriate state container to which the BBV refers through the basic block state container (BBSC) data structures 628a to 628d.
- the BBSC data structures 628a to 628d complete the direct global connectivity between code cells which define or use, e.g., read, or write, to the corresponding state container in multiple basic blocks.
- pointer 642a establishes a connection between BBV1 of register "ax" 640a and the first operand 624a which does a read of register "ax”.
- Pointer 642a connects the read list head field of BBV1 of register "ax” 640a to the second operand of code cell 618a.
- the next -- op field of operand 624a contains a pointer to the next operand which does a read of BBV1 of register "ax”.
- next -- op field of 624a is null denoted by 651a* representing a null pointer, e.g., that this is the end of the list. If there were more than one operand which did a read of this data value of register "ax", pointer 651a would designate the next consecutive operand rather than a null value.
- the Def (definition) field of BBV1 of register "ax" 640a contains a null pointer 646a. This is because the definition used by the first code cell is not defined within the basic block.
- BBV definition for this BBV is denoted by a null pointer indicating that it is not defined within this basic block.
- the definition of the data value associated with BBV1 for register or state container "ax" exists in another basic block and is a global data value. This is discussed in the following text in conjunction with global data values.
- An example of a local data definition is pointer 646b of BBV2 of register "ax" 640b. Pointer 646b connects the Def field of 640b to the third operand 626a of code cell 618a.
- the BBSC field of BBV1 of register "ax" 640a points to BBSC of register "ax” 628a of FIG. 47 as denoted by pointer 648a.
- the first BBV of "ax" 640a is connected to the second BBV for register "ax” 640b by pointer 650a.
- FIGS. 47 and 48 illustrate by example the connections established by the mentioned BBSC data structure fields.
- the BBSC of register "ax" 628 comprises the four (4) fields BB pointer 671, SC pointer 668, BBV list head 670 and BBSC next 673.
- Pointer 632a designates a connection between BBSC of "ax" 628a and BB 609.
- Pointer 638a establishes a connection between the SC field of BBSC of "ax" 628a and state container "ax” 630a.
- the BBV list head field has a pointer 634a to BBV1 of "ax" 640a. Remaining BBVs associated with the state container "ax" are threaded on a linked list headed by the BBSC.
- BBV1 for register "ax” 640a is connected to the second BBV for register "ax” 640b by pointer 650a connecting the BBV next field of 640a to BBV2 of register “ax” 640b.
- Pointer 636a connects the BBSC for register "ax” with the next BBSC 628b for state container "mem1". All of the BBSCs associated with the basic block are also connected on a threaded link list wherein the next field of BBSC n points to BBSC n+1 .
- an IR opcode table 680 is depicted as comprising various opcodes and associated information.
- An implementation can store the various opcodes used in code cell fields 620a-620d in an IR opcode table.
- Table 680 as shown has five (5) columns of information.
- Opcode column 682 is a list of all of the opcodes used within the IR. Specifically, the opcodes 682a and 682b can appear in the opcode field of an IR code cell.
- the opcodes are represented as ASCII text which map ASCII text appearing in the opcode field of a code cell in the IR.
- this table may contain an additional column associating the numeric value or opcode number with an IR opcode instruction mnemonic comprising ASCII text.
- Column 683 the operand count, contains an integer quantity that represents the number of operands for the associated opcode appearing on the same line in column 682.
- the IR opcode table 680 comprises three operand fields 684-686, respectively. The operand count field will designate how many of the succeeding operand columns 684-686 contain valid operand information associated with the corresponding opcode.
- Each of the operand fields 684-686 contain information about the type of access that operand performs on a state container or data value.
- opcode 682a is an ADD instruction with three (3) operands.
- the first operand 684a reads a data value associated with a state container.
- the second operand 685a also reads a data value associated with a state container.
- the third operand 686a performs a write and actually provides a data definition for a data value associated with a state container.
- Opcode 682b is an increment (INC) opcode having one (1) operand as designated by the operand count 683b.
- the operand count of one (1) associated with the increment instruction 682b means that operand fields 685b and 686b contain no information relevant to the opcode.
- Operand 1 has read-modify write access 684b to a data value.
- read-modify write means that the increment instruction, even though it has one (1) operand, reads the data value associated with the operand, modifies the data value by incrementing it, and then writes the updated data value back to the state container. This is one example with only one operand where both a read and a write is performed to a state container.
- This increment instruction also exemplifies a case in which a first data value associated with one BBV is read and a data definition associated with a different second BBV is also provided with a single operand single instruction.
- FIG. 50 depicts an example using two fields of the BBV not previously described. These fields are the modify-write boolean 659 and read-modify pointer 660 of BBV 640.
- FIG. 50 contains only those pointers relevant to highlighting the use of these two (2) BBV fields in conjunction with the code cells and BBSCs.
- these two (2) BBV fields are used in conjunction with IR opcodes such as the increment instruction 682b of FIG. 49 which has a read-modify write operand performing both a read and a destructive write operation to the same state container.
- an operand of the increment opcode will refer to two BBVs for the same state container.
- code cell 618h is an increment (INC) instruction.
- Code cell 618h increments the contents of register "ax” and then rewrites that value to the state container register "ax".
- pointer 693 connects the read-modify field of BBV1 of register "ax” 640f with the first operand of code cell 618h.
- the first operand of the increment instruction also performs a write to the state container register "ax” by incrementing the value of the contents of register "ax”. This produces a second data value for register "ax”.
- FIG. 50 contains a second BBV of register "ax" 640g.
- the definition for the second data value is indicated by pointer 694 which connects the DEF (definition) field of BBV2 of register "ax" 640g to the first operand of the increment codecell 618h.
- the second BBV for register "ax" has the field modify-write set to TRUE.
- Modify-write is a boolean value which is true when the definition associated for that data value is the result of a read-modify write as in this case with the increment instruction of code cell 618h. Otherwise, modify-write is FALSE.
- FIG. 50 contains four (4) code cells 618f-618i.
- Data structures as those pictured in FIG. 47 and FIG. 48 and FIG. 50 are built by traversing a list of code cells off of a basic block. For example, referring again to FIG. 47 and FIG. 48, the list of code cells is traversed beginning with the first code cell pointed to by pointer 610 of BB 609. For a given opcode such as the ADD opcode of code cell 618a, the IR opcode table 680 can be used to obtain information regarding the type of access of its operand and the number of operands for the given opcode. Using this information, the BBVs and the BBSCs can be built by traversing the list of code cells and establishing necessary connections between operands, for example, and BBVs.
- Global data flow information also includes data definitions within a basic block that are referenced in other subsequent basic blocks. With respect to the basic block which defines the data item globally referenced by other basic blocks, these definitions are referred to as global definitions comprising global data flow information.
- the BBSC summary information field describes how a basic block accesses an associated state container.
- the BBSC summary information describes how BBVs within a basic block manipulate a state container. Since a basic block is associated with one or more BBSCs, all local data flow summary information about the basic block used during global data flow (GDF) analysis can be easily obtained by examining the the BBSCs associated with a basic block.
- GDF global data flow
- the BBSC summary information field 672 previously seen in FIG. 47 will now be described.
- the BBSC summary information field is a single value that represents one of five patterns of access performed within a basic block of the associated state container.
- FIG. 51 shows these five possible patterns.
- Read access 708 indicates that only read accesses are performed within a basic block. Any access within this basic block reads a value which is upwardly exposed or defined within another basic block.
- a second pattern of access within a basic block to a state container is write access 710. If the first mention or use of the state container within a basic block is a write, e.g., there is a write and no preceding reads of that state container, then the summary information will indicate that write access is performed defining a data value that may be used in another basic block.
- a third pattern of access to a state container within a basic block is read-write access 712.
- the read-write access value indicates that a read is performed within the basic block which is dependent upon an external definition defined within another basic block. That is, when the first mention of the state container within the basic block is a read, read-write access 712 will be set. Additionally, there is also a write access within the basic block giving a newly assigned value to the associated state container. The newly assigned value may be used in another basic block.
- a fourth pattern of access to a state container within a basic block is read-modify-write access 714.
- a read-modify write pattern of access for a basic block implies that all writes to the associated state container are of the nature of the increment instruction, e.g., a read and write to the same state container with the same instruction.
- a fifth pattern of access within a basic block to a state container may indicate no local access 716 implying that the associated state container is not accessed, e.g., not actually read or written, within the basic block.
- FIG. 52 an arrangement of the data structures representing global data flow analysis information is depicted.
- Three basic blocks BB0, BB1 and BB2 are respectively numbered 609a-609c.
- a basic block such as BBO is associated with several BBSCs.
- this association is represented by enclosing the BBSCs in a bit vector form within a basic block.
- BB0 609a is depicted as a rectangle enclosing one or more BBSCs, such as BBSC1 628f for register "bx".
- FIG. 52 only depicts the BBSC summary information field 707a-707c of the BBSC.
- GDF global data flow
- Pointer or GDF1 edge 718a represents the global data flow connection between BB0 and BB1 in that BB0 can supply a value for state container "bx" read within BB2.
- pointer GDF2 718b represents the global data flow connection between BB1 and BB2 in that BB1 can supply a value or definition for a value of state container "bx" read within BB2.
- Control flow on the global level between basic blocks is denoted by control flow edges CFE1-CFE3, respectively 720a-720c.
- a control flow edge is used to represent the possible execution control flow paths between basic blocks.
- BB0 and BB1 flow into BB2.
- FIG. 53 details the GDF information represented in FIG. 52 by pointers GDF1 and GDF2.
- FIG. 53 highlights the DEF list head field 722 and USE list head field 724 of the BBSC and shows how they are used in representing global data flow analysis information.
- BB2 which is associated with BBSC3
- the relationship represented by GDF1 and GDF2 is detailed in FIG. 53 by having a DEF list head field of the BBSC 628H for register "bx" connected 722c to a first BBSC connector 725b.
- the DEF list head pointer 722c points to the beginning of a threaded list of BBSC connectors 725b-725d in which the BBSCs provide a definition for a state container read within the basic block associated with BBSC3 for register "bx".
- BBSC connector 725b points 726a to BBSC1 for register "bx" 628f.
- BBSC connector 725c points 726b to BBSC2 for register "bx" 628g.
- a first BBSC connector associated with a first basic block points to a list of all global definitions used within the first basic block for a state container defined within another basic block.
- null pointers 722a* and 722b* BBSC1 and BBSC2 for register "bx" do not have any upwardly exposed reads dependent on definitions for register bx defined within another basic block.
- FIG. 53 also illustrates the USE list head field 664 as previously mentioned in conjunction with FIG. 48.
- the USE list head field of a first BBSC associated with a first basic block represents a list of external data references of other basic blocks which depend on a value defined within the first basic block.
- BBSC3 628h for register "bx" is associated with BB2 which reads register "bx" using a data value defined in either BB0 or BB1.
- the representation of the global definition provided by BB0 uses BBSC1 628f associated with BB0.
- the USE list head field of BBSC1 for register "bx” points 724a to a BBSC connector 725a which is connected 726d to BBSC3 for register "bx".
- FIG. 53 indicates the detailed connections of the global data flow connections abstractly represented by GDF1 and GDF2, respectively, 718a-718b, of FIG. 52.
- FIG. 54 depicts a detailed view of a control flow edge (CFE). Specifically FIG. 54 is a more detailed description of CFE2 720b representing the control flow edge between BB1 and BB2. FIG. 54 also highlights two basic block fields in In -- CFE -- list 730 and Out -- CFE -- list 732 previously mentioned regarding the basic block data structure 609.
- In -- CFE -- list points to a list of CFE connectors 733 representing all incoming control flow edges to a basic block.
- the Out -- CFE -- list 732 functionally represents all outgoing control flow edges from a basic block.
- Connector 733 connects a source basic block 734 with a target basic block 736.
- the source CFE next field 738 points to another CFE connector 733.
- the target CFE next field 739 would point to another CFE connector 733 representing information about another target basic block.
- the foregoing data structures comprising the global data flow analysis information are typically produced using a method which performs global data flow analysis of a program by performing global data flow analysis upon each routine that is included in the program.
- step 746 any global data flow connections from a prior global data flow analysis are first eliminated.
- the "dominator tree” is computed as in step 748.
- a “dominator tree” represents a relationship between basic blocks.
- a first basic block of a routine "dominates" a second basic block if every path from the initial basic block when tracing the control flow of a program to the second basic block goes through the first basic block.
- every basic block "dominates" itself and the first basic block of a routine may "dominate” all other basic blocks in the routine assuming that there is only one common entry point to the routine.
- a useful way of representing dominator information is in the tree called the "dominator tree" in which the initial basic block is the root of the tree and the tree has the property that each node represents a basic block and "dominates" its descendants in the tree.
- the "dominance frontier” is computed as in step 750.
- the concept of a "dominance frontier” and a method for computing the dominance frontier is also detailed in "Efficiently Computing Static Single Assignment Form and the Control Dependence Graph", by Citron et al.
- X and Y are two nodes in a flow graph of a routine. Each node X and Y are basic blocks in the instant case. If X appears on every path from routine entry to Y, then X "dominates" Y, as previously discussed. If all paths to node Y must strictly and only go through X to reach node Y, X "strictly dominates" Y.
- the "dominance frontier" of a node X in the flow graph is the set of all nodes Y in the flow graph such that X "dominates" a predecessor of Y in the flow graph, but does not "strictly dominate" Y.
- a predecessor of a node Y is a node which precedes Y in the flow graph.
- GDF global data flow connections
- a merge point is a merge or joining definition point within a routine for multiple definitions of the same state container.
- FIGS. 56A and 56B detailed method steps 754 for determining merge points are shown. The method described in FIGS. 56A and 56B makes a list of all of the definitions within a routine and then adds merge point definitions using the dominance frontier.
- a first state container (SC) for a routine is obtained as in step 758.
- a determination is made as in step 760 as to whether or not this is the last SC associated with a routine. If it is the last SC, the method stops as in step 762. If this is not the last SC, a boolean flag upward exposure is initialized to null as in step 764.
- the list of BBSCs associated with a state container is traversed beginning with a first BBSC as in step 766.
- a determination is made as in step 768 as to whether or not there are any more BBSCs associated with the current state container. If a determination is made that this is not the last BBSC associated with a state container using the BBSC summary information the pattern of local access within the basic block is classified as in step 770.
- the access falls into one of four (4) classifications or patterns. If there are read and write accesses or a read-modify-write access within a basic block, upward -- exposure is set to "yes" as in step 771 and the definition of the data value created by the write is added to an ongoing list of definitions. If there is only read access, upward -- exposure is set to "yes" as in step 773.
- step 774 merge BBSCs remain from a previous global data flow computation. Therefore, these remaining BBSCs are deleted.
- BBSCs are produced representing an artificial definition of a state container to represent merging definitions in a routine.
- step 774 if a BBSC exists when there is no local access to a state container within the associated basic block, the BBSC was produced from a previous iteration of the method steps of FIGS. 56A and 56B for finding merge points. These BBSCs are deleted in step 774.
- step 776 If the basic block local access is determined to be a write only access, that is, there are no reads but only a write access as in step 776, a definition is added to a list of definitions being maintained. Control then proceeds to step 778 where the next BBSC is examined. Control then returns to step 768 for a determination again as to whether there are any more BBSCs associated with the current state container. The loop bounded by steps 768 and 778 is performed until there are no more BBSCs associated with the current state container.
- step 768 Upon a determination at step 768 that there are no more BBSCs associated with the current state container, control proceeds to step 780 of FIG. 56B where a determination is made of whether or not upward -- exposure has been set to "yes". If upward -- exposure has been set to "yes", control proceeds to step 782 in which merge points are detected and merge point definitions may be added by creating BBSCs.
- a merge point and the creation of a BBSC for a merge point definition is discussed in following text in FIG. 57.
- a merge point of multiple definitions is determined to be at a basic block X containing no local references or definitions to the strate container, a BBSC representing this merge point is created and associated with the basic block X having the BBSC local summary information indicate "no local access”.
- control proceeds to step 784 where the next state container is examined for the current routine.
- Control then proceeds to step 760 where the loop bounded by step 760 and step 784 is repeated until a determination is made at step 760 that there are no more state containers associated with the current routine.
- the arrangement uses the boolean upward exposure to determine when an upwardly exposed definition has been detected within a basic block. Accordingly, merge points are only added when there is global access for reference outside of a basic block to a definition defined within another basic block. If there is no upward exposure, there can be no global connectivity even if there are definitions within a basic block. Thus, the steps, of determining merge point definitions and adding needed BBSCs is eliminated from the method.
- FIG. 57 a global data flow analysis arrangement is illustrated in which a BBSC is produced while performing the foregoing global data flow analysis method.
- the BBSC produced acts as a merge point definition for register "bx", as in step 782 of FIG. 56B.
- BBSCs associated with a basic block are enclosed within a rectangle.
- BB0 609f is a rectangular box enclosing BBSC1 628i.
- FIG. 57 includes five (5) basic blocks with appropriate global data flow edges GDF1-GDF3, respectively numbered 718c-718e and control flow edges CFE 1-CFE 5, respectively numbered 720d-720h.
- BB0 and BB2 both have write access to register "bx", as indicated in BBSC1 628i and BBSC2 628j.
- BBSC1 and BBSC2 each provide a definition for the state container or register "bx" which is read in BB4, as indicated by BBSC 628l.
- BBSC3 628k is produced.
- BBSC3 represents a merge point definition indicating the earliest control flow point within the current routine at which all dependent definitions merge.
- BBSC3 represents a merge point or juncture for two definitions of register "bx". Merge points are used, for example, when performing optimization involving data dependency.
- the foregoing arrangement for representing local and global data flow analysis information has several advantages over existing arrangements typically used for local and global data flow analysis information.
- the hierarchical structure of the local and global data flow analysis information arrangement allows a clear and distinct line to be drawn between local and global data flow information in which the BBSC data structure acts as a wall or a filter between the local and global data flow.
- the data flow information arrangement provides an advantage in software development and maintainence in that it to easy to identify between data structures as effected by local data flow analysis and data structures as effected by global data flow analysis when performing, for example, a software modification.
- the fact that local and global data flow analysis information and their data structures can be easily distinguished aids in debugging software affected by the software modification. For example, if an incorrect value is stored to a BBV a developer may typically conclude that there is a coding error within the local data flow analysis code and not the global data flow analysis code.
- the foregoing arrangement provides an information rich data structure which interconnects local and global data flow analysis information without requiring a large amount of fixed storage as typically needed when using a bit vector. Additionally, the data flow analysis arrangement of the invention is scalable in that the amount of memory generally increases linearly with program size since the amount of memory used is linearly proportional to the number of definitions and uses within a program.
- the foregoing arrangement also provides direct connectivity between definitions and references both locally and globally. For example, for a given basic block it can easily be determined what all of the global references are.
- Another advantage is that the foregoing arrangement does not use two different techniques for representing local and global data flow analysis information.
- the number of routines common to both local and global data flow information will increase if both local and global data flow information impart similar structural features to their respective data structures and similar techniques are employed in building and maintaining the data structures.
- an increase in the amount of code commonly used for local and global data flow analysis results in decreased development costs by typically reducing the amount of code which must be tested and maintained by developers.
- the foregoing representation for data flow analysis information also affords flexibility allowing an implementation to interchange and trade-off optimization execution time for storage space. Recall such flexibility is needed within a binary translator due to the different optimizations performed and their varying requirements as to system memory. For example, an optimization may be memory intensive. Upon computing local and global data flow analysis information, the local data flow analysis information may be discarded if not needed in performing the optimization, thus decreasing the amount of required memory for storing data flow analysis information. Additionally, the hierarchical structure previously described provides for easily identifying what data structures comprise the local data flow analysis information that may be eliminated.
- the binary translator 54 is part of a background system 34 which also includes an optimizer 58.
- the background system 34 is responsive to the non-native image file 17b and profile statistics gathered during a run-time execution of the non-native image by a run-time system such as an interpreter 44.
- the binary image transformer 800 which preferably operates as a background process and transforms a non-native binary image from segment 17b in conjunction with run-time profile statistics from segment 17d into a translated binary image 17c is shown.
- the binary image transformer 800 comprises the translator 54 and the optimizer 58 as depicted in the background system of FIG. 3.
- the arrangement shown in FIG. 3 comprising an optimizer and a translator is one arrangement for the binary image transformer 800.
- the binary image transformer transforms the first binary image or non-native image 17b to a translated binary image or native image 17c.
- FIG. 58B depicts another arrangement for the binary image transformer 800 where the transformer comprises only the binary image translator 54 with no optimizer.
- FIG. 58C depicts the arrangement for the binary image transformer of FIG. 3.
- FIG. 58D depicts yet another alternate arrangement for the binary image transformer 800 comprising a binary image translator and optimizer 802 as a combined unit.
- the binary image translator of FIG. 58D translation and optimization are intermixed to improve the efficiency of the translated/optimized code.
- the first or non-native binary image 17b is an image built to execute in a complex instruction set computer (CISC).
- CISC complex instruction set computer
- RISC reduced instruction set computer
- step 804 the steps performed by a binary image transformer 602 (FIG. 58D) to transform a binary image 17b into a translated binary image 17c are depicted.
- Translation units are determined, as in step 804, as mentioned above in conjunction with FIGS. 41 to 44.
- One of the translation units is selected, as in step 806.
- step 808 a determination is made as to whether or not there are any remaining translation units. If there are remaining translation units, control proceeds to step 810 where an initial intermediate representation (IR) is produced.
- the initial IR is translated and optimized to produce a final translation unit IR, as in step 812.
- Control is transferred back to step 806 where another translation unit is selected.
- step 808 a determination is again made as to whether or not there are any remaining translation units.
- a final translated binary image IR is produced, as in step 816.
- the final translated binary image IR combines individual translation unit IRs into one final translated binary image intermediate representation (IR).
- the translated binary image 17c is then produced, as in step 818.
- step 804 Prior to performing optimizations or translations, it is necessary, as in step 804, to determine what translation units comprise the non-native binary image 17b. Generally, to be able to perform a wide range of optimizations including local and global optimizations, it is necessary to define a translation unit which does not inhibit the application of existing and new optimization techniques. One such preferred technique for determining a translation unit was previously described in conjunction with FIGS. 41 to 44.
- step 806a selection of a translation unit begins by determining for the image to be translated, call relationships amongst translation units, as in step 820.
- a call graph is produced using the call execution order, as in step 822.
- a translation unit is selected from the call graph based on a depth first search of the call graph, as in step 824.
- Tracing the call execution order of the translation units comprising a binary image includes tracing the run time execution order in which translation units are called. For example, if routine A calls routine B, and then routine B calls routine C, the call execution order of these routines is A, B, C.
- a call graph is a data structure comprising nodes in which each node corresponds to a translation unit or routine called in the execution order.
- routine A calls routine B.
- routine B calls routine C, D and E.
- Routine A also calls routine X. It can be seen that each node in the graph corresponds to a routine. Nodes at a top level of the graph, such as node A 826, occur earlier in the execution order.
- the bottom most level of the call graph contains the nodes representing the last routines in the execution order, such as nodes 828a-828d.
- step 824 the depth first search of the graph as in FIG. 60A is performed producing a depth first search order.
- One depth first search produces an ordering of nodes A, B, C, D, E and X.
- the order in which the translation units would be selected is in the order produced by the depth first search.
- register preservation and allocation techniques can use the information produced by the call execution order. For example, a register allocator can use the information that routine C does not call routine D, and the fact that both of these routines are called from routine B. A register allocator determines that routines C and D have the same registers available for allocation within the routines.
- the method 806b produces an ordering of translation units to be translated based on how frequently each translation unit is called.
- the profile information is read. Specifically, the profile information includes information about how frequently translation units are called. As previously described, this profile information is run time execution information gathered by the interpreter 44. Using the information from the profile statistics, the translation units are ordered from most to least frequently called, as in step 832. Each translation unit is selected from the ordering with the most frequently called routine being selected first.
- method 806b One benefit of using method 806b is apparent when there is a user specified time limit for translation. For example, if the user allots time N to translate the first binary image to the second binary image, it is typically most beneficial in terms of run-time execution efficiency to translate, rather than interpret, those translation units which are called or executed most frequently.
- step 810 steps in a method for building an initial IR 810 are shown.
- Memory operands of CISC instructions are removed and replaced with register and constant operands, as in step 836.
- One CISC instruction with memory operands produces one or more IR instruction code cells in the initial IR.
- step 838 an initial determination is made as to whether the instruction or instructions which corresponds to the IR instruction code cell can produce a run time exception.
- Information which is needed in later processing is also stored with each IR instruction code cell.
- One piece of information which is stored and can be used in later processing is the address of each instruction being translated, as in step 840.
- each IR instruction code cell Associated with each IR instruction code cell is the address of the corresponding machine instruction in the first binary image which corresponds to that IR instruction code cell.
- the address represents a location within the first binary image. This address is used, for example, when determining a correspondence between a CISC instruction in a first binary image and IR code cells producing RISC instructions included in a second translated binary image. Also performed at this time are tasks which initialize and create data structures, for example, additional data structures included as part of the IR which are used in later processing stages.
- One such piece of information which is stored and used in later processing is initialization of condition code masks, as in step 842.
- a CISC instruction typically includes a memory operand referring to a memory location.
- RISC instructions generally do not have memory operands. Rather, RISC instructions load an address into a register and retrieve contents from memory using the register as an address operand pointing to the memory location.
- the memory operands are removed from instructions. These operands are replaced with a register or a constant value IR operand.
- a run-time exception can occur, for example, when there is a divide by zero error when executing a floating point instruction.
- Another example of a run-time exception is when a memory access is attempted using an invalid address with a load or a store instruction. A data structure to maintain track of such instructions is described in conjunction with FIG. 62C.
- Another piece of information which is associated with each IR instruction code cell is recording the image address identifying a location within the first binary image 17b currently being translated as in step 840.
- Each IR instruction code cell also includes a condition code bit mask, as provided in step 842.
- a CISC instruction such as the X86 set mentioned above set condition codes to indicate certain conditions that happen as a result of run-time execution of an instruction.
- a RISC architecture such as the Alpha architecture mentioned above, does not have or use condition codes.
- condition codes of the CISC instructions are handled as mentioned above in conjunction with FIGS. 7 to 20.
- a condition code bit mask is initialized and associated with each IR instruction code cell for use in later condition code processing.
- condition code bit mask associated with an IR code cell is initialized indicating those condition codes which can be affected by execution of an instruction corresponding to the IR code cell.
- One representation of the condition code bit mask reserves one bit in the bit mask for each condition code in the first instruction set associated with the binary image being translated.
- a CISC instruction 844 ADDB is illustrated. ADDB adds together two bytes of information. One byte of information is in the register AL 844a.
- the second operand is a memory location 844b whose address is specified by adding the contents of register SP (the stack pointer in the non-native architecture) plus register AX plus 4.
- the add byte (ADDB) instruction loads the contents from memory specified by address 844b, adds a byte of that memory location to the contents of register AL 844a, and stores the result in register AL.
- this CISC instruction operating comprises 3 steps corresponding to 3 IR instruction code cells which will now be described.
- IR code cell 846 represents the formation of the address 844b of the second operand. The address is stored in register treg1. The second IR instruction code cell 848 loads from memory the contents of the location specified by treg1. The contents of the memory location are placed in register treg2. Finally, the third IR instruction code cell 850 adds a byte of information from treg2 to register AL storing the result in register AL.
- the IR instruction code cell 844 includes the address formation of an operand corresponding to IR instruction code cell 846, loading the operand from memory corresponding to IR instruction code cell 848, and performing the data operation of the instruction 844, e.g., ADDB, in IR instruction code cell 850. Note that the representation in FIG.
- the operands treg1 and treg2 denote general hardware registers that are allocated or more particularly defined in a later register allocation process.
- the register operands treg1 and treg2 operate as place holders for which a particular register will be determined later in the translation.
- the original instruction in the first binary image being translated 844 corresponds to 3 IR code cells and has an image address.
- the image address of the instruction 844 is associated with each of the IR instruction code cells 846, 848 and 850.
- the table 852 contains two columns.
- the first column 854 contains an entry for each IR instruction that can be specified within an IR instruction code cell.
- the second column 856 contains an entry corresponding to an IR instruction appearing in column 854.
- Column 856 contains a bit value indicating whether a machine instruction, corresponding to an IR instruction in column 854, when executed can produce a run time exception.
- the floating point add instruction (FADD) 854A can produce a run time floating point exception as indicated by the bit value here "1"856a.
- a bit value is associated with each IR instruction code cell.
- the initial IR which is built as a result of processing at step 810 of FIG. 59, is an intermediate representation of the machine instructions comprising the translation unit currently being processed.
- one IR comprises a list of IR instruction code cells.
- Each IR instruction code cell comprises an IR instruction opcode followed by one or more operands associated with that instruction opcodle.
- the IR which is produced as a result of step 810 and used in the remaining translation and optimization steps is similar to the IR discussed in conjunction with two level data flow analysis. Different portions of the IR are constructed during various portions of the translation and optimization steps. It is the IR construction of step 810 which constructs an initial list of IR instruction code cells corresponding to machine instructions comprising the translation unit.
- state containers are incorporated into the IR as needed to accurately represent IR operands.
- an IR state container is added to the IR for each piece of state information.
- state containers are added, for example, for each register, partial register, and memory operand.
- the IR will be updated to accurately reflect the later processing steps.
- IR state containers and references to them are accordingly updated to reflect the register processing.
- the initial IR is translated and optimized to produce a final routine IR as in step 812.
- Condition code processing is performed, as in step 852, to represent condition codes and their uses into a form which readily transforms into RISC instructions of the translated binary image.
- Register processing is performed, as in step 854.
- the Intel CISC instruction set includes partial register operands which use a portion of a register as an operand. Special processing is needed to convert the partial register operand and their uses into a representation in the IR enabling translation into RISC instructions.
- Early optimization processing is performed, as in step 856.
- a particular implementation as in step 856, performs early floating point optimization processing.
- This particular floating point optimization processing includes performing peephole optimizations to reduce the number of IR instruction code cells used in later translation and optimization steps.
- Another translation step particular to translating Intel CISC instructions to Alpha RISC instructions, includes processing the Intel instructions which use floating point (FP) register stack addressing, as in step 858.
- FP floating point
- step 852 through 858 of FIG. 63 represents special processing particular to the CISC instruction set being translated, such as the Intel instruction set.
- An implementation which translates a different CISC instruction may use the same or different processing step tailored for the CISC instruction set comprising the binary image being translated.
- the processing performed by steps 852 through 858 typically work on translating and transforming the IR including operands into a form which more closely resembles the RISC instruction set that will comprise the translated binary image 17c produced as a result of the binary image translation.
- step 860 local basic block and global routine optimization processing is performed.
- Exception handler processing is performed, as in step 862, to enable proper handling of a run time exception which occurs when executing the translated binary image.
- the code selection and operand processing as in step 864, perform final transformation of the IR code cells. In particular, if the machine instruction set comprising a binary image being translated 17b has 32 bit operands and the machine instruction set of the translated binary image 17c has 64-bit operands, part of the code selection processing insures that all operands are 64 bits in length.
- code selection processing insures that no opcodes corresponding to machine instructions in the source instruction set of the binary image 17b exist in the IR at the completion of step 864.
- the first code scheduling optimization pass is performed on the IR.
- the IR is generally in a one to one correspondence with instructions that will comprise the translated binary image.
- Optimizations such as code scheduling which are highly dependent upon the machine instruction set of the translated binary image 17c, are performed. Code scheduling typically rearranges sequences of instructions into a more optimal sequence due to resource contentions within the computer system 10.
- Register allocation is performed, as in step 868. Register allocation determines specifically which registers within the machine instruction set comprising a translated binary image will be used to hold what specific operands. For example, recall that in the initial IR representation, temporary registers such as treg1 and treg2 were introduced when transforming a machine instruction from the binary image 17b into the initial IR. These temporary register names are now assigned or bound to particular registers as used with the machine instructions comprising the translated binary image 17c.
- a second code scheduling pass is performed, as in step 870. After allocating and binding a specific register to a certain operand, a particular sequence of instructions may be able to be reordered for more optimal performance and efficient use of resources.
- Exception handler tables are generated, as in step 872, and comprise the final translated binary image. These tables produced as a result of step 872 enable proper run time behavior of the translated binary image when a run time exception occurs.
- condition code processing 852 of FIG. 63 is described in more detail.
- Data flow analysis of the condition code bit mask is performed, as in step 874.
- the condition code bit masks are those bit masks which were initialized and created as a result of building the initial IR in step 810 of FIG. 59.
- Data flow analysis includes determining reads and writes, respectively references and definitions, to the various condition codes.
- Local data flow analysis is performed for each basic block to determine "live" condition codes for each basic block, as in step 876.
- a "live" condition code is one which is defined in one basic block and referenced in another basic block.
- IR state containers are provided one per condition code, as in step 878. State containers, which represent state information including condition codes, were previously discussed in conjunction with two level data flow analysis and producing an initial IR, as in step 810.
- IR instructions which set and propagate condition code values as in step 880, are added.
- condition code bit mask 882 is shown.
- the condition code bit mask is a 32 bit register mask that is associated with each IR instruction code cell.
- a maximum of 8 condition codes exist in the first machine instruction set comprising the non-native binary image 17c.
- Four bytes of information 882a-882d comprising the 32 bit mask are used to represent the four possible states of each condition code.
- Each condition code can be in one of four states as indicated by the corresponding byte in FIG.
- a "set” state 882a in which the condition code has been set due to the run time execution of an instruction
- a "clear” state 882b which indicates that this condition code cannot be set or is cleared by the execution of this machine instruction
- a "func” state 882c in which the value is determined by the instruction results computed by the corresponding machine instruction
- a fourth "undefined” state 882d in which the value of the condition code as affected by this instruction cannot be determined.
- a particular machine instruction within the non-native binary image 17b can cause a condition code to be set to 1. Its corresponding position within the set bit mask 882a is set to 1. Similarly, if an operation performed by an IR code cell corresponds to a machine instruction whose result determines the condition code, a bit within the func bit mask 882c which corresponds to the condition code would be set to 1.
- condition code bit mask 882 is initialized, as in step 842 of FIG. 62A when building the initial IR. After the initial IR has been built in step 810, the condition code bit mask associated with an IR instruction code cell is initialized to indicate which condition codes can be set upon execution of the machine instruction associated with the IR opcode.
- Step 874 of FIG. 64 examines the initialized condition code bit mask associated with each instruction code cell and stores, for each basic block, summary information indicating which condition codes are set in one block and referenced in other blocks.
- Such a condition code which is defined in one block and referenced in succeeding block is referred to as a "live" condition code, as previously described.
- the IR is modified to contain state containers representing each condition code.
- a state container references a piece of state information about a resource used in instructions.
- CISC instructions are being translated into RISC instructions where the RISC instructions only have immediate constants and register operands.
- the state container which represents a condition code is used to map a condition code resource in a CISC instruction to a register in the RISC architecture.
- the state containers act as resource map of a resource used in a first computer system associated with the non-native binary image 17b to another resource in a second computer system associated with the translated, native binary image 17c.
- an IR instruction code cell such as an add or subtract instruction
- other IR code cells are added to set and propagate the proper condition code or, rather as in the instant case, the RISC register associated with the condition code state container.
- IR instruction code cells are also added where a condition code is referenced or read.
- Source instructions 884 are transformed into the initial IR 886 by performing processing as in step 810.
- Condition code processing as in step 852 is subsequently performed using the initial IR 886.
- the IR resulting after condition code processing is represented as 888.
- Source instruction 884a performs a byte compare of register AL to the constant 3.
- Instruction 884b performs a branch if the value contained in the register AL is not equal to 3. For the purposes of the example in FIG. 65B since the focus is on condition code processing, only those elements of the IR which are pertinent to condition code processing have been shown. For example, there is no target of the branch instruction 884b shown.
- the initial IR produced as a result of processing source instructions 884 is shown in 886.
- the first instruction 886a of the initial IR subtracts the value of register AL from the constant 3 storing the result in a temporary register TZ. Additionally note 886c indicates that a condition code in the condition code bit mask is set by the subtract instruction.
- the IR instruction 886b performs a conditional branch based on the condition code Z bit where the Z bit represents whether or not the operation previously performed as with the subtract instruction 886a produced a zero result.
- the instructions shown in 886 are transformed after condition code processing into the IR instruction code cells shown in 888.
- the first instruction 886a has two corresponding instructions 888a and 883b. Since the target RISC instruction set only comprises a subtract quad word for integer values (SUBQ), the subtract byte instruction (SUBB) of 886a is replaced with a subtract quadword instruction of 888a with the result placed in a register denoted TZ.
- the IR comprises a state container associated with the Z bit condition code which corresponds to a register in the RISC architecture.
- a byte is extracted from register TZ as performed by instruction code cell 888b, so that data operations are performed upon a byte quantity as in the original source instruction and the initial IR.
- the IR instruction code cell 886b which performs a 32 bit branch based on the Z bit condition code has been replaced with the IR instruction code cell 888c which performs a 64-bit branch based on the contents of the register associated with the Z bit condition code state container.
- FIG. 65B depicts a typical transformation of an initial IR 886 after condition code processing 888.
- the condition code in the CISC architecture is associated with a state container since the condition code is a piece of state information.
- the state container associated with the condition code is mapped to a register in the RISC architecture.
- the resulting IR after condition code processing has the register in the RISC architecture associated with the condition code state container as an operand in the IR after condition code processing. Additional instructions, such as 888b, are added to produce equivalent results between IR transformations. References and uses of the condition code are replaced with the register state container associated with the condition code.
- a state container is produced in the IR for each condition code.
- the state container maps the condition code, as with the Z bit condition code in this example, to a register in the RISC architecture, as denoted by the temporary register TZ.
- references to the Z bit will point to the state container and all definitions to the Z bit will point to the state container as well.
- condition code processing enables the resulting IR to resemble machine instructions which will comprise the translated binary image.
- condition code processing of step 852 CISC condition codes are mapped to RISC registers. This mapping occurs using state containers.
- new IR instruction code cells, such as 888a-888c have opcodes resembling RISC machine instructions which will comprise the translated binary image.
- register processing Another type of processing which occurs when transforming CISC instructions to RISC instructions in which the CISC instructions include partial register operands is register processing, as performed in step 854 of FIG. 63.
- step 890 all partial register operands are determined and replaced with a corresponding complete register operand.
- the complete register operand is a register operand as used in other instructions. Needed IR instructions are added, as in step 892, producing a computational result equivalent to the previous IR.
- step 894 IR instruction code cells which reference a partial register operand is updated and replaced with a corresponding register operand.
- a 32-bit register EAX is shown 896.
- the entire register as an operand in an instruction included in the first binary image is referred to as EAX.
- Partial register operands which appear in instructions included in the binary image to be translated 17B are operands AH, AL and AX.
- AX as an operand refers to byte 0 and byte 1 of the contents of register EAX.
- the operand AH refers to byte 1 of register EAX and similarly the operand AL refers only to byte 0 of register EAX.
- the partial register operands for register EAX are AH, AL and AX.
- each partial register operand is mapped to an entity included in the second instruction set.
- CISC instructions are translated to RISC instructions.
- the RISC instruction set only has registers or constant values as operands.
- each partial register operand is mapped to an entire register in the RISC architecture.
- an IR instruction code cell 898a is transformed into two corresponding code cells 898b and 898c.
- IR instruction code cell 898a performs byte addition of partial register operand AL with the contents of register treg1 with results stored in byte location AL. Additionally, condition codes are set by this instruction, as indicated by the "CC" of 898B.
- Register processing replaces partial register operand AL of instruction 898a with two equivalent instructions 898b and 898c, as indicated in FIG. 67B.
- Partial register AL of 898a is replaced with EAX, as in 898b and 898c.
- IR instruction code cell 898b adds the contents of register treg1 to register EAX storing the result in register treg2.
- IR instruction code cell 898c inserts a byte into register EAX from treg2 and stored the result in register EAX.
- IR instruction code cell 898c preserves the data comparability of register EAX in that only a byte of the data register is replaced.
- FIG. 67B is an example once again of how the partial register operand AH is replaced with the full register operand EAX and how additional instructions are added to preserve the operation result of the original instruction.
- Floating point optimization processing is peephole optimization processing performed early in the overall translation and optimization process.
- peephole optimization processing replaces one or more instructions from one instruction set with one or more instructions which are deemed to be more efficient.
- the one or more instructions replaced are CISC instructions.
- the peephole optimization replaces the CISC instructions with an equivalent single RISC instruction which will comprise the final translated image.
- the peephole optimization processing, as depicted in step 856, is highly dependent upon the instruction set.
- a code pattern 902 comprising multiple instructions is shown.
- This code pattern is searched for in the IR instructions and replaced with an equivalent RISC instruction.
- the pattern depicted in 902 comprises four different instructions which must appear in sequence. For simplicity, only those opcodes and relevant operands used in identifying the code pattern are shown in 902 of FIG. 68A.
- Entries 902a to 902d correspond to IR instruction code cells which appear in sequence within the IR.
- Instruction 902a compares a floating point value stored as the top stack value with the constant 0.
- the stack is an area of memory pointed to by a register (stack register).
- Stack operands are implicit operands in the floating point (FP) Intel CISC instructions. The address of one of the implicit operands is indicated by the address in the stack register. Operands are pushed (added) onto the stack and popped (removed) from the stack as FP operations are performed.
- Instruction 902b stores the status word of the 16 bit floating point state information to a register (denoted ⁇ REG> in FIGS. 68A-68B).
- Instruction 902c performs a test of the register to which the status word was stored by comparing the register to a bit mask specifying a comparison value. A branch is performed by instruction 902d based upon the content of the status word as compared to the bit mask.
- Instructions 902a-902d perform a conditional branch based on the floating point value stored on top of the stack. Note that the last instruction 902d which will be searched for in the pattern can either be a branch on equal to zero (BEQ), or a branch not equal to zero (BNE).
- the RISC instruction set to which the series of CISC instructions is being translated comprises a floating point branch operation as a single instruction. Thus, the result of the four CISC instructions is accomplished with one equivalent replacement instruction in the RISC architecture.
- a table 903 is shown depicting a replacement instruction 908 which replaces a detected pattern 902a-902d.
- the precise replacement instruction shown as 908 depends upon the bit mask value 904, as used in instruction 902c, and the last instruction in the code pattern 906, as used in instruction 902d.
- the bit mask value used in instruction 902c tests for the Z bit and the last instruction in 902d is a branch if equal to 0 instruction (BEQ).
- the Z bit is set in the CISC instruction if a zero data value is indicated by the FTST instruction 902a.
- the replacement instruction is the FBEQ instruction having an operand that corresponds to the register used in 902b and 902c.
- the replacement instructions included in column 908 have a one to one correspondence with a RISC instruction that will comprise the translated or native binary image 17c.
- the IR used in this translation and optimization processing has a particular structure which provides great flexibility in that optimization and translation substeps can be intermixed and performed in an efficient order without undue restrictions.
- the IR has the property that the opcode of any instruction code cell is one of: an opcode which corresponding to the non-native instruction set of the non-native image 17b, a pseudo op instruction specifically included for translation processing, or an opcode corresponding to a machine instruction in the destination or native instruction set of the native binary image 17c.
- an optimization such as the early floating point peephole optimization processing of step 856 can be performed at multiple points during binary translation producing a resulting replacement instruction in the IR which has a direct correspondence to an instruction in the translated binary image 17c.
- a compiler typically uses several different IRs rather than a single IR as here.
- an initial IR goes through several transformations into other IRs in which each IR has varying properties and restrictions from the previous IR representation. Generally, these properties restrict the type of processing, e.g., translation and optimization steps, which can occur at various phases of translation or compilation.
- a compiler front end performing syntactic and semantic processing and a compiler back end which typically performs optimizations and code generations.
- the front end produces an initial IR which is input to the back end.
- the back end initially produces a compact intermediate representation thereby limiting or restricting the number of IR opcodes which it must analyze.
- the optimizer then transforms the compact intermediate representation and produces an optimized intermediate representation.
- the code generator subsequently generates a final intermediate representation from the optimized intermediate representation.
- the final intermediate representation has the property that its opcodes correspond directly to instructions in the destination instruction set. If an opcode that is typically included in the final intermediate representation appeared in the foregoing compact intermediate representation, an error in translation results. Given this typical organization of a compiler with the foregoing restrictions, the compiler itself is generally unable to interchange optimization steps with translation steps due to processing restrictions.
- the binary translator of the invention does not impose such undue restrictions on the IR. Thus, the binary translator can perform substeps of optimization and translation in an efficient order without undue restrictions.
- Step 858 of FIG. 63 performs floating point (FP) register stack addressing processing.
- the CISC instruction set in binary image 17b includes floating point instructions having implicit operands on the stack.
- the stack was previously discussed in conjunction with early FP peephole optimization processing.
- the RISC instruction set does not have implicit stack operand instructions.
- the CISC instructions performing floating point register stack addressing must be transformed into an equivalent item in the RISC instruction set.
- the first of the foregoing instructions loads or pushes the first operand register EA1's contents onto the stack.
- the second instruction also pushes the content of operand register EA2 onto the stack placing the content in a memory location indicated by the address in the stack register.
- the third instruction performs a floating point add (FADDP) and pushes the result of the floating point addition onto the stack.
- FADDP floating point add
- the effect of the FADDP instruction is that the two operands EA1 and EA2 previously pushed on the stack are popped off, and replaced with an arithmetic result that is a single floating point number.
- the fourth instruction FST stores the result from the stack placing it in EA3.
- the fourth instruction pops the top value off of the stack returning the stack to its original position prior to the foregoing sequence of four instructions.
- the stack is an implicit operand in each of these four instructions.
- the Alpha RISC instruction set, associated with the translated image 17c, does not have similar floating point register stack addressing operands or equivalent instructions.
- the IR is considered to be well-formed in that peculiarities particular to the CISC instruction set, such as implicit FP stack operands, partial register operands, and condition codes, have been removed.
- the IR resembles a series of RISC instructions.
- IR operands are register operands or constants. There are no more memory operands.
- added instructions for example, as a result of condition code processing or register processing, are either pseudo instructions or closely resemble the RISC instructions that will comprise the translated binary image 17c.
- steps 852 through 858 of a preferred implementation do not add opcodes or replace existing opcodes with other opcodes having a direct correlation to the binary image 17b currently being translated.
- steps comprising local basic block and global routine optimization processing 860 are set forth.
- those optimizations which are performed per basic block are referred to as local optimizations
- those optimizations which are performed as between basic blocks are referred to as global optimizations.
- step 910 Local peephole optimizations are performed, as in step 910.
- a peephole optimization searches for a particular pattern or sequence of instructions and replaces those instructions with other instructions deemed to be more efficient.
- a peephole technique was applied to translations of step 856 performing floating point optimization processing.
- the peephole technique accomplishes more than an optimization.
- the peephole technique is used for translating a series of CISC instructions to a single RISC instruction.
- the focus is optimization processing because of the prior translation steps already performed.
- common subexpression elimination is performed per basic block.
- common subexpression elimination a subexpression is identified which produces a result. This subexpression is used multiple times within the translation unit or program.
- the optimization generally identifies the common subexpression, computes its result in one statement, and rather than use the entire expression in repeated locations, substitutes each repeated occurrence of the subexpression with the result as computed by the first statement.
- Dead code elimination is performed for the translation unit, as in step 914. Dead code elimination involves identifying and removing those segments of code which can never be reached as by a section of code which is always branched around or has no entry point.
- step 916 constant propagation is performed for a translation unit. Constant propagation typically involves operations with constants.
- constant propagation for example, is in the computation of addresses of subscripted variables when the subscript values can be determined earlier at compile time.
- step 918 inlining is performed for the translation unit. The inlining optimization of step 918 replaces a call to a routine, for example, with the instructions comprising the routine. The instructions of the routine are included in line rather than the call to the routine.
- a preferred implementation repeats local optimization 910 processing and dead code elimination 912.
- Repeating certain optimizations can be beneficial in that repeating an earlier optimization can result in a better IR that has subsequently been effected by a later optimization.
- repeating local peephole optimization, as in step 910 can be beneficial because additional code has been included as a result of inlining as in step 918.
- the specific optimizations which an implementation chooses to perform is highly dependent upon the IR representation and the previous translations and transformations which have occurred.
- a substep of translation and optimization processing is exception handler processing.
- an initial determination was made as to whether or not an instruction is capable of generating a run time exception.
- Each IR instruction was previously examined in step 810 and a determination was made as to whether a corresponding machine instruction, if executed, could generate a run time exception. In this prior processing the determination was made solely by examining the IR opcode. A translator can more specifically determine if an exception can occur by examining the associated operands.
- code selection and operand processing (step 864 of FIG. 63) is set forth in detail.
- the code selection and operand processing perform remaining transformations needed to place IR instruction opcodes and operands in a direct correspondence with machine instructions that comprise the instruction set of the architecture of the computer system 10 and hence provide the native image 17c.
- any remaining source IR instruction opcodes are replaced with target IR instruction opcodes.
- a source IR instruction opcode has a direct correspondence with a machine instruction in the binary image 17b.
- each of the IR instruction code ,cells correspond to a 64 bit length instruction performing a 64 bit data operation.
- Step 922 can be accomplished using a pattern driven instruction look-up and replacement technique using a table which maps a source instruction opcode to one or more corresponding target IR instruction opcodes.
- the RISC architecture when translating a CISC operand to a RISC operand, the RISC architecture requires that the 32-bit CISC operands be transformed to corresponding 64-bit RISC operands. Additionally, in this specific translation, the high order 32 bits of each corresponding 64-bit RISC operand are sign extended.
- This processing step uses local data flow and global data flow information, as can be determined using the two level data flow analysis technique, to locate definitions and uses of operands to determine if a particular operand has been properly sign extended.
- intra image call processing is performed.
- An intra image call is a call made from one translation unit to another translation unit wherein both translation units are within the binary image being translated 17b.
- Step 928 is performed as a "catch all" step performing any remaining miscellaneous processing necessary to remove source dependencies from the IR placing the IR in a final routine form such that no opcodes included in an IR instruction code cell have a direct correspondence to an instruction in the non-native binary image 17b.
- the IR in final routine form produced as a result of step 928 comprises IR instruction code cells which correspond directly to machine instructions associated with the instruction set of the computer system 10 to provide native binary image 17c.
- step 930 a determination is made as to whether a call is an intra image call (YES decision) or an inter image call (NO decision).
- An inter image call performs a call to a routine in another translation unit.
- An intra-image call is a call from one translation unit or routine to another routine within the same binary image being translated.
- step 930 If a determination is made at step 930 that the current call is an interimage call, run time intervention is required by the run time interpreter to transfer control to the called routine. As such, there is no special processing performed with the current call. Control proceeds to step 932 and the next call is examined.
- step 934 provisions are made for direct run time execution transfer to the called translation unit.
- one type of call is a PC (program counter) relative call in which the address of the called routine is represented by displacement relative to the instruction currently being executed.
- the effective address of the called routine is formed by adding the run time address of a program counter register plus and offset.
- the program counter register contains the address of the instruction following the call instruction.
- the offset represents a byte displacement.
- the binary image translator and optimizer 802 determine a correct translated displacement value for the called routine within the native binary image 17c.
- a first target address within the non-native binary image 17b corresponding to the called routine is determined.
- the translator and optimizer 802 map the addresses of the CISC call instruction and the called routine within the binary image 17b, respectively, to first and second translated addresses within the translated binary image 17c. By determining the difference between these two translated addresses, the translated displacement is determined representing the displacement between the calling instruction and the called routine in the translated binary image 17c. Modifications are made to the IR code cell corresponding to the call instruction by including the translated displacement value.
- step 934 After completing step 934, control proceeds to step 936 where the next call is examined. Processing resumes with step 930.
- step 872 of FIG. 63 exception handler tables are generated to provide for proper run time control if an instruction in the translated binary image when executed generates a run time exception.
- FIG. 71A a diagram of a translated binary image 17c and its corresponding non-native binary image 17b are shown.
- the non-native image 17b has a floating point add (FADD) instruction 938.
- the binary image translator and optimizer 802 produce an equivalent instruction ADDT 940 in the translated binary image 17c.
- the translated instructions 940 can produce a run time exception, such as a floating point divide by 0 error, depending on the operand values at run-time.
- An exception handler is typically invoked when such a run-time condition occurs.
- the translated binary image 17c includes user exception handler tables 942 and translated exception tables 944.
- the user exception handler table 942 identifies a user routine address or handler to which control is transferred when a run-time exception occurs within a user routine or translation unit.
- the translator exception table 944 is used by the binary translation run-time system when an exception occurs as will be explained in following text.
- the translator exception table 944 comprises one or more table entries.
- the table entry within the translator exception table 944 includes a first binary image address 946a, a count field 946b followed by one or more pairs of a CISC resource 946c and a corresponding RISC resource 946d.
- the first binary image address 946a corresponds to an address within the image 17b.
- the count field 946b indicates the number of resource pairs 946c to 946d that follow.
- the pairs of resource entries 946c and 946d identify, respectively, a CISC resource and a corresponding RISC resource. These entries are used at run time as will be described in conjunction with FIG. 71C.
- a run time exception can occur when executing a translated binary image 17c, as with the ADDT instruction 940.
- run time control passes to a standard portion of the operating system such as the RISC handler 948.
- the RISC handler reads the user exception handler tables 942 to obtain the address of a user specified handler to which run time control is transferred.
- the RISC handler 948 reads an address identifying a translator run time handler routine 950.
- the translator run time handler 950 is included as part of the binary translation system.
- the binary image translator and optimizer 802 when generating a translated binary image 17c, place the address of the translator run time handler routine 950 in the user exception handler table included in the translated binary image 17c.
- the user exception handler table is typically a standard part of an object file format of the translated binary image.
- the translator run time handler routine 950 is a special routine included as part of the binary image translator.
- the translator run time handler 950 uses the information contained in the translator exception table 944 to map a RISC resource as included in the non-native binary image 17c to a CISC resource.
- the translator run time handler 950 transfers control to the appropriate CISC exception handler 952. At this point control transfers to the run-time system 32 to determine if the CISC exception handler 952 is translated, or if the run time interpreter must be invoked to execute the CISC exception handler 952.
- step 810 the intermediate data structures created and used by the binary image translator and optimizer 802 typically use a large amount of memory and additional computer system resources.
- the steps of performing translation and optimization, as set forth in FIG. 63, and their particular order, as performed within a binary image transformer 800, are particularly dependent upon the instruction set of the non-native binary image 17b and the other machine instruction set of the translated binary image 17c.
- special processing steps 852 through 858 are highly dependent upon the source instruction set used in the binary image 17b.
- step 856 which performs floating point optimization processing is highly dependent upon the instruction sets of both the non-native binary image 17b and the translated binary image 17c.
- the particular optimization steps and their respective order included, as in step 860, will typically vary with implementation enabling production of an efficiently executing binary translated image 17c.
- An embodiment of the binary image transformer 800 may have only a portion of the planned functionality implemented and can still be used in binary translation.
- a portion of the background translator and optimizer 802 may not be implemented.
- one implementation of the binary image transformer does not perform processing for a floating point instruction in the CISC instruction set.
- the native binary image 17c does not comprise any translated floating point instructions.
- the run-time system always provides for interpretation of floating point instructions and control passed to the run-time interpreter for these instructions.
- the binary image transformer contains special processing to ignore floating point instructions during the translation process. Such instructions would then be interpreted.
- the foregoing technique is flexible in that the steps of optimization and translation can be intermixed and performed in a variety of different orderings.
- the intermediate representation affords this flexibility by not imposing undue restrictions or making assumptions about the state of an intermediate representation at various points during translation and optimization.
- the foregoing intermediate representation decreases development and maintenance costs associated with a binary translation process.
- the foregoing single intermediate representation used throughout the binary translation process is a single IR having opcodes corresponding to both source and destination instruction sets. Since a single IR is used throughout the translation process, common service routines operating on the IR can be used throughout the binary translation process as contrasted with a more costly binary translation process having various IRs requiring multiple corresponding sets of service routines operating on the various IRs.
Abstract
Description
TABLE I __________________________________________________________________________ Next CC Most Recent CC State State ALL.sub.-- BUT.sub.-- C ONLY.sub.-- C C.sub.-- AND.sub.-- O ONLY.sub.-- Z ALL __________________________________________________________________________ ALL.sub.-- BUT.sub.-- C replace push push replace push ONLY.sub.-- C push replace resolve resolve push C.sub.-- AND.sub.-- O push replace replace resolve push ONLY.sub.-- Z resolve resolve resolve replace push ALL replace replace replace replace replace __________________________________________________________________________
______________________________________ LDQ T2, 8(T.sub.0) Loads both gEIP and gBSP SLL T1, #32, T1 The actual ESP before popping the non-native return address OR EIP, T1, T1, The actual EIP and ESP in a quad word SUBQ T1, T2, T1 Load the native return LDL T3, 4(T.sub.0) address in case it is needed BNE T1, $1 Actual discarded shadow frame MOV T0, SP RET (T3,) ______________________________________
TABLE II ______________________________________ Code Environment Replacement Code Environment Where Interface Interface Where Interface Referenced Signature Created ______________________________________ Architecture B PAJB Architecture A Architecture A PAJB Architecture A Architecture B PBJA Architecture B Architecture A PBJA Architecture B ______________________________________
______________________________________ Field Name Value: ______________________________________ NON-NATIVE.sub.-- ADDRESS.sub.-- OF.sub.-- X INDIRECT.sub.-- TRANSFER.sub.-- INSTRUCTION NUM.sub.-- UNIQUE.sub.-- TARGET.sub.-- ADDRESSES 5 TARGET.sub.-- ADDRESS.sub.-- LIST Y.sub.0 Y.sub.1 Y.sub.2 Y.sub.3 Y.sub.4, each Y.sub.n representing a target address ______________________________________
______________________________________ 1 FLD EA1 /*push EA1 on stack */ 2 FLD EA2 /*push EA2 on stack */ 3 FADDP /*add two top stack elements, push .sup. result */ 4 FST EA3 /* store result in EA3 */ ______________________________________
Claims (18)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US08/593,286 US6000028A (en) | 1996-01-29 | 1996-01-29 | Means and apparatus for maintaining condition codes in an unevaluated state |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US08/593,286 US6000028A (en) | 1996-01-29 | 1996-01-29 | Means and apparatus for maintaining condition codes in an unevaluated state |
Publications (1)
Publication Number | Publication Date |
---|---|
US6000028A true US6000028A (en) | 1999-12-07 |
Family
ID=24374158
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US08/593,286 Expired - Lifetime US6000028A (en) | 1996-01-29 | 1996-01-29 | Means and apparatus for maintaining condition codes in an unevaluated state |
Country Status (1)
Country | Link |
---|---|
US (1) | US6000028A (en) |
Cited By (32)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6230310B1 (en) * | 1998-09-29 | 2001-05-08 | Apple Computer, Inc., | Method and system for transparently transforming objects for application programs |
US6243864B1 (en) * | 1997-07-17 | 2001-06-05 | Matsushita Electric Industrial Co., Ltd. | Compiler for optimizing memory instruction sequences by marking instructions not having multiple memory address paths |
US6279150B1 (en) * | 1997-09-01 | 2001-08-21 | Siemens Nixdorf Informationssysteme Aktiengesellschaft | Method for converting an object code into a program code |
US20020166016A1 (en) * | 2001-05-02 | 2002-11-07 | International Business Machines Corporation | Efficient locking for thread-safe self-modifying code |
US6486897B1 (en) * | 1998-09-29 | 2002-11-26 | Apple Computer, Inc. | Multi-repository display system using separate presentation, adaptation and access layers |
US20020184618A1 (en) * | 2001-06-04 | 2002-12-05 | Vasanth Bala | Networked client-server architecture for transparently transforming and executing applications |
US6516405B1 (en) * | 1999-12-30 | 2003-02-04 | Intel Corporation | Method and system for safe data dependency collapsing based on control-flow speculation |
EP1377034A1 (en) * | 2002-06-27 | 2004-01-02 | Thomson Licensing S.A. | Data processing device and method for interactive television |
US6763452B1 (en) | 1999-01-28 | 2004-07-13 | Ati International Srl | Modifying program execution based on profiling |
US20040158822A1 (en) * | 2002-02-06 | 2004-08-12 | Sandham John H. | Condition code flag emulation for program code conversion |
US6779107B1 (en) | 1999-05-28 | 2004-08-17 | Ati International Srl | Computer execution by opportunistic adaptation |
US6789181B1 (en) | 1999-01-28 | 2004-09-07 | Ati International, Srl | Safety net paradigm for managing two computer execution modes |
US20040176941A1 (en) * | 2003-03-04 | 2004-09-09 | Shan-Chyun Ku | Method of simulating computation instructions for an instruction set simulator |
US20050060689A1 (en) * | 2003-09-11 | 2005-03-17 | International Business Machines Corporation | Method, apparatus, and computer program product for implementing enhanced debugger graphical user interface functions |
US6954923B1 (en) | 1999-01-28 | 2005-10-11 | Ati International Srl | Recording classification of instructions executed by a computer |
US7013456B1 (en) | 1999-01-28 | 2006-03-14 | Ati International Srl | Profiling execution of computer programs |
US20060294508A1 (en) * | 2005-06-27 | 2006-12-28 | Intel Corporation | Apparatus, system, and method of dynamic binary translation supporting a denormal input handling mechanism |
US7275246B1 (en) * | 1999-01-28 | 2007-09-25 | Ati International Srl | Executing programs for a first computer architecture on a computer of a second architecture |
US20070240135A1 (en) * | 2006-03-09 | 2007-10-11 | Stoodley Kevin A | Programmatic compiler optimization of glacial constants |
US7319700B1 (en) * | 2000-12-29 | 2008-01-15 | Juniper Networks, Inc. | Communicating constraint information for determining a path subject to such constraints |
US20080115132A1 (en) * | 2006-07-31 | 2008-05-15 | Infineon Technologies Ag | Data processing device and method for monitoring correct operation of a data processing device |
US20080177985A1 (en) * | 2002-02-06 | 2008-07-24 | Transitive Limited | Condition code flag emulation for program code conversion |
US7941647B2 (en) | 1999-01-28 | 2011-05-10 | Ati Technologies Ulc | Computer for executing two instruction sets and adds a macroinstruction end marker for performing iterations after loop termination |
US8065504B2 (en) | 1999-01-28 | 2011-11-22 | Ati International Srl | Using on-chip and off-chip look-up tables indexed by instruction address to control instruction execution in a processor |
US8074055B1 (en) | 1999-01-28 | 2011-12-06 | Ati Technologies Ulc | Altering data storage conventions of a processor when execution flows from first architecture code to second architecture code |
US8127121B2 (en) | 1999-01-28 | 2012-02-28 | Ati Technologies Ulc | Apparatus for executing programs for a first computer architechture on a computer of a second architechture |
US8631395B2 (en) | 2011-09-02 | 2014-01-14 | Microsoft Corporation | Inter-procedural dead catch handler optimizations |
US20150006866A1 (en) * | 2013-06-28 | 2015-01-01 | International Business Machines Corporation | Optimization of instruction groups across group boundaries |
US20160006714A1 (en) * | 2005-04-22 | 2016-01-07 | Microsoft Technology Licensing, Llc | Protected media pipeline |
US9348596B2 (en) | 2013-06-28 | 2016-05-24 | International Business Machines Corporation | Forming instruction groups based on decode time instruction optimization |
US20170085663A1 (en) * | 2015-09-17 | 2017-03-23 | International Business Machines Corporation | Passing data streams between remote cooperating systems |
US11966727B2 (en) | 2016-03-11 | 2024-04-23 | Lzlabs Gmbh | Load module compiler |
Citations (16)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4914581A (en) * | 1987-10-26 | 1990-04-03 | Motorola, Inc. | Method and apparatus for explicitly evaluating conditions in a data processor |
US5287490A (en) * | 1991-03-07 | 1994-02-15 | Digital Equipment Corporation | Identifying plausible variable length machine code of selecting address in numerical sequence, decoding code strings, and following execution transfer paths |
US5301325A (en) * | 1991-03-07 | 1994-04-05 | Digital Equipment Corporation | Use of stack depth to identify architechture and calling standard dependencies in machine code |
US5307492A (en) * | 1991-03-07 | 1994-04-26 | Digital Equipment Corporation | Mapping assembly language argument list references in translating code for different machine architectures |
US5307504A (en) * | 1991-03-07 | 1994-04-26 | Digital Equipment Corporation | System and method for preserving instruction granularity when translating program code from a computer having a first architecture to a computer having a second reduced architecture during the occurrence of interrupts due to asynchronous events |
US5317740A (en) * | 1991-03-07 | 1994-05-31 | Digital Equipment Corporation | Alternate and iterative analysis of computer programs for locating translatable code by resolving callbacks and other conflicting mutual dependencies |
US5339238A (en) * | 1991-03-07 | 1994-08-16 | Benson Thomas R | Register usage tracking in translating code for different machine architectures by forward and reverse tracing through the program flow graph |
US5339422A (en) * | 1991-03-07 | 1994-08-16 | Digital Equipment Corporation | System and method for jacketing cross-domain calls in a multi-code execution and debugging system within a multi-architecture environment |
US5428786A (en) * | 1991-03-07 | 1995-06-27 | Digital Equipment Corporation | Branch resolution via backward symbolic execution |
US5432795A (en) * | 1991-03-07 | 1995-07-11 | Digital Equipment Corporation | System for reporting errors of a translated program and using a boundry instruction bitmap to determine the corresponding instruction address in a source program |
US5450575A (en) * | 1991-03-07 | 1995-09-12 | Digital Equipment Corporation | Use of stack depth to identify machine code mistakes |
US5507030A (en) * | 1991-03-07 | 1996-04-09 | Digitial Equipment Corporation | Successive translation, execution and interpretation of computer program having code at unknown locations due to execution transfer instructions having computed destination addresses |
US5551015A (en) * | 1988-12-06 | 1996-08-27 | Lucent Technologies Inc. | Method and apparatus for direct conversion of programs in object code form between different hardware architecture computer systems |
US5564050A (en) * | 1992-06-25 | 1996-10-08 | International Business Machines Corporation | System and method for enabling an interpreted programming language to be executed in a database management system environment |
US5574927A (en) * | 1994-03-25 | 1996-11-12 | International Meta Systems, Inc. | RISC architecture computer configured for emulation of the instruction set of a target computer |
US5598560A (en) * | 1991-03-07 | 1997-01-28 | Digital Equipment Corporation | Tracking condition codes in translation code for different machine architectures |
-
1996
- 1996-01-29 US US08/593,286 patent/US6000028A/en not_active Expired - Lifetime
Patent Citations (16)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4914581A (en) * | 1987-10-26 | 1990-04-03 | Motorola, Inc. | Method and apparatus for explicitly evaluating conditions in a data processor |
US5551015A (en) * | 1988-12-06 | 1996-08-27 | Lucent Technologies Inc. | Method and apparatus for direct conversion of programs in object code form between different hardware architecture computer systems |
US5307504A (en) * | 1991-03-07 | 1994-04-26 | Digital Equipment Corporation | System and method for preserving instruction granularity when translating program code from a computer having a first architecture to a computer having a second reduced architecture during the occurrence of interrupts due to asynchronous events |
US5432795A (en) * | 1991-03-07 | 1995-07-11 | Digital Equipment Corporation | System for reporting errors of a translated program and using a boundry instruction bitmap to determine the corresponding instruction address in a source program |
US5301325A (en) * | 1991-03-07 | 1994-04-05 | Digital Equipment Corporation | Use of stack depth to identify architechture and calling standard dependencies in machine code |
US5317740A (en) * | 1991-03-07 | 1994-05-31 | Digital Equipment Corporation | Alternate and iterative analysis of computer programs for locating translatable code by resolving callbacks and other conflicting mutual dependencies |
US5339238A (en) * | 1991-03-07 | 1994-08-16 | Benson Thomas R | Register usage tracking in translating code for different machine architectures by forward and reverse tracing through the program flow graph |
US5339422A (en) * | 1991-03-07 | 1994-08-16 | Digital Equipment Corporation | System and method for jacketing cross-domain calls in a multi-code execution and debugging system within a multi-architecture environment |
US5428786A (en) * | 1991-03-07 | 1995-06-27 | Digital Equipment Corporation | Branch resolution via backward symbolic execution |
US5307492A (en) * | 1991-03-07 | 1994-04-26 | Digital Equipment Corporation | Mapping assembly language argument list references in translating code for different machine architectures |
US5450575A (en) * | 1991-03-07 | 1995-09-12 | Digital Equipment Corporation | Use of stack depth to identify machine code mistakes |
US5507030A (en) * | 1991-03-07 | 1996-04-09 | Digitial Equipment Corporation | Successive translation, execution and interpretation of computer program having code at unknown locations due to execution transfer instructions having computed destination addresses |
US5287490A (en) * | 1991-03-07 | 1994-02-15 | Digital Equipment Corporation | Identifying plausible variable length machine code of selecting address in numerical sequence, decoding code strings, and following execution transfer paths |
US5598560A (en) * | 1991-03-07 | 1997-01-28 | Digital Equipment Corporation | Tracking condition codes in translation code for different machine architectures |
US5564050A (en) * | 1992-06-25 | 1996-10-08 | International Business Machines Corporation | System and method for enabling an interpreted programming language to be executed in a database management system environment |
US5574927A (en) * | 1994-03-25 | 1996-11-12 | International Meta Systems, Inc. | RISC architecture computer configured for emulation of the instruction set of a target computer |
Non-Patent Citations (22)
Title |
---|
"Adaptive Systems for the Dynamic Run-Time Optimization of Programs", G. Hansen, Carnegie-Mellon University, Mar., 1974, pp. 1-171. |
"Binary Translation", Richard L. Sites et al., Digital Technical Journal, pp. 137-152. |
"Compiler Design Theory", P. Lewis, II et al., pp. 559-568. |
"Compilers: Principles, Techniques and Tools", A. Aho et al., Computer Science, pp. 527-647. |
"Data Flow Analysis for `Intractable` Imbedded System Software", H. Johnson, pp. 109-115. |
"Data Structures and Algorithms", A. Aho et al., Computer Science and Information Processing, pp. 110-117. |
"Efficiently Computing Static Single Assignment Form and the Control Dependence Graph", R. Cytron et al., ACM Transactions on Programming Language and Systems, vol. 13, No. 4, Oct., 1991, pp. 451-490. |
"Method and Apparatus for Direct Conversion of Programs in Object Code Form Between Different Hardware Architecture Computer Systems", J. Goettelmann et al., pp. 3-37. |
Adaptive Systems for the Dynamic Run Time Optimization of Programs , G. Hansen, Carnegie Mellon University, Mar., 1974, pp. 1 171. * |
Binary Translation , Richard L. Sites et al., Digital Technical Journal, pp. 137 152. * |
Compiler Design Theory , P. Lewis, II et al., pp. 559 568. * |
Compilers: Principles, Techniques and Tools , A. Aho et al., Computer Science, pp. 527 647. * |
Data Flow Analysis for Intractable Imbedded System Software , H. Johnson, pp. 109 115. * |
Data Structures and Algorithms , A. Aho et al., Computer Science and Information Processing, pp. 110 117. * |
Efficiently Computing Static Single Assignment Form and the Control Dependence Graph , R. Cytron et al., ACM Transactions on Programming Language and Systems, vol. 13, No. 4, Oct., 1991, pp. 451 490. * |
Method and Apparatus for Direct Conversion of Programs in Object Code Form Between Different Hardware Architecture Computer Systems , J. Goettelmann et al., pp. 3 37. * |
U.S. application No. 07/665,888, filed Mar. 7, 1991. * |
U.S. application No. 07/666,028, filed Mar. 7, 1991. * |
U.S. application No. 07/666,039, filed Mar. 7, 1991. * |
U.S. application No. 07/666,072, filed Mar. 7, 1991. * |
U.S. application No. 07/667,071, filed Mar. 7, 1991. * |
U.S. application No. 08/580,686, filed Dec. 29, 1995. * |
Cited By (64)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6243864B1 (en) * | 1997-07-17 | 2001-06-05 | Matsushita Electric Industrial Co., Ltd. | Compiler for optimizing memory instruction sequences by marking instructions not having multiple memory address paths |
US6279150B1 (en) * | 1997-09-01 | 2001-08-21 | Siemens Nixdorf Informationssysteme Aktiengesellschaft | Method for converting an object code into a program code |
US20030071854A1 (en) * | 1998-09-29 | 2003-04-17 | Yan Arrouye | Multi-repository display system using separate presentation, adaptation and access layers |
US6230310B1 (en) * | 1998-09-29 | 2001-05-08 | Apple Computer, Inc., | Method and system for transparently transforming objects for application programs |
US6486897B1 (en) * | 1998-09-29 | 2002-11-26 | Apple Computer, Inc. | Multi-repository display system using separate presentation, adaptation and access layers |
US7669145B2 (en) | 1998-09-29 | 2010-02-23 | Apple Inc. | Multi-repository display system using separate presentation, adaption and access layers |
US8122380B2 (en) | 1998-09-29 | 2012-02-21 | Apple Inc. | Multi-repository display system using separate presentation, adaptation and access layers |
US20030071857A1 (en) * | 1998-09-29 | 2003-04-17 | Yan Arrouye | Multi-repository display system using separate presentation, adaptation and access layers |
US8127121B2 (en) | 1999-01-28 | 2012-02-28 | Ati Technologies Ulc | Apparatus for executing programs for a first computer architechture on a computer of a second architechture |
US8121828B2 (en) | 1999-01-28 | 2012-02-21 | Ati Technologies Ulc | Detecting conditions for transfer of execution from one computer instruction stream to another and executing transfer on satisfaction of the conditions |
US8074055B1 (en) | 1999-01-28 | 2011-12-06 | Ati Technologies Ulc | Altering data storage conventions of a processor when execution flows from first architecture code to second architecture code |
US8065504B2 (en) | 1999-01-28 | 2011-11-22 | Ati International Srl | Using on-chip and off-chip look-up tables indexed by instruction address to control instruction execution in a processor |
US7941647B2 (en) | 1999-01-28 | 2011-05-10 | Ati Technologies Ulc | Computer for executing two instruction sets and adds a macroinstruction end marker for performing iterations after loop termination |
US6763452B1 (en) | 1999-01-28 | 2004-07-13 | Ati International Srl | Modifying program execution based on profiling |
US6954923B1 (en) | 1999-01-28 | 2005-10-11 | Ati International Srl | Recording classification of instructions executed by a computer |
US8788792B2 (en) | 1999-01-28 | 2014-07-22 | Ati Technologies Ulc | Apparatus for executing programs for a first computer architecture on a computer of a second architecture |
US6789181B1 (en) | 1999-01-28 | 2004-09-07 | Ati International, Srl | Safety net paradigm for managing two computer execution modes |
US7275246B1 (en) * | 1999-01-28 | 2007-09-25 | Ati International Srl | Executing programs for a first computer architecture on a computer of a second architecture |
US6826748B1 (en) | 1999-01-28 | 2004-11-30 | Ati International Srl | Profiling program execution into registers of a computer |
US7013456B1 (en) | 1999-01-28 | 2006-03-14 | Ati International Srl | Profiling execution of computer programs |
US6779107B1 (en) | 1999-05-28 | 2004-08-17 | Ati International Srl | Computer execution by opportunistic adaptation |
US7284116B2 (en) * | 1999-12-30 | 2007-10-16 | Intel Corporation | Method and system for safe data dependency collapsing based on control-flow speculation |
US6516405B1 (en) * | 1999-12-30 | 2003-02-04 | Intel Corporation | Method and system for safe data dependency collapsing based on control-flow speculation |
US20030154362A1 (en) * | 1999-12-30 | 2003-08-14 | Jourdan Stephan J. | Method and system for safe data dependency collapsing based on control-flow speculation |
US7948996B2 (en) * | 2000-12-29 | 2011-05-24 | Juniper Networks | Communicating constraint information for determining a path subject to such constraints |
US20080084890A1 (en) * | 2000-12-29 | 2008-04-10 | Kireeti Kompella | Communicating constraint information for determining a path subject to such constraints |
US7319700B1 (en) * | 2000-12-29 | 2008-01-15 | Juniper Networks, Inc. | Communicating constraint information for determining a path subject to such constraints |
US20020166016A1 (en) * | 2001-05-02 | 2002-11-07 | International Business Machines Corporation | Efficient locking for thread-safe self-modifying code |
US7185337B2 (en) * | 2001-05-07 | 2007-02-27 | International Business Machines Corporation | Efficient locking for thread-safe self-modifying code |
US20020184618A1 (en) * | 2001-06-04 | 2002-12-05 | Vasanth Bala | Networked client-server architecture for transparently transforming and executing applications |
US7640153B2 (en) * | 2001-06-04 | 2009-12-29 | Hewlett-Packard Development Company, L.P. | Networked client-server architecture for transparently transforming and executing applications |
US20040158822A1 (en) * | 2002-02-06 | 2004-08-12 | Sandham John H. | Condition code flag emulation for program code conversion |
US8024555B2 (en) | 2002-02-06 | 2011-09-20 | International Business Machines Corporation | Condition code flag emulation for program code conversion |
US7331040B2 (en) | 2002-02-06 | 2008-02-12 | Transitive Limted | Condition code flag emulation for program code conversion |
US20080177985A1 (en) * | 2002-02-06 | 2008-07-24 | Transitive Limited | Condition code flag emulation for program code conversion |
US20050229232A1 (en) * | 2002-06-27 | 2005-10-13 | Thomson Licensing S.A. | Data processing device and method for interactive television |
WO2004003740A2 (en) * | 2002-06-27 | 2004-01-08 | Thomson Licensing Sa | A data processing device and method for interactive television |
WO2004003740A3 (en) * | 2002-06-27 | 2004-04-08 | Thomson Licensing Sa | A data processing device and method for interactive television |
EP1377034A1 (en) * | 2002-06-27 | 2004-01-02 | Thomson Licensing S.A. | Data processing device and method for interactive television |
US20040176941A1 (en) * | 2003-03-04 | 2004-09-09 | Shan-Chyun Ku | Method of simulating computation instructions for an instruction set simulator |
US20050060689A1 (en) * | 2003-09-11 | 2005-03-17 | International Business Machines Corporation | Method, apparatus, and computer program product for implementing enhanced debugger graphical user interface functions |
US7251808B2 (en) * | 2003-09-11 | 2007-07-31 | International Business Machines Corporation | Graphical debugger with loadmap display manager and custom record display manager displaying user selected customized records from bound program objects |
US20160006714A1 (en) * | 2005-04-22 | 2016-01-07 | Microsoft Technology Licensing, Llc | Protected media pipeline |
US20060294508A1 (en) * | 2005-06-27 | 2006-12-28 | Intel Corporation | Apparatus, system, and method of dynamic binary translation supporting a denormal input handling mechanism |
US7363471B2 (en) * | 2005-06-27 | 2008-04-22 | Intel Corporation | Apparatus, system, and method of dynamic binary translation supporting a denormal input handling mechanism |
US7840950B2 (en) | 2006-03-09 | 2010-11-23 | International Business Machines Corporation | Programmatic compiler optimization of glacial constants |
US20070240135A1 (en) * | 2006-03-09 | 2007-10-11 | Stoodley Kevin A | Programmatic compiler optimization of glacial constants |
US20080115132A1 (en) * | 2006-07-31 | 2008-05-15 | Infineon Technologies Ag | Data processing device and method for monitoring correct operation of a data processing device |
US20100042995A9 (en) * | 2006-07-31 | 2010-02-18 | Infineon Technologies Ag | Data processing device and method for monitoring correct operation of a data processing device |
US7689874B2 (en) * | 2006-07-31 | 2010-03-30 | Infineon Technologies Ag | Data processing device and method for monitoring correct operation of a data processing device |
US8631395B2 (en) | 2011-09-02 | 2014-01-14 | Microsoft Corporation | Inter-procedural dead catch handler optimizations |
US9678757B2 (en) | 2013-06-28 | 2017-06-13 | International Business Machines Corporation | Forming instruction groups based on decode time instruction optimization |
US9348596B2 (en) | 2013-06-28 | 2016-05-24 | International Business Machines Corporation | Forming instruction groups based on decode time instruction optimization |
US9361108B2 (en) | 2013-06-28 | 2016-06-07 | International Business Machines Corporation | Forming instruction groups based on decode time instruction optimization |
US9372695B2 (en) * | 2013-06-28 | 2016-06-21 | Globalfoundries Inc. | Optimization of instruction groups across group boundaries |
US9477474B2 (en) | 2013-06-28 | 2016-10-25 | Globalfoundries Inc. | Optimization of instruction groups across group boundaries |
US9678756B2 (en) | 2013-06-28 | 2017-06-13 | International Business Machines Corporation | Forming instruction groups based on decode time instruction optimization |
US20150006866A1 (en) * | 2013-06-28 | 2015-01-01 | International Business Machines Corporation | Optimization of instruction groups across group boundaries |
US20170085663A1 (en) * | 2015-09-17 | 2017-03-23 | International Business Machines Corporation | Passing data streams between remote cooperating systems |
US9923985B2 (en) * | 2015-09-17 | 2018-03-20 | International Business Machines Corporation | Facilitating an efficient exchange of streaming data constructs between origin and target systems while making remote procedure calls |
US10069927B2 (en) * | 2015-09-17 | 2018-09-04 | International Business Machines Corporation | Facilitating an efficient exchange of streaming data constructs between origin and target systems while making remote procedure calls |
US20180324267A1 (en) * | 2015-09-17 | 2018-11-08 | International Business Machines Corporation | Passing data streams between remote cooperating systems |
US10581994B2 (en) * | 2015-09-17 | 2020-03-03 | International Business Machines Corporation | Facilitating communication between an origin machine and a target machine |
US11966727B2 (en) | 2016-03-11 | 2024-04-23 | Lzlabs Gmbh | Load module compiler |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US5802373A (en) | Method for providing a pipeline interpreter for a variable length instruction set | |
US5930509A (en) | Method and apparatus for performing binary translation | |
US6091897A (en) | Fast translation and execution of a computer program on a non-native architecture by use of background translator | |
US5842017A (en) | Method and apparatus for forming a translation unit | |
US6000028A (en) | Means and apparatus for maintaining condition codes in an unevaluated state | |
US6226789B1 (en) | Method and apparatus for data flow analysis | |
US6535903B2 (en) | Method and apparatus for maintaining translated routine stack in a binary translation environment | |
US6199095B1 (en) | System and method for achieving object method transparency in a multi-code execution environment | |
US6164841A (en) | Method, apparatus, and product for dynamic software code translation system | |
US5963740A (en) | System for monitoring computer system performance | |
Fitzgerald et al. | Marmot: An optimizing compiler for Java | |
Cheung et al. | Sloth: Being lazy is a virtue (when issuing database queries) | |
US5956512A (en) | Computer program debugging in the presence of compiler synthesized variables | |
US8141064B2 (en) | Method and system for program transformation using flow-sensitive type constraint analysis | |
US6481008B1 (en) | Instrumentation and optimization tools for heterogeneous programs | |
US6311324B1 (en) | Software profiler which has the ability to display performance data on a computer screen | |
US20020199179A1 (en) | Method and apparatus for compiler-generated triggering of auxiliary codes | |
US7036118B1 (en) | System for executing computer programs on a limited-memory computing machine | |
US20040221278A1 (en) | Method and apparatus for performing interpreter optimizations during program code conversion | |
McDaniel | An Analysis of a Mesa Instruction Set | |
US6119206A (en) | Design of tags for lookup of non-volatile registers | |
Kieburtz | The G-machine: A fast, graph-reduction evaluator | |
Armstrong et al. | Isla: Integrating full-scale ISA semantics and axiomatic concurrency models | |
Kang | Function call interception techniques | |
Guyer et al. | Optimizing the use of high performance software libraries |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: DIGITAL EQUIPMENT CORPORATION, MASSACHUSETTSFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:CHERNOFF, ANTON;YATES, JOHN S.;REEL/FRAME:007850/0903Effective date: 19960129 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
AS | Assignment |
Owner name: COMPAQ INFORMATION TECHNOLOGIES GROUP, L.P., TEXASFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:DIGITAL EQUIPMENT CORPORATION;COMPAQ COMPUTER CORPORATION;REEL/FRAME:012447/0903;SIGNING DATES FROM 19991209 TO 20010620 |
|
FPAY | Fee payment |
Year of fee payment: 4 |
|
AS | Assignment |
Owner name: HEWLETT-PACKARD DEVELOPMENT COMPANY, L.P., TEXASFree format text: CHANGE OF NAME;ASSIGNOR:COMPAQ INFORMANTION TECHNOLOGIES GROUP LP;REEL/FRAME:014102/0224Effective date: 20021001 |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYFree format text: PAYER NUMBER DE-ASSIGNED (ORIGINAL EVENT CODE: RMPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
REMI | Maintenance fee reminder mailed | ||
FPAY | Fee payment |
Year of fee payment: 12 |
|
SULP | Surcharge for late payment |
Year of fee payment: 11 |
|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:HEWLETT-PACKARD DEVELOPMENT COMPANY, L.P.;HEWLETT-PACKARD COMPANY;REEL/FRAME:027661/0258Effective date: 20111025 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044144/0001Effective date: 20170929 |