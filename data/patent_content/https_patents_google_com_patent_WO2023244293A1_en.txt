WO2023244293A1 - Generic index for protobuf data - Google Patents
Generic index for protobuf data Download PDFInfo
- Publication number
- WO2023244293A1 WO2023244293A1 PCT/US2023/018897 US2023018897W WO2023244293A1 WO 2023244293 A1 WO2023244293 A1 WO 2023244293A1 US 2023018897 W US2023018897 W US 2023018897W WO 2023244293 A1 WO2023244293 A1 WO 2023244293A1
- Authority
- WO
- WIPO (PCT)
- Prior art keywords
- field
- value pair
- index
- value
- processors
- Prior art date
Links
- 239000000872 buffer Substances 0.000 claims abstract description 80
- 238000000034 method Methods 0.000 claims description 21
- 230000008859 change Effects 0.000 abstract description 5
- 238000010586 diagram Methods 0.000 description 16
- 230000015654 memory Effects 0.000 description 15
- 238000012545 processing Methods 0.000 description 7
- 230000008569 process Effects 0.000 description 4
- 230000006870 function Effects 0.000 description 3
- 238000003491 array Methods 0.000 description 2
- 238000006243 chemical reaction Methods 0.000 description 2
- 239000000835 fiber Substances 0.000 description 2
- 238000013178 mathematical model Methods 0.000 description 2
- 230000009467 reduction Effects 0.000 description 2
- 238000013515 script Methods 0.000 description 2
- 238000005516 engineering process Methods 0.000 description 1
- 230000007246 mechanism Effects 0.000 description 1
- 230000003287 optical effect Effects 0.000 description 1
- 230000002688 persistence Effects 0.000 description 1
- 238000012805 post-processing Methods 0.000 description 1
- 239000007787 solid Substances 0.000 description 1
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/22—Indexing; Data structures therefor; Storage structures
- G06F16/2228—Indexing structures
- G06F16/2272—Management thereof
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/80—Information retrieval; Database structures therefor; File system structures therefor of semi-structured data, e.g. markup language structured data such as SGML, XML or HTML
- G06F16/81—Indexing, e.g. XML tags; Data structures therefor; Storage structures
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/22—Indexing; Data structures therefor; Storage structures
- G06F16/2228—Indexing structures
- G06F16/2246—Trees, e.g. B+trees
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/24—Querying
- G06F16/248—Presentation of query results
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/80—Information retrieval; Database structures therefor; File system structures therefor of semi-structured data, e.g. markup language structured data such as SGML, XML or HTML
- G06F16/84—Mapping; Conversion
- G06F16/86—Mapping to a database
Definitions
- Protocol Buffers are a language-neutral, platform-neutral, extensible mechanism for serializing structured data that can be helpful in developing programs to communicate with each other over a network or to store data.
- Protocol buffers generally involve an interface description language that describes the structure of some data and a program that generates source code from that description for generating or parsing a stream of bytes that represents the structured data.
- Indexing protocol buffer data can require listing all the fields that need to be indexed. However, if the protocol buffer has a large number of fields, listing all of those fields can be compute demanding. Further, a protocol buffer definition can be changed at any time, which can cause inconsistencies between the data schema and the protocol buffer definition. When searching text in protocol buffer data, identifying the location of matched fields can require compute intensive post-processing.
- aspects of the disclosure are directed to an approach for building a generic framework to allow protocol buffer data to be fully text searchable and matched fields to be quickly identified.
- the approach includes converting protocol buffer data from a tree structure into a field-value pair structure.
- the fieldvalue pair structure can represent any protocol buffer and any new protocol buffer definition change can be adopted automatically.
- the approach further includes building a reverse index at a record level, which can immediately indicate the fields for each token.
- An aspect of the disclosure provides for a method for searching protocol buffer data.
- the method includes converting, with one or more processors, protocol buffer data from a tree structure into a fieldvalue pair structure. A field portion of each field-value pair represents leaf fields of the tree structure and a value portion of each field-value pair represents one or more terms appearing in the respective field.
- the method further includes generating, with the one or more processors, a reverse index of the field-value pairs.
- the reverse index includes a term-to-field list that maps the terms with the respective fields in which they appear.
- the method further includes generating, with the one or more processors, a search result based on the generated reverse index.
- the field portion of each field-value pair is a field index.
- the field index includes one of an integer key or a string of characters.
- the method further includes generating, with the one or more processors, a weight for the field portion of each field-value pair based on the respective value portion. In yet another example, the method further includes determining, with the one or more processors, a ranking score for a search result based on a summation of weights generated for the field portion of field-value pairs related to the search.
- the method further includes highlighting, with the one or more processors, matched terms in a search result based on the generated reverse index. In yet another example, the method further includes highlighting, with the one or more processors, related terms in a search result based on the generated reverse index.
- Another aspect of the disclosure provides for a system including one or more processors; and one or more storage devices coupled to the one or more processors and storing instructions that, when executed by the one or more processors, causes the one or more processors to perform operations for searching protocol buffer data.
- the operations include converting protocol buffer data from a tree structure into a field-value pair structure. A field portion of each field-value pair represents leaf fields of the tree structure and a value portion of each field-value pair represents one or more terms appearing in the respective field.
- the operations further include generating a reverse index of the field-value pairs.
- the reverse index includes a term-to-field list that maps the terms with the respective fields in which they appear.
- the operations further include generating a search result based on the generated reverse index.
- the field portion of each field- value pair is a field index, where the field index includes one of an integer key or a string of characters.
- the operations further include generating a weight for the field portion of each field-value pair based on the respective value portion. In yet another example, the operations further include determining a ranking score for a search result based on a summation of weights generated for the field portion of field-value pairs related to the search. In yet another example, the operations further include highlighting at least one of matched terms or related terms in a search result based on the generated reverse index.
- Yet another aspect of the disclosure provides for a non-transitory computer readable medium for storing instructions that, when executed by one or more processors, causes the one or more processors to perform operations for searching protocol buffer data.
- the operations include converting protocol buffer data from a tree structure into a field-value pair structure. A field portion of each field-value pair represents leaf fields of the tree structure and a value portion of each field-value pair represents one or more terms appearing in the respective field.
- the operations further include generating a reverse index of the fieldvalue pairs.
- the reverse index includes a term-to-field list that maps the terms with the respective fields in which they appear.
- the operations further include generating a search result based on the generated reverse index.
- the field portion of each field- value pair is a field index, where the field index includes one of an integer key or a string of characters.
- the operations further include generating a weight for the field portion of each field-value pair based on the respective value portion. In yet another example, the operations further include determining a ranking score for a search result based on a summation of weights generated for the field portion of field-value pairs related to the search. In yet another example, the operations further include highlighting at least one of matched terms or related terms in a search result based on the generated reverse index.
- FIG. 1 depicts a block diagram of a system to build a generic framework for searching protocol buffer data according to aspects of the disclosure.
- FIG. 2 depicts a block diagram further detailing the format converter of the system to build a generic framework for searching protocol buffer data according to aspects of the disclosure.
- FIG. 3 depicts a flow diagram of an example process to build a generic framework for searching protocol buffer data according to aspects of the disclosure.
- FIG. 4 depicts a block diagram of protocol buffer data in a tree structure being converted into a field-value pair structure according to aspects of the disclosure.
- FIG. 5 depicts a block diagram of an example conversion of an entity “diagnostic report” of protocol buffer data according to aspects of the disclosure.
- FIG. 6 depicts a block diagram of a reverse index generated from a field-value pair structure according to aspects of the disclosure.
- FIG. 7 depicts a block diagram of an example reverse index for the entity “diagnostic report” of protocol buffer data according to aspects of the disclosure.
- FIG. 8 depicts a block diagram of a field-value pair structure with weights and a reverse index incorporating the field-value pair structure according to aspects of the disclosure.
- Protocol buffers generally can support more data types than JavaScript Object Notation (JSON) or extensible markup language (XML).
- JSON JavaScript Object Notation
- XML extensible markup language
- the field-value pair structure can represent any protocol buffer and any new protocol buffer definition change can be adopted automatically based on a new protocol buffer schema and its associated values. In other words, a field-value pair structure can be efficiently changed to accommodate a change in the protocol buffer definition of the underlying protocol buffer data from which the field-value pair structure was obtained. Data types supported by protocol buffers but not supported by other data formats can be converted into the field- value pair structure.
- the field-value pair can include a field portion and a value portion.
- the field portion can be a field index representing leaf fields of the tree structure.
- the field portion can be a string of characters or, to save storage space, integer keys, such as Int32.
- the value portion can be entries for the field and include one or more terms appearing in a respective field.
- Building the generic framework can further include generating a reverse index at a record level of a database to immediately identify fields for each term of the values.
- Data types supported by protocol buffers but not supported by other data formats can be incorporated into the reverse index.
- a reverse index can reverse entries before they are entered in the index, for example, terms can be listed before the field portion.
- the reverse index can include a term-to-field list that maps terms of the values with the field indexes in which they appear.
- Field indexes can be ranked or given a weight based on their value for more accurate search results. For example, more important fields, such as entity titles, can be given higher weights than less important fields, such as comments.
- a ranking score can be determined that is a summation of the weights for each field in which the search term is included.
- the ranking score can be generated by using the weights for each weight through a mathematical model, such as a linear model.
- the field index ranks or weights can enable retrieving search results more efficiently as more relevant results can be provided, allowing for more efficient compute processing and reduction of memory.
- Matched terms and/or related terms can be highlighted based on the reverse index for more accurate search results.
- Matched terms are terms that are partially or exactly equivalent to terms in a query.
- Related terms are terms that are associated with terms in a query. Based on a query, the matched and/or related terms can be determined.
- the reverse index can show in which fields matched and/or related terms from the query appear.
- FIG. 1 depicts a block diagram of a system 100 to build a generic framework for searching protocol buffer data.
- the system can include a format converter 110 and a database 120.
- the format converter 110 can receive protocol buffer data 130 as one or more entities, each in a tree structure.
- the format converter 110 can convert the protocol buffer data 130 from the tree structures into field-value pair structures and generate a reverse index for the converted protocol buffer data 140, to be described in further detail below.
- the reverse index of the converted protocol buffer data 140 can be stored in the database 120, where the protocol buffer data 140 can be text searchable for a search 150 from a client device 160.
- the database 120 can be a single storage device or a plurality of storage devices, such as hard drives, random access memory, disks, disk arrays, tape drives, etc.
- the database 120 can implement any of a number of architectures and technologies, including, but not limited to, direct attached storage (DAS), network attached storage (NAS), storage area networks (SANs), fiber channel (FC), fiber channel over Ethernet (FCoE), mixed architecture networks, or the like.
- DAS direct attached storage
- NAS network attached storage
- SANs storage area networks
- FC fiber channel
- FCoE fiber channel over Ethernet
- mixed architecture networks or the like.
- the database 120 can include virtualized or containerized environments.
- the database 120 can include one or more virtual machines running on a host machine.
- the database 120 can store, for example, data files, documents, code, schemas, persistence frameworks, applications, or any of a variety of other information or tools typically stored in databases.
- the client device 160 can be configured with a processor, memory, instructions, and data.
- the client device can be a personal computer, intended for use by a person having all the internal components normally found in a personal computer such as a central processing unit (CPU), hard drive, and input/output device, and all of the components used for connecting these elements to one another.
- the client device 160 can be any device capable of processing instructions and transmitting data to and from humans and other computers including general purpose computers, tablets, mobile phones, smartwatches, home assistants, video game systems, network computers lacking local storage capability, set top boxes for televisions, and other networked devices.
- the client device 160 can include an application interface module used to search 150 the database 120.
- the application interface module may include sub-routines, data structures, object classes and other types of software components used to allow the database 120 and client device 160 to communicate with each other.
- the application interface module may be a software module operable in conjunction with several types of operating systems known in the arts.
- the client may be connected to a Structured Query Language (SQL) database server that may operate in conjunction with the application interface module for saving and retrieving information data.
- SQL Structured Query Language
- FIG. 2 depicts a block diagram further detailing the format converter 110 of the system 100 to build a generic framework for searching protocol buffer data.
- the format converter 110 includes a set of computing resources such as one or more processors 210 and memory 220.
- the processors 210 are configured to execute data 230 and instructions 240 stored in the memory 220 to convert protocol buffer data 250 from the tree structures into field- value pair structures and generate a reverse index for the converted protocol buffer data 250.
- the processors 210 can be any processors, including one or more central processing units (CPUs), graphic processing units (GPUs), field programmable gate arrays (FPGAs), and/or application specific integrated circuits (ASICs).
- the format converter 110 can include specialized hardware components to perform specific computing processes.
- the memory 220 can be a type of non- transitory computer readable medium capable of storing information accessible by the processor 210, such as a hard-drive, solid state drive, tape drive, optical storage, memory card, ROM, RAM, DVD, CD-ROM, write -capable, and read-only memories.
- the memory 220 can store information accessible by the processor 210, including instructions 240 that can be executed by the processor 210 and that can be retrieved, manipulated, or stored by the processor 210.
- the instructions 240 can be a set of instructions executed directly, such as machine code, or indirectly, such as scripts, by the processor 210.
- the terms “instructions”, “steps”, and “programs” can be used interchangeably herein.
- the instructions 240 can be stored in object code format for direct processing by the processor 210, or other types of computer language including scripts or collections of independent source code modules that are interpreted on demand or compiled in advance.
- the instructions 240 can include receiving protocol buffer data in a tree structure, converting the protocol buffer data from the tree structure into a field-value pair structure, generating a reverse index for the converted protocol buffer data, and storing the reverse index of converted protocol buffer data in the database 120. Functions, methods, and routines of the instructions are explained in more detail below.
- the data 230 can be retrieved, stored, or modified by the processor 210 in accordance with the instructions.
- the data 230 can also be formatted in a computer-readable format such as, but not limited to, binary values, ASCII, or Unicode.
- the data 230 can include information sufficient to identify relevant information, such as numbers, descriptive text, proprietary codes, pointers, references to data stored in other memories, including other network locations, or information that is used by a function to calculate relevant data.
- the data 230 can include the protocol buffer data 250 that is converted into the field-value pair structure to be incorporated into the reverse index.
- FIG. 2 functionally illustrates the processor 210 and memory 220 of the format converter 110 as being within the same block
- the processor 210 and/or memory 220 can actually include multiple processors or memories that may or may not be stored within the same physical housing.
- the memory 220 can be a hard drive or other storage media located in housings different from that of the format converter 110. Accordingly, references to a processor or memory will be understood to include references to a collection of processors or memories that may or may not operate in parallel.
- references to a processor or memory will be understood to include references to a collection of processors or memories that may or may not operate in parallel.
- some functions described below are indicated as taking place on a single computing device having a single processor, various aspects of the subject matter described herein can be implemented by a plurality of computing devices, for example, communicating information over a network.
- FIG. 3 depicts a flow diagram of an example process 300 to build a generic framework for searching protocol buffer data.
- the example process 300 can be performed on a system of one or more processors in one or more locations, such as the format converter 110 of FIGs. 1-2.
- the format converter 110 can receive protocol buffer data 130 in a tree structure.
- the protocol buffer data 130 can include one or more entities, each in a tree structure.
- the format converter 110 can convert the protocol buffer data 130 from the tree structure into a field-value pair structure.
- the field-value pair structure can represent any protocol buffer and any new protocol buffer definition change can be adopted automatically based on a new protocol buffer schema and its associated values. Data types supported by protocol buffers but not supported by other data formats can be converted into the field-value pair structure.
- FIG. 4 depicts a block diagram of protocol buffer data 130 in a tree structure 410 being converted into a field- value pair structure 420.
- the tree structure 410 can include one or more root entities with one or more leaf fields representing values. While a single entity, e.g., Entity 1, is shown for simplicity, the tree structure 410 can include any number of entities having any number of fields.
- Entity 1 can include a plurality of fields, e.g., Field 1 through Field n, respectively including a plurality of values, e.g., Value 1 through Value n, as entries for the fields. In the example shown in FIG. 4, Entity 1 corresponds to the root entity and Field 1 through Field n correspond to leaf entities.
- the field-value pair structure 420 can include a field portion and a value portion.
- the field portion can be a field index representing leaf fields of the tree structure.
- the field portion can be a string of characters or integer keys. Integer keys can be used to save storage space.
- Example integer keys can include Int 16, Int32, and Int64.
- the plurality of fields, e.g., Field 1 through Field n can be represented by a plurality of corresponding field indexes with integer keys, e.g., Field Index 1 through Field Index n.
- the data type of entity 1 can also be represented by a field index with an integer key, e.g., Field Index n+1.
- Protocol buffers can support data types that other data formats, like JSON and XML, cannot support.
- the value portion can be entries for the field and include one or more terms appearing in a respective field.
- the field indexes with integer keys e.g., Field Index 1 through Field Index n
- FIG. 5 depicts a block diagram of an example conversion of an entity “diagnostic report” of protocol buffer data.
- the entity can include three fields, “diagnostic report name”, “conclusion”, and “entity”, with respective values “fake diagnostic report”, “everything looks good”, and “diagnostic report”.
- This protocol buffer data can be represented as field- value pairs [ 1: “fake diagnostic report ⁇ , ⁇ 2: “everything looks good” ⁇ , and ⁇ 3: “diagnostic report” ⁇ , where the field index can be the integer key, and the value can be the description.
- the integer key can further describe the field indexes so that 1 can be “diagnostic report name”, 2 can be “conclusion”, and 3 can be “entity”.
- the field index can also be represented as strings instead of integer keys, so that the field-value pair can be ⁇ diagnostic report name: fake diagnostic report ⁇ , ⁇ conclusion: everything looks good ⁇ , and ⁇ entity: diagnostic report ⁇ .
- the format converter 110 can generate a reverse index for the converted protocol buffer data 130.
- Data types supported by protocol buffers but not supported by other data formats can be incorporated into the reverse index.
- a reverse index can reverse entries before they are entered in the index, for example, terms can be listed before the field portion.
- FIG. 6 depicts a block diagram of a reverse index 620 generated from a field-value pair structure 610.
- the reverse index 620 can include a term-to-field list that maps terms of the values with the field indexes in which they appear. For example, Term 1 appears in the values of Field 1 and Field n, so the term-to-field list for Term 1 includes Field 1 and Field n. As another example, Term 2 appears only in the value of Field 2, so the term-to-field list for Term 2 includes only Field 2.
- the term-to-field list can include any number of terms, e.g., Term 1 through Term m, with respective values indicating in which fields the term appears.
- FIG. 7 depicts a block diagram of an example reverse index for the entity “diagnostic report” of protocol buffer data, described earlier with respect to FIG. 5.
- the term-to-field list can include the term “diagnostic” mapped with field indexes “1” and “3”.
- the term-to-field list can further include the term “everything” mapped with field index “2”.
- the term-to-field list can also include the term “fake” mapped with field index “1”. All other terms can be mapped with the field indexes in which they appear.
- the reverse index of the field-value pairs can allow for text-searchable protocol buffer data.
- the format converter 110 can store the reverse index 140 of the converted protocol buffer data at a record level of the database 120. Based on the reverse index 140, a search 150 can quickly identify fields terms in the search.
- Field indexes can also be ranked or given a weight by a computing device, such as the client device 160, based on their importance for more accurate search results. For example, more important fields, such as entity titles, can be given higher weights than less important fields, such as comments.
- An example weight value for a more important field can be 100 and an example weight value for a less important field can be 10. It should be noted that weights could be any numerical value to represent importance for each field.
- a ranking score can be determined that is a summation of the weights for each field in which the search term is included.
- the ranking score can be generated by using the weights for each field through a mathematical model, such as a linear model.
- FIG. 8 depicts a block diagram of a field- value pair structure with weights 810 and a reverse index 820 incorporating the field-value pair structure 810.
- the field index ranks or weights can enable retrieving search results more efficiently as more relevant results can be provided, allowing for more efficient compute processing and reduction of memory.
- Matched terms and/or related terms can also be highlighted by a computing device, such as the client device 160, based on the reverse index for more accurate search results.
- Matched terms arc terms that are partially or exactly equivalent to terms in a search query.
- Related terms are terms that are associated with other terms in a query. Whether terms are related can be predetermined prior to a query. Based on a query, the matched and/or related terms can be retrieved for highlighting.
- the reverse index can show in which fields matched and/or related terms from the query appear using the term-to-field lists.
- Protocol buffers generally can support more data types than JavaScript Object Notation (JSON) or extensible markup language (XML).
- JSON JavaScript Object Notation
- XML extensible markup language
Abstract
Aspects of the disclosure are directed to an approach for building a generic framework to allow protocol buffer data to be fully text searchable and matched fields to be quickly identified. The approach includes converting protocol buffer data from a tree structure into a field-value pair structure. The field-value pair structure can represent any protocol buffer and any new protocol buffer definition change can be adopted automatically. The approach further includes building a reverse index at a record level, which can immediately indicate the fields for each token.
Description
GENERIC INDEX FOR PROTOBUF DATA
CROSS-REFERENCE TO RELATED APPLICATIONS
[0001] The present application is a continuation of U.S. Patent Application No. 17/841,874, filed June 16, 2022, the disclosure of which is incorporated herein by reference.
BACKGROUND
[0002] Protocol Buffers, a.k.a., protobuf, are a language-neutral, platform-neutral, extensible mechanism for serializing structured data that can be helpful in developing programs to communicate with each other over a network or to store data. Protocol buffers generally involve an interface description language that describes the structure of some data and a program that generates source code from that description for generating or parsing a stream of bytes that represents the structured data.
[0003] Indexing protocol buffer data can require listing all the fields that need to be indexed. However, if the protocol buffer has a large number of fields, listing all of those fields can be compute demanding. Further, a protocol buffer definition can be changed at any time, which can cause inconsistencies between the data schema and the protocol buffer definition. When searching text in protocol buffer data, identifying the location of matched fields can require compute intensive post-processing.
BRIEF SUMMARY
[0004] Aspects of the disclosure are directed to an approach for building a generic framework to allow protocol buffer data to be fully text searchable and matched fields to be quickly identified. The approach includes converting protocol buffer data from a tree structure into a field-value pair structure. The fieldvalue pair structure can represent any protocol buffer and any new protocol buffer definition change can be adopted automatically. The approach further includes building a reverse index at a record level, which can immediately indicate the fields for each token.
[0005] An aspect of the disclosure provides for a method for searching protocol buffer data. The method includes converting, with one or more processors, protocol buffer data from a tree structure into a fieldvalue pair structure. A field portion of each field-value pair represents leaf fields of the tree structure and a value portion of each field-value pair represents one or more terms appearing in the respective field. The method further includes generating, with the one or more processors, a reverse index of the field-value pairs. The reverse index includes a term-to-field list that maps the terms with the respective fields in which they appear.
[0006] In an example, the method further includes generating, with the one or more processors, a search result based on the generated reverse index. In another example, the field portion of each field-value pair is a field index. In yet another example, the field index includes one of an integer key or a string of characters.
[0007] In yet another example, the method further includes generating, with the one or more processors, a weight for the field portion of each field-value pair based on the respective value portion. In yet another
example, the method further includes determining, with the one or more processors, a ranking score for a search result based on a summation of weights generated for the field portion of field-value pairs related to the search.
[0008] In yet another example, the method further includes highlighting, with the one or more processors, matched terms in a search result based on the generated reverse index. In yet another example, the method further includes highlighting, with the one or more processors, related terms in a search result based on the generated reverse index.
[0009] Another aspect of the disclosure provides for a system including one or more processors; and one or more storage devices coupled to the one or more processors and storing instructions that, when executed by the one or more processors, causes the one or more processors to perform operations for searching protocol buffer data. The operations include converting protocol buffer data from a tree structure into a field-value pair structure. A field portion of each field-value pair represents leaf fields of the tree structure and a value portion of each field-value pair represents one or more terms appearing in the respective field. The operations further include generating a reverse index of the field-value pairs. The reverse index includes a term-to-field list that maps the terms with the respective fields in which they appear.
[0010] In an example, the operations further include generating a search result based on the generated reverse index. In another example, the field portion of each field- value pair is a field index, where the field index includes one of an integer key or a string of characters.
[0011] In yet another example, the operations further include generating a weight for the field portion of each field-value pair based on the respective value portion. In yet another example, the operations further include determining a ranking score for a search result based on a summation of weights generated for the field portion of field-value pairs related to the search. In yet another example, the operations further include highlighting at least one of matched terms or related terms in a search result based on the generated reverse index.
[0012] Yet another aspect of the disclosure provides for a non-transitory computer readable medium for storing instructions that, when executed by one or more processors, causes the one or more processors to perform operations for searching protocol buffer data. The operations include converting protocol buffer data from a tree structure into a field-value pair structure. A field portion of each field-value pair represents leaf fields of the tree structure and a value portion of each field-value pair represents one or more terms appearing in the respective field. The operations further include generating a reverse index of the fieldvalue pairs. The reverse index includes a term-to-field list that maps the terms with the respective fields in which they appear.
[0013] In an example, the operations further include generating a search result based on the generated reverse index. In another example, the field portion of each field- value pair is a field index, where the field index includes one of an integer key or a string of characters.
[0014] In yet another example, the operations further include generating a weight for the field portion of each field-value pair based on the respective value portion. In yet another example, the operations further include determining a ranking score for a search result based on a summation of weights generated for the
field portion of field-value pairs related to the search. In yet another example, the operations further include highlighting at least one of matched terms or related terms in a search result based on the generated reverse index.
BRIEF DESCRIPTION OF THE DRAWINGS
[0015] FIG. 1 depicts a block diagram of a system to build a generic framework for searching protocol buffer data according to aspects of the disclosure.
[0016] FIG. 2 depicts a block diagram further detailing the format converter of the system to build a generic framework for searching protocol buffer data according to aspects of the disclosure.
[0017] FIG. 3 depicts a flow diagram of an example process to build a generic framework for searching protocol buffer data according to aspects of the disclosure.
[0018] FIG. 4 depicts a block diagram of protocol buffer data in a tree structure being converted into a field-value pair structure according to aspects of the disclosure.
[0019] FIG. 5 depicts a block diagram of an example conversion of an entity “diagnostic report” of protocol buffer data according to aspects of the disclosure.
[0020] FIG. 6 depicts a block diagram of a reverse index generated from a field-value pair structure according to aspects of the disclosure.
[0021] FIG. 7 depicts a block diagram of an example reverse index for the entity “diagnostic report” of protocol buffer data according to aspects of the disclosure.
[0022] FIG. 8 depicts a block diagram of a field-value pair structure with weights and a reverse index incorporating the field-value pair structure according to aspects of the disclosure.
DETAILED DESCRIPTION
[0023] Generally disclosed herein are implementations for building a generic framework to search protocol buffer data. The generic framework can allow for unified indexing so that any protocol buffer data is text searchable in an efficient manner. The generic framework can also allow for quickly identifying matched fields of protocol buffer data for queries or query expansions. Protocol buffers generally can support more data types than JavaScript Object Notation (JSON) or extensible markup language (XML).
[0024] Building the generic framework can include converting protocol buffer data from a tree structure into a field-value pair structure. The field-value pair structure can represent any protocol buffer and any new protocol buffer definition change can be adopted automatically based on a new protocol buffer schema and its associated values. In other words, a field-value pair structure can be efficiently changed to accommodate a change in the protocol buffer definition of the underlying protocol buffer data from which the field-value pair structure was obtained. Data types supported by protocol buffers but not supported by other data formats can be converted into the field- value pair structure. The field-value pair can include a field portion and a value portion. The field portion can be a field index representing leaf fields of the tree structure. The field portion can be a string of characters or, to save storage space, integer keys, such as
Int32. The value portion can be entries for the field and include one or more terms appearing in a respective field.
[0025] Building the generic framework can further include generating a reverse index at a record level of a database to immediately identify fields for each term of the values. Data types supported by protocol buffers but not supported by other data formats can be incorporated into the reverse index. A reverse index can reverse entries before they are entered in the index, for example, terms can be listed before the field portion. The reverse index can include a term-to-field list that maps terms of the values with the field indexes in which they appear.
[0026] Field indexes can be ranked or given a weight based on their value for more accurate search results. For example, more important fields, such as entity titles, can be given higher weights than less important fields, such as comments. When searching, a ranking score can be determined that is a summation of the weights for each field in which the search term is included. The ranking score can be generated by using the weights for each weight through a mathematical model, such as a linear model. The field index ranks or weights can enable retrieving search results more efficiently as more relevant results can be provided, allowing for more efficient compute processing and reduction of memory.
[0027] Matched terms and/or related terms can be highlighted based on the reverse index for more accurate search results. Matched terms are terms that are partially or exactly equivalent to terms in a query. Related terms are terms that are associated with terms in a query. Based on a query, the matched and/or related terms can be determined. The reverse index can show in which fields matched and/or related terms from the query appear.
[0028] FIG. 1 depicts a block diagram of a system 100 to build a generic framework for searching protocol buffer data. The system can include a format converter 110 and a database 120. The format converter 110 can receive protocol buffer data 130 as one or more entities, each in a tree structure. The format converter 110 can convert the protocol buffer data 130 from the tree structures into field-value pair structures and generate a reverse index for the converted protocol buffer data 140, to be described in further detail below. The reverse index of the converted protocol buffer data 140 can be stored in the database 120, where the protocol buffer data 140 can be text searchable for a search 150 from a client device 160.
[0029] The database 120 can be a single storage device or a plurality of storage devices, such as hard drives, random access memory, disks, disk arrays, tape drives, etc. The database 120 can implement any of a number of architectures and technologies, including, but not limited to, direct attached storage (DAS), network attached storage (NAS), storage area networks (SANs), fiber channel (FC), fiber channel over Ethernet (FCoE), mixed architecture networks, or the like. Further, in some examples the database 120 can include virtualized or containerized environments. For example, the database 120 can include one or more virtual machines running on a host machine. The database 120 can store, for example, data files, documents, code, schemas, persistence frameworks, applications, or any of a variety of other information or tools typically stored in databases. While a single database is shown, the database 120 can also be a plurality of database replicas in a distributed system.
[0030] The client device 160 can be configured with a processor, memory, instructions, and data. The client device can be a personal computer, intended for use by a person having all the internal components normally found in a personal computer such as a central processing unit (CPU), hard drive, and input/output device, and all of the components used for connecting these elements to one another. The client device 160 can be any device capable of processing instructions and transmitting data to and from humans and other computers including general purpose computers, tablets, mobile phones, smartwatches, home assistants, video game systems, network computers lacking local storage capability, set top boxes for televisions, and other networked devices.
[0031] The client device 160 can include an application interface module used to search 150 the database 120. For example, the application interface module may include sub-routines, data structures, object classes and other types of software components used to allow the database 120 and client device 160 to communicate with each other. In one aspect, the application interface module may be a software module operable in conjunction with several types of operating systems known in the arts. For example, the client may be connected to a Structured Query Language (SQL) database server that may operate in conjunction with the application interface module for saving and retrieving information data.
[0032] FIG. 2 depicts a block diagram further detailing the format converter 110 of the system 100 to build a generic framework for searching protocol buffer data. The format converter 110 includes a set of computing resources such as one or more processors 210 and memory 220. The processors 210 are configured to execute data 230 and instructions 240 stored in the memory 220 to convert protocol buffer data 250 from the tree structures into field- value pair structures and generate a reverse index for the converted protocol buffer data 250.
[0033] The processors 210 can be any processors, including one or more central processing units (CPUs), graphic processing units (GPUs), field programmable gate arrays (FPGAs), and/or application specific integrated circuits (ASICs). Although not necessary, the format converter 110 can include specialized hardware components to perform specific computing processes. The memory 220 can be a type of non- transitory computer readable medium capable of storing information accessible by the processor 210, such as a hard-drive, solid state drive, tape drive, optical storage, memory card, ROM, RAM, DVD, CD-ROM, write -capable, and read-only memories.
[0034] The memory 220 can store information accessible by the processor 210, including instructions 240 that can be executed by the processor 210 and that can be retrieved, manipulated, or stored by the processor 210. The instructions 240 can be a set of instructions executed directly, such as machine code, or indirectly, such as scripts, by the processor 210. In this regard, the terms “instructions”, “steps”, and “programs” can be used interchangeably herein. The instructions 240 can be stored in object code format for direct processing by the processor 210, or other types of computer language including scripts or collections of independent source code modules that are interpreted on demand or compiled in advance. The instructions 240 can include receiving protocol buffer data in a tree structure, converting the protocol buffer data from the tree structure into a field-value pair structure, generating a reverse index for the converted protocol
buffer data, and storing the reverse index of converted protocol buffer data in the database 120. Functions, methods, and routines of the instructions are explained in more detail below.
[0035] The data 230 can be retrieved, stored, or modified by the processor 210 in accordance with the instructions. The data 230 can also be formatted in a computer-readable format such as, but not limited to, binary values, ASCII, or Unicode. Moreover, the data 230 can include information sufficient to identify relevant information, such as numbers, descriptive text, proprietary codes, pointers, references to data stored in other memories, including other network locations, or information that is used by a function to calculate relevant data. The data 230 can include the protocol buffer data 250 that is converted into the field-value pair structure to be incorporated into the reverse index.
[0036] Although FIG. 2 functionally illustrates the processor 210 and memory 220 of the format converter 110 as being within the same block, the processor 210 and/or memory 220 can actually include multiple processors or memories that may or may not be stored within the same physical housing. For example, the memory 220 can be a hard drive or other storage media located in housings different from that of the format converter 110. Accordingly, references to a processor or memory will be understood to include references to a collection of processors or memories that may or may not operate in parallel. Yet further, although some functions described below are indicated as taking place on a single computing device having a single processor, various aspects of the subject matter described herein can be implemented by a plurality of computing devices, for example, communicating information over a network.
[0037] FIG. 3 depicts a flow diagram of an example process 300 to build a generic framework for searching protocol buffer data. The example process 300 can be performed on a system of one or more processors in one or more locations, such as the format converter 110 of FIGs. 1-2.
[0038] As shown in block 310, the format converter 110 can receive protocol buffer data 130 in a tree structure. The protocol buffer data 130 can include one or more entities, each in a tree structure.
[0039] As shown in block 320, the format converter 110 can convert the protocol buffer data 130 from the tree structure into a field-value pair structure. The field-value pair structure can represent any protocol buffer and any new protocol buffer definition change can be adopted automatically based on a new protocol buffer schema and its associated values. Data types supported by protocol buffers but not supported by other data formats can be converted into the field-value pair structure.
[0040] FIG. 4 depicts a block diagram of protocol buffer data 130 in a tree structure 410 being converted into a field- value pair structure 420. The tree structure 410 can include one or more root entities with one or more leaf fields representing values. While a single entity, e.g., Entity 1, is shown for simplicity, the tree structure 410 can include any number of entities having any number of fields. Entity 1 can include a plurality of fields, e.g., Field 1 through Field n, respectively including a plurality of values, e.g., Value 1 through Value n, as entries for the fields. In the example shown in FIG. 4, Entity 1 corresponds to the root entity and Field 1 through Field n correspond to leaf entities.
[0041] The field-value pair structure 420 can include a field portion and a value portion. The field portion can be a field index representing leaf fields of the tree structure. The field portion can be a string of characters or integer keys. Integer keys can be used to save storage space. Example integer keys can include
Int 16, Int32, and Int64. The plurality of fields, e.g., Field 1 through Field n, can be represented by a plurality of corresponding field indexes with integer keys, e.g., Field Index 1 through Field Index n. The data type of entity 1 can also be represented by a field index with an integer key, e.g., Field Index n+1. Protocol buffers can support data types that other data formats, like JSON and XML, cannot support.
[0042] The value portion can be entries for the field and include one or more terms appearing in a respective field. The field indexes with integer keys, e.g., Field Index 1 through Field Index n, can also represent the plurality of values, e.g., Value 1 through Value n, based on the field in which each value appears.
[0043] FIG. 5 depicts a block diagram of an example conversion of an entity “diagnostic report” of protocol buffer data. The entity can include three fields, “diagnostic report name”, “conclusion”, and “entity”, with respective values “fake diagnostic report”, “everything looks good”, and “diagnostic report”. This protocol buffer data can be represented as field- value pairs [ 1: “fake diagnostic report}, {2: “everything looks good”}, and {3: “diagnostic report”}, where the field index can be the integer key, and the value can be the description. The integer key can further describe the field indexes so that 1 can be “diagnostic report name”, 2 can be “conclusion”, and 3 can be “entity”. The field index can also be represented as strings instead of integer keys, so that the field-value pair can be {diagnostic report name: fake diagnostic report}, {conclusion: everything looks good}, and {entity: diagnostic report}.
[0044] Referring back to FIG. 3, as shown in block 330, the format converter 110 can generate a reverse index for the converted protocol buffer data 130. Data types supported by protocol buffers but not supported by other data formats can be incorporated into the reverse index. A reverse index can reverse entries before they are entered in the index, for example, terms can be listed before the field portion.
[0045] FIG. 6 depicts a block diagram of a reverse index 620 generated from a field-value pair structure 610. The reverse index 620 can include a term-to-field list that maps terms of the values with the field indexes in which they appear. For example, Term 1 appears in the values of Field 1 and Field n, so the term-to-field list for Term 1 includes Field 1 and Field n. As another example, Term 2 appears only in the value of Field 2, so the term-to-field list for Term 2 includes only Field 2. The term-to-field list can include any number of terms, e.g., Term 1 through Term m, with respective values indicating in which fields the term appears.
[0046] FIG. 7 depicts a block diagram of an example reverse index for the entity “diagnostic report” of protocol buffer data, described earlier with respect to FIG. 5. The term-to-field list can include the term “diagnostic” mapped with field indexes “1” and “3”. The term-to-field list can further include the term “everything” mapped with field index “2”. The term-to-field list can also include the term “fake” mapped with field index “1”. All other terms can be mapped with the field indexes in which they appear. The reverse index of the field-value pairs can allow for text-searchable protocol buffer data.
[0047] Referring back to FIG. 3, as shown in block 340, the format converter 110 can store the reverse index 140 of the converted protocol buffer data at a record level of the database 120. Based on the reverse index 140, a search 150 can quickly identify fields terms in the search.
[0048] Field indexes can also be ranked or given a weight by a computing device, such as the client device 160, based on their importance for more accurate search results. For example, more important fields, such as entity titles, can be given higher weights than less important fields, such as comments. An example weight value for a more important field can be 100 and an example weight value for a less important field can be 10. It should be noted that weights could be any numerical value to represent importance for each field. When searching, a ranking score can be determined that is a summation of the weights for each field in which the search term is included. The ranking score can be generated by using the weights for each field through a mathematical model, such as a linear model. FIG. 8 depicts a block diagram of a field- value pair structure with weights 810 and a reverse index 820 incorporating the field-value pair structure 810. The field index ranks or weights can enable retrieving search results more efficiently as more relevant results can be provided, allowing for more efficient compute processing and reduction of memory.
[0049] Matched terms and/or related terms can also be highlighted by a computing device, such as the client device 160, based on the reverse index for more accurate search results. Matched terms arc terms that are partially or exactly equivalent to terms in a search query. Related terms are terms that are associated with other terms in a query. Whether terms are related can be predetermined prior to a query. Based on a query, the matched and/or related terms can be retrieved for highlighting. The reverse index can show in which fields matched and/or related terms from the query appear using the term-to-field lists.
[0050] As such, generally disclosed herein are implementations for building a generic framework to search protocol buffer data. The generic framework can allow for unified indexing so that any protocol buffer data is text searchable. The generic framework can also allow for quickly identifying matched fields of protocol buffer data for queries or query expansions. Protocol buffers generally can support more data types than JavaScript Object Notation (JSON) or extensible markup language (XML).
[0051] Unless otherwise stated, the foregoing alternative examples are not mutually exclusive, but may be implemented in various combinations to achieve unique advantages. As these and other variations and combinations of the features discussed above can be utilized without departing from the subject matter defined by the claims, the foregoing description of the embodiments should be taken by way of illustration rather than by way of limitation of the subject matter defined by the claims. In addition, the provision of the examples described herein, as well as clauses phrased as "such as," "including" and the like, should not be interpreted as limiting the subject matter of the claims to the specific examples; rather, the examples are intended to illustrate only one of many possible embodiments. Further, the same reference numbers in different drawings can identify the same or similar elements.
Claims
1. A method for searching protocol buffer data comprising: converting, with one or more processors, protocol buffer data from a tree structure into a field-value pair structure, a field portion of each field-value pair representing leaf fields of the tree structure and a value portion of each field-value pair representing one or more terms appearing in the respective field; and generating, with the one or more processors, a reverse index of the field-value pairs, the reverse index comprising a term-to-field list that maps the terms with the respective fields in which they appear.
2. The method of claim 1, further comprising generating, with the one or more processors, a search result based on the generated reverse index.
3. The method of claim 1, wherein the field portion of each field-value pair is a field index.
4. The method of claim 3, wherein the field index comprises one of an integer key or a string of characters.
5. The method of claim 1, further comprising generating, with the one or more processors, a weight for the field portion of each field-value pair based on the respective value portion.
6. The method of claim 5, further comprising determining, with the one or more processors, a ranking score for a search result based on a summation of weights generated for the field portion of field-value pairs related to the search.
7. The method of claim 1, further comprising highlighting, with the one or more processors, matched terms in a search result based on the generated reverse index.
8. The method of claim 1, further comprising highlighting, with the one or more processors, related terms in a search result based on the generated reverse index.
9. A system comprising: one or more processors; and one or more storage devices coupled to the one or more processors and storing instructions that, when executed by the one or more processors, causes the one or more processors to perform operations for searching protocol buffer data, the operations comprising: converting protocol buffer data from a tree structure into a field-value pair structure, a field portion of each field-value pair representing leaf fields of the tree structure and a value
portion of each field-value pair representing one or more terms appearing in the respective field; and generating a reverse index of the field-value pairs, the reverse index comprising a term-to-field list that maps the terms with the respective fields in which they appear. The system of claim 9, wherein the operations further comprise generating a search result based on the generated reverse index. The system of claim 9, wherein the field portion of each field-value pair is a field index, the field index comprising one of an integer key or a string of characters. The system of claim 9, wherein the operations further comprise generating a weight for the field portion of each field-value pair based on the respective value portion. The system of claim 12, wherein the operations further comprise determining a ranking score for a search result based on a summation of weights generated for the field portion of fieldvalue pairs related to the search. The system of claim 9, wherein the operations further comprise highlighting at least one of matched terms or related terms in a search result based on the generated reverse index. A non-transitory computer readable medium for storing instructions that, when executed by one or more processors, causes the one or more processors to perform operations for searching protocol buffer data, the operations comprising: converting protocol buffer data from a tree structure into a field-value pair structure, a field portion of each field-value pair representing leaf fields of the tree structure and a value portion of each field-value pair representing one or more terms appearing in the respective field; and generating a reverse index of the field-value pairs, the reverse index comprising a term-to-field list that maps the terms with the respective fields in which they appear. The non-transitory computer readable medium of claim 15, wherein the operations further comprise generating a search result based on the generated reverse index. The non-transitory computer readable medium of claim 15, wherein the field portion of each field-value pair is a field index, the field index comprising one of an integer key or a string of characters.
The non- transitory computer readable medium of claim 15, wherein the operations further comprise generating a weight for the field portion of each field-value pair based on the respective value portion. The non- transitory computer readable medium of claim 18, wherein the operations further comprise determining a ranking score for a search result based on a summation of weights generated for the field portion of field-value pairs related to the search. The non-transitory computer readable medium of claim 15, wherein the operations further comprise highlighting at least one of matched terms or related terms in a search result based on the generated reverse index.
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US17/841,874 US20230409550A1 (en) | 2022-06-16 | 2022-06-16 | Generic Index for Protobuf Data |
US17/841,874 | 2022-06-16 |
Publications (1)
Publication Number | Publication Date |
---|---|
WO2023244293A1 true WO2023244293A1 (en) | 2023-12-21 |
Family
ID=86688658
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
PCT/US2023/018897 WO2023244293A1 (en) | 2022-06-16 | 2023-04-18 | Generic index for protobuf data |
Country Status (2)
Country | Link |
---|---|
US (1) | US20230409550A1 (en) |
WO (1) | WO2023244293A1 (en) |
Family Cites Families (8)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6721727B2 (en) * | 1999-12-02 | 2004-04-13 | International Business Machines Corporation | XML documents stored as column data |
US7363310B2 (en) * | 2001-09-04 | 2008-04-22 | Timebase Pty Limited | Mapping of data from XML to SQL |
US20090144266A1 (en) * | 2007-12-04 | 2009-06-04 | Eclipsys Corporation | Search method for entries in a database |
US8862897B2 (en) * | 2011-10-01 | 2014-10-14 | Oracle International Corporation | Increasing data security in enterprise applications by using formatting, checksums, and encryption to detect tampering of a data buffer |
US9129046B2 (en) * | 2013-02-25 | 2015-09-08 | 4medica, Inc. | Systems and methods for managing a master patient index including duplicate record detection |
US10944771B2 (en) * | 2017-05-03 | 2021-03-09 | Servicenow, Inc. | Computing resource identification |
US10511515B1 (en) * | 2017-08-29 | 2019-12-17 | Rockwell Collins, Inc. | Protocol buffer avionics system |
US11176202B2 (en) * | 2019-09-18 | 2021-11-16 | Salesforce.Com, Inc. | Ranking results of searches of databases |
-
2022
- 2022-06-16 US US17/841,874 patent/US20230409550A1/en active Pending
-
2023
- 2023-04-18 WO PCT/US2023/018897 patent/WO2023244293A1/en unknown
Non-Patent Citations (2)
Title |
---|
ANONYMOUS: "Database index - Wikipedia", 20 October 2015 (2015-10-20), XP093022296, Retrieved from the Internet <URL:https://en.wikipedia.org/w/index.php?title=Database_index&oldid=686651483> [retrieved on 20230209] * |
HASAN ZAFARI ET AL: "XLight, An Efficient Relational Schema to Store and Query XML Data", DATA STORAGE AND DATA ENGINEERING (DSDE), 2010 INTERNATIONAL CONFERENCE ON, IEEE, PISCATAWAY, NJ, USA, 9 February 2010 (2010-02-09), pages 254 - 257, XP031661349, ISBN: 978-1-4244-5678-9 * |
Also Published As
Publication number | Publication date |
---|---|
US20230409550A1 (en) | 2023-12-21 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
Diao et al. | YFilter: Efficient and scalable filtering of XML documents | |
US7293018B2 (en) | Apparatus, method, and program for retrieving structured documents | |
US9798772B2 (en) | Using persistent data samples and query-time statistics for query optimization | |
US11789945B2 (en) | Clause-wise text-to-SQL generation | |
US9607061B2 (en) | Using views of subsets of nodes of a schema to generate data transformation jobs to transform input files in first data formats to output files in second data formats | |
US8001128B2 (en) | Selection of a set of optimal n-grams for indexing string data in a DBMS system under space constraints introduced by the system | |
US7548933B2 (en) | System and method for exploiting semantic annotations in executing keyword queries over a collection of text documents | |
Haw et al. | Data storage practices and query processing in XML databases: A survey | |
US8595231B2 (en) | Ruleset generation for multiple entities with multiple data values per attribute | |
CN107491476B (en) | Data model conversion and query analysis method suitable for various big data management systems | |
US20220391367A1 (en) | Efficient Indexing for Querying Arrays in Databases | |
US20060161525A1 (en) | Method and system for supporting structured aggregation operations on semi-structured data | |
US20180365294A1 (en) | Artificial intelligence driven declarative analytic platform technology | |
US20060190452A1 (en) | Sort digits as number collation in server | |
US7085760B2 (en) | Data query differential analysis | |
US8639717B2 (en) | Providing access to data with user defined table functions | |
Berra et al. | Computer architecture for a surrogate file to a very large data/knowledge base | |
US20050060307A1 (en) | System, method, and service for datatype caching, resolving, and escalating an SQL template with references | |
US20230409550A1 (en) | Generic Index for Protobuf Data | |
US20060167867A1 (en) | Enhancing node-based query languages to support common relational mapping patterns | |
JP2008210272A (en) | System and method for retrieving document | |
CN108664573A (en) | A kind of quick processing system of big data and method with double-channel data library | |
Ježek et al. | NWB Query engines: tools to search data stored in neurodata without borders format | |
Namba | High-performance XML storage/retrieval system | |
Choi et al. | Efficient filtering of branch queries for high-performance XML data services |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
121 | Ep: the epo has been informed by wipo that ep was designated in this application |
Ref document number: 23728457Country of ref document: EPKind code of ref document: A1 |