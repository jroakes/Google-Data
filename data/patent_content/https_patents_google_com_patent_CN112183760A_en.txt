CN112183760A - System and method for reducing idleness of machine learning training system using data echo - Google Patents
System and method for reducing idleness of machine learning training system using data echo Download PDFInfo
- Publication number
- CN112183760A CN112183760A CN202010459362.2A CN202010459362A CN112183760A CN 112183760 A CN112183760 A CN 112183760A CN 202010459362 A CN202010459362 A CN 202010459362A CN 112183760 A CN112183760 A CN 112183760A
- Authority
- CN
- China
- Prior art keywords
- training
- data
- machine learning
- echo
- computing devices
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Granted
Links
- 238000012549 training Methods 0.000 title claims abstract description 607
- 238000010801 machine learning Methods 0.000 title claims abstract description 126
- 238000000034 method Methods 0.000 title claims abstract description 62
- 239000000872 buffer Substances 0.000 claims description 46
- 238000012545 processing Methods 0.000 claims description 23
- 230000006870 function Effects 0.000 claims description 15
- 230000009466 transformation Effects 0.000 claims description 12
- 230000008569 process Effects 0.000 claims description 10
- 230000002708 enhancing effect Effects 0.000 claims description 7
- 238000011156 evaluation Methods 0.000 claims description 6
- 230000008859 change Effects 0.000 claims description 5
- 238000012544 monitoring process Methods 0.000 claims description 3
- 239000000306 component Substances 0.000 description 86
- 238000002592 echocardiography Methods 0.000 description 31
- 238000013528 artificial neural network Methods 0.000 description 24
- 238000002474 experimental method Methods 0.000 description 24
- 238000011144 upstream manufacturing Methods 0.000 description 24
- 238000004422 calculation algorithm Methods 0.000 description 12
- 230000008901 benefit Effects 0.000 description 11
- 238000004891 communication Methods 0.000 description 10
- 238000010586 diagram Methods 0.000 description 10
- 230000001133 acceleration Effects 0.000 description 8
- 230000006872 improvement Effects 0.000 description 8
- 230000000694 effects Effects 0.000 description 7
- 238000007781 pre-processing Methods 0.000 description 7
- 230000002596 correlated effect Effects 0.000 description 5
- 230000000875 corresponding effect Effects 0.000 description 5
- 230000001965 increasing effect Effects 0.000 description 5
- 230000003993 interaction Effects 0.000 description 5
- 230000006399 behavior Effects 0.000 description 4
- 238000003780 insertion Methods 0.000 description 4
- 230000037431 insertion Effects 0.000 description 4
- 238000000844 transformation Methods 0.000 description 4
- 238000001514 detection method Methods 0.000 description 3
- 230000002349 favourable effect Effects 0.000 description 3
- 238000012986 modification Methods 0.000 description 3
- 230000004048 modification Effects 0.000 description 3
- 230000009467 reduction Effects 0.000 description 3
- 238000004364 calculation method Methods 0.000 description 2
- 230000002860 competitive effect Effects 0.000 description 2
- 230000009849 deactivation Effects 0.000 description 2
- 238000013461 design Methods 0.000 description 2
- 238000011143 downstream manufacturing Methods 0.000 description 2
- 230000006698 induction Effects 0.000 description 2
- 238000013383 initial experiment Methods 0.000 description 2
- 239000011159 matrix material Substances 0.000 description 2
- 238000010606 normalization Methods 0.000 description 2
- 230000002688 persistence Effects 0.000 description 2
- 230000000306 recurrent effect Effects 0.000 description 2
- 230000003068 static effect Effects 0.000 description 2
- 238000012360 testing method Methods 0.000 description 2
- 229920002803 thermoplastic polyurethane Polymers 0.000 description 2
- 238000007476 Maximum Likelihood Methods 0.000 description 1
- AVUYXHYHTTVPRX-UHFFFAOYSA-N Tris(2-methyl-1-aziridinyl)phosphine oxide Chemical compound CC1CN1P(=O)(N1C(C1)C)N1C(C)C1 AVUYXHYHTTVPRX-UHFFFAOYSA-N 0.000 description 1
- 230000009471 action Effects 0.000 description 1
- 238000007792 addition Methods 0.000 description 1
- 230000004075 alteration Effects 0.000 description 1
- 238000013459 approach Methods 0.000 description 1
- 230000003190 augmentative effect Effects 0.000 description 1
- 230000003139 buffering effect Effects 0.000 description 1
- 239000003795 chemical substances by application Substances 0.000 description 1
- 239000003086 colorant Substances 0.000 description 1
- 230000001276 controlling effect Effects 0.000 description 1
- 239000008358 core component Substances 0.000 description 1
- 238000011161 development Methods 0.000 description 1
- YQGOJNYOYNNSMM-UHFFFAOYSA-N eosin Chemical compound [Na+].OC(=O)C1=CC=CC=C1C1=C2C=C(Br)C(=O)C(Br)=C2OC2=C(Br)C(O)=C(Br)C=C21 YQGOJNYOYNNSMM-UHFFFAOYSA-N 0.000 description 1
- 230000002452 interceptive effect Effects 0.000 description 1
- 239000012464 large buffer Substances 0.000 description 1
- 230000008450 motivation Effects 0.000 description 1
- 230000003287 optical effect Effects 0.000 description 1
- 238000005457 optimization Methods 0.000 description 1
- 238000002360 preparation method Methods 0.000 description 1
- 230000000644 propagated effect Effects 0.000 description 1
- 230000002787 reinforcement Effects 0.000 description 1
- 230000008521 reorganization Effects 0.000 description 1
- 238000005070 sampling Methods 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N20/00—Machine learning
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
- G06N3/084—Backpropagation, e.g. using gradient descent
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/06—Physical realisation, i.e. hardware implementation of neural networks, neurons or parts of neurons
- G06N3/063—Physical realisation, i.e. hardware implementation of neural networks, neurons or parts of neurons using electronic means
Abstract
A method for reducing idleness in a machine learning training system may include performing an operation by a computing device. The first set of training operations may access and prepare a plurality of training examples of a set of training data. The second set of training operations may train the machine learning model based at least in part on the set of training data, and may include one or more iterative iterations in which at least a portion of the second set of training operations is repeatedly performed such that the training examples are repeated for training the machine learning model. The rate of repeating the iterations may be based at least in part on an echo factor, which may be based at least in part on a comparison of a first computation time of the first set of training operations and a second computation time of the second set of training operations.
Description
Technical Field
The present disclosure relates generally to training of machine learning models. More particularly, the present disclosure relates to a system and method for reducing idleness in a machine learning training system.
Background
The training of machine learning models can generally be divided into a data pre-processing step and a subsequent training step using the processed data. The data pre-processing step may typically take longer than the subsequent training step. For example, dedicated hardware has been developed that can greatly increase the speed of parallel processing, which is common in training procedures. In various instances, such dedicated hardware may be referred to as "acceleration" hardware, "accelerators," Application Specific Integrated Circuits (ASICs), and/or other terminology. Example dedicated hardware includes a Graphics Processing Unit (GPU), Tensor Processing Unit (TPU), and/or the like. Due to this dedicated hardware (and other factors), the execution of the training steps may start and stop when pre-processed training data becomes available intermittently. Accordingly, systems and methods for reducing idle in machine learning training systems would be welcomed in the art.
Disclosure of Invention
Aspects and advantages of embodiments of the present disclosure will be set forth in part in the description which follows or may be learned by practice of the embodiments.
One example aspect of the present disclosure relates to a method for reducing idleness in a machine learning training system, which may include: executing, by one or more computing devices, a first set of training operations to access and prepare a plurality of training examples included in a set of training data; and performing, by the one or more computing devices, a second set of training operations to train the machine learning model based at least in part on the set of training data. Performing the second set of training operations may include: performing, by the one or more computing devices, one or more iterative iterations in which at least a portion of the second set of training operations are repeatedly performed on at least one of a plurality of training examples included in the set of training data such that the at least one training example is repeatedly used to train the machine learning model. The rate of one or more repeated iterations may be based at least in part on an echo factor based at least in part on a comparison of a first computation time associated with performing a first set of training operations and a second computation time associated with performing a second set of training operations.
Another example aspect of the present disclosure is directed to a computing system configured to perform a training process to train a machine learning model based on a training data set that may include a plurality of training examples. The computing system may include: a computer-readable storage disk configured to store a plurality of training examples; and a first set of hardware components configured to run a first set of training operations to access the plurality of training examples from the computer-readable storage disk, prepare the plurality of training examples for training the machine learning model, and store the prepared training examples in an intermediate data buffer. The intermediate data buffer may be configured to store the prepared training examples. The computing system may include a second set of hardware components configured to run a second set of training operations to access the prepared training examples from the intermediate data buffer and train the machine learning model using the prepared training examples. The second set of hardware components may be configured to perform one or more iterative iterations, where the second set of hardware components iteratively accesses the at least one prepared training example from the intermediate data buffer and iteratively uses the at least one prepared training example to train the machine learning model. The rate at which the second set of hardware components is configured to perform the one or more repeated iterations is based at least in part on an echo factor that is based at least in part on a comparison of a first computation time associated with performing a first set of training operations by the first set of hardware components and a second computation time associated with performing a second set of training operations by the second set of hardware components.
Other aspects of the disclosure are directed to various systems, apparatuses, non-transitory computer-readable media, user interfaces, and electronic devices.
These and other features, aspects, and advantages of various embodiments of the present disclosure will become better understood with reference to the following description and appended claims. The accompanying drawings, which are incorporated in and constitute a part of this specification, illustrate exemplary embodiments of the disclosure and together with the description, serve to explain the relevant principles.
Drawings
A detailed discussion of embodiments directed to one of ordinary skill in the art is set forth in the specification, which makes reference to the appended drawings, in which:
fig. 1A depicts a block diagram of an example computing system for reducing idleness in a machine learning training system, according to an example embodiment of the present disclosure.
Fig. 1B depicts a block diagram of an example computing system for reducing idleness in a machine learning training system, according to an example embodiment of the present disclosure.
Fig. 1C depicts a block diagram of an example computing system for reducing idleness in a machine learning training system, according to an example embodiment of the present disclosure.
Fig. 2 is a simplified schematic diagram of a computing system for reducing idleness in a machine learning training system, according to an example embodiment of the present disclosure.
Fig. 3 depicts a block diagram of an example machine learning model, according to an example embodiment of the present disclosure.
Fig. 4 depicts a flowchart of an example method for reducing idleness in a machine learning training system, according to an example embodiment of the present disclosure.
Fig. 5 depicts a flowchart of another example method for reducing idleness in a machine learning training system, according to an example embodiment of the present disclosure.
FIG. 6 depicts a typical neural network training pipeline.
FIG. 7 depicts a scenario in which stages are executed if in parallel and tupstream＝2tdownstreamThe case of overlapping computation times upstream and downstream of the pipeline stages of the data echo insertion point.
Fig. 8 depicts a case where the data echo of e-2, or the number of fresh instances required to reach the target off-sample performance is reduced or unchanged, the dashed line indicating the expected value that would be useful if the repeated instances were as fresh instances.
Fig. 9 depicts a case where the fraction of training time assuming different R values changes, R being the ratio of upstream and downstream computation times, the data echo can reduce the training time for a range of echo factors around the optimum value e R, especially when e ≦ R, the y-axis being a logarithmic scale.
Fig. 10 depicts a situation in which the example echo reduces the number of fresh examples required by the transformer on LM1B for echo factors of up to (at least) 16. For batch size 1024 there is a maximum useful echo factor somewhere between 4 and 8, while for batch size 4096 the maximum useful echo factor is greater than 16, the dashed line indicating an expected value that would be useful if the example repeated were as fresh.
Fig. 11 depicts a situation where the performance of the echo is either constant or improved relative to the baseline batch as the batch size increases, while for the example echo, its performance is either constant or worse by increasing the score of the duplicate example at each batch, with the dashed line indicating the expected value that would be useful if the example repeated as the fresh example.
Fig. 12 depicts a situation where data echoes with more shuffles perform better, the dashed line indicating the expected value that would be useful if the repeated example were as the fresh example.
FIG. 13 depicts experiments to get the best off-sample performance within the fresh example budget.
Detailed Description
Overview
In general, the present disclosure is directed to systems and methods for reducing idleness in a machine learning training system. The computing system may include a first set of hardware components (e.g., a general purpose processor and associated memory components) configured to perform a first set of training operations to access and prepare a plurality of training examples included in a set of training data. The computing system may also include a second set of hardware components (e.g., one or more special-purpose hardware units included in the model training system) configured to execute a second set of training operations to train the machine learning model based at least in part on the set of training data (e.g., in parallel with execution of the first set of operations). The first set of training operations (which may also be referred to as, for example, "upstream" processing tasks) may include reading, decoding, shuffling, enhancing, and/or batching training data to prepare the training data. However, the first set of training operations takes longer to complete than the second set of training operations (which may also be referred to as "downstream" processing), which may include training the model based on prepared training data (e.g., by performing a gradient descent technique and/or other training techniques). According to an aspect of the disclosure, a computing system may perform data echo (echo) to reduce idle time of "downstream" processing and/or the second set of hardware components. More specifically, the training iteration may be repeatedly performed on some or all of the training examples, such that the second set of hardware components may continue to perform the second set of operations (e.g., training the machine learning model) even when no new or "fresh" training examples are available in the first set of hardware components. Thus, performing repeated iterations may reduce the idleness of the system by reducing the "idle time" when a first set of training operations is being performed but a second set of training operations is not being performed. Furthermore, experiments have shown that this can reduce the number of fresh training examples required to train a machine learning model to achieve a given performance benchmark. Appendix a, which is incorporated into and forms a part of this disclosure, includes data from experiments, showing and quantifying the benefits achieved by performing data echoes in accordance with this disclosure.
More specifically, for the same training example, a number of iterations of the iteration (e.g., by the second set of computing hardware components) based on the echo factor may be performed. The number of iterations repeated for a given training example may be positively correlated or otherwise based on the echo factor. For example, an echo factor of 2 may correspond to performing a single iteration of repetition for each training example, resulting in a total of two iterations per training example. The echo factor may be selected to reduce (e.g., minimize, eliminate, etc.) idle time. As described above, the idle time may be defined as a first set of training operations (e.g., pre-processing training data) being performed but not a second set of training operations (e.g., training a model based on the pre-processing training data).
According to another aspect of the disclosure, the echo factor may be based on a computation time and/or rate associated with accessing data and/or training a machine learning model to minimize idle time. More specifically, the echo factor may be based on a comparison of a first computation time associated with performing a first set of training operations and a second computation time associated with performing a second set of training operations. The first computation time and/or the second computation time may include or describe an average computation time (e.g., a total average time of processing times for a set of training examples having a known size, complexity, etc.) and/or an average computation rate associated with accessing training data and/or training a machine learning model (e.g., training examples per unit time or other suitable metric). The comparison of the first computation time and the second computation time may be used to determine an expected time at which the second set of training operations becomes idle without data echoes. An echo factor may then be determined such that the first computation time and the adjusted second computation time (including data echo) are approximately equal, thereby reducing or eliminating idleness of the second set of training operations.
In some implementations, each iteration of repetition may include a series of training steps. The number of repetitions of the series of training steps may be based at least in part on an echo factor. For example, a second set of hardware components (which may be referred to, for example, as a "model trainer") may input training examples into the machine learning model and receive training outputs as outputs of the machine learning model. The second set of hardware components may evaluate the training output and adjust parameters of the machine learning model based at least in part on the evaluation of the training output. For example, the evaluation training output may include back-propagation errors through layers of the neural network of the machine learning model with respect to the loss function. Parameters of the machine learning model may be adjusted based on the loss function using a variety of suitable methods, including, for example, random gradient descent.
In some implementations, data enhancement may be performed on some or all of the training data. Data enhancement may include applying a transformation to training examples to generate training examples of additional transformations. As an example, training examples including images may be resized, mirrored, rotated, cropped, and/or tiled. Additionally or in combination, one or more attributes of the training examples may be adjusted, such as brightness, contrast, saturation, and so forth. Any suitable transformation known in the art may be used. Other types of transformations may be applicable to other types of training data (e.g., audio, preferences, statistics, etc.).
In some implementations, data enhancement may be included in the second set of training operations (e.g., performed by the second set of hardware components) such that the training example(s) are enhanced during one or more iterations of repetition. As a result, iterative iterations may be performed with the enhanced training example(s). In some cases, this may improve the training value of the repeated iterations as compared to repeating the same training example.
However, in other implementations, data enhancement may be included in the first set of training operations (e.g., performed by the first set of hardware components) such that the training example(s) remain unchanged during the repeated iteration(s). In this way, the machine learning model may be trained on repeated identical training examples. This configuration is useful in the case where the training value of the training example(s) is maximum without enhancement. However, it should be understood that in some implementations, the enhancement may be performed in each of the first set of training operations and the second set of training operations.
In some implementations, the intermediate data buffer can be used to store training data output by the first set of hardware components. The second set of hardware components may access training data stored in the intermediate data buffer to train the machine learning model using the training data. Training examples included in the training data may also be shuffled (e.g., reordered) in the intermediate data buffer or accessed from the intermediate data buffer in a non-contiguous manner (e.g., randomly, probabilistically, etc.). Thus, the intermediate data buffer may facilitate storing and accessing training examples for training the machine learning model, including using iterative iterations.
In some implementations, training examples may be probabilistically selected for repeated iterations based on echo factors, such that repeated iterations are performed on some training examples and not on others. This may facilitate data echo by an echo factor rather than by an integer value. Training examples may be retrieved from the intermediate data buffer as needed. As described above, training examples may be shuffled and/or accessed discontinuously in the intermediate data buffer. However, in other implementations, the training examples may be continuously visited such that the same training example is continuously repeated in repeated iterations. In one example, an echo factor of 2 may result in a number of repeated iterations for each training example, for a total of two repeated iterations for each training example. An echo factor of 1 may result in no iteration being performed repeatedly. Probabilistically selecting the training example(s) for repeated iterations may facilitate achieving an echo factor between one and two by probabilistically selecting training examples for repeated iterations based on the echo factor, such that repeated iterations are performed at a desired average rate corresponding to the echo factor. For example, an echo factor of 1.5 may result in half of the training examples being probabilistically selected for repeated iterations such that the total number of iterations (including fresh training examples and repeated iterations) is equal to 150% of the number of fresh training examples.
The above iterative iterations may be performed on various training examples, and thus may be described as "example-level" data echoes. Rather, "batch level" data echo may be employed in other implementations. For batch-level data echo, a repeat iteration may be performed on each training example of a batch of training examples (e.g., before repeating the iteration on any member of the batch of training examples). More specifically, the training steps may be performed on a first training example, then on a second training example, and so on until the training step is performed on each training example of the batch. The training steps may then be repeated for each training example in the batch of training examples in the same manner. The training step may be repeated for the batch, the number of repetitions being based on the echo factor. Thus, batch-level echo may be employed by repeating iterations for a batch of training examples, rather than repeating iterations for individual training examples. Batch echo may sometimes be better than example-level echo with a relatively larger batch size.
In some implementations, the echo factor may be a static hyper-parameter that is manually selected or determined by a user or operator of the computing system. The echo factor may also be determined (e.g., determined by a user, operator, or automatically by a computing system) based on information about the hardware components (processing power, available buffer size, etc.) and/or training data (size, complexity, etc.). Thus, the echo factor may be system-tailored to minimize idleness and optimize the efficiency of the model training system.
However, in other implementations, the computing system may dynamically adjust the echo factor (e.g., during training of the machine learning model). For example, the computing system may increase the echo factor when a new training example is unavailable or expected to become unavailable. Thus, the model training system may dynamically adjust the number of repeated iterations of the training examples in real-time based on the availability (or expected availability) of fresh training examples (e.g., from a data buffer).
As another example, the echo factor may be dynamically adjusted based on real-time monitoring information about the training process and/or hardware components used to train the machine learning model. For example, the computing system may monitor, in real-time, a first computation time associated with performing a first set of training operations (e.g., by a first set of hardware components) and/or a second computation time associated with performing a second set of training operations (e.g., by a second set of hardware components). The computing system may dynamically adjust the echo factor in real-time based at least in part on a comparison of the first computation time and the second computation time to reduce idle time in real-time (e.g., during training of the machine learning model). As described above, idle time may be defined when a first set of training operations is being performed while a second set of training operations is not being performed.
As another example, the echo factor may be adjusted based on a loss function. The loss function may be evaluated against the machine learning model and the given training example to determine a loss value for the training example. The echo factor may be positively correlated with the loss value of the training example, such that more iterations of repetition may be performed for training examples that incur higher loss values than training examples that incur lower loss values. Alternatively, the echo factor may remain the same, but based on having a relatively higher correlation loss value, the training examples may be selected with greater probability for repeated iterations. Thus, the number of iterations to repeat for a particular training example may be intelligently selected to maximize the value of repeating the selected training example.
The iterative iterations may be performed for fewer than all training examples of the training data. As one example, the training example(s) may be selected for repeated iteration based on a loss function that evaluates at least some of the plurality of training examples and the machine learning model to determine respective loss values for the training examples. Training examples with higher associated loss values (e.g., relatively higher than the loss values of other training examples in the training data) may facilitate repeated iterations. The training example(s) with relatively lower correlation loss values may not be favorable for repeated iterations. For example, the amount of training examples required for repeated iterations may be calculated. The corresponding loss value for the training example may then be calculated. The training examples may then be ranked according to their respective loss values. A subset of the plurality of training examples may then be selected for repeated iterations based on the respective loss value rankings of the plurality of training examples and the amount of training examples needed (e.g., to avoid or reduce idleness). Thus, the computing system may be configured to intelligently improve or maximize the effectiveness of performing repeated iterations of training the machine learning model.
As another example, the training example(s) may be selected for repeated iterations based on their relative positions within the training data. More recent training examples for training the machine learning model may be selected for repeated iterations. This may provide the benefit of being easy to implement and may require less computing resources. For example, calculation of a loss value for a training example may potentially be avoided, such as for machine learning methods, where the loss value need not be calculated.
As another example, the training example(s) may be selected for repeated iterations based on their respective data sources. Training examples may be received from multiple data sources including publicly available training data sets (e.g., image data sets, audio data sets, etc.) and/or from a user of the mobile device (if the user has agreed). For example, training data can be obtained or generated based on interactions with a user of the mobile device, user preferences, and/or the like (e.g., to customize a machine learning model for the user). The training examples collected from the user of the mobile device may be given priority for repeated iterations over training examples collected from other sources. Importantly, a user may be provided with controls that allow the user to select whether and when the systems, programs, or features described herein may enable the collection of user information (e.g., preferences). In addition, certain data may be processed in one or more ways before being stored or used in order to remove identifiable personal information (personally identifiable information). For example, the identity of the user may be processed such that no identifiable personal information can be determined for the user. Thus, the user may have control over which information is collected about the user, how the information is used, and which information is provided to the user.
In some implementations, the methods described herein may be performed across multiple hardware components. As described above, the first set of hardware components may be configured to run a first set of training operations to access and prepare a plurality of training examples. The first set of hardware components may store the prepared training examples in an intermediate data buffer. The second set of hardware components may be configured to run a second set of training operations to access the prepared training examples from the intermediate data buffer and train the machine learning model using the prepared training examples.
In some implementations, the first set of hardware components may include one or more general purpose processors and the second set of hardware components may include one or more application specific integrated circuits. For example, the application specific integrated circuit may include a hardware accelerator that includes a graphics processing unit(s) or a tensor processing unit(s).
The systems and methods of the present disclosure may provide a number of technical effects and benefits. For example, the use of data echoes may reduce idleness, thereby increasing the efficiency of training the machine learning model, resulting in reduced use of computing resources, such as processor time, network bandwidth, memory usage, and the like. Furthermore, experiments have shown that data echo can reduce the number of fresh training examples required to reach a given performance benchmark. Appendix a, which is incorporated into and forms a part of this disclosure, includes data from experiments that show and quantify some of the benefits achieved by performing content data echoes in accordance with this disclosure. Accordingly, less computing resources are required to access, pre-process, and/or buffer such fresh training examples. In contrast, using data echoes with a given number of training examples may achieve improved model performance compared to prior art training methods. Thus, the present method and system provide a technical improvement to the technical problem of training machine learning models. Benefits include reduced idleness during training, greater computational efficiency during training, and improved performance of models trained in accordance with the present systems and methods.
As one example, the systems and methods of the present disclosure may be included or otherwise employed in the context of an application, browser plug-in, or other context. Thus, in some implementations, the models of the present disclosure may be included in or stored and implemented by a user computing device, such as a laptop, tablet, or smartphone. As yet another example, the model may be included in, stored by, and implemented by a server computing device in communication with the user computing device according to a client-server relationship. For example, the model may be implemented by a server computing device as part of a network service (e.g., a network email service).
Referring now to the drawings, example embodiments of the disclosure will be discussed in further detail.
Example apparatus and System
FIG. 1A depicts a block diagram of an example computing system 100 that performs idle reduction in a machine learning training system, according to an example embodiment of the present disclosure. The system 100 includes a user computing device 102, a server computing system 130, and a training computing system 150 communicatively coupled through a network 180.
The user computing device 102 may be any type of computing device, such as a personal computing device (e.g., a laptop or desktop computer), a mobile computing device (e.g., a smartphone or tablet computer), a gaming console or controller, a wearable computing device, an embedded computing device, or any other type of computing device.
The user computing device 102 includes one or more processors 112 and memory 114. The one or more processors 112 may be any suitable processing device (e.g., processor cores, microprocessors, ASICs, FPGAs, controllers, microcontrollers, etc.) and may be one or more processors operatively connected. Memory 114 may include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, disks, etc., and combinations thereof. The memory 114 may store data 116 and instructions 118 that are executed by the processor 112 to cause the user computing device 102 to perform operations.
The user computing device 102 may store or include one or more machine learning models 120. For example, the machine learning model 120 may be or may include various machine learning models, such as a neural network (e.g., a deep neural network) or other multi-layered nonlinear model. The neural network may include a recurrent neural network (e.g., a long-short term memory recurrent neural network), a feed-forward neural network, or other form of neural network. An example machine learning model 120 is discussed with reference to FIG. 2.
In some implementations, one or more machine learning models 120 can be received from the server computing system 130 over the network 180, stored in the user computing device memory 114, and used or otherwise implemented by the one or more processors 112. In some implementations, the user computing device 102 can implement multiple parallel instances of a single machine learning model 120 (e.g., perform parallel operations among multiple instances of the machine learning model 120).
Additionally or alternatively, one or more machine learning models 140 may be included in, or stored and implemented by, the server computing system 130 communicating with the user computing device 102 according to a client-server relationship. For example, the machine learning model 140 may be implemented by the server computing system 140 as part of a web service. Accordingly, one or more machine learning models 120 may be stored and implemented at the user computing device 102, and/or one or more models 140 may be stored and implemented at the server computing system 130.
The user computing device 102 may also include one or more user input components 122 that receive user input. For example, the user input component 122 may be a touch sensitive component (e.g., a touch sensitive display screen or touchpad) that is sensitive to touch by a user input object (e.g., a finger or stylus). The touch sensitive component may be used to implement a virtual keyboard. Other example user input components include a microphone, a conventional keyboard, or other device through which a user may input communications.
The server computing system 130 includes one or more processors 132 and memory 134. The one or more processors 132 may be any suitable processing device (e.g., processor cores, microprocessors, ASICs, FPGAs, controllers, microcontrollers, etc.) and may be one or more processors operatively connected. Memory 134 may include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, a disk, and the like, as well as combinations thereof. The memory 134 may store data 136 and instructions 138 that are executed by the processor 132 to cause the server computing system 130 to perform operations.
In some implementations, the server computing system 130 includes or is implemented by one or more server computing devices. Where the server computing system 130 includes multiple server computing devices, such server computing devices may operate according to a sequential computing architecture, a parallel computing architecture, or some combination thereof.
As described above, the server computing system 130 may store or otherwise include one or more machine learning models 140. For example, the model 140 may be or may otherwise include various machine learning models, such as a neural network (e.g., a deep-cycle neural network) or other multi-layer nonlinear model. An example model 140 is discussed with reference to FIG. 2.
The server computing system 130 may train the model 140 through interaction with a training computing system 150 communicatively coupled through a network 180. The training computing system 150 may be separate from the server computing system 130 or may be part of the server computing system 130.
The training computing system 150 may include a first set of hardware components 160 and a second set of hardware components 162 configured to perform training operations on one or both of the machine learning models 140, 120 or machine learning models stored in the training computing system 150, e.g., as described herein with reference to fig. 2. The first and second sets of hardware components 160, 162 may employ various training or learning techniques, e.g., back propagation of errors. In some implementations, performing back-propagation of errors may include performing truncated back-propagation over time. The model trainer 160 may perform a variety of induction techniques (e.g., weight decay, random deactivation, etc.) to improve the induction capability of the trained model.
In some implementations, the training examples may be provided by the user computing device 102 if the user has provided consent (e.g., based on communications previously provided by the user of the user computing device 102). Thus, in such implementations, the model 120 provided to the user computing device 102 may be trained by the training computing system 150 for user-specific communication data received from the user computing device 102. In some cases, this process may be referred to as a personalization model.
The model trainer 160 includes computer logic for providing the desired functionality. Model trainer 160 may be implemented in hardware, firmware, and/or software that controls a general purpose processor. For example, in some implementations, model trainer 160 includes program files stored on a storage device, loaded into memory, and executed by one or more processors. In other implementations, the model trainer 160 includes one or more sets of computer-executable instructions stored in a tangible computer-readable storage medium, such as a RAM hard disk or an optical or magnetic medium.
FIG. 1A illustrates one example computing system that can be used to implement the present disclosure. Other computing systems may also be used. For example, in some implementations, the user computing device 102 may include a model trainer 160 and a training data set 164. In such implementations, the model 120 may be trained and used locally at the user computing device 102. In some such implementations, the user computing device 102 may implement the model trainer 160 to personalize the model 120 based on user-specific data.
FIG. 1B depicts a block diagram of an example computing device 10, performed in accordance with an example embodiment of the present disclosure. Computing device 10 may be a user computing device or a server computing device.
As shown in fig. 1B, each application may communicate with a plurality of other components of the computing device, such as one or more sensors, a context manager, a device state component, and/or additional components. In some implementations, each application can communicate with each device component using an API (e.g., a public API). In some implementations, the API used by each application is specific to that application.
Fig. 1C depicts a block diagram of an example computing device 50, performed in accordance with an example embodiment of the present disclosure. Computing device 50 may be a user computing device or a server computing device.
The central intelligence layer includes a number of machine learning models. For example, as shown in FIG. 1C, a respective machine learning model (e.g., model) can be provided for each application and managed by a central reporting layer. In other implementations, two or more applications may share a single machine learning model. For example, in some implementations, the central intelligence layer may provide a single model (e.g., single model) for all applications. In some implementations, the central advisory layer is included within or implemented by the operating system of computing device 50.
The central advisory layer may be in communication with the central device data layer. The central device data layer may be a centralized data store of computing devices 50. As shown in fig. 1C, the central device data layer may communicate with a plurality of other components of the computing device, such as one or more sensors, a context manager, a device status component, and/or additional components. In some implementations, the central device data layer can communicate with each device component using an API (e.g., a private API).
FIG. 2 is a simplified schematic diagram of a computing system 200, the computing system 200 configured to perform a training process to train a machine learning model based on a training data set comprising a plurality of training examples. In some implementations, elements of the computing system 200 may be included in the model trainer 160 of the training computing system 150 of fig. 1. The computing system 200 may include a computer-readable storage disk 201, a first set of hardware components 202, an intermediate data buffer 204, and a second set of hardware components 206. The computer-readable storage disk 201 and/or the intermediate data buffer 204 may correspond to the memory 154 of fig. 1A. The first set of hardware components 202 and the second set of hardware components 206 may correspond to the first set of hardware components 160 and the second set of hardware components 162 of fig. 1A. The computing system 200 may be configured to perform a training process to train a machine learning model, for example, as described below with reference to the machine learning model 300 of fig. 3 and the methods 400, 500 of fig. 4 and 5. The computing system 200 may train the machine learning model 300 based on training data that includes a plurality of training examples. The computer-readable storage disk 201 may be configured to store a plurality of training examples.
The first set of hardware components 202 may be configured to run a first set of training operations to access a plurality of training examples from the computer-readable storage disk 201 and prepare the plurality of training examples for training the machine learning model. The first set of hardware components 202 may include one or more general purpose processors. The first set of hardware components 202 may store the prepared training examples at an intermediate data buffer 204, which intermediate data buffer 204 may be configured to store the prepared training examples.
More specifically, the intermediate data buffer 204 may be used to store training data output by the first set of hardware components 202. The second set of hardware components 206 may access training data stored in the intermediate data buffer 204 to train the machine learning model using the training data. Training examples included in the training data may also be shuffled in the intermediate data buffer 204 or accessed from the intermediate data buffer 204 in a non-continuous manner (e.g., randomly, probabilistically, etc.). Accordingly, the intermediate data buffer 204 may facilitate storing and accessing training examples for training a machine learning model, including using iterative iterations.
The second set of hardware components 206 may include one or more application specific integrated circuits. For example, the application specific integrated circuit may include a hardware accelerator that includes a graphics processing unit(s) or a tensor processing unit(s).
The second set of hardware components 206 may be configured to run a second set of training operations to access the prepared training examples from the intermediate data buffer 204 and train the machine learning model using the prepared training examples. The second set of hardware components 206 may be configured to perform one or more iterative iterations in which the second set of hardware components 206 iteratively accesses the prepared training example(s) from the intermediate data buffer 204 and iteratively uses the prepared training example(s) to train the machine learning model. The rate at which the second set of hardware components 206 is configured to perform the iterative iteration(s) may be based at least in part on an echo factor, e.g., as described herein. The echo factor may be based at least in part on a comparison of a first computation time associated with the first set of hardware components 202 performing a first set of training operations and a second computation time associated with the second set of hardware components 206 performing a second set of training operations.
Example model arrangements
Fig. 3 depicts a block diagram of an example machine learning model 300, according to an example embodiment of the present disclosure. In some implementations, the machine learning model 300 may be trained to receive the training example(s) 302 included in the training data set and, as a result of receiving the training example(s) 302, provide training output 304, e.g., by the second set of hardware components 206 described above with reference to fig. 2. The training output 304 may include any suitable output of the machine learning model 300. Examples include object detection/recognition output, voice recognition/identification output, natural language output, embedding, and/or any other output suitable for use in a machine learning model.
The training example(s) 302 may include various suitable training data types (e.g., images, audio, video, sensor data, statistical information, etc.). The plurality of training examples (or plurality) 302 may be received from a plurality of data sources including publicly available training data sets (e.g., image data sets, audio data sets, sensor data sets, etc.) and/or from a user of a mobile device (e.g., user computing device 102 of fig. 1A). For example, training data may be obtained or generated based on interactions with a user of the mobile device, user preferences, and/or the like (e.g., to customize the machine learning model 300 for the user). In some implementations, training examples collected from a user of a mobile device can be given priority over training examples collected from other sources for repeated iterations. Importantly, a user may be provided with controls that allow the user to select whether and when the systems, programs, or features described herein may enable the collection of user information (e.g., preferences). In addition, certain data may be processed in one or more ways before being stored or used in order to remove identifiable personal information. For example, the identity of the user may be processed such that no identifiable personal information can be determined for the user. Thus, the user may have control over which information is collected about the user, how the information is used, and which information is provided to the user.
Example method
Fig. 4 depicts a flowchart of an example method 400 for reducing idleness in a machine learning training system according to an example embodiment of the present disclosure. Although fig. 4 depicts steps performed in a particular order for purposes of illustration and discussion, the methods of the present disclosure are not limited to the particular illustrated order or arrangement. The various steps of the method 400 may be omitted, rearranged, combined, and/or adjusted in various ways without departing from the scope of the present disclosure.
At 402, a computing system may perform a first set of training operations to access and prepare a plurality of training examples included in a set of training data. As an example, the first set of training operations may include reading, decoding, shuffling, enhancing, and/or batching training data. The first set of training operations may be performed by a first set of hardware components, for example, as described with reference to fig. 3 and 5. However, other suitable training operations may be performed to access and prepare the training examples. The appropriate training operation may be selected depending on the attributes of the machine learning model being trained and/or the attributes of the training data (e.g., size, complexity, type, etc.).
At 404, the computing system may perform a second set of training operations to train the machine learning model based at least in part on the set of training data. The second set of training operations may include inputting training examples into the machine learning model and adjusting parameters of the machine learning model based on an evaluation of training outputs received from the machine learning model, for example, as described with reference to fig. 5. The second set of training operations may be performed by a second set of hardware components, e.g., as described herein with reference to fig. 3 and 5.
At 406, the computing system may repeat the iteration (e.g., some or all of the second set of training operations 404) based on an echo factor based at least in part on a comparison of a first computation time associated with performing the first set of training operations 402 and a second computation time associated with performing the second set of training operations 404. The iterative iterations may be included in the second set of training operations 404 and/or performed by a second set of hardware components.
More specifically, for the same training example, a number of iterations based on the echo factor may be performed at 406 (e.g., by the second set of computing hardware components). The number of iterations repeated for a given training example may be positively correlated or otherwise based on the echo factor. For example, an echo factor of two may correspond to performing a single iteration over each training example, resulting in a total of two iterations per training example. The echo factor may be selected to reduce (e.g., minimize, eliminate, etc.) idle time (e.g., idle time of the second set of computing devices). As described above, the idle time may be defined when a first set of training operations at 402 (e.g., pre-processing training data) is being performed and a second set of training operations at 404 (e.g., training a model based on the pre-processed training data) is not being performed.
The echo factor may be based on a computation time and/or rate associated with accessing data and/or training a machine learning model to minimize idle time. More specifically, the echo factor may be based on a comparison of a first computation time associated with performing the first set of training operations 402 and a second computation time associated with performing the second set of training operations 404. As an example, the first or second computation time may include or describe an average computation time (e.g., a total average time of processing times for a set of training examples having a known size, complexity, etc.) and/or an average computation rate (e.g., training examples per unit time or other suitable metric) associated with the first set of training operations 402 and/or the second set of training operations 404. The computation time may include other suitable metrics that may be used to estimate when idle time occurs or to determine the number of iterations of repetition required to reduce or eliminate idle time.
For example, a comparison of the first computation time and the second computation time may be used to determine an expected time at which the second set of training operations 404 will become idle without data echoes. The echo factor may then be determined such that the first computation time and the adjusted second computation time (including data echo) are approximately equal, thereby reducing or eliminating idleness of the second set of training operations 404.
In some implementations, the training example(s) may be probabilistically selected for repeated iterations based on echo factors at 406 such that repeated iterations are performed on some training examples and not other training examples. This may facilitate data echo by echo factors rather than integer values. For example, in one example, an echo factor of 2 may result in successive iterations of each of a plurality of training examples, for a total of two iterations of each training example. An echo factor of 1 may result in no iteration being performed repeatedly. Probabilistically selecting the training example(s) may facilitate implementation of non-integer echo factors (e.g., between one and two) by probabilistically skipping training examples for repeated iterations based on the echo factor, such that repeated iterations are performed at a desired average rate corresponding to the echo factor. For example, an echo factor of 1.5 may result in probabilistically skipping about half of the training examples, such that the total number of iterations (including fresh training examples and repeated iterations) may be equal to 150% of the number of fresh training examples. Thus, the probabilistic selection of training examples may be used to implement non-integer echo factors, which may be used to more accurately adjust or tune the number of repeated iterations, thereby reducing idle time.
The above iterative iterations may be performed at 406 for each training example, and thus may be described as an "example level" data echo. Rather, "batch level" data echo may be employed in other implementations. For batch-level data echo, repeated iterations (e.g., sequentially) may be performed on each training example of a batch of training examples. More specifically, a set of training steps (e.g., some or all of the second set of training operations 404) may be performed on the first training example, then on the second training example, and so on until the training steps of the second set of training operations 404 are performed on each training example of the batch. The set of training steps of the second set of training operations 404 may then be repeated in the same manner for each training example in the batch of training examples. The training steps (e.g., some or all of the second set of training operations 404) may be repeated for the batch, the number of repetitions based on the echo factor. Thus, batching echoes may include repeating iterations for multiple batches of training examples rather than repeating iterations for individual training examples.
It has been found that batch echo can sometimes be better than example level echo, for example, with relatively larger batch sizes. Example level echoes sometimes require more shuffling than batch level echoes. Appendix a, which is incorporated into and forms a part of this disclosure, provides additional description and experimental data on batch-level and example-level echoes.
In some implementations, the echo factor may be a static hyper-parameter that is manually selected or determined by a user or operator of the computing system. The echo factor may also be determined (e.g., by a user, an operator, or automatically by a computing system) based on information about the hardware components (e.g., processing power, available buffer size, etc.) and/or training data (e.g., size, complexity, etc.). Thus, the echo factor can be customized or personalized to the system to minimize idle time and optimize the efficiency of the model training system.
In other implementations, the computing system may dynamically adjust the echo factor (e.g., during execution of the first set of training operations 402 and/or the second set of training operations 404). For example, the computing system may increase the echo factor when a new training example is unavailable or is expected to become unavailable (e.g., from the first set of training operations 402). Thus, the model training system may dynamically adjust the number of iterations of the training examples in real-time based on the availability (or expected availability) of fresh training examples.
As another example, the echo factor may be dynamically adjusted based on real-time monitoring information about the training process and/or hardware components used to train the machine learning model. For example, the computing system may monitor, in real-time, a first computation time associated with performing the first set of training operations 402 (e.g., by the first set of hardware components) and/or a second computation time associated with performing the second set of training operations 403 (e.g., by the second set of hardware components). The computing system may dynamically adjust the echo factor in real-time based at least in part on a comparison of the first computation time and the second computation time to reduce idle time in real-time (e.g., during training of the machine learning model). As described above, idle time may be defined when the first set of training operations 402 is being performed while the second set of training operations 404 is not being performed.
As another example, the echo factor may be adjusted based on a loss function. The loss function may be evaluated with respect to the machine learning model and the given training example to determine a loss value for the training example, e.g., as described below with reference to step 518 of method 500 of fig. 5. The echo factor may be positively correlated with the loss value of the training example, such that at 406, more iterations of repetition may be performed for the training example that incur a higher loss value than for the training example that incur a lower loss value. Thus, the number of iterations to repeat for a particular training example may be intelligently selected to maximize the value of repeating the selected training example.
At 406, repeated iterations may be performed on less than all of the training examples of the training data. As one example, at 406, the training example(s) may be selected for repeated iteration based on a loss function that evaluates at least some of the plurality of training examples and the machine learning model to determine respective loss values for the training examples. At 406, training examples with higher associated loss values (e.g., relatively higher than the loss values of other training examples in the training data) may facilitate repeated iterations. At 406, training examples with relatively more correlated loss values may not be favorable for repeated iterations. For example, at 406, the amount of training examples needed for the repeated iterations may be calculated (e.g., to prevent or minimize idle time). Corresponding loss values for the training examples may then be calculated. The training examples may then be ranked according to their respective loss values. Then, at 406, a subset of the plurality of training examples may be selected for repeated iterations based on the respective loss value rankings of the plurality of training examples and the amount of training examples needed (e.g., to avoid or reduce idleness). Thus, at 406, the computing system may be configured to intelligently improve or maximize the effectiveness of performing repeated iterations to train the machine learning model.
As another example, at 406, the training example(s) may be selected for repeated iterations based on the relative position of the training data in the training examples. At 406, a more recent (or recent) training example used to train the machine learning model may be selected for repeated iterations. This may provide the benefit of being easy to implement and may require less computing resources. For example, calculation of a loss value for a training example may potentially be avoided, such as for machine learning methods, where the loss value need not be calculated.
As another example, at 406, the training example(s) may be selected for repeated iterations based on their respective data sources. As described above, training examples may be received from multiple data sources including publicly available training data sets (e.g., image data sets, audio data sets, etc.) and/or from a user of the mobile device (if the user has agreed). Training data can be obtained or generated based on interactions with a user of the mobile device, user preferences, and the like (e.g., to customize a machine learning model for the user). The training examples collected from the user of the mobile device may be given priority for repeated iterations over training examples collected from other sources.
Fig. 5 depicts a flowchart of an example method 500 for reducing idleness in a machine learning training system, according to an example embodiment of the present disclosure. Although fig. 5 depicts steps performed in a particular order for purposes of illustration and discussion, the methods of the present disclosure are not limited to the particular illustrated order or arrangement. The various steps of the method 500 may be omitted, rearranged, combined, and/or adjusted in various ways without departing from the scope of the present disclosure.
The method 500 may include: a first set of training operations 502, accessing and preparing a plurality of training examples included in a set of training data; and a second set of training operations 504 to train the machine learning model based at least in part on the set of training data. The first set of training operations 502 may be performed by a first set of hardware components and the second set of training operations 504 may be performed by a second set of hardware components, e.g., as described above with reference to fig. 3 and 4.
The first set of operations 502 may include various preparation operations with respect to training data. For example, the first set of operations 502 may include reading and/or decoding training data at 506, shuffling training data at 508, enhancing training data at 510, and/or batch processing training data at 512. However, other suitable training operations may be performed to access and prepare the training examples. The appropriate training operation may be selected depending on the attributes of the machine learning model to be trained and/or the attributes of the training data (e.g., size, complexity, type, etc.).
Enhancing the training data at 510 may include applying a transformation to the training examples to generate additional transformed training examples. As an example, training examples including images may be resized, mirrored, rotated, cropped, and/or tiled. Additionally or in combination, one or more attributes of the training examples may be adjusted, such as brightness, contrast, saturation, and so forth. Any suitable transformation known in the art may be used. Other types of transformations may be applicable to other types of training data (e.g., audio, preferences, statistics, etc.).
Thus, at 510, one or more training examples may be enhanced by applying a transformation to the training example(s) in the first set of training operations 502 (e.g., by the first set of hardware components) such that, at 522, in the second set of operations 504, the training example(s) remain unchanged during the repeated iteration(s). Thus, the machine learning model may be trained on the same training examples that are repeated. This configuration is useful in the case where the training value of the training example(s) is maximum without enhancement. However, it should be understood that in some implementations, data enhancement may additionally or alternatively be included in the second set of training operations 504, e.g., as described below with reference to enhancing training data at 524.
The second set of operations 504 may include a series of training operations to train the machine learning model based at least in part on the training data. For example, at 514, the second set of hardware components may input the training example(s) in the set of training data into the machine learning model. At 516, the second set of hardware components may receive one or more training outputs as outputs of the machine learning model, e.g., as described above with reference to fig. 3.
At 518, the second set of hardware components may evaluate the training output(s), e.g., as described above with reference to fig. 3. Evaluating the training output at 518 may include evaluating a loss function for the training output of the machine learning model. For the loss function, errors may be propagated back through layers of the neural network of the machine learning model.
At 520, the second set of hardware components may adjust parameters of the machine learning model based at least in part on the evaluation of the at least one training output. Various suitable methods may be used to adjust the parameters of the machine learning model based on the loss function, including, for example, random gradient descent.
At 522, repeated iterations may be performed on some or all of the training examples based on an echo factor based at least in part on a comparison of a first computation time associated with performing the first set of training operations 502 and a second computation time associated with performing the second set of training operations 504, e.g., as described above with reference to fig. 4. For example, the training example(s) may be probabilistically selected for iterative iteration (e.g., step 514-520) based on echo factors such that iterative iteration is performed for some training examples and not performed for other training examples. This may facilitate data echo by echo factors rather than integer values. Training examples may be retrieved from the intermediate data buffer as needed. As described above, training examples may be shuffled and/or accessed discontinuously in the intermediate data buffer. However, in other implementations, the training examples may be continuously visited such that the same training example is continuously repeated in repeated iterations.
In one example, in each training example, an echo factor of 2 may result in repeating iterations for each of a plurality of training examples, for a total of two repeating iterations for each training example, at 522. An echo factor of 1 may result in no iteration being performed at 522. Probabilistically selecting the training example(s) for the repeated iteration may facilitate achieving an echo factor between one and two by probabilistically selecting a training example for the repeated iteration based on the echo factor at 522, such that the repeated iteration is performed at 522 at a desired average rate corresponding to the echo factor. For example, an echo factor of 1.5 may result in probabilistically selecting half of the training examples for repeated iterations at 522, such that the total number of iterations (including fresh training examples and repeated iterations) is equal to 150% of the number of fresh training examples.
The iterative iterations at 522 above may be performed for each training example, and thus may be described as an "example level" data echo. Rather, "batch level" data echo may be employed in other implementations. For batch-level data echo, a repeat iteration may be performed on each training example of a batch of training examples at 522 (e.g., before repeating the iteration on any member of the batch of training examples). More specifically, the training steps (e.g., steps 514 and 520) may be performed on the first training example, then on the second training example, and so on until the training steps are performed on each training example of the batch. The training steps may then be repeated for each training example in the batch of training examples in the same manner. The training step (e.g., step 514-520) may be repeated for the batch at 522, the number of repetitions being based on the echo factor. Thus, batch-level echo may be employed by repeating the iteration for this batch of training examples at 522, rather than repeating the iteration for each training example. For relatively larger batch sizes, batch echo may sometimes perform better than example-level echo.
In some implementations, the data enhancement at 524 can be performed in the second set of training operations 504. One or more training examples may be enhanced at 524 such that the training example(s) are enhanced during one or more repeated iterations. Although shown after repeated iterations at 522, it should be understood that the enhanced training data at 524 may be performed in conjunction with repeated iterations at 522, such that some or all of the repeated iterations at 522 may be performed using an enhanced version of the fresh training example(s). In some cases, this may improve the training value of the repeated iterations as compared to repeating the same training example. In some implementations, data enhancement may be performed in the first set of training operations 502 (e.g., at 510) and the second set of training operations 504 (e.g., at 524).
Additional disclosure
The techniques discussed herein make reference to servers, databases, software applications, and other computer-based systems, as well as actions taken and information sent by such systems. The inherent flexibility of computer-based systems allows for a wide variety of possible configurations, combinations, and divisions of tasks and functions between components. For example, the processes discussed herein may be implemented using a single device or component or multiple devices or components operating in combination. The database and applications may be implemented on a single system or may be distributed across multiple systems. The distributed components may operate sequentially or in parallel.
While the present subject matter has been described in detail with respect to various specific example embodiments thereof, each example is provided by way of illustration, and not limitation of the present disclosure. Alterations, modifications and equivalents may readily occur to those skilled in the art, upon an understanding of the foregoing. Accordingly, the present disclosure does not preclude inclusion of such modifications, variations and/or additions to the present subject matter as would be readily apparent to one of ordinary skill in the art. For instance, features illustrated or described as part of one embodiment, can be used with another embodiment to yield a still further embodiment. Accordingly, it is intended that the present disclosure cover such alternatives, modifications, and equivalents.
Appendix A
Faster neural network training with data echo
Anonymous authors
Unit of
Address
Electronic mail
Abstract
In moore's law eosin, GPUs and other specialized hardware accelerators have greatly accelerated the training speed of neural networks. However, early stages of the training pipeline (such as disk I/O and data pre-processing) do not run on the accelerator. With the continued improvement of accelerators, these early stages will become increasingly bottlenecks. In this context, we introduce "data echo" which reduces the total amount of computation used in the early pipeline stages and speeds up the training speed when the training time is taken up upstream of the accelerator's computations. Data echoes are reused (or "echoes") at the intermediate output of the early pipeline stages to reclaim spare capacity. We studied the behavior of different data echo algorithms at various workloads, various echo volumes, and various batch sizes. We have found that at least one data echo algorithm can use fewer upstream computations to match the predicted performance of the baseline under all settings. In some cases, the data echo can compensate even for an input pipeline that is 4 times slower.
1. Introduction to the design reside in
Over the past decade, significant increases in neural network training speed have enabled researchers to train larger data sets using larger data setsAnd explores new ideas more quickly, thereby facilitating a significant improvement in predictive performance. With the end of moore's law, general-purpose processors are no longer getting faster quickly, but specialized hardware continues to push significant speedup by optimizing a narrower set of operations. E.g. GPU and TPU1And optimizing highly parallel matrix operation, which is a core component of a neural network training algorithm.
However, training a neural network not only requires good operation on the accelerator, so we cannot rely solely on accelerator improvements to maintain acceleration under all conditions. The training program may need to read and decompress the training data, reorganize it, batch it, and even transform or enhance it. These steps may use a number of system components including CPU, disk, network bandwidth, and memory bandwidth. It is impractical to design dedicated hardware for all these general operations involving so many different components. At the same time, improvements in accelerators are outpacing improvements in general purpose computing, and there have been workloads that: code running on the accelerator consumes only a small portion of the total wall time. Thus, if we want to continue to train the neural network faster, we must either (1) make the non-accelerator work faster, or (2) reduce the amount of non-accelerator work required to achieve the desired predicted performance. Although scheme (1) is attractive, it may require a significant amount of engineering labor or a technique that is not easily generalized (e.g., Zhu et al, 2018; Ying et al, 2018; Kumar et al, 2017). Adding more workers may be too expensive, if possible, or add too much complexity to the system. Instead, we focus on option (2) and explore techniques that reduce the overall workload performed at the early stages of the training pipeline.
We can view the neural network training program as a data pipeline of buffering and overlapping computations. For example, FIG. 6 shows a typical small batch random gradient descent (SGD) training pipeline and its variants, which are de facto standard algorithms for training neural networks. The training program first reads and decodes the input data, then shuffles the data, applies a set of transformations to enhance the data, and collects the examples in batches. Finally, the program iteratively updates the parameters of the neural network to reduce the loss function of continuous batch processing; we call this stage "SGD update", regardless of which SGD variant is used. Alternative sequences of these stages are also possible, with some pipelines possibly omitting stages or adding new stages. Since the output of any pipeline stage can be buffered, the computations of the different stages overlap and the slowest stage dominates the training time. Modern accelerators emphasize any slowness of other pipeline stages by making it unlikely that optimized matrix operations dominate the overall training time.
In this work, we studied how to speed up neural network training by reducing the total time spent in the early part of the training pipeline, which exceeds the time spent in the later part of the pipeline (see (a) in fig. 7). This situation is realistic today and will become more prevalent if the improvements of the accelerator continue beyond general purpose CPUs and I/os. In particular, we consider an algorithm that reuses the output of the first portion of the pipeline for multiple SGD updates to take advantage of idle processing power. We call this type of algorithm data echo and each intermediate output uses the number of times the echo factor.
The data echo algorithm inserts a repetition phase (optional shuffling) somewhere in the training pipeline before the SGD update. If the time spent by the upstream task (before the repetition phase) exceeds the time spent by the downstream task (after the repetition phase), then this technique will reclaim spare downstream computing capacity and increase the SGD update rate of the model (see (b) in fig. 7). By varying the selection of insertion points in the pipeline, the echo factor, and the amount of shuffling, different data echo algorithms with different behaviors can be implemented.
Herein, we demonstrate that:
1. data echo reduces the amount of upstream computation required to achieve competitive off-sample error rates on various data sets and model architectures;
2. data echoes can support a wide range of echo factors;
3. the effectiveness of the data echo depends on the insertion point in the training pipeline;
4. data echo may benefit from additional shuffling after echo, but it is not required; and
5. contrary to expectations, the data echo reached the same error rate as the adjusted baseline.
1.1 related work
The data echo is similar to the empirical playback (Mnih et al, 2015), which samples batches from a buffer containing the reinforcement learning agent's past experience to prevent recent interactive control updates. While both data echo and empirical playback reuse previous data, our data echo implementation chooses the number of times each example is repeated, and most implementations of empirical playback do not explicitly control this. Furthermore, the local SGD algorithm (Zinkevich et al, 2010; Zhang et al, 2016), which performs multiple local model updates prior to global communication, can be viewed as reusing data to save computation. However, the local SGD targets the overhead of communication between workers and is therefore orthogonal to the data echo.
We know that the two previous papers describe variations of data echo. Fischetti et al (2018) describe a special data echo case called "mini-batch persistence" that reuses mini-batches for multiple consecutive SGD updates. They run experiments on CIFAR-10 but did not adjust the meta-parameters for baseline or method. In their experiments, neither their methods nor baselines reached competitive test set numbers, which left a pending question whether small lot persistence was more advantageous than a well-adjusted baseline. Similarly, Hoffer et al (2019) describe a special data echo case, called "bulk enhancement," with the example repeated multiple times within a given batch, but with different enhancements. None of their experiments adjusted the optimization meta-parameters, although their baseline usage settings were taken from the original paper that introduced each model. Fischetti et al (2018) and Hoffer et al (2019) primarily motivate their work as a way to improve generalization, only to mention slightly the possibility of reclaiming spare computing capacity. For a fixed number of SGD updates, we do not want data echoes to improve generalization capability because repeated data is more valuable than new data. Our experiments in the third section only show that data echoes can get better out-of-sample errors with the same amount of fresh data.
2. Data echo
We implement data echo by inserting a stage in the training pipeline that repeats (echoes) the output of the previous stage. In some cases we also shuffle the output of the echo stage, but this may require additional memory. If the overhead of duplicate data is negligible and the stages on either side of the echo are performed in parallel (e.g., Chien et al, 2018), then the average time for the data echo to complete one upstream step and e downstream steps is
max{tupstream，e×tdownstream}， (1)
Wherein t isupstreamIs the time taken by all upstream stages of echo, tdownstreamIs the time spent all downstream of the echo, e is the echo factor. Let us assume tupstream≥tdownstreamSince this is the main motivation to use data echo. If we use R ═ tupstream/tdownstreamRepresenting the ratio of upstream to downstream processing times, the time to complete an upstream step and e downstream steps is the same for all echo factors e to R. In other words, the additional downstream steps are "free" in that they utilize free downstream capacity. Non-integer echo factors can be expected by probabilistically repeating data items.
When using data echo, the reduction in training time (if any) depends on the trade-off between upstream and downstream steps. On the one hand, since duplicate data may not be as valuable as completely fresh data, the data echo may require more downstream SGD updates to achieve the expected predicted performance. On the other hand, data echo only requires 1/e (instead of 1) upstream steps per downstream step. If the number of required downstream steps increases by a factor less than e, the total number of upstream steps (and therefore the total training time) will decrease. R is the maximum likelihood acceleration of the data echo, which will be achieved if e-R and the duplicate data is as valuable as the new data.
Considering that each operation in the training pipeline takes some time to perform, R is maximum if the data echo is applied just before the SGD update, which will result in the same batch being used multiple times in each epoch. However, despite the overhead, we may prefer to insert data echoes earlier in the pipeline if a more favorable trade-off is provided between the number of upstream and downstream steps. In particular, the following factors affect the behavior of data echoes at different insertion points.
Pre-batch echo or post-batch echo: pre-batch echo refers to repeating and shuffling data at the sample level rather than at the batch level. This increases the likelihood that adjacent batches will differ, but at the cost of potentially duplicating examples in a batch. Batch or batch operation is more important, which is an empirical issue we discuss in section 3. We refer to the class of algorithms for echoes at the example level as example echoes and the class of algorithms for echoes at the batch level as batch echoes.
Pre-or post-enhanced echo: the echo before data enhancement allows the repeated data to be transformed in different ways, bringing the repeated data closer to the new data. A similar objective can be achieved by adding noise during SGD update, such as random deactivation, even in the absence of enhancement or post-enhancement echo (Hoffer et al, 2019).
TABLE 1 service profiles
The behavior of the data echo is also affected by the amount of shuffling performed after the echo phase, if any. Where applicable, we implement the shuffling stage as a buffer in which previous pipeline stages randomly sample entries. The larger the buffer size, the more echo data is shuffled and the closer the training algorithm is to a program that loads the entire training set into memory before randomly sampling the data. For some workloads a relatively large buffer size may be very realistic, but we are mainly interested in that in this case we can only provide one buffer size, which is a fraction of the (augmented) data set size.
3. Experiment of
We evaluated the data echoes of two language modeling tasks, two image classification tasks, and one object detection task. For language modeling, we are at LM1B (Chelba et al, 2014) and Common Crawl2The transducer self-attention model was trained on the dataset (Vaswani et al, 2017). For image classification, we trained the ResNet model (He et al, 2016) on CIFAR-10(Krizhevsky and Hinton, 2009) and ImageNet datasets (Russakovsky et al, 2015). For object detection, we trained a single point detector (SSD, Liu et al, 2016) on the COCO dataset (Lin et al, 2014).
The primary problem we have studied is whether the data echo can provide training acceleration. We measure training time as the number of "fresh" training examples needed to reach the target sample outlier value. The echoed data is not counted as new data, but for models trained for multiple epochs, a fresh example is counted for each reading of a given example. The number of fresh example reads is proportional to the number of upstream steps in the training pipeline (see section 2). If e ≦ R, the number of fresh instances needed is a proxy for the total training time, and any reduction in this value will be reflected proportionally in the wall time (provided the overhead of data echo is negligible). In our experiments, we do not assume or measure the actual value of R, since R depends on the implementation and may change with future hardware development. In our implementation, not all tasks satisfy R ≧ 1. Instead, we designed our experiments to investigate whether data echo can reduce the number of fresh examples needed for different tasks, since this measure is implementation independent. In the best case, duplicate data is as useful as fresh data, and the number of fresh instances required will reduce the echo factor. In the worst case, the number of fresh examples needed will increase, or the model will not be able to achieve the target sample outlier value. However, neither of these cases occurred in any of our experiments-in the worst case, we observed that the number of fresh instances needed to reach the target metric value did not change (within the error bars).
For each workload, we run a set of initial experiments without data echo and adjusted the metapa parameters to obtain the best off-sample performance within the actual computational budget. We then choose the target metric value to be slightly below the optimum value to ensure that this value can be reliably reached. We demonstrate that minor changes to the target do not affect our conclusions. Table 1 summarizes the workload and target metric values we used in the experiment.
We trained the SSD model using momentum-bearing SGD (Polyak, 1964; Rumelhart et al, 1986), the transducer and ResNet model using Nesterov momentum (Nesterov, 1983; Sutskeeper et al, 2013). We use a constant learning rate for the converter and a learning rate table for ResNet (linear decay) and SSD (linear post-preheat piecewise exponential decay). We performed the same pre-processing on the text dataset as Shallue et al (2018). We enhance the image dataset at training by resizing each image, random cropping, and random horizontal reflection cropped images. We randomly distorted the image colors of ImageNet and COCO. Unless otherwise noted, we use a batch size of 1024 for the variators, 128 for ResNet-50, and 256 for ResNet-32. We used batch normalization (Ioffe and Szegedy, 2015) for ResNet-50 and SSD for virtual batch sizes (Hoffer et al, 2017) of 32 and 128, respectively.
In each experiment, we adjusted the learning rate, momentum, and, where applicable, the parameters controlling the learning rate schedule independently. We manually select the search space on the basis of initial experiments and verify after each experiment whether the optimal meta-parameter values are far from the search space boundaries. We used quasi-random search (Bousquet et al, 2017) to adjust for non-divergent with fixed budget3The meta-parameters of the experiment (100 for the inverter and ResNet-32, 50 for ResNet-50 and SSD). Then, we selectThe trial to reach the target metric value is selected using the fewest fresh examples. We repeat this meta-parameter search 5 times for each search space. All figures in this section show the mean of the new line examples required for these 5 experiments, with the minimum and maximum values shown as error bars.
Our experiments evaluated the effect of adding data echoes in a typical neural network training pipeline (fig. 6). We consider three variants of data echo: example pre-enhanced echo, example post-enhanced echo, and batch echo. For the example echo variant, we omit the baseline "shuffling example" buffer and insert a shuffling buffer of the same size as the baseline buffer after the echo phase. For batch echo, we keep a baseline "shuffling exemplar" buffer and simply repeat the batch after the "batch exemplar" (no shuffling). Thus, in all cases, our training pipeline always has one buffer of the same size, so all data echo variants use the same amount of memory as the baseline. We chose the buffer size to reasonably shuffle the examples in each epoch (10 for LM1B and Common Crawl)6For CIFAR-10 is 10410 for ImageNet5And for COCO is 104). We discuss the effect of increasing buffer size in section 3.5.
3.1 data echo can reduce the number of fresh examples required for training
Fig. 8 shows the effect of data echo e-2 for all workloads in table 1. In all but one case, data echo requires fewer fresh examples than baseline to achieve target off-sample performance. The only exception (batch echo on ResNet-50) requires as many fresh instances as the baseline-although data echo has no benefit, it does not compromise training. The earlier the echo is inserted in the pipeline, the fewer fresh examples are needed: the example echo requires fewer fresh examples than the batch echo, and the echo before data enhancement requires fewer fresh examples than the echo after. For ResNet-50 or SSD, we did not observe any negative interaction between data echo and batch normalization.
3.2 data echo can reduce training time
Fig. 9 shows the fractional change in training time (assuming negligible echo overhead), different echo factors assuming different R values. If R is 1, the data echo is either increased or the training time is not changed significantly. If R >1, any selection of e ≦ R will reduce training time by setting the maximum acceleration achieved by e ≦ R. Setting e > R does not reduce the training time of the transformer on LM1B, but it does provide acceleration for ResNet-50 on ImageNet, even if e is 4 and R is 1.5. These results indicate that data echo can reduce the training time for a range of echo factors around the optimum value e R, especially when e ≦ R.
3.3 data echoes are useful within a reasonable upper bound on the echo coefficient
Fig. 10 shows the effect of an example echo with an echo factor of up to 16 for the transformer on LM 1B. For a batch size of 1024, the maximum effective echo factor is between 4 and 8; beyond this value, the number of fresh instances required is greater than the number required for a smaller echo factor. The number of fresh examples needed eventually must exceed the baseline as the echo factor increases, but even with an echo factor of 16 this requires far fewer fresh examples than the baseline. For a batch size of 4096, the maximum effective echo factor is even greater than 16, indicating that a larger batch size can support a larger echo factor than a smaller batch size.
3.4 data echo as batch size increases
With larger batch sizes, batch echo performs better, but example echoes sometimes require more shuffling. Fig. 11 shows the echo effect of data of different batch sizes, e-2. As the batch size increases, the batch echo performance relative to the baseline either remains unchanged or increases. This effect is significant because when the batch size approaches the training set size, the repeated batch should approximate the new batch, and therefore, within limits, the batch echo must be reduced by the echo factor by the number of fresh instances required. On the other hand, FIG. 11 shows that the performance of the example echo relative to the baseline either remains the same or deteriorates slightly as the batch size increases. Since the expected score of repeating examples in each batch increases with batch size, in practice, examples with larger batches may behave more like smaller batch sizes. Smaller batch sizes may increase the number of SGD updates required (Shallue et al, 2018), which may explain the results of the example echo in fig. 11. Increasing the amount of shuffling of duplicate examples (at the cost of additional memory) can improve the performance of example echoes at larger batch sizes by reducing the probability of duplicate examples in each batch.
3.5 data echo performs better with more shuffling
All batch echo experiments in the previous sections were batch repeated without shuffling. Fig. 12 (a) shows that if repeated batches are shuffled, the performance of the batch echo with e-2 improves (at the cost of extra memory), while more shuffling leads to better performance. Similarly, all example echo experiments in the previous section use the "shuffling example" stage of the original pipeline to shuffle the repeated examples. Fig. 12 (b) shows that as the size of the buffer for the shuffling increases, the performance of the example echo with e-2 improves (at the cost of extra memory), even though it does not help the baseline pipeline. This is because more shuffling reduces the likelihood of duplicate examples in each batch, as described in section 3.4.
3.6 data echo does not compromise prediction performance
While one might worry that reusing data might compromise the final prediction performance, we did not observe any cases where the data echo using a reasonable echo factor failed to reach the target metric. To further demonstrate that data echo does not degrade the quality of the solution, we performed experiments using transformers on LM1B and ResNet-50 on ImageNet to find the best achievable performance, including data echo and no data echo, within the given fresh example budget. We have chosen a fresh example budget so that the baseline transformer pipeline will achieve a cross-entropy error better than 3.9, and the baseline ResNet-50 pipeline will achieve an accuracy of at least 75%. We performed all data echo experiments using e-4. We used 500 transducer trials and 100 ResNet-50 trials to adjust the meta-parameters of baseline and data echoes. In each case, we chose the test that performed best at any time during the training process. Figure 13 shows that for both tasks, all data echo variants achieve at least the same performance as the baseline.
4. Conclusion
Data echo is a simple strategy to increase hardware utilization when the training pipeline encounters a bottleneck at some upstream stage. While a priori one may worry that updating the SGD with repeated data is useless, or even harmful, for each workload we consider, at least one data echo variant reduces the total number of instances we need to read from disk. Even for Common Crawl transducers, since this data set is too large to even train for a full period. In this case, the data echo reaches the target prediction performance, but only a subset of the examples seen at the baseline are seen. The enhanced echo is still effective in reducing the total number of instances read from disk, which makes it attractive for image data sets enhanced with expensive data running on the CPU.
Data echo is a simple and effective alternative to optimizing the training pipeline or adding additional staff to perform upstream data processing, which may not always be possible or desirable. Although the exact acceleration depends on the model structure, data set, batch size, and degree of reorganization of duplicate data, setting the echo factor as a ratio of upstream and downstream processing times maximizes the potential acceleration and works well in our experiments, even at large ratios. As improvements in specialized accelerators like GPUs and TPUs continue to outpace general purpose computing, we expect data echoes and similar strategies to become an increasingly important part of the neural network training toolkit.
1
https://www.blog.google/products/google-cloud/google-cloud-offer-tpus-mach ine-learning/
2http://commoncrawl.org/2017/07/june-2017-crawl-archive-now-available/
3We discarded experiments with divergent training losses, which occur when the learning rate is too high
Reference to the literature
Olivier Bousquet,Sylvain Gelly,Karol Kurach,Olivier Teytaud,and Damien Vincent. Critical hyper-parameters:No random,no cry.arXiv preprint arXiv:1706.03200,2017.
Ciprian Chelba,Tomas Mikolov,Mike Schuster,Qi Ge,Thorsten Brants,Phillipp Koehn, and Tony Robinson.One billion word benchmark for measuring progress in statistical language modeling.In Conference of the International Speech Communication Association,2014.
Steven WD Chien,Stefano Markidis,Chaitanya Prasad Sishtla,Luis Santos,Pawel Herman,Sai Narasimhamurthy,and Erwin Laure.Characterizing deep-learning I/O workloads in TensorFlow.arXiv preprint arXiv:1810.03035,2018.
Matteo Fischetti,Iacopo Mandatelli,and Domenico Salvagnin.Faster SGD training by minibatch persistency.arXiv preprint arXiv:1806.07353,2018.
Kaiming He,Xiangyu Zhang,Shaoqing Ren,and Jian Sun.Deep residual learning for image recognition.In Proceedings of the IEEE conference on computer vision and pattern recognition,pages 770–778,2016.
Elad Hoffer,Itay Hubara,and Daniel Soudry.Train longer,generalize better:closing the generalization gap in large batch training of neural networks.In Advances in Neural Information Processing Systems,pages 1731–1741,2017.
Elad Hoffer,Tal Ben-Nun,Itay Hubara,Niv Giladi,Torsten Hoefler,and Daniel Soudry. Augment your batch:better training with larger batches.arXiv preprint arXiv:1901.09335,2019.
Sergey Ioffe and Christian Szegedy.Batch normalization:Accelerating deep network training by reducing internal covariate shift.arXiv preprint arXiv:1502.03167,2015.
Alex Krizhevsky and Geoffrey Hinton.Learning multiple layers of features from tiny images.Technical report,Citeseer,2009.
Sameer Kumar,Dheeraj Sreedhar,Vaibhav Saxena,Yogish Sabharwal,and Ashish Verma. Efficient training of convolutional neural nets on large distributed systems.arXiv preprint arXiv:1711.00705,2017.
Tsung-Yi Lin,Michael Maire,Serge Belongie,James Hays,Pietro Perona,Deva Ramanan, Piotr Dollar,and C Lawrence Zitnick.Microsoft COCO:Common objects in context.In European conference on computer vision,pages 740–755.Springer,2014.
Wei Liu,Dragomir Anguelov,Dumitru Erhan,Christian Szegedy,Scott Reed, Cheng-Yang Fu,and Alexander C Berg.SSD:Single shot multibox detector.In European conference on computer vision,pages 21–37.Springer,2016.
Volodymyr Mnih,Koray Kavukcuoglu,David Silver,Andrei A Rusu,Joel Veness,Marc G Bellemare,Alex Graves,Martin Riedmiller,Andreas K Fidjeland,Georg Ostrovski,et al. Human-level control through deep reinforcement learning.Nature,518(7540):529,2015.
Yurii Nesterov.A method for unconstrained convex minimization problem with the rate of conver gence O(1/k2).In Doklady AN USSR,volume 269,pages 543–547,1983.
Boris T Polyak.Some methods of speeding up the convergence of iteration methods. USSR Computational Mathematics and Mathematical Physics,4(5):1–17,1964.
David E Rumelhart,Geoffrey E Hinton,and Ronald J Williams.Learning representations by back-propagating errors.Nature,323(6088):533,1986.
Olga Russakovsky,Jia Deng,Hao Su,Jonathan Krause,Sanjeev Satheesh,Sean Ma, Zhiheng Huang,Andrej Karpathy,Aditya Khosla,Michael Bernstein,et al.ImageNet large scale visual recognition challenge.International Journal of Computer Vision,115(3):211–252,2015.
Christopher J Shallue,Jaehoon Lee,Joe Antognini,Jascha Sohl-Dickstein,Roy Frostig, and George E Dahl.Measuring the effects of data parallelism on neural network training.arXiv preprint arXiv:1811.03600,2018.
Ilya Sutskever,James Martens,George E.Dahl,and Geoffrey E.Hinton.On the importance of initialization and momentum in deep learning.In International Conference on Machine Learning,pages 1139–1147,2013.
Ashish Vaswani,Noam Shazeer,Niki Parmar,Jakob Uszkoreit,Llion Jones,Aidan N Gomez,
Chris Ying,Sameer Kumar,Dehao Chen,Tao Wang,and Youlong Cheng.Image classification at supercomputer scale.arXiv preprint arXiv:1811.06992,2018.
Jian Zhang,Christopher De Sa,Ioannis Mitliagkas,and Christopher Re.Parallel SGD: When does averaging helparXiv preprint arXiv:1606.07365,2016.
Yue Zhu,Fahim Chowdhury,Huansong Fu,Adam Moody,Kathryn Mohror,Kento Sato, and Weikuan Yu.Entropy-aware I/O pipelining for large-scale deep learning on HPC systems.In 2018 IEEE 26th International Symposium on Modeling,Analysis,and Simulation of Computer and Telecommunication Systems(MASCOTS),pages 145–156.IEEE,2018.
Martin Zinkevich,Markus Weimer,Lihong Li,and Alex J Smola.Parallelized stochastic gradient descent.In Advances in neural information processing systems,pages 2595–2603, 2010.
Claims (20)
1. A method for reducing idleness in a machine learning training system, the method comprising:
executing, by one or more computing devices, a first set of training operations to access and prepare a plurality of training examples included in a set of training data; and
performing, by the one or more computing devices, a second set of training operations to train the machine learning model based at least in part on the set of training data;
wherein performing, by the one or more computing devices, the second set of training operations comprises: performing, by the one or more computing devices, one or more iterative iterations in which at least a portion of the second set of training operations are repeatedly performed on at least one of a plurality of training examples included in the set of training data such that the at least one training example is repeated for training the machine learning model; and
wherein a rate of the one or more repeated iterations is based at least in part on an echo factor based at least in part on a comparison of a first computation time associated with performing the first set of training operations and a second computation time associated with performing the second set of training operations.
2. The method of claim 1, wherein performing one or more iterations by the one or more computing devices reduces idle time, which occurs when the one or more computing devices are performing the first set of training operations and not performing the second set of training operations.
3. The method of any of the preceding claims, wherein performing, by one or more computing devices, one or more iterations comprises:
for each of a plurality of iterations:
inputting, by one or more computing devices, at least one training example of a set of training data into a machine learning model;
receiving, by one or more computing devices, at least one training output as an output of a machine learning model;
evaluating, by one or more computing devices, at least one training output; and
adjusting, by the one or more computing devices, parameters of the machine learning model based at least in part on the evaluation of the at least one training output;
wherein the number of the plurality of iterations is based at least in part on the echo factor.
4. The method of claim 3, further comprising: the at least one training example is enhanced by the one or more computing devices by applying a transformation to the at least one training example.
5. The method of claim 4, wherein the enhancing, by the one or more computing devices, the at least one training example is included in the first set of training operations such that the at least one training example does not change during the one or more repeated iterations.
6. The method of claim 4, wherein the enhancing, by the one or more computing devices, the at least one training example is included in a second set of training operations such that the at least one training example is enhanced during each of the one or more repeated iterations.
7. The method of any of the preceding claims, wherein performing, by one or more computing devices, one or more iterations further comprises:
performing, by one or more computing devices, a training step on each of a batch of a plurality of training examples of a training data set;
repeating, by the one or more computing devices, the training step for each of the batch of the plurality of training examples of training data is based on a number of repetitions of the echo factor.
8. The method of any of the preceding claims, further comprising: the echo factor is dynamically adjusted by one or more computing devices.
9. The method of any of the preceding claims, further comprising:
monitoring, by one or more computing devices, in real-time, one or both of:
a first computation time associated with performing a first set of training operations; and
a second computation time associated with performing a second set of training operations; and
dynamically adjusting, in real-time, by the one or more computing devices, based at least in part on a comparison of a first computation time associated with performing the first set of training operations and a second computation time associated with performing the second set of training operations to reduce, in real-time, idle time that occurs while the one or more computing devices are performing the first set of training operations and are not performing the second set of training operations.
10. The method of any of the preceding claims, further comprising:
evaluating, by the one or more computing devices, a loss function on the at least one training example and the machine learning model to determine a loss value for the at least one training example; and
adjusting, by the one or more computing devices, the echo factor based on the loss value.
11. The method of any of the preceding claims, further comprising:
evaluating, by the one or more computing devices, a loss function on at least two of the plurality of training examples and the machine learning model to determine a respective loss value for each of the at least two of the plurality of training examples; and
selecting, by the one or more computing devices, at least one training example from the plurality of training examples based on respective loss values of at least two of the plurality of training examples.
12. The method of any of the preceding claims, further comprising: selecting, by the one or more computing devices, at least one training example based on at least one of:
a relative position of the at least one training example in the plurality of training examples; or
A data source of at least one training example.
13. The method of any of the preceding claims, further comprising: at least one training example is probabilistically selected by the one or more computing devices based on the echo factor such that repeated iterations are performed on less than all of the plurality of training examples.
14. A computing system configured to perform a training process to train a machine learning model based on a training data set comprising a plurality of training examples, the computing system comprising:
a computer-readable storage disk configured to store a plurality of training examples;
a first set of hardware components configured to run a first set of training operations to access a plurality of training examples from a computer-readable storage disk, prepare the plurality of training examples for training a machine learning model, and store the prepared training examples in an intermediate data buffer;
an intermediate data buffer configured to store the prepared training samples; and
a second set of hardware components configured to run a second set of training operations to access the prepared training examples from the intermediate data buffer and train the machine learning model using the prepared training examples;
wherein the second set of hardware components is configured to perform one or more iterative iterations in which the second set of hardware components repeatedly accesses the at least one prepared training example from the intermediate data buffer and repeatedly uses the at least one prepared training example to train the machine learning model; and
wherein a rate at which the second set of hardware components is configured to perform the one or more repeated iterations is based at least in part on an echo factor based at least in part on a comparison of a first computation time associated with performing the first set of training operations by the first set of hardware components and a second computation time associated with performing the second set of training operations by the second set of hardware components.
15. The computing system of claim 14, wherein the first set of hardware components comprises one or more general purpose processors and the second set of hardware components comprises one or more application specific integrated circuits.
16. The computing system of claim 15, wherein the application specific integrated circuit comprises a hardware accelerator comprising one or more graphics processing units or tensor processing units.
17. The computing system of any of claims 14 to 16, wherein performing one or more iterative iterations reduces idle time, which occurs when a first set of hardware components is performing a first set of training operations but a second set of hardware components is not performing a second set of training operations.
18. The computing system of any of claims 14 to 17, wherein performing one or more repeated iterations comprises:
for each of a plurality of iterations:
inputting, by one or more computing devices, at least one of a plurality of training examples into a machine learning model;
receiving, by one or more computing devices, at least one training output as an output of a machine learning model;
evaluating, by one or more computing devices, at least one training output; and
adjusting, by the one or more computing devices, parameters of the machine learning model based at least in part on the evaluation of the at least one training output;
wherein the number of the plurality of iterations is based at least in part on the echo factor.
19. The computing system of any of claims 14 to 18, wherein the first set of hardware components is further configured to enhance at least one training example in the first set of training operations by applying a transformation to the at least one training example such that the at least one training example does not change during one or more repeated iterations.
20. The computing system of any of claims 14 to 18, wherein the second set of hardware components is further configured to enhance at least one training example of the second set of training operations by applying a transformation to the at least one training example such that the at least one training example is enhanced during each of the one or more repeated iterations performed by the second set of hardware components.
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201962852056P | 2019-05-23 | 2019-05-23 | |
US62/852,056 | 2019-05-23 |
Publications (2)
Publication Number | Publication Date |
---|---|
CN112183760A true CN112183760A (en) | 2021-01-05 |
CN112183760B CN112183760B (en) | 2024-05-14 |
Family
ID=
Citations (6)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20180181503A1 (en) * | 2015-08-02 | 2018-06-28 | Wave Computing, Inc. | Data flow computation using fifos |
US20180225568A1 (en) * | 2017-02-07 | 2018-08-09 | Fmr Llc | Domain-specific stopword removal from unstructured computer text using a neural network |
CN108564164A (en) * | 2018-01-08 | 2018-09-21 | 中山大学 | A kind of parallelization deep learning method based on SPARK platforms |
CN108564168A (en) * | 2018-04-03 | 2018-09-21 | 中国科学院计算技术研究所 | A kind of design method to supporting more precision convolutional neural networks processors |
CN109754088A (en) * | 2017-11-06 | 2019-05-14 | 谷歌有限责任公司 | The computing system of modular basis structure with training production confrontation network |
CN109753751A (en) * | 2019-01-20 | 2019-05-14 | 北京工业大学 | A kind of MEC Random Task moving method based on machine learning |
Patent Citations (6)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20180181503A1 (en) * | 2015-08-02 | 2018-06-28 | Wave Computing, Inc. | Data flow computation using fifos |
US20180225568A1 (en) * | 2017-02-07 | 2018-08-09 | Fmr Llc | Domain-specific stopword removal from unstructured computer text using a neural network |
CN109754088A (en) * | 2017-11-06 | 2019-05-14 | 谷歌有限责任公司 | The computing system of modular basis structure with training production confrontation network |
CN108564164A (en) * | 2018-01-08 | 2018-09-21 | 中山大学 | A kind of parallelization deep learning method based on SPARK platforms |
CN108564168A (en) * | 2018-04-03 | 2018-09-21 | 中国科学院计算技术研究所 | A kind of design method to supporting more precision convolutional neural networks processors |
CN109753751A (en) * | 2019-01-20 | 2019-05-14 | 北京工业大学 | A kind of MEC Random Task moving method based on machine learning |
Non-Patent Citations (2)
Title |
---|
CHOI D等: "Faster neural network training with data echoing", 《ARXIV:1907.05550V3》, pages 1 - 15 * |
陈君等: "面向警务数据处理的Spark性能优化研究与实现", 《中国优秀硕士学位论文全文数据库信息科技辑》, no. 9, pages 138 - 186 * |
Also Published As
Publication number | Publication date |
---|---|
US20200372407A1 (en) | 2020-11-26 |
US11537949B2 (en) | 2022-12-27 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
EP3446260B1 (en) | Memory-efficient backpropagation through time | |
US11676008B2 (en) | Parameter-efficient multi-task and transfer learning | |
US20220222531A1 (en) | Asynchronous neural network training | |
CN110852421B (en) | Model generation method and device | |
CN110766142A (en) | Model generation method and device | |
CN110852438A (en) | Model generation method and device | |
Esmaeilzadeh et al. | Neural acceleration for general-purpose approximate programs | |
JP2018533804A (en) | Convoluted gate control recursive neural network | |
Almeida et al. | Smart at what cost? characterising mobile deep neural networks in the wild | |
US10909457B2 (en) | Compound model scaling for neural networks | |
US11188796B2 (en) | Method and apparatus with data processing | |
Song et al. | Designing and auto-tuning parallel 3-D FFT for computation-communication overlap | |
EP3836030A1 (en) | Method and apparatus with model optimization, and accelerator system | |
CN114286985A (en) | Method and apparatus for predicting kernel tuning parameters | |
Adámek et al. | GPU fast convolution via the overlap-and-save method in shared memory | |
US20220076121A1 (en) | Method and apparatus with neural architecture search based on hardware performance | |
CN112183760B (en) | System and method for reducing idle of machine learning training system using data echo | |
CN112771546A (en) | Operation accelerator and compression method | |
CN112183760A (en) | System and method for reducing idleness of machine learning training system using data echo | |
Jain et al. | Workload characterization of a time-series prediction system for spatio-temporal data | |
US20220417175A1 (en) | Method and system for resource governance in a multi-tenant system | |
CN113168555A (en) | System and related method for reducing resource consumption of convolutional neural network | |
US11610135B2 (en) | Information processing apparatus, information processing method, and non-transitory computer-readable storage medium for storing program | |
CN111190800B (en) | Method, system, device and storage medium for predicting batch operation duration of host | |
EP4133416A1 (en) | Automatic selection of quantization and filter removal optimization under energy constraints |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
SE01 | Entry into force of request for substantive examination | ||
GR01 | Patent grant |