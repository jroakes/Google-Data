US8452795B1 - Generating query suggestions using class-instance relationships - Google Patents
Generating query suggestions using class-instance relationships Download PDFInfo
- Publication number
- US8452795B1 US8452795B1 US12/759,608 US75960810A US8452795B1 US 8452795 B1 US8452795 B1 US 8452795B1 US 75960810 A US75960810 A US 75960810A US 8452795 B1 US8452795 B1 US 8452795B1
- Authority
- US
- United States
- Prior art keywords
- class
- query
- text
- instance
- pair
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active, expires
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/24—Querying
- G06F16/242—Query formulation
- G06F16/2423—Interactive query statement specification based on a database schema
Definitions
- Internet search engines provide information about Internet accessible resources (e.g., Web pages, images, text documents, and multimedia content) that are responsive to a user's search query by returning a set of search results in response to the query.
- a search result may include, for example, a Uniform Resource Locator (URL) and a snippet of information for resources responsive to a query.
- URL Uniform Resource Locator
- Some Internet search engines provide query suggestions as a user is entering a query. These query suggestions generally correspond to possible completions of the user's input.
- a search engine may suggest the query completion “formic acid properties.” These query suggestions can be presented, for example, in a drop down box that lists the query suggestions.
- one innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of receiving a plurality of candidate text queries and a plurality of class instance pairs, each class instance pair comprising class text naming an entity class and entity text naming a particular instance of the entity class; generating one or more query specializations from the plurality of candidate text queries and the plurality of class instance pairs, wherein each query specialization is the text of one of the candidate text queries modified so that an n-gram in the text of the candidate text query is replaced by the entity text from a class instance pair having class text matching the n-gram; and storing specialization data, the specialization data associating each of one or more of the queries with one or more query specializations identified from the query.
- Other embodiments of this aspect include corresponding systems, apparatus, and computer programs recorded on computer storage devices, each configured to perform the operations of the methods.
- Each class instance pair has an associated weight and the specialization data associating each of the one or more queries with one or more query specializations further associates each of the one or more query specializations with the weight of the class instance pair used to generate the query specialization.
- the actions further include excluding from the extracted n-grams any n-grams that do not match at least one of class text and entity text in the class instance pairs.
- the actions further include generating only query specializations that are included on a query whitelist.
- the query whitelist is a list of the plurality of candidate text queries.
- the actions further include receiving a plurality of documents and one or more extraction patterns; and applying the extraction patterns to the documents to derive the plurality of class instance pairs.
- the actions further include calculating a weight for each class instance pair according to a frequency score and a diversity score for the class instance pair.
- another innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of storing specialization data, the specialization data associating each of a plurality of text queries with one or more query specializations identified from the text query; receiving a partial query entered by a user; obtaining one or more candidate queries that are completions of the partial query; identifying, in the specialization data, one or more query specializations for one or more of the obtained candidate queries; and presenting query suggestions to the user, the query suggestions that include one or more of the obtained candidate queries and one or more of the identified query specializations.
- Other embodiments of this aspect include corresponding systems, apparatus, and computer programs recorded on computer storage devices, each configured to perform the operations of the methods.
- the actions further include determining an order for the query suggestions and presenting the query suggestions according to the order. Determining the order comprises determining an order that separates the obtained candidate queries from the query specializations. Determining the order comprises ordering the candidate queries according to a respective weight for each candidate query. Each query specialization is associated with a weight for the class instance pair from which it was generated; and the order for the one or more query specializations is determined according to the weight associated with the query specialization. Determining the order comprises determining an order such that at least one query specialization is presented between two candidate queries.
- query suggestions can include query suggestions referencing specific instances of classes.
- Query suggestions can be generated for queries with few or no possible query completions. Users can be provided with help to submit more focused queries than the users might otherwise submit.
- FIG. 1 illustrates an example query specialization suggestion system.
- FIG. 2 is a flow chart of an example method for generating query specializations for candidate queries.
- FIG. 3 is a flow chart of an example method for extracting and scoring class-instance pairs.
- FIG. 4 is a flow chart of an example method for obtaining and presenting query suggestions to a user.
- FIG. 5 illustrates an example search user interface including query suggestions for a partial query entered by a user.
- FIG. 1 illustrates an example query specialization suggestion system 100 .
- the system 100 is a sub-system of a search system.
- the search system is implemented by one or more computers that receive search queries from a client device of a user, identify search results that are responsive to the queries, and present the responsive search results to the user, for example, by sending the search results to the client device for presentation to the user.
- the system 100 generates query suggestions for partial queries submitted by a user.
- a partial query is text input entered in a query input field of a search engine user interface by a user before a user submits a search request to the search system.
- the system 100 includes a query specialization module 102 and a query suggestion module 104 .
- the query specialization module 102 processes a group of candidate queries and a group of class-instance pairs and uses the class-instance pairs to generate one or more respective query specializations for each of one or more of the candidate queries.
- a candidate query is text that could be submitted to a search engine as a query.
- a query specialization of a candidate query is a modified version of the candidate query where text referring to a general class of entities in the candidate query is replaced by text referring to a specific instance of an entity in the class. For example, “formic acid properties” has corresponding query specialization “formic acid density,” because “density” is a specific instance of the class “property.” An example method used to generate the query specializations is described below with reference to FIG. 2 .
- the system stores specialization data in a specialization data store 106 .
- This specialization data associates candidate queries with the query specializations identified for the candidate queries by the query specialization module 102 .
- the query suggestion module 104 uses the specialization data in the specialization data store 106 to generate query suggestions for a partial query received from a user.
- the generated query suggestions include query specializations of query completions of the partial query.
- the query suggestions can also include other suggestions, for example, query suggestions generated using conventional methods.
- a query completion begins with the partial query and has one or more additional characters. For example, “formic acid properties” is a query completion of the partial query “formic acid prop.”
- An example method for generating specialized query suggestions from query completions is described below with reference to FIG. 4 .
- FIG. 2 is a flow chart of an example method 200 for generating query specializations for candidate queries.
- the method 200 is described with reference to a data processing system that performs the method.
- the system can be, for example, the system 100 described in reference to FIG. 1 .
- the system receives candidate text queries and class-instance pairs ( 202 ).
- the candidate text queries are candidate queries for which the system will try to generate query specializations.
- the candidate text queries are identified from query log data indicating what queries users have submitted to a search engine over time.
- the candidate queries can include all queries in the query log data, or queries that appear in the query log data more than a threshold number of times.
- the candidate text queries are one or more word phrases extracted from the text of documents indexed by a search engine.
- the candidate text queries can be all phrases that appear in document text or phrases that appear in document text more than a threshold number of times.
- the candidate text queries are identified from both query log data and the text of documents indexed by a search engine.
- Each class-instance pair has class text that is a name of an entity class and entity text that is a name of an instance of the entity class.
- the instance of the entity class has an “is-a” relationship with the entity class; in other words, the instance of the entity class is an example of the entity class.
- An example class-instance pair is the pair (food, pizza), because pizza is a food.
- the class-instance pair data can be received from a system that generates class-instance pair data using conventional methods for identifying classes and instances.
- the class-instance pairs can be manually generated by one or more experts, can be collaboratively generated by non-experts, or can be extracted from text documents using conventional methods.
- the class-instance pair data was previously derived from a set of documents using pattern matching techniques. An example process for performing this extraction is described in more detail below with reference to FIG. 3 .
- the system generates one or more query specializations from the candidate text queries using the class-instance pairs ( 204 ).
- the system tries to generate query specializations from each of the candidate text queries, but does not necessarily identify a query specialization from each candidate text query.
- the system also does not necessarily use every class-instance pair when trying to generate the query specializations.
- the system identifies the query specializations by comparing the words and phrases of the candidate queries to the class text of the class-instance pairs, and replacing matching query text with associated entity text from the matching class-instance pairs.
- two texts match when the texts are identical.
- two texts match when the texts are identical or differ only in small differences in form. For example, if one text is a singular form of a word and another text is a plural form of the word, the two texts can be considered to match.
- the system only identifies query specializations that are on a query whitelist.
- the query whitelist is made up of all candidate queries that were received by the system; however, other query whitelists can also be used. For example, a query whitelist that is a subset of all of the candidate queries can also be used.
- the system identifies query specializations using programs implemented with a MapReduce framework and programming model.
- MapReduce An example implementation of MapReduce is described in U.S. Pat. No. 7,650,331, to Dean et al., for “System And Method For Efficient Large-Scale Data Processing”, issued Jan. 19, 2010.
- the system performs a series of MapReduce steps which, in combination, lead to the desired query specializations.
- the description below refers to complete MapReduce steps.
- each MapReduce step actually involves a separate map step followed by a separate reduce step.
- the first MapReduce step takes candidate queries as input and outputs key-value pairs for each of the candidate queries. These key-value pairs each have a key representing the context of a candidate query, and a value representing an n-gram extracted from the query.
- An n-gram is n consecutive words, where n is an integer greater than or equal to one.
- the context of a candidate query is made up of a prefix context of any words before the n-gram in the candidate query and a suffix context of any words after the n-gram in the candidate query.
- the candidate query “Mountain View restaurants” can be divided into the following (prefix context, n-gram, suffix context) tuples, which can be mapped to the following (key, value) pairs:
- the first MapReduce step filters the key-value pairs.
- the system can filter out key-value pairs having value n-grams whose length in words exceeds a predetermined threshold, e.g., when n is greater than 8.
- the system can compare each value n-gram that is extracted to the class names and instance names in the class-instance data, and filter out key-value pairs having a value n-gram that does not match a class name or an instance name in the class-instance data, e.g., by excluding those n-grams from the extracted n-grams that are used by the system.
- the system can filter out key-value pairs for key contexts that are associated with more than a threshold number of value n-grams.
- the first MapReduce step generates a condensed representation of the key-value pairs. These condensed key-value pairs have a key representing a query context and a value representing a list of all n-grams associated with that key context.
- the second MapReduce step receives the key-value pairs output from the first MapReduce step as input and generates a second type of key-value pair as output.
- This second type of key-value pair has a key that represents a pair of n-grams sharing the same context and a value representing the shared context.
- the pair of n-grams in the key has an order, for example, alphabetical order.
- a condensed representation of this second type of key-value pair can also be generated, where the key is an n-gram pair and the value is a list of contexts shared by the n-gram pair.
- the second MapReduce step generates output as follows.
- the first condensed key-value pair only includes two n-grams in its list of values. Therefore, the second MapReduce step generates a single key from the first condensed key-value pair: (“ibuprofen”: “nsaids”). The second MapReduce step generates an output key-value pair corresponding to this key and two context values, one for each of the received condensed key-value pairs, since both of the n-grams ibuprofen and nsaids are included in the list of values for both of the condensed key-value pairs. The two context values are therefore (“ ”, “side effects”) and (“allergic reaction to”, “ ”).
- the second MapReduce step then generates two pairs of n-grams that have not already been generated from the second key-value pair: (“aspirin”: “ibuprofen”) and (“aspirin”: nsaids“).
- the colon in the above notation is used to separate the two n-grams.
- the second MapReduce step generates two output pairs, each having one of the keys, and a value of (“allergic reaction to”, “ ”).
- the second MapReduce step first generates a mapping from context to pairs of n-grams, and then inverts the mapping to produce key-value pairs of the form described above.
- the second MapReduce step is performed on two groups of input data.
- Each group of input data is generated as described above with reference to the first MapReduce step.
- the first group is made up of class-specific key-value pairs that only includes key-value pairs whose n-gram values match class names in the class-instance pair data.
- the second group is made up of instance-specific key-value pairs that only includes key-value pairs whose n-gram values match entity names in the class-instance pair data.
- the second MapReduce step generates the set of output key-value pairs as follows.
- the second MapReduce step generates an output key-value pair for each pair of class-specific and instance-specific key-value pairs that have the same context key.
- the key of the output key-value pair is a pair of n-grams that is the n-gram value from the class-specific key-value pair and the n-gram value from the instance-specific key-value pair, in that order.
- the value is the context that is shared by the class-specific key-value pair and the instance-specific key value pair.
- the second MapReduce receives the class-specific key-value pair ((“ ”, “delicious”), “food”) and the instance-specific key-value pair ((“ ”, “delicious”), “pizza”), the second MapReduce step generates the output key-value pair ((“food”: “pizza”), (“ ”, “delicious”)).
- the third MapReduce step receives a set of weighted class-instance pairs as input and outputs a third type of key-value pair.
- the key of this third type of key-value pair is class text and entity text from a class-instance pair.
- the keys can be sorted in alphabetical order. For example, the key representing class-instance pair (“food”, “pizza”) is (“food”: “pizza”), while the key representing the class-instance pair (“food”, “chocolate”) is (“chocolate”: “food”).
- the keys can maintain the class-instance ordering, where the first text in the key is the class text and the second text is the entity text. In general, the keys are ordered according to the same convention used to order the keys generated by the second MapReduce.
- the value of this third type of key-value pair specifies whether the class comes first or second in the key.
- the value can also specify the weight associated with the class-instance pair. For example, for class-instance pair (“food”, “pizza”, 0.9), the resulting key-value pair is ⁇ (“food”: “pizza”), (0.9, “first element is class”) ⁇ .
- the third MapReduce step filters out class texts that are determined to be too general, for example, class texts that appear in more than a predetermined threshold number of class-instance pairs, and does not include these class texts in the resulting set of key-value pairs.
- the third MapReduce step filters out class-instance pairs that have a weight that is less than a predetermined threshold, and does not include key-value pairs for these class-instance pairs in the resulting set of key-value pairs.
- the entity texts for a given class are ranked, e.g., by their weights, and the third MapReduce step only generates key-value pairs for up to a given number of the entity texts. For example, only the first j entity texts for each class text could be used, where j is a pre-defined threshold.
- the fourth MapReduce step receives two groups of key-value pairs as input.
- the fourth MapReduce step receives the outputs of the second MapReduce step and the third MapReduce step as input, and performs a merge, e.g., join, operation to combine the output of the second MapReduce step with the output from the third MapReduce step.
- a merge e.g., join
- the fourth MapReduce step can use conventional database join techniques.
- the join filters out entries whose keys are not included in both the outputs of the second MapReduce and the output of the third MapReduce.
- this join results in a set of key-value pairs corresponding to query specializations for particular n-grams and contexts.
- the key is the n-gram pair, and the value is the context for the pair.
- the value can optionally include additional optional information on whether the class or the instance is first in the key and the weight for the context-instance pair represented by the key.
- each of the query specializations generated by the join are also included in the candidate queries (i.e., on a query whitelist). Therefore, an implicit side effect of the join is that each of the resulting query specializations is a query on the query whitelist.
- the system can then perform a final MapReduce step to identify query specializations for each of the candidate queries.
- the system generates the query specializations for a given candidate query by considering each key-value pair output from the fourth MapReduce step.
- the system generates a first candidate query and a second candidate query from the key-value pair.
- the first candidate query is generated by recombining the context with the first n-gram in the key.
- the second candidate query is generated by recombining the context with the second n-gram in the key.
- the system determines whether the class is first or second in the key. If the class is first in the key, the system identifies the second candidate query as a query specialization for the first candidate query. Otherwise, the system identifies the first candidate query as a query specialization for the second candidate query.
- the system identifies the second candidate query as a query specialization for the first candidate query.
- each query specialization for a candidate text query corresponds to the text of the candidate text query modified so that an n-gram in the text is replaced by the entity text from a class-instance pair having class text matching the n-gram.
- the system associates a weight with each resulting query specialization.
- This weight can be derived from the weight associated with the class-instance pair used to generate the query specialization.
- the weight can be the weight associated with the class-instance pair itself or a function of the weight associated with the class-instance pair, e.g., a logarithm of the weight.
- the system stores specialization data associating each of one or more of the candidate text queries with one or more query specializations generated from the query ( 206 ).
- the system automatically associates each of the one or more candidate queries with all of the query specializations identified from the candidate query (if any).
- the system compares the number of query specializations identified from each candidate query to a predetermined threshold, and only associates the specializations with the candidate query if the number satisfies, e.g., is below, the threshold.
- the system only associates a candidate query with query specializations having a weight that satisfies a predetermined threshold.
- the weight of a query specialization can be derived from the weight of the class-instance pair used to generate the query specialization, as described above.
- the system orders the query specializations for a candidate query, for example, according to the weight of the specializations or according to other metrics that indicate specialization quality.
- the system then associates a top number of the query specializations with the candidate query.
- the specialization data can be used to identify query specializations for use as query suggestions for a user query, as described below with reference to FIG. 4 .
- FIG. 3 is a flow chart of an example method 300 for deriving and scoring class-instance pairs.
- the method 300 is described with reference to a system that performs the method.
- the system can be, for example, the system 100 described above in reference to FIG. 1 , or a separate system.
- the class-instance pairs can be used, for example, by the query specialization process described above in reference to FIG. 2 .
- the system applies extraction patterns to derive class-instance pairs ( 302 ).
- Each extraction pattern is a pre-defined pattern for extracting class text and entity text from document text. Matching class text and entity text is extracted from the documents according to the patterns.
- the patterns can be applied, for example, using conventional pattern matching techniques.
- the class terms C is a noun phrase identified from parts-of-speech tags applied to the terms in the document.
- a noun phrase is a sequence of adjectives or nouns ending in a noun.
- the noun can be plural or singular, depending on the form of the pattern.
- Example noun phrases include “food,” “European banks,” and “exciting afternoon trips.”
- the derived classes and instances are put in a standard form, for example, by converting all text to lowercase.
- the system determines a weight for each distinct class-instance pair ( 304 ).
- the weight represents an estimate of a strength of relationship between the instance and the class.
- the weight is derived from one or more of a frequency score for the class-instance pair and a diversity score for the class-instance pair.
- the frequency score is related to the number of times the class-instance pair was derived from the documents. In some implementations, the frequency score is derived from the total number of times the pair of class text C and entity text I was derived from the set of documents. In other implementations, the frequency score is derived from a number of unique phrases from which the class instance pair was extracted.
- the diversity score for the class-instance pair is related to the number of distinct patterns used to extract the class-instance pair. The diversity score can be the number of distinct patterns itself or a number derived by applying a function to the number of distinct patterns.
- Weight( C,I ) Size( ⁇ Pattern( C,I ) ⁇ ) 2 ⁇ Freq( C,I ), where the size of Pattern(C, I) is the diversity score for the class-instance pair and Freq(C, I) is the frequency score for the class-instance pair.
- the weight for a given class instance pair is further determined from a weight associated with each pattern used to extract the class instance pair.
- the weight for each pattern can be derived from a pre-determined estimate of the quality of the class instance pairs that are extracted using the pattern.
- Another example formula for determining the weight for a class-instance pair (C, I) using the pattern weights is:
- Weight ⁇ ( C , I ) Size ⁇ ( ⁇ Pattern ⁇ ( C , I ) ⁇ ) 2 ⁇ ⁇ p ⁇ ⁇ Pattern ⁇ ( C , I ) ⁇ ⁇ w p ⁇ Freq ⁇ ( ( C , I ) , p ) , where Pattern(C, I) is the set of patterns for which the pair (C, I) was identified, w p is the weight of pattern p, and Freq((C, I),p) is the frequency score for the number of extractions of the pair (C, I) using the pattern p.
- Example techniques for scoring class-instance pairs are described in more detail in U.S. patent application Ser. No. 12/727,940, entitled “Extracting and Scoring Class-Instance Pairs,” filed on Mar. 19, 2010, which is incorporated herein by reference.
- the system stores class-instance pair data for the class-instance pairs ( 306 ).
- the class-instance pair data associates each class and instance that are in an extracted class-instance pair.
- the class-instance pair data maps each class to each instance associated with the class. In other implementations, the class-instance pair data maps each instance to each class associated with the instance.
- the class-instance pair data also associates the class and the instance with the determined weight for the class-instance pair.
- FIG. 4 is a flow chart of an example method 400 for obtaining and presenting query suggestions to a user.
- the method 400 is described with reference to a system that performs the method.
- the system can be, for example, the system 100 described in reference to FIG. 1 .
- the system receives a partial query entered by a user ( 402 ).
- the user can enter the partial query in a query input field in a search user interface provided in a web browser of a client device.
- the system obtains one or more candidate queries that are completions of the partial query ( 404 ).
- the system can obtain these query completions, for example, from a system that had previously generated the query completions or that generates the query completions as needed, for example, using conventional methods.
- each query completion also has an associated weight that estimates a quality of the query completion, or the likelihood that, if the user completed his or her query, the resulting query would match the query completion. The weights can be received along with the query completions.
- the system identifies one or more query specializations associated with one or more of the query completions ( 406 ). In some implementations, the system uses the associations in the specialization data. In other implementations, the system generates the associations as needed, for example, using the method described above with reference to FIG. 2 .
- the system presents, to the user, query suggestions corresponding to one or more of the query completions and one or more of the query specializations ( 408 ).
- the system presents the query suggestions by sending data to a client device of the user with instructions that the client device present the query suggestions in the search user interface of the web browser.
- Each query suggestion can be presented, for example, as a user-selectable element in a search user interface.
- the client device can submit a query for the query suggestion to a search engine.
- An example search user interface including user-selectable query suggestions is described below with reference to FIG. 5 .
- the system determines an order for the query suggestions and presents the suggestions according to the order.
- the system can implement various algorithms to determine the order for the query suggestions.
- the system only presents up to a top k number of query suggestions in the order, where k is a predetermined threshold.
- the presentation separates the query completions from the query specializations.
- the system can present all of the query completions before presenting any of the query specializations, or can present all of the query specializations before presenting any of the query completions.
- the query completions and query specializations may be interleaved, e.g., a query specialization can be presented between two query completions, or vice versa.
- the system can use different ranking heuristics to order the query completions and the query specializations. For example, in some implementations, each query completion has an associated weight that is received along with the query completion. Each query specialization has two associated weights.
- One weight is the weight of the query completion from which the query specialization was generated and one weight is a weight associated with the class-instance pair used to generate the query specialization from the query completion.
- the system uses these weights to rank the query completions according to their associated weights and to rank the query specializations according to a combination of their two associated weights.
- the system can generate a score used to rank a given query specialization according to the following formula:
- score 1 rank S + 1 rank ISA , where rank s is the rank of the query suggestion when sorted by the weight associated with its corresponding query completion and rank ISA is the rank of the query suggestion when sorted by the weight associated with its corresponding class-instance pair.
- the system can display a suggestion, followed by the query specializations for that suggestion, followed by the next suggestion.
- the system can rank each of the query suggestions and query specializations using conventional query suggestion ranking algorithms and present them according to their rank.
- query suggestions that include query completions and query specializations
- other types of query suggestions can also be presented, either alongside or instead of the query completions and query specializations.
- These other types of query suggestions can include, for example, other types of conventional query suggestions and query specializations that are generated from the other types of conventional query suggestions.
- FIG. 5 illustrates an example search user interface 500 including query suggestions 502 for a partial query 504 entered by a user.
- the example search user interface 500 is presented by a web browser executing on a client device.
- the partial query 504 is a partial query because the user has not yet selected the search button 506 or otherwise submitted the partial query 504 to a search engine. As the user enters the partial query 504 , query suggestions appear in the drop-down box below the partial query.
- the query suggestions 502 include query completions 508 that are possible completions of the partial query 504 and query specializations 510 that are possible specializations of one of the query completions.
- Each of the query completions 508 starts with the same text as the partial query: “formic acid pro.”
- both of the query specializations 510 are specializations of the query completion “formic acid properties,” where “properties” has been replaced by either “density” or “ph.”
- the query specializations 510 could also include specializations of the other query completions 508 .
- a query for the query suggestion is sent to a search engine, which then presents search results responsive to the selected query suggestion to the user.
- the query suggestions that are query specializations 510 are presented differently than the other query suggestions.
- the query suggestions that are query specializations 510 can be physically separated from the other suggestions, e.g., by a line in the user interface.
- the query suggestions that are to query specializations 510 can be presented in different color text or in a different size or style of font.
- the query can be rewritten to emphasize the specialization. For example, query specialization “formic acid density” corresponding to the query completion “formic acid properties” can be written as “formic acid properties (density)” or “formic acid properties: density”.
- Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them.
- Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions encoded on a computer storage medium for execution by, or to control the operation of, data processing apparatus.
- the program instructions can be encoded on a propagated signal that is an artificially generated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus.
- the computer storage medium can be a machine-readable storage device, a machine-readable storage substrate, a random or serial access memory device, or a combination of one or more of them.
- data processing apparatus encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers.
- the apparatus can include special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
- the apparatus can also include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them.
- a computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, or declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment.
- a computer program may, but need not, correspond to a file in a file system.
- a program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub-programs, or portions of code).
- a computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
- the processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output.
- the processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
- processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer.
- a processor will receive instructions and data from a read-only memory or a random access memory or both.
- the essential elements of a computer are a processor for performing or executing instructions and one or more memory devices for storing instructions and data.
- a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks.
- mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks.
- a computer need not have such devices.
- a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., a universal serial bus (USB) flash drive), to name just a few.
- PDA personal digital assistant
- GPS Global Positioning System
- USB universal serial bus
- Computer-readable media suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks.
- semiconductor memory devices e.g., EPROM, EEPROM, and flash memory devices
- magnetic disks e.g., internal hard disks or removable disks
- magneto-optical disks e.g., CD-ROM and DVD-ROM disks.
- the processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
- a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer.
- a display device e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor
- keyboard and a pointing device e.g., a mouse or a trackball
- Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.
- a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a
- Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back-end, middleware, or front-end components.
- the components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), e.g., the Internet.
- LAN local area network
- WAN wide area network
- the computing system can include clients and servers.
- a client and server are generally remote from each other and typically interact through a communication network.
- the relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
- the specialization data can be used to identify query specializations of other types of candidate queries, in addition to query completions.
- the specialization data can be used to generate query specializations of query refinements for a query.
- the query refinements can be received, for example, from a system that generates refinements using conventional methods. A system can then identify query specializations for one or more of the query refinements and present the query specializations to a user along with or instead of the query refinements.
Abstract
Description
(Prefix Context, N-Gram, Suffix) | (Key, Value) Pair |
(“”, “Mountain”, “View restaurants”) → | ((“”, “View restaurants”), |
“Mountain”), | |
(“Mountain”, “View”, “restaurants”) → | ((“Mountain”, “restaurants”), |
“View”), | |
(“Mountain View”, “restaurants”, “”) → | ((“Mountain View”, “”), |
“restaurants”), | |
(“”, “Mountain View”, “restaurants”) → | ((“”, “restaurants”), |
“Mountain View”), | |
(“Mountain”, “View restaurants”, “”) → | ((“Mountain”, “”), “View |
restaurants”), | |
(“”, “Mountain View restaurants”, “”) → | ((“”, “”), “Mountain View |
restaurants”). | |
Weight(C,I)=Size({Pattern(C,I)})2×Freq(C,I),
where the size of Pattern(C, I) is the diversity score for the class-instance pair and Freq(C, I) is the frequency score for the class-instance pair.
where Pattern(C, I) is the set of patterns for which the pair (C, I) was identified, wp is the weight of pattern p, and Freq((C, I),p) is the frequency score for the number of extractions of the pair (C, I) using the pattern p.
where ranks is the rank of the query suggestion when sorted by the weight associated with its corresponding query completion and rankISA is the rank of the query suggestion when sorted by the weight associated with its corresponding class-instance pair. Other scoring algorithms can also be used. For example, the system can generate a score for a given query specialization according to the following formula:
score=V×F(Q)+(1−V)×W,
where F(Q) is the weight of the query completion used to generate the query specialization and W is the weight of the class-instance pair used to generate to the query suggestion, and V is an interpolation parameter between zero and one, inclusive.
Claims (34)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US12/759,608 US8452795B1 (en) | 2010-01-15 | 2010-04-13 | Generating query suggestions using class-instance relationships |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US29566410P | 2010-01-15 | 2010-01-15 | |
US12/759,608 US8452795B1 (en) | 2010-01-15 | 2010-04-13 | Generating query suggestions using class-instance relationships |
Publications (1)
Publication Number | Publication Date |
---|---|
US8452795B1 true US8452795B1 (en) | 2013-05-28 |
Family
ID=48445431
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US12/759,608 Active 2030-05-17 US8452795B1 (en) | 2010-01-15 | 2010-04-13 | Generating query suggestions using class-instance relationships |
Country Status (1)
Country | Link |
---|---|
US (1) | US8452795B1 (en) |
Cited By (11)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20120011115A1 (en) * | 2010-07-09 | 2012-01-12 | Jayant Madhavan | Table search using recovered semantic information |
US8886662B1 (en) * | 2011-07-11 | 2014-11-11 | Google Inc. | Generating word completions based on shared suffix analysis |
US9047278B1 (en) | 2012-11-09 | 2015-06-02 | Google Inc. | Identifying and ranking attributes of entities |
CN105095223A (en) * | 2014-04-25 | 2015-11-25 | 阿里巴巴集团控股有限公司 | Method for classifying texts and server |
US20160004706A1 (en) * | 2014-07-01 | 2016-01-07 | Microsoft Corporation | Security trimming of search suggestions |
US20160350355A1 (en) * | 2014-11-25 | 2016-12-01 | Yahoo! Inc. | Method and System for Analyzing a User Agent String |
US9514098B1 (en) * | 2013-12-09 | 2016-12-06 | Google Inc. | Iteratively learning coreference embeddings of noun phrases using feature representations that include distributed word representations of the noun phrases |
US20170011116A1 (en) * | 2015-07-07 | 2017-01-12 | Google Inc. | Generating elements of answer-seeking queries and elements of answers |
US9703871B1 (en) * | 2010-07-30 | 2017-07-11 | Google Inc. | Generating query refinements using query components |
CN109947947A (en) * | 2019-03-29 | 2019-06-28 | 北京泰迪熊移动科技有限公司 | A kind of file classification method, device and computer readable storage medium |
CN112528653A (en) * | 2020-12-02 | 2021-03-19 | 支付宝(杭州)信息技术有限公司 | Short text entity identification method and system |
Citations (9)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20010000356A1 (en) * | 1995-07-07 | 2001-04-19 | Woods William A. | Method and apparatus for generating query responses in a computer-based document retrieval system |
US20040034632A1 (en) | 2002-07-31 | 2004-02-19 | International Business Machines Corporation | Automatic query refinement |
US20070233656A1 (en) | 2006-03-31 | 2007-10-04 | Bunescu Razvan C | Disambiguation of Named Entities |
US7366715B2 (en) | 2003-12-17 | 2008-04-29 | International Business Machines Corporation | Processing, browsing and extracting information from an electronic document |
US20090083226A1 (en) * | 2007-09-20 | 2009-03-26 | Jaya Kawale | Techniques for modifying a query based on query associations |
US20090271363A1 (en) | 2008-04-24 | 2009-10-29 | Lexisnexis Risk & Information Analytics Group Inc. | Adaptive clustering of records and entity representations |
US20100145678A1 (en) * | 2008-11-06 | 2010-06-10 | University Of North Texas | Method, System and Apparatus for Automatic Keyword Extraction |
US20110035456A1 (en) | 2009-08-05 | 2011-02-10 | Disney Enterprises, Inc. | Methods and arrangements for content filtering |
US7890526B1 (en) * | 2003-12-30 | 2011-02-15 | Microsoft Corporation | Incremental query refinement |
-
2010
- 2010-04-13 US US12/759,608 patent/US8452795B1/en active Active
Patent Citations (9)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20010000356A1 (en) * | 1995-07-07 | 2001-04-19 | Woods William A. | Method and apparatus for generating query responses in a computer-based document retrieval system |
US20040034632A1 (en) | 2002-07-31 | 2004-02-19 | International Business Machines Corporation | Automatic query refinement |
US7366715B2 (en) | 2003-12-17 | 2008-04-29 | International Business Machines Corporation | Processing, browsing and extracting information from an electronic document |
US7890526B1 (en) * | 2003-12-30 | 2011-02-15 | Microsoft Corporation | Incremental query refinement |
US20070233656A1 (en) | 2006-03-31 | 2007-10-04 | Bunescu Razvan C | Disambiguation of Named Entities |
US20090083226A1 (en) * | 2007-09-20 | 2009-03-26 | Jaya Kawale | Techniques for modifying a query based on query associations |
US20090271363A1 (en) | 2008-04-24 | 2009-10-29 | Lexisnexis Risk & Information Analytics Group Inc. | Adaptive clustering of records and entity representations |
US20100145678A1 (en) * | 2008-11-06 | 2010-06-10 | University Of North Texas | Method, System and Apparatus for Automatic Keyword Extraction |
US20110035456A1 (en) | 2009-08-05 | 2011-02-10 | Disney Enterprises, Inc. | Methods and arrangements for content filtering |
Non-Patent Citations (3)
Title |
---|
Durme et al. "Weakly-Supervised Acquisition of open-Domain Classes and Class Attributes from Web Documents and Query logs" Proceedings of ACL-08: HL T, p. 19-27, Jun. 2008. |
Hughes et al. "Lexical Semantic Relatedness with Random Graph Walks" Proceedings of Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning, p. 581-589, Jun. 2007. |
Talukdar et al. "Weakly-Supervised Acquisition of Labeled Class Instances using Graph Random Walks" Proceedings of the 2008 Conference on Empirical Methods in Nature language Processing, p. 582-590, Oct. 2008. |
Cited By (16)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20120011115A1 (en) * | 2010-07-09 | 2012-01-12 | Jayant Madhavan | Table search using recovered semantic information |
US9703871B1 (en) * | 2010-07-30 | 2017-07-11 | Google Inc. | Generating query refinements using query components |
US8886662B1 (en) * | 2011-07-11 | 2014-11-11 | Google Inc. | Generating word completions based on shared suffix analysis |
US9047278B1 (en) | 2012-11-09 | 2015-06-02 | Google Inc. | Identifying and ranking attributes of entities |
US10185751B1 (en) | 2012-11-09 | 2019-01-22 | Google Llc | Identifying and ranking attributes of entities |
US9514098B1 (en) * | 2013-12-09 | 2016-12-06 | Google Inc. | Iteratively learning coreference embeddings of noun phrases using feature representations that include distributed word representations of the noun phrases |
CN105095223A (en) * | 2014-04-25 | 2015-11-25 | 阿里巴巴集团控股有限公司 | Method for classifying texts and server |
CN105095223B (en) * | 2014-04-25 | 2018-09-11 | 阿里巴巴集团控股有限公司 | File classification method and server |
US20160004706A1 (en) * | 2014-07-01 | 2016-01-07 | Microsoft Corporation | Security trimming of search suggestions |
US20160350355A1 (en) * | 2014-11-25 | 2016-12-01 | Yahoo! Inc. | Method and System for Analyzing a User Agent String |
US11120004B2 (en) * | 2014-11-25 | 2021-09-14 | Verizon Media Inc. | Method and system for analyzing a user agent string |
US20170011116A1 (en) * | 2015-07-07 | 2017-01-12 | Google Inc. | Generating elements of answer-seeking queries and elements of answers |
US10592540B2 (en) * | 2015-07-07 | 2020-03-17 | Google Llc | Generating elements of answer-seeking queries and elements of answers |
CN109947947A (en) * | 2019-03-29 | 2019-06-28 | 北京泰迪熊移动科技有限公司 | A kind of file classification method, device and computer readable storage medium |
CN112528653A (en) * | 2020-12-02 | 2021-03-19 | 支付宝(杭州)信息技术有限公司 | Short text entity identification method and system |
CN112528653B (en) * | 2020-12-02 | 2023-11-28 | 支付宝(杭州)信息技术有限公司 | Short text entity recognition method and system |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US8452795B1 (en) | Generating query suggestions using class-instance relationships | |
US8452763B1 (en) | Extracting and scoring class-instance pairs | |
US11514035B1 (en) | Query refinements using search data | |
US7519588B2 (en) | Keyword characterization and application | |
US8688727B1 (en) | Generating query refinements | |
US7849104B2 (en) | Searching heterogeneous interrelated entities | |
US8868539B2 (en) | Search equalizer | |
US9336277B2 (en) | Query suggestions based on search data | |
US9411890B2 (en) | Graph-based search queries using web content metadata | |
US20190073357A1 (en) | Hybrid classifier for assigning natural language processing (nlp) inputs to domains in real-time | |
US9507804B2 (en) | Similar search queries and images | |
US20120317088A1 (en) | Associating Search Queries and Entities | |
US8417692B2 (en) | Generalized edit distance for queries | |
US20060195435A1 (en) | System and method for providing query assistance | |
US20160012045A1 (en) | User interface for summarizing the relevance of a document to a query | |
US20100235343A1 (en) | Predicting Interestingness of Questions in Community Question Answering | |
US20110191336A1 (en) | Contextual image search | |
US10437894B2 (en) | Method and system for app search engine leveraging user reviews | |
US10180964B1 (en) | Candidate answer passages | |
US10691679B2 (en) | Providing query completions based on data tuples | |
US10025783B2 (en) | Identifying similar documents using graphs | |
JP2015500525A (en) | Method and apparatus for information retrieval | |
US10042934B2 (en) | Query generation system for an information retrieval system | |
US20210349959A1 (en) | Recommending domains from free text | |
US9703871B1 (en) | Generating query refinements using query components |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:FINKELSTEIN, LEV;PEREIRA, FERNANDO;PASCA, MARIUS;SIGNING DATES FROM 20100406 TO 20100413;REEL/FRAME:024234/0457 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
CC | Certificate of correction | ||
CC | Certificate of correction | ||
FPAY | Fee payment |
Year of fee payment: 4 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044101/0299Effective date: 20170929 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 8TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1552); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 8 |