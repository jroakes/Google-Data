JP6967570B2 - Energy efficient processor core architecture for image processors - Google Patents
Energy efficient processor core architecture for image processors Download PDFInfo
- Publication number
- JP6967570B2 JP6967570B2 JP2019197437A JP2019197437A JP6967570B2 JP 6967570 B2 JP6967570 B2 JP 6967570B2 JP 2019197437 A JP2019197437 A JP 2019197437A JP 2019197437 A JP2019197437 A JP 2019197437A JP 6967570 B2 JP6967570 B2 JP 6967570B2
- Authority
- JP
- Japan
- Prior art keywords
- shift register
- sheet
- register array
- lane
- array
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active
Links
- 238000000034 method Methods 0.000 claims description 29
- 238000004590 computer program Methods 0.000 claims description 8
- 230000015654 memory Effects 0.000 description 59
- 238000012545 processing Methods 0.000 description 27
- 238000013461 design Methods 0.000 description 23
- 230000008569 process Effects 0.000 description 18
- 230000006870 function Effects 0.000 description 13
- 238000004458 analytical method Methods 0.000 description 12
- 125000001475 halogen functional group Chemical group 0.000 description 11
- 238000003860 storage Methods 0.000 description 8
- 238000004364 calculation method Methods 0.000 description 7
- 238000003491 array Methods 0.000 description 6
- 238000013459 approach Methods 0.000 description 5
- 238000010586 diagram Methods 0.000 description 5
- 230000006399 behavior Effects 0.000 description 3
- 230000000694 effects Effects 0.000 description 3
- 238000007726 management method Methods 0.000 description 3
- 235000008694 Humulus lupulus Nutrition 0.000 description 2
- 238000004891 communication Methods 0.000 description 2
- 230000005574 cross-species transmission Effects 0.000 description 2
- 238000013500 data storage Methods 0.000 description 2
- 230000009977 dual effect Effects 0.000 description 2
- 238000005516 engineering process Methods 0.000 description 2
- 238000005304 joining Methods 0.000 description 2
- 238000012986 modification Methods 0.000 description 2
- 230000004048 modification Effects 0.000 description 2
- 230000003287 optical effect Effects 0.000 description 2
- 239000004065 semiconductor Substances 0.000 description 2
- 239000007787 solid Substances 0.000 description 2
- 238000012546 transfer Methods 0.000 description 2
- 241000473391 Archosargus rhomboidalis Species 0.000 description 1
- 230000009471 action Effects 0.000 description 1
- 238000013019 agitation Methods 0.000 description 1
- 230000001413 cellular effect Effects 0.000 description 1
- 230000001186 cumulative effect Effects 0.000 description 1
- 238000010801 machine learning Methods 0.000 description 1
- 238000004519 manufacturing process Methods 0.000 description 1
- 238000007620 mathematical function Methods 0.000 description 1
- 239000002245 particle Substances 0.000 description 1
- 230000002093 peripheral effect Effects 0.000 description 1
- 230000001902 propagating effect Effects 0.000 description 1
- 238000009877 rendering Methods 0.000 description 1
- 230000004044 response Effects 0.000 description 1
- 230000007480 spreading Effects 0.000 description 1
- 238000003892 spreading Methods 0.000 description 1
- 238000003756 stirring Methods 0.000 description 1
- 230000000007 visual effect Effects 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06T—IMAGE DATA PROCESSING OR GENERATION, IN GENERAL
- G06T1/00—General purpose image data processing
- G06T1/20—Processor architectures; Processor configuration, e.g. pipelining
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F15/00—Digital computers in general; Data processing equipment in general
- G06F15/76—Architectures of general purpose stored program computers
- G06F15/80—Architectures of general purpose stored program computers comprising an array of processing units with common control, e.g. single instruction multiple data processors
- G06F15/8007—Architectures of general purpose stored program computers comprising an array of processing units with common control, e.g. single instruction multiple data processors single instruction multiple data [SIMD] multiprocessors
- G06F15/8023—Two dimensional arrays, e.g. mesh, torus
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/30003—Arrangements for executing specific machine instructions
- G06F9/3004—Arrangements for executing specific machine instructions to perform operations on memory
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/30003—Arrangements for executing specific machine instructions
- G06F9/3004—Arrangements for executing specific machine instructions to perform operations on memory
- G06F9/30043—LOAD or STORE instructions; Clear instruction
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/30098—Register arrangements
- G06F9/3012—Organisation of register space, e.g. banked or distributed register file
- G06F9/30134—Register stacks; shift registers
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/38—Concurrent instruction execution, e.g. pipeline, look ahead
- G06F9/3802—Instruction prefetching
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/38—Concurrent instruction execution, e.g. pipeline, look ahead
- G06F9/3836—Instruction issuing, e.g. dynamic instruction scheduling or out of order instruction execution
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/38—Concurrent instruction execution, e.g. pipeline, look ahead
- G06F9/3836—Instruction issuing, e.g. dynamic instruction scheduling or out of order instruction execution
- G06F9/3851—Instruction issuing, e.g. dynamic instruction scheduling or out of order instruction execution from multiple instruction streams, e.g. multistreaming
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/38—Concurrent instruction execution, e.g. pipeline, look ahead
- G06F9/3867—Concurrent instruction execution, e.g. pipeline, look ahead using instruction pipelines
- G06F9/3871—Asynchronous instruction pipeline, e.g. using handshake signals between stages
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/38—Concurrent instruction execution, e.g. pipeline, look ahead
- G06F9/3885—Concurrent instruction execution, e.g. pipeline, look ahead using a plurality of independent parallel functional units
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/38—Concurrent instruction execution, e.g. pipeline, look ahead
- G06F9/3885—Concurrent instruction execution, e.g. pipeline, look ahead using a plurality of independent parallel functional units
- G06F9/3887—Concurrent instruction execution, e.g. pipeline, look ahead using a plurality of independent parallel functional units controlled by a single instruction for multiple data lanes [SIMD]
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N3/00—Scanning details of television systems; Combination thereof with generation of supply voltages
- H04N3/10—Scanning details of television systems; Combination thereof with generation of supply voltages by means not exclusively optical-mechanical
- H04N3/14—Scanning details of television systems; Combination thereof with generation of supply voltages by means not exclusively optical-mechanical by means of electrically scanned solid-state devices
- H04N3/15—Scanning details of television systems; Combination thereof with generation of supply voltages by means not exclusively optical-mechanical by means of electrically scanned solid-state devices for picture signal generation
- H04N3/1575—Picture signal readout register, e.g. shift registers, interline shift registers
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N5/00—Details of television systems
- H04N5/14—Picture signal circuitry for video frequency region
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/38—Concurrent instruction execution, e.g. pipeline, look ahead
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N3/00—Scanning details of television systems; Combination thereof with generation of supply voltages
- H04N3/10—Scanning details of television systems; Combination thereof with generation of supply voltages by means not exclusively optical-mechanical
- H04N3/14—Scanning details of television systems; Combination thereof with generation of supply voltages by means not exclusively optical-mechanical by means of electrically scanned solid-state devices
Description
発明の分野
本発明の分野は、一般に画像処理に関し、より詳細には、画像プロセッサのためのエネルギ効率的なプロセッサコアアーキテクチャに関する。
Fields of Invention The field of invention relates generally to image processing and, more particularly to, energy efficient processor core architectures for image processors.
背景
画像処理は、典型的には、アレイに編成されたピクセル値の処理を含む。ここで、空間的に編成された二次元アレイは、画像の二次元的性質を捕捉する（追加の次元は、時間（例えば二次元画像のシーケンス）およびデータタイプ（例えば色）を含み得る。典型的なケースでは、アレイ化されたピクセル値は、静止画像または動きの画像を捕捉するためにフレームのシーケンスを生成したカメラによって提供される。伝統的な画像プロセッサは、典型的には、２つの極端な側面のいずれかに分類される。
Background image processing typically involves processing pixel values organized in an array. Here, the spatially organized two-dimensional array may capture the two-dimensional properties of the image (additional dimensions may include time (eg, sequence of two-dimensional images) and data type (eg, color). In typical cases, the arrayed pixel values are provided by the camera that generated the sequence of frames to capture a still or moving image. Traditional image processors typically have two. It falls into one of the extreme aspects.
第１の極端な側面は、汎用プロセッサまたは汎用状プロセッサ（例えばベクトル命令拡張を備えた汎用プロセッサ）上で実行されるソフトウェアプログラムとして画像処理タスクを実行する。第１の極端な側面は、一般的に非常に汎用性の高いアプリケーションソフトウェア開発プラットフォームを提供するが、関連するオーバーヘッド（例えば、命令フェッチおよびデコード、オンチップおよびオフチップデータの処理、投機的実行）と組み合わされたより精細な粒子のデータ構造の使用は、究極的には、プログラムコードの実行中に、データの単位あたり、より多くのエネルギが消費される結果となる。 The first extreme aspect is to perform an image processing task as a software program running on a general purpose processor or general purpose processor (eg, a general purpose processor with vector instruction extensions). The first extreme aspect generally provides a very versatile application software development platform, but with associated overhead (eg instruction fetch and decode, on-chip and off-chip data processing, speculative execution). The use of finer grain data structures in combination with is ultimately the result of more energy being consumed per unit of data during the execution of the program code.
第２の逆の極端な側面は、固定機能のハードワイヤード回路系をはるかに大きなデータブロックに適用する。カスタム設計された回路に直接適用される、（粒度の細かいブロックとは対照的な）より大きなデータブロックの使用は、データ単位あたりの消費電力を大幅に削減する。しかしながら、カスタム設計された固定機能回路系の使用は、一般に、プロセッサが実行することができるタスクのセットが限られる結果となる。このように、（第１の極端な側面に関連する）幅広く汎用性の高いプログラミング環境は第２の極端な側面においては欠けている。 The second opposite extreme aspect applies fixed functional hardwired circuitry to much larger data blocks. The use of larger data blocks (as opposed to finer-grained blocks), which are applied directly to custom-designed circuits, significantly reduces power consumption per data unit. However, the use of custom-designed fixed-function circuitry generally results in a limited set of tasks that the processor can perform. Thus, a broad and versatile programming environment (related to the first extreme aspect) is lacking in the second extreme aspect.
高度に汎用性の高いアプリケーションソフトウェア開発の機会と、データ単位あたりの電力効率の向上とを両立させた技術プラットフォームは、依然として望ましいが、欠けている解決策である。 A technology platform that combines highly versatile application software development opportunities with improved power efficiency per data unit is still a desirable but lacking solution.
概要
装置が記載される。装置は、命令をフェッチし発行するためのプログラムコントローラを含む。装置は、命令を実行するよう少なくとも１つの実行ユニットを有する実行レーンを含む。実行レーンは、二次元シフトレジスタアレイ構造に結合される実行レーンアレイの一部であり、実行レーンアレイの実行レーンは、それぞれのアレイ位置に位置し、二次元シフトレジスタアレイにおいてそれぞれの同じアレイ位置で専用レジスタに結合される。
Outline The device is described. The device includes a program controller for fetching and issuing instructions. The device includes an execution lane having at least one execution unit to execute an instruction. The execution lanes are part of the execution lane array coupled to the two-dimensional shift register array structure, and the execution lanes of the execution lane array are located at their respective array positions and at the same array position in the two-dimensional shift register array. Is combined with a dedicated register.
図面のリスト
以下の説明および添付の図面は、本発明の実施形態を例示するために使用される。
List of Drawings The following description and accompanying drawings are used to illustrate embodiments of the present invention.
詳細な記載
ａ．画像プロセッサハードウェアアーキテクチャおよび動作
図１は、ハードウェアで実現される画像プロセッサのためのアーキテクチャ１００の実施形態を示す。画像プロセッサは、例えば、シミュレートされた環境内で仮想プロセッサ用に書かれたプログラムコードを、ハードウェアプロセッサによって実際に実行されるプログラムコードに変換するコンパイラによって対象とされてもよい。図４に示すように、アーキテクチャ１００は、複数のラインバッファユニット１０１＿１〜１０１＿Ｍを含み、それらは、複数のステンシルプロセッサユニット１０２＿１〜１０２＿Ｎおよび対応するシート生成部ユニット１０３＿１〜１０３＿Ｎに、ネットワーク１０４（例えば、ネットワークオンチップ（ＮＯＣ）（オンチップスイッチネットワーク、オンチップリングネットワークまたは他の種類のネットワークを含む））を介して相互接続される。一実施形態では、どのラインバッファユニットが、ネットワーク１０４を介してどのシート生成部および対応するステンシルプロセッサに接続してもよい。
Detailed description a. Image Processor Hardware Architecture and Operation Figure 1 shows an embodiment of Architecture 100 for an image processor implemented in hardware. The image processor may be targeted, for example, by a compiler that translates program code written for the virtual processor in a simulated environment into program code that is actually executed by the hardware processor. As shown in FIG. 4, the architecture 100 includes a plurality of line buffer units 101_1 to 101_M, which are connected to a plurality of stencil processor units 102_1 to 102_N and corresponding sheet generator units 103_1 to 103_N to a network 104 (eg, for example. It is interconnected via a network on chip (NOC) (including on-chip switch networks, on-chip ring networks or other types of networks). In one embodiment, any line buffer unit may be connected to any sheet generator and corresponding stencil processor via the
一実施形態では、プログラムコードはコンパイルされ、対応するステンシルプロセッサ１０２にロードされて、ソフトウェア開発者によって以前に定義された画像処理動作を実行する（プログラムコードは、例えば、設計および実装に応じて、ステンシルプロセッサの関連のシート生成部１０３にもロードされてもよい）。少なくともいくつかの例では、画像処理パイプラインを、第１のパイプラインステージ用の第１のカーネルプログラムを第１のステンシルプロセッサ１０２＿１にロードし、第２のパイプラインステージ用の第２のカーネルプログラムを第２のステンシルプロセッサ１０２＿２にロードするなどして、実現することができ、第１のカーネルはパイプラインの第１ステージの機能を実行し、第２のカーネルはパイプラインの第２ステージの機能を実行し、追加の制御フロー方法がインストールされて、出力画像データをパイプラインの１つのステージからの次のステージに渡す。
In one embodiment, the program code is compiled and loaded into the
他の構成では、画像プロセッサは、同じカーネルプログラムコードを動作させる２つ以上のステンシルプロセッサ１０２＿１，１０２＿２を有する並列マシンとして実現することができる。例えば、画像データの高密度かつ高データレートのストリームが、各々が同じ機能を実行する複数のステンシルプロセッサにわたってフレームを広げることによって処理されてもよい。 In other configurations, the image processor can be implemented as a parallel machine with two or more stencil processors 102_1, 102_2 running the same kernel program code. For example, a high density and high data rate stream of image data may be processed by spreading frames across multiple stencil processors, each performing the same function.
さらに他の構成では、カーネルの本質的に任意のＤＡＧのハードウェアプロセッサへのロードを、それぞれのステンシルプロセッサをそれら自身のプログラムコードのカーネルとともに構成し、適切な制御フローフックをハードウェアに構成して、出力画像をＤＡＧ設計における１つのカーネルから次のカーネルの入力に向けることによって、行なってもよい。 In yet other configurations, the kernel loads into essentially any DAG hardware processor, each stencil processor is configured with its own program code kernel, and the appropriate control flow hooks are configured in hardware. This may be done by directing the output image from one kernel in the DAG design to the input of the next kernel.
一般的なフローとして、画像データのフレームは、マクロＩ／Ｏユニット１０５で受信され、フレーム単位でラインバッファユニット１０１の１つ以上に渡される。特定のラインバッファユニットは、それの画像データのフレームを、「ライングループ」と呼ばれる画像データのより小さな領域に解析し、次いでライングループをネットワーク１０４を介して特定のシート生成部に渡す。ある完全な（ｆｕｌｌ）単数のライングループを、例えば、フレームの複数の連続した完全な行または列のデータで構成することができる（簡単にするために、本明細書では主に連続した行と称する）。シート生成部は、画像データのライングループを「シート」と呼ばれる画像データのより小さな領域にさらに解析し、そ
のシートを対応するステンシルプロセッサに提示する。
As a general flow, a frame of image data is received by the macro I /
単一入力の画像処理パイプラインやＤＡＧフローの場合、一般に、入力フレームは、同じラインバッファユニット１０１＿１に向けられ、それは、画像データをライングループに解析し、ライングループを対応するシート生成部１０３＿１（対応するステンシルプロセッサ１０２＿１はパイプライン／ＤＡＧにおいて第１のカーネルのコードを実行している）に向ける。ステンシルプロセッサ１０２＿１による、それが処理するライングループでの動作が終了した後、シート生成部１０３＿１は、出力ライングループを「下流」のラインバッファユニット１０１＿２に送信する（ある使用例では、出力ライングループは、先に入力ライングループを送信したのと同じラインバッファ装置１０１＿１に送り返すことができる）。 In the case of a single input image processing pipeline or DAG flow, the input frame is generally directed to the same line buffer unit 101_1, which analyzes the image data into linegroups and corresponds to the linegroup sheet generator 103_1 ( The corresponding stencil processor 102_1 is running the code of the first kernel in the pipeline / DAG). After the stencil processor 102_1 has finished operating in the line group it processes, the sheet generator 103_1 sends the output line group to the "downstream" line buffer unit 101_2 (in one use case, the output line group is). , Can be sent back to the same line buffer device 101_1 that previously sent the input line group).
自身のそれぞれの他のシート生成部およびステンシルプロセッサ（例えば、シート生成部１０３＿２およびステンシルプロセッサ１０２＿２）上で実行されるパイプライン／ＤＡＧにおける次のステージ／動作を表す１つ以上の「消費側」カーネルは、下流ラインバッファユニット１０１＿２から、第１のステンシルプロセッサ１０２＿１によって生成された画像データを受信する。このようにして、第１のステンシルプロセッサ上で動作する「作成側」カーネルは、その出力データが、第２のステンシルプロセッサ上で動作する「消費側」カーネルに転送され、消費側カーネルは、パイプラインまたはＤＡＧ全体の設計と整合する作成側カーネルの後に次のタスクのセットを実行する。 One or more "consumer" kernels representing the next stage / operation in a pipeline / DAG running on their respective other sheet generators and stencil processors (eg, sheet generators 103_2 and stencil processors 102_2). Receives image data generated by the first stencil processor 102_1 from the downstream line buffer unit 101_2. In this way, the "creator" kernel running on the first stencil processor transfers its output data to the "consumer" kernel running on the second stencil processor, and the consumer kernel pipes. Perform the following set of tasks after the creator kernel that is consistent with the design of the line or the entire DAG.
ステンシルプロセッサ１０２は、画像データの複数の重なり合うステンシル上で同時に動作するように設計されている。複数の重なり合うステンシルおよびステンシルプロセッサの内部ハードウェア処理能力は、シートのサイズを効果的に決定する。ここでは、ステンシルプロセッサ１０２内で、実行レーンのアレイが一致して動作して、複数の重なり合うステンシルによってカバーされる画像データ表面領域を同時に処理する。
The
以下でより詳細に説明するように、様々な実施形態において、画像データのシートは、ステンシルプロセッサ１０２内において二次元レジスタアレイ構造にロードされる。シートおよび二次元レジスタアレイ構造の使用は、大量のデータを、大量のレジスタ空間に、例えば、処理タスクが実行レーンアレイによってその直後に直接データ上で実行される単一のロード動作として移動することによって、電力消費の改善を効果的に提供すると考えられている。さらに、実行レーンアレイおよび対応するレジスタアレイの使用は、容易にプログラマブル／設定可能な異なるステンシルサイズを提供する。
As will be described in more detail below, in various embodiments, the sheet of image data is loaded into a two-dimensional register array structure within the
図２ａ〜図２ｅは、ラインバッファユニット１０１の解析アクティビティ、およびシート生成部ユニット１０３のより微細な粒子の解析アクティビティ、ならびにシート生成部１０３に結合されるステンシルプロセッサ１０２のステンシル処理アクティビティの両方のハイレベルの実施形態を示す。
2a-2e show high of both the analysis activity of the
図２ａは、画像データ２０１の入力フレームの一実施形態を示す。図２ａはまた、ステンシルプロセッサが動作するように設計された３つの重なり合うステンシル２０２（各々３ピクセル×３ピクセルの寸法を有する）の概要を示す。各ステンシルがそれぞれ出力画像データを生成する出力ピクセルは、ベタ黒で強調表示される。簡略化のために、３つの重なり合うステンシル２０２は、垂直方向にのみ重なるように示されている。実際には、ステンシルプロセッサは、垂直方向および水平方向の両方に重なるステンシルを有するように設計されてもよいことを認識することが適切である。
FIG. 2a shows an embodiment of an input frame of
図２ａに見られるように、ステンシルプロセッサ内の垂直に重なり合うステンシル２０２のために、フレーム内に単一のステンシルプロセッサが動作することができる画像デー
タの広い帯域が存在する。以下でより詳細に説明するように、一実施形態では、ステンシルプロセッサは、データを、それらの重なり合うステンシル内で、左から右への態様で、画像データにわたって処理する（そして、次のラインのセットに対して、上から下の順序で繰り返す）。このように、ステンシルプロセッサがそれらの動作を前方に進めるにつれて、ベタ黒出力ピクセルブロックの数は、水平方向に右に成長する。上述したように、ラインバッファユニット１０１は、ステンシルプロセッサが今後の拡張された数のサイクルにわたって動作するのに十分な入来フレームからの入力画像データのライングループを解析することを担う。ライングループの例示的な図示は、陰影領域２０３として示されている。一実施形態では、ラインバッファユニット１０１は、ライングループをシート生成部との間で送受信するための異なるダイナミクスを理解することができる。例えば、「完全なグループ」と呼ばれる１つのモードによれば、画像データの完全な全幅のラインが、ラインバッファユニットとシート生成部との間で渡される。「仮想的に高い」と呼ばれる第２のモードによれば、ライングループは最初に全幅行のサブセットと共に渡される。その後、残りの行は、より小さい（全幅未満の）片で順番に渡される。
As seen in FIG. 2a, due to the vertically overlapping
入力画像データのライングループ２０３がラインバッファユニットによって画定され、シート生成部ユニットに渡されると、シート生成部ユニットはさらに、ライングループを、ステンシルプロセッサのハードウェア制限に、より正確に適合する、より微細なシートに、解析する。より具体的には、以下でさらに詳細に説明するように、一実施形態では、各ステンシルプロセッサは、二次元シフトレジスタアレイからなる。二次元シフトレジスタアレイは、本質的に、画像データを実行レーンのアレイの「真下」にシフトし、シフトのパターンは、各実行レーンをそれ自身のステンシル内においてデータに対して動作させる（すなわち、各実行レーンは、それ自身の情報のステンシル上で処理して、そのステンシルの出力を生成する）。一実施形態では、シートは、二次元シフトレジスタアレイを「満たす」か、さもなければ二次元シフトレジスタアレイにロードされる入力画像データの表面領域である。
When the
以下でより詳細に説明するように、様々な実施形態では、実際には、任意のサイクルでシフト可能な二次元レジスタデータの複数の層が存在する。便宜上、本記載の多くは、「二次元シフトレジスタ」などの用語を、シフト可能な二次元レジスタデータの１つ以上のそのような層を有する構造を指すために単純に使用する。 As described in more detail below, in various embodiments, there are actually multiple layers of two-dimensional register data that can be shifted in any cycle. For convenience, much of this description simply uses terms such as "two-dimensional shift register" to refer to structures with one or more such layers of shiftable two-dimensional register data.
したがって、図２ｂに見られるように、シート生成部は、ライングループ２０３から最初のシート２０４を解析し、それをステンシルプロセッサに供給する（ここで、データのシートは、参照番号２０４によって全体的に識別される陰影領域に対応する）。図２ｃおよび図２ｄに示すように、ステンシルプロセッサは、重なるステンシル２０２をシート上で左から右へ効果的に移動させることによって、入力画像データのシートに対して動作する。図２ｄのように、シート内のデータから出力値を計算することができるピクセル数が使い果たされる（他のピクセル位置は、シート内の情報から決定される出力値を有することができない）。簡単にするために、画像の境界領域は無視されている。
Therefore, as seen in FIG. 2b, the sheet generator analyzes the
図２ｅにおいて見られるように、シート生成部は次いで、ステンシルプロセッサが動作を継続する次のシート２０５を提供する。ステンシルが次のシートに対して動作を開始するときのステンシルの初期位置は、（先に図２ｄに示されている）最初のシート上の消耗点から右への次の進行であることに留意されたい。新たなシート２０５で、ステンシルプロセッサが最初のシートの処理と同じ態様で新たなシートに対して動作するにつれ、ステンシルは単に右に移動し続ける。
As seen in FIG. 2e, the sheet generator then provides the
出力ピクセル位置を取り囲むステンシルの境界領域のために、第１のシート２０４のデータと第２のシート２０５のデータとの間にいくらかの重なりがあることに留意されたい
。重なりは、シート生成部が重なり合うデータを２回再送信することによって簡単に処理することができる。別の実現例では、次のシートをステンシルプロセッサに供給するために、シート生成部は、ステンシルプロセッサに新たなデータを送るだけに進んでもよく、ステンシルプロセッサは、前のシートからの重なり合うデータを再利用する。
Note that there is some overlap between the data on the
ｂ．ステンシルプロセッサ設計および動作
図３ａは、ステンシルプロセッサアーキテクチャ３００の一実施形態を示す。図３ａにおいて見られるように、ステンシルプロセッサは、データ計算ユニット３０１、スカラープロセッサ３０２および関連するメモリ３０３およびＩ／Ｏユニット３０４を含む。データ計算ユニット３０１は、実行レーンのアレイ３０５、二次元シフトアレイ構造３０６、およびアレイの特定の行または列に関連する別個のランダムアクセスメモリ３０７を含む。
b. Stencil Processor Design and Operation Figure 3a shows an embodiment of the
Ｉ／Ｏユニット３０４は、シート生成部から受け取ったデータの「入力」シートをデータ計算ユニット３０１にロードし、ステンシルプロセッサからのデータの「出力」シートをシート生成部に格納する役割を果たす。一実施形態では、データ計算ユニット３０１へのシートデータのロードは、受け取ったシートを画像データの行／列に解析し、画像データの行／列を二次元シフトレジスタ構造３０６または実行レーンアレイの行／列のそれぞれのランダムアクセスメモリ３０７にロードすることを必要とする（以下でより詳細に説明する）。シートが最初にメモリ３０７にロードされる場合、実行レーンアレイ３０５内の個々の実行レーンは、適宜、ランダムアクセスメモリ３０７からシートデータを二次元シフトレジスタ構造３０６にロードすることができる（例えば、シートのデータ上での動作のすぐ前のロード命令として）。データのシートのレジスタ構造３０６へのロード（シート生成部からの直接的であろうとまたはメモリ３０７からであろうと）が完了すると、実行レーンアレイ３０５の実行レーンはデータに対して動作し、最終的に、完成したデータをシートとしてシート生成部に、またはランダムアクセスメモリ３０７に「書き戻す」。後者の場合、Ｉ／Ｏユニット３０４はランダムアクセスメモリ３０７からデータをフェッチして出力シートを形成し、出力シートはシート生成部に転送される。
The I /
スカラープロセッサ３０２は、スカラーメモリ３０３からステンシルプロセッサのプログラムコードの命令を読み出し、実行レーンアレイ３０５の実行レーンに命令を発行するプログラムコントローラ３０９を含む。一実施形態では、データ計算ユニット３０１からＳＩＭＤのような動作を実行するために、単一の同じ命令がアレイ３０５内のすべての実行レーンにブロードキャストされる。一実施形態では、スカラーメモリ３０３から読み出され、実行レーンアレイ３０５の実行レーンに発行される命令の命令フォーマットは、命令当たり２つ以上のオペコードを含む非常に長い命令語（ＶＬＩＷ）タイプのフォーマットを含む。さらなる実施形態では、ＶＬＩＷフォーマットは、（以下に説明するように、一実施形態では２つ以上の従来のＡＬＵ動作を指定することができる）各実行レーンのＡＬＵによって実行される数学的機能を指示するＡＬＵオペコードと、（特定の実行レーンまたは実行レーンのセットに対してメモリ操作を指示する）メモリオペコードとの両方を含む。
The
「実行レーン」という用語は、命令を実行することができる１つ以上の実行ユニットのセット（例えば、命令を実行することができる論理回路系）を指す。実行レーンは、しかしながら、様々な実施形態では、単なる実行ユニットを超えた、よりプロセッサに似た機能を含むことができる。例えば、１つ以上の実行ユニットに加えて、実行レーンは、受信された命令をデコードする論理回路系、または、よりＭＩＭＤのような設計の場合、命令をフェッチおよびデコードする論理回路系を含むことができる。ＭＩＭＤのようなアプローチに関しては、ここでは集中プログラム制御アプローチが主に記載されているが、より分散型のアプローチが様々な代替実施形態（例えば、アレイ３０５の各実行レーン内のプ
ログラムコードおよびプログラムコントローラを含む）において実施されてもよい。
The term "execution lane" refers to a set of one or more execution units capable of executing an instruction (eg, a logic circuit system capable of executing an instruction). Execution lanes, however, can include, in various embodiments, more processor-like functions that go beyond just execution units. For example, in addition to one or more execution units, the execution lane may include a logic circuit system that decodes the received instructions, or, in the case of a more MIMD-like design, a logic circuit system that fetches and decodes the instructions. Can be done. For approaches such as MIMD, the centralized program control approach is primarily described here, but the more distributed approach is a variety of alternative embodiments (eg, program code and program controller within each execution lane of array 305). May be carried out in).
実行レーンアレイ３０５、プログラムコントローラ３０９および二次元シフトレジスタ構造３０６の組み合わせは、広範囲のプログラマブルな機能のための幅広く適応可能／設定可能なハードウェアプラットフォームを提供する。例えば、アプリケーションソフトウェア開発者は、個々の実行レーンが多種多様な機能を実行することができ、任意の出力アレイ位置に近接した入力画像データに容易にアクセスすることができれば、寸法（例えばステンシルサイズ）だけでなく幅広い異なる機能能力を有するカーネルをプログラミングすることができる。
The combination of run lane array 305,
実行レーンアレイ３０５によって操作される画像データのためのデータ記憶装置として機能することとは別に、ランダムアクセスメモリ３０７は、１つ以上のルックアップテーブルを保持することもできる。様々な実施形態では、１つ以上のスカラールックアップテーブルをスカラーメモリ３０３内でインスタンス化することもできる。
Apart from acting as a data storage device for the image data operated by the execution lane array 305, the
スカラールックアップは、同じルックアップテーブルからの同じインデックスからの同じデータ値を実行レーンアレイ３０５内の各実行レーンに渡すことを含む。様々な実施形態では、上述のＶＬＩＷ命令フォーマットは、スカラープロセッサによって実行されるルックアップ動作をスカラールックアップテーブルに向けるスカラーオペコードを含むようにも拡張される。オペコードとともに使用するために指定されたインデックスは、即値オペランドでもよいし、他のデータ記憶位置からフェッチされてもよい。いずれにせよ、一実施形態では、スカラーメモリ内のスカラールックアップテーブルからのルックアップは、基本的に同じクロックサイクル中に実行レーンアレイ３０５内のすべての実行レーンに同じデータ値をブロードキャストすることを含む。ルックアップテーブルの使用および動作に関する追加の詳細は、以下でさらに説明する。 Scalar lookup involves passing the same data values from the same index from the same lookup table to each run lane in the run lane array 305. In various embodiments, the VLIW instruction format described above is also extended to include scalar opcodes that direct the lookup operations performed by the scalar processor to the scalar lookup table. The index specified for use with the opcode may be an immediate operand or may be fetched from another data storage location. In any case, in one embodiment, the lookup from the scalar lookup table in the scalar memory essentially broadcasts the same data value to all the execution lanes in the execution lane array 305 during the same clock cycle. include. Additional details regarding the use and behavior of lookup tables are described further below.
図３ｂは、上述のＶＬＩＷ命令ワードの実施形態を要約したものである。図３ｂにおいて見られるように、ＶＬＩＷ命令ワードフォーマットは、３つの別個の命令、すなわち、１）スカラープロセッサによって実行されるスカラー命令３５１、２）実行レーンアレイ内でそれぞれのＡＬＵによってＳＩＭＤ方式でブロードキャストされ実行されるＡＬＵ命令３５２、および３）部分的ＳＩＭＤ方式でブロードキャストされ実行されるメモリ命令３５３に対するフィールドを含む（例えば、実行レーンアレイ内において同じ行に沿った実行レーンが同じランダムアクセスメモリを共有する場合、異なる行の各々からの１つの実行レーンが実際に命令を実行する（メモリ命令３５３のフォーマットは、各行からのどの実行レーンが命令を実行するかを識別するオペランドを含むことができる）。
FIG. 3b summarizes the embodiments of the VLIW instruction word described above. As can be seen in FIG. 3b, the VLIW instruction word format is broadcast in SIMD fashion by each ALU within three separate instructions: 1)
１つ以上の即時オペランドに対するフィールド３５４も含まれる。命令３５１，３５２，３５３のどれが、どの即時オペランド情報を用いるかは命令フォーマットで識別されてもよい。命令３５１，３５２，３５３の各々は、また、それら自身のそれぞれの入力オペランドおよび結果情報（例えば、ＡＬＵ演算用のローカルレジスタならびにメモリアクセス命令用のローカルレジスタおよびメモリアドレス）を含む。一実施形態では、スカラー命令３５１は、実行レーンアレイ内の実行レーンが他の２つの命令３５２，３５３のいずれかを実行する前にスカラープロセッサによって実行される。すなわち、ＶＬＩＷワードの実行は、スカラー命令３５１が実行される第１のサイクルと、続いて他の命令３５２，３５３が実行されてもよい第２のサイクルとを含む。（様々な実施形態では、命令３５２，３５３は並列して実行されてもよい）。
一実施形態では、スカラープロセッサによって実行されるスカラー命令は、シートをデータ計算ユニットのメモリもしくは２Ｄシフトレジスタからロードまたはそれに格納するようシート生成部に発行されるコマンドを含む。ここで、シート生成部の動作は、ライン
バッファユニットの動作またはスカラープロセッサによって発行されたコマンドをシート生成部が完了するのに要するサイクル数のプレランタイムの理解を妨げる他の変数に依存し得る。したがって、一実施形態では、スカラー命令３５１がシート生成部に発行されるべきコマンドに対応するか、さもなければコマンドをシート生成部に発行させるＶＬＩＷワードは、他の２つの命令フィールド３５２，３５３に無操作（ＮＯＯＰ）命令を含む。次に、プログラムコードは、シート生成部がデータ計算ユニットに対するそのロードまたはデータ計算ユニットからのその格納を完了するまで、命令フィールド３５２，３５３についてＮＯＯＰ命令のループに入る。ここで、シート生成部にコマンドを発行すると、スカラープロセッサは、シート生成部がコマンドの完了時にリセットするインターロックレジスタのビットをセットしてもよい。ＮＯＯＰループの間、スカラープロセッサはインターロックビットのビットを監視する。スカラープロセッサが、シート生成部がそのコマンドを完了したことを検出すると、通常の実行が再び開始される。
In one embodiment, the scalar instruction executed by the scalar processor includes a command issued to the sheet generator to load or store the sheet from the memory of the data calculation unit or the 2D shift register. Here, the operation of the sheet generator may depend on the operation of the line buffer unit or other variables that interfere with the pre-runtime understanding of the number of cycles required for the sheet generator to complete the command issued by the scalar processor. Therefore, in one embodiment, the
図４は、データ計算コンポーネント４０１の一実施形態を示す。図４において見られるように、データ計算コンポーネント４０１は、二次元シフトレジスタアレイ構造４０６「の上に」論理的に位置決めされる実行レーンのアレイ４０５を含む。上述したように、様々な実施形態では、シート生成部によって提供される画像データのシートが二次元シフトレジスタ４０６にロードされる。実行レーンは、レジスタ構造４０６からのシートデータに対して動作する。
FIG. 4 shows an embodiment of the
実行レーンアレイ４０５およびシフトレジスタ構造４０６は、互いに対して適所に固定される。しかし、シフトレジスタアレイ４０６内のデータは、戦略的かつ調整された態様でシフトして、実行レーンアレイ内の各実行レーンがデータ内で異なるステンシルを処理するようにする。したがって、各実行レーンは、生成されている出力シートにおいて異なるピクセルに対する出力画像値を決定する。図４のアーキテクチャから、実行レーンアレイ４０５が垂直に近接する実行レーンおよび水平に近接する実行レーンを含むので、重なり合うステンシルが垂直に配置されるだけでなく水平にも配置されることは明らかである。
The
データ計算ユニット４０１のいくつかの注目すべきアーキテクチャ上の特徴には、実行レーンアレイ４０５よりも広い寸法を有するシフトレジスタ構造４０６が含まれる。すなわち、実行レーンアレイ４０５の外側にレジスタ４０９の「ハロー」が存在する。ハロー４０９は、実行レーンアレイの２つの側に存在するように示されているが、実現例に応じて、実行レーンアレイ４０５の２つ未満（１つ）またはそれ以上（３つまたは４つ）の側に存在してもよい。ハロー４０５は、データが実行レーン４０５の「下で」シフトしているときに、実行レーンアレイ４０５の境界の外側にこぼれ出るデータのための「スピルオーバ」空間を提供する働きをする。単純なケースとして、実行レーンアレイ４０５の右端を中心とする５×５のステンシルは、ステンシルの最も左側のピクセルが処理されるとき、さらに右側に４つのハローレジスタ位置を必要とすることになる。図面を簡単にするために、図４は、名目上の実施例において、どちらの側（右、底）のレジスタでも水平方向接続および垂直方向接続の両方を有するであろうとき、ハローの右側のレジスタを、水平方向シフト接続を有するだけとして、およびハローの底側のレジスタを、垂直方向シフト接続を有するだけとして示す。
Some notable architectural features of the
アレイの各行および／もしくは各列またはその一部分に結合されるランダムアクセスメモリ４０７によって追加のスピルオーバールームが提供される（例えば、ランダムアクセスメモリは、４つの実行レーン行状と２つの実行レーン列状にまたがる実行レーンアレイの「領域」に割り当てられてもよい。簡略化のために、アプリケーションの残りの部分は、主に、行および／または列に基づく割り当てスキームを指す）。ここで、実行レーンのカーネル動作が、それが（一部の画像処理ルーチンが必要とする場合がある）二次元シフ
トレジスタアレイ４０６の外にあるピクセル値を処理することを必要とする場合、画像データの面は、ハロー領域４０９からランダムアクセスメモリ４０７にさらにこぼれ出ることができる。例えば、ハードウェアが実行レーンアレイの右端の実行レーンの右側にわずか４つの記憶素子のハロー領域を含む場合の６Ｘ６ステンシルを考える。この場合、ステンシルを完全に処理するために、データをハロー４０９の右端からさらに右側にシフトする必要があるであろう。ハロー領域４０９の外側にシフトされたデータは、ランダムアクセスメモリ４０７にこぼれ出る。ランダムアクセスメモリ４０７および図３のステンシルプロセッサの他の適用例を以下でさらに説明する。
図５ａないし図５ｋは、上述のように実行レーンアレイ「の下で」二次元シフトレジスタアレイ内で画像データがシフトされる態様の実施例を示す。図５ａにおいて見られるように、二次元シフトアレイのデータ内容は第１のアレイ５０７に示され、実行レーンアレイはフレーム５０５によって示される。また、実行レーンアレイ内の２つの近隣の実行レーン５１０が簡略化して示されている。この簡単な図示５１０では、各実行レーンは、シフトレジスタからデータを受け付け、ＡＬＵ出力からデータを受け付け（例えば、サイクルにわたってアキュムレータとして動作する）、または出力データを出力先に書き込むことができるレジスタＲ１を含む。
5a-5k show examples of embodiments in which image data is shifted within a two-dimensional shift register array "under" the execution lane array as described above. As seen in FIG. 5a, the data content of the two-dimensional shift array is shown in the
各実行レーンはまた、ローカルレジスタＲ２において、二次元シフトアレイにおけるそれ「の下の」内容が利用可能である。したがって、Ｒ１は実行レーンの物理レジスタであり、Ｒ２は二次元シフトレジスタアレイの物理レジスタである。実行レーンは、Ｒ１および／またはＲ２によって提供されるオペランドに対して動作可能なＡＬＵを含む。さらに詳細に後述するように、一実施形態では、シフトレジスタは、実際にはアレイ位置ごとに複数の（ある「深さ」の）記憶／レジスタ素子で実現されるが、シフト動作は記憶素子の１つの面に限られる（例えば、記憶素子の１つの面のみがサイクルごとにシフトすることができる）。図５ａないし図５ｋは、それぞれの実行レーンから結果のＸを格納するために使用されるとしてこれらのより深いレジスタ位置の１つを示している。例示を容易にするために、より深い結果のレジスタは、その対応するレジスタＲ２の下ではなく、その横に図示されている。 Each run lane also has its "below" content available in the two-dimensional shift array at local register R2. Therefore, R1 is the physical register of the execution lane, and R2 is the physical register of the two-dimensional shift register array. The execution lane contains an ALU that can operate on the operands provided by R1 and / or R2. As will be described in more detail below, in one embodiment, the shift register is actually realized by a plurality of storage / register elements (of a certain "depth") for each array position, but the shift operation is performed by the storage element. Limited to one surface (eg, only one surface of the storage element can shift per cycle). 5a-5k show one of these deeper register positions as used to store the resulting X from each execution lane. For ease of illustration, the deeper resulting registers are shown next to their corresponding register R2, rather than below.
図５ａ〜図５ｋは、実行レーンアレイ内に示された実行レーン位置５１１の対に中心位置が整列された２つのステンシルの計算に焦点を当てている。例示を容易にするために、実行レーン５１０の対は、実際には、以下の例によれば、それらが垂直方向の近隣実行レーンである場合に、水平方向の近隣実行レーンとして図示されている。
FIGS. 5a-5k focus on the calculation of two stencils whose center positions are aligned with a pair of execution lane positions 511 shown in the execution lane array. For ease of illustration, pairs of run
図５ａで最初に見られるように、実行レーンはそれらの中央のステンシル位置上に中心を配される。図５ｂは、両方の実行レーンによって実行されるオブジェクトコードを示す。図５ｂにおいて見られるように、両方の実行レーンのプログラムコードは、シフトレジスタアレイ内のデータを、１つの位置だけ下にシフトさせ、１つの位置だけ右にシフトさせる。これにより、両方の実行レーンがそれらのそれぞれのステンシルの左上隅に整列される。次に、プログラムコードは、（Ｒ２において）それらのそれぞれの位置にあるデータをＲ１にロードさせる。 As first seen in FIG. 5a, the execution lanes are centered on their central stencil position. FIG. 5b shows the object code executed by both execution lanes. As can be seen in FIG. 5b, the program code in both execution lanes shifts the data in the shift register array down by one position and to the right by one position. This aligns both run lanes in the upper left corner of their respective stencils. The program code then causes R1 to load the data at their respective positions (in R2).
図５ｃに示すように、次にプログラムコードは、実行レーンの対に、シフトレジスタアレイ内のデータを１単位だけ左にシフトさせ、各実行レーンのそれぞれの位置の右の値を各実行レーンの位置にシフトさせる。Ｒ１の値（以前の値）は、次いで、（Ｒ２における）実行レーンの位置にシフトした新しい値とともに加算される。結果はＲ１に書き込まれる。図５ｄで見られるように、図５ｃについて上述したのと同じプロセスが繰り返され、結果のＲ１に対して、今度は上側実行レーンにおける値Ａ＋Ｂ＋Ｃ、および下側実行レーンにおけるＦ＋Ｇ＋Ｈ値を含ませるようにする。この時点で、両方の実行レーンはそれら
のそれぞれのステンシルの上側の行を処理している。（左側に存在する場合には）実行レーンアレイの左側でハロー領域に、またはハロー領域が存在しない場合にはランダムアクセスメモリにこぼれ出ることは、実行レーンアレイの左側には存在しないことに注目されたい。
As shown in FIG. 5c, the program code then shifts the data in the shift register array to the left by one unit to the pair of execution lanes, and the value to the right of each position in each execution lane is the value of each execution lane. Shift to position. The value of R1 (previous value) is then added with the new value shifted to the position of the execution lane (in R2). The result is written in R1. As can be seen in FIG. 5d, the same process as described above for FIG. 5c is repeated so that the resulting R1 now includes the values A + B + C in the upper execution lane and the F + G + H values in the lower execution lane. do. At this point, both run lanes are processing the upper row of their respective stencils. Note that spilling into the halo area on the left side of the execution lane array (if present on the left side) or into random access memory if the halo area does not exist is not present on the left side of the execution lane array. sea bream.
図５ｅに示すように、次に、プログラムコードは、シフトレジスタアレイ内のデータを１単位だけ上にシフトさせ、両方の実行レーンをそれらのそれぞれのステンシルの中間行の右端に整列される。両方の実行レーンのレジスタＲ１は、現在、ステンシルの最上行および中間行の一番右の値の合計を含む。図５ｆおよび図５ｇは、両方の実行レーンのステンシルの中間行にわたって左方向に移動する継続的な進行を示す。累積加算は、図５ｇの処理の終了時に、両方の実行レーンがそれらのそれぞれのステンシルの最上行の値と中間行の値との合計を含むように、継続する。 As shown in FIG. 5e, the program code then shifts the data in the shift register array up by one unit and aligns both execution lanes to the right edge of the middle row of their respective stencils. Register R1 in both execution lanes currently contains the sum of the rightmost values in the top and middle rows of the stencil. 5f and 5g show a continuous progression to the left across the middle row of stencils in both execution lanes. Cumulative addition continues so that at the end of the process of FIG. 5g, both execution lanes contain the sum of the values in the top row and the values in the middle row of their respective stencils.
図５ｈは、各実行レーンをそれの対応するステンシルの最下行に整列させる別のシフトを示す。図５ｉおよび図５ｊは、両方の実行レーンのステンシルの過程にわたって処理を完了するための継続的なシフトを示す。図５ｋは、各実行レーンをデータアレイにおいてそれの正しい位置に整列させ、その結果をそこに書き込むための追加のシフトを示す。 FIG. 5h shows another shift that aligns each run lane to the bottom row of its corresponding stencil. 5i and 5j show continuous shifts to complete the process over the stencil process of both execution lanes. FIG. 5k shows an additional shift to align each run lane to its correct position in the data array and write the result there.
図５ａ〜図５ｋの例では、シフト動作のためのオブジェクトコードは、（Ｘ、Ｙ）座標で表されるシフトの方向および大きさを識別する命令フォーマットを含むことができることに留意されたい。例えば、１つの位置分の上方向シフトのためのオブジェクトコードは、オブジェクトコードでＳＨＩＦＴ０，＋１として表現されてもよい。別の例として、１つの位置分の右方向へのシフトは、オブジェクトコードでＳＨＩＦＴ＋１，０として表現されてもよい。様々な実施形態では、より大きい大きさのシフトも、オブジェクトコードで指定することができる（例えば、シフト０，＋２）。ここで、２Ｄシフトレジスタハードウェアが１サイクルにつき１つの位置だけしかシフトをサポートしない場合、命令は機械によって複数のサイクル実行を要求するように解釈されてもよく、または２Ｄシフトレジスタハードウェアは、１サイクルにつき２つ以上の位置分シフトをサポートするように設計されてもよい。後者の実施形態はより詳細にさらに下に記載される。
It should be noted that in the examples of FIGS. 5a-5k, the object code for the shift operation may include an instruction format that identifies the direction and magnitude of the shift represented by the (X, Y) coordinates. For example, the object code for the upward shift for one position may be expressed as
図６ａは、アレイ実行レーンおよびシフトレジスタ構造の単位セルの別のより詳細な図を示す（ハロー領域のレジスタは、対応する実行レーンを含まない）。実行レーンおよび実行レーンアレイの各位置に関連するレジスタ空間は、一実施形態では、実行レーンアレイの各ノードで、図６ａに示す回路系をインスタンス化することによって実施される。図６ａに示すように、単位セルは、４つのレジスタＲ２〜Ｒ５からなるレジスタファイル６０２に結合される実行レーン６０１を含む。任意のサイクルの間、実行レーン６０１は、レジスタＲ１〜Ｒ５のいずれかから読み書きすることができる。２つの入力オペランドを必要とする命令の場合、実行レーンはＲ１〜Ｒ５のいずれかからオペランドの両方を取り出すことができる。
FIG. 6a shows another more detailed diagram of the array execution lane and the unit cell of the shift register structure (registers in the halo region do not include the corresponding execution lane). The register space associated with each position of the execution lane and the execution lane array is, in one embodiment, implemented by instantiating the circuit system shown in FIG. 6a at each node of the execution lane array. As shown in FIG. 6a, the unit cell includes an
一実施形態では、二次元シフトレジスタ構造は、近隣のレジスタファイル間のシフトが同じ方向にあるように（例えば、すべての実行レーンは左にシフトする、すべての実行レーンは右にシフトするなど）、それの近隣のレジスタファイルが入力マルチプレクサ６０４を介する場合に、単一のサイクルの間に、レジスタＲ２〜Ｒ４のいずれか（ただ）１つの内容が、出力マルチプレクサ６０３を介してその近隣のレジスタファイルの１つにシフト「アウト」され、対応するものからシフト「イン」される内容でレジスタＲ２〜Ｒ４のいずれか（ただ）１つの内容が置き換えられることによって、実現される。同じレジスタがその内容がシフトアウトされて同じサイクルでシフトインされる内容で置き換えられるのが一般的であるかもしれないが、マルチプレクサ構成６０３，６０４は、同じサイクル中に同じレジスタファイル内で異なるシフトソースおよびシフトターゲットレジスタを可
能にする。
In one embodiment, the two-dimensional shift register structure causes shifts between neighboring register files to be in the same direction (eg, all run lanes shift to the left, all run lanes shift to the right, etc.). , If the register file in its vicinity is via the
図６ａに示すように、シフトシーケンスの間、実行レーンは、内容をそのレジスタファイル６０２からその左、右、上および下の近隣のレジスタファイルにシフトアウトする。同じシフトシーケンスと関連して、実行レーンは、さらに、内容をその左、右、上および下の近隣のレジスタファイルの特定のものからそれのレジスタファイルにシフトする。再び、シフトアウトターゲットおよびシフトインソースは、すべての実行レーンについて同じシフト方向と整合しなければならない（例えば、シフトアウトが右隣に対する場合、シフトインは左隣からでなければならない）。
As shown in FIG. 6a, during the shift sequence, the execution lane shifts its contents from its
一実施形態では、１サイクルにつき１つの実行レーンにつき１つのレジスタの内容だけをシフトすることが許されるが、他の実施形態では、２つ以上のレジスタの内容をシフトイン／アウトすることが許されてもよい。例えば、図６ａに示されたマルチプレクサ回路系６０３，６０４の第２の例が図６ａの設計に組み込まれる場合、同じサイクルの間に２つのレジスタの内容がシフトアウト／インされてもよい。もちろん、１つのレジスタの内容だけがサイクルごとにシフトされることが許される実施形態では、数学的演算間のシフトのためにより多くのクロックサイクルを消費することによって、複数のレジスタからのシフトが数学的演算間に起こってもよい（例えば、２つのレジスタの内容が、数学的演算間で２つのシフト演算を消費することによって数学的演算間でシフトされてもよい）。 In one embodiment it is permissible to shift the contents of only one register per execution lane per cycle, while in other embodiments it is permissible to shift in / out the contents of two or more registers. May be done. For example, if the second example of the multiplexer circuit system 603,604 shown in FIG. 6a is incorporated into the design of FIG. 6a, the contents of the two registers may be shifted out / in during the same cycle. Of course, in embodiments where only the contents of one register are allowed to shift from cycle to cycle, shifting from multiple registers is mathematical by consuming more clock cycles due to shifting between mathematical operations. It may occur between mathematical operations (eg, the contents of two registers may be shifted between mathematical operations by consuming two shift operations between mathematical operations).
実行レーンのレジスタファイルのすべての内容未満がシフトシーケンス中にシフトアウトされる場合、各実行レーンのシフトアウトされないレジスタの内容は適所に残る（シフトしない）ことに留意されたい。したがって、シフトインされる内容と置き換えられないシフトされない内容は、シフトサイクルにわたって実行レーンにローカルに維持される。各実行レーンで見られるメモリユニット（「Ｍ」）は、実行レーンアレイ内の実行レーンの行および／または列に関連付けられるランダムアクセスメモリ空間からデータをロード／に格納するために使用される。ここで、Ｍユニットは、実行レーンの自身のレジスタ空間からロード／に格納できないデータをロード／格納するためによく使用されるという点で、標準的なＭユニットとして機能する。様々な実施形態では、Ｍユニットの主な動作は、ローカルレジスタからメモリにデータを書き込み、メモリからデータを読み出してそれをローカルレジスタに書き込むことである。 Note that if less than all the contents of the register file for the execution lane are shifted out during the shift sequence, the contents of the unshifted registers for each execution lane remain in place (not shift). Therefore, the unshifted content that is not replaced with the content that is shifted in is maintained locally in the execution lane throughout the shift cycle. The memory unit (“M”) found in each run lane is used to load / store data from the random access memory space associated with the rows and / or columns of the run lanes in the run lane array. Here, the M unit functions as a standard M unit in that it is often used to load / store data that cannot be loaded / stored from its own register space in the execution lane. In various embodiments, the main operation of the M unit is to write data from the local register to the memory, read the data from the memory and write it to the local register.
ハードウェア実行レーン６０１のＡＬＵユニットによってサポートされるＩＳＡオペコードに関して、様々な実施形態において、ハードウェアＡＬＵによってサポートされる数学的オペコードは、仮想実行レーンによってサポートされる数学的オペコード（例えば、ＡＤＤ、ＳＵＢ、ＭＯＶ、ＭＵＬ、ＭＡＤ、ＡＢＳ、ＤＩＶ、ＳＨＬ、ＳＨＲ、ＭＩＮ／ＭＡＸ、ＳＥＬ、ＡＮＤ、ＯＲ、ＸＯＲ、ＮＯＴ）と一体的に結び付けられる（例えば実質的に同じである）。上述のように、メモリアクセス命令は、実行レーン６０１によって実行され、データをそれらの関連付けられるランダムアクセスメモリからフェッチ／に格納することができる。さらに、ハードウェア実行レーン６０１は、シフト演算命令（右、左、上、下）をサポートし、二次元シフトレジスタ構造内でデータをシフトする。上述したように、プログラム制御命令は主にステンシルプロセッサのスカラープロセッサによって実行される。
With respect to the ISA opcode supported by the ALU unit of the
図６ｂは、プロセッサＡＬＵの一実施形態を示す。図６ｂに示すように、プロセッサＡＬＵは、乗算−加算ユニット６１１と、第１および第２の名目ＡＬＵ６１２，６１３とを含む。乗算−加算部６１１は、演算（Ａ＊Ｂ）＋Ｃを行う。第１および第２の名目ＡＬＵは、比較演算を含む名目数学的演算および論理演算（例えば、加算、減算、ａｎｄ、ｏｒ、ｘｏｒ、比較、最小値、最大値、絶対値、シフト）を実行する。ＡＬＵ設計は、２つの主データパス、すなわち、乗算−加算ユニット６１１を含む第１のものと、デュアルＡＬ
Ｕ６１２，６１３チェーンを含む第２のものとを有するとして見ることができる。デュアルＡＬＵチェーン６１２，６１３は、単一の命令における２つの演算（例えば、単一の命令における２つのＡＤＤ；単一の命令におけるＡＤＤと除算（ＤＩＶ）；単一の命令における減算（ＳＵＢ）と絶対値（ＡＢＳ）など）を有するより複雑な命令を可能にする。入力オペランドはレジスタから受け取り可能である。様々な実施形態は、オペコードに付加される即値オペランドの使用を含むことができる。出力結果はレジスタに書き込まれる。
FIG. 6b shows an embodiment of the processor ALU. As shown in FIG. 6b, the processor ALU includes a multiplication-
It can be seen as having a second one, including the U612,613 chain. Dual ALU chains 612,613 include two operations in a single instruction (eg, two ADDs in a single instruction; ADD and division (DIV) in a single instruction; subtraction (SUB) in a single instruction). Allows for more complex instructions with absolute values (ABS), etc.). Input operands can be received from registers. Various embodiments can include the use of immediate operands attached to the opcode. The output result is written to the register.
ｃ．２Ｄシフトレジスタの実施形態
図７ａは、二次元レジスタアレイ構造の論理的（および潜在的には物理的な）設計の「トップダウン」図の一実施形態を示す。図７ａの「トップダウン」図は、図６の単位セル設計の実施形態に本質的に従っており、特定のアレイ位置の各レジスタファイルが、その左、右、上および下の近隣の単位セル位置のレジスタファイルに結合されている。すなわち、例えば、図７ａに見られるように、レジスタファイルＡは、レジスタファイルＢ、Ｃ、ＤおよびＥに結合される。
c. 2D Shift Register Embodiment Figure 7a shows an embodiment of a "top-down" diagram of the logical (and potentially physical) design of a two-dimensional register array structure. The “top-down” diagram of FIG. 7a essentially follows the embodiment of the unit cell design of FIG. 6, where each register file at a particular array position has its left, right, top, and bottom neighbor unit cell positions. It is bound to the register file. That is, for example, as seen in FIG. 7a, the register file A is coupled to the register files B, C, D and E.
図７ｂは、二次元レジスタアレイ構造の論理的（および潜在的に物理的な）設計の「トップダウン」図の別の実施形態を示す。図７ｂに見られるように、単位セルは、最も近い垂直および水平方向の近隣に結合されるだけでなく、「第２に」最も近い垂直および水平方向の近隣にも結合される。例えば、図７ｂに見られるように、単位セルＡは、単位セルＢ、Ｃ、ＤおよびＥに結合されるだけでなく、単位セルＦ、Ｇ、ＨおよびＩにも結合される。図示および表示を容易にするために、単位セルＡだけが、最も近い近隣結合および第２に最も近い近隣結合の両方を有するのに必要な接続の全セットを有するものとして示されている。単位セルＡ以外では、１つおきの単位セルだけが、任意の特定の行または列に沿って第２に最も近い近隣結合を示す（例えば、単位セルＢは、第２に最も近い近隣結合を全く示さない）。読者は、好ましい実施形態が、例えば、コア内の、第２に最も近い近隣結合をサポートするようアレイ縁部から十分離れている全ての単位セルに対して単位セルＡの結合を含むであろうことを理解するであろう。 FIG. 7b shows another embodiment of a "top-down" diagram of the logical (and potentially physical) design of a two-dimensional register array structure. As can be seen in FIG. 7b, unit cells are not only merged into the closest vertical and horizontal neighbors, but also into the "second" closest vertical and horizontal neighbors. For example, as seen in FIG. 7b, unit cell A is not only associated with unit cells B, C, D and E, but also with unit cells F, G, H and I. For ease of illustration and display, only unit cell A is shown as having the entire set of connections required to have both the closest neighbor join and the second closest neighbor join. Except for unit cell A, only every other unit cell shows the second closest neighbor join along any particular row or column (eg, unit cell B has the second closest neighbor join). Not shown at all). The reader will appreciate that a preferred embodiment would include joining unit cell A for all unit cells that are sufficiently far from the edge of the array to support, for example, the second closest neighbor join in the core. You will understand that.
第２に最も近い接続を有することにより、レジスタアレイを介したレジスタ値のより高速な伝搬が可能になる。例えば、レジスタ値を４つの位置だけ離れた単位セルに移動する必要がある場合、図７ｂのアレイ構造は２サイクルで移動を達成することができるが、図７ｂのアレイ構造は４サイクルだけで同じ移動を達成することができる。図７ｂの実施形態は、最も近い近隣接続も有することに留意されたい。したがって、図７ｂの構造に対するプロセッサ命令セットは、図７ａの構造のためのプロセッサ命令セットよりも拡張的であり得る（前者は１ホップおよび２ホップＭＯＶ命令を有するが、後者は１ホップＭＯＶ命令しか持たない）。 Having the second closest connection allows faster propagation of register values through the register array. For example, if the register values need to be moved to unit cells that are four positions apart, the array structure of FIG. 7b can achieve the movement in two cycles, whereas the array structure of FIG. 7b is the same in only four cycles. Movement can be achieved. Note that the embodiment of FIG. 7b also has the closest neighbor connection. Therefore, the processor instruction set for the structure of FIG. 7b can be more extended than the processor instruction set for the structure of FIG. 7a (the former has 1-hop and 2-hop MOV instructions, while the latter has only 1-hop MOV instructions. do not have).
異なる番号のホップ移動の数および組合せ、ならびに対応するアレイ構造の実施形態は、迅速なレジスタ値の移動の必要性とアレイ構造配線密度の許容差との間の適切なトレードオフのバランスに応じて、実施形態ごとに大きく異なり得ることを指摘することが適切である。一部の実施形態は、第３および／または第４に最も近い近隣接続をサポートしてもよく、他の接続はサポートしなくてもよい（第４に最も近い近隣接続の場合、例えば、単位セルＤは、図７ｂの単位セルＪに直接結合されるであろう）。いくつかの実施形態は、最も近い近隣接続および第３に最も近いかまたはそれより遠い接続などのみを有してもよい。おそらく、より精巧な実施形態は、斜め接続（例えば、単位セルＡを図７ｂの単位セルＫおよびそれの他の３つの近隣コーナー単位セルと接続すること）をサポートすることさえできる。当業者であれば、単位セル間の様々な拡張された接続のいずれでも、図６ａの入力マルチプレクサ構造６０４への入力のソースを拡張し、出力マルチプレクサ構造６０３からのファンアウトを拡張することによって、容易に達成されることを認識するであろう。
The number and combination of different numbered hop moves, as well as the corresponding array structure embodiments, depend on the appropriate trade-off balance between the need for rapid register value movement and the array structure wiring density tolerance. It is appropriate to point out that it can vary greatly from embodiment to embodiment. Some embodiments may support the third and / or fourth closest neighbor connection and may not support other connections (for the fourth closest neighbor connection, eg, unit). Cell D will be directly attached to the unit cell J in FIG. 7b). Some embodiments may have only the closest neighbor connection and the third closest or farther connection. Perhaps a more elaborate embodiment can even support diagonal connections (eg, connecting unit cell A with unit cell K in FIG. 7b and three other neighboring corner unit cells). Those skilled in the art will be able to extend the source of the input to the
図８ａは、二次元レジスタアレイ構造内で行または列に沿ったレジスタの例示的な論理配置を示す（図示を容易にするため、レジスタアレイは８ｘ８の寸法しか持たないが、実際には寸法ははるかに大きくてもよい）。ここで、処理されているアレイにおける近隣のピクセルは、数値的に近隣の単位セルに位置する（例えば、アレイにおける近隣のピクセルの対は、単位セル３および５ではなく単位セル３および４に配置される）。図８ａの論理設計はまた、接続８０１を介して最初の論理単位セル１を最後の単位セル８に結合することによってロール能力を含む（したがって、実行レーンのプロセッサはロールオペコードを含むこともできる）。
FIG. 8a shows an exemplary logical arrangement of registers along rows or columns within a two-dimensional register array structure (for ease of illustration, the register array has only 8x8 dimensions, but in practice the dimensions are. May be much larger). Here, the neighboring pixels in the processed array are numerically located in the neighboring unit cells (for example, the pair of neighboring pixels in the array is placed in the
しかし、図８ａの設計が論理設計を表すだけでなく、物理的設計も表す場合には、特に大きな寸法のアレイの場合に問題が生じる可能性がある。図８ａのアプローチが物理的設計も表す場合、接続８０１は、対１および８以外の単位セル対を接続する他の配線の長さと比較して、極端に長い配線に対応する。この特定の配線長外れ値は、（すべての単位セル間のすべてのシフト時間を最も遅い１＜−＞８シフト時間以上になるように遅くすることにより、または任意の他の近隣の単位セル間のシフトよりも１＜−＞８シフト間においてより多くのサイクルを認識する複雑さを導入することにより）回路のタイミングの複雑さに影響する可能性がある。
However, if the design in FIG. 8a represents not only a logical design but also a physical design, problems can arise, especially for arrays of large dimensions. If the approach of FIG. 8a also represents a physical design, the
図８ｂは、図８ａの論理設計を有するレジスタアレイ構造の行または列に対する改良された物理的設計の実施形態を示す。ここで、物理的設計は、（論理設計の場合のように）単なる論理接続に対立するものとしての回路構造の実際のレイアウトに対応する。図８ｂに見られるように、物理的設計は、レイアウトの論理にトロイド設計を課すことによって、他の単位セル間において１＜−＞８接続に必要とされる余分な長さを償却する。例えば、単位セル１は論理設計を保存するために単位セル２に物理的に接続されているが、単位セル８は物理的にそれらの間に座する。結果は、図８ａの配線８０１の長さよりもはるかに短い、図８ｂの構造における単位セル間の最大配線長さである。したがって、図８ｂの構造のタイミングの複雑さは、上述した図８ａの構造のタイミングの複雑さを回避する。一実施形態では、すべての単位セル間のレジスタ内容のロールが単一のサイクル内で発生し得る。
FIG. 8b shows an embodiment of an improved physical design for a row or column of a register array structure with the logical design of FIG. 8a. Here, the physical design corresponds to the actual layout of the circuit structure as opposed to a mere logical connection (as in the case of logical design). As can be seen in FIG. 8b, the physical design amortizes the extra length required for 1 <−> 8 connections between other unit cells by imposing a toroid design on the logic of the layout. For example, the
図８ｃは、シート生成部またはランダムアクセスメモリ８０２（図４のＲＡＭ４０７のいずれかなど）とレジスタアレイの行または列との間のデータバス構造が一種の攪拌構造８０３を含み、トロイド物理レイアウトを有するアレイまたは行への正しい論理接続を維持するのを示す。図８ｄは、任意のレジスタ値が移動する最大距離が４単位セルである４ホップシフトを実現することができる別のトロイド構造を示す。ここでは、図８ｄのレジスタとシート生成部またはＲＡＭとの間に別の攪拌状のデータバスが存在するであろうことは明らかである。このように、トロイド物理レイアウトの実現の特徴は、論理的順序で配列される入力を接続するデータバスによる攪拌の存在である。
FIG. 8c shows that the data bus structure between the sheet generator or random access memory 802 (such as any of
図８ｅは、シフトアレイ構造の単位セルの出力マルチプレクサ８０４からの特別なファンアウト回路系を示す。ここで、出力マルチプレクサ８０４は、図６ａの出力マルチプレクサ６０３に類似していると見ることができる。シフトアレイが、ますます多くの接続（１ホップ、２ホップなど）をサポートするように設計されるにつれ、出力マルチプレクサ８０４のファンアウトは増大する。マルチプレクサ８０４のファンアウトが増大するにつれて、電力消費はますます問題になる可能性がある。図８ｅは、１ホップおよび２つの接続の両方を充分にサポートするシフトレジスタアレイのための出力マルチプレクサ８０４を示す。ここで、図８ｅに見られる論理ゲートの存在なしで、マルチプレクサ８０４における新たな出力（例えば新しいシフトアウト値）は、８つの異なる位置（左隣、右隣、…、２ホップ下隣）にブロードキャストされるであろう。ここでは、当技術分野で理解され
ているように、論理回路における配線のランレングスを横切るデータの変化は、「スイッチング動作」に対応し、これは電力を消費する。
FIG. 8e shows a special fanout circuit system from the output multiplexer 804 of a unit cell of shift array structure. Here, the output multiplexer 804 can be seen as similar to the
マルチプレクサ８０４の出力で見られる８つの論理ゲートの存在は、シフト方向に対応する実際の配線上を除くそのようなデータ変化を防止するように設計される。例えば、シフト方向が右へ１ホップである場合、すぐ右隣に結合されるゲートのみが、マルチプレクサ８０４の出力を通過させる。すべての他の論理ゲートは、データ値が（シフト値が必要とされない）他のノードに伝搬するのを防止し、プロセスにおけるシフト動作の電力消費を低減する。 The presence of eight logic gates found at the output of the multiplexer 804 is designed to prevent such data changes except on the actual wiring corresponding to the shift direction. For example, if the shift direction is one hop to the right, only the gate coupled to the immediate right will pass the output of the multiplexer 804. All other logic gates prevent data values from propagating to other nodes (where shift values are not required), reducing the power consumption of shift operations in the process.
ｄ．注記の追加的実行レーン動作
図９は、実行レーンアレイ内の実行レーンが異なるデータビット幅を処理することを可能にするために使用される技術に関する。ここで、当技術分野で理解されているように、より大きなダイナミックレンジが、データ値のビット幅を増加させることによって達成される（１６ビット値は、８ビット値より大きいダイナミックレンジで値を表現することができる）。一実施形態では、ステンシルプロセッサは、８、１６、または３２ビットピクセル値のような異なるビット幅を有する画像に対して動作することが期待される。したがって、１つのアプローチによれば、実行レーンそれら自体は、３２ビットオペランドを内部で処理できるという意味で、３２ビットマシンである。
d. Note Additional Execution Lane Operation FIG. 9 relates to techniques used to allow execution lanes in an execution lane array to handle different data bit widths. Here, as is understood in the art, a larger dynamic range is achieved by increasing the bit width of the data value (16-bit values represent values with a dynamic range greater than 8-bit values). can do). In one embodiment, the stencil processor is expected to work with images having different bit widths, such as 8, 16, or 32-bit pixel values. Therefore, according to one approach, the execution lanes themselves are 32-bit machines in the sense that they can handle 32-bit operands internally.
しかし、二次元シフトレジスタのサイズおよび複雑さを低減するために、各実行レーンのレジスタファイル内のレジスタの個々の記憶素子は８ビットに制限される。８ビットの画像データの場合には、データのシート全体がレジスタファイルの１つのレジスタに収まり得るので問題はない。対照的に、１６または３２ビットオペランドの場合、シート生成部は、入力オペランドデータセットを適切に表現するために複数のシートを生成する。 However, in order to reduce the size and complexity of the two-dimensional shift register, the individual storage elements of the registers in the register file for each execution lane are limited to 8 bits. In the case of 8-bit image data, there is no problem because the entire sheet of data can fit in one register of the register file. In contrast, for 16- or 32-bit operands, the sheet generator will generate multiple sheets to properly represent the input operand dataset.
例えば、図９に示すように、１６ビットの入力オペランドの場合、シート生成部は、ＨＩ半シートおよびＬＯ半シートを生成する。ＨＩ半シートは、正しいアレイ位置において各データ項目の上位８ビットを含む。ＬＯ半シートは、正しいアレイ位置において各データ項目の下位８ビットを含む。次いで、両方のシートをステンシルプロセッサにロードし、１６ビット演算が行われることを実行レーンハードウェアに（例えば、プログラムコードの即値を介して）通知することによって、１６ビット演算が実行される。ここでは、ほんの１つの可能な動作モードとして、ＨＩシートおよびＬＯシートの両方が、各実行レーンのレジスタファイルの２つの異なるレジスタにロードされる。 For example, as shown in FIG. 9, in the case of a 16-bit input operand, the sheet generator generates a HI half sheet and an LO half sheet. The HI half sheet contains the upper 8 bits of each data item at the correct array position. The LO half sheet contains the lower 8 bits of each data item at the correct array position. The 16-bit operation is then performed by loading both sheets into the stencil processor and notifying the execution lane hardware (eg, via the immediate value of the program code) that the 16-bit operation will be performed. Here, as only one possible mode of operation, both the HI sheet and the LO sheet are loaded into two different registers in the register file for each execution lane.
実行レーンユニットは、最初にレジスタファイル位置の１つから読み出し、その中のデータを別のレジスタファイル位置から読み出されたデータで付加することにより、正しいオペランドを内部的に構築することができる。同様に、書込方向では、実行レーンユニットは２つの書込を実行しなくてはならない。具体的には、ＬＯシートを含むレジスタファイルの第１のレジスタへの下位８ビットの第１の書込と、ＨＩシートを含むレジスタファイルの第２のレジスタへの上位８ビットの第２の書込とを行う。 The execution lane unit can internally construct the correct operand by first reading from one of the register file positions and adding the data in it to the data read from another register file position. Similarly, in the write direction, the execution lane unit must perform two writes. Specifically, the first write of the lower 8 bits to the first register of the register file containing the LO sheet and the second book of the upper 8 bits to the second register of the register file containing the HI sheet. Do the inclusion.
先の考察から、様々な実施形態のシフトでは、１つのレジスタのみの内容がサイクルごとにシフトされることが許可されることを思い出されたい。これらの場合において、二次元シフトレジスタ構造の周りで１６ビットデータ値を移動させるためには、８ビットデータ値の場合における１サイクルではなく、（演算間で）シフトシーケンスにつき２サイクルが消費される。つまり、８ビットのデータ値の公称の場合では、すべてのデータを位置間で１サイクルでシフトすることができる。対照的に、１６ビットのデータ値の場合には、２つの８ビット値がシフトレジスタシフト動作ごとにシフトされなければならない（ＨＩ半シートおよびＬＯ半シート）。一実施形態では、３２ビットの場合、画像データ全体
を表すために２つのシートではなく４つのシートが作成される以外は、同じ原理が適用される。同様に、シフトシーケンスごとに４サイクルも消費する必要があり得る。
Recall from the previous discussion that the shifts of the various embodiments allow the contents of only one register to be shifted cycle by cycle. In these cases, moving a 16-bit data value around a two-dimensional shift register structure consumes two cycles per shift sequence (between operations) instead of one cycle in the case of 8-bit data values. .. That is, in the case of a nominal 8-bit data value, all data can be shifted between positions in one cycle. In contrast, for 16-bit data values, two 8-bit values must be shifted for each shift register shift operation (HI half-sheet and LO half-sheet). In one embodiment, the same principle applies, except that in the case of 32 bits, four sheets are created instead of two to represent the entire image data. Similarly, it may be necessary to consume as many as 4 cycles per shift sequence.
図１０は、動作中に実際のハードウェア内において競合するメモリアクセスがないように、ランダムメモリアクセスをアンロールするコンパイラ動作に関する。ここで、図１０の手順は、データがより高いレベルの仮想コードによって操作されることおよび基礎となるマシンの物理的制限を考慮してオブジェクトコードを構成することに向けられる。前述のように、実行レーンアレイにおける各実行レーンは、関連するレジスタファイル（例えば、実行レーン当たり４つのレジスタ）を有する。ほとんどの実行レーンと同様に、実行レーンは、オブジェクトコード命令と整合するレジスタとデータの読み書きを行う。コンパイラは、ほとんどのコンパイラと同様に、どのレジスタにどのデータが格納されているかを意識し、使用可能なレジスタ空間の物理的な制限を認識する。 FIG. 10 relates to a compiler operation that unrolls random memory access so that there are no conflicting memory accesses in the actual hardware during operation. Here, the procedure of FIG. 10 is directed to constructing the object code in view of the fact that the data is manipulated by higher level virtual code and the physical limitations of the underlying machine. As mentioned above, each run lane in the run lane array has an associated register file (eg, 4 registers per run lane). Like most execution lanes, execution lanes read and write registers and data consistent with object code instructions. Like most compilers, the compiler is aware of which data is stored in which register and is aware of the physical limitations of the register space available.
したがって、時折、実行レーンは、レジスタ空間にはないが、実行レーンアレイにおける実行レーンの行および／または列に関連付けられるランダムアクセスメモリに位置するデータ項目を必要とし得る。同様に、時折、実行レーンはデータ項目を書き込む必要があり得るが、（現在レジスタ空間内のすべてのデータが依然として依存性を有するため）データを書き込むことができるレジスタ空間がない。このような状況では、コンパイラは、メモリロード命令またはメモリストア命令を（レジスタロード命令またはレジスタストア命令とは対照的に）オブジェクトコードに挿入して、レジスタ空間ではなくランダムアクセスメモリとデータのフェッチ／書込を行う。 Therefore, from time to time, the execution lanes may require data items that are not in register space but are located in random access memory associated with the rows and / or columns of the execution lanes in the execution lane array. Similarly, from time to time, the execution lane may need to write data items, but there is no register space to write data to (because all the data in the register space currently still has dependencies). In such situations, the compiler inserts a memory load or memory store instruction into the object code (as opposed to a register load or register store instruction) to fetch random access memory and data instead of register space /. Write.
図１０は、アレイの各行に沿って別個のランダムアクセスメモリ１００７＿１ないし１００７＿Ｒを示すハードウェアアーキテクチャの実施形態を示す。このアーキテクチャから、実行レーンアレイの同じ行に沿った実行レーンは、同じランダムアクセスメモリへのアクセスが与えられる。図示のように、各実行レーンは、それのそれぞれのランダムアクセスメモリにアクセスするためのメモリユニットを含む。したがって、異なる行の２つの異なる実行レーンが同じサイクル中にメモリロード命令を実行するとき、命令は、異なるランダムアクセスメモリに向けられるので、競合しない。 FIG. 10 shows an embodiment of a hardware architecture showing separate random access memories 1007_1 through 1007_R along each row of the array. From this architecture, run lanes along the same row in the run lane array are given access to the same random access memory. As shown, each execution lane contains a memory unit for accessing its respective random access memory. Therefore, when two different execution lanes on different rows execute memory load instructions during the same cycle, the instructions are directed to different random access memories and therefore do not conflict.
対照的に、同じ行の実行レーンが同じサイクルでメモリアクセスを実行する場合、メモリアクセスは競合する。実行レーンアレイがＳＩＭＤのような態様でに動作することを想定すると、プログラムコードは当然、（行及び列の両方を含む）アレイの実行レーンに同じサイクルでメモリアクセス要求を発行させる。したがって、同じ行にある実行レーンからの競合するメモリアクセスは予見可能な危険である。図１０は、同じ行の２つの異なる実行レーン上で実行するためのスレッド１００１の対を示す。マシンのＳＩＭＤのような性質が与えられると、両方の実行レーンは、最初の２つの示されるサイクルでメモリロード命令の対を含む同じサイクルで同じオペコードを実行する。メモリロード命令のアドレスを調べると、すべてのアドレスが異なることに注目されたい。したがって、両方のスレッドの第１のメモリロード命令は真に互いと競合し、両方のスレッドの第２のメモリロード命令は真に互いと競合する。
In contrast, memory access conflicts when execution lanes on the same row perform memory access in the same cycle. Assuming that the execution lane array operates in a SIMD-like manner, the program code naturally causes the execution lanes of the array (including both rows and columns) to issue memory access requests in the same cycle. Therefore, competing memory access from execution lanes on the same row is a foreseeable danger. FIG. 10 shows a pair of
このように、コンパイラがオブジェクトコードにメモリロード命令を課すと、コンパイラはメモリロード命令が同じ行にある実行レーンに対してコンフリクトを押付けることも認識する。それに応答して、コンパイラは、シーケンシャルなメモリロード命令をコードに課して、同じ行に沿った競合するメモリロード命令を効果的にアンロールし、各実行レーンにメモリにアクセスするためのそれ自身の予約サイクルが提供されるようにする。図１０の例では、最終オブジェクトコード１００２は、４つのサイクルにわたる４つのシーケンシャルなメモリロード命令のシーケンスを含み、ある実行レーンのメモリアクセスが同じ行に沿った別の実行レーンのメモリアクセスと干渉しないことを保証する。
Thus, when the compiler imposes a memory load instruction on the object code, the compiler also recognizes that the memory load instruction imposes a conflict on the execution lane on the same line. In response, the compiler imposes sequential memory load instructions on the code to effectively unroll conflicting memory load instructions along the same line and access its own memory to each execution lane. Ensure that a booking cycle is provided. In the example of FIG. 10, the
図１０の手法は、セクション１．０で上述したメモリモデルのルックアップテーブル部分に特に適用可能であることに注目されたい。ここで、異なる実行レーンが同じルックアップテーブル内の異なるインデックスを使用して、同じサイクルで同じルックアップテーブルの異なるエントリにアクセスすることができることを想起されたい。一実施形態では、コンパイラは、同じルックアップテーブルの異なるコピーを各ランダムアクセスメモリ１００７＿１ないし１００７＿Ｒにインスタンス化する。したがって、異なる行の実行レーンによって同じサイクル中にローカルテーブルコピーにルックアップを作成することができる。そのようなルックアップは競合せず、各ルックアップのインデックスは異なり得る。対照的に、同じ行に沿った実行レーンによって実行されるルックアップは、同じメモリにおける同じルックアップテーブルにアクセスし、シーケンシャルにアンロールされ実行される必要がある。シーケンシャルなアクセスへのアンロールによって、インデックス値は異なることを許される。一実施形態では、オブジェクトコードのＶＬＩＷ命令フォーマットは、数学的演算のためのオペコードと共に、実際に命令を実行することになっているある行に沿った実行レーンの識別情報をさらに含むメモリ動作のためのオペコードを含む（行に沿った他の実行レーンはそれをノーオペレーションとして扱う）。 It should be noted that the method of FIG. 10 is particularly applicable to the look-up table portion of the memory model described above in Section 1.0. Recall that different execution lanes can use different indexes in the same look-up table to access different entries in the same look-up table in the same cycle. In one embodiment, the compiler instantiates different copies of the same look-up table into each random access memory 1007_1 through 1007_R. Therefore, it is possible to create a lookup on a local table copy during the same cycle with different row execution lanes. Such lookups do not conflict and the index of each lookup can be different. In contrast, lookups performed by execution lanes along the same row must access the same lookup table in the same memory and be sequentially unrolled and executed. Index values are allowed to vary depending on the unroll to sequential access. In one embodiment, the VLIW instruction format of the object code is for memory operation that further includes the opcode for the mathematical operation as well as the identification information of the execution lane along a line where the instruction is actually to be executed. Includes the opcode of (other execution lanes along the line treat it as no operation).
様々な実施形態では、コンパイラはアトミック更新命令をルックアップテーブルと同様に扱う。すなわち、アトミック命令の結果のためにランダムアクセスメモリ１００７＿１ないし１００７＿Ｒに（例えば、行ごとに）メモリ空間が予約される。（例えば、異なる行に沿った同じ位置決めされた実行レーンからの）競合しない更新は、同じサイクル中に実行することが許可され、（例えば、同じ行に沿った実行レーンによる）競合する更新は、別々の命令にアンロールされる。アトミック更新命令は、多くの場合、コンパイラによってリード・モディファイ・ライト命令として実現され、読出は実行レーンのレジスタ空間に存在する最近の結果データからなされ、そのようなデータは数学的に演算され、次いで、特別に予約されたアトミック更新テーブルに書き込まれる。 In various embodiments, the compiler treats atomic update instructions like a look-up table. That is, a memory space is reserved in the random access memories 1007_1 to 1007_R (for example, line by line) for the result of the atomic instruction. Non-conflicting updates (eg from the same positioned run lane along different rows) are allowed to run during the same cycle, and conflicting updates (eg from run lanes along the same row) Unrolled into separate instructions. Atomic update instructions are often implemented by the compiler as read-modify-write instructions, reads are made from recent result data residing in the register space of the execution lane, such data is mathematically calculated, and then , Written to a specially reserved atomic update table.
ｃ．実現例の実施形態
上述した様々な画像プロセッサアーキテクチャの特徴は、必ずしも従来の意味での画像処理に限定されず、したがって、画像プロセッサを再特徴付けしてもよい（またはしなくてもよい）他のアプリケーションに適用することができることを指摘することが適切である。例えば、実際のカメラ画像の処理とは対照的に、アニメーションの作成および／または生成および／またはレンダリングにおいて上述した様々な画像プロセッサアーキテクチャの特徴のいずれかが使用される場合、画像プロセッサはグラフィックス処理ユニットとして徳経づけられてもよい。さらに、上述した画像プロセッサアーキテクチャの特徴は、ビデオ処理、視覚処理、画像認識および／または機械学習などの他の技術的用途にも適用することができる。このように適用されて、画像プロセッサは、より汎用的なプロセッサ（例えば、コンピューティングシステムのＣＰＵの一部であるか、またはその一部である）と（例えばコプロセッサとして）一体化されてもよく、またはコンピューティングシステム内のスタンドアロンプロセッサであってもよい。
c. Embodiments of the Examples The features of the various image processor architectures described above are not necessarily limited to image processing in the traditional sense, and thus may (or may not) recharacterize the image processor, etc. It is appropriate to point out that it can be applied to the application of. For example, if any of the features of the various image processor architectures mentioned above are used in creating and / or generating and / or rendering animations, as opposed to processing the actual camera image, the image processor will process the graphics. It may be rendered as a unit. In addition, the features of the image processor architecture described above can be applied to other technical applications such as video processing, visual processing, image recognition and / or machine learning. Applied in this way, the image processor may be integrated (eg, as a coprocessor) with a more general purpose processor (eg, part of or part of the CPU of a computing system). Well, or may be a stand-alone processor in a computing system.
上述したハードウェア設計の実施形態は、半導体チップ内において、および／または最終的に半導体製造プロセスに向けての回路設計の記述として実施することができる。後者の場合、そのような回路記述は、より高い／挙動レベルの回路記述（例えばＶＨＤＬ記述）もしくはより低いレベルの回路記述（例えばレジスタ転送レベル（ＲＴＬ）記述、トランジスタレベル記述もしくはマスク記述）またはそれらの様々な組み合わせの形態をとってもよい。回路記述は、典型的には、コンピュータ可読記憶媒体（例えばＣＤ−ＲＯＭまたは他のタイプの記憶技術）上に実施される。 The hardware design embodiments described above can be implemented within the semiconductor chip and / or as a description of the circuit design for the semiconductor manufacturing process in the end. In the latter case, such circuit descriptions may be higher / behavior level circuit descriptions (eg VHDL descriptions) or lower level circuit descriptions (eg register transfer level (RTL) descriptions, transistor level descriptions or mask descriptions) or them. It may take the form of various combinations of. The circuit description is typically implemented on a computer-readable storage medium (eg, a CD-ROM or other type of storage technology).
先のセクションから、上記の画像プロセッサは、（例えば、ハンドヘルド装置のカメラ
からのデータを処理するハンドヘルド装置のシステムオンチップ（ＳＯＣ）の一部として）コンピュータシステム上のハードウェアで実施できることを認識することに関係する。画像プロセッサがハードウェア回路として実施される場合、画像プロセッサによって処理される画像データはカメラから直接受信されてもよいことに留意されたい。ここで、画像プロセッサは、別体のカメラの一部であってもよいし、一体化されたカメラを有するコンピューティングシステムの一部であってもよい。後者の場合、画像データは、カメラから直接、またはコンピューティングシステムのシステムメモリから受信することができる（例えば、カメラは、その画像データを画像プロセッサではなくシステムメモリに送信する）。先のセクションで説明した機能の多くは、（アニメーションをレンダリングする）グラフィックスプロセッサユニットにも適用可能であることにも留意されたい。
From the previous section, we recognize that the above image processor can be implemented in hardware on a computer system (eg, as part of a handheld device's system-on-chip (SOC) that processes data from the handheld device's camera). Related to that. Note that if the image processor is implemented as a hardware circuit, the image data processed by the image processor may be received directly from the camera. Here, the image processor may be part of a separate camera or part of a computing system with an integrated camera. In the latter case, the image data can be received directly from the camera or from the system memory of the computing system (eg, the camera sends the image data to the system memory instead of the image processor). It should also be noted that many of the features described in the previous section are also applicable to the graphics processor unit (which renders the animation).
図１１は、コンピューティングシステムの例示的な図である。以下に説明するコンピューティングシステムのコンポーネントの多くは、一体化されたカメラおよび関連する画像プロセッサ（例えば、スマートフォンまたはタブレットコンピュータなどのハンドヘルドデバイス）を有するコンピューティングシステムに適用可能である。当業者は、２つの間の範囲を容易に定めることができるであろう。 FIG. 11 is an exemplary diagram of a computing system. Many of the computing system components described below are applicable to computing systems with integrated cameras and associated image processors (eg, handheld devices such as smartphones or tablet computers). Those skilled in the art will be able to easily determine the range between the two.
図１１に見られるように、基本的なコンピューティングシステムは、中央処理ユニット１１０１（例えば、マルチコアプロセッサまたはアプリケーションプロセッサ上に配置された複数の汎用処理コア１１１５＿１〜１１１５＿Ｎおよびメインメモリコントローラ１１１７を含み得る）、システムメモリ１１０２、ディスプレイ１１０３（例えばタッチスクリーン、フラットパネル）、ローカル有線ポイントツーポイントリンク（例えばＵＳＢ）インタフェース１１０４、様々なネットワークＩ／Ｏ機能１１０５（イーサネット（登録商標）インタフェースおよび／またはセルラーモデムサブシステムなど）、無線ローカルエリアネットワーク（例えばＷｉＦｉ）インタフェース１１０６、ワイヤレスポイントツーポイントリンク（例えばブルートゥース（登録商標））インタフェース１１０７およびグローバルポジショニングシステムインタフェース１１０８、様々なセンサ１１０９＿１〜１１０９＿Ｎ、１つ以上のカメラ１１１０、バッテリ１１１１、電力管理制御ユニット１１１２、スピーカおよびマイクロホン１１１３、ならびに音声コーダ／デコーダ１１１４を含んでもよい。
As seen in FIG. 11, a basic computing system may include a central processing unit 1101 (eg, including a plurality of general purpose processing cores 1115_1-1115_N and a main memory controller 1117 located on a multi-core processor or application processor). ,
アプリケーションプロセッサまたはマルチコアプロセッサ１１５０は、そのＣＰＵ１１０１内における１つ以上の汎用処理コア１１１５、１つ以上のグラフィカル処理ユニット１１１６、メモリ管理機能１１１７（例えばメモリコントローラ）、Ｉ／Ｏ制御機能１１１８および画像処理ユニット１１１９を含んでもよい。汎用処理コア１１１５は、典型的には、コンピューティングシステムのオペレーティングシステムおよびアプリケーションソフトウェアを実行する。グラフィックス処理ユニット１１１６は、典型的には、ディスプレイ１１０３上に提示されるグラフィックス情報を生成するために、グラフィックス集中型機能を実行する。メモリ制御機能１１１７は、システムメモリ１１０２とインタフェースして、システムメモリ１１０２との間でデータの書込／読出を行う。電力管理制御ユニット１１１２は、システム１１００の電力消費を全体的に制御する。
The application processor or
画像処理ユニット１１１９は、先のセクションで説明した画像処理ユニットの実施形態のいずれかに従って実現することができる。代替的にまたは組み合わせて、ＩＰＵ１１１９は、ＧＰＵ１１１６およびＣＰＵ１１０１のいずれかまたは両方にそのコプロセッサとして結合されてもよい。さらに、様々な実施形態では、ＧＰＵ１１１６は、上で説明した画像プロセッサの特徴のいずれかを用いて実現することができる。
The
タッチスクリーンディスプレイ１１０３、通信インタフェース１１０４〜１１０７、ＧＰＳインタフェース１１０８、センサ１１０９、カメラ１１１０、およびスピーカ／マイ
クコーデック１１１３，１１１４の各々はすべて、適切な場合には、一体化された周辺装置（例えば１つ以上のカメラ１１１０）も含むコンピューティングシステム全体に対して様々な形態のＩ／Ｏ（入力および／または出力）として見ることができる。実現例によっては、これらのＩ／Ｏコンポーネントの様々なものは、アプリケーションプロセッサ／マルチコアプロセッサ１１５０上に統合されてもよく、またはアプリケーションプロセッサ／マルチコアプロセッサ１１５０のダイから離れて、またはそのパッケージ外に配置されてもよい。
Touch screen displays 1103, communication interfaces 1104-1107,
一実施形態では、１つ以上のカメラ１１１０は、カメラとその視野内の対象との間の深度を測定することができる深度カメラを含む。アプリケーションプロセッサまたは他のプロセッサの汎用ＣＰＵコア（もしくはプログラムコードを実行するために命令実行パイプラインを有する他の機能ブロック）上で実行されるアプリケーションソフトウェア、オペレーティングシステムソフトウェア、デバイスドライバソフトウェアおよび／またはファームウェアは、上記の機能のいずれかを実行してもよい。
In one embodiment, the one or
本発明の実施形態は、上述したような様々なプロセスを含むことができる。これらのプロセスは、機械実行可能命令で実施されてもよい。これらの命令は、汎用または特殊目的のプロセッサに特定のプロセスを実行させるために使用できる。代替的に、これらのプロセスは、プロセスを実行するためのハードワイヤード論理を含む特定のハードウェアコンポーネントによって、またはプログラミングされたコンピュータコンポーネントとカスタムハードウェアコンポーネントとの任意の組み合わせによって実行されてもよい。 Embodiments of the present invention can include various processes as described above. These processes may be carried out with machine executable instructions. These instructions can be used to force a general purpose or special purpose processor to perform a particular process. Alternatively, these processes may be run by specific hardware components, including hard-wired logic to run the processes, or by any combination of programmed computer components and custom hardware components.
本発明の要素はまた、機械実行可能命令を記憶するための機械可読媒体として提供されてもよい。機械可読媒体は、フロッピー（登録商標）ディスク、光ディスク、ＣＤ−ＲＯＭ、および光磁気ディスク、フラッシュメモリ、ＲＯＭ、ＲＡＭ、ＥＰＲＯＭ、ＥＥＰＲＯＭ、磁気もしくは光カード、伝搬媒体、または電子命令を記憶するのに適した他のタイプの媒体／機械可読媒体を含むが、それらに限定はされない。例えば、本発明は、搬送波または通信リンク（例えばモデムもしくはネットワーク接続）を介する他の伝搬媒体で実施されたデータ信号によって、遠隔のコンピュータ（例えばサーバ）から要求側コンピュータ（例えばクライアント）に転送され得るコンピュータプログラムとしてダウンロードすることができる。 The elements of the invention may also be provided as a machine-readable medium for storing machine-executable instructions. Machine-readable media are for storing floppy (registered trademark) disks, optical disks, CD-ROMs, and magneto-optical disks, flash memories, ROMs, RAMs, EPROMs, EEPROMs, magnetic or optical cards, propagation media, or electronic instructions. Includes, but is not limited to, other suitable types of media / machine readable media. For example, the invention may be transferred from a remote computer (eg server) to a requesting computer (eg client) by a data signal carried out on a carrier or other propagation medium over a communication link (eg modem or network connection). It can be downloaded as a computer program.
前述の明細書では、本発明をその特定の例示的な実施形態を参照して説明した。しかしながら、特許請求の範囲に記載される本発明のより広い精神および範囲から逸脱することなく、様々な修正および変更がなされ得ることは明らかであろう。したがって、明細書および図面は、限定的ではなく例示的なものとみなされるべきである。 In the above specification, the present invention has been described with reference to its particular exemplary embodiment. However, it will be clear that various modifications and modifications can be made without departing from the broader spirit and scope of the invention described in the claims. Therefore, the specification and drawings should be regarded as exemplary rather than limiting.
Claims (20)
実行レーンのアレイと、
スカラーレーンと、
二次元シフトレジスタアレイと、
データのシートを二次元シフトレジスタアレイにロードするように構成されたシート生成部とを備え、前記コンピューティングデバイスは、動作を実行するように構成され、前記動作は、
前記スカラーレーンが、（１）スカラーレーンによって実行されるべき演算を指定するスカラー命令と、（２）前記シフトレジスタアレイ内のシフトレジスタの第２のビット幅よりも広い第１のビット幅を有するオペランドを用いて実行されるべき演算を指定する実行レーン命令とを有する予め定められたフォーマットの命令を受け取ることと、
前記シート生成部にハイシートおよびローシートを前記コンピューティングデバイスの前記シフトレジスタアレイにロードさせる１つ以上の命令を前記シート生成部に対して発行することと、
前記スカラーレーンが、前記予め定められたフォーマットの命令を受け取ると、前記スカラー命令が指定する演算を実行し、前記実行レーン命令を前記実行レーンのアレイの前記実行レーンの各々に与えることとを含み、
前記実行レーン命令は、前記シフトレジスタアレイにロードされた前記ハイシートおよび前記ローシートからのデータを用いて、前記第１のビット幅を有する前記オペランドを用いて前記演算を実行する１つ以上の命令を含む、コンピューティングデバイス。 It ’s a computing device,
An array of execution lanes and
Scalar lane and
Two-dimensional shift register array and
The computing device is configured to perform an operation, comprising a sheet generator configured to load a sheet of data into a two-dimensional shift register array.
The scalar lane has (1) a scalar instruction specifying an operation to be performed by the scalar lane and (2) a first bit width wider than the second bit width of the shift register in the shift register array. Receiving an instruction in a predetermined format with an execution lane instruction that specifies the operation to be performed using an operand, and
Issuing one or more instructions to the sheet generator to load the high sheet and the low sheet into the shift register array of the computing device.
When the scalar lane receives an instruction in the predetermined format, it includes performing an operation specified by the scalar instruction and giving the execution lane instruction to each of the execution lanes in the array of the execution lanes. ,
The execution lane instruction is one or more instructions that use data from the high sheet and the low sheet loaded into the shift register array to perform the operation using the operands having the first bit width. the including computing device.
前記シフトレジスタアレイに格納された前記ハイシートから第１の読み取りを実行して、前記オペランドの第１の部分を取得することと、
前記シフトレジスタアレイに格納された前記ローシートから第２の読み取りを実行して、前記オペランドの第２の部分を取得することとを含む動作を実行することによって行うよう構成される、請求項１に記載のコンピューティングデバイス。 The execution lane uses the data from the high seat and the low seat loaded in the shift register array.
To obtain the first part of the operand by performing a first read from the highsheet stored in the shift register array.
Claim 1 is configured to perform a second read from the rowsheet stored in the shift register array to perform an operation comprising acquiring a second portion of the operand. Described computing device.
前記結果の第１の部分の第１の書き込みを前記シフトレジスタアレイに格納された前記ハイシートに対して実行することと、
前記結果の第２の部分の第２の書き込みを前記シフトレジスタアレイに格納された前記ローシートに対して実行することと含む動作を実行することにより行うように構成される、請求項２に記載のコンピューティングデバイス。 The execution lane stores the respective parts of the result of executing the one or more instructions in the high sheet and the low sheet of the shift register array.
Performing the first write of the first part of the result to the highsheet stored in the shift register array,
2. The second aspect of claim 2, wherein the second write of the second portion of the result is configured to be performed by performing an operation including performing on the row sheet stored in the shift register array. Computing device.
前記シフトレジスタアレイに格納された第１の追加のシートから第１の読み取りを実行して、前記オペランドの第１の部分を取得することと、
前記シフトレジスタアレイに格納された第２の追加のシートから第２の読み取りを実行して、前記オペランドの第２の部分を取得することとを含む動作を実行することによって行うよう構成される、請求項６に記載のコンピューティングデバイス。 The execution lane uses data from two additional data sheets loaded into the shift register array.
Performing a first read from the first additional sheet stored in the shift register array to get the first part of the operand.
It is configured to perform a second read from a second additional sheet stored in the shift register array to perform an operation including retrieving a second portion of the operand. The computing device according to claim 6.
前記スカラーレーンが、（１）スカラーレーンによって実行されるべき演算を指定するスカラー命令と、（２）前記シフトレジスタアレイ内のシフトレジスタの第２のビット幅よりも広い第１のビット幅を有するオペランドを用いて実行されるべき演算を指定する実行レーン命令とを有する予め定められたフォーマットの命令を受け取ることと、
前記シート生成部にハイシートおよびローシートを前記コンピューティングデバイスの前記シフトレジスタアレイにロードさせる１つ以上の命令を前記シート生成部に対して発行することと、
前記スカラーレーンが、前記予め定められたフォーマットの命令を受け取ると、前記スカラー命令が指定する演算を実行し、前記実行レーン命令を前記実行レーンのアレイの前記実行レーンの各々に与えることとを備え、
前記実行レーン命令は、前記シフトレジスタアレイにロードされた前記ハイシートおよび前記ローシートからのデータを用いて、前記第１のビット幅を有する前記オペランドを用いて前記演算を実行する１つ以上の命令を備える、コンピューティングデバイスによって実行される方法。 In a manner executed by a computing device having an array of execution lanes, a scalar lane, a two-dimensional shift register array, and a sheet generator configured to load a sheet of data into the two-dimensional shift register array. There,
The scalar lane has (1) a scalar instruction specifying an operation to be performed by the scalar lane and (2) a first bit width wider than the second bit width of the shift register in the shift register array. Receiving an instruction in a predetermined format with an execution lane instruction that specifies the operation to be performed using an operand, and
Issuing one or more instructions to the sheet generator to load the high sheet and the low sheet into the shift register array of the computing device.
When the scalar lane receives an instruction in the predetermined format, it is provided with performing an operation specified by the scalar instruction and giving the execution lane instruction to each of the execution lanes in the array of the execution lanes. ,
The execution lane instruction is one or more instructions that use the data from the high sheet and the low sheet loaded into the shift register array to perform the operation using the operand having the first bit width. method performed the Bei El, by a computing device.
前記シフトレジスタアレイに格納された前記ハイシートから第１の読み取りを実行して、前記オペランドの第１の部分を取得することと、
前記シフトレジスタアレイに格納された前記ローシートから第２の読み取りを実行して、前記オペランドの第２の部分を取得することとを含む、請求項８に記載の方法。 The execution lane further comprises using the data from the high sheet and the low sheet loaded into the shift register array, and the data from the high sheet and the low sheet with the execution lane loaded into the shift register array. To use
To obtain the first part of the operand by performing a first read from the highsheet stored in the shift register array.
8. The method of claim 8, comprising performing a second read from the rowsheet stored in the shift register array to obtain a second portion of the operand.
前記結果の第１の部分の第１の書き込みを前記シフトレジスタアレイに格納された前記ハイシートに対して実行することと、
前記結果の第２の部分の第２の書き込みを前記シフトレジスタアレイに格納された前記ローシートに対して実行することと含む、請求項９に記載の方法。 The execution lane further comprises storing each portion of the result of executing the one or more instructions in the high sheet and the low sheet of the shift register array, the execution lane having the one or more instructions. It is possible to store each part of the result of executing the above in the high sheet and the low sheet of the shift register array.
Performing the first write of the first part of the result to the highsheet stored in the shift register array,
9. The method of claim 9, comprising performing a second write of a second portion of the result to the rowsheet stored in the shift register array.
前記スカラーレーンが、各実行レーンに対して、前記ハイシートおよび前記ローシートを同じ方向に別々にシフトするよう複数のシフト命令を発行することとをさらに備える、請求項１０に記載の方法。 Upon receiving a shift instruction specifying that the scalar lane shifts the data on the high seat and the low seat of the shift register array.
10. The method of claim 10, wherein the scalar lane further comprises issuing a plurality of shift instructions to each execution lane to separately shift the high seat and the low seat in the same direction.
前記シフトレジスタアレイに格納された第１の追加のシートから第１の読み取りを実行して、前記オペランドの第１の部分を取得することと、
前記シフトレジスタアレイに格納された第２の追加のシートから第２の読み取りを実行して、前記オペランドの第２の部分を取得することとを含む、請求項１３に記載の方法。 The execution lane further comprises using data from two sheets of additional data loaded into the shift register array, from the two sheets of additional data the execution lane loaded into the shift register array. Using data is
Performing a first read from the first additional sheet stored in the shift register array to get the first part of the operand.
13. The method of claim 13, comprising performing a second read from the second additional sheet stored in the shift register array to obtain a second portion of the operand.
前記命令は、（１）スカラーレーンによって実行されるべき演算を指定するスカラー命令と、（２）前記シフトレジスタアレイ内のシフトレジスタの第２のビット幅よりも広い第１のビット幅を有するオペランドを用いて実行されるべき演算を指定する実行レーン命令とを有する予め定められたフォーマットの命令を含み、前記命令を実行することとは、前記コンピューティングデバイスに動作を実行させ、前記動作は、
前記シート生成部にハイシートおよびローシートを前記コンピューティングデバイスの前記シフトレジスタアレイにロードさせる１つ以上の命令を前記シート生成部に対して発行することと、
前記スカラーレーンが、前記予め定められたフォーマットの命令を受け取ると、前記スカラー命令に従う演算を実行し、前記実行レーン命令を前記実行レーンのアレイの前記実行レーンの各々に与えることとを含み、
前記実行レーン命令は、前記シフトレジスタアレイにロードされた前記ハイシートおよび前記ローシートからのデータを用いて、前記第１のビット幅を有する前記オペランドを用いて前記演算を実行する１つ以上の命令を含む、コンピュータプログラム。 Instructions executed by a computing device comprising an array of execution lanes, a scalar lane, a two-dimensional shift register array, and a sheet generator configured to load a sheet of data into the two-dimensional shift register array. It ’s a computer program that I had.
The instructions are an operand having (1) a scalar instruction specifying an operation to be performed by the scalar lane and (2) a first bit width wider than the second bit width of the shift register in the shift register array. Including an instruction in a predetermined format having an execution lane instruction specifying an operation to be performed using the instruction, executing the instruction causes the computing device to perform an operation.
Issuing one or more instructions to the sheet generator to load the high sheet and the low sheet into the shift register array of the computing device.
When the scalar lane receives an instruction in the predetermined format, it includes performing an operation according to the scalar instruction and giving the execution lane instruction to each of the execution lanes in the array of execution lanes.
The execution lane instruction is one or more instructions to perform the operation with the operand having the first bit width using the data from the high sheet and the low sheet loaded in the shift register array. Computer programs , including orders.
前記シフトレジスタアレイに格納された前記ハイシートから第１の読み取りを実行して、前記オペランドの第１の部分を取得することと、
前記シフトレジスタアレイに格納された前記ローシートから第２の読み取りを実行して、前記オペランドの第２の部分を取得することとを含む、請求項１５に記載のコンピュータプログラム。 The operation further comprises using data from the highseat and the lowseat with the execution lane loaded into the shift register array, the highseat with the execution lane loaded into the shift register array and the said. Using data from the low sheet is
To obtain the first part of the operand by performing a first read from the highsheet stored in the shift register array.
15. The computer program of claim 15, comprising performing a second read from the rowsheet stored in the shift register array to obtain a second portion of the operand.
前記結果の第１の部分の第１の書き込みを前記シフトレジスタアレイに格納された前記ハイシートに対して実行することと、
前記結果の第２の部分の第２の書き込みを前記シフトレジスタアレイに格納された前記ローシートに対して実行することと含む、請求項１６に記載のコンピュータプログラム。 The operation further comprises storing each portion of the result of the execution of the one or more instructions in the high sheet and the low sheet of the shift register array, wherein the execution lane is said to be said. Storing each portion of the result of executing one or more instructions in the high sheet and the low sheet of the shift register array is possible.
Performing the first write of the first part of the result to the highsheet stored in the shift register array,
16. The computer program of claim 16, comprising performing a second write of a second portion of the result to the rowsheet stored in the shift register array.
前記スカラーレーンが、前記シフトレジスタアレイの前記ハイシートおよび前記ローシートのデータをシフトすることを指定するシフト命令を受け取ることと、
前記スカラーレーンが、各実行レーンに対して、前記ハイシートおよび前記ローシートを同じ方向に別々にシフトするよう複数のシフト命令を発行することとを含む、請求項１７に記載のコンピュータプログラム。 The above operation further
Upon receiving a shift instruction specifying that the scalar lane shifts the data on the high seat and the low seat of the shift register array.
17. The computer program of claim 17, wherein the scalar lane issues a plurality of shift instructions to each execution lane to separately shift the high seat and the low seat in the same direction.
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US14/694,815 US9772852B2 (en) | 2015-04-23 | 2015-04-23 | Energy efficient processor core architecture for image processor |
US14/694,815 | 2015-04-23 | ||
JP2018148594A JP6612403B2 (en) | 2015-04-23 | 2018-08-07 | Energy efficient processor core architecture for image processors |
Related Parent Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
JP2018148594A Division JP6612403B2 (en) | 2015-04-23 | 2018-08-07 | Energy efficient processor core architecture for image processors |
Publications (2)
Publication Number | Publication Date |
---|---|
JP2020035471A JP2020035471A (en) | 2020-03-05 |
JP6967570B2 true JP6967570B2 (en) | 2021-11-17 |
Family
ID=55963456
Family Applications (3)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
JP2017550902A Active JP6412663B2 (en) | 2015-04-23 | 2016-04-08 | Energy efficient processor core architecture for image processors |
JP2018148594A Active JP6612403B2 (en) | 2015-04-23 | 2018-08-07 | Energy efficient processor core architecture for image processors |
JP2019197437A Active JP6967570B2 (en) | 2015-04-23 | 2019-10-30 | Energy efficient processor core architecture for image processors |
Family Applications Before (2)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
JP2017550902A Active JP6412663B2 (en) | 2015-04-23 | 2016-04-08 | Energy efficient processor core architecture for image processors |
JP2018148594A Active JP6612403B2 (en) | 2015-04-23 | 2018-08-07 | Energy efficient processor core architecture for image processors |
Country Status (7)
Country | Link |
---|---|
US (4) | US9772852B2 (en) |
EP (1) | EP3286722A1 (en) |
JP (3) | JP6412663B2 (en) |
KR (1) | KR101971657B1 (en) |
CN (1) | CN107408041B (en) |
DE (1) | DE112016001836T5 (en) |
WO (1) | WO2016171928A1 (en) |
Families Citing this family (19)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US9772852B2 (en) | 2015-04-23 | 2017-09-26 | Google Inc. | Energy efficient processor core architecture for image processor |
US10313641B2 (en) | 2015-12-04 | 2019-06-04 | Google Llc | Shift register with reduced wiring complexity |
US9830150B2 (en) | 2015-12-04 | 2017-11-28 | Google Llc | Multi-functional execution lane for image processor |
US9891955B2 (en) * | 2015-12-22 | 2018-02-13 | Nxp Usa, Inc. | Heterogenous multicore processor configuration framework |
US10204396B2 (en) * | 2016-02-26 | 2019-02-12 | Google Llc | Compiler managed memory for image processor |
US10387988B2 (en) | 2016-02-26 | 2019-08-20 | Google Llc | Compiler techniques for mapping program code to a high performance, power efficient, programmable image processing hardware platform |
US10380969B2 (en) | 2016-02-28 | 2019-08-13 | Google Llc | Macro I/O unit for image processor |
US20180007302A1 (en) | 2016-07-01 | 2018-01-04 | Google Inc. | Block Operations For An Image Processor Having A Two-Dimensional Execution Lane Array and A Two-Dimensional Shift Register |
US20180005346A1 (en) | 2016-07-01 | 2018-01-04 | Google Inc. | Core Processes For Block Operations On An Image Processor Having A Two-Dimensional Execution Lane Array and A Two-Dimensional Shift Register |
US20180005059A1 (en) | 2016-07-01 | 2018-01-04 | Google Inc. | Statistics Operations On Two Dimensional Image Processor |
US10546211B2 (en) | 2016-07-01 | 2020-01-28 | Google Llc | Convolutional neural network on programmable two dimensional image processor |
US10489199B2 (en) * | 2017-05-12 | 2019-11-26 | Google Llc | Program code transformations to improve image processor runtime efficiency |
US10503689B2 (en) * | 2017-05-15 | 2019-12-10 | Google Llc | Image processor I/O unit |
TWI769810B (en) * | 2017-05-17 | 2022-07-01 | 美商谷歌有限責任公司 | Special purpose neural network training chip |
CN111258653B (en) * | 2018-11-30 | 2022-05-24 | 上海寒武纪信息科技有限公司 | Atomic access and storage method, storage medium, computer equipment, device and system |
US11397624B2 (en) * | 2019-01-22 | 2022-07-26 | Arm Limited | Execution of cross-lane operations in data processing systems |
US10552939B1 (en) | 2019-02-12 | 2020-02-04 | Google Llc | Image processor complex transfer functions |
GB2590521B (en) * | 2020-06-18 | 2022-02-23 | Imagination Tech Ltd | Multiplexing between different processing channels |
US20220197634A1 (en) * | 2020-12-21 | 2022-06-23 | Intel Corporation | Efficient divide and accumulate instruction when an operand is equal to or near a power of two |
Family Cites Families (83)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4445177A (en) | 1981-05-22 | 1984-04-24 | Data General Corporation | Digital data processing system utilizing a unique arithmetic logic unit for handling uniquely identifiable addresses for operands and instructions |
DE3851005T2 (en) * | 1987-06-01 | 1995-04-20 | Applied Intelligent Syst Inc | Parallel neighboring processing system and method. |
US4935894A (en) | 1987-08-31 | 1990-06-19 | Motorola, Inc. | Multi-processor, multi-bus system with bus interface comprising FIFO register stocks for receiving and transmitting data and control information |
US5446479A (en) * | 1989-02-27 | 1995-08-29 | Texas Instruments Incorporated | Multi-dimensional array video processor system |
US5253308A (en) | 1989-06-21 | 1993-10-12 | Amber Engineering, Inc. | Massively parallel digital image data processor using pixel-mapped input/output and relative indexed addressing |
WO1994009595A1 (en) | 1991-09-20 | 1994-04-28 | Shaw Venson M | Method and apparatus including system architecture for multimedia communications |
JP3482660B2 (en) | 1993-09-08 | 2003-12-22 | ソニー株式会社 | Image data processing apparatus and image data processing method |
US5612693A (en) | 1994-12-14 | 1997-03-18 | International Business Machines Corporation | Sliding window data compression using a toroidal bit shift register |
JP3573755B2 (en) * | 1996-01-15 | 2004-10-06 | シーメンス アクチエンゲゼルシヤフト | Image processing processor |
US5892962A (en) | 1996-11-12 | 1999-04-06 | Lucent Technologies Inc. | FPGA-based processor |
US6366289B1 (en) | 1998-07-17 | 2002-04-02 | Microsoft Corporation | Method and system for managing a display image in compressed and uncompressed blocks |
US6587158B1 (en) | 1998-07-23 | 2003-07-01 | Dvdo, Inc. | Method and apparatus for reducing on-chip memory in vertical video processing |
US7010177B1 (en) | 1998-08-27 | 2006-03-07 | Intel Corporation | Portability of digital images |
EP1164544B1 (en) * | 1999-03-16 | 2011-11-02 | Hamamatsu Photonics K.K. | High-speed vision sensor |
JP3971535B2 (en) | 1999-09-10 | 2007-09-05 | 株式会社リコー | SIMD type processor |
JP3922859B2 (en) | 1999-12-28 | 2007-05-30 | 株式会社リコー | Image processing apparatus, image processing method, and computer-readable recording medium storing program for causing computer to execute the method |
DE60019081D1 (en) * | 2000-01-31 | 2005-05-04 | St Microelectronics Srl | Interleaved burst memory with burst access on synchronous read cycles, where the two subordinate memory arrays are independently readable with random access during asynchronous read cycles |
US6745319B1 (en) | 2000-02-18 | 2004-06-01 | Texas Instruments Incorporated | Microprocessor with instructions for shuffling and dealing data |
US6728862B1 (en) | 2000-05-22 | 2004-04-27 | Gazelle Technology Corporation | Processor array and parallel data processing methods |
US6728722B1 (en) | 2000-08-28 | 2004-04-27 | Sun Microsystems, Inc. | General data structure for describing logical data spaces |
US6986025B2 (en) * | 2001-06-11 | 2006-01-10 | Broadcom Corporation | Conditional execution per lane |
US7286717B2 (en) | 2001-10-31 | 2007-10-23 | Ricoh Company, Ltd. | Image data processing device processing a plurality of series of data items simultaneously in parallel |
JP4146654B2 (en) | 2002-02-28 | 2008-09-10 | 株式会社リコー | Image processing circuit, composite image processing circuit, and image forming apparatus |
US9170812B2 (en) | 2002-03-21 | 2015-10-27 | Pact Xpp Technologies Ag | Data processing system having integrated pipelined array data processor |
WO2003088033A1 (en) | 2002-04-09 | 2003-10-23 | University Of Rochester | Multiplier-based processor-in-memory architectures for image and graphics processing |
US6954204B2 (en) * | 2002-07-18 | 2005-10-11 | Nvidia Corporation | Programmable graphics system and method using flexible, high-precision data formats |
AU2003286131A1 (en) | 2002-08-07 | 2004-03-19 | Pact Xpp Technologies Ag | Method and device for processing data |
US20060044576A1 (en) | 2004-07-30 | 2006-03-02 | Kabushiki Kaisha Toshiba | Apparatus for image processing |
US7667764B2 (en) | 2004-06-04 | 2010-02-23 | Konica Minolta Holdings, Inc. | Image sensing apparatus |
JP4219887B2 (en) | 2004-12-28 | 2009-02-04 | 富士通マイクロエレクトロニクス株式会社 | Image processing apparatus and image processing method |
ATE504043T1 (en) | 2005-04-28 | 2011-04-15 | Univ Edinburgh | RECONFIGURABLE INSTRUCTION CELL ARRAY |
US7882339B2 (en) | 2005-06-23 | 2011-02-01 | Intel Corporation | Primitives to enhance thread-level speculation |
JP2007067917A (en) | 2005-08-31 | 2007-03-15 | Matsushita Electric Ind Co Ltd | Image data processing apparatus |
US7602974B2 (en) | 2005-10-21 | 2009-10-13 | Mobilic Technology (Cayman) Corp. | Universal fixed-pixel-size ISP scheme |
FR2895103B1 (en) | 2005-12-19 | 2008-02-22 | Dxo Labs Sa | METHOD AND SYSTEM FOR PROCESSING DIGITAL DATA |
US7802073B1 (en) | 2006-03-29 | 2010-09-21 | Oracle America, Inc. | Virtual core management |
TWI349908B (en) * | 2006-09-14 | 2011-10-01 | Au Optronics Corp | Shift register, shift register array circuit, and flat display apparatus |
US20080111823A1 (en) | 2006-11-13 | 2008-05-15 | Faraday Technology Corp. | Graphics processing system |
EP1927949A1 (en) | 2006-12-01 | 2008-06-04 | Thomson Licensing | Array of processing elements with local registers |
US8321849B2 (en) | 2007-01-26 | 2012-11-27 | Nvidia Corporation | Virtual architecture and instruction set for parallel thread computing |
US20080244222A1 (en) | 2007-03-30 | 2008-10-02 | Intel Corporation | Many-core processing using virtual processors |
US8068114B2 (en) | 2007-04-30 | 2011-11-29 | Advanced Micro Devices, Inc. | Mechanism for granting controlled access to a shared resource |
JP4389976B2 (en) | 2007-06-29 | 2009-12-24 | ブラザー工業株式会社 | Image processing apparatus and image processing program |
TWI338900B (en) * | 2007-08-07 | 2011-03-11 | Au Optronics Corp | Shift register array |
JP4844853B2 (en) | 2007-09-05 | 2011-12-28 | 国立大学法人東北大学 | Solid-state imaging device and driving method thereof |
JP5020029B2 (en) * | 2007-11-16 | 2012-09-05 | 株式会社メガチップス | Image processing device |
CN102047241B (en) | 2008-05-30 | 2014-03-12 | 先进微装置公司 | Local and global data share |
JP4999791B2 (en) | 2008-06-30 | 2012-08-15 | キヤノン株式会社 | Information processing apparatus, control method thereof, and program |
US8456480B2 (en) | 2009-01-14 | 2013-06-04 | Calos Fund Limited Liability Company | Method for chaining image-processing functions on a SIMD processor |
US8332794B2 (en) | 2009-01-22 | 2012-12-11 | Taiwan Semiconductor Manufacturing Company, Ltd. | Circuits and methods for programmable transistor array |
KR101572879B1 (en) | 2009-04-29 | 2015-12-01 | 삼성전자주식회사 | Dynamic parallel system and method for parallel application program |
US20110055495A1 (en) | 2009-08-28 | 2011-03-03 | Qualcomm Incorporated | Memory Controller Page Management Devices, Systems, and Methods |
US8976195B1 (en) | 2009-10-14 | 2015-03-10 | Nvidia Corporation | Generating clip state for a batch of vertices |
US8436857B2 (en) | 2009-10-20 | 2013-05-07 | Oracle America, Inc. | System and method for applying level of detail schemes |
US8595428B2 (en) | 2009-12-22 | 2013-11-26 | Intel Corporation | Memory controller functionalities to support data swizzling |
US8749667B2 (en) | 2010-08-02 | 2014-06-10 | Texas Instruments Incorporated | System and method for maintaining maximum input rate while up-scaling an image vertically |
US8508612B2 (en) | 2010-09-30 | 2013-08-13 | Apple Inc. | Image signal processor line buffer configuration for processing ram image data |
US8797323B2 (en) | 2011-01-18 | 2014-08-05 | Intel Corporation | Shadowing dynamic volumetric media |
WO2012105174A1 (en) | 2011-01-31 | 2012-08-09 | パナソニック株式会社 | Program generation device, program generation method, processor device, and multiprocessor system |
US9092267B2 (en) | 2011-06-20 | 2015-07-28 | Qualcomm Incorporated | Memory sharing in graphics processing unit |
US20130027416A1 (en) | 2011-07-25 | 2013-01-31 | Karthikeyan Vaithianathan | Gather method and apparatus for media processing accelerators |
JP5742651B2 (en) | 2011-10-15 | 2015-07-01 | コニカミノルタ株式会社 | Image processing apparatus, linkage method, and linkage program |
JP5746100B2 (en) | 2011-12-27 | 2015-07-08 | 京セラドキュメントソリューションズ株式会社 | Image forming apparatus |
US8823736B2 (en) | 2012-01-20 | 2014-09-02 | Intel Corporation | Graphics tiling architecture with bounding volume hierarchies |
US10244246B2 (en) | 2012-02-02 | 2019-03-26 | Texas Instruments Incorporated | Sub-pictures for pixel rate balancing on multi-core platforms |
US10007527B2 (en) * | 2012-03-05 | 2018-06-26 | Nvidia Corporation | Uniform load processing for parallel thread sub-sets |
US9235769B2 (en) | 2012-03-15 | 2016-01-12 | Herta Security, S.L. | Parallel object detection method for heterogeneous multithreaded microarchitectures |
TWI520598B (en) | 2012-05-23 | 2016-02-01 | 晨星半導體股份有限公司 | Image processing apparatus and image processing method |
US20140019486A1 (en) | 2012-07-13 | 2014-01-16 | Amitava Majumdar | Logic Content Processing for Hardware Acceleration of Multi-Pattern Search |
US9232139B2 (en) | 2012-07-24 | 2016-01-05 | Apple Inc. | Image stabilization using striped output transformation unit |
US9378181B2 (en) | 2012-11-09 | 2016-06-28 | Intel Corporation | Scalable computing array |
US9851977B2 (en) * | 2012-12-06 | 2017-12-26 | Kalray | Apparatus and method for combining thread warps with compatible execution masks for simultaneous execution and increased lane utilization |
US8954992B2 (en) | 2013-03-15 | 2015-02-10 | Lenovo Enterprise Solutions (Singapore) Pte. Ltd. | Distributed and scaled-out network switch and packet processing |
US10241707B2 (en) * | 2013-05-23 | 2019-03-26 | Intel Corporation | Techniques for organizing three-dimensional array data |
FR3008505B1 (en) * | 2013-07-10 | 2017-03-03 | Thales Sa | METHOD FOR OPTIMIZING PARALLEL DATA PROCESSING ON A MATERIAL PLATFORM |
US9779534B2 (en) * | 2013-08-28 | 2017-10-03 | Qualcomm Incorporated | Prefixed summed length in graphics processing |
US9547530B2 (en) * | 2013-11-01 | 2017-01-17 | Arm Limited | Data processing apparatus and method for processing a plurality of threads |
US9519479B2 (en) * | 2013-11-18 | 2016-12-13 | Globalfoundries Inc. | Techniques for increasing vector processing utilization and efficiency through vector lane predication prediction |
US9977678B2 (en) * | 2015-01-12 | 2018-05-22 | International Business Machines Corporation | Reconfigurable parallel execution and load-store slice processor |
US9818166B2 (en) | 2015-01-16 | 2017-11-14 | Intel Corporation | Graph-based application programming interface architectures with producer/consumer nodes for enhanced image processing parallelism |
US9749548B2 (en) | 2015-01-22 | 2017-08-29 | Google Inc. | Virtual linebuffers for image signal processors |
US9772852B2 (en) | 2015-04-23 | 2017-09-26 | Google Inc. | Energy efficient processor core architecture for image processor |
GB2540382B (en) * | 2015-07-15 | 2020-03-04 | Advanced Risc Mach Ltd | Data processing systems |
-
2015
- 2015-04-23 US US14/694,815 patent/US9772852B2/en active Active
-
2016
- 2016-04-08 KR KR1020177028028A patent/KR101971657B1/en active IP Right Grant
- 2016-04-08 CN CN201680019801.XA patent/CN107408041B/en active Active
- 2016-04-08 JP JP2017550902A patent/JP6412663B2/en active Active
- 2016-04-08 WO PCT/US2016/026789 patent/WO2016171928A1/en active Application Filing
- 2016-04-08 DE DE112016001836.3T patent/DE112016001836T5/en active Pending
- 2016-04-08 EP EP16721988.0A patent/EP3286722A1/en active Pending
-
2017
- 2017-05-15 US US15/595,632 patent/US10275253B2/en active Active
-
2018
- 2018-08-07 JP JP2018148594A patent/JP6612403B2/en active Active
-
2019
- 2019-03-28 US US16/368,288 patent/US10754654B2/en active Active
- 2019-10-30 JP JP2019197437A patent/JP6967570B2/en active Active
-
2020
- 2020-08-24 US US17/001,097 patent/US11138013B2/en active Active
Also Published As
Publication number | Publication date |
---|---|
JP6612403B2 (en) | 2019-11-27 |
KR20170125932A (en) | 2017-11-15 |
US20210004232A1 (en) | 2021-01-07 |
US20170249153A1 (en) | 2017-08-31 |
WO2016171928A1 (en) | 2016-10-27 |
US20160313999A1 (en) | 2016-10-27 |
US11138013B2 (en) | 2021-10-05 |
CN107408041A (en) | 2017-11-28 |
JP2018206413A (en) | 2018-12-27 |
JP2020035471A (en) | 2020-03-05 |
US20190220282A1 (en) | 2019-07-18 |
DE112016001836T5 (en) | 2018-03-29 |
US10754654B2 (en) | 2020-08-25 |
JP2018513473A (en) | 2018-05-24 |
KR101971657B1 (en) | 2019-04-23 |
US10275253B2 (en) | 2019-04-30 |
CN107408041B (en) | 2020-09-25 |
US9772852B2 (en) | 2017-09-26 |
EP3286722A1 (en) | 2018-02-28 |
JP6412663B2 (en) | 2018-10-24 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
JP6967570B2 (en) | Energy efficient processor core architecture for image processors | |
JP6764904B2 (en) | 2D shift array for image processors | |
JP6793228B2 (en) | Sheet generator for image processor | |
JP6858239B2 (en) | Compiler techniques for mapping program code to high-performance, power-efficient, programmable image processing hardware platforms | |
KR101973733B1 (en) | Architecture for high performance, power efficient, programmable image processing processing | |
JP6726752B2 (en) | Compiler managed memory for image processor | |
JP7208920B2 (en) | Determination of memory allocation per line buffer unit | |
JP6967597B2 (en) | An image processor with a configurable number of active cores and an internal network that supports it | |
JP6775088B2 (en) | Program code variants to improve image processor runtime efficiency |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
A521 | Request for written amendment filed |
Free format text: JAPANESE INTERMEDIATE CODE: A523Effective date: 20191113 |
|
A621 | Written request for application examination |
Free format text: JAPANESE INTERMEDIATE CODE: A621Effective date: 20191113 |
|
A977 | Report on retrieval |
Free format text: JAPANESE INTERMEDIATE CODE: A971007Effective date: 20201216 |
|
A131 | Notification of reasons for refusal |
Free format text: JAPANESE INTERMEDIATE CODE: A131Effective date: 20210112 |
|
A521 | Request for written amendment filed |
Free format text: JAPANESE INTERMEDIATE CODE: A523Effective date: 20210401 |
|
TRDD | Decision of grant or rejection written | ||
A01 | Written decision to grant a patent or to grant a registration (utility model) |
Free format text: JAPANESE INTERMEDIATE CODE: A01Effective date: 20210928 |
|
A61 | First payment of annual fees (during grant procedure) |
Free format text: JAPANESE INTERMEDIATE CODE: A61Effective date: 20211025 |
|
R150 | Certificate of patent or registration of utility model |
Ref document number: 6967570Country of ref document: JPFree format text: JAPANESE INTERMEDIATE CODE: R150 |