WO2007134130A2 - Systems and methods for generating statistics from search engine query logs - Google Patents
Systems and methods for generating statistics from search engine query logs Download PDFInfo
- Publication number
- WO2007134130A2 WO2007134130A2 PCT/US2007/068602 US2007068602W WO2007134130A2 WO 2007134130 A2 WO2007134130 A2 WO 2007134130A2 US 2007068602 W US2007068602 W US 2007068602W WO 2007134130 A2 WO2007134130 A2 WO 2007134130A2
- Authority
- WO
- WIPO (PCT)
- Prior art keywords
- sequence
- events
- randomly
- query
- positions
- Prior art date
Links
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06Q—INFORMATION AND COMMUNICATION TECHNOLOGY [ICT] SPECIALLY ADAPTED FOR ADMINISTRATIVE, COMMERCIAL, FINANCIAL, MANAGERIAL OR SUPERVISORY PURPOSES; SYSTEMS OR METHODS SPECIALLY ADAPTED FOR ADMINISTRATIVE, COMMERCIAL, FINANCIAL, MANAGERIAL OR SUPERVISORY PURPOSES, NOT OTHERWISE PROVIDED FOR
- G06Q30/00—Commerce
- G06Q30/02—Marketing; Price estimation or determination; Fundraising
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/24—Querying
- G06F16/242—Query formulation
- G06F16/2425—Iterative querying; Query formulation based on the results of a preceding query
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/30—Information retrieval; Database structures therefor; File system structures therefor of unstructured textual data
- G06F16/33—Querying
- G06F16/3331—Query processing
- G06F16/3349—Reuse of stored results of previous queries
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/95—Retrieval from the web
- G06F16/951—Indexing; Web crawling techniques
Definitions
- the present invention relates generally to search engine and in particular to systems and methods for generating statistics from search engine query logs.
- Data aggregation is a process in which information is gathered and expressed in a summary form for purposes such as statistical data analysis. It often reveals useful information hidden in a large volume of original data records. For example, from a database containing millions of sales records generated by an on-line store, a marketing analyst can learn information about a particular group of consumers such as trends and patterns in their shopping habits by aggregating the related sales records based on specific variables such as product type information, product pricing information, customer age, customer gender, geographic location (e.g., store location or purchaser's address) and any other customer and/or product information available in the database.
- a web search engine may receive millions of queries per day from users around the world.
- the search engine For each query, the search engine generates a query record in its query log.
- the query record may include one or more query terms, a timestamp indicating when the query is received by the search engine, an IP address identifying a unique device (e.g., a PC or a cell phone) from which the query terms are submitted, and an identifier associated with a user who submits the query terms (e.g., a user identifier in a web browser cookie; in some cases the user identifier may also be associated with a toolbar or other application or service to which the user has subscribed).
- Appropriate aggregation of these query records can also unveil interesting or useful information about the web search engine users. For instance, a publisher can gauge the popularity of a newly released book in a specific city from the frequencies of relevant queries submitted by users from that city within a given time period.
- any log record data mining tool include safeguards for preventing the disclosure of information that may be traced back to individuals or small groups of users.
- a computer-implemented method comprises calculating first statistics about a user-identified event within a first subset of a database of events; selecting a second subset of the database of events based on said first statistics; calculating second statistics about the user-identified event within the second subset of the database of events; merging the first and second statistics as statistics of the user- identified event within the entire database of events; and generating a result including at least a portion of the merged statistics of the user-identified event.
- a computer-implemented method comprises identifying in an inverse index file a sequence of positions associated with an indexed item, wherein the sequence of positions corresponds to a set of events from a sequence of randomly-arranged events, each event including at least one occurrence of the indexed item and having a respective sequence number; selecting in the sequence of randomly-arranged events an event corresponding to a predefined position in the sequence of positions and its sequence number; determining a number of positions in the sequence of positions that precede the predefined position; and determining an occurrence frequency for the indexed item in the sequence of randomly-arranged events using the selected event's sequence number and the determined number of positions.
- Figure 1 is a flowchart illustrating a process of converting a query log into multiple sorted partitions of session records in accordance with some embodiments of the present invention.
- Figure 2A is a block diagram of a data structure for storing a query log in accordance with some embodiments of the present invention.
- Figure 2B is a block diagram of a data structure for storing a query session record in accordance with some embodiments of the present invention.
- Figure 2C is a block diagram of an alternative data structure for storing the query session record in accordance with some embodiments of the present invention.
- Figure 3 is a block diagram of an exemplary information service that generates statistics in response to a query in accordance with some embodiments of the present invention.
- Figure 4A is a block diagram of a data structure for storing tokenized session records within a database partition in accordance with some embodiments of the present invention.
- Figure 4B is a block diagram of a data structure for storing a tokenized session record in accordance with some embodiments of the present invention.
- Figure 5A is a flow diagram of a process of identifying a list of repository positions in response to one or more query terms in accordance with some embodiments of the present invention.
- Figure 5B is a block diagram of a data structure for translating or mapping repository positions to session record identifiers and vice versa in accordance with some embodiments of the present invention.
- Figure 5C is a block diagram of a data structure for translating or mapping session record identifiers to user identifiers and vice versa in accordance with some embodiments of the present invention.
- Figure 6 is a block diagram of an exemplary hierarchical structure of multiple query servers in accordance with some embodiments of the present invention.
- Figure 7 is a flowchart illustrating a process of generating statistics from session records in response to a statistics query in accordance with some embodiments of the present invention.
- Figure 8 is a flowchart illustrating a process of executing a statistics sub-query at a leaf query server in accordance with some embodiments of the present invention.
- Figure 9 is a flowchart illustrating a two-pass or multi-pass process of generating statistics related to a specific parameter of the session records in accordance with some embodiments of the present invention.
- Figures 1OA, 1OB and 1OC are exemplary screenshots of webpages containing trends statistics and geographical distribution statistics for queries concerning a particular query term in accordance with some embodiments of the present invention.
- Figure 1 IA is a block diagram of an exemplary query distribution and aggregation server in accordance with some embodiments of the present invention.
- Figure 1 IB is a block diagram of an exemplary leaf query server in accordance with some embodiments of the present invention.
- Figure 12 is a block diagram of an exemplary partition server in accordance with some embodiments of the present invention.
- Figure 13 is a diagram of a bell-shaped curve representing a normal distribution of random data samples.
- FIG 1 is a flowchart illustrating such a data preprocessing procedure for converting a web search engine's query log into multiple sorted partitions of session records.
- Many users submit queries from clients 102 to a search engine 106 through a communication network 106 (e.g., the Internet).
- the search engine 106 For each query, the search engine 106 generates a query record in a query log file 108.
- a query log 210 contains many query records.
- Each query record has multiple attributes, including one or more query terms of a search query, a timestamp, an IP address, and a web cookie or other user identifier.
- each query record includes a language identifier, identifying the language associated with the search query.
- the timestamp indicates when the search query is received by the search engine, and the IP address maps to a unique device (e.g., a personal computer, cell phone, or other client device) from which the search query terms are submitted.
- the web cookie uniquely identifies a user of the web search engine and therefore can be used as a proxy for the user's identifier.
- each query log record contains a user identifier.
- a query log sampling process 110 can be employed to sub- sample the query log 108 and produce a sub-sampled query log 112.
- the sub- sampled query log 112 may contain ten percent or twenty percent of the log records in the original query log 108. Note that the sampling process is optional. In some embodiments, the entire query log 108 is used to generate statistical information.
- the query log sampling process 110 may utilize any of a number of different random (or pseudo-random) sampling schemes to produce a sub-sampled, but diversified and robust, query log 112.
- the query log sampling process 110 performs a uniform sub-sampling of the query log, e.g., selecting every fifth query record as the sub- sampled query log.
- the query log sampling process 110 first separates all the query records by their associated geographical regions (which are based on the IP addresses associated with the records). For each geographical region, the query log sampling process 110 randomly selects a certain percentage of query records as the sub- sampled query log.
- This sampling scheme ensures that query records from different geographical regions are proportionally included in the sub-sampled query log, based on their ratios in the original query log. These sub-sampling schemes can be based other predefined criteria. There are also many other sampling schemes known to one skilled in the art that may be used here to produce the sub-sampled query log 112.
- the query log sampling process 110 implements a sampling strategy to achieve a sub-sampled query log 112 that satisfies one or more predefined diversity requirements.
- Exemplary requirements include limiting the number of query records in the query log 112 having a particular IP address for a given time period. These requirements can effectively increase the sub-sampled query log 112' s diversity and prevent the sub-sampled query log 112 from being corrupted by bogus query data associated with malicious operations such as query spam.
- a user may submit multiple related queries to the search engine
- the user may first submit a query "French restaurant, Palo Alto, CA", looking for information about French restaurants in Palo Alto, California. Subsequently, the same user may submit a new query "Italian restaurant, Palo Alto, CA", looking for information about Italian restaurants in Palo Alto, California. These two queries are logically related since they both concern a search for restaurants in Palo Alto, California. This relationship may be demonstrated by the fact that the two queries are submitted closely in time or the two queries share some query terms (e.g., "restaurant” and "Palo Alto").
- these related queries are grouped together into a query session to characterize a user's search activities more accurately.
- a query session is comprised of a one or more queries from a single user, including either all queries submitted over a short period of time (e.g., ten minutes), or a sequence of queries having overlapping or shared query terms that may extend over a somewhat longer period of time (e.g., queries submitted by a single user over a period of up to two hours). Queries that concerning different topics or interests are assigned to different sessions, unless the queries are submitted in very close succession and are not otherwise assigned to a session that includes other similar queries.
- a query session extraction process 114 is invoked to classify the individual query records into different query session records 116.
- a query session record includes queries closely spaced in time and/or queries that are related to the same user interest.
- the query session extraction process is based on heuristics.
- FIG. 2B depicts one data structure 220 for storing a session record. Since the query records with the session record belong to the same user, they must have the same cookie, which is used here as a proxy for the user's identifier, as well as the same IP address. Each query record includes one or more query terms and a timestamp. In some embodiments, a query record 220 also includes a language identifier.
- Figure 2C illustrates an alternative data structure 230 for storing the session record.
- the timestamps associated with the query records in the session record are translated into certain temporal values (e.g., day, week, month, and year) and the IP addresses are converted into certain geographical values (e.g., city, region, and country).
- the query record 230 may also include a language value (e.g., English, French, Spanish, etc.).
- the temporal values are represented in the form of absolute values that represent the interval from a predefined moment in the history, e.g., January 1, 2000, to the time represented by the query record's timestamp. For example, the month value "75" corresponds to March, 2006.
- This absolute expression is convenient for data aggregation operations, and facilitates the aggregation of information from session records for particular days, weeks, months or years.
- the temporal values for each session record are determined in accordance with the timestamp for the first query in the session. In other embodiments the timestamp of the last query in the session or an average of the timestamps in the session are used to determine the temporal values.
- a temporal or geographical value also includes a corresponding parameter name, and thus is represented as a name-value pair.
- This type of expression can be easily distinguishable from regular query terms like "London” or "2005”.
- this name plus value expression corresponds to a single token in the lexicon of the log records database and the token is different from the tokens corresponding to the query terms "London” and "2005”. Therefore, the database of logs records can be searched for instances of a single token in order to identify session records having a particular temporal parameter value or a particular geographic parameter value.
- each of the queries in the session record is separated from the others by a query boundary marker, such as ⁇ q>.
- a query boundary marker such as ⁇ q>.
- a set of session records can be searched either (A) for all sessions that contain a user-specified Boolean combination of query terms (e.g., "Paris” and "restaurants"), or (B) for all sessions that contain at least one query that contains a user- specified Boolean combination of query terms.
- the first exemplary request ignores the query boundary markers in the session records, while the second request only matches sessions that have query terms, not separated by any query boundary markers, which satisfy the user- specified Boolean combination of query terms.
- a query session partition process 118 ( Figure 1) is employed to divide the query session records into many database partitions 120, each database partition corresponding to a portion of the session records.
- the query session records 116 are divided or distributed into L partitions 122.
- Each partition of session records is assigned to a respective computer server.
- the session records constituting the partition are randomly chosen from the query session records 116 by the query session partition process 118.
- the users identified in the query log entries are randomly assigned to the L partitions, and then all the query session records of the users are distributed to the partitions to which the corresponding users have been assigned.
- the query session extraction process 114 is a heuristic procedure. It does not guarantee that all the queries corresponding to one user interest always fall into the same session. For example, the user may submit one iPod-related query in Day One followed by some other queries unrelated to iPods, and then another iPod- related query in Day Two. In this case, the two iPod-related queries will be assigned to two different query sessions, and the aforementioned approach of calculating the query session- based percentage would count both query sessions.
- a partition sorting process 124 sorts the query sessions within a database partition by users. As a result, each partition 122 of session records in the database 120 becomes a sorted partition 128 in the database 126.
- the query sessions associated with one particular user are grouped together as one contiguous set. Different sets associated with different users are arranged in a random order such that any portion of the sorted partition does not have any biased data distribution. Similarly, the query sessions associated with each respective user are also arranged in a random order for similar purposes.
- FIG. 3 is a block diagram of an exemplary information service 300.
- the information service 300 generates statistics about one or more query terms in response to a query string containing the query terms.
- the information service 300 includes a query session processing system 320 and a statistics query processing system 340.
- the query session processing system 320 generally includes one or more database partitions 302 of sorted session records, a lexicon builder 306, an encoding/decoding system 304 and a tokenspace repository 310 containing tokenized session records.
- the encoding/decoding system 304 retrieves session records from the one or more database partitions 302, parses the session records into tokens, encodes the tokens into a compressed format using the lexicon mappings 308 from the lexicon builder 306, and then stores the encoded tokens into the tokenspace repository 310.
- the lexicon builder 306 generates the lexicon mappings 308 used for encoding a set of query session records by parsing the query session records.
- a "token" can be any object typically found in a query session record, including but not limited to terms, phrases, temporal values, geographical values, language value and the like.
- a set of query session records is represented as a sequence of tokens. In some embodiments, every token has the same fixed size (e.g., 32 bits).
- each token in the sequence of tokens has a token position in the tokenspace repository 310. The token position of a token also represents the position of the token in the set of query session records.
- the first token in the set of query session records may be assigned a position of 0
- the second token in the set of query session records may be assigned a position of 1 , and so on. It is noted that in some implementations, a completely different set of computer servers are used for encoding query session records than the computer servers used for decoding query session records.
- the statistics query processing system 340 includes one or more query log servers 312 coupled to the encoding/decoding system 304 and a tokenspace inverse index 314.
- the tokenspace inverse index 314 maps all the tokenIDs in the set of query session records to their positions within the tokenspace repository 310 (which contains the query session records).
- the inverse index 314 contains a list of token positions for each tokenID.
- the list of token positions for each tokenID may be encoded so as to reduce the amount of space occupied by the inverse index 314.
- the query log servers 312 parse a statistics query into multiple query terms that are transformed by the query log servers 312 into a query expression (e.g., Boolean tree expression).
- a lookup operation is performed so as retrieve from the tokenspace inverse index 314 the token positions in the tokenspace repository 310 of the query terms, as described below in connection with Figure 5 A.
- the query log servers 312 use the token positions to retrieve relevant tokenized query session records from the tokenspace repository 310, perform data aggregation operations on the retrieved query session records, and return statistical information based on the data aggregation operations as the query result.
- FIG. 4 A depicts an exemplary data structure 410 for storing the tokenized query session records associated with different users within a database partition M, each query session record having a unique session ID (sometimes called a Doc ID).
- a unique session ID sometimes called a Doc ID
- integer numbers starting from zero are used as the session IDs. Therefore, the session ID of a particular session record also indicates the number of query session records preceding it in the database partition.
- the query session records are sorted by user such that the query session records associated with one user have continuous session IDs.
- the first (A+l) query session records correspond to a first user having a unique ID "UserO”
- the next (B-A) query session records correspond to a second user having an ID "Userl”
- the last (Z-Y) query session records correspond to the last user having an ID "UserL”.
- integer numbers starting from zero are also used for representing user IDs.
- the user ID associated with a particular session record also indicates the number of users corresponding to the query sessions preceding the current one. As will be explained below, this naming convention makes it easier to normalize data aggregation results.
- Figure 4B is a data structure 420 for storing an individual tokenized session record in the data structure 410 of Figure 4A.
- This data structure has the same set of components as the data structure 230 of Figure 2C except that every component in the data structure 230 has been encoded (tokenized) to occupy less space.
- FIGS. 5A-5C are block diagrams illustrating an exemplary process of generating statistical information in response to a statistics query.
- FIG. 5 A is a block diagram of an embodiment of the first stage of the exemplary process with a tokenspace repository.
- the process involves a lexicon 502, a tokenspace inverse index 506, and a tokenID to index record map 504.
- Query terms or strings are received by the lexicon 502 that translates the query terms into tokenIDs using a translation table or mapping built from entries of the lexicon 502.
- a map 504 then maps the tokenIDs to index records stored in the inverse index 508.
- Each index record identified using the map 504 contains a list of token positions, which directly correspond to token positions in the tokenspace repository 310.
- the token positions in the tokenspace inverse index 506 refer to the exact locations of the query terms in different tokenized query session records in the tokenspace repository 310.
- the query log servers 312 need to identify the starting position of the query session record in the tokenspace repository 310.
- Figure 5B is a data structure for storing a two-way look-up map 508 between the session IDs of the query session records in the tokenspace repository and the starting positions of the query session records in the repository.
- Each entry in the two-way look-up map 508 includes a session ID and a starting repository position for the corresponding query session record.
- the last token in any query session record is the position immediately prior to the starting position identified by the next entry in the look-up map 508.
- FIG. 113 a lookup of the map 508 indicates that this position value is greater than the starting position of SessionM and smaller than the starting position of SessionM+1. Therefore, the query session record SessionM must contain the query term "iPod".
- One of the query log servers 312 visits the data structure 410 of Figure 4A to retrieve the tokenized session record for SessionM and aggregates the parameter value of the retrieve session record.
- Figure 5C is a data structure for storing a two-way look-up map 510 between the user IDs and the starting session IDs of the corresponding users. Each entry in the two- way look-up map 510 includes a user ID and a starting session ID for the corresponding user.
- the session ID of the last session record of any user is the value immediately prior to the starting session ID of the next entry in the look-up map 510.
- the starting session ID of the user "UserO" in Figure 4A is 0, the starting session ID of the user "Userl” is A+l, and the starting session ID of the user “UserL” is Y+l.
- a query log server After aggregating one session record associated with a particular user, a query log server must skip the remaining query sessions associated with the same user and move to the matching session record associated with the next user.
- the list of repository positions matching the query term "iPod" identified in the inverse index 506 includes 113, 134, 153, and 178, and they are found in the query sessions M, M+2, M+6, and M+8, respectively.
- the first instance of the query term "iPod" is in the query session M
- the second instance is in the session M+2
- the third instance is in the query session M+6,
- the forth instance is in the query session M+8.
- the query log server first aggregates the query session M. Since the ID of session M is larger than that of session M-2 and smaller than that of session M+7, session M belongs to user A. By the same token, both sessions M+2 and M+6 belong to user A. Therefore, after aggregating session M, the query log server skips the other two instances of the term "iPod" in the sessions M+2 and M+6 since they are associated with the same user A.
- the next query session visited by the query log server is the query session M+8, which belongs to a different user having a user ID "A+l".
- the user ID "A+l" also indicates the total number of users that have been scanned for the current data aggregation result. As will be explained below in connection with Figure 8, this value can be used to normalize the data aggregation result.
- each partition is assigned to a respective query log server.
- a small number of partitions e.g., two, three or four, may be assigned to the same query log server.
- each partition may be treated as a distinct entity executing on a distinct query log server.
- the query log servers are arranged in a hierarchical structure (e.g., tree).
- Figure 6 is a block diagram of such an exemplary hierarchical structure in accordance with some embodiments of the present invention.
- the query log servers 312 are coupled to a frontend server 602.
- the frontend server 602 is coupled to a news backend server 620.
- the news backend server 620 is responsible for generating news-related statistical information responsive to a statistics query. For example, given a statistics query that contains only one query term, "iPod", the news backend server 620 counts the number of occurrences of the term within a particular week's news coverage.
- the news backend server selects a piece of news from a credible news source as the representative news item or story of that week.
- the "most representative headline” may be defined as the headline whose terms appear most frequently among all the matching news items (i.e., news items matching the statistics query) during that week.
- the frontend server 602 is responsible for initially parsing the statistics query and is also responsible for preparing query results (e.g., generating images and HTML files, etc.) based on the query results generated by the news backend server 620 and the query log servers 312, respectively.
- query results e.g., generating images and HTML files, etc.
- the root query server 604 is responsible for generating a set of sub-queries in response to a statistics query, identifying a subset of intermediate query servers 606 for a selected subset of sub-queries, distributing the selected sub-queries to the identified intermediate query servers 606, and aggregating the query results returned by different intermediate query servers 606.
- An intermediate query server 606 is responsible for identifying a respective subset of leaf query servers 608 for each sub-query, distributing the sub-query to the leaf query servers, and aggregating the query results returned by different leaf query servers 606.
- a leaf query server 608 is responsible for aggregating data or information from its associated partition of sorted query session records 610 in accordance with the sub-query assigned to the leaf query server.
- a more detailed description of the data aggregation process is provided below in connection with Figure 8.
- the number of layers in the hierarchical structure may depend on the volume of query session records in the database. The example shown in Figure 6 is only for illustrative purposes. In some embodiments, if the volume of the query session records is limited, the intermediate layer of query servers 606 is not necessary. In these embodiments, the root query server 604 is directly responsible for distributing sub-queries to different leaf query servers 608 and aggregating their query results accordingly.
- more intermediate layers of query servers 606 may be necessary to process a large volume of query session records.
- a specific hierarchical structure design is chosen to maximize the system's throughput.
- the exemplary embodiment will be assumed to have 1024 database partitions, each of which contains data for at least one million query sessions. Thus, when a sub-query is executed against 25 database partitions, about 2.5 percent of the database is being sampled by the execution of that sub-query.
- the number of leaf query servers 108 may be the same as the number of database partitions, in some embodiments, some or all of the leaf query servers 608 service two or more (e.g., two to four) database partitions.
- the entire volume of query session records are broken into L partitions.
- the value "L" is also the number of leaf query servers in the hierarchical structure.
- Query session records are randomly assigned to the leaf query servers.
- the query session records at a particular leaf query server are sorted by their respective users, but are otherwise distributed randomly. For example, one set of session records associated with a user from the United States may be preceded by a set of session records associated with a user from Germany and followed by another set of session records associated with a user from India.
- the session records associated with a particular user are also distributed randomly according to the same or similar principle.
- each database partition Due to the random distribution of query records among the database partitions, and the fact that each database partition contains millions of query session records, each database partition has coverage of representative query sessions very similar to that of the entire database.
- a statistical estimate based on a subset (e.g., one, or a few) of the database partitions is often sufficiently close to a statistical estimate based on all the database partitions. In other words, there is no need to invoke all the leaf query servers for every single statistical query. This can significantly boost the query processing system's throughput.
- an estimate based on too few data samples is not a reliable approximate of an estimate based on the entire database. There must be a sufficient number of data samples to ensure the reliability of an estimate based on a subset of a database, and also to ensure that reported statistics cannot be traced back to individual users or even to small groups of such users.
- Figure 13 is a diagram of a bell-shaped curve 1300 representing the probability density of a random variable X having a normal distribution.
- the value ⁇ in the middle corresponds to the mean of all the data samples within a dataset of the random variable X and the value ⁇ represents the standard deviation of the dataset. If the random variable X takes on data values ⁇ xi, X 2 , ..., X N ⁇ , below are the respective definitions of the mean ⁇ and the standard deviation ⁇ ,
- the distribution of millions of session records and their associated users within a database partition can be approximated by a normal distribution.
- the formula above can be used to provide guidance with respect to the number of users required to produce a reliable statistical estimate.
- a leaf query server may need to scan through tens of thousands of session records until a predetermined number of queries containing the specific term are found. In some embodiments, this predetermined number is one thousand, two thousand, or a number larger than two thousand (e.g., at least 2,500 positive samples).
- the magnitude of the predetermined number is, at least in part, dependent upon the ratio of the sub-sampled query log versus the entire query log and their absolute sizes. There are many known statistical theories on how to determine the number of data samples for given reliability requirements.
- the first operation is to search a selected subset of the database partitions for matching query sessions.
- the second operation is to search additional database partitions (by employing additional leaf query servers) to conduct a new search if the first search operation fails to return at least the predetermined number of matching query session records. Therefore, the first operation is always required and the second operation is conditional.
- the root query server first receives a statistics query from a requestor (702).
- the query may include one or more query terms. These query terms are combined together using one or more Boolean operators such as AND, OR, etc.
- the root query server generates a list of sub-queries based on the statistical query (704). For example, given the statistical query having only one term "iPod", the root query server may generate a series of sub-queries for a predetermined period of time, each sub-query for determining the percentage of users having submitted at least one iPod-related query in a given week. Similarly, the root query server may also generate sub-queries to determine the percentage of users having submitted at least one iPod-related query from a set of distinct locations, or using a set of distinct languages.
- the root query server (or the root query server in conjunction with one or more of intermediate query servers) identifies a subset of the database partitions, and their corresponding leaf query servers, for each sub-query (706). In doing so, the root query server checks the workload and free resources available at different leaf query servers and then selects one or more database partitions against which to execute the sub-query to achieve an overall load balance. Since there may be multiple leaf query servers executing the same sub- query, each leaf query server is only responsible for identifying a fraction of the predetermined number of matching query sessions.
- each corresponding leaf query server only needs to identify 100 instances of matching query session records within each of its selected database partitions.
- each leaf query server may be asked to identify up to N instances of matching query session records in each of its selected database partitions, where N is larger (e.g., 10 percent to 100 percent larger) than the predefined number divided by the number of database partitions being queried.
- the sub-queries are executed by their respective subsets of leaf query servers (708). A more detailed description of this sub-operation is provided below in connection with Figure 8.
- a selected subset of leaf query servers return their query results to the root query server.
- the root query server then aggregates these query results and checks if the aggregated query result has met some predetermined requirements (710). There are two possible outcomes for the aggregated query result. If the leaf query servers have found their shares of matching query session records in their database partitions, the aggregated query result is deemed as a reliable approximation of the query result derived from the entire database. In this event, Step Two is skipped.
- the root query server checks if all sub-queries have been executed (724). If not, the root query server returns to operation 708 and asks the leaf query servers execute another sub-query. In some embodiments, operation 708 launches all of the identified sub-queries prior to receiving the results for any of these sub-queries. In these embodiments, the loop control operation 720 is not needed.
- the root query server identifies a second subset of additional database partitions and their corresponding leaf query servers (712). For example, if the average number of matching query sessions identified in the initially selected 25 database partitions is only 50 (for a total of approximately 1250 matching query session records), the root query server identify at least another 25 database partitions on which to execute the same sub-query. In some embodiments, the root query server may identify more than 25 (e.g., 30) database partitions (and their leaf query servers) to make sure that a sufficient number of matching query sessions are found. Next, the newly-selected leaf query servers execute the same sub-query against their associated database partitions (714).
- the root query server checks if the aggregated query result has met the predetermined requirements (716). If the number of matching query sessions is still below the predetermined number (716, No) and the root query server predicts that there is not sufficient data in the entire database (718), the root query server makes a mark in an entry in the query result corresponding to the sub-query.
- the frontend server upon receiving the query result, can use other measures (e.g., data interpolation) to fix the missing entry, or it may omit the query result corresponding to the sub-query that returned an insufficient number of results. After executing all the sub-queries (720, Yes), the root query server normalizes the aggregated query results (722) and returns them to the requestor through the frontend server (724).
- FIG. 8 is a flowchart illustrating how a leaf query server executes a sub- query in accordance with some embodiments of the present invention.
- a query distributor e.g., the root query server
- the leaf query server Upon receipt of a sub- query from a query distributor (e.g., the root query server), the leaf query server visits the tokenspace inverse index 314 and identifies a list of repository positions for the sub-query (804). If the sub-query is a Boolean expression including more than one query term, the leaf query server identifies the repository position lists corresponding to different query terms and then generates a list of query sessions that satisfy the Boolean expression.
- the list of repository positions for any given query term corresponds to the locations of the query term(s) in the matching query session records.
- the leaf query server consults the two look-up maps (mapping repository positions to session IDs, and mapping session IDs to user IDs) discussed above with reference to Figures 5B and 5C.
- the leaf query server must access the query session records themselves in order to aggregate their parameter values (e.g., time, location and language).
- the leaf query server identifies the value of the session parameter (e.g., city) and adds a count to a corresponding counter.
- each leaf query server is responsible for identifying a predetermined number of matching query sessions in corresponding database partition. As noted above, this predetermined number is typically a fraction of the number for the entire database. Every time the leaf query server finds a matching query session, it needs to check if the current count of matching query sessions has met the predetermined number (811). If so, the leaf query server does not have to proceed to a subsequent repository position in the list. Rather, the leaf query server moves to determine the total number of users that have been scanned (816). Otherwise, the aggregation moves onto the next repository position in the list (814).
- the leaf query server After finishing the data aggregation operation, the leaf query server checks if the current repository position is the last one in the list (812). If not, the leaf query server proceeds to a subsequent repository position in the list (814). Note that if the leaf query server generates user-based query results, the next repository position that matches the sub- query may not be the correct one since it may be associated with the same session (e.g., one query session record may include multiple instances of the query term like "iPod") or a different session that corresponds to the same user. Therefore, the leaf query server must find the first repository position corresponding to a different user than the previously processed session record.
- the leaf query server finds an entry including the next user in the look-up map 510.
- the same entry also includes the starting session ID corresponding to the next user.
- the leaf query server visits the look-up map 508 to identify the starting repository position corresponding to the starting session ID. Based on this starting repository position, the leaf query server then examines its list of repository positions to find the first repository position in the list of query-matching repository positions that is beyond that starting position.
- operation 804 may identify a list of sessions that match the sub- query, and operations 806 and 808 utilize the identified list of matching sessions.
- the leaf query server determines the total number of users that have been scanned in the database partition (816). This sub-operation also involves the two look-up maps 508 and 510. The leaf query server first checks the look-up map 508 to find the session ID whose record contains the last repository position in the list. From the session ID, the leaf query server finds the corresponding user ID in the look-up map 510. The user ID associated with the smaller starting session ID corresponds to the total number of users that have been scanned in the database partition. Finally, the leaf query server normalizes the query result using the total number of scanned users and returns the normalized query result to the query distributor (818).
- the root query server In order to find the popularity of the query term "iPod" in different weeks, the root query server generates at least two sub-queries for each particular week.
- the leaf query server may stop short of determining the total number of users who have submitted at least one iPod-related query during the week "xyz”. Rather, the leaf query server may stop its search when it finds a predetermined number of such users (e.g., 100 if 25 database partitions are being searched). But in order to find the 100 users, the leaf query server must scan a larger number of users, i.e., the total number of scanned users determined at sub-operation 816. If the query is very popular, the leaf query server may not need to scan too many users to reach the goal of 100. But if the query is not popular, the leaf query server must scan a substantial number of users to reach the goal of 100.
- the total number of scanned users for each sub-query indicates the popularity of the sub-query. A higher total number of scanned users correspond to a less popular sub-query. [0082] Therefore, the number corresponding to the query N("iPod", “WEEK-xyz”) should be expressed in a normalized fashion as
- N("iPod",'WEEK , where Cp rede termin ed _N umber corresponds to the predetermined number of matching query session records the leaf query server was asked to find and C ⁇ o tai_users_scanne d represents the total number of users that the leaf query server has scanned in order to reach the predetermined number of matching query sessions.
- the two normalizations are merged into one sub-operation 722 of Figure 7.
- the leaf query server returns the total number of scanned users for each individual sub-query at operation 818 of Figure 8.
- the execution of one statistics query as described above in connection with Figure 7 may bring forward a set of subsequent candidate statistics queries.
- a user when a user submits a statistics query for the term "iPod", besides the term's popularity over time, the user may be interested in learning the top 10 cities that have the largest number of users submitting at least one iPod-related query. But this information cannot be generated during the first pass of executing the statistics query for "iPod” because there could be thousands of cities having at least one user submitting an iPod-related query. This list of cities is unknown at the time of executing the query for "iPod”. Even if this list is known, it would not be practical for the root query server to generate even hundreds of sub- queries in order to identify and generate statistics for the top 10 cities. This massive number of sub-queries would adversely affect the throughput of the query log servers.
- Figure 9 is a flowchart illustrating a two-pass process of identifying the top N candidates without generating a large number of sub-queries.
- the first pass of the process includes three operations 902, 904, and 906.
- Operation 902 is similar to the process shown in Figure 7.
- the root query server executes a statistics query at a selected subset of leaf query servers (i.e., against a selected subset of the database partitions). For example, the statistics query has only one query term "iPod".
- the leaf query servers identify the users having at least one iPod-related query and aggregate the user by their associated cities, regions, countries and languages.
- the root query server selects from the aggregated query results a subset of parameter values meeting predefined criteria (904).
- the root query server selects the top 25 cities, regions, countries and/or languages based on the aggregated query results. Since a database partition is like a smaller version of the entire database, it is very likely that the top 25 candidates identified by the leaf query servers encompass the top 10 candidates, although the candidates' order may not be exactly the same. For each of the top 25 candidates in different categories, the root query server generates a new subsequent statistics query (906). The first pass of the process is also referred as the discovery pass. Its goal is to reduce the number of candidates from several thousand to a few dozen by performing a "discovery" search of a small subset of the database partitions.
- the second pass of the process is referred to as the refinement pass.
- the root query server From the query results of the discovery pass, the root query server not only has a list of candidates for each parameter category, but also has reasonable estimates of the densities of query session records containing the different candidates.
- the root query server For each subsequent statistics query, the root query server identifies (i.e., selects) a respective subset of database partitions (and their corresponding leaf query servers) (908).
- the number of the database partitions depends on the density estimate associated with the subsequent query. A query having a lower density estimate needs to be executed against more database partitions to find the predetermined number of matching query session records.
- the root query server executes each of the subsequent queries at the corresponding subset of leaf query servers against the identified database partitions (910).
- the root query returns the query results associated with the subsequent queries to the requestor (912). Since the second pass has found a sufficient number of matching records for each query, the query result generated at the second pass is more reliable than that of the first pass. But the first pass substantially reduces the number of candidates and makes it possible to execute the second pass efficiently.
- Figure 10 is an exemplary screenshot of a webpage containing statistics about users related to a particular query term "iPod".
- the webpage includes various types of statistical information. It takes less than a second for the statistical query processing system to generate this webpage.
- the curve 1002 represents the popularity of the term "iPod" over a time period of more than two years. Each data point on the curve 1002 corresponds to a ratio between the number of users that have submitted at least one iPod-related query during a particular week and the number of users that have submitted any query during that week. The curve 1002 has both peaks and troughs suggesting that the term's popularity indeed varies with time. [0088] Below the curve 1002 is another curve 1004. This curve represents the volume of news coverage of iPod during the same time period. Each data point on the curve 1004 represents the number of occurrences of the term "iPod" in that week's news coverage.
- the spikes on the curve 1004 indicate increases in news coverage concerning the iPod product during that week.
- the frontend server selects the weeks corresponding to six spikes on the curve 1004 and marks the corresponding weeks on the curve 1002 using labels A-F.
- the label C indicates that the increase in iPod-related queries is in synch with the news coverage spike.
- the representative news during that week is that Apple releases its new generation of product, iPod Nano and iPod phone.
- FIG. 10 On the top-right corner of the screenshot are two dropdown lists, 1016 for date sub-ranges (labelled "years") and 1018 for countries.
- a user can request that the prior inquiry be re-executed for a particular month, in which case a new webpage is provided that reflects statistics based on the query session records for that month, as shown in Figure 1OB.
- a user request that the prior inquiry be re-executed for a particular country, in which case a new webpage is provided that reflects statistics based on the query session records for that country, as shown in Figure 1OC.
- Figure 1 IA is a block diagram of an exemplary query distribution and aggregation server (e.g., a root query server or intermediate query server) 1100 in accordance with some embodiments of the present invention, which typically includes one or more processing units (CPU's) 1102, one or more network or other communications interfaces 1104, memory 1110, and one or more communication buses 1112 for interconnecting these components.
- Memory 1 110 may include high speed random access memory and may also include non-volatile memory, such as one or more magnetic disk storage devices.
- Memory 1110 preferably stores the following programs, modules and data structures, or a subset or superset thereof: • an operating system 1114 that includes procedures for handling various basic system services and for performing hardware dependent tasks;
- a network communication module (or instructions) 1116 that is used for connecting the query server 1100 to other computers via the one or more communication network interfaces 1104; • a sub-query distributor 1118 for assigning a sub-query to a selected subset of database partitions and their corresponding leaf query servers;
- a sub-query generator 1122 for generating a set of sub-queries for a statistics query
- a load balance analyzer 1126 for analyzing the workload at different leaf query servers and selecting a subset of the leaf query servers based upon their workload.
- FIG. 1 IB is a block diagram of an exemplary leaf query server 1150 in accordance with some embodiments of the present invention, which typically includes one or more processing units (CPU's) 1152, one or more network or other communications interfaces 1154, memory 1160, and one or more communication buses 1162 for interconnecting these components.
- Memory 1160 may include high speed random access memory and may also include non-volatile memory, such as one or more magnetic disk storage devices.
- Memory 1160 preferably stores the following programs, modules and data structures, or a subset or superset thereof:
- an operating system 1164 that includes procedures for handling various basic system services and for performing hardware dependent tasks
- a network communication module (or instructions) 1166 that is used for connecting the query server 1100 to other computers via the one or more communication network interfaces 1104;
- a sub-query executor 1168 for executing a sub-query against a database partition
- one or more database partitions 1170 each of which may include a token repository
- an inverse index 1174 a session ID range map (session ID to token position map) 1176, and a user ID range map (user ID to session ID map) 1178.
- Figure 12 is a block diagram of an exemplary query session partition server
- Memory 1210 may include high speed random access memory and may also include non-volatile memory, such as one or more magnetic disk storage devices. Memory 1210 preferably stores the following programs, modules and data structures, or a subset or superset thereof:
- an operating system 1214 that includes procedures for handling various basic system services and for performing hardware dependent tasks;
- a network communication module (or instructions) 1216 that is used for connecting the partition server 1200 to other computers via the one or more communication network interfaces 1204;
- a query session extractor 1220 for grouping different query records into different query sessions in accordance with predefined criteria
- a query session sorter 1224 for sorting the query session records within a partition by their associated users
Abstract
A computer-implemented method includes calculating first statistics about a user- identified event within a first subset of a database of events; selecting a second subset of the database of events based on said first statistics; calculating second statistics about the user- identified event within the second subset of the database of events; merging the first and second statistics as statistics of the user-identified event within the entire database of events; and generating a result including at least a portion of the merged statistics of the user- identified event.
Description
Systems and Methods for Generating Statistics from Search Engine Query Logs
RELATED APPLICATIONS
[0001] This application claims priority to U.S. Provisional Application Serial No. 60/746,886, filed May 9, 2006, and U.S. Patent Application Serial No. 11/746,049, filed May 8, 2007, which is incorporated herein by reference in its entirety.
FIELD OF THE INVENTION
[0002] The present invention relates generally to search engine and in particular to systems and methods for generating statistics from search engine query logs.
BACKGROUND OF THE INVENTION
[0003] Data aggregation is a process in which information is gathered and expressed in a summary form for purposes such as statistical data analysis. It often reveals useful information hidden in a large volume of original data records. For example, from a database containing millions of sales records generated by an on-line store, a marketing analyst can learn information about a particular group of consumers such as trends and patterns in their shopping habits by aggregating the related sales records based on specific variables such as product type information, product pricing information, customer age, customer gender, geographic location (e.g., store location or purchaser's address) and any other customer and/or product information available in the database. [0004] As another example, a web search engine may receive millions of queries per day from users around the world. For each query, the search engine generates a query record in its query log. The query record may include one or more query terms, a timestamp indicating when the query is received by the search engine, an IP address identifying a unique device (e.g., a PC or a cell phone) from which the query terms are submitted, and an identifier associated with a user who submits the query terms (e.g., a user identifier in a web browser cookie; in some cases the user identifier may also be associated with a toolbar or other application or service to which the user has subscribed). Appropriate aggregation of these query records can also unveil interesting or useful information about the web search engine users. For instance, a publisher can gauge the popularity of a newly released book in
a specific city from the frequencies of relevant queries submitted by users from that city within a given time period.
[0005] For the same query log, social scientists, marketers, and politicians may have dramatically different interests and therefore require different types of data aggregations to meet their needs. Some types of "data mining" of a search engine's log records may be useful only if the statistical inquiries receive substantially instantaneous responses (e.g., in less than five seconds). But most of the conventional data aggregation techniques are incapable of deriving reliable statistical information from a large number of query records substantially instantaneously. [0006] Another concern with data mining search engine query logs or commercial transaction logs is the protection of user privacy. Even if the log records do not contain user names or the like, returning statistical information or trends information based on very small numbers of users or transactions (e.g., less than twenty transactions) may inadvertently disclose information that can be traced back to an individuals or small groups of users (e.g., fewer than a predefined number of distinct users, such as twenty, one hundred or two hundred distinct users). It is therefore important that any log record data mining tool include safeguards for preventing the disclosure of information that may be traced back to individuals or small groups of users.
SUMMARY
[0007] In a first aspect of the present invention, a computer-implemented method comprises calculating first statistics about a user-identified event within a first subset of a database of events; selecting a second subset of the database of events based on said first statistics; calculating second statistics about the user-identified event within the second subset of the database of events; merging the first and second statistics as statistics of the user- identified event within the entire database of events; and generating a result including at least a portion of the merged statistics of the user-identified event.
[0008] In a second aspect of the present invention, a computer-implemented method comprises identifying in an inverse index file a sequence of positions associated with an indexed item, wherein the sequence of positions corresponds to a set of events from a sequence of randomly-arranged events, each event including at least one occurrence of the indexed item and having a respective sequence number; selecting in the sequence of randomly-arranged events an event corresponding to a predefined position in the sequence of
positions and its sequence number; determining a number of positions in the sequence of positions that precede the predefined position; and determining an occurrence frequency for the indexed item in the sequence of randomly-arranged events using the selected event's sequence number and the determined number of positions.
BRIEF DESCRIPTION OF THE DRAWINGS
[0009] The aforementioned features and advantages of the invention as well as additional features and advantages thereof will be more clearly understood hereinafter as a result of a detailed description of preferred embodiments of the invention when taken in conjunction with the drawings. [0010] Figure 1 is a flowchart illustrating a process of converting a query log into multiple sorted partitions of session records in accordance with some embodiments of the present invention.
[0011] Figure 2A is a block diagram of a data structure for storing a query log in accordance with some embodiments of the present invention. [0012] Figure 2B is a block diagram of a data structure for storing a query session record in accordance with some embodiments of the present invention.
[0013] Figure 2C is a block diagram of an alternative data structure for storing the query session record in accordance with some embodiments of the present invention.
[0014] Figure 3 is a block diagram of an exemplary information service that generates statistics in response to a query in accordance with some embodiments of the present invention.
[0015] Figure 4A is a block diagram of a data structure for storing tokenized session records within a database partition in accordance with some embodiments of the present invention. [0016] Figure 4B is a block diagram of a data structure for storing a tokenized session record in accordance with some embodiments of the present invention.
[0017] Figure 5A is a flow diagram of a process of identifying a list of repository positions in response to one or more query terms in accordance with some embodiments of the present invention.
[0018] Figure 5B is a block diagram of a data structure for translating or mapping repository positions to session record identifiers and vice versa in accordance with some embodiments of the present invention.
[0019] Figure 5C is a block diagram of a data structure for translating or mapping session record identifiers to user identifiers and vice versa in accordance with some embodiments of the present invention.
[0020] Figure 6 is a block diagram of an exemplary hierarchical structure of multiple query servers in accordance with some embodiments of the present invention.
[0021] Figure 7 is a flowchart illustrating a process of generating statistics from session records in response to a statistics query in accordance with some embodiments of the present invention.
[0022] Figure 8 is a flowchart illustrating a process of executing a statistics sub-query at a leaf query server in accordance with some embodiments of the present invention.
[0023] Figure 9 is a flowchart illustrating a two-pass or multi-pass process of generating statistics related to a specific parameter of the session records in accordance with some embodiments of the present invention.
[0024] Figures 1OA, 1OB and 1OC are exemplary screenshots of webpages containing trends statistics and geographical distribution statistics for queries concerning a particular query term in accordance with some embodiments of the present invention. [0025] Figure 1 IA is a block diagram of an exemplary query distribution and aggregation server in accordance with some embodiments of the present invention.
[0026] Figure 1 IB is a block diagram of an exemplary leaf query server in accordance with some embodiments of the present invention.
[0027] Figure 12 is a block diagram of an exemplary partition server in accordance with some embodiments of the present invention.
[0028] Figure 13 is a diagram of a bell-shaped curve representing a normal distribution of random data samples.
[0029] Like reference numerals refer to corresponding parts throughout the several views of the drawings.
DESCRIPTION OF EMBODIMENTS
[0030] In order to generate statistics from a large database efficiently, some data preprocessing operations may be necessary. Figure 1 is a flowchart illustrating such a data preprocessing procedure for converting a web search engine's query log into multiple sorted partitions of session records. Many users submit queries from clients 102 to a search engine 106 through a communication network 106 (e.g., the Internet). For each query, the search engine 106 generates a query record in a query log file 108. As shown in Figure 2 A, a query log 210 contains many query records. Each query record has multiple attributes, including one or more query terms of a search query, a timestamp, an IP address, and a web cookie or other user identifier. In some embodiments, each query record includes a language identifier, identifying the language associated with the search query. The timestamp indicates when the search query is received by the search engine, and the IP address maps to a unique device (e.g., a personal computer, cell phone, or other client device) from which the search query terms are submitted. In some embodiments, the web cookie uniquely identifies a user of the web search engine and therefore can be used as a proxy for the user's identifier. Alternately, each query log record contains a user identifier.
[0031] To get reliable statistical information from the query log 108, it is not always necessary to survey all the query records (also herein called log records or transaction records) in the query log. As long as the statistical information is derived from a sufficient number of samples in the query log, the information is as reliable as information derived from all the log records. Moreover, it takes less time and computer resources to survey a sub- sampled query log. Therefore, a query log sampling process 110 can be employed to sub- sample the query log 108 and produce a sub-sampled query log 112. For example, the sub- sampled query log 112 may contain ten percent or twenty percent of the log records in the original query log 108. Note that the sampling process is optional. In some embodiments, the entire query log 108 is used to generate statistical information.
[0032] The query log sampling process 110 may utilize any of a number of different random (or pseudo-random) sampling schemes to produce a sub-sampled, but diversified and robust, query log 112. In some embodiments, the query log sampling process 110 performs a uniform sub-sampling of the query log, e.g., selecting every fifth query record as the sub- sampled query log. In some other embodiments, the query log sampling process 110 first separates all the query records by their associated geographical regions (which are based on
the IP addresses associated with the records). For each geographical region, the query log sampling process 110 randomly selects a certain percentage of query records as the sub- sampled query log. This sampling scheme ensures that query records from different geographical regions are proportionally included in the sub-sampled query log, based on their ratios in the original query log. These sub-sampling schemes can be based other predefined criteria. There are also many other sampling schemes known to one skilled in the art that may be used here to produce the sub-sampled query log 112.
[0033] In some embodiments, the query log sampling process 110 implements a sampling strategy to achieve a sub-sampled query log 112 that satisfies one or more predefined diversity requirements. Exemplary requirements include limiting the number of query records in the query log 112 having a particular IP address for a given time period. These requirements can effectively increase the sub-sampled query log 112' s diversity and prevent the sub-sampled query log 112 from being corrupted by bogus query data associated with malicious operations such as query spam. [0034] Very often, a user may submit multiple related queries to the search engine
106 within a short timeframe in order to find information of interest. For example, the user may first submit a query "French restaurant, Palo Alto, CA", looking for information about French restaurants in Palo Alto, California. Subsequently, the same user may submit a new query "Italian restaurant, Palo Alto, CA", looking for information about Italian restaurants in Palo Alto, California. These two queries are logically related since they both concern a search for restaurants in Palo Alto, California. This relationship may be demonstrated by the fact that the two queries are submitted closely in time or the two queries share some query terms (e.g., "restaurant" and "Palo Alto").
[0035] In some embodiments, these related queries are grouped together into a query session to characterize a user's search activities more accurately. A query session is comprised of a one or more queries from a single user, including either all queries submitted over a short period of time (e.g., ten minutes), or a sequence of queries having overlapping or shared query terms that may extend over a somewhat longer period of time (e.g., queries submitted by a single user over a period of up to two hours). Queries that concerning different topics or interests are assigned to different sessions, unless the queries are submitted in very close succession and are not otherwise assigned to a session that includes other similar queries. The same user looking for Palo Alto restaurants may submit a query "iPod Video" later for information about the new product made by Apple Computer. This new
query is related to a different interest or topic that Palo Alto restaurants, and is therefore not grouped into the same session as the restaurant-related queries. Therefore the queries from a single user may be associated with multiple sessions. Two sessions associated with the same user will share the same cookie, but will have different session identifiers. [0036] As shown in Figure 1, a query session extraction process 114 is invoked to classify the individual query records into different query session records 116. A query session record includes queries closely spaced in time and/or queries that are related to the same user interest. In some embodiments, the query session extraction process is based on heuristics. For example, consecutive queries belong to the same session if they share some query terms or if they are submitted within a predefined time period (e.g., ten minutes) even though there is no common query term among them. Figure 2B depicts one data structure 220 for storing a session record. Since the query records with the session record belong to the same user, they must have the same cookie, which is used here as a proxy for the user's identifier, as well as the same IP address. Each query record includes one or more query terms and a timestamp. In some embodiments, a query record 220 also includes a language identifier.
[0037] Figure 2C illustrates an alternative data structure 230 for storing the session record. In this embodiment, the timestamps associated with the query records in the session record are translated into certain temporal values (e.g., day, week, month, and year) and the IP addresses are converted into certain geographical values (e.g., city, region, and country). The query record 230 may also include a language value (e.g., English, French, Spanish, etc.). In some embodiments, the temporal values are represented in the form of absolute values that represent the interval from a predefined moment in the history, e.g., January 1, 2000, to the time represented by the query record's timestamp. For example, the month value "75" corresponds to March, 2006. This absolute expression is convenient for data aggregation operations, and facilitates the aggregation of information from session records for particular days, weeks, months or years. In some embodiments, the temporal values for each session record are determined in accordance with the timestamp for the first query in the session. In other embodiments the timestamp of the last query in the session or an average of the timestamps in the session are used to determine the temporal values.
[0038] In some embodiments, a temporal or geographical value also includes a corresponding parameter name, and thus is represented as a name-value pair. For example, the city value of a session record is expressed as "CITY=London" and the year value is
expressed as "YEAR=2005". This type of expression can be easily distinguishable from regular query terms like "London" or "2005". As will be explained below, this name plus value expression corresponds to a single token in the lexicon of the log records database and the token is different from the tokens corresponding to the query terms "London" and "2005". Therefore, the database of logs records can be searched for instances of a single token in order to identify session records having a particular temporal parameter value or a particular geographic parameter value.
[0039] Another characteristic of the session record data structure 230 is that each of the queries in the session record is separated from the others by a query boundary marker, such as <q>. In this way, a set of session records can be searched either (A) for all sessions that contain a user-specified Boolean combination of query terms (e.g., "Paris" and "restaurants"), or (B) for all sessions that contain at least one query that contains a user- specified Boolean combination of query terms. The first exemplary request ignores the query boundary markers in the session records, while the second request only matches sessions that have query terms, not separated by any query boundary markers, which satisfy the user- specified Boolean combination of query terms.
[0040] In most cases, the number of query session records 116 is too large to be processed by a single computer server efficiently. Accordingly, a query session partition process 118 (Figure 1) is employed to divide the query session records into many database partitions 120, each database partition corresponding to a portion of the session records. In some embodiments, the query session records 116 are divided or distributed into L partitions 122. Each partition of session records is assigned to a respective computer server. In some embodiments, the session records constituting the partition are randomly chosen from the query session records 116 by the query session partition process 118. Alternately, the users identified in the query log entries are randomly assigned to the L partitions, and then all the query session records of the users are distributed to the partitions to which the corresponding users have been assigned.
[0041] In some embodiments, the data aggregation occurs at the query session record level. For example, in order to compute the percentage of query sessions containing the query term "iPod" among all query sessions associated with the city of London, a computer server only needs to check the inverse index to determine a first number of session records containing both the term "iPod" and the term "CITY=London" and a second number of session records containing the term "CITY=London". Dividing the first total number by the
second total number gives the percentage of the query sessions from London that contain the term "iPod". It may be noted that this percentage may be somewhat different from the percentage of users from London who have submitted at least one query having the term "iPod". [0042] The reason is because one London user may be associated with multiple query sessions including the term "iPod". As noted above, the query session extraction process 114 is a heuristic procedure. It does not guarantee that all the queries corresponding to one user interest always fall into the same session. For example, the user may submit one iPod-related query in Day One followed by some other queries unrelated to iPods, and then another iPod- related query in Day Two. In this case, the two iPod-related queries will be assigned to two different query sessions, and the aforementioned approach of calculating the query session- based percentage would count both query sessions.
[0043] In order to compute a user-based percentage, as opposed to a query session- based percentage, a partition sorting process 124 is required. The partition sorting process 124 sorts the query sessions within a database partition by users. As a result, each partition 122 of session records in the database 120 becomes a sorted partition 128 in the database 126. The query sessions associated with one particular user are grouped together as one contiguous set. Different sets associated with different users are arranged in a random order such that any portion of the sorted partition does not have any biased data distribution. Similarly, the query sessions associated with each respective user are also arranged in a random order for similar purposes. But since one user may have multiple query sessions matching the query term "iPod", having a total number of matching sessions from the inverse index is not enough to calculate the percentage of users who have submitted queries that include the term "iPod." Rather, it is necessary to access all the query session records in a sorted database partition 128 to avoid counting more than once for those users having more than one matching query session record. Although this percentage estimate is more computationally expensive, it is clearly a more accurate indication of a query term's popularity among users of the search engine. A more detailed description of the sorted session records within a partition is provided below in connection with Figure 4A. [0044] Figure 3 is a block diagram of an exemplary information service 300. The information service 300 generates statistics about one or more query terms in response to a query string containing the query terms. The information service 300 includes a query session processing system 320 and a statistics query processing system 340.
[0045] The query session processing system 320 generally includes one or more database partitions 302 of sorted session records, a lexicon builder 306, an encoding/decoding system 304 and a tokenspace repository 310 containing tokenized session records. The encoding/decoding system 304 retrieves session records from the one or more database partitions 302, parses the session records into tokens, encodes the tokens into a compressed format using the lexicon mappings 308 from the lexicon builder 306, and then stores the encoded tokens into the tokenspace repository 310. The lexicon builder 306 generates the lexicon mappings 308 used for encoding a set of query session records by parsing the query session records. [0046] A "token" can be any object typically found in a query session record, including but not limited to terms, phrases, temporal values, geographical values, language value and the like. After parsing, a set of query session records is represented as a sequence of tokens. In some embodiments, every token has the same fixed size (e.g., 32 bits). Furthermore, each token in the sequence of tokens has a token position in the tokenspace repository 310. The token position of a token also represents the position of the token in the set of query session records. For example, the first token in the set of query session records may be assigned a position of 0, the second token in the set of query session records may be assigned a position of 1 , and so on. It is noted that in some implementations, a completely different set of computer servers are used for encoding query session records than the computer servers used for decoding query session records.
[0047] The statistics query processing system 340 includes one or more query log servers 312 coupled to the encoding/decoding system 304 and a tokenspace inverse index 314. The tokenspace inverse index 314 maps all the tokenIDs in the set of query session records to their positions within the tokenspace repository 310 (which contains the query session records). Conceptually, the inverse index 314 contains a list of token positions for each tokenID. For efficiency, the list of token positions for each tokenID may be encoded so as to reduce the amount of space occupied by the inverse index 314.
[0048] In some embodiments, the query log servers 312 parse a statistics query into multiple query terms that are transformed by the query log servers 312 into a query expression (e.g., Boolean tree expression). A lookup operation is performed so as retrieve from the tokenspace inverse index 314 the token positions in the tokenspace repository 310 of the query terms, as described below in connection with Figure 5 A. The query log servers 312 use the token positions to retrieve relevant tokenized query session records from the
tokenspace repository 310, perform data aggregation operations on the retrieved query session records, and return statistical information based on the data aggregation operations as the query result.
[0049] As noted above, multiple query session records may correspond to the same user within a database partition and user-based statistical information is generally more preferable than query session-based statistical information. Accordingly, the query session records within a database partition are sorted by user to achieve better performance when aggregated. Figure 4 A depicts an exemplary data structure 410 for storing the tokenized query session records associated with different users within a database partition M, each query session record having a unique session ID (sometimes called a Doc ID). In some embodiments, integer numbers starting from zero are used as the session IDs. Therefore, the session ID of a particular session record also indicates the number of query session records preceding it in the database partition. The query session records are sorted by user such that the query session records associated with one user have continuous session IDs. For example, the first (A+l) query session records correspond to a first user having a unique ID "UserO", the next (B-A) query session records correspond to a second user having an ID "Userl", and the last (Z-Y) query session records correspond to the last user having an ID "UserL". In some embodiments, integer numbers starting from zero are also used for representing user IDs. Similarly, the user ID associated with a particular session record also indicates the number of users corresponding to the query sessions preceding the current one. As will be explained below, this naming convention makes it easier to normalize data aggregation results.
[0050] Figure 4B is a data structure 420 for storing an individual tokenized session record in the data structure 410 of Figure 4A. This data structure has the same set of components as the data structure 230 of Figure 2C except that every component in the data structure 230 has been encoded (tokenized) to occupy less space. When a repository position identified in the tokenspace inverse index 314 corresponds to a location within the data structure 420, the query log servers 312 retrieve the tokenized session record and aggregate its parameter values accordingly. For example, if the data aggregation is to calculate the total number of users from London and the tokenized geographical values of a respective session record include the tokenized version of "CITY=London", the counter corresponding to the total number will increase by one.
[0051] As noted above, the tokenspace inverse index 314 contains the repository positions for different tokenIDs. But the typical goal of a statistics query is to find out the percentage of users submitting certain queries among a specific group of users meeting certain criteria. Some mapping mechanisms are necessary to bridge the gap between the domain of repository positions and that of users submitting queries. Figures 5A-5C are block diagrams illustrating an exemplary process of generating statistical information in response to a statistics query.
[0052] Figure 5 A is a block diagram of an embodiment of the first stage of the exemplary process with a tokenspace repository. The process involves a lexicon 502, a tokenspace inverse index 506, and a tokenID to index record map 504. Query terms or strings are received by the lexicon 502 that translates the query terms into tokenIDs using a translation table or mapping built from entries of the lexicon 502. A map 504 then maps the tokenIDs to index records stored in the inverse index 508. Each index record identified using the map 504 contains a list of token positions, which directly correspond to token positions in the tokenspace repository 310.
[0053] The token positions in the tokenspace inverse index 506 refer to the exact locations of the query terms in different tokenized query session records in the tokenspace repository 310. In order to aggregate the parameter values of each query session record containing one of the token positions, the query log servers 312 need to identify the starting position of the query session record in the tokenspace repository 310.
[0054] Figure 5B is a data structure for storing a two-way look-up map 508 between the session IDs of the query session records in the tokenspace repository and the starting positions of the query session records in the repository. Each entry in the two-way look-up map 508 includes a session ID and a starting repository position for the corresponding query session record. The last token in any query session record is the position immediately prior to the starting position identified by the next entry in the look-up map 508.
[0055] Assuming that a repository position corresponding to the query term "iPod" is
113, a lookup of the map 508 indicates that this position value is greater than the starting position of SessionM and smaller than the starting position of SessionM+1. Therefore, the query session record SessionM must contain the query term "iPod". One of the query log servers 312 then visits the data structure 410 of Figure 4A to retrieve the tokenized session record for SessionM and aggregates the parameter value of the retrieve session record.
[0056] Figure 5C is a data structure for storing a two-way look-up map 510 between the user IDs and the starting session IDs of the corresponding users. Each entry in the two- way look-up map 510 includes a user ID and a starting session ID for the corresponding user. The session ID of the last session record of any user is the value immediately prior to the starting session ID of the next entry in the look-up map 510. For example, the starting session ID of the user "UserO" in Figure 4A is 0, the starting session ID of the user "Userl" is A+l, and the starting session ID of the user "UserL" is Y+l.
[0057] If the goal is to generate user-based statistical information, after aggregating one session record associated with a particular user, a query log server must skip the remaining query sessions associated with the same user and move to the matching session record associated with the next user. Suppose that the list of repository positions matching the query term "iPod" identified in the inverse index 506 includes 113, 134, 153, and 178, and they are found in the query sessions M, M+2, M+6, and M+8, respectively. In other words, the first instance of the query term "iPod" is in the query session M, the second instance is in the session M+2, the third instance is in the query session M+6, and the forth instance is in the query session M+8. Further, suppose that the starting session IDs for users A and A+l are M-2 and M+7, respectively. The query log server first aggregates the query session M. Since the ID of session M is larger than that of session M-2 and smaller than that of session M+7, session M belongs to user A. By the same token, both sessions M+2 and M+6 belong to user A. Therefore, after aggregating session M, the query log server skips the other two instances of the term "iPod" in the sessions M+2 and M+6 since they are associated with the same user A. The next query session visited by the query log server is the query session M+8, which belongs to a different user having a user ID "A+l". The user ID "A+l" also indicates the total number of users that have been scanned for the current data aggregation result. As will be explained below in connection with Figure 8, this value can be used to normalize the data aggregation result.
[0058] As noted above, the sheer volume of the query session records is often beyond the capacity of a single computer server. Accordingly, the query session records are broken into multiple partitions, each partition being assigned to a respective query log server. In some embodiments, a small number of partitions, e.g., two, three or four, may be assigned to the same query log server. For purposes of explaining the operation of a statistics query processing system, each partition may be treated as a distinct entity executing on a distinct query log server.
[0059] In order to increase the throughout of the statistical query processing system
340 of Figure 3, the query log servers are arranged in a hierarchical structure (e.g., tree). Figure 6 is a block diagram of such an exemplary hierarchical structure in accordance with some embodiments of the present invention. The query log servers 312 are coupled to a frontend server 602. The frontend server 602 is coupled to a news backend server 620. The news backend server 620 is responsible for generating news-related statistical information responsive to a statistics query. For example, given a statistics query that contains only one query term, "iPod", the news backend server 620 counts the number of occurrences of the term within a particular week's news coverage. For each week, the news backend server also selects a piece of news from a credible news source as the representative news item or story of that week. In some embodiments, the representative news story having the "most representative headline." And the "most representative headline" may be defined as the headline whose terms appear most frequently among all the matching news items (i.e., news items matching the statistics query) during that week. A more detailed description of the news backend server can be found in the U.S. Patent Application No. 11/239,684, entitled "Labeling Events in Historic News" filed September 30, 2005, which is incorporated herein by reference in its entirety. The frontend server 602 is responsible for initially parsing the statistics query and is also responsible for preparing query results (e.g., generating images and HTML files, etc.) based on the query results generated by the news backend server 620 and the query log servers 312, respectively.
[0060] Within the hierarchical structure of the query log servers 312, there is a root query server 604. The root query server 604 is responsible for generating a set of sub-queries in response to a statistics query, identifying a subset of intermediate query servers 606 for a selected subset of sub-queries, distributing the selected sub-queries to the identified intermediate query servers 606, and aggregating the query results returned by different intermediate query servers 606. An intermediate query server 606 is responsible for identifying a respective subset of leaf query servers 608 for each sub-query, distributing the sub-query to the leaf query servers, and aggregating the query results returned by different leaf query servers 606. A leaf query server 608 is responsible for aggregating data or information from its associated partition of sorted query session records 610 in accordance with the sub-query assigned to the leaf query server. A more detailed description of the data aggregation process is provided below in connection with Figure 8.
[0061] The number of layers in the hierarchical structure may depend on the volume of query session records in the database. The example shown in Figure 6 is only for illustrative purposes. In some embodiments, if the volume of the query session records is limited, the intermediate layer of query servers 606 is not necessary. In these embodiments, the root query server 604 is directly responsible for distributing sub-queries to different leaf query servers 608 and aggregating their query results accordingly. In some other embodiments, more intermediate layers of query servers 606 may be necessary to process a large volume of query session records. One skilled in the art will appreciate that a specific hierarchical structure design is chosen to maximize the system's throughput. [0062] For the purposes of explaining the operation of an exemplary embodiment of the system shown in Figure 6, the exemplary embodiment will be assumed to have 1024 database partitions, each of which contains data for at least one million query sessions. Thus, when a sub-query is executed against 25 database partitions, about 2.5 percent of the database is being sampled by the execution of that sub-query. In addition, while the number of leaf query servers 108 may be the same as the number of database partitions, in some embodiments, some or all of the leaf query servers 608 service two or more (e.g., two to four) database partitions.
[0063] As noted above, the entire volume of query session records are broken into L partitions. In some embodiments, the value "L" is also the number of leaf query servers in the hierarchical structure. Query session records are randomly assigned to the leaf query servers. The query session records at a particular leaf query server are sorted by their respective users, but are otherwise distributed randomly. For example, one set of session records associated with a user from the United States may be preceded by a set of session records associated with a user from Germany and followed by another set of session records associated with a user from India. The session records associated with a particular user are also distributed randomly according to the same or similar principle.
[0064] Due to the random distribution of query records among the database partitions, and the fact that each database partition contains millions of query session records, each database partition has coverage of representative query sessions very similar to that of the entire database. A statistical estimate based on a subset (e.g., one, or a few) of the database partitions is often sufficiently close to a statistical estimate based on all the database partitions. In other words, there is no need to invoke all the leaf query servers for every single statistical query. This can significantly boost the query processing system's
throughput. On the other hand, an estimate based on too few data samples is not a reliable approximate of an estimate based on the entire database. There must be a sufficient number of data samples to ensure the reliability of an estimate based on a subset of a database, and also to ensure that reported statistics cannot be traced back to individual users or even to small groups of such users.
[0065] In statistics, the standard deviation is a common measure of the distribution of data samples within a dataset and the normal distribution, also called Gaussian distribution, is an extremely important probability distribution in many fields. Figure 13 is a diagram of a bell-shaped curve 1300 representing the probability density of a random variable X having a normal distribution. The value μ in the middle corresponds to the mean of all the data samples within a dataset of the random variable X and the value σ represents the standard deviation of the dataset. If the random variable X takes on data values {xi, X2, ..., XN}, below are the respective definitions of the mean μ and the standard deviation σ,
1 N X V1 + X7 + ... + X, μ = — > x = —
N ^ ' N
and
[0066] As shown in Figure 13, in the case of a normal distribution, one standard deviation σ from the mean μ accounts for 68.26% of the set of data values. In other words, nearly 70% of all the data samples generated by the random variable X are between [μ-σ, μ+σ]- Similarly, two standard deviations 2σ from the mean μ account for 95.5%, and three standard deviations 3σ from the mean μ account for 99.7% of the entire set of data values. A large standard deviation indicates that the data samples are far from the mean and a small standard deviation indicates that they are clustered closely around the mean. For a random variable having a normal distribution, the more data points that are sampled, the more likely we are to get a small standard deviation and therefore a more reliable estimate of the mean of the random variable.
[0067] In the present invention, the distribution of millions of session records and their associated users within a database partition can be approximated by a normal distribution. The formula above can be used to provide guidance with respect to the number of users required to produce a reliable statistical estimate. For example, to estimate the
probability of a query including a specific term, a leaf query server may need to scan through tens of thousands of session records until a predetermined number of queries containing the specific term are found. In some embodiments, this predetermined number is one thousand, two thousand, or a number larger than two thousand (e.g., at least 2,500 positive samples). The magnitude of the predetermined number is, at least in part, dependent upon the ratio of the sub-sampled query log versus the entire query log and their absolute sizes. There are many known statistical theories on how to determine the number of data samples for given reliability requirements.
[0068] In order to identify at least a predetermined number of matching query session records, a two-step approach is described below in connection with Figure 7. The first operation is to search a selected subset of the database partitions for matching query sessions. The second operation is to search additional database partitions (by employing additional leaf query servers) to conduct a new search if the first search operation fails to return at least the predetermined number of matching query session records. Therefore, the first operation is always required and the second operation is conditional.
[0069] As shown in Figure 7, there are several sub-operations within each primary operation. Within the first operation, the root query server first receives a statistics query from a requestor (702). The query may include one or more query terms. These query terms are combined together using one or more Boolean operators such as AND, OR, etc. Next, the root query server generates a list of sub-queries based on the statistical query (704). For example, given the statistical query having only one term "iPod", the root query server may generate a series of sub-queries for a predetermined period of time, each sub-query for determining the percentage of users having submitted at least one iPod-related query in a given week. Similarly, the root query server may also generate sub-queries to determine the percentage of users having submitted at least one iPod-related query from a set of distinct locations, or using a set of distinct languages.
[0070] The root query server (or the root query server in conjunction with one or more of intermediate query servers) identifies a subset of the database partitions, and their corresponding leaf query servers, for each sub-query (706). In doing so, the root query server checks the workload and free resources available at different leaf query servers and then selects one or more database partitions against which to execute the sub-query to achieve an overall load balance. Since there may be multiple leaf query servers executing the same sub- query, each leaf query server is only responsible for identifying a fraction of the
predetermined number of matching query sessions. For example, if the original predetermined number for the entire database is 2500 and 25 database partitions are selected to execute a sub-query, each corresponding leaf query server only needs to identify 100 instances of matching query session records within each of its selected database partitions. Alternately, each leaf query server may be asked to identify up to N instances of matching query session records in each of its selected database partitions, where N is larger (e.g., 10 percent to 100 percent larger) than the predefined number divided by the number of database partitions being queried. Next, the sub-queries are executed by their respective subsets of leaf query servers (708). A more detailed description of this sub-operation is provided below in connection with Figure 8.
[0071] After completing the assigned sub-query, a selected subset of leaf query servers return their query results to the root query server. The root query server then aggregates these query results and checks if the aggregated query result has met some predetermined requirements (710). There are two possible outcomes for the aggregated query result. If the leaf query servers have found their shares of matching query session records in their database partitions, the aggregated query result is deemed as a reliable approximation of the query result derived from the entire database. In this event, Step Two is skipped. The root query server checks if all sub-queries have been executed (724). If not, the root query server returns to operation 708 and asks the leaf query servers execute another sub-query. In some embodiments, operation 708 launches all of the identified sub-queries prior to receiving the results for any of these sub-queries. In these embodiments, the loop control operation 720 is not needed.
[0072] If the total number of matching query session records identified by the leaf query servers has not reached the predetermined number, the root query server identifies a second subset of additional database partitions and their corresponding leaf query servers (712). For example, if the average number of matching query sessions identified in the initially selected 25 database partitions is only 50 (for a total of approximately 1250 matching query session records), the root query server identify at least another 25 database partitions on which to execute the same sub-query. In some embodiments, the root query server may identify more than 25 (e.g., 30) database partitions (and their leaf query servers) to make sure that a sufficient number of matching query sessions are found. Next, the newly-selected leaf query servers execute the same sub-query against their associated database partitions (714). The root query server then checks if the aggregated query result has met the predetermined
requirements (716). If the number of matching query sessions is still below the predetermined number (716, No) and the root query server predicts that there is not sufficient data in the entire database (718), the root query server makes a mark in an entry in the query result corresponding to the sub-query. The frontend server, upon receiving the query result, can use other measures (e.g., data interpolation) to fix the missing entry, or it may omit the query result corresponding to the sub-query that returned an insufficient number of results. After executing all the sub-queries (720, Yes), the root query server normalizes the aggregated query results (722) and returns them to the requestor through the frontend server (724). [0073] Figure 8 is a flowchart illustrating how a leaf query server executes a sub- query in accordance with some embodiments of the present invention. Upon receipt of a sub- query from a query distributor (e.g., the root query server), the leaf query server visits the tokenspace inverse index 314 and identifies a list of repository positions for the sub-query (804). If the sub-query is a Boolean expression including more than one query term, the leaf query server identifies the repository position lists corresponding to different query terms and then generates a list of query sessions that satisfy the Boolean expression. As noted above, the list of repository positions for any given query term (i.e., token) corresponds to the locations of the query term(s) in the matching query session records. To map the repository positions to session records and/or user identifiers, the leaf query server consults the two look-up maps (mapping repository positions to session IDs, and mapping session IDs to user IDs) discussed above with reference to Figures 5B and 5C. Moreover, the leaf query server must access the query session records themselves in order to aggregate their parameter values (e.g., time, location and language).
[0074] The leaf query server selects the first repository position in the list as the current repository position (806). If the sub-query is a "discovery" sub-query, the leaf query server identifies the query session (using look-up map 508) that encompasses the current repository position and then retrieves the query session record from the database partition (808). Next, the leaf query server aggregates the query session record by its parameter values (810). For example, if the sub-query is to count the unique users whose query session records fall into a particular week (e.g., the sub-query is "iPOD AND week=103"), the leaf query server simply increments a count value. If the sub-query is a discovery sub-query (e.g., identify the cities of the users who submitted matching queries), the leaf query server
identifies the value of the session parameter (e.g., city) and adds a count to a corresponding counter.
[0075] Depending upon the number of database partitions selected for a particular sub-query, each leaf query server is responsible for identifying a predetermined number of matching query sessions in corresponding database partition. As noted above, this predetermined number is typically a fraction of the number for the entire database. Every time the leaf query server finds a matching query session, it needs to check if the current count of matching query sessions has met the predetermined number (811). If so, the leaf query server does not have to proceed to a subsequent repository position in the list. Rather, the leaf query server moves to determine the total number of users that have been scanned (816). Otherwise, the aggregation moves onto the next repository position in the list (814).
[0076] After finishing the data aggregation operation, the leaf query server checks if the current repository position is the last one in the list (812). If not, the leaf query server proceeds to a subsequent repository position in the list (814). Note that if the leaf query server generates user-based query results, the next repository position that matches the sub- query may not be the correct one since it may be associated with the same session (e.g., one query session record may include multiple instances of the query term like "iPod") or a different session that corresponds to the same user. Therefore, the leaf query server must find the first repository position corresponding to a different user than the previously processed session record.
[0077] In some embodiments, from the current user, the leaf query server finds an entry including the next user in the look-up map 510. The same entry also includes the starting session ID corresponding to the next user. Based on the starting session ID, the leaf query server visits the look-up map 508 to identify the starting repository position corresponding to the starting session ID. Based on this starting repository position, the leaf query server then examines its list of repository positions to find the first repository position in the list of query-matching repository positions that is beyond that starting position.
[0078] Alternately, operation 804 may identify a list of sessions that match the sub- query, and operations 806 and 808 utilize the identified list of matching sessions. [0079] If all the repository positions (or matching sessions) in the list have been processed (812, Yes), the leaf query server then determines the total number of users that have been scanned in the database partition (816). This sub-operation also involves the two
look-up maps 508 and 510. The leaf query server first checks the look-up map 508 to find the session ID whose record contains the last repository position in the list. From the session ID, the leaf query server finds the corresponding user ID in the look-up map 510. The user ID associated with the smaller starting session ID corresponds to the total number of users that have been scanned in the database partition. Finally, the leaf query server normalizes the query result using the total number of scanned users and returns the normalized query result to the query distributor (818).
[0080] Generally, there are two types of normalization in connection with the generation of user-based statistics. For example, in order to find the popularity of the query term "iPod" in different weeks, the root query server generates at least two sub-queries for each particular week. One sub-query N("iPod", "WEEK=xyz") estimates the number of users that have submitted at least one iPod-related query during the week and the other sub- query N("WEEK=xyz") estimates the number of users that have submitted any query during the same week N("WEEK=xyz"). Since there may be a significant growth of users visiting the web search engine from week to week, the number corresponding to the query N("iPod", "WEEK=IOOO") may also increase from week to week without indicating any increase in popularity of the query. Without normalization, changes in the numbers corresponding to the query N("iPod", "WEEK=xyz") from week to week may not corresponding to changes in popularity. Therefore, the popularity of the query term "iPod" has to be expressed in a normalized fashion as
N("iPod",WEEK = xyz") N("WEEK = xyz")
[0081] As noted above, when a leaf query server executes a sub-query N("iPod",
"WEEK=xyz"), it may stop short of determining the total number of users who have submitted at least one iPod-related query during the week "xyz". Rather, the leaf query server may stop its search when it finds a predetermined number of such users (e.g., 100 if 25 database partitions are being searched). But in order to find the 100 users, the leaf query server must scan a larger number of users, i.e., the total number of scanned users determined at sub-operation 816. If the query is very popular, the leaf query server may not need to scan too many users to reach the goal of 100. But if the query is not popular, the leaf query server must scan a substantial number of users to reach the goal of 100. In other words, the total number of scanned users for each sub-query indicates the popularity of the sub-query. A higher total number of scanned users correspond to a less popular sub-query.
[0082] Therefore, the number corresponding to the query N("iPod", "WEEK-xyz") should be expressed in a normalized fashion as
N("iPod",'WEEK = ,
[0084] Figure 9 is a flowchart illustrating a two-pass process of identifying the top N candidates without generating a large number of sub-queries. The first pass of the process includes three operations 902, 904, and 906. Operation 902 is similar to the process shown in Figure 7. The root query server executes a statistics query at a selected subset of leaf query servers (i.e., against a selected subset of the database partitions). For example, the statistics query has only one query term "iPod". The leaf query servers identify the users having at least one iPod-related query and aggregate the user by their associated cities, regions, countries and languages. Next, the root query server selects from the aggregated query results a subset of parameter values meeting predefined criteria (904). For example, the root query server selects the top 25 cities, regions, countries and/or languages based on the aggregated query results. Since a database partition is like a smaller version of the entire
database, it is very likely that the top 25 candidates identified by the leaf query servers encompass the top 10 candidates, although the candidates' order may not be exactly the same. For each of the top 25 candidates in different categories, the root query server generates a new subsequent statistics query (906). The first pass of the process is also referred as the discovery pass. Its goal is to reduce the number of candidates from several thousand to a few dozen by performing a "discovery" search of a small subset of the database partitions.
[0085] The second pass of the process is referred to as the refinement pass. From the query results of the discovery pass, the root query server not only has a list of candidates for each parameter category, but also has reasonable estimates of the densities of query session records containing the different candidates. For each subsequent statistics query, the root query server identifies (i.e., selects) a respective subset of database partitions (and their corresponding leaf query servers) (908). The number of the database partitions depends on the density estimate associated with the subsequent query. A query having a lower density estimate needs to be executed against more database partitions to find the predetermined number of matching query session records. Next, the root query server executes each of the subsequent queries at the corresponding subset of leaf query servers against the identified database partitions (910). Finally, the root query returns the query results associated with the subsequent queries to the requestor (912). Since the second pass has found a sufficient number of matching records for each query, the query result generated at the second pass is more reliable than that of the first pass. But the first pass substantially reduces the number of candidates and makes it possible to execute the second pass efficiently.
[0086] Figure 10 is an exemplary screenshot of a webpage containing statistics about users related to a particular query term "iPod". The webpage includes various types of statistical information. It takes less than a second for the statistical query processing system to generate this webpage.
[0087] Some of the statistical information is time-based. For example, the curve 1002 represents the popularity of the term "iPod" over a time period of more than two years. Each data point on the curve 1002 corresponds to a ratio between the number of users that have submitted at least one iPod-related query during a particular week and the number of users that have submitted any query during that week. The curve 1002 has both peaks and troughs suggesting that the term's popularity indeed varies with time.
[0088] Below the curve 1002 is another curve 1004. This curve represents the volume of news coverage of iPod during the same time period. Each data point on the curve 1004 represents the number of occurrences of the term "iPod" in that week's news coverage. The spikes on the curve 1004 indicate increases in news coverage concerning the iPod product during that week. The frontend server selects the weeks corresponding to six spikes on the curve 1004 and marks the corresponding weeks on the curve 1002 using labels A-F. For some of the spikes on the news curve 1004, there is a corresponding increase of users submitting the iPod-related query. For example, the label C indicates that the increase in iPod-related queries is in synch with the news coverage spike. The representative news during that week is that Apple releases its new generation of product, iPod Nano and iPod phone.
[0089] In contrast, although label D corresponds to the highest news coverage spike on the curve 1004, there is no significant increase of iPod-related queries. The representative iPod-related news is that Apple releases its iPod Video. A comparison of the two curves 1002 and 1004 may provide valuable insights to various persons (e.g., marketing professional, social scientist, etc.) and organizations.
[0090] Below the two curves are three tabs, 1006 for cities, 1008 for countries and
1010 for languages. Under the Cities tab 1006 are the top 10 cities that have the largest number of users that have submitted at least one iPod-related query. Note that the number next to each city is not necessarily the actual number of users from that city. It is a value representing the scale of one city versus a reference value. To the right of the numbers is a bar chart 1012. The bar chart 1012 illustrates the volume of users from the top 10 cities in a more intuitive manner. When a user clicks the Countries tab 1008 or the Language tab 1010, the statistics query processing system receives a new statistics request and then generates query results using the two-pass process described above in connection with Figure 9.
[0091] On the top-right corner of the screenshot are two dropdown lists, 1016 for date sub-ranges (labelled "years") and 1018 for countries. A user can request that the prior inquiry be re-executed for a particular month, in which case a new webpage is provided that reflects statistics based on the query session records for that month, as shown in Figure 1OB. Similarly, a user request that the prior inquiry be re-executed for a particular country, in which case a new webpage is provided that reflects statistics based on the query session records for that country, as shown in Figure 1OC.
[0092] Figure 1 IA is a block diagram of an exemplary query distribution and aggregation server (e.g., a root query server or intermediate query server) 1100 in accordance with some embodiments of the present invention, which typically includes one or more processing units (CPU's) 1102, one or more network or other communications interfaces 1104, memory 1110, and one or more communication buses 1112 for interconnecting these components. Memory 1 110 may include high speed random access memory and may also include non-volatile memory, such as one or more magnetic disk storage devices. Memory 1110 preferably stores the following programs, modules and data structures, or a subset or superset thereof: • an operating system 1114 that includes procedures for handling various basic system services and for performing hardware dependent tasks;
• a network communication module (or instructions) 1116 that is used for connecting the query server 1100 to other computers via the one or more communication network interfaces 1104; • a sub-query distributor 1118 for assigning a sub-query to a selected subset of database partitions and their corresponding leaf query servers;
• a sub-query result aggregator 1120 for aggregating query results generated by leaf query servers;
• a sub-query generator 1122 for generating a set of sub-queries for a statistics query; and
• a load balance analyzer 1126 for analyzing the workload at different leaf query servers and selecting a subset of the leaf query servers based upon their workload.
[0093] Figure 1 IB is a block diagram of an exemplary leaf query server 1150 in accordance with some embodiments of the present invention, which typically includes one or more processing units (CPU's) 1152, one or more network or other communications interfaces 1154, memory 1160, and one or more communication buses 1162 for interconnecting these components. Memory 1160 may include high speed random access memory and may also include non-volatile memory, such as one or more magnetic disk storage devices. Memory 1160 preferably stores the following programs, modules and data structures, or a subset or superset thereof:
• an operating system 1164 that includes procedures for handling various basic system services and for performing hardware dependent tasks;
• a network communication module (or instructions) 1166 that is used for connecting the query server 1100 to other computers via the one or more communication network interfaces 1104;
• a sub-query executor 1168 for executing a sub-query against a database partition; and • one or more database partitions 1170, each of which may include a token repository
1172, an inverse index 1174, a session ID range map (session ID to token position map) 1176, and a user ID range map (user ID to session ID map) 1178.
[0094] Figure 12 is a block diagram of an exemplary query session partition server
1200 in accordance with some embodiments of the present invention, which typically includes one or more processing units (CPU's) 1202, one or more network or other communications interfaces 1204, memory 1210, and one or more communication buses 1212 for interconnecting these components. Memory 1210 may include high speed random access memory and may also include non-volatile memory, such as one or more magnetic disk storage devices. Memory 1210 preferably stores the following programs, modules and data structures, or a subset or superset thereof:
• an operating system 1214 that includes procedures for handling various basic system services and for performing hardware dependent tasks;
• a network communication module (or instructions) 1216 that is used for connecting the partition server 1200 to other computers via the one or more communication network interfaces 1204;
• a query log sampler 1218 for sampling a web search engine's query log;
• a query session extractor 1220 for grouping different query records into different query sessions in accordance with predefined criteria;
• a query session partitioner 1222 for breaking the entire query session database into multiple partitions;
• a query session sorter 1224 for sorting the query session records within a partition by their associated users; and
• multiple database partitions 1226, each database partition having a token repository 1228, an inverse index 1230, a session ID range map 1232 and a user ID range map 1234.
[0095] Although some of various drawings illustrate a number of logical stages in a particular order, stages that are not order dependent may be reordered and other stages may be combined or broken out. While some reordering or other groupings are specifically mentioned, others will be obvious to those of ordinary skill in the art and so do not present an exhaustive list of alternatives. Moreover, it should be recognized that the stages could be implemented in hardware, firmware, software or any combination thereof. [0096] The foregoing description, for purpose of explanation, has been described with reference to specific embodiments. However, the illustrative discussions above are not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations are possible in view of the above teachings. The embodiments were chosen and described in order to best explain the principles of the invention and its practical applications, to thereby enable others skilled in the art to best utilize the invention and various embodiments with various modifications as are suited to the particular use contemplated.
Claims
1. A computer-implemented method, comprising: calculating first statistics about a user-identified event within a first subset of a database of events; selecting a second subset of the database of events based on said first statistics; calculating second statistics about the user-identified event within the second subset of the database of events; merging the first and second statistics as statistics of the user-identified event within the entire database of events; and generating a result including at least a portion of the merged statistics of the user- identified event.
2. The method of claim 1, further comprising: treating the first statistics as the statistics of the user-identified event within the entire database of events if the first statistics meets predefined criteria, the predefined criteria including that a number of instances of an event within a subset of the database of events exceeds a predefined threshold.
3. The method of claim 1 , further comprising: accessing the database of events, wherein the database of events includes multiple partitions, each partition including a non-overlapping subset of the database of events; selecting a first set of the partitions as the first subset of the database of events; and determining a first number of instances of the user-identified event within the first set of partitions.
4. The method of claim 3, further comprising: if the first number of instances of the user-identified event exceeds a predefined threshold, determining within the first set of partitions a total number of events corresponding to the first number of instances of the user-identified event; and estimating an occurrence frequency of the user-identified event within the entire database of events in accordance with the first number of instances of the user-identified event and the total number of events.
5. The method of claim 3, further comprising: selecting a second set of the partitions as the second subset of the database of events in accordance with a comparison of the first number of instances of the user-identified event within the first set of partitions with a predefined threshold; determining a second number of instances of the user-identified event within the second set of partitions; determining within the second set of partitions a total number of events corresponding to the second number of instances of the user-identified event; and estimating an occurrence frequency of the user-identified event within the entire database of events in accordance with the first and second numbers of instances of the user- identified event and their associated total numbers of events.
6. The method of claim 1, wherein an event in the database of events includes one or more mini-sessions, each mini-session having a user identifier, a temporal value, a location value, and one or more query strings.
7. The method of claim 6, wherein the user identifier of a mini-session is based on a cookie of the mini-session.
8. The method of claim 6, wherein the statistics of the user-identified event includes numbers of instances of the event within multiple time periods, and the method including aggregating instances of the event in a plurality of respective time periods based on their associated mini-session temporal values.
9. The method of claim 6, wherein the statistics of the user-identified event includes numbers of instances of the event within multiple geographical regions, and the method including aggregating instances of the event in a plurality of respective geographical regions based on their associated mini-session location values.
10. A computer-implemented method, comprising: identifying in an inverse index file a sequence of positions associated with an indexed item, wherein the sequence of positions corresponds to a set of events from a sequence of randomly-arranged events, each event including at least one occurrence of the indexed item and having a respective sequence number; selecting in the sequence of randomly-arranged events an event corresponding to a predefined position in the sequence of positions and its sequence number; determining a number of positions in the sequence of positions that precede the predefined position; and determining an occurrence frequency for the indexed item in the sequence of randomly-arranged events using the selected event's sequence number and the determined number of positions.
11. The method of claim 10, wherein each event has an associated user identifier and the sequence of randomly-arranged events is sorted by their respective user identifiers.
12. The method of claim 11 , further comprising: determining a first number of unique user identifiers associated with events in the sequence of randomly-arranged events that precede the selected event; determining a second number of unique user identifiers corresponding to the number of positions in the sequence of positions that precede the predefined position; and determining an occurrence frequency for the indexed item in the sequence of randomly-arranged events using the first and second numbers of unique user identifiers.
13. The method of claim 12, wherein the second number of unique user identifiers is at least equal to or more than a predefined number.
14. The method of claim 10, wherein an event in the sequence of randomly-arranged events includes one or more mini-sessions, each mini-session having a user identifier, a temporal value, a location value, and one or more query strings.
15. The method of claim 14, wherein the user identifier of a mini-session is based on a cookie of the mini-session.
16. The method of claim 10, further comprising: randomly partitioning the sequence of randomly-arranged events into a plurality of sub-sequences of randomly-arranged events; applying the operations recited in claim 10 to each of a subset of the sub-sequences of randomly-arranged events to determine a respective occurrence frequency for the indexed item in each sub-sequence of randomly-arranged events; and determining the occurrence frequency for the indexed item in the sequence of randomly-arranged events by combing the respective occurrence frequencies for the indexed item.
17. The method of claim 16, further comprising: applying the operations recited in claim 10 to an additional sub-sequence of randomly-arranged events to determine an additional occurrence frequency for the indexed item in the additional sub-sequence of randomly-arranged events; updating the occurrence frequency for the indexed item in the sequence of randomly- arranged events using the additional occurrence frequency for the indexed item in the additional sub-sequence of randomly-arranged events; and repeating the applying and updating operations until the updated occurrence frequency for the indexed item in the sequence of randomly-arranged events meets a predefined condition.
18. The method of claim 10, further comprising: identifying in a second inverse index file a second sequence of positions associated with the indexed item, wherein the second sequence of positions corresponds to a second set of events among a second sequence of randomly-arranged events, each event including at least one occurrence of the indexed item and having a respective sequence number, and the sequence of randomly-arranged events and the second sequence of randomly-arranged events are both randomly selected from a database of events; selecting in the second sequence of randomly-arranged events a second event corresponding to a second position in the second sequence of positions and its sequence number; determining a second number of positions in the second sequence of positions that precede the position; determining a second occurrence frequency for the indexed item in the second sequence of randomly-arranged events using the selected second event's sequence number and the second number of positions; and updating the occurrence frequency for the indexed item in the sequence of randomly- arranged events recited in claim 10 using the second occurrence frequency for the indexed item in the second sequence of randomly-arranged events.
19. The method of claim 18, further comprising: selecting from the database of events an additional sequence of randomly-arranged events; applying the operations recited in claim 10 to the additional sequence of randomly- arranged events to determine an additional occurrence frequency for the indexed item in the additional sequence of randomly-arranged events; further updating the occurrence frequency for the indexed item using the additional occurrence frequency for the indexed item in the additional sequence of randomly-arranged events; and repeating the selecting, applying and updating operations until the updated occurrence frequency for the indexed item meets a predefined condition.
20. A computer system for managing time and place information, comprising: memory; one or more processors; one or more programs stored in the memory and configured for execution by the one or more processors, the one or more programs including: instructions for identifying in an inverse index file a sequence of positions associated with an indexed item, wherein the sequence of positions corresponds to a set of events from a sequence of randomly-arranged events, each event including at least one occurrence of the indexed item and having a respective sequence number; instructions for selecting in the sequence of randomly-arranged events an event corresponding to a predefined position in the sequence of positions and its sequence number; instructions for determining a number of positions in the sequence of positions that precede the predefined position; and instructions for determining an occurrence frequency for the indexed item in the sequence of randomly-arranged events using the selected event's sequence number and the determined number of positions.
21. The computer system of claim 20, wherein each event has an associated user identifier and the sequence of randomly-arranged events is sorted by their respective user identifiers.
22. The computer system of claim 21 , further comprising: instructions for determining a first number of unique user identifiers associated with events in the sequence of randomly-arranged events that precede the selected event; instructions for determining a second number of unique user identifiers corresponding to the number of positions in the sequence of positions that precede the predefined position; and instructions for determining an occurrence frequency for the indexed item in the sequence of randomly-arranged events using the first and second numbers of unique user identifiers.
23. The computer system of claim 22, wherein the second number of unique user identifiers is at least equal to or more than a predefined number.
24. The computer system of claim 20, wherein an event in the sequence of randomly- arranged events includes one or more mini-sessions, each mini-session having a user identifier, a temporal value, a location value, and one or more query strings.
25. The computer system of claim 24, wherein the user identifier of a mini-session is based on a cookie of the mini-session.
26. The computer system of claim 20, further comprising: instructions for randomly partitioning the sequence of randomly-arranged events into a plurality of sub-sequences of randomly-arranged events; instructions for applying the instructions recited in claim 20 to each of a subset of the sub-sequences of randomly-arranged events to determine a respective occurrence frequency for the indexed item in each sub-sequence of randomly-arranged events; and instructions for determining the occurrence frequency for the indexed item in the sequence of randomly-arranged events by combing the respective occurrence frequencies for the indexed item.
27. The computer system of claim 26, further comprising: instructions for applying the instructions recited in claim 20 to an additional sub- sequence of randomly-arranged events to determine an additional occurrence frequency for the indexed item in the additional sub-sequence of randomly-arranged events; instructions for updating the occurrence frequency for the indexed item in the sequence of randomly-arranged events using the additional occurrence frequency for the indexed item in the additional sub-sequence of randomly-arranged events; and instructions for repeating the applying and updating operations until the updated occurrence frequency for the indexed item in the sequence of randomly-arranged events meets a predefined condition.
28. The computer system of claim 20, further comprising: instructions for identifying in a second inverse index file a second sequence of positions associated with the indexed item, wherein the second sequence of positions corresponds to a second set of events among a second sequence of randomly-arranged events, each event including at least one occurrence of the indexed item and having a respective sequence number, and the sequence of randomly-arranged events and the second sequence of randomly-arranged events are both randomly selected from a database of events; instructions for selecting in the second sequence of randomly-arranged events a second event corresponding to a second position in the second sequence of positions and its sequence number; instructions for determining a second number of positions in the second sequence of positions that precede the position; instructions for determining a second occurrence frequency for the indexed item in the second sequence of randomly-arranged events using the selected second event's sequence number and the second number of positions; and instructions for updating the occurrence frequency for the indexed item in the sequence of randomly-arranged events recited in claim 20 using the second occurrence frequency for the indexed item in the second sequence of randomly-arranged events.
29. The computer system of claim 28, further comprising: instructions for selecting from the database of events an additional sequence of randomly-arranged events; instructions for applying the instructions recited in claim 20 to the additional sequence of randomly-arranged events to determine an additional occurrence frequency for the indexed item in the additional sequence of randomly-arranged events; instructions for further updating the occurrence frequency for the indexed item using the additional occurrence frequency for the indexed item in the additional sequence of randomly-arranged events; and instructions for repeating the selecting, applying and updating operations until the updated occurrence frequency for the indexed item meets a predefined condition.
30. A computer program product for use in conjunction with a computer system, the computer program product comprising a computer readable storage medium and a computer program mechanism embedded therein, the computer program mechanism comprising: instructions for identifying in an inverse index file a sequence of positions associated with an indexed item, wherein the sequence of positions corresponds to a set of events from a sequence of randomly-arranged events, each event including at least one occurrence of the indexed item and having a respective sequence number; instructions for selecting in the sequence of randomly-arranged events an event corresponding to a predefined position in the sequence of positions and its sequence number; instructions for determining a number of positions in the sequence of positions that precede the predefined position; and instructions for determining an occurrence frequency for the indexed item in the sequence of randomly-arranged events using the selected event's sequence number and the determined number of positions.
31. The computer program product of claim 30, wherein each event has an associated user identifier and the sequence of randomly-arranged events is sorted by their respective user identifiers.
32. A computer system for managing time and place information, comprising: memory; one or more processors; one or more programs stored in the memory and configured for execution by the one or more processors, the one or more programs including: means for identifying in an inverse index file a sequence of positions associated with an indexed item, wherein the sequence of positions corresponds to a set of events from a sequence of randomly-arranged events, each event including at least one occurrence of the indexed item and having a respective sequence number; means for selecting in the sequence of randomly-arranged events an event corresponding to a predefined position in the sequence of positions and its sequence number; means for determining a number of positions in the sequence of positions that precede the predefined position; and means for determining an occurrence frequency for the indexed item in the sequence of randomly-arranged events using the selected event's sequence number and the determined number of positions.
Applications Claiming Priority (4)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US74688606P | 2006-05-09 | 2006-05-09 | |
US60/746,886 | 2006-05-09 | ||
US11/746,049 US8126874B2 (en) | 2006-05-09 | 2007-05-08 | Systems and methods for generating statistics from search engine query logs |
US11/746,049 | 2007-05-08 |
Publications (2)
Publication Number | Publication Date |
---|---|
WO2007134130A2 true WO2007134130A2 (en) | 2007-11-22 |
WO2007134130A3 WO2007134130A3 (en) | 2008-10-09 |
Family
ID=38694684
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
PCT/US2007/068602 WO2007134130A2 (en) | 2006-05-09 | 2007-05-09 | Systems and methods for generating statistics from search engine query logs |
Country Status (2)
Country | Link |
---|---|
US (2) | US8126874B2 (en) |
WO (1) | WO2007134130A2 (en) |
Cited By (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
EP2389624A1 (en) * | 2009-01-22 | 2011-11-30 | Alibaba Group Holding Limited | Sampling analysis of search queries |
JP2012014355A (en) * | 2010-06-30 | 2012-01-19 | Yahoo Japan Corp | Device and method for discriminating spam id address and device and method for discriminating spam query |
US20120284305A1 (en) * | 2010-01-19 | 2012-11-08 | Nec Corporation | Trend information search device, trend information search method and recording medium |
Families Citing this family (63)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US7610282B1 (en) * | 2007-03-30 | 2009-10-27 | Google Inc. | Rank-adjusted content items |
AU2008254644B2 (en) * | 2007-05-21 | 2013-11-21 | Google Llc | Query statistics provider |
CN101779200B (en) * | 2007-06-14 | 2013-03-20 | 谷歌股份有限公司 | Dictionary word and phrase determination |
US8290921B2 (en) * | 2007-06-28 | 2012-10-16 | Microsoft Corporation | Identification of similar queries based on overall and partial similarity of time series |
KR100893129B1 (en) * | 2007-10-24 | 2009-04-15 | 엔에이치엔(주) | System for extracting recommended keyword of multimedia contents and method thereof |
KR100903506B1 (en) * | 2007-10-24 | 2009-06-17 | 엔에이치엔(주) | System and method for managing informaiton map |
GB0813123D0 (en) * | 2008-07-17 | 2008-08-27 | Symbian Software Ltd | Method of searching |
US8180774B2 (en) * | 2008-10-03 | 2012-05-15 | Seomoz, Inc. | Web-scale data processing system and method |
US8214350B1 (en) * | 2009-01-02 | 2012-07-03 | Google Inc. | Pre-computed impression lists |
US8504580B2 (en) * | 2009-03-03 | 2013-08-06 | Ilya Geller | Systems and methods for creating an artificial intelligence |
US8516013B2 (en) | 2009-03-03 | 2013-08-20 | Ilya Geller | Systems and methods for subtext searching data using synonym-enriched predicative phrases and substituted pronouns |
US8447789B2 (en) * | 2009-09-15 | 2013-05-21 | Ilya Geller | Systems and methods for creating structured data |
US8756244B2 (en) * | 2009-07-29 | 2014-06-17 | Teradata Us, Inc. | Metadata as comments for search problem determination and analysis |
US8255379B2 (en) | 2009-11-10 | 2012-08-28 | Microsoft Corporation | Custom local search |
US20110270819A1 (en) * | 2010-04-30 | 2011-11-03 | Microsoft Corporation | Context-aware query classification |
US20110314045A1 (en) * | 2010-06-21 | 2011-12-22 | Microsoft Corporation | Fast set intersection |
US9430502B1 (en) * | 2010-09-10 | 2016-08-30 | Tellabs Operations, Inc. | Method and apparatus for collecting and storing statistics data from network elements using scalable architecture |
US20130006914A1 (en) * | 2011-06-28 | 2013-01-03 | Microsoft Corporation | Exposing search history by category |
US8688499B1 (en) * | 2011-08-11 | 2014-04-01 | Google Inc. | System and method for generating business process models from mapped time sequenced operational and transaction data |
US9218629B2 (en) * | 2012-01-20 | 2015-12-22 | Blackberry Limited | Prioritizing and providing information about user contacts |
US20130232172A1 (en) * | 2012-03-01 | 2013-09-05 | Salesforce.Com, Inc. | Methods and systems for matching expressions |
US8620925B1 (en) | 2012-05-17 | 2013-12-31 | Google Inc. | System and method for identifying advertising opportunities |
US8516008B1 (en) | 2012-05-18 | 2013-08-20 | Splunk Inc. | Flexible schema column store |
US10061807B2 (en) | 2012-05-18 | 2018-08-28 | Splunk Inc. | Collection query driven generation of inverted index for raw machine data |
US8682925B1 (en) * | 2013-01-31 | 2014-03-25 | Splunk Inc. | Distributed high performance analytics store |
US9201916B2 (en) * | 2012-06-13 | 2015-12-01 | Infosys Limited | Method, system, and computer-readable medium for providing a scalable bio-informatics sequence search on cloud |
US20150235187A1 (en) * | 2012-09-18 | 2015-08-20 | Newtek Business Services, Inc. | Real-Time Data Capture and Distribution System for E-Commerce Payment Transactions |
CN104077530A (en) | 2013-03-27 | 2014-10-01 | 国际商业机器公司 | Method and device used for evaluating safety of data access sentence |
US9373322B2 (en) * | 2013-04-10 | 2016-06-21 | Nuance Communications, Inc. | System and method for determining query intent |
US10169711B1 (en) * | 2013-06-27 | 2019-01-01 | Google Llc | Generalized engine for predicting actions |
US11921715B2 (en) | 2014-01-27 | 2024-03-05 | Microstrategy Incorporated | Search integration |
US10095759B1 (en) | 2014-01-27 | 2018-10-09 | Microstrategy Incorporated | Data engine integration and data refinement |
US9952894B1 (en) * | 2014-01-27 | 2018-04-24 | Microstrategy Incorporated | Parallel query processing |
US10255320B1 (en) | 2014-01-27 | 2019-04-09 | Microstrategy Incorporated | Search integration |
US11386085B2 (en) | 2014-01-27 | 2022-07-12 | Microstrategy Incorporated | Deriving metrics from queries |
US9818065B2 (en) * | 2014-03-12 | 2017-11-14 | Microsoft Technology Licensing, Llc | Attribution of activity in multi-user settings |
US10599659B2 (en) * | 2014-05-06 | 2020-03-24 | Oath Inc. | Method and system for evaluating user satisfaction with respect to a user session |
US9747331B2 (en) * | 2014-10-06 | 2017-08-29 | International Business Machines Corporation | Limiting scans of loosely ordered and/or grouped relations in a database |
RU2610280C2 (en) | 2014-10-31 | 2017-02-08 | Общество С Ограниченной Ответственностью "Яндекс" | Method for user authorization in a network and server used therein |
RU2580432C1 (en) | 2014-10-31 | 2016-04-10 | Общество С Ограниченной Ответственностью "Яндекс" | Method for processing a request from a potential unauthorised user to access resource and server used therein |
US10229150B2 (en) | 2015-04-23 | 2019-03-12 | Splunk Inc. | Systems and methods for concurrent summarization of indexed data |
US11048701B2 (en) * | 2016-09-13 | 2021-06-29 | International Business Machines Corporation | Query optimization in hybrid DBMS |
CN106649804A (en) * | 2016-12-29 | 2017-05-10 | 深圳市优必选科技有限公司 | Data processing method, data processing device and data processing system for data query server |
US11379530B2 (en) | 2017-01-31 | 2022-07-05 | Splunk Inc. | Leveraging references values in inverted indexes to retrieve associated event records comprising raw machine data |
US10474674B2 (en) | 2017-01-31 | 2019-11-12 | Splunk Inc. | Using an inverted index in a pipelined search query to determine a set of event data that is further limited by filtering and/or processing of subsequent query pipestages |
US10467433B2 (en) * | 2017-03-17 | 2019-11-05 | Mediasift Limited | Event processing system |
US10846318B1 (en) | 2017-04-18 | 2020-11-24 | Microstrategy Incorporated | Natural language visualizations |
US10423638B2 (en) | 2017-04-27 | 2019-09-24 | Google Llc | Cloud inference system |
US20180357278A1 (en) * | 2017-06-09 | 2018-12-13 | Linkedin Corporation | Processing aggregate queries in a graph database |
US10817757B2 (en) | 2017-07-31 | 2020-10-27 | Splunk Inc. | Automated data preprocessing for machine learning |
US11403366B2 (en) * | 2018-09-30 | 2022-08-02 | Hewlett Packard Enterprise Development Lp | On-demand retrieval of information from databases |
US11195050B2 (en) | 2019-02-05 | 2021-12-07 | Microstrategy Incorporated | Machine learning to generate and evaluate visualizations |
CN112307360B (en) * | 2019-07-30 | 2023-08-25 | 百度在线网络技术（北京）有限公司 | Regional event detection method and device based on search engine and search engine |
US11620157B2 (en) | 2019-10-18 | 2023-04-04 | Splunk Inc. | Data ingestion pipeline anomaly detection |
US11620296B2 (en) * | 2019-10-18 | 2023-04-04 | Splunk Inc. | Online machine learning algorithm for a data intake and query system |
US11614970B2 (en) | 2019-12-06 | 2023-03-28 | Microstrategy Incorporated | High-throughput parallel data transmission |
US11567965B2 (en) | 2020-01-23 | 2023-01-31 | Microstrategy Incorporated | Enhanced preparation and integration of data sets |
US11704490B2 (en) | 2020-07-31 | 2023-07-18 | Splunk Inc. | Log sourcetype inference model training for a data intake and query system |
US11663176B2 (en) | 2020-07-31 | 2023-05-30 | Splunk Inc. | Data field extraction model training for a data intake and query system |
CN112463570B (en) * | 2020-12-15 | 2024-04-09 | 航天信息股份有限公司 | Log statistics method, device and system |
US11687438B1 (en) | 2021-01-29 | 2023-06-27 | Splunk Inc. | Adaptive thresholding of data streamed to a data processing pipeline |
US20230229659A1 (en) * | 2022-01-20 | 2023-07-20 | Oracle International Corporation | Estimating query execution performance using a sampled counter |
CN116450885B (en) * | 2023-02-14 | 2024-05-03 | 厦门市兴百邦科技有限公司 | Data reconstruction method of Windows event log file |
Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5983216A (en) * | 1997-09-12 | 1999-11-09 | Infoseek Corporation | Performing automated document collection and selection by providing a meta-index with meta-index values indentifying corresponding document collections |
US20040215607A1 (en) * | 2003-04-25 | 2004-10-28 | Travis Robert L. | Method and system fo blending search engine results from disparate sources into one search result |
US20050010564A1 (en) * | 2003-05-19 | 2005-01-13 | Netezza Corporation | Limiting scans of loosely ordered and/or grouped relations using nearly ordered maps |
Family Cites Families (32)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6115393A (en) * | 1991-04-12 | 2000-09-05 | Concord Communications, Inc. | Network monitoring |
US5613113A (en) * | 1993-10-08 | 1997-03-18 | International Business Machines Corporation | Consistent recreation of events from activity logs |
CA2167790A1 (en) * | 1995-01-23 | 1996-07-24 | Donald S. Maier | Relational database system and method with high data availability during table data restructuring |
US6144967A (en) * | 1996-01-25 | 2000-11-07 | International Business Machines Corporation | Object oriented processing log analysis tool framework mechanism |
US5696964A (en) * | 1996-04-16 | 1997-12-09 | Nec Research Institute, Inc. | Multimedia database retrieval system which maintains a posterior probability distribution that each item in the database is a target of a search |
US6654933B1 (en) * | 1999-09-21 | 2003-11-25 | Kasenna, Inc. | System and method for media stream indexing |
US6108648A (en) * | 1997-07-18 | 2000-08-22 | Informix Software, Inc. | Optimizer with neural network estimator |
US6292830B1 (en) * | 1997-08-08 | 2001-09-18 | Iterations Llc | System for optimizing interaction among agents acting on multiple levels |
US6067541A (en) * | 1997-09-17 | 2000-05-23 | Microsoft Corporation | Monitoring document changes in a file system of documents with the document change information stored in a persistent log |
KR100268749B1 (en) * | 1998-02-26 | 2000-10-16 | 이 병 길 | Layered manganese dioxide for li secondary batteries and method for producing the same |
US6278993B1 (en) * | 1998-12-08 | 2001-08-21 | Yodlee.Com, Inc. | Method and apparatus for extending an on-line internet search beyond pre-referenced sources and returning data over a data-packet-network (DPN) using private search engines as proxy-engines |
US6898597B1 (en) * | 1999-11-09 | 2005-05-24 | Insweb Corporation | Event log |
US6477523B1 (en) * | 1999-12-03 | 2002-11-05 | Ncr Corporation | Selectivity prediction with compressed histograms in a parallel processing database system |
US20020152305A1 (en) * | 2000-03-03 | 2002-10-17 | Jackson Gregory J. | Systems and methods for resource utilization analysis in information management environments |
EP1269382A4 (en) * | 2000-03-30 | 2005-03-02 | I411 Inc | Methods and systems for enabling efficient retrieval of data from data collections |
US6687696B2 (en) * | 2000-07-26 | 2004-02-03 | Recommind Inc. | System and method for personalized search, information filtering, and for generating recommendations utilizing statistical latent class models |
US6766320B1 (en) * | 2000-08-24 | 2004-07-20 | Microsoft Corporation | Search engine with natural language-based robust parsing for user query and relevance feedback learning |
US7617201B1 (en) * | 2001-06-20 | 2009-11-10 | Microstrategy, Incorporated | System and method for analyzing statistics in a reporting system |
US7139749B2 (en) * | 2002-03-19 | 2006-11-21 | International Business Machines Corporation | Method, system, and program for performance tuning a database query |
US7249118B2 (en) * | 2002-05-17 | 2007-07-24 | Aleri, Inc. | Database system and methods |
US6947927B2 (en) * | 2002-07-09 | 2005-09-20 | Microsoft Corporation | Method and apparatus for exploiting statistics on query expressions for optimization |
US7308643B1 (en) * | 2003-07-03 | 2007-12-11 | Google Inc. | Anchor tag indexing in a web crawler system |
US7240049B2 (en) * | 2003-11-12 | 2007-07-03 | Yahoo! Inc. | Systems and methods for search query processing using trend analysis |
US7383262B2 (en) * | 2004-06-29 | 2008-06-03 | Microsoft Corporation | Ranking database query results using probabilistic models from information retrieval |
US7567959B2 (en) * | 2004-07-26 | 2009-07-28 | Google Inc. | Multiple index based information retrieval system |
US7584175B2 (en) * | 2004-07-26 | 2009-09-01 | Google Inc. | Phrase-based generation of document descriptions |
US7426507B1 (en) * | 2004-07-26 | 2008-09-16 | Google, Inc. | Automatic taxonomy generation in search results using phrases |
US7580921B2 (en) * | 2004-07-26 | 2009-08-25 | Google Inc. | Phrase identification in an information retrieval system |
US20060074883A1 (en) * | 2004-10-05 | 2006-04-06 | Microsoft Corporation | Systems, methods, and interfaces for providing personalized search and information access |
US7809722B2 (en) * | 2005-05-09 | 2010-10-05 | Like.Com | System and method for enabling search and retrieval from image files based on recognized information |
US20070038889A1 (en) * | 2005-08-11 | 2007-02-15 | Wiggins Robert D | Methods and systems to access process control log information associated with process control systems |
US7668823B2 (en) * | 2007-04-03 | 2010-02-23 | Google Inc. | Identifying inadequate search content |
-
2007
- 2007-05-08 US US11/746,049 patent/US8126874B2/en not_active Expired - Fee Related
- 2007-05-09 WO PCT/US2007/068602 patent/WO2007134130A2/en active Application Filing
-
2012
- 2012-02-14 US US13/396,511 patent/US9262767B2/en active Active
Patent Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5983216A (en) * | 1997-09-12 | 1999-11-09 | Infoseek Corporation | Performing automated document collection and selection by providing a meta-index with meta-index values indentifying corresponding document collections |
US20040215607A1 (en) * | 2003-04-25 | 2004-10-28 | Travis Robert L. | Method and system fo blending search engine results from disparate sources into one search result |
US20050010564A1 (en) * | 2003-05-19 | 2005-01-13 | Netezza Corporation | Limiting scans of loosely ordered and/or grouped relations using nearly ordered maps |
Cited By (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
EP2389624A1 (en) * | 2009-01-22 | 2011-11-30 | Alibaba Group Holding Limited | Sampling analysis of search queries |
JP2012515978A (en) * | 2009-01-22 | 2012-07-12 | アリババ・グループ・ホールディング・リミテッド | Sampling analysis of search queries |
EP2389624A4 (en) * | 2009-01-22 | 2013-02-13 | Alibaba Group Holding Ltd | Sampling analysis of search queries |
US20120284305A1 (en) * | 2010-01-19 | 2012-11-08 | Nec Corporation | Trend information search device, trend information search method and recording medium |
JP2012014355A (en) * | 2010-06-30 | 2012-01-19 | Yahoo Japan Corp | Device and method for discriminating spam id address and device and method for discriminating spam query |
Also Published As
Publication number | Publication date |
---|---|
US8126874B2 (en) | 2012-02-28 |
US20120215765A1 (en) | 2012-08-23 |
US20110040733A1 (en) | 2011-02-17 |
US9262767B2 (en) | 2016-02-16 |
WO2007134130A3 (en) | 2008-10-09 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US9262767B2 (en) | Systems and methods for generating statistics from search engine query logs | |
Jansen et al. | Defining a session on Web search engines | |
US8478737B2 (en) | Segmentation of search topics in query logs | |
US10002189B2 (en) | Method and apparatus for searching using an active ontology | |
US8949251B2 (en) | System for and method of identifying closely matching textual identifiers, such as domain names | |
Koshman et al. | Web searching on the Vivisimo search engine | |
US8751470B1 (en) | Context sensitive ranking | |
CN100541495C (en) | A kind of searching method of individual searching engine | |
US20090287645A1 (en) | Search results with most clicked next objects | |
US8868570B1 (en) | Selection and display of online content items | |
WO2007001128A1 (en) | Method and system for determining relation between search terms in the internet search system | |
US20080065602A1 (en) | Selecting advertisements for search results | |
US20090193007A1 (en) | Systems and methods for ranking search engine results | |
GB2339938A (en) | Collecting information about document retrievals over the World Wide Web | |
WO2007124430A2 (en) | Search techniques using association graphs | |
US8121991B1 (en) | Identifying transient paths within websites | |
Mortazavi-Asl | Discovering and mining user web-page traversal patterns | |
US7139972B2 (en) | Preemptive downloading of web pages with terms associated with user interest keywords | |
US10108716B1 (en) | Systems and methods for providing stock ticker information | |
CN103646034A (en) | Web search engine system and search method based content credibility | |
US20110258187A1 (en) | Relevance-Based Open Source Intelligence (OSINT) Collection | |
US8909795B2 (en) | Method for determining validity of command and system thereof | |
Maheswari et al. | Algorithm for Tracing Visitors' On-Line Behaviors for Effective Web Usage Mining | |
JP2003173351A (en) | Method, device, program and storage medium for analysis, collection and retrieval of information | |
Raiyani et al. | Enhance preprocessing technique Distinct user identification using web log usage data |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
121 | Ep: the epo has been informed by wipo that ep was designated in this application |
Ref document number: 07762074Country of ref document: EPKind code of ref document: A2 |
|
NENP | Non-entry into the national phase in: |
Ref country code: DE |
|
122 | Ep: pct application non-entry in european phase |
Ref document number: 07762074Country of ref document: EPKind code of ref document: A2 |