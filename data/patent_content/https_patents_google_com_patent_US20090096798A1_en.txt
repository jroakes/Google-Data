US20090096798A1 - Graphics Processing and Display System Employing Multiple Graphics Cores on a Silicon Chip of Monolithic Construction - Google Patents
Graphics Processing and Display System Employing Multiple Graphics Cores on a Silicon Chip of Monolithic Construction Download PDFInfo
- Publication number
- US20090096798A1 US20090096798A1 US11/883,104 US88310406A US2009096798A1 US 20090096798 A1 US20090096798 A1 US 20090096798A1 US 88310406 A US88310406 A US 88310406A US 2009096798 A1 US2009096798 A1 US 2009096798A1
- Authority
- US
- United States
- Prior art keywords
- gpu
- graphics
- graphic
- pipeline cores
- data
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Abandoned
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06T—IMAGE DATA PROCESSING OR GENERATION, IN GENERAL
- G06T15/00—3D [Three Dimensional] image rendering
- G06T15/005—General purpose rendering architectures
Definitions
- FIG. 1A shows a block diagram of a conventional graphic system as part of PC architecture, comprising of CPU ( 111 ), system memory ( 112 ), I/O chipset ( 113 ), high speed CPU-GPU bus ( 114 ) (e.g. PCI express 16 ⁇ ), video (graphic) card ( 115 ) based on a single GPU, and display ( 116 ).
- the single GPU graphic pipeline decomposes into two major parts: a geometry subsystem for processing 3D graphics primitives (e.g. polygons) and a pixel subsystem for computing pixel values. These two parts are consistently designed for increased parallelism.
- the graphics databases are regular, typically consisting of a large number of primitives that receive nearly identical processing; therefore the natural concurrency is to partition the data into separate streams and to process them independently.
- image parallelism has long been an attractive approach for high-speed rasterization architectures, since pixels can be generated in parallel in many ways.
- An example of a highly parallel Graphic Processing Unit chip (GPU) in prior art is depicted in FIG. 2A (taken from 3 D Architecture White Paper , by ATI).
- the geometry subsystem consists of six (6) parallel pipes while the pixel subsystem has sixteen (16) parallel pipes.
- the “converge stage” 221 between these two subsystems is very problematic as it must handle the full data stream bandwidth.
- the multiple streams of transformed and clipped primitives must be directed to the processors doing rasterization. This can require sorting primitives based on spatial information while different processors are assigned to different screen regions.
- a second difficulty in the parallel pixel stage is that ordering of data may change as those data pass through parallel processors. For example, one processor may transform two small primitives before another processor transforms a single, large one. Certain global commands, such as commands to update one window instead of another, or to switch between double buffers, require that data be synchronized before and after command. This converge stage between the geometry and pixel stages, restricts the parallelism in a single GPU.
- a typical technology increasing the level of parallelism employs multiple GPU-cards, or multiple GPU chips on a card, where the rendering performance is additionally improved, beyond the converge limitation in a single core GPU.
- This technique is practiced today by several academic researches (e.g. Chromium parallel graphics system by Stanford University) and commercial products (e.g. SLI—a dual GPU system by Nvidia, Crossfire—a dual GPU by ATI).
- FIG. 3 shows a commercial dual GPU system, Asus A8N-SLI, based on Nvidia SLI technology.
- FIG. 2C indicates typical bottlenecks in a graphic pipeline that breaks-down into segmented stages of bus transfer, geometric processing and fragment fill bound processing.
- a given pipeline is only as strong as the weakest link of one of the above stages, thus the main bottleneck determines overall throughput.
- pipeline bottlenecks stem from: ( 231 ) geometry, texture, animation and meta data transfer, ( 232 ) geometry data memory limits, ( 233 ) texture data memory limits, ( 234 ) geometry transformations, and ( 235 ) fragment rendering.
- a primary object of the present invention is to provide a novel method of and apparatus for high-speed graphics processing and display, which avoid the shortcomings and drawbacks of prior art apparatus and methodologies.
- Another object of the present invention is to provide a novel graphics processing and display system having multiple graphics cores with unlimited graphics parallelism, getting around the inherent converge bottleneck of a single GPU system.
- Another object of the present invention is to provide a novel graphics processing and display system which ensures the best graphics performance, eliminating the shortages of a multi-chip system, the restricted bandwidth of inter-GPU communication, mechanical complexity (size, power, and heat), redundancy of components, and high cost.
- Another object of the present invention is to provide a novel graphics processing and display system that has an amplified graphics processing and display power by parallelizing multiple graphic cores in a single silicon chip.
- Another object of the present invention is to provide a novel graphics processing and display system that is realized on a silicon chip having a non-restricted number of multiple graphic cores.
- Another object of the present invention is to provide a novel graphics processing and display system that is realized on a silicon chip which utilizes a cluster of multiple graphic cores.
- Another object of the present invention is to provide a novel graphics processing and display system that is realized on a silicon chip having multiple graphic cores or pipes (i.e. a multiple-pipe system-on-chip, or MP-SOC) and providing architectural flexibility to achieve the advanced parallel graphics display performance.
- a novel graphics processing and display system that is realized on a silicon chip having multiple graphic cores or pipes (i.e. a multiple-pipe system-on-chip, or MP-SOC) and providing architectural flexibility to achieve the advanced parallel graphics display performance.
- Another object of the present invention is to provide a novel graphics processing and display system that is realized on a silicon chip having multiple graphic cores, and adaptively supporting different modes of parallelism within both its geometry and pixel processing subsystems.
- Another object of the present invention is to provide a novel graphics processing and display system that is realized on a silicon chip having multiple GPU cores, and providing adaptivity for highly advanced graphics processing and display performance.
- Another object of the present invention is to provide a novel graphics processing and display system and method, wherein the graphic pipeline bottlenecks of vertex (i.e. 3D polygon geometry) processing and fragment processing are transparently and intelligently resolved.
- vertex i.e. 3D polygon geometry
- Another object of the present invention to provide a method and system for an intelligent decomposition of data and graphic commands, preserving the basic features of graphic libraries as state machines and tightly sticking to the graphic standard.
- Another object of the present invention to provide a new PCI graphics card supporting a graphics processing and display system realized on a silicon chip having multiple graphic cores, and providing architectural flexibility to achieve the best parallel performance.
- Another object of the present invention to provide a computing system having improved graphics processing and display capabilities, employing a graphics card having a silicon chip with multiple graphic cores, and providing architectural flexibility to achieve the best parallel performance.
- Another object of the present invention to provide such a computing system having improved graphics processing and display performance required by applications including, video-gaming, virtual reality, scientific visualization, and other interactive application requiring or demanding photo-realistic graphics display capabilities.
- FIG. 1A is a schematic representation of a prior art, standard PC architecture, in which its conventional single GPU graphic card is shown circled;
- FIG. 1B is a simplified block diagram of a prior art conventional graphics system employing a single GPU, having geometry and pixel processing subsystems, wherein the data converge stream therebetween presents a serious system bottleneck that significantly limits performance;
- FIG. 2A is a schematic diagram illustrating high parallelism in a typical prior art ATI X800 Graphic Processing Unit chip (GPU), wherein the geometry subsystem consists of 6 parallel pipes and the pixel subsystem consists of 16 parallel pipes;
- GPU Graphic Processing Unit chip
- FIG. 2B is a schematic diagram of the internal portion of a prior art graphic processing unit (GPU) chip (e.g. ATI X800) illustrating the bottlenecking converge stage (setup engine) between geometric and pixel parallel engines therein;
- GPU graphic processing unit
- FIG. 2C is a schematic representation of a conventional graphics pipeline, illustrating the data bottleneck problem existing therein;
- FIG. 3 is a photograph of a prior art dual GPU-driven video graphics card
- FIG. 4A is a schematic system block diagram representation of a computing system employing a printed circuit graphics card employing the multiple-pipe system-on-chip (MP-SOC) device in accordance with the principles of the present invention, wherein the system block diagram shows the CPU, I/O chipset, system memory, graphic card based on MP-SOC, and display screen(s);
- MP-SOC multiple-pipe system-on-chip
- FIG. 4B is schematic representation of the physical implementation of the MP-SOC of the present invention, mounted on a printed circuit (PC) video graphics board;
- PC printed circuit
- FIG. 4C is a photograph of a standard PCI express graphics slot on a motherboard to which MP-SOC-based PC graphics board of the present invention is interconnected;
- FIG. 4D is a schematic representation of an exemplary MP-SOC silicon-layout including four GPU-driven pipeline cores according to the principles of the present invention
- FIG. 4E is a schematic representation of an exemplary packaging of the MP-SOC chip of the present invention.
- FIG. 5 is a schematic block diagram of the MP-SOC architecture, according to the illustrative embodiment of the present invention.
- FIG. 6 is the software block diagram of MP-SOC based computing system, according to the illustrative embodiment of the present invention.
- FIG. 7A is a schematic block diagram further illustrating the modules that comprise the multi-pipe software drivers of MP-SOC based system of the illustrative embodiment of the present invention.
- FIG. 7B is a flow chart illustrating the steps carried out by the mechanism that runs the three parallelization modes (i.e. Object Division, Image Division and Time Division) within the MP-SOC-based devices and systems of the present invention
- FIG. 8 is a schematic representation illustrating the object-division configuration of the MP-SOC system of the present invention.
- FIG. 9 is a schematic representation illustrating the image-division configuration of the MP-SOC system of the present invention.
- FIG. 10 is a schematic representation illustrating the time-division configuration of the MP-SOC system of the present invention.
- FIG. 11 is a flowchart illustrating the process for distributing polygons between multiple GPU-driven pipeline cores along the MP-SOC-based system of the present invention.
- FIG. 12 shows an example of eight (8) GPU-driven pipeline cores arranged as a combination of parallel modes, in accordance with the principles of the present invention.
- WO 2004/070652 A2 incorporated herein by reference, teaches the use of compositing image mechanism based on associative decision making, to provide fast and non-expensive re-compositing of frame buffers as part of Object Division parallelism.
- the benefits of this novel alternative approach include VLSI-based miniaturization of multi-GPU clusters, high bandwidth of inter-GPU communication, lower power and heat dissipation, no redundancy of components, and low cost. Details on practicing this alternative approach will now be described below.
- the present invention disclosed herein teaches an improved way of and a means for parallelizing graphics functions on a semiconductor level, as a multiple graphic pipeline architecture realized on a single chip, preferably of monolithic construction.
- a multiple graphic pipeline architecture realized on a single chip, preferably of monolithic construction.
- MP-SOC multi-pipe system on chip
- This system “on a silicon chip” comprises a cluster of GPU-driven pipeline cores organized in flexible topology, allowing different parallelization schemes. Theoretically, the number of pipeline cores is unlimited, restricted only by silicon area considerations.
- the MP-SOC is driven by software driver modes, which re resident to the host CPU.
- the variety of parallelization schemes enables performance optimization. These schemes are time, image and object division, and derivatives of thereof.
- the illustrative embodiment of the present invention enjoys the advantages of a multi GPU chip, namely: bypassing the converge limitation of a single GPU, while at the same time it gets rid of the inherent problems of a multi-GPU system, such as restricted bandwidth of inter-GPU communication, mechanical complexity (size, power, and heat), redundancy of components, and high cost.
- the physical graphic system of the present embodiment comprises of a conventional motherboard ( 418 ) and MP-SOC based graphic card ( 415 ).
- the motherboard carries the usual set of components, which are CPU ( 411 ), system memory ( 412 ), I/O chipset ( 413 ), and other non-graphic components as well (see FIG. 1A for the complete set of components residing on a PC motherboard).
- the printed circuit graphic card based on the MP-SOC chip 416 connects to the motherboard via a PCI express 16 ⁇ lanes connector ( 414 ).
- the card has also an output to at least one screen ( 416 ).
- the MP-SOC graphic card replaces the conventional single-GPU graphic card on the motherboard.
- FIG. 4B shows a possible physical implementation of the present invention.
- a standard form PC card ( 421 ) on which the MP-SOC ( 422 ) is mounted connects to the motherboard ( 426 ) of the host computing system, via PCI express 16 ⁇ lanes connector ( 423 ).
- the display screen is connected via standard DVI connector ( 424 ). Since the multiple pipelines on MP-SOC are anticipated to consume high power, for which the standard supply via PCI express connector is not adequate, an auxiliary power is supplied to the card via dedicated power cable ( 425 ).
- FIG. 4C shows the PCI express connector ( 431 ) on a motherboard to which a MP-SOC based card connects. It should be emphasized that the standard physical implementation of MP-SOC on a PC card makes it an easy and natural replacement of the prior art GPU-driven video graphics cards.
- FIGS. 4D and 4E describe an artist's concept of the MP-SOC chip to further illustrate a physical implementation of the semiconductor device.
- FIG. 4D shows a possible MP-SOC silicon layout.
- FIG. 4E shows possible packaging and appearance of the MP-SOC chip.
- this chip along with other peripheral components (e.g. memory chips, bus chips, etc.) intends to be mounted on a standard sized PCB (printed circuit board) and used as a sole graphic card in a PC system, replacing prior art video graphics cards. Production of MP-SOC based cards can be carried out by graphic card manufacturers (e.g. AsusTech, Gigabyte).
- the multi-pipe-SOC architecture consists of the following components:
- the software of the system comprises the graphic application, graphics library (e.g. graphic standards OpenGL or DirectX), and proprietary soft driver (multi-pipe driver).
- graphics library e.g. graphic standards OpenGL or DirectX
- proprietary soft driver multi-pipe driver
- FIG. 7 shows a functional block diagram presenting the main tasks of the multi-pipe driver, according to an embodiment the present invention.
- the multi-pipe driver carries on at least the following actions:
- a major feature of the present invention is its topological flexibility which enables revamping of performance bottlenecks. Such flexibility is gained by rearranging the cluster of graphics pipelines by means of routing center and different merging schemes at the compositing unit. Different parallelization schemes affect different performance bottlenecks. Therefore bottlenecks, identified by the profiling module, can be cured by utilizing the corresponding parallelization scheme.
- the flowchart of FIG. 7B describes the mechanism that runs the three parallel modes: Object Division, Image Division and Time Division.
- the mechanism combines the activity of soft driver modules with MP-SOC units.
- the cycle of the flowchart is one frame.
- the mode to begin with is the Object Division (OD), since it is the preferred parallel mode, as it will be explained hereinafter.
- the profiling and analysis of the application is constantly on, under control of the soft Profile and Analysis module (S-PA). Every frame the Parallel Policy Management (S-PPM) module checks for the optimal mode, to choose from the three parallelization modes.
- S-PA Soft Profile and Analysis module
- the Distributed Graphic Functions Control (S-DGFC) module configures the entire system for OD, characterized by distribution of geometric data and the compositing algorithm in use. This configuration is shown in FIG. 8 , and described in detail later on.
- the S-DGFC module decomposes the geometric data into partitions, each sent by the Routing unit (C-RC) to different GPU-driven pipe core (C-PC) for rendering.
- the rendered stream of data is monitored by the State Monitoring (S-SM) module for blocking commands, as shown in FIG. 11 , and described in great detail hereinafter.
- the left path in the flowchart is Image Division (ID) operation.
- ID Image Division
- the ID configuration as set by the S-DGFC, is also shown in FIG. 9 , and described later in greater detail. It is characterized by broadcasting of the same data among all pipe cores, and by image based compositing algorithm. The partitioning of image among pipe cores is done by S-DGFC. The data is broadcast by the Routing Center, and then rendered at pipe cores (C-PC), while each one is designated another portion of image. Upon accomplishing of rendering, the C-Ctrl moves the partial FBs to compositing unit (C-CU) for reconstruction of the complete image. Then C-DI moves the FB to Display. Finally the Change test is performed by S-PS and S-PPM modules. Pending the result, a new frame will continue the ID mode, or switch to another mode.
- the Time Division mode alternates frames among the GPU-driven pipe cores. It is set for alternation by the S-GDFC module, while each core is designated a frame data by S-DGFC and delivered by the C-RC unit. Each core (C-PC) generates a frame, in a line. Then the C-Ctrl moves the matured FB via compositing unit to the Display Interface, and out to the display. Actually, the compositing unit in this mode acts just as a transit. Finally there is a change-mode test by S-PA and S-PPM modules, same as in the other modes before.
- FIG. 8 describes the object-division parallelization scheme.
- the soft driver and specifically the Distributed Graphic Functions Control module, breaks down the polygon data of a scene into N partial streams (N—the number of participating pipeline cores).
- N the number of participating pipeline cores.
- the entire data is sent, by the GPU Drivers module, to the MP-SOC Routing Center, which distributes the data to N pipeline cores for rendering, according to the soft driver's partition, each of approximately 1/N polygons.
- Rendering in the pipeline cores is done under the monitoring of State Monitoring module of the soft driver ( FIG. 11 and detailed description below).
- the resultant full frame buffers are gathered in the Compositing Unit. They are depth-composed, pixel by pixel to find the final set of visible pixels. At each x-y coordinate all hidden pixels are eliminated by compositing mechanism.
- the final frame buffer is moved out to display.
- FIG. 9 describes the image-division parallelization scheme, which is chosen by Parallelism Policy Management module, as a result of profiling, analysis, and decision making in the Profiling and Analysis module of the soft driver.
- Each pipeline core is designated a unique 1/N part of the screen.
- the complete polygon data is delivered to each of the pipeline cores via the GPU Driver module and Routing Center.
- the parallel rendering in pipeline cores results in partial frame buffer at each.
- the image segments are moved to the Compositing Unit for 2D merging into a single image and moved out to the display.
- FIG. 10 describes the time-division parallelization scheme which is chosen by Parallelism Policy Management module, as a result of profiling, analysis, and decision making in the Profiling and Analysis module of the soft driver.
- the Compositing unit functions here as a simple switch, alternating the access to the Display among all the pipeline cores.
- the profiler identifies problem areas within the graphics system which cause bottlenecks. It is implemented in the Application Profiling and Analysis module of the driver.
- the profiler module requires such inputs as usage of graphic API commands (e.g. OpenGL, DirectX, other), memory speed, memory usage in bytes, total pixels rendered, geometric data entering rendering, frame rate, workload of each GPU, load balance among GPUs, volumes of transferred data, textures count, and depth complexity, etc.
- object-division method supersedes the other division modes in that it reduces more bottlenecks.
- the object-division relaxes virtually all bottleneck across the pipeline: (i) the geometry (i.e. polygons, lines, dots, etc) transform processing is offloaded at each pipeline, handling only 1/N of polygons (N—number of participating pipeline cores); (ii) fill bound processing is reduced since less polygons are feeding the rasterizer, (iii) less geometry memory is needed; (iv) less texture memory is needed.
- time-division method releases bottlenecks by allowing to each pipeline core more time per frame generation, however this method suffers from severe problems such as CPU bottlenecks, the pipeline cores generated frame buffers that are not available to each other, and there are frequent cases of pipeline latency. Therefore this method is not suitable to all applications. Consequently, due to its superiority as bottleneck opener, object-division becomes the primary parallel mode.
- the following object division algorithm distributes polygons among the multiple graphic pipeline cores.
- Typical application generates a stream of graphic calls that includes blocks of graphic data; each block consists of a list of geometric operations, such as single vertex operations or buffer based operations (vertex array).
- the decomposition algorithm splits the data between pipeline cores preserving the blocks as basic data units.
- Geometric operations are attached to the block(s) of data, instructing the way the data is handled.
- a block is directed to designated GPU.
- there are operations belonging to the group of Blocking Operations such as Flush, Swap, Alpha blending, which affect the entire graphic system, setting the system to blocking mode.
- Blocking operations are exceptional in that they require a composed valid FB data, thus in the parallel setting of the present invention, they have an effect on all pipeline cores. Therefore, whenever one of the Blocking operations is issued, all the pipeline cores must be synchronized.
- Each frame has at least 2 blocking operations: Flush and Swap, which terminate the frame.
- FIG. 11 presents a flowchart describing an algorithm for distributing polygons among multiple GPU-driven pipeline cores, according to an illustrative embodiment of the present invention.
- the frame activity starts with distributing blocks of data among GPUs.
- Each graphic operation is tested for blocking mode at step 112 .
- a regular path non-blocking path
- data is redirected to the designated pipeline core at step 1113 . This loop is repeated until a blocking operation is detected.
- the Swap operation activates the double buffering mechanism, swapping the back and front color buffers. If Swap is detected at step 1115 , it means that the composited frame must be terminated at all pipeline cores, except pipeline 0 . All pipeline cores have the final composed contents of a FB designated to store said contents, but only the one connected to the screen (pipeline 0 ) displays the image at step 1116 .
- Another case is operations that are applied globally to the scene and need to be broadcasted to all the pipeline cores. If one of the other blocking operations is identified, such as Alpha blending for transparency, then all pipeline cores are flushed as before at step 1114 , and merged into a common FB. This time the Swap operation is not detected (step 1115 ), therefore all pipeline cores have the same data, and as long as the blocking mode is on (step 1117 ), all of them keep processing the same data (step 1118 ). If the end of the block mode is detected at step 1117 , pipeline cores return working on designated data (step 1113 ).
- Depth complexity is the number of fragment replacements as a result of depth tests (the number of polygons drawn on every pixel). In the ideal case of no fragment replacement (e.g. all polygons of the scene are located on the same depth level), the fill is reduced according to the reduced number of polygons (as for 2 pipeline cores).
- depth complexity is getting high, the advantage of object-division drops down, and in some cases the image-division may even perform better, e.g. applications with small number of polygons and high volume of textures.
- the present invention introduces a dynamic load-balancing technique that combines the object division method with the image division and time division methods in image and time domains, based on the load exhibits by previous processing stages. Combining all the three parallel methods into a unified framework dramatically increases the frame rate stability of the graphic system.
- FIG. 12 discloses a sample configuration of the system, employing 8 pipeline cores, according to an embodiment of the present invention.
- the pipeline cores are divided into two groups for time division parallelism. Pipeline cores indexed with 1 , 2 , 3 , and 4 are configured to process even frames and pipeline cores indexed with 5 , 6 , 7 , and 8 are configured to process odd frames.
- two pipeline core subgroups are set for image division: the pipeline cores with the lower indexes ( 1 , 2 and 5 , 6 respectively) are configured to process half of the screen, and the high-indexed pipeline cores ( 3 , 4 and 7 , 8 respectively) are configured to process the other half.
- pipeline cores indexed with 1 , 3 , 5 and 7 are fed with half of the objects
- pipeline cores indexed with 2 , 4 , 6 and 8 are fed with the other half of the objects.
- pipeline cores are reconfigured, so that each pipeline core will render a quarter of the screen within the respective frame.
- the original partition for time division, between pipeline cores 1 , 2 , 3 , 4 and between 5 , 6 , 7 , 8 still holds, but pipeline core 2 and pipeline core 5 are configured to render the first quarter of screen in even and odd frames respectively.
- Pipeline cores 1 and 6 render the second quarter
- pipeline cores 4 and 7 the third quarter
- pipeline cores 3 and 8 the forth quarter. No object division is implied.
- pipeline cores are reconfigured, so that each pipeline core will process a quarter of the geometrical data within the respective frame. That is, pipeline cores 3 and 5 are configured to process the first quarter of the polygons in even and odd frames respectively.
- Pipeline cores 1 and 7 render the second quarter
- pipeline cores 4 and 6 the third quarter
- pipeline cores 2 and 8 the forth quarter. No image division is implied.
- any combination between the parallel modes can be scheduled to evenly balance the graphic load.
- the parallelization process between all pipeline cores may be based on an object division mode or image division mode or time division mode or any combination thereof in order to optimize the processing performance of each frame.
- the decision on parallel mode is done on a per-frame basis, based on the above profiling and analysis. It is then carried out by reconfiguration of the parallelization scheme, as described above and shown in FIGS. 8 , 9 , 10 and 12 .
- the MP-SOC architecture described in great detail hereinabove can be readily adapted for use in diverse kinds of graphics processing and display systems. While the illustrative embodiments of the present invention have been described in connection with PC-type computing systems, it is understood that the present invention can be use improve graphical performance in diverse kinds of systems including mobile computing devices, embedded systems, and as well as scientific and industrial computing systems supporting graphic visualization of photo-realistic quality.
Abstract
A high performance graphics processing and display system architecture realized on a monolithic silicon chip, supporting a cluster of multiple cores of graphic processing units (GPUs) that cooperate to provide a powerful and highly scalable visualization solution supporting photo-realistic graphics capabilities for diverse applications. The present invention eliminates rendering bottlenecks along the graphics pipeline by dynamically managing various parallel rendering techniques and enabling adaptive handling of diverse graphics applications.
Description
- Over the past few decades, much of the research and development in the graphics architecture field has been concerned the ways to improve the performance of three-dimensional (3D) computer graphics rendering. Graphics architecture is driven by the same advances in semiconductor technology that have driven general-purpose computer architecture. Many of the same acceleration techniques have been used in this field, including pipelining and parallelism. The graphics rendering application, however, imposes special demands and makes available new opportunities. For example, since image display generally involves a large number of repetitive calculations, it can more easily exploit massive parallelism than can general-purpose computations.
- In high-performance graphics systems, the number of computations highly exceeds the capabilities of a single processing unit, so parallel systems have become the rule of graphics architectures. A very high-level of parallelism is applied today in silicon-based graphics processing units (GPU), to perform graphics computations.
- Typically these computations are performed by graphics pipeline, supported by video memory, which are part of a graphic system.
FIG. 1A shows a block diagram of a conventional graphic system as part of PC architecture, comprising of CPU (111), system memory (112), I/O chipset (113), high speed CPU-GPU bus (114) (e.g. PCI express 16×), video (graphic) card (115) based on a single GPU, and display (116). The single GPU graphic pipeline, as shown inFIG. 1B , decomposes into two major parts: a geometry subsystem for processing 3D graphics primitives (e.g. polygons) and a pixel subsystem for computing pixel values. These two parts are consistently designed for increased parallelism. - In the geometry subsystem, the graphics databases are regular, typically consisting of a large number of primitives that receive nearly identical processing; therefore the natural concurrency is to partition the data into separate streams and to process them independently. In the pixel subsystem, image parallelism has long been an attractive approach for high-speed rasterization architectures, since pixels can be generated in parallel in many ways. An example of a highly parallel Graphic Processing Unit chip (GPU) in prior art is depicted in
FIG. 2A (taken from 3D Architecture White Paper, by ATI). The geometry subsystem consists of six (6) parallel pipes while the pixel subsystem has sixteen (16) parallel pipes. - However, as shown in
FIG. 2B , the “converge stage” 221 between these two subsystems is very problematic as it must handle the full data stream bandwidth. In the pixel subsystem, the multiple streams of transformed and clipped primitives must be directed to the processors doing rasterization. This can require sorting primitives based on spatial information while different processors are assigned to different screen regions. A second difficulty in the parallel pixel stage is that ordering of data may change as those data pass through parallel processors. For example, one processor may transform two small primitives before another processor transforms a single, large one. Certain global commands, such as commands to update one window instead of another, or to switch between double buffers, require that data be synchronized before and after command. This converge stage between the geometry and pixel stages, restricts the parallelism in a single GPU. - A typical technology increasing the level of parallelism employs multiple GPU-cards, or multiple GPU chips on a card, where the rendering performance is additionally improved, beyond the converge limitation in a single core GPU. This technique is practiced today by several academic researches (e.g. Chromium parallel graphics system by Stanford University) and commercial products (e.g. SLI—a dual GPU system by Nvidia, Crossfire—a dual GPU by ATI).
FIG. 3 shows a commercial dual GPU system, Asus A8N-SLI, based on Nvidia SLI technology. - Parallelization is capable of increasing performance by releasing bottlenecks in graphic systems.
FIG. 2C indicates typical bottlenecks in a graphic pipeline that breaks-down into segmented stages of bus transfer, geometric processing and fragment fill bound processing. A given pipeline is only as strong as the weakest link of one of the above stages, thus the main bottleneck determines overall throughput. As indicated inFIG. 2C , pipeline bottlenecks stem from: (231) geometry, texture, animation and meta data transfer, (232) geometry data memory limits, (233) texture data memory limits, (234) geometry transformations, and (235) fragment rendering. - There are different ways to parallelize the GPUs, such as: time-division (each GPU renders the next successive frame); image-division (each GPU renders a subset of the pixels of each frame); and object-division (each GPU renders a subset of the whole data, including geometry and textures), and derivatives and combinations of thereof. Although promising, this approach of parallelizing cluster or GPU chips suffers from some inherent problems, such as: restricted bandwidth of inter-GPU communication; mechanical complexity (e.g. size, power, and heat); redundancy of components; and high cost.
- Thus, there is a great need in the art for an improved method of and apparatus for high-speed graphics processing and display, which avoids the shortcomings and drawbacks of such prior art apparatus and methodologies.
- Accordingly, a primary object of the present invention is to provide a novel method of and apparatus for high-speed graphics processing and display, which avoid the shortcomings and drawbacks of prior art apparatus and methodologies.
- Another object of the present invention is to provide a novel graphics processing and display system having multiple graphics cores with unlimited graphics parallelism, getting around the inherent converge bottleneck of a single GPU system.
- Another object of the present invention is to provide a novel graphics processing and display system which ensures the best graphics performance, eliminating the shortages of a multi-chip system, the restricted bandwidth of inter-GPU communication, mechanical complexity (size, power, and heat), redundancy of components, and high cost.
- Another object of the present invention is to provide a novel graphics processing and display system that has an amplified graphics processing and display power by parallelizing multiple graphic cores in a single silicon chip.
- Another object of the present invention is to provide a novel graphics processing and display system that is realized on a silicon chip having a non-restricted number of multiple graphic cores.
- Another object of the present invention is to provide a novel graphics processing and display system that is realized on a silicon chip which utilizes a cluster of multiple graphic cores.
- Another object of the present invention is to provide a novel graphics processing and display system that is realized on a silicon chip having multiple graphic cores or pipes (i.e. a multiple-pipe system-on-chip, or MP-SOC) and providing architectural flexibility to achieve the advanced parallel graphics display performance.
- Another object of the present invention is to provide a novel graphics processing and display system that is realized on a silicon chip having multiple graphic cores, and adaptively supporting different modes of parallelism within both its geometry and pixel processing subsystems.
- Another object of the present invention is to provide a novel graphics processing and display system that is realized on a silicon chip having multiple GPU cores, and providing adaptivity for highly advanced graphics processing and display performance.
- Another object of the present invention is to provide a novel graphics processing and display system and method, wherein the graphic pipeline bottlenecks of vertex (i.e. 3D polygon geometry) processing and fragment processing are transparently and intelligently resolved.
- Another object of the present invention to provide a method and system for an intelligent decomposition of data and graphic commands, preserving the basic features of graphic libraries as state machines and tightly sticking to the graphic standard.
- Another object of the present invention to provide a new PCI graphics card supporting a graphics processing and display system realized on a silicon chip having multiple graphic cores, and providing architectural flexibility to achieve the best parallel performance.
- Another object of the present invention to provide a computing system having improved graphics processing and display capabilities, employing a graphics card having a silicon chip with multiple graphic cores, and providing architectural flexibility to achieve the best parallel performance.
- Another object of the present invention to provide such a computing system having improved graphics processing and display performance required by applications including, video-gaming, virtual reality, scientific visualization, and other interactive application requiring or demanding photo-realistic graphics display capabilities.
- These and other objects and advantages of the present invention will become apparent hereinafter.
- For a more complete understanding of how to practice the Objects of the Present Invention, the following Detailed Description of the Illustrative Embodiments can be read in conjunction with the accompanying Drawings, briefly described below, wherein:
-
FIG. 1A is a schematic representation of a prior art, standard PC architecture, in which its conventional single GPU graphic card is shown circled; -
FIG. 1B is a simplified block diagram of a prior art conventional graphics system employing a single GPU, having geometry and pixel processing subsystems, wherein the data converge stream therebetween presents a serious system bottleneck that significantly limits performance; -
FIG. 2A is a schematic diagram illustrating high parallelism in a typical prior art ATI X800 Graphic Processing Unit chip (GPU), wherein the geometry subsystem consists of 6 parallel pipes and the pixel subsystem consists of 16 parallel pipes; -
FIG. 2B is a schematic diagram of the internal portion of a prior art graphic processing unit (GPU) chip (e.g. ATI X800) illustrating the bottlenecking converge stage (setup engine) between geometric and pixel parallel engines therein; -
FIG. 2C is a schematic representation of a conventional graphics pipeline, illustrating the data bottleneck problem existing therein; -
FIG. 3 is a photograph of a prior art dual GPU-driven video graphics card; -
FIG. 4A is a schematic system block diagram representation of a computing system employing a printed circuit graphics card employing the multiple-pipe system-on-chip (MP-SOC) device in accordance with the principles of the present invention, wherein the system block diagram shows the CPU, I/O chipset, system memory, graphic card based on MP-SOC, and display screen(s); -
FIG. 4B is schematic representation of the physical implementation of the MP-SOC of the present invention, mounted on a printed circuit (PC) video graphics board; -
FIG. 4C is a photograph of a standard PCI express graphics slot on a motherboard to which MP-SOC-based PC graphics board of the present invention is interconnected; -
FIG. 4D is a schematic representation of an exemplary MP-SOC silicon-layout including four GPU-driven pipeline cores according to the principles of the present invention; -
FIG. 4E is a schematic representation of an exemplary packaging of the MP-SOC chip of the present invention; -
FIG. 5 is a schematic block diagram of the MP-SOC architecture, according to the illustrative embodiment of the present invention; -
FIG. 6 is the software block diagram of MP-SOC based computing system, according to the illustrative embodiment of the present invention; -
FIG. 7A is a schematic block diagram further illustrating the modules that comprise the multi-pipe software drivers of MP-SOC based system of the illustrative embodiment of the present invention; -
FIG. 7B is a flow chart illustrating the steps carried out by the mechanism that runs the three parallelization modes (i.e. Object Division, Image Division and Time Division) within the MP-SOC-based devices and systems of the present invention; -
FIG. 8 is a schematic representation illustrating the object-division configuration of the MP-SOC system of the present invention; -
FIG. 9 is a schematic representation illustrating the image-division configuration of the MP-SOC system of the present invention; -
FIG. 10 is a schematic representation illustrating the time-division configuration of the MP-SOC system of the present invention; -
FIG. 11 is a flowchart illustrating the process for distributing polygons between multiple GPU-driven pipeline cores along the MP-SOC-based system of the present invention; and -
FIG. 12 shows an example of eight (8) GPU-driven pipeline cores arranged as a combination of parallel modes, in accordance with the principles of the present invention. - The techniques taught in Applicant's prior PCT application No. PCT/IL04/001069, published as WIPO Publication No. WO 2005/050557 A2, incorporated herein by reference, teaches the use of a graphics scalable Hub architecture, comprised of Hardware Hub and Software Hub Driver, which serves to glue together (i.e. functioning in parallel) off-the-shelf GPU chips for the purpose of providing a high performance and scalable visualization solution, object division decomposition algorithm, employing multiple parallel modes and combination thereof, and adaptive parallel mode management. Also, PCT Application No. PCT/IL2004/000079, published as WIPO Publication No. WO 2004/070652 A2, incorporated herein by reference, teaches the use of compositing image mechanism based on associative decision making, to provide fast and non-expensive re-compositing of frame buffers as part of Object Division parallelism.
- The approaches taught in Applicant's PCT Applications identified above have numerous advantages and benefits, namely the ability to construct powerful parallel systems by use of off-the-shelf GPUs, transparently to existing applications. However, in many applications, it will be desirable to provide such benefits in conventional graphics systems, using an alternative approach, namely: by providing PCs with a graphics processing and display architecture employing powerful graphics processing and display system realized on monolithic silicon chips, for the purpose of delivering high performance, high frame-rate stability of graphic solutions at relatively low-cost, and transparency to existing graphics applications.
- The benefits of this novel alternative approach include VLSI-based miniaturization of multi-GPU clusters, high bandwidth of inter-GPU communication, lower power and heat dissipation, no redundancy of components, and low cost. Details on practicing this alternative approach will now be described below.
- In general, the present invention disclosed herein teaches an improved way of and a means for parallelizing graphics functions on a semiconductor level, as a multiple graphic pipeline architecture realized on a single chip, preferably of monolithic construction. For convenience of expression, such a device is termed herein as a “multi-pipe system on chip” or “MP-SOC”. This system “on a silicon chip” comprises a cluster of GPU-driven pipeline cores organized in flexible topology, allowing different parallelization schemes. Theoretically, the number of pipeline cores is unlimited, restricted only by silicon area considerations. The MP-SOC is driven by software driver modes, which re resident to the host CPU. The variety of parallelization schemes enables performance optimization. These schemes are time, image and object division, and derivatives of thereof.
- The illustrative embodiment of the present invention enjoys the advantages of a multi GPU chip, namely: bypassing the converge limitation of a single GPU, while at the same time it gets rid of the inherent problems of a multi-GPU system, such as restricted bandwidth of inter-GPU communication, mechanical complexity (size, power, and heat), redundancy of components, and high cost.
- As shown in
FIG. 4A , the physical graphic system of the present embodiment comprises of a conventional motherboard (418) and MP-SOC based graphic card (415). The motherboard carries the usual set of components, which are CPU (411), system memory (412), I/O chipset (413), and other non-graphic components as well (seeFIG. 1A for the complete set of components residing on a PC motherboard). The printed circuit graphic card based on the MP-SOC chip 416) connects to the motherboard via a PCI express 16× lanes connector (414). The card has also an output to at least one screen (416). The MP-SOC graphic card replaces the conventional single-GPU graphic card on the motherboard. The way the MP-SOC graphic card integrates in a conventional PC system becomes apparent from comparingFIG. 4A withFIG. 1A By simply replacing the single-GPU graphic card (circled inFIG. 1A ) with the MP-SOC based card of the present invention, and replacing its drivers with the multi-pipe soft drivers on the host CPU (419), the system of invention is realized with all of the advantages and benefits described herein. This modification is completely transparent to the user and application, apart from the improved performance. -
FIG. 4B shows a possible physical implementation of the present invention. A standard form PC card (421) on which the MP-SOC (422) is mounted, connects to the motherboard (426) of the host computing system, via PCI express 16× lanes connector (423). The display screen is connected via standard DVI connector (424). Since the multiple pipelines on MP-SOC are anticipated to consume high power, for which the standard supply via PCI express connector is not adequate, an auxiliary power is supplied to the card via dedicated power cable (425). -
FIG. 4C shows the PCI express connector (431) on a motherboard to which a MP-SOC based card connects. It should be emphasized that the standard physical implementation of MP-SOC on a PC card makes it an easy and natural replacement of the prior art GPU-driven video graphics cards. -
FIGS. 4D and 4E describe an artist's concept of the MP-SOC chip to further illustrate a physical implementation of the semiconductor device.FIG. 4D shows a possible MP-SOC silicon layout. In this example there are 4 off-the-shelf cores of graphic pipelines. The number of cores can be scaled to any number, pending silicon area restrictions. The detailed discussion on the MP-SOC functional units is given below.FIG. 4E shows possible packaging and appearance of the MP-SOC chip. As mentioned before, this chip, along with other peripheral components (e.g. memory chips, bus chips, etc.) intends to be mounted on a standard sized PCB (printed circuit board) and used as a sole graphic card in a PC system, replacing prior art video graphics cards. Production of MP-SOC based cards can be carried out by graphic card manufacturers (e.g. AsusTech, Gigabyte). - As presented in
FIG. 5 , the multi-pipe-SOC architecture consists of the following components: -
- Routing center which is located on the CPU bus (e.g. PCI express of 16 lanes). It distributes the graphics data stream, coming from CPU among graphic pipeline cores, and then collects the rendered results (frame buffers) from cores, to the compositing unit. The way data is distributed is dictated by the control unit, depending on current parallelization mode.
- Compositing unit re-composes the partial frame buffers according to the ongoing parallelization mode.
- Control unit is under control of the CPU-resident soft multi-pipe driver. It is responsible for configuration and functioning of the entire MP-SOC system according to the parallelization mode.
- Processing element (PE) unit with internal or external memory, and optional cache memory. The PE can be any kind of processor-on-chip according to architectural needs. Besides serving the PE, the cache and memory can be used to cache graphics data common to all pipeline cores, such as textures, vertex objects, etc.
- Multiple GPU-driven pipeline cores. These cores may, but need not to be of proprietary designed. They can be originally designed as a regular single core GPU.
- Profiling functions unit. This unit delivers to the multi-pipe driver a benchmarking data such as memory speed, memory usage in bytes, total pixels rendered, geometric data entering rendering, frame rate, workload of each pipeline core, load balance among pipeline cores, volumes of transferred data, textures count, and depth complexity.
- Display interface, capable of running single or multiple screens.
- As shown in
FIG. 6 , the software of the system comprises the graphic application, graphics library (e.g. graphic standards OpenGL or DirectX), and proprietary soft driver (multi-pipe driver). The generic graphics application needs no modifications or special porting efforts to run on the MP-SOC. -
FIG. 7 shows a functional block diagram presenting the main tasks of the multi-pipe driver, according to an embodiment the present invention. The multi-pipe driver carries on at least the following actions: -
- Generic GPU drivers. Perform all the functions of a generic GPU driver associated with interaction with the Operation System, graphic library (e.g. OpenGL or DirectX), and controlling the GPUs.
- Distributed graphic functions control. This module performs all functions associated with carrying on the different parallelization modes according to parallelization policy management. In each mode, the data is differently distributed and re-composed among pipelines, as will be described in greater detail hereinafter.
- State monitoring. The graphic libraries (e.g. OpenGL and DirectX) are state machines. Parallelization must preserve cohesive state across the graphic system. It is done by continuous analysis of all incoming commands, while the state commands and some of the data must be multiplicated to all pipelines in order to preserve the valid state across the graphic pipelines. A specific problem is posed by the class called Blocking operations such as Flush, Swap, Alpha blending, which affect the entire graphic system, setting the system to blocking mode. Blocking operations are exceptional in that they require a composed valid FB data, thus in the parallel setting of the present invention, they have an effect on all pipeline cores. A more detailed description of handling Blocking operations will be given hereinafter.
- Application profiling and analysis module. This module performs real-time profiling and analysis of the running application. It continuously monitors of application parameters in the system, such as memory speed, memory usage in bytes, total pixels rendered, geometric data entering rendering, frame rate, workload of each pipeline core, load balance among graphic pipelines, volumes of transferred data, textures count, and depth complexity, etc. The profiler module identifies problem areas within the graphics system which cause bottlenecks. The profiler module requires inputs from the registers of the multi-pipe cores, registers of the MP-SOC control unit, and graphic API commands (e.g. OpenGL, DirectX).
- Parallelism policy management makes a decision on the parallel mode to be performed, on a per-frame basis, based on the above profiling and analysis. The decision is then carried out by means of the control unit in the MP-SOC.
- A major feature of the present invention is its topological flexibility which enables revamping of performance bottlenecks. Such flexibility is gained by rearranging the cluster of graphics pipelines by means of routing center and different merging schemes at the compositing unit. Different parallelization schemes affect different performance bottlenecks. Therefore bottlenecks, identified by the profiling module, can be cured by utilizing the corresponding parallelization scheme.
- The flowchart of
FIG. 7B describes the mechanism that runs the three parallel modes: Object Division, Image Division and Time Division. The mechanism combines the activity of soft driver modules with MP-SOC units. The cycle of the flowchart is one frame. The mode to begin with is the Object Division (OD), since it is the preferred parallel mode, as it will be explained hereinafter. The profiling and analysis of the application is constantly on, under control of the soft Profile and Analysis module (S-PA). Every frame the Parallel Policy Management (S-PPM) module checks for the optimal mode, to choose from the three parallelization modes. - Let us assume that the Object Division (OD) path was taken. The Distributed Graphic Functions Control (S-DGFC) module configures the entire system for OD, characterized by distribution of geometric data and the compositing algorithm in use. This configuration is shown in
FIG. 8 , and described in detail later on. The S-DGFC module decomposes the geometric data into partitions, each sent by the Routing unit (C-RC) to different GPU-driven pipe core (C-PC) for rendering. The rendered stream of data is monitored by the State Monitoring (S-SM) module for blocking commands, as shown inFIG. 11 , and described in great detail hereinafter. When the rendering is completed, all the Frame Buffers are moved by the Control Unit (C-Ctrl) to Compositing Unit (C-CU) to composite all buffers to a single one, based on depth test (as explained in detail below). The final FB is moved to Display by Display Interface Unit (C-DI). At the end of the frame the S-PA and S-PPM modules test for the option of changing the parallel mode. If decision was taken to stay with the same mode, a new OD frame starts with another data partition. Otherwise, a new test for optimal mode is performed by S-PA and S-PPM modules. - The left path in the flowchart is Image Division (ID) operation. The ID configuration, as set by the S-DGFC, is also shown in
FIG. 9 , and described later in greater detail. It is characterized by broadcasting of the same data among all pipe cores, and by image based compositing algorithm. The partitioning of image among pipe cores is done by S-DGFC. The data is broadcast by the Routing Center, and then rendered at pipe cores (C-PC), while each one is designated another portion of image. Upon accomplishing of rendering, the C-Ctrl moves the partial FBs to compositing unit (C-CU) for reconstruction of the complete image. Then C-DI moves the FB to Display. Finally the Change test is performed by S-PS and S-PPM modules. Pending the result, a new frame will continue the ID mode, or switch to another mode. - The Time Division mode alternates frames among the GPU-driven pipe cores. It is set for alternation by the S-GDFC module, while each core is designated a frame data by S-DGFC and delivered by the C-RC unit. Each core (C-PC) generates a frame, in a line. Then the C-Ctrl moves the matured FB via compositing unit to the Display Interface, and out to the display. Actually, the compositing unit in this mode acts just as a transit. Finally there is a change-mode test by S-PA and S-PPM modules, same as in the other modes before.
-
FIG. 8 describes the object-division parallelization scheme. The soft driver, and specifically the Distributed Graphic Functions Control module, breaks down the polygon data of a scene into N partial streams (N—the number of participating pipeline cores). The entire data is sent, by the GPU Drivers module, to the MP-SOC Routing Center, which distributes the data to N pipeline cores for rendering, according to the soft driver's partition, each of approximately 1/N polygons. Rendering in the pipeline cores is done under the monitoring of State Monitoring module of the soft driver (FIG. 11 and detailed description below). The resultant full frame buffers are gathered in the Compositing Unit. They are depth-composed, pixel by pixel to find the final set of visible pixels. At each x-y coordinate all hidden pixels are eliminated by compositing mechanism. The final frame buffer is moved out to display. -
FIG. 9 describes the image-division parallelization scheme, which is chosen by Parallelism Policy Management module, as a result of profiling, analysis, and decision making in the Profiling and Analysis module of the soft driver. Each pipeline core is designated a unique 1/N part of the screen. The complete polygon data is delivered to each of the pipeline cores via the GPU Driver module and Routing Center. The parallel rendering in pipeline cores results in partial frame buffer at each. The image segments are moved to the Compositing Unit for 2D merging into a single image and moved out to the display. -
FIG. 10 describes the time-division parallelization scheme which is chosen by Parallelism Policy Management module, as a result of profiling, analysis, and decision making in the Profiling and Analysis module of the soft driver. The Distributed Graphic Functions Control module, through GPU Drivers module, divides the frames into N cycles (N=number of cores) letting each core time slot of N frames for rendering the entire polygon data. Therefore the scene polygon data is distributed, via Router, to a different pipeline core at a time Each core performs rendering during N cycles, and outputs its full frame buffer to display, for a single frame. The Compositing unit functions here as a simple switch, alternating the access to the Display among all the pipeline cores. - Different parallelization schemes resolve different performance bottlenecks. Therefore bottlenecks must be identified and then eliminated (or reduced) by applying the right scheme at the right time.
- As shown in
FIG. 7B , the profiler identifies problem areas within the graphics system which cause bottlenecks. It is implemented in the Application Profiling and Analysis module of the driver. The profiler module requires such inputs as usage of graphic API commands (e.g. OpenGL, DirectX, other), memory speed, memory usage in bytes, total pixels rendered, geometric data entering rendering, frame rate, workload of each GPU, load balance among GPUs, volumes of transferred data, textures count, and depth complexity, etc. These data types are collected from the following sources within the MP-SOC based graphics system: - 1. The profiling functions unit in MP-SOC
- 2. The driver
- 3. The pipeline cores
- 4. Chipset Architecture Performance (CHAP) Counters
- 5. Typically, the performance data is retrieved on a frame time basis, however, the periodicity can also be a configuration attribute of the profiler, or can be set based on a detected configuration event which the profiler is designed to detect before retrieving performance data.
- The analysis, resulting in the selection of a preferred parallel method is based on the assumption that in a well defined case (described below), object-division method supersedes the other division modes in that it reduces more bottlenecks. In contrast to image-division, that reduces only the fragment/fill bound processing at each pipeline core, the object-division relaxes virtually all bottleneck across the pipeline: (i) the geometry (i.e. polygons, lines, dots, etc) transform processing is offloaded at each pipeline, handling only 1/N of polygons (N—number of participating pipeline cores); (ii) fill bound processing is reduced since less polygons are feeding the rasterizer, (iii) less geometry memory is needed; (iv) less texture memory is needed.
- Although the time-division method releases bottlenecks by allowing to each pipeline core more time per frame generation, however this method suffers from severe problems such as CPU bottlenecks, the pipeline cores generated frame buffers that are not available to each other, and there are frequent cases of pipeline latency. Therefore this method is not suitable to all applications. Consequently, due to its superiority as bottleneck opener, object-division becomes the primary parallel mode.
- The following object division algorithm distributes polygons among the multiple graphic pipeline cores. Typical application generates a stream of graphic calls that includes blocks of graphic data; each block consists of a list of geometric operations, such as single vertex operations or buffer based operations (vertex array). Typically, the decomposition algorithm splits the data between pipeline cores preserving the blocks as basic data units. Geometric operations are attached to the block(s) of data, instructing the way the data is handled. A block is directed to designated GPU. However, there are operations belonging to the group of Blocking Operations, such as Flush, Swap, Alpha blending, which affect the entire graphic system, setting the system to blocking mode. Blocking operations are exceptional in that they require a composed valid FB data, thus in the parallel setting of the present invention, they have an effect on all pipeline cores. Therefore, whenever one of the Blocking operations is issued, all the pipeline cores must be synchronized. Each frame has at least 2 blocking operations: Flush and Swap, which terminate the frame.
-
FIG. 11 presents a flowchart describing an algorithm for distributing polygons among multiple GPU-driven pipeline cores, according to an illustrative embodiment of the present invention. The frame activity starts with distributing blocks of data among GPUs. Each graphic operation is tested for blocking mode atstep 112. In a regular path (non-blocking path), data is redirected to the designated pipeline core atstep 1113. This loop is repeated until a blocking operation is detected. - When the blocking operation is detected, all pipeline cores must be synchronized at
step 1114 by at least the following sequence: - performing a flush operation in order to terminate rendering and clean up the internal pipeline (flushing) in pipeline core;
- performing a composition in order to merge the contents of all FBs into a single FB; and
- transmitting the contents of said single FB back to all pipeline cores, in order to create a common ground for continuation.
- The Swap operation activates the double buffering mechanism, swapping the back and front color buffers. If Swap is detected at
step 1115, it means that the composited frame must be terminated at all pipeline cores, except pipeline0. All pipeline cores have the final composed contents of a FB designated to store said contents, but only the one connected to the screen (pipeline0) displays the image atstep 1116. - Another case is operations that are applied globally to the scene and need to be broadcasted to all the pipeline cores. If one of the other blocking operations is identified, such as Alpha blending for transparency, then all pipeline cores are flushed as before at
step 1114, and merged into a common FB. This time the Swap operation is not detected (step 1115), therefore all pipeline cores have the same data, and as long as the blocking mode is on (step 1117), all of them keep processing the same data (step 1118). If the end of the block mode is detected atstep 1117, pipeline cores return working on designated data (step 1113). - The relative advantage of object-division depends very much on depth complexity of the scene. Depth complexity is the number of fragment replacements as a result of depth tests (the number of polygons drawn on every pixel). In the ideal case of no fragment replacement (e.g. all polygons of the scene are located on the same depth level), the fill is reduced according to the reduced number of polygons (as for 2 pipeline cores). However, when depth complexity is getting high, the advantage of object-division drops down, and in some cases the image-division may even perform better, e.g. applications with small number of polygons and high volume of textures.
- In addition, the present invention introduces a dynamic load-balancing technique that combines the object division method with the image division and time division methods in image and time domains, based on the load exhibits by previous processing stages. Combining all the three parallel methods into a unified framework dramatically increases the frame rate stability of the graphic system.
-
FIG. 12 discloses a sample configuration of the system, employing 8 pipeline cores, according to an embodiment of the present invention. According to the above sample configuration, a balanced graphic application is assumed. The pipeline cores are divided into two groups for time division parallelism. Pipeline cores indexed with 1, 2, 3, and 4 are configured to process even frames and pipeline cores indexed with 5, 6, 7, and 8 are configured to process odd frames. Within each group, two pipeline core subgroups are set for image division: the pipeline cores with the lower indexes (1,2 and 5,6 respectively) are configured to process half of the screen, and the high-indexed pipeline cores (3,4 and 7,8 respectively) are configured to process the other half. Finally, for the object division, pipeline cores indexed with 1, 3, 5 and 7 are fed with half of the objects, and pipeline cores indexed with 2, 4, 6 and 8 are fed with the other half of the objects. - If at some point the system detects that the bottlenecks exhibited in previous frames occur at the raster stage of the pipeline, it means that fragment processing dominates the time it takes to render the frames and that the configuration is imbalanced. At that point the pipeline cores are reconfigured, so that each pipeline core will render a quarter of the screen within the respective frame. The original partition for time division, between
pipeline cores pipeline core 2 and pipeline core 5 are configured to render the first quarter of screen in even and odd frames respectively.Pipeline cores pipeline cores 3 and 8—the forth quarter. No object division is implied. - In addition, if at some point the system detects that the bottleneck exhibited in previous frames occurs at the geometry stage of the pipe, the pipeline cores are reconfigured, so that each pipeline core will process a quarter of the geometrical data within the respective frame. That is,
pipeline cores 3 and 5 are configured to process the first quarter of the polygons in even and odd frames respectively.Pipeline cores 1 and 7—render the second quarter,pipeline cores 4 and 6—the third quarter andpipeline cores 2 and 8—the forth quarter. No image division is implied. - It should be noted, that taking 8 pipeline cores is sufficient in order to combine all three parallel modes, which are time, image and object division modes, per frame. Taking the number of pipeline cores larger than 8, also enables combining all 3 modes, but in a non-symmetric fashion. The flexibility also exists in frame count in a time division cycle. In the above example, the cluster of 8 pipeline cores was broken down into the two groups, each group handling a frame. However, it is possible to extend the number of frames in a time division mode to a sequence, which is longer than 2 frames, for example 3 or 4 frames.
- Taking a smaller number of pipeline cores still allows the combination of the parallel modes, however the combination of two modes only. For example, taking only 4 pipeline cores enables to combine image and object division modes, without time division mode. It is clearly understood from
FIG. 12 , while talking the group of pipeline cores 1-4, which is the left cluster. Similarly, the group ofpipeline cores pipeline cores - It should be noted, that similarly to the above embodiments, any combination between the parallel modes can be scheduled to evenly balance the graphic load.
- It also should be noted, that according to the present invention, the parallelization process between all pipeline cores may be based on an object division mode or image division mode or time division mode or any combination thereof in order to optimize the processing performance of each frame.
- The decision on parallel mode is done on a per-frame basis, based on the above profiling and analysis. It is then carried out by reconfiguration of the parallelization scheme, as described above and shown in
FIGS. 8 , 9, 10 and 12. - The MP-SOC architecture described in great detail hereinabove can be readily adapted for use in diverse kinds of graphics processing and display systems. While the illustrative embodiments of the present invention have been described in connection with PC-type computing systems, it is understood that the present invention can be use improve graphical performance in diverse kinds of systems including mobile computing devices, embedded systems, and as well as scientific and industrial computing systems supporting graphic visualization of photo-realistic quality.
- It is understood that the graphics processing and display technology described in the illustrative embodiments of the present invention may be modified in a variety of ways which will become readily apparent to those skilled in the art of having the benefit of the novel teachings disclosed herein. All such modifications and variations of the illustrative embodiments thereof shall be deemed to be within the scope and spirit of the present invention as defined by the Claims to Invention appended hereto.
Claims (24)
1-10. (canceled)
11: A graphics card for connection to the motherboard of a computing system having a CPU bus, said graphics card comprising:
a silicon chip of a monolithic construction implementing a graphics processing and display subsystem including:
(a) multiple GPU-driven pipeline cores;
(b) a routing center, disposed on said CPU bus, for distributing the graphics data stream, coming from said CPU among said GPU-driven pipeline cores, and then collecting the rendered results (frame buffers) from said pipeline cores, to said compositing unit;
(c) a compositing unit for re-composing the partial frame buffers according to said ongoing parallelization mode;
(d) a control unit, for controlling the configuring and functioning of said graphics processing and display system according to the parallelization mode selected at any instant in time;
(d) a processing element (PE) with internal or external memory;
(e) a profiling functions unit, for delivering a benchmarking data to said multi-pipe drivers; and
(f) a display interface, for running single or multiple display screens.
12: The graphics card of claim 11 , wherein said graphics data stream is distributed among said GPU-driven pipeline cores, under the control of said control unit, and depending on the current parallelization mode.
13: The graphics card of claim 11 , wherein said silicon chip has multiple GPU-driven pipeline cores each with graphic processing unit (GPU) that supports the parallelization of image processing using one or more parallelization modes, and being adapted for interfacing with a computing system having a means for displaying images on at least one computer screen and supporting (i) one or more software applications for issuing graphics commands, (ii) one or more graphic libraries (state machines) for storing data used to implement said graphics commands, and (iii) multi-pipe drivers for allowing said GPU-drive pipeline cores to interact with said graphic libraries.
14: The graphics card of claim 12 , wherein said multi-pipe drivers include:
(1) a GPU drivers unit for performing the functions of a generic GPU driver associated with interaction with the operating system (OS) of said computing system, and graphic library;
(2) a distributed graphic functions control module for performing functions associated with carrying on the different parallelization modes according to parallelization policy management;
(3) a state monitoring driver module for continuously analysis of all incoming commands, including state commands, transferring certain state commands and some of the data all of said GPU-driven pipeline cores so as to preserve the valid state across said GPU-driven graphic pipeline cores;
(4) an application profiling and analysis driver module for performing real-time continuous monitoring of application parameters in said computing system identifying problem areas within said graphics system which are likely to cause data bottlenecks, wherein said application profiling and analysis driver modules uses inputs from (i) the registers of said multiple GPU-driven pipeline cores, (ii) registers of said control unit, and graphic API commands; and
(5) parallelism policy management driver module for determining, on a per-frame basis, the parallelization mode of said GPU-driven pipeline cores, using the results of said application profiling and analysis driver module, and for such determination to be carried out by means of the control unit of MP-SOC.
15: The graphics card of claim 11 , further comprises cache memory, for serving said processing element, and for caching graphics data common to said GPU-driven pipeline cores.
16: The graphics card of claim 15 , wherein said graphics data is selected from the group consisting of textures and vertex objects.
17: The graphics card of claim 4, wherein said benchmark parameters include data selected from the group consisting of memory speed, memory usage in bytes, total pixels rendered, geometric data entering rendering, frame rate, workload of each pipeline core, load balance among graphic pipelines, volumes of transferred data, textures count, and depth complexity.
18: The graphics card of claim 11 , wherein said graphic libraries are selected from the group consisting of OpenGL and DirectX.
19: The graphics card of claim 11 , wherein the number of said GPU-driven pipeline cores has no architectural limit.
20: The graphics card of claim 11 , wherein said GPU-driven pipeline cores are organized in different parallelization modes for solving performance bottlenecks.
21: The graphics card of claim 11 , wherein said parallelization modes include an object division mode, an image division mode and a time division mode.
22: A computer system for display images on more or more display screens, comprising:
a motherboard having a CPU bus and a silicon chip of a monolithic construction for implementing a graphics processing and display subsystem, said silicon chip including:
(a) multiple GPU-driven pipeline cores;
(b) a routing center, disposed on said CPU bus, for distributing the graphics data stream, coming from said CPU among said GPU-driven pipeline cores, and then collecting the rendered results (frame buffers) from said pipeline cores, to said compositing unit,
wherein the way said data is distributed is dictated by said control unit, and depending on the current parallelization mode;
a compositing unit for re-composing the partial frame buffers according to said ongoing parallelization mode;
a control unit, for controlling the configuring and functioning of said graphics processing and display system according to the parallelization mode selected at any instant in time;
a processing element (PE) with internal or external memory;
a profiling functions unit, for delivering a benchmarking data to said multi-pipe drivers; and
a display interface, for running single or multiple display screens.
23: The computer system of claim 22 , wherein said graphics data stream is distributed among said GPU-driven pipeline cores, under the control of said control unit, and depending on the current parallelization mode.
24: The computer system of claim 22 , wherein said silicon chip has multiple GPU-driven pipeline cores each with graphic processing unit (GPU) that supports the parallelization of image processing using one or more parallelization modes, and being adapted for interfacing with a computing system having a means for displaying images on at least one computer screen and supporting (i) one or more software applications for issuing graphics commands, (ii) one or more graphic libraries (state machines) for storing data used to implement said graphics commands, and (iii) multi-pipe drivers for allowing said GPU-drive pipeline cores to interact with said graphic libraries.
25: The computer system of claim 24 , wherein said multi-pipe drivers comprises:
(1) a GPU drivers unit for performing the functions of a generic GPU driver associated with interaction with the operating system (OS) of said computing system, and graphic library;
(2) a distributed graphic functions control module for performing functions associated with carrying on the different parallelization modes according to parallelization policy management;
(3) a state monitoring driver module for continuously analysis of all incoming commands, including state commands, transferring certain state commands and some of the data all of said GPU-driven pipeline cores so as to preserve the valid state across said GPU-driven graphic pipeline cores;
(4) an application profiling and analysis driver module for performing real-time continuous monitoring of application parameters in said computing system identifying problem areas within said graphics system which are likely to cause data bottlenecks, wherein said application profiling and analysis driver modules uses inputs from (i) the registers of said multiple GPU-driven pipeline cores, (ii) registers of said control unit, and graphic API commands; and
(5) parallelism policy management driver module for determining, on a per-frame basis, the parallelization mode of said GPU-driven pipeline cores, using the results of said application profiling and analysis driver module, and for such determination to be carried out by means of the control unit of MP-SOC.
26: The computer system of claim 22 , further comprises cache memory, for serving said processing element, and for caching graphics data common to said GPU-driven pipeline cores.
27: The computer system of claim 22 , wherein said graphics data is selected from the group consisting of textures and vertex objects.
28: The computer system of claim 22 , wherein said benchmark parameters include data selected from the group consisting of memory speed, memory usage in bytes, total pixels rendered, geometric data entering rendering, frame rate, workload of each pipeline core, load balance among graphic pipelines, volumes of transferred data, textures count, and depth complexity.
29: The computer system of claim 22 , wherein said graphic libraries are selected from the group consisting of OpenGL and DirectX.
30: The computer system of claim 22 , wherein the number of said GPU-driven pipeline cores has no architectural limit.
31: The computer system of claim 22 , wherein said GPU-driven pipeline cores are organized in different parallelization modes for solving performance bottlenecks.
32: The computer system of claim 22 , wherein said parallelization modes include an object division mode, an image division mode and a time division mode.
33-45. (canceled)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US11/883,104 US20090096798A1 (en) | 2005-01-25 | 2006-01-25 | Graphics Processing and Display System Employing Multiple Graphics Cores on a Silicon Chip of Monolithic Construction |
Applications Claiming Priority (4)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US64714605P | 2005-01-25 | 2005-01-25 | |
US11/340,402 US7812844B2 (en) | 2004-01-28 | 2006-01-25 | PC-based computing system employing a silicon chip having a routing unit and a control unit for parallelizing multiple GPU-driven pipeline cores according to the object division mode of parallel operation during the running of a graphics application |
US11/883,104 US20090096798A1 (en) | 2005-01-25 | 2006-01-25 | Graphics Processing and Display System Employing Multiple Graphics Cores on a Silicon Chip of Monolithic Construction |
PCT/IB2006/001529 WO2006117683A2 (en) | 2005-01-25 | 2006-01-25 | Graphics processing and display system employing multiple graphics cores on a silicon chip of monolithic construction |
Related Parent Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US11/340,402 Continuation-In-Part US7812844B2 (en) | 2003-11-19 | 2006-01-25 | PC-based computing system employing a silicon chip having a routing unit and a control unit for parallelizing multiple GPU-driven pipeline cores according to the object division mode of parallel operation during the running of a graphics application |
Publications (1)
Publication Number | Publication Date |
---|---|
US20090096798A1 true US20090096798A1 (en) | 2009-04-16 |
Family
ID=40533757
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US11/883,104 Abandoned US20090096798A1 (en) | 2005-01-25 | 2006-01-25 | Graphics Processing and Display System Employing Multiple Graphics Cores on a Silicon Chip of Monolithic Construction |
Country Status (1)
Country | Link |
---|---|
US (1) | US20090096798A1 (en) |
Cited By (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20130086315A1 (en) * | 2011-10-04 | 2013-04-04 | Moon J. Kim | Direct memory access without main memory in a semiconductor storage device-based system |
US20160006714A1 (en) * | 2005-04-22 | 2016-01-07 | Microsoft Technology Licensing, Llc | Protected media pipeline |
US10430918B2 (en) | 2014-07-23 | 2019-10-01 | Samsung Electronics Co., Ltd. | Display driver, display system, and method of operating the display driver |
US11283864B2 (en) * | 2017-08-28 | 2022-03-22 | Texas Instruments Incorporated | Cluster system with fail-safe fallback mechanism |
Citations (93)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5740464A (en) * | 1995-05-15 | 1998-04-14 | Nvidia Corporation | Architecture for providing input/output operations in a computer system |
US5745762A (en) * | 1994-12-15 | 1998-04-28 | International Business Machines Corporation | Advanced graphics driver architecture supporting multiple system emulations |
US5754866A (en) * | 1995-05-08 | 1998-05-19 | Nvidia Corporation | Delayed interrupts with a FIFO in an improved input/output architecture |
US5758182A (en) * | 1995-05-15 | 1998-05-26 | Nvidia Corporation | DMA controller translates virtual I/O device address received directly from application program command to physical i/o device address of I/O device on device bus |
US5757385A (en) * | 1994-07-21 | 1998-05-26 | International Business Machines Corporation | Method and apparatus for managing multiprocessor graphical workload distribution |
US5909595A (en) * | 1995-05-15 | 1999-06-01 | Nvidia Corporation | Method of controlling I/O routing by setting connecting context for utilizing I/O processing elements within a computer system to produce multimedia effects |
US6169553B1 (en) * | 1997-07-02 | 2001-01-02 | Ati Technologies, Inc. | Method and apparatus for rendering a three-dimensional scene having shadowing |
US6181352B1 (en) * | 1999-03-22 | 2001-01-30 | Nvidia Corporation | Graphics pipeline selectively providing multiple pixels or multiple textures |
US6184908B1 (en) * | 1998-04-27 | 2001-02-06 | Ati Technologies, Inc. | Method and apparatus for co-processing video graphics data |
US6188412B1 (en) * | 1998-08-28 | 2001-02-13 | Ati Technologies, Inc. | Method and apparatus for performing setup operations in a video graphics system |
US6191800B1 (en) * | 1998-08-11 | 2001-02-20 | International Business Machines Corporation | Dynamic balancing of graphics workloads using a tiling strategy |
US6201545B1 (en) * | 1997-09-23 | 2001-03-13 | Ati Technologies, Inc. | Method and apparatus for generating sub pixel masks in a three dimensional graphic processing system |
US6212617B1 (en) * | 1998-05-13 | 2001-04-03 | Microsoft Corporation | Parallel processing method and system using a lazy parallel data type to reduce inter-processor communication |
US6212261B1 (en) * | 1996-08-14 | 2001-04-03 | Nortel Networks Limited | Internet-based telephone call manager |
US6337686B2 (en) * | 1998-01-07 | 2002-01-08 | Ati Technologies Inc. | Method and apparatus for line anti-aliasing |
US20020015055A1 (en) * | 2000-07-18 | 2002-02-07 | Silicon Graphics, Inc. | Method and system for presenting three-dimensional computer graphics images using multiple graphics processing units |
US6352479B1 (en) * | 1999-08-31 | 2002-03-05 | Nvidia U.S. Investment Company | Interactive gaming server and online community forum |
US6362825B1 (en) * | 1999-01-19 | 2002-03-26 | Hewlett-Packard Company | Real-time combination of adjacent identical primitive data sets in a graphics call sequence |
US20020059302A1 (en) * | 2000-10-10 | 2002-05-16 | Hitoshi Ebihara | Data communication system and method, computer program, and recording medium |
US20030020720A1 (en) * | 1999-12-06 | 2003-01-30 | Nvidia Corporation | Method, apparatus and article of manufacture for a sequencer in a transform/lighting module capable of processing multiple independent execution threads |
US20030034975A1 (en) * | 1999-12-06 | 2003-02-20 | Nvidia Corporation | Lighting system and method for a graphics processor |
US6529198B1 (en) * | 1999-03-16 | 2003-03-04 | Nec Corporation | Parallel rendering device |
US6532013B1 (en) * | 2000-05-31 | 2003-03-11 | Nvidia Corporation | System, method and article of manufacture for pixel shaders for programmable shading |
US6532525B1 (en) * | 2000-09-29 | 2003-03-11 | Ati Technologies, Inc. | Method and apparatus for accessing memory |
US6535209B1 (en) * | 1999-03-17 | 2003-03-18 | Nvidia Us Investments Co. | Data stream splitting and storage in graphics data processing |
US6542971B1 (en) * | 2001-04-23 | 2003-04-01 | Nvidia Corporation | Memory access system and method employing an auxiliary buffer |
US6557065B1 (en) * | 1999-12-20 | 2003-04-29 | Intel Corporation | CPU expandability bus |
US20030080959A1 (en) * | 2001-10-29 | 2003-05-01 | Ati Technologies, Inc. | System, Method, and apparatus for early culling |
US20030103054A1 (en) * | 1999-12-06 | 2003-06-05 | Nvidia Corporation | Integrated graphics processing unit with antialiasing |
US6577309B2 (en) * | 1999-12-06 | 2003-06-10 | Nvidia Corporation | System and method for a graphics processing framework embodied utilizing a single semiconductor platform |
US6578068B1 (en) * | 1999-08-31 | 2003-06-10 | Accenture Llp | Load balancer in environment services patterns |
US6577320B1 (en) * | 1999-03-22 | 2003-06-10 | Nvidia Corporation | Method and apparatus for processing multiple types of pixel component representations including processes of premultiplication, postmultiplication, and colorkeying/chromakeying |
US20030112246A1 (en) * | 1999-12-06 | 2003-06-19 | Nvidia Corporation | Blending system and method in an integrated computer graphics pipeline |
US20030117971A1 (en) * | 2001-12-21 | 2003-06-26 | Celoxica Ltd. | System, method, and article of manufacture for profiling an executable hardware model using calls to profiling functions |
US6677953B1 (en) * | 2001-11-08 | 2004-01-13 | Nvidia Corporation | Hardware viewport system and method for use in a graphics pipeline |
US20040012600A1 (en) * | 2002-03-22 | 2004-01-22 | Deering Michael F. | Scalable high performance 3d graphics |
US6683614B2 (en) * | 2001-12-21 | 2004-01-27 | Hewlett-Packard Development Company, L.P. | System and method for automatically configuring graphics pipelines by tracking a region of interest in a computer graphical display system |
US6690372B2 (en) * | 2000-05-31 | 2004-02-10 | Nvidia Corporation | System, method and article of manufacture for shadow mapping |
US6691180B2 (en) * | 1998-04-17 | 2004-02-10 | Nvidia Corporation | Apparatus for accelerating the rendering of images |
US20040036159A1 (en) * | 2002-08-23 | 2004-02-26 | Ati Technologies, Inc. | Integrated circuit having memory disposed thereon and method of making thereof |
US6700583B2 (en) * | 2001-05-14 | 2004-03-02 | Ati Technologies, Inc. | Configurable buffer for multipass applications |
US6704025B1 (en) * | 2001-08-31 | 2004-03-09 | Nvidia Corporation | System and method for dual-depth shadow-mapping |
US6724394B1 (en) * | 2000-05-31 | 2004-04-20 | Nvidia Corporation | Programmable pixel shading architecture |
US6725457B1 (en) * | 2000-05-17 | 2004-04-20 | Nvidia Corporation | Semaphore enhancement to improve system performance |
US6728820B1 (en) * | 2000-05-26 | 2004-04-27 | Ati International Srl | Method of configuring, controlling, and accessing a bridge and apparatus therefor |
US6731298B1 (en) * | 2000-10-02 | 2004-05-04 | Nvidia Corporation | System, method and article of manufacture for z-texture mapping |
US6734861B1 (en) * | 2000-05-31 | 2004-05-11 | Nvidia Corporation | System, method and article of manufacture for an interlock module in a computer graphics processing pipeline |
US6741243B2 (en) * | 2000-05-01 | 2004-05-25 | Broadcom Corporation | Method and system for reducing overflows in a computer graphics system |
US6744433B1 (en) * | 2001-08-31 | 2004-06-01 | Nvidia Corporation | System and method for using and collecting information from a plurality of depth layers |
US6753878B1 (en) * | 1999-03-08 | 2004-06-22 | Hewlett-Packard Development Company, L.P. | Parallel pipelined merge engines |
US6842180B1 (en) * | 2000-09-20 | 2005-01-11 | Intel Corporation | Opportunistic sharing of graphics resources to enhance CPU performance in an integrated microprocessor |
US6844879B2 (en) * | 2001-07-19 | 2005-01-18 | Nec Corporation | Drawing apparatus |
US6856320B1 (en) * | 1997-11-25 | 2005-02-15 | Nvidia U.S. Investment Company | Demand-based memory system for graphics applications |
US20050041031A1 (en) * | 2003-08-18 | 2005-02-24 | Nvidia Corporation | Adaptive load balancing in a multi-processor graphics processing system |
US6864984B2 (en) * | 2000-03-16 | 2005-03-08 | Fuji Photo Film Co., Ltd. | Measuring method and apparatus using attenuation in total reflection |
US6864893B2 (en) * | 2002-07-19 | 2005-03-08 | Nvidia Corporation | Method and apparatus for modifying depth values using pixel programs |
US6870540B1 (en) * | 1999-12-06 | 2005-03-22 | Nvidia Corporation | System, method and computer program product for a programmable pixel processing model with instruction set |
US6876362B1 (en) * | 2002-07-10 | 2005-04-05 | Nvidia Corporation | Omnidirectional shadow texture mapping |
US20050081115A1 (en) * | 2003-09-26 | 2005-04-14 | Ati Technologies, Inc. | Method and apparatus for monitoring and resetting a co-processor |
US6885376B2 (en) * | 2002-12-30 | 2005-04-26 | Silicon Graphics, Inc. | System, method, and computer program product for near-real time load balancing across multiple rendering pipelines |
US6894687B1 (en) * | 2001-06-08 | 2005-05-17 | Nvidia Corporation | System, method and computer program product for vertex attribute aliasing in a graphics pipeline |
US6894689B1 (en) * | 1998-07-22 | 2005-05-17 | Nvidia Corporation | Occlusion culling method and apparatus for graphics systems |
US6900810B1 (en) * | 2003-04-10 | 2005-05-31 | Nvidia Corporation | User programmable geometry engine |
US20050122330A1 (en) * | 2003-11-14 | 2005-06-09 | Microsoft Corporation | Systems and methods for downloading algorithmic elements to a coprocessor and corresponding techniques |
US6982718B2 (en) * | 2001-06-08 | 2006-01-03 | Nvidia Corporation | System, method and computer program product for programmable fragment processing in a graphics pipeline |
US20060005178A1 (en) * | 2004-07-02 | 2006-01-05 | Nvidia Corporation | Optimized chaining of vertex and fragment programs |
US6985152B2 (en) * | 2004-04-23 | 2006-01-10 | Nvidia Corporation | Point-to-point bus bridging without a bridge controller |
US6989840B1 (en) * | 2001-08-31 | 2006-01-24 | Nvidia Corporation | Order-independent transparency rendering system and method |
US6995767B1 (en) * | 2003-07-31 | 2006-02-07 | Nvidia Corporation | Trilinear optimization for texture filtering |
US7002588B1 (en) * | 1999-12-06 | 2006-02-21 | Nvidia Corporation | System, method and computer program product for branching during programmable vertex processing |
US20060055695A1 (en) * | 2004-09-13 | 2006-03-16 | Nvidia Corporation | Increased scalability in the fragment shading pipeline |
US20060059494A1 (en) * | 2004-09-16 | 2006-03-16 | Nvidia Corporation | Load balancing |
US7015915B1 (en) * | 2003-08-12 | 2006-03-21 | Nvidia Corporation | Programming multiple chips from a command buffer |
US7023437B1 (en) * | 1998-07-22 | 2006-04-04 | Nvidia Corporation | System and method for accelerating graphics processing using a post-geometry data stream during multiple-pass rendering |
US7027972B1 (en) * | 2001-01-24 | 2006-04-11 | Ati Technologies, Inc. | System for collecting and analyzing graphics data and method thereof |
US7038685B1 (en) * | 2003-06-30 | 2006-05-02 | Nvidia Corporation | Programmable graphics processor for multithreaded execution of programs |
US7038678B2 (en) * | 2003-05-21 | 2006-05-02 | Nvidia Corporation | Dependent texture shadow antialiasing |
US7038692B1 (en) * | 1998-04-07 | 2006-05-02 | Nvidia Corporation | Method and apparatus for providing a vertex cache |
US20060101218A1 (en) * | 2004-11-11 | 2006-05-11 | Nvidia Corporation | Memory controller-adaptive 1T/2T timing control |
US7053901B2 (en) * | 2003-12-11 | 2006-05-30 | Nvidia Corporation | System and method for accelerating a special purpose processor |
US20060119607A1 (en) * | 2004-02-27 | 2006-06-08 | Nvidia Corporation | Register based queuing for texture requests |
US7119808B2 (en) * | 2003-07-15 | 2006-10-10 | Alienware Labs Corp. | Multiple parallel processor computer graphics system |
US7224359B1 (en) * | 2002-02-01 | 2007-05-29 | Nvidia Corporation | Depth clamping system and method in a hardware graphics pipeline |
US20070159488A1 (en) * | 2005-12-19 | 2007-07-12 | Nvidia Corporation | Parallel Array Architecture for a Graphics Processor |
US20080007559A1 (en) * | 2006-06-30 | 2008-01-10 | Nokia Corporation | Apparatus, method and a computer program product for providing a unified graphics pipeline for stereoscopic rendering |
US7324547B1 (en) * | 2002-12-13 | 2008-01-29 | Nvidia Corporation | Internet protocol (IP) router residing in a processor chipset |
US7324111B2 (en) * | 2004-04-09 | 2008-01-29 | Nvidia Corporation | Method and apparatus for routing graphics processing signals to a stand-alone module |
US7325086B2 (en) * | 2005-12-15 | 2008-01-29 | Via Technologies, Inc. | Method and system for multiple GPU support |
US7372465B1 (en) * | 2004-12-17 | 2008-05-13 | Nvidia Corporation | Scalable graphics processing for remote display |
US7477256B1 (en) * | 2004-11-17 | 2009-01-13 | Nvidia Corporation | Connecting graphics adapters for scalable performance |
US7525547B1 (en) * | 2003-08-12 | 2009-04-28 | Nvidia Corporation | Programming multiple chips from a command buffer to process multiple images |
US7561161B2 (en) * | 2005-01-28 | 2009-07-14 | Microsoft Corporation | Quantitative measure of a video interface |
US7602395B1 (en) * | 2005-04-22 | 2009-10-13 | Nvidia Corporation | Programming multiple chips from a command buffer for stereo image generation |
-
2006
- 2006-01-25 US US11/883,104 patent/US20090096798A1/en not_active Abandoned
Patent Citations (103)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5757385A (en) * | 1994-07-21 | 1998-05-26 | International Business Machines Corporation | Method and apparatus for managing multiprocessor graphical workload distribution |
US5745762A (en) * | 1994-12-15 | 1998-04-28 | International Business Machines Corporation | Advanced graphics driver architecture supporting multiple system emulations |
US5754866A (en) * | 1995-05-08 | 1998-05-19 | Nvidia Corporation | Delayed interrupts with a FIFO in an improved input/output architecture |
US5758182A (en) * | 1995-05-15 | 1998-05-26 | Nvidia Corporation | DMA controller translates virtual I/O device address received directly from application program command to physical i/o device address of I/O device on device bus |
US5909595A (en) * | 1995-05-15 | 1999-06-01 | Nvidia Corporation | Method of controlling I/O routing by setting connecting context for utilizing I/O processing elements within a computer system to produce multimedia effects |
US5740464A (en) * | 1995-05-15 | 1998-04-14 | Nvidia Corporation | Architecture for providing input/output operations in a computer system |
US6212261B1 (en) * | 1996-08-14 | 2001-04-03 | Nortel Networks Limited | Internet-based telephone call manager |
US6169553B1 (en) * | 1997-07-02 | 2001-01-02 | Ati Technologies, Inc. | Method and apparatus for rendering a three-dimensional scene having shadowing |
US6201545B1 (en) * | 1997-09-23 | 2001-03-13 | Ati Technologies, Inc. | Method and apparatus for generating sub pixel masks in a three dimensional graphic processing system |
US7170515B1 (en) * | 1997-11-25 | 2007-01-30 | Nvidia Corporation | Rendering pipeline |
US6856320B1 (en) * | 1997-11-25 | 2005-02-15 | Nvidia U.S. Investment Company | Demand-based memory system for graphics applications |
US6337686B2 (en) * | 1998-01-07 | 2002-01-08 | Ati Technologies Inc. | Method and apparatus for line anti-aliasing |
US7038692B1 (en) * | 1998-04-07 | 2006-05-02 | Nvidia Corporation | Method and apparatus for providing a vertex cache |
US6691180B2 (en) * | 1998-04-17 | 2004-02-10 | Nvidia Corporation | Apparatus for accelerating the rendering of images |
US6184908B1 (en) * | 1998-04-27 | 2001-02-06 | Ati Technologies, Inc. | Method and apparatus for co-processing video graphics data |
US6212617B1 (en) * | 1998-05-13 | 2001-04-03 | Microsoft Corporation | Parallel processing method and system using a lazy parallel data type to reduce inter-processor communication |
US6894689B1 (en) * | 1998-07-22 | 2005-05-17 | Nvidia Corporation | Occlusion culling method and apparatus for graphics systems |
US7023437B1 (en) * | 1998-07-22 | 2006-04-04 | Nvidia Corporation | System and method for accelerating graphics processing using a post-geometry data stream during multiple-pass rendering |
US7170513B1 (en) * | 1998-07-22 | 2007-01-30 | Nvidia Corporation | System and method for display list occlusion branching |
US6191800B1 (en) * | 1998-08-11 | 2001-02-20 | International Business Machines Corporation | Dynamic balancing of graphics workloads using a tiling strategy |
US6188412B1 (en) * | 1998-08-28 | 2001-02-13 | Ati Technologies, Inc. | Method and apparatus for performing setup operations in a video graphics system |
US6362825B1 (en) * | 1999-01-19 | 2002-03-26 | Hewlett-Packard Company | Real-time combination of adjacent identical primitive data sets in a graphics call sequence |
US6753878B1 (en) * | 1999-03-08 | 2004-06-22 | Hewlett-Packard Development Company, L.P. | Parallel pipelined merge engines |
US6529198B1 (en) * | 1999-03-16 | 2003-03-04 | Nec Corporation | Parallel rendering device |
US6535209B1 (en) * | 1999-03-17 | 2003-03-18 | Nvidia Us Investments Co. | Data stream splitting and storage in graphics data processing |
US6181352B1 (en) * | 1999-03-22 | 2001-01-30 | Nvidia Corporation | Graphics pipeline selectively providing multiple pixels or multiple textures |
US6577320B1 (en) * | 1999-03-22 | 2003-06-10 | Nvidia Corporation | Method and apparatus for processing multiple types of pixel component representations including processes of premultiplication, postmultiplication, and colorkeying/chromakeying |
US6578068B1 (en) * | 1999-08-31 | 2003-06-10 | Accenture Llp | Load balancer in environment services patterns |
US6352479B1 (en) * | 1999-08-31 | 2002-03-05 | Nvidia U.S. Investment Company | Interactive gaming server and online community forum |
US7002588B1 (en) * | 1999-12-06 | 2006-02-21 | Nvidia Corporation | System, method and computer program product for branching during programmable vertex processing |
US6577309B2 (en) * | 1999-12-06 | 2003-06-10 | Nvidia Corporation | System and method for a graphics processing framework embodied utilizing a single semiconductor platform |
US20030103054A1 (en) * | 1999-12-06 | 2003-06-05 | Nvidia Corporation | Integrated graphics processing unit with antialiasing |
US6734874B2 (en) * | 1999-12-06 | 2004-05-11 | Nvidia Corporation | Graphics processing unit with transform module capable of handling scalars and vectors |
US20030112245A1 (en) * | 1999-12-06 | 2003-06-19 | Nvidia Corporation | Single semiconductor graphics platform |
US20030112246A1 (en) * | 1999-12-06 | 2003-06-19 | Nvidia Corporation | Blending system and method in an integrated computer graphics pipeline |
US20030034975A1 (en) * | 1999-12-06 | 2003-02-20 | Nvidia Corporation | Lighting system and method for a graphics processor |
US20030020720A1 (en) * | 1999-12-06 | 2003-01-30 | Nvidia Corporation | Method, apparatus and article of manufacture for a sequencer in a transform/lighting module capable of processing multiple independent execution threads |
US20030038808A1 (en) * | 1999-12-06 | 2003-02-27 | Nvidia Corporation | Method, apparatus and article of manufacture for a sequencer in a transform/lighting module capable of processing multiple independent execution threads |
US6992667B2 (en) * | 1999-12-06 | 2006-01-31 | Nvidia Corporation | Single semiconductor graphics platform system and method with skinning, swizzling and masking capabilities |
US6870540B1 (en) * | 1999-12-06 | 2005-03-22 | Nvidia Corporation | System, method and computer program product for a programmable pixel processing model with instruction set |
US6557065B1 (en) * | 1999-12-20 | 2003-04-29 | Intel Corporation | CPU expandability bus |
US7051139B2 (en) * | 1999-12-20 | 2006-05-23 | Intel Corporation | CPU expandability bus |
US6864984B2 (en) * | 2000-03-16 | 2005-03-08 | Fuji Photo Film Co., Ltd. | Measuring method and apparatus using attenuation in total reflection |
US6741243B2 (en) * | 2000-05-01 | 2004-05-25 | Broadcom Corporation | Method and system for reducing overflows in a computer graphics system |
US6725457B1 (en) * | 2000-05-17 | 2004-04-20 | Nvidia Corporation | Semaphore enhancement to improve system performance |
US6728820B1 (en) * | 2000-05-26 | 2004-04-27 | Ati International Srl | Method of configuring, controlling, and accessing a bridge and apparatus therefor |
US6690372B2 (en) * | 2000-05-31 | 2004-02-10 | Nvidia Corporation | System, method and article of manufacture for shadow mapping |
US6724394B1 (en) * | 2000-05-31 | 2004-04-20 | Nvidia Corporation | Programmable pixel shading architecture |
US6532013B1 (en) * | 2000-05-31 | 2003-03-11 | Nvidia Corporation | System, method and article of manufacture for pixel shaders for programmable shading |
US6734861B1 (en) * | 2000-05-31 | 2004-05-11 | Nvidia Corporation | System, method and article of manufacture for an interlock module in a computer graphics processing pipeline |
US20020015055A1 (en) * | 2000-07-18 | 2002-02-07 | Silicon Graphics, Inc. | Method and system for presenting three-dimensional computer graphics images using multiple graphics processing units |
US6842180B1 (en) * | 2000-09-20 | 2005-01-11 | Intel Corporation | Opportunistic sharing of graphics resources to enhance CPU performance in an integrated microprocessor |
US6532525B1 (en) * | 2000-09-29 | 2003-03-11 | Ati Technologies, Inc. | Method and apparatus for accessing memory |
US6731298B1 (en) * | 2000-10-02 | 2004-05-04 | Nvidia Corporation | System, method and article of manufacture for z-texture mapping |
US20020059302A1 (en) * | 2000-10-10 | 2002-05-16 | Hitoshi Ebihara | Data communication system and method, computer program, and recording medium |
US7027972B1 (en) * | 2001-01-24 | 2006-04-11 | Ati Technologies, Inc. | System for collecting and analyzing graphics data and method thereof |
US6542971B1 (en) * | 2001-04-23 | 2003-04-01 | Nvidia Corporation | Memory access system and method employing an auxiliary buffer |
US6700583B2 (en) * | 2001-05-14 | 2004-03-02 | Ati Technologies, Inc. | Configurable buffer for multipass applications |
US6982718B2 (en) * | 2001-06-08 | 2006-01-03 | Nvidia Corporation | System, method and computer program product for programmable fragment processing in a graphics pipeline |
US6894687B1 (en) * | 2001-06-08 | 2005-05-17 | Nvidia Corporation | System, method and computer program product for vertex attribute aliasing in a graphics pipeline |
US6844879B2 (en) * | 2001-07-19 | 2005-01-18 | Nec Corporation | Drawing apparatus |
US6989840B1 (en) * | 2001-08-31 | 2006-01-24 | Nvidia Corporation | Order-independent transparency rendering system and method |
US6744433B1 (en) * | 2001-08-31 | 2004-06-01 | Nvidia Corporation | System and method for using and collecting information from a plurality of depth layers |
US6704025B1 (en) * | 2001-08-31 | 2004-03-09 | Nvidia Corporation | System and method for dual-depth shadow-mapping |
US6999076B2 (en) * | 2001-10-29 | 2006-02-14 | Ati Technologies, Inc. | System, method, and apparatus for early culling |
US20030080959A1 (en) * | 2001-10-29 | 2003-05-01 | Ati Technologies, Inc. | System, Method, and apparatus for early culling |
US6677953B1 (en) * | 2001-11-08 | 2004-01-13 | Nvidia Corporation | Hardware viewport system and method for use in a graphics pipeline |
US6683614B2 (en) * | 2001-12-21 | 2004-01-27 | Hewlett-Packard Development Company, L.P. | System and method for automatically configuring graphics pipelines by tracking a region of interest in a computer graphical display system |
US20030117971A1 (en) * | 2001-12-21 | 2003-06-26 | Celoxica Ltd. | System, method, and article of manufacture for profiling an executable hardware model using calls to profiling functions |
US7224359B1 (en) * | 2002-02-01 | 2007-05-29 | Nvidia Corporation | Depth clamping system and method in a hardware graphics pipeline |
US20040012600A1 (en) * | 2002-03-22 | 2004-01-22 | Deering Michael F. | Scalable high performance 3d graphics |
US6876362B1 (en) * | 2002-07-10 | 2005-04-05 | Nvidia Corporation | Omnidirectional shadow texture mapping |
US6864893B2 (en) * | 2002-07-19 | 2005-03-08 | Nvidia Corporation | Method and apparatus for modifying depth values using pixel programs |
US20040036159A1 (en) * | 2002-08-23 | 2004-02-26 | Ati Technologies, Inc. | Integrated circuit having memory disposed thereon and method of making thereof |
US7324547B1 (en) * | 2002-12-13 | 2008-01-29 | Nvidia Corporation | Internet protocol (IP) router residing in a processor chipset |
US6885376B2 (en) * | 2002-12-30 | 2005-04-26 | Silicon Graphics, Inc. | System, method, and computer program product for near-real time load balancing across multiple rendering pipelines |
US6900810B1 (en) * | 2003-04-10 | 2005-05-31 | Nvidia Corporation | User programmable geometry engine |
US7038678B2 (en) * | 2003-05-21 | 2006-05-02 | Nvidia Corporation | Dependent texture shadow antialiasing |
US7038685B1 (en) * | 2003-06-30 | 2006-05-02 | Nvidia Corporation | Programmable graphics processor for multithreaded execution of programs |
US7119808B2 (en) * | 2003-07-15 | 2006-10-10 | Alienware Labs Corp. | Multiple parallel processor computer graphics system |
US6995767B1 (en) * | 2003-07-31 | 2006-02-07 | Nvidia Corporation | Trilinear optimization for texture filtering |
US7525547B1 (en) * | 2003-08-12 | 2009-04-28 | Nvidia Corporation | Programming multiple chips from a command buffer to process multiple images |
US7015915B1 (en) * | 2003-08-12 | 2006-03-21 | Nvidia Corporation | Programming multiple chips from a command buffer |
US20060114260A1 (en) * | 2003-08-12 | 2006-06-01 | Nvidia Corporation | Programming multiple chips from a command buffer |
US20050041031A1 (en) * | 2003-08-18 | 2005-02-24 | Nvidia Corporation | Adaptive load balancing in a multi-processor graphics processing system |
US20050081115A1 (en) * | 2003-09-26 | 2005-04-14 | Ati Technologies, Inc. | Method and apparatus for monitoring and resetting a co-processor |
US20050122330A1 (en) * | 2003-11-14 | 2005-06-09 | Microsoft Corporation | Systems and methods for downloading algorithmic elements to a coprocessor and corresponding techniques |
US7053901B2 (en) * | 2003-12-11 | 2006-05-30 | Nvidia Corporation | System and method for accelerating a special purpose processor |
US20060119607A1 (en) * | 2004-02-27 | 2006-06-08 | Nvidia Corporation | Register based queuing for texture requests |
US7324111B2 (en) * | 2004-04-09 | 2008-01-29 | Nvidia Corporation | Method and apparatus for routing graphics processing signals to a stand-alone module |
US6985152B2 (en) * | 2004-04-23 | 2006-01-10 | Nvidia Corporation | Point-to-point bus bridging without a bridge controller |
US20060028478A1 (en) * | 2004-04-23 | 2006-02-09 | Nvidia Corporation | Point-to-point bus bridging without a bridge controller |
US20060005178A1 (en) * | 2004-07-02 | 2006-01-05 | Nvidia Corporation | Optimized chaining of vertex and fragment programs |
US20060055695A1 (en) * | 2004-09-13 | 2006-03-16 | Nvidia Corporation | Increased scalability in the fragment shading pipeline |
US20060059494A1 (en) * | 2004-09-16 | 2006-03-16 | Nvidia Corporation | Load balancing |
US20060101218A1 (en) * | 2004-11-11 | 2006-05-11 | Nvidia Corporation | Memory controller-adaptive 1T/2T timing control |
US7477256B1 (en) * | 2004-11-17 | 2009-01-13 | Nvidia Corporation | Connecting graphics adapters for scalable performance |
US7372465B1 (en) * | 2004-12-17 | 2008-05-13 | Nvidia Corporation | Scalable graphics processing for remote display |
US7561161B2 (en) * | 2005-01-28 | 2009-07-14 | Microsoft Corporation | Quantitative measure of a video interface |
US7602395B1 (en) * | 2005-04-22 | 2009-10-13 | Nvidia Corporation | Programming multiple chips from a command buffer for stereo image generation |
US7325086B2 (en) * | 2005-12-15 | 2008-01-29 | Via Technologies, Inc. | Method and system for multiple GPU support |
US20070159488A1 (en) * | 2005-12-19 | 2007-07-12 | Nvidia Corporation | Parallel Array Architecture for a Graphics Processor |
US20080007559A1 (en) * | 2006-06-30 | 2008-01-10 | Nokia Corporation | Apparatus, method and a computer program product for providing a unified graphics pipeline for stereoscopic rendering |
Cited By (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20160006714A1 (en) * | 2005-04-22 | 2016-01-07 | Microsoft Technology Licensing, Llc | Protected media pipeline |
US20130086315A1 (en) * | 2011-10-04 | 2013-04-04 | Moon J. Kim | Direct memory access without main memory in a semiconductor storage device-based system |
US10430918B2 (en) | 2014-07-23 | 2019-10-01 | Samsung Electronics Co., Ltd. | Display driver, display system, and method of operating the display driver |
US11283864B2 (en) * | 2017-08-28 | 2022-03-22 | Texas Instruments Incorporated | Cluster system with fail-safe fallback mechanism |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US10614545B2 (en) | System on chip having processing and graphics units | |
US9405586B2 (en) | Method of dynamic load-balancing within a PC-based computing system employing a multiple GPU-based graphics pipeline architecture supporting multiple modes of GPU parallelization | |
US20090096798A1 (en) | Graphics Processing and Display System Employing Multiple Graphics Cores on a Silicon Chip of Monolithic Construction |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: LUCID INFORMATION TECHNOLOGY, LTD., ISRAELFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:BAKALASH, REUVEN;REMEZ, OFFIR;FOGEL, EFI;REEL/FRAME:020929/0759Effective date: 20080501 |
|
STCB | Information on status: application discontinuation |
Free format text: ABANDONED -- FAILURE TO RESPOND TO AN OFFICE ACTION |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:LUCIDLOGIX TECHNOLOGY LTD.;REEL/FRAME:046361/0169Effective date: 20180131 |