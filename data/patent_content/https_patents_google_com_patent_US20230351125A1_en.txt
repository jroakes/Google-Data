US20230351125A1 - Modeling Ambiguity in Neural Machine Translation - Google Patents
Modeling Ambiguity in Neural Machine Translation Download PDFInfo
- Publication number
- US20230351125A1 US20230351125A1 US18/089,684 US202218089684A US2023351125A1 US 20230351125 A1 US20230351125 A1 US 20230351125A1 US 202218089684 A US202218089684 A US 202218089684A US 2023351125 A1 US2023351125 A1 US 2023351125A1
- Authority
- US
- United States
- Prior art keywords
- translation
- text
- exemplar
- probability
- module
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
- 238000013519 translation Methods 0.000 title claims abstract description 184
- 230000001537 neural effect Effects 0.000 title abstract description 11
- 230000014616 translation Effects 0.000 claims description 178
- 230000006870 function Effects 0.000 claims description 64
- 238000013528 artificial neural network Methods 0.000 claims description 32
- 238000000034 method Methods 0.000 claims description 26
- 230000004913 activation Effects 0.000 claims description 18
- 238000001994 activation Methods 0.000 claims description 18
- 230000015654 memory Effects 0.000 claims description 16
- 238000012545 processing Methods 0.000 claims description 15
- 238000005516 engineering process Methods 0.000 abstract description 25
- 238000009826 distribution Methods 0.000 description 24
- 238000010606 normalization Methods 0.000 description 21
- 238000012549 training Methods 0.000 description 21
- 238000013459 approach Methods 0.000 description 20
- 238000005070 sampling Methods 0.000 description 15
- 238000012360 testing method Methods 0.000 description 12
- 230000007170 pathology Effects 0.000 description 7
- 238000002474 experimental method Methods 0.000 description 6
- 230000007246 mechanism Effects 0.000 description 6
- 230000009466 transformation Effects 0.000 description 6
- PCHJSUWPFVWCPO-UHFFFAOYSA-N gold Chemical compound [Au] PCHJSUWPFVWCPO-UHFFFAOYSA-N 0.000 description 5
- 239000010931 gold Substances 0.000 description 5
- 229910052737 gold Inorganic materials 0.000 description 5
- 238000003058 natural language processing Methods 0.000 description 5
- 230000008569 process Effects 0.000 description 5
- 238000000844 transformation Methods 0.000 description 5
- 230000008901 benefit Effects 0.000 description 4
- 230000035558 fertility Effects 0.000 description 4
- 230000015556 catabolic process Effects 0.000 description 3
- 238000004891 communication Methods 0.000 description 3
- 238000006731 degradation reaction Methods 0.000 description 3
- 238000011161 development Methods 0.000 description 3
- 230000018109 developmental process Effects 0.000 description 3
- 230000006872 improvement Effects 0.000 description 3
- 238000010361 transduction Methods 0.000 description 3
- 230000026683 transduction Effects 0.000 description 3
- 239000013598 vector Substances 0.000 description 3
- 201000005947 Carney Complex Diseases 0.000 description 2
- 235000019687 Lamb Nutrition 0.000 description 2
- 238000012937 correction Methods 0.000 description 2
- 230000007423 decrease Effects 0.000 description 2
- 238000004836 empirical method Methods 0.000 description 2
- 238000011156 evaluation Methods 0.000 description 2
- 238000009499 grossing Methods 0.000 description 2
- 238000013507 mapping Methods 0.000 description 2
- 230000000116 mitigating effect Effects 0.000 description 2
- 230000008450 motivation Effects 0.000 description 2
- 238000005457 optimization Methods 0.000 description 2
- 238000001303 quality assessment method Methods 0.000 description 2
- 238000013515 script Methods 0.000 description 2
- 238000010845 search algorithm Methods 0.000 description 2
- 235000010627 Phaseolus vulgaris Nutrition 0.000 description 1
- 244000046052 Phaseolus vulgaris Species 0.000 description 1
- 235000009499 Vanilla fragrans Nutrition 0.000 description 1
- 244000263375 Vanilla tahitensis Species 0.000 description 1
- 235000012036 Vanilla tahitensis Nutrition 0.000 description 1
- 238000013473 artificial intelligence Methods 0.000 description 1
- 230000006399 behavior Effects 0.000 description 1
- 230000009286 beneficial effect Effects 0.000 description 1
- 238000004590 computer program Methods 0.000 description 1
- 230000001143 conditioned effect Effects 0.000 description 1
- 230000003750 conditioning effect Effects 0.000 description 1
- 238000013135 deep learning Methods 0.000 description 1
- 230000007812 deficiency Effects 0.000 description 1
- 238000003745 diagnosis Methods 0.000 description 1
- 238000010586 diagram Methods 0.000 description 1
- 238000012986 modification Methods 0.000 description 1
- 230000004048 modification Effects 0.000 description 1
- 230000003287 optical effect Effects 0.000 description 1
- 238000005192 partition Methods 0.000 description 1
- 238000000275 quality assurance Methods 0.000 description 1
- 230000000306 recurrent effect Effects 0.000 description 1
- 238000011160 research Methods 0.000 description 1
- 230000011218 segmentation Effects 0.000 description 1
- 230000006403 short-term memory Effects 0.000 description 1
- 230000007480 spreading Effects 0.000 description 1
- 238000003892 spreading Methods 0.000 description 1
- 238000013179 statistical model Methods 0.000 description 1
- 238000003860 storage Methods 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F40/00—Handling natural language data
- G06F40/40—Processing or translation of natural language
- G06F40/42—Data-driven translation
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F40/00—Handling natural language data
- G06F40/40—Processing or translation of natural language
- G06F40/58—Use of machine translation, e.g. for multi-lingual retrieval, for server-side translation for client devices or for real-time translation
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F40/00—Handling natural language data
- G06F40/20—Natural language analysis
- G06F40/279—Recognition of textual entities
- G06F40/284—Lexical analysis, e.g. tokenisation or collocates
Definitions
- Machine translation is the automatic translation from a written sentence in one language into another language.
- Neural models for MT may try to address different kinds of uncertainty. This can include model uncertainty in which the model itself is unsure which of two or more translations is correct, and intrinsic uncertainty in which there is more than one correct translation for an input sentence.
- Existing NMT models may use a softmax layer to define a probability distribution over all target language sentences. While this approach can account for uncertainty by spreading the probability mass accordingly, it cannot distinguish between the different kinds of uncertainty.
- This shortcoming may cause many pathologies of neural machine translation models.
- One such pathology is that when the beam size is increased at inference time (when the model searches over a larger space of translations), the model prefers short translations when compared to the reference translations. This pathology may be addressed by dividing the model score by a function of the length of the translation or using a reward for longer candidate translations.
- fixes are post-hoc and do not address the underlying causes of the pathologies.
- NMT approaches can produce lower quality results or otherwise suffer a degradation in performance when used with larger beam sizes.
- the apps and services that employ such approaches may not provide suitable or appropriate results.
- aspects of the technology approach machine translation as a multi-label classification task.
- the system learns binary classifiers for each sentence pair (x,y) that indicate whether or not y is a valid translation of x.
- intrinsic uncertainty can be represented by setting the probabilities of two (or more) correct translations y 1 and y 2 to 1 simultaneously.
- the probabilities for each translation can be computed using separate binary classifiers, and thus there is no requirement that the probabilities sum to one over all translations.
- the ambiguity modeling approach herein utilizes sigmoid activations (or another bounded activation function) that assign a probability between 0 and 1 to each token in the vocabulary (the set of all tokens) at each time step.
- a loss function referred to herein as “Single-label Contrastive Objective for Non-Exclusive Sequences” (SCONES) allows models to be trained on single reference training data. This allows for modeling non-exclusive outputs. This approach can provide noticeable improvement over existing techniques regarding intrinsic uncertainty, and mitigates pathologies encountered by those other techniques.
- a system is configured for a machine translation model.
- the system comprises memory configured to store a set of text exemplars in a source language and a set of rewritten texts in one or more languages different from the source language, and one or more processing elements operatively coupled to the memory.
- the one or more processing elements implement the machine translation model as a neural network having an encoder module and a decoder module.
- a logits module is configured to act on the unbounded function to generate a corresponding bounded conditional probability for each token, wherein the conditional probabilities are not normalized over the vocabulary at each time step.
- a loss function module has a positive loss component and a scaled negative loss component, in which the loss function module is configured to identify whether each target text of a set of target texts is a valid translation of the given text exemplar.
- the set of text exemplars may comprise a set of input sentences, and the system is configured to learn binary classifiers for each sentence pair (x,y) that indicate whether or not y is a valid translation of x.
- intrinsic uncertainty may be represented by setting the conditional probabilities of at least two correct translations y 1 and y 2 to a maximum probability simultaneously.
- the logits module is configured to generate probabilities for each translation using separate binary classifiers.
- a probability of a complete translation of the given text exemplar may be decomposed into a product of token-level probabilities.
- the logits module is configured to apply sigmoid activations to the unbounded function at each time step.
- the positive loss component applies a log function to the bounded conditional probability for each reference token
- the scaled negative loss component applies a log function to the bounded conditional probability for each non-reference token.
- the system is configured to search for a translation that has a highest probability of being a translation of text segment to be translated.
- the system is configured to express intrinsic uncertainty associated with machine translation model.
- the loss function module is configured to adjust scaling of the negative loss component to maximize translation performance.
- the encoder module and the decoder module comprise a self-attention neural network encoder-decoder architecture.
- the encoder module and the decoder module may comprise a sequence to sequence model architecture.
- >): generating, by the encoder module, an encoded representation of the given text exemplar; receiving, by a decoder module, the encoded representation and a set of translation prefixes (y ⁇ i y 1 , . . .
- the set of text exemplars comprises a set of input sentences
- the method includes learning binary classifiers for each sentence pair (x,y) that indicate whether or not y is a valid translation of x.
- intrinsic uncertainty may be represented by setting the conditional probabilities of at least two correct translations y 1 and y 2 to a maximum probability simultaneously.
- generating the corresponding bounded conditional probability for each token comprises generating probabilities for each translation using separate binary classifiers.
- a probability of a complete translation of the given text exemplar may be decomposed into a product of token-level probabilities.
- generating the corresponding bounded conditional probability for each token may comprise applying sigmoid activations to the unbounded function at each time step.
- the positive loss component may apply a log function to the bounded conditional probability for each token
- the scaled negative loss component may apply a log function to the bounded conditional probability for each token.
- the method may further comprise, during inference searching for a translation that has a highest probability of being a translation of text segment to be translated.
- the method may further comprise adjusting scaling of the negative loss component to maximize translation performance.
- FIG. 1 illustrates an example of using a trained NMT model in a text-based application in accordance with aspects of the teleology.
- FIG. 2 illustrates a Transformer-type architecture that may be employed in accordance with aspects of the technology.
- FIG. 3 illustrates a multi-way NMT Transformer architecture for non-exclusive target sequences in accordance with aspects of the technology.
- FIGS. 4 A-B are tables showing Transformer hyper-parameters and MT training net sizes in accordance with aspects of the technology.
- FIGS. 5 A-B illustrate a comparison of a SCONES-based NMT systems with softmax baselines in accordance with aspects of the technology.
- FIG. 6 illustrates a table of language pairs and a values based on BLEU scores in accordance with aspects of the technology.
- FIGS. 7 A-F are plots show BLEU scores for different translation directions as a function of decoding speed in accordance with aspects of the technology.
- FIG. 8 plots BLEU scores as a function of the beam size in accordance with aspects of the technology.
- FIGS. 9 A-B plot test results involving length ratio, beam size and a values in accordance with aspects of the technology.
- FIGS. 10 A-B illustrate tables comparing results for beam search and exact search in accordance with aspects of the technology.
- FIG. 10 C illustrates mean and standard deviation of log-probabilities of the global highest probability translations search in accordance with aspects of the technology.
- FIG. 11 illustrates the percentage of beam search errors for different test criteria in accordance with aspects of the technology.
- FIGS. 12 A-B illustrate tables of sampling information when testing according to IBM- 3 in accordance with aspects of the technology.
- FIGS. 13 A-B present plot of BLEU scores with different sampling temperatures in accordance with aspects of the technology.
- FIG. 14 provides an example implementation of SCONES in JAX in accordance with aspects of the technology.
- FIGS. 15 A-B illustrate a system for use with aspects of the technology.
- FIG. 16 illustrates a method in accordance with aspects of the technology.
- FIG. 1 illustrates a high-level example 100 of using a trained NMT model in a text-based application.
- one or more source files e.g., curated text files in one or more selected languages
- the output from the model is translated text 106 , which is in a different language than the original language.
- the translated text can be used in a variety of applications, including machine translation, grammatical error correction, dialogue modeling or automatic foreign-language subtitling (e.g., for video content), etc.
- the translated text can be evaluated via a comparison against a baseline translation (e.g., a human-created gold translation).
- Some traditional NMT models may be based on a Transformer architecture.
- This architecture employs a softmax function to generate a set of output probabilities (a probability distribution).
- the softmax layer in neural machine translation is designed to model the distribution over mutually exclusive tokens.
- Machine translation is intrinsically uncertain: the same source sentence can have multiple semantically equivalent translations. Therefore, one aspect of the technology replaces the softmax activation with a multi-label classification layer that can model ambiguity more effectively.
- a SCONES loss function enables the modeling of non-exclusive outputs.
- the multi-label output layer can still be trained on single reference training data using the SCONES loss function.
- SCONES yields consistent BLEU score gains across various translation directions, particularly for medium resource language pairs and small beam sizes. By using smaller beam sizes, the approach can speed up inference by a factor on the order of 3.9 ⁇ and still match or improve the softmax BLEU score, as shown in testing.
- SCONES can be used to train NMT models that assign the highest probability to adequate translations, thus mitigating the “beam search curse”. As detailed below, additional experiments on synthetic language pairs with varying levels of uncertainty indicate that the improvements from SCONES over other approaches can be attributed to better handling of ambiguity.
- the SCONES approach may employ a self-attention architecture. e.g., the Transformer neural network encoder-decoder architecture.
- An exemplary general Transformer-type architecture is shown in FIG. 2 , which is based on the arrangement shown in U.S. Pat. No. 10,452,978, entitled “Attention-based sequence transduction neural networks”, the entire disclosure of which is incorporated herein by reference. While a Transformer-type architecture may be employed, the approach described herein can also be utilized with different architectures. For instance, sequence to sequence models, such as those that use a long short-term memory (LSTM) architecture.
- LSTM long short-term memory
- System 200 of FIG. 2 is implementable as computer programs by processors of one or more computers in one or more locations.
- the system 200 receives an input sequence 202 and processes the input sequence 202 to transduce the input sequence 202 into an output sequence 204 .
- the input sequence 202 has a respective network input at each of multiple input positions in an input order and the output sequence 204 has a respective network output at each of multiple output positions in an output order.
- System 200 can perform any of a variety of tasks that require processing sequential inputs to generate sequential outputs.
- System 200 includes an attention-based sequence transduction neural network 206 , which in turn includes an encoder neural network 208 and a decoder neural network 210 .
- the encoder neural network 208 is configured to receive the input sequence 202 and generate a respective encoded representation of each of the network inputs in the input sequence.
- An encoded representation is a vector or other ordered collection of numeric values.
- the decoder neural network 210 is then configured to use the encoded representations of the network inputs to generate the output sequence 204 .
- both the encoder 208 and the decoder 210 are attention-based.
- the encoder neural network 208 includes an embedding layer (input embedding) 212 and a sequence of one or more encoder subnetworks 214 .
- the encoder neural 208 network may N encoder subnetworks 214 .
- the embedding layer 212 is configured, for each network input in the input sequence, to map the network input to a numeric representation of the network input in an embedding space, e.g., into a vector in the embedding space.
- the embedding layer 212 then provides the numeric representations of the network inputs to the first subnetwork in the sequence of encoder subnetworks 214 .
- the embedding layer 212 may be configured to map each network input to an embedded representation of the network input and then combine, e.g., sum or average, the embedded representation of the network input with a positional embedding of the input position of the network input in the input order to generate a combined embedded representation of the network input.
- the positional embeddings are learned. As used herein, “learned” means that an operation or a value has been adjusted during the training of the sequence transduction neural network 206 . In other cases, the positional embeddings may be fixed and are different for each position.
- Each of the encoder subnetworks 214 is configured to receive a respective encoder subnetwork input for each of the plurality of input positions and to generate a respective subnetwork output for each of the plurality of input positions.
- the encoder subnetwork outputs generated by the last encoder subnetwork in the sequence are then used as the encoded representations of the network inputs.
- the encoder subnetwork input is the numeric representations generated by the embedding layer 212
- the encoder subnetwork input is the encoder subnetwork output of the preceding encoder subnetwork in the sequence.
- Each encoder subnetwork 214 includes an encoder self-attention sub-layer 216 .
- the encoder self-attention sub-layer 216 is configured to receive the subnetwork input for each of the plurality of input positions and, for each particular input position in the input order, apply an attention mechanism over the encoder subnetwork inputs at the input positions using one or more queries derived from the encoder subnetwork input at the particular input position to generate a respective output for the particular input position.
- the attention mechanism is a multi-head attention mechanism as shown.
- each of the encoder subnetworks 214 may also include a residual connection layer that combines the outputs of the encoder self-attention sub-layer with the inputs to the encoder self-attention sub-layer to generate an encoder self-attention residual output and a layer normalization layer that applies layer normalization to the encoder self-attention residual output.
- a residual connection layer that combines the outputs of the encoder self-attention sub-layer with the inputs to the encoder self-attention sub-layer to generate an encoder self-attention residual output
- a layer normalization layer that applies layer normalization to the encoder self-attention residual output.
- Some or all of the encoder subnetworks can also include a position-wise feed-forward layer 218 that is configured to operate on each position in the input sequence separately.
- the feed-forward layer 218 is configured receive an input at the input position and apply a sequence of transformations to the input at the input position to generate an output for the input position.
- the inputs received by the position-wise feed-forward layer 218 can be the outputs of the layer normalization layer when the residual and layer normalization layers are included or the outputs of the encoder self-attention sub-layer 216 when the residual and layer normalization layers are not included.
- the transformations applied by the layer 218 will generally be the same for each input position (but different feed-forward layers in different subnetworks may apply different transformations).
- the encoder subnetwork can also include a residual connection layer that combines the outputs of the position-wise feed-forward layer with the inputs to the position-wise feed-forward layer to generate an encoder position-wise residual output and a layer normalization layer that applies layer normalization to the encoder position-wise residual output.
- these two layers are also collectively referred to as an “Add & Norm” operation.
- the outputs of this layer normalization layer can then be used as the outputs of the encoder subnetwork 214 .
- the decoder neural network 210 is configured to generate the output sequence in an auto-regressive manner. That is, the decoder neural network 210 generates the output sequence, by at each of a plurality of generation time steps, generating a network output for a corresponding output position conditioned on (i) the encoded representations and (ii) network outputs at output positions preceding the output position in the output order. In particular, for a given output position, the decoder neural network generates an output that defines a probability distribution over possible network outputs at the given output position. The decoder neural network can then select a network output for the output position by sampling from the probability distribution or by selecting the network output with the highest probability.
- the decoder neural network 210 is auto-regressive, at each generation time step, the decoder network 210 operates on the network outputs that have already been generated before the generation time step, i.e., the network outputs at output positions preceding the corresponding output position in the output order. In some implementations, to ensure this is the case during both inference and training, at each generation time step the decoder neural network 210 shifts the already generated network outputs right by one output order position (i.e., introduces a one position offset into the already generated network output sequence) and (as will be described in more detail below) masks certain operations so that positions can only attend to positions up to and including that position in the output sequence (and not subsequent positions).
- the decoder neural network 210 includes an embedding layer (output embedding) 220 , a sequence of decoder subnetworks 222 , a linear layer 224 , and a softmax layer 226 .
- the decoder neural network can include N decoder subnetworks 222 .
- the embedding layer 220 is configured to, at each generation time step, for each network output at an output position that precedes the current output position in the output order, map the network output to a numeric representation of the network output in the embedding space. The embedding layer 220 then provides the numeric representations of the network outputs to the first subnetwork 222 in the sequence of decoder subnetworks.
- the embedding layer 220 is configured to map each network output to an embedded representation of the network output and combine the embedded representation of the network output with a positional embedding of the output position of the network output in the output order to generate a combined embedded representation of the network output.
- the combined embedded representation is then used as the numeric representation of the network output.
- the embedding layer 220 generates the combined embedded representation in the same manner as described above with reference to the embedding layer 212 .
- Each decoder subnetwork 222 is configured to, at each generation time step, receive a respective decoder subnetwork input for each of the plurality of output positions preceding the corresponding output position and to generate a respective decoder subnetwork output for each of the plurality of output positions preceding the corresponding output position (or equivalently, when the output sequence has been shifted right, each network output at a position up to and including the current output position).
- each decoder subnetwork 222 includes two different attention sub-layers: a decoder self-attention sub-layer 228 and an encoder-decoder attention sub-layer 230 .
- Each decoder self-attention sub-layer 228 is configured to, at each generation time step, receive an input for each output position preceding the corresponding output position and, for each of the particular output positions, apply an attention mechanism over the inputs at the output positions preceding the corresponding position using one or more queries derived from the input at the particular output position to generate a updated representation for the particular output position. That is, the decoder self-attention sub-layer 228 applies an attention mechanism that is masked so that it does not attend over or otherwise process any data that is not at a position preceding the current output position in the output sequence.
- Each encoder-decoder attention sub-layer 230 is configured to, at each generation time step, receive an input for each output position preceding the corresponding output position and, for each of the output positions, apply an attention mechanism over the encoded representations at the input positions using one or more queries derived from the input for the output position to generate an updated representation for the output position.
- the encoder-decoder attention sub-layer 230 applies attention over encoded representations while the decoder self-attention sub-layer 228 applies attention over inputs at output positions.
- the decoder self-attention sub-layer 228 is shown as being before the encoder-decoder attention sub-layer in the processing order within the decoder subnetwork 222 . In other examples, however, the decoder self-attention sub-layer 228 may be after the encoder-decoder attention sub-layer 230 in the processing order within the decoder subnetwork 222 or different subnetworks may have different processing orders.
- each decoder subnetwork 222 includes, after the decoder self-attention sub-layer 228 , after the encoder-decoder attention sub-layer 230 , or after each of the two sub-layers, a residual connection layer that combines the outputs of the attention sub-layer with the inputs to the attention sub-layer to generate a residual output and a layer normalization layer that applies layer normalization to the residual output.
- a residual connection layer that combines the outputs of the attention sub-layer with the inputs to the attention sub-layer to generate a residual output
- a layer normalization layer that applies layer normalization to the residual output.
- the decoder subnetwork 222 also include a position-wise feed-forward layer 232 that is configured to operate in a similar manner as the position-wise feed-forward layer 218 from the encoder 208 .
- the layer 232 is configured to, at each generation time step: for each output position preceding the corresponding output position: receive an input at the output position, and apply a sequence of transformations to the input at the output position to generate an output for the output position.
- the inputs received by the position-wise feed-forward layer 232 can be the outputs of the layer normalization layer (following the last attention sub-layer in the subnetwork 222 ) when the residual and layer normalization layers are included or the outputs of the last attention sub-layer in the subnetwork 222 when the residual and layer normalization layers are not included.
- the decoder subnetwork can also include a residual connection layer that combines the outputs of the position-wise feed-forward layer with the inputs to the position-wise feed-forward layer to generate a decoder position-wise residual output and a layer normalization layer that applies layer normalization to the decoder position-wise residual output.
- These two layers are also collectively referred to as an “Add & Norm” operation.
- the outputs of this layer normalization layer can then be used as the outputs of the decoder subnetwork 222 .
- the linear layer 224 applies a learned linear transformation to the output of the last decoder subnetwork 222 in order to project the output of the last decoder subnetwork 222 into the appropriate space for processing by the softmax layer 226 .
- the softmax layer 226 then applies a softmax function over the outputs of the linear layer 224 to generate the probability distribution (output probabilities) 234 over the possible network outputs at the generation time step.
- the decoder 210 can then select a network output from the possible network outputs using the probability distribution.
- NMT neural machine translation
- aspects of the technology frame machine translation as a multi-label classification task.
- the system learns binary classifiers for each sentence pair (x, y) that indicate whether or not y is a valid translation of x.
- intrinsic uncertainty can be represented by setting the probabilities of two (or more) correct translations y 1 and y 2 to a maximum. e.g. a “1” on a scale of 0-1, simultaneously.
- the probabilities for each translation are computed using separate binary classifiers, and thus there is no requirement that the probabilities sum to 1 over all translations.
- the probability of a complete translation is decomposed into a product of the token-level probabilities.
- a softmax output layer in Transformer model e.g., 226 in FIG. 2
- sigmoid activations that assign a probability between 0 and 1 to each token in the vocabulary at each time step.
- another bounded activation function may be employed such as tanh.
- the SCONES loss function allows the system to train models on single reference training data. Unlike noise-contrastive estimation (NCE), which had a primary goal to efficiently train models over large vocabularies, using the SCONES approach enables modeling of non-exclusive outputs.
- SCONES mitigates pathologies of traditional NMT models.
- Softmax-based models have been shown to assign the highest probability to either empty or inadequate translations (modes). This behavior manifests itself as the “beam search curse” where increasing the beam size may lead to worse translation quality, as described in “Six challenges for neural machine translation” by Koehn and Knowles, published in 2017 in the Proceedings of the First Workshop on Neural Machine Translation, pages 28-39, by the Association for Computational Linguistics (the entire disclosure of which is incorporated herein by reference). Testing shows that SCONES can be used to train models that a) assign the highest probability to adequate translations and b) do not suffer from the beam search curse.
- SCONES may also be used to train models on synthetic translation pairs that were generated by sampling from the IBM Model 3 (“IBM- 3 ”) (see “The mathematics of statistical machine translation: Parameter estimation” by Brown et al., published in 1993 in Computational Linguistics, the entire disclosure of which is incorporated herein by reference. By varying the sampling temperature (the entropy of the distribution), one can control the level of ambiguity in the language pair. Testing shows that SCONES is effective in improving the adequacy of the highest probability translation for highly ambiguous translation pairs, confirming that SCONES can handle intrinsic uncertainty highly effectively.
- IBM Model 3 IBM Model 3
- the special end-of-sentence symbol as w 1 ⁇ /s>
- a center dot “ ⁇ ” is used for string concatenations.
- SCONES learns a separate binary classifier for each sentence pair (x, y).
- x) 1 for the empty translation prefix):
- conditional probabilities are assigned by applying the sigmoid activation function ⁇ ( ⁇ ) to the logits (in which the logits are vectors of raw predictions that the model generates prior to normalization):
- w ⁇ V is a single token
- are the logits at time step i
- ⁇ (x, y ⁇ i ) w is the logit corresponding to token w.
- FIG. 3 shows a multi-way NMT Transformer architecture for non-exclusive target sequences.
- the source sentence x is applied to transformer encoder 302 and the output from the transformer encoder 304 is applied to transformer decoder 304 along with translation prefix y ⁇ i .
- the output of the transformer decoder 304 is applied to logits 306 .
- the transformer decoder output is bounded with a logistic activation function, ⁇ , where ⁇ (f( )) is the bounded activation function.
- ⁇ a logistic activation function
- P 308 For each token w (e.g., w 1 , w 2 , w 3 , w 4 , etc.), a corresponding conditional probability P 308 is obtained.
- the SCONES loss function aims to balance two token-level objectives using a scaling factor ⁇ + :
- the positive loss component applies a log function to the bounded conditional probability for each reference token.
- Block 310 in FIG. 3 illustrates the probabilities 308 of the bounded activation function being applied to the SCONES loss function. Aspects of the loss function include:
- the negative loss component applies a log function to the bounded conditional probability for each non-reference token.
- the system searches for the translation y* that ends with ⁇ /s> and has the highest probability of being a translation of x:
- vanilla beam search is a standard beam search algorithm for sequence to sequence models.
- Such a beam search takes the best N tokens, and selects the best N partial sequences (at each time step), considering the probabilities of the combination for all preceding words in addition to the word in the current location.
- An example is described in “Sequence to Sequence Learning with Neural Networks” by Sutskever et al., published Dec. 14, 2014, the entire disclosure of which is incorporated herein by reference.
- the same inference code is used for both softmax baselines and the SCONES trained models.
- the only difference would be that the logits from SCONES models are transformed by a sigmoid instead of a softmax activation—in other words no summation over the full vocabulary (set of all tokens) is necessary.
- the SCONES loss function is related to noise-contrastive estimation (NCE) in the sense that both methods reformulate next word prediction as a multi-label classification problem, and both losses have a “positive” component for the gold label, and a “negative” component for other labels.
- NCE noise-contrastive estimation
- the negative loss component ( _( ⁇ )) in SCONES does not require sampling from a noise distribution as it makes use of all tokens in the vocabulary besides the gold token. This is possible because the SCONES approach is able to operate on a limited (e.g., 32 K) subword vocabulary, whereas NCE is typically used to train language models with much larger word-level vocabularies.
- NCE has a “self-normalization” property which can reduce computation by avoiding the expensive partition function for distributions over the full vocabulary. To do so, NCE uses the multi-label classification task as a proxy problem. By contrast, in SCONES, the multi-label classification perspective is used to express the intrinsic uncertainty in MT and is not simply a proxy for the full softmax. Thus, a primary motivation for SCONES is not self-normalization over the full vocabulary. Details regarding NCE may be found in “Noise-contrastive estimation: A new estimation principle for unnormalized statistical models” by Gutmann and Hyvärinen, in the Proceedings of the thirteenth international conference on artificial intelligence and statistics, pages 297-304. JMLR Workshop and Conference Proceedings, the entire disclosure of which is incorporated herein by reference.
- the training sets were filtered using language ID and simple length-based heuristics, and split into subwords using joint 32K SentencePiece models, as described in “SentencePiece: A simple and language independent subword tokenizer and detokenizer for neural text processing” by Kudo and Richardson, Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing: System Demonstrations, pages 66-71. Brussels, Belgium, the entire disclosure of which is incorporated herein by reference.
- the softmax baselines were trained by minimizing cross-entropy without label smoothing.
- the multi-way NMT models were trained by minimizing the SCONES loss function described above, also without label smoothing.
- the models were evaluated on the WMT19 test sets with SacreBLEU, using the WMT18 test sets as development sets to tune a.
- a greedy search implementation is configured to operate directly on the logits without applying the output activations. Details regarding SacreBLEU can be found in “A call for clarity in reporting BLEU scores” by Matt Post. 2018, in Proceedings of the Third Conference on Machine Translation: Research Papers, pages 186-191, the entire disclosure of which is incorporated herein by reference.
- the tables 500 and 520 in FIGS. 5 A-B compares a SCONES-based NMT systems with the softmax baselines when a is tuned based on the BLEU score on the development set shown in the table of FIG. 6 . As shown. SCONES yields consistent improvements across the board. For four of six language pairs (all except en-de and fi-en), SCONES with greedy search is even able to outperform the softmax models with beam search. The language pairs with fewer resources (fi ⁇ en, lt ⁇ en) benefit from SCONES training much more than the high-resource language pairs (de ⁇ en).
- the softmax-based models reach their (near) optimum BLEU score with a beam size of around 4. Most of the SCONES models can achieve similar or better BLEU scores with greedy search. Replacing beam-4 search with greedy search corresponds to a 3.9 ⁇ speed-up (2.76 ⁇ 10.64 sentences per second) on an entry-level NVIDIA Quadro P1000 GPU with a batch size of 4.8
- FIGS. 7 A-F show the BLEU scores for all six translation directions as a function of decoding speed.
- the SCONES results are all above the softmax results.
- Most of the speed-ups are due to choosing a smaller beam size and not due to SCONES avoiding the normalization over the full vocabulary. Further speed-ups from SCONES are expected when comparing models with larger vocabularies.
- FIG. 8 plots the BLEU score as a function of the beam size.
- the sharp decline of the softmax curve 802 for large beam sizes reflects the beam search curse for the softmax baseline.
- FIG. 10 C which illustrates mean and standard deviation (error bars) of log-probabilities of the global highest probability translations (found using exact search) and the empty translations for German-English, sheds some light on why SCONES with small a does not prefer empty translations.
- 1002 shows a softmax empty translation
- 1004 shows a softmax exact search translation
- 1006 shows a SCONES empty translation
- 1008 shows a SCONES exact search translation.
- a small a leads to a larger gap between the log-probabilities of the exact search translation and the empty translation that arises from higher log-probabilities for the exact-search translation along with smaller variances.
- a small a reduces the importance of the negative loss component ( _( ⁇ )) in the above-identified SCONES (x, y, i) equation, and thus biases each binary classifier towards predicting the true label.
- FIG. 11 displays the percentage of beam search errors (for a German-English example), in particular the fraction of sentences for which beam search did not find the global best translation, as a function of beam size.
- 1102 is the softmax plot
- SCONES A key motivation for SCONES is to equip the model to naturally represent intrinsic uncertainty, i.e., the existence of multiple correct target sentences for the same source sentence.
- synthetic language pairs were generated that differ by the level of ambiguity.
- MGIZA is described in “Parallel implementations of word alignment tool” by Gao and Vogel in Software Engineering, Testing, and Quality Assurance for Natural Language Processing”, pages 49-57, 2008, the entire disclosure of which is incorporated by reference herein.
- IBM-3 is a generative symbolic model that describes the translation process from one language into another with a generative story, and has been used to find word alignments for statistical (phrase-based) machine translation.
- the generative story includes different steps such as distortion (word reordering), fertility (1: n word mappings), and lexical translation (word-to-word translation) that describe the translation process.
- the parameters of IBM-3 define probability distributions for each step. In the experiments, IBM- 3 was not used for finding word alignments. Instead, for the original German sentences synthetic English-like translations were sampled from the model with different sampling temperatures to control the ambiguity levels of the translation task. A low sampling temperature generates sentence pairs that still capture some of the characteristics of MT such as word reorderings, but the mapping is mostly deterministic (i.e., the same source token is almost always translated to the same target token). A high temperature corresponds to more randomness, which is to say more intrinsic uncertainty. NMT models may be trained using either sofimax or SCONES on the synthetic corpora.
- the tables in FIGS. 12 A-B contains more details about sampling from IBM- 3 .
- the parameters of the IBM-3 model are composed of a set of fertility probabilities n( ⁇
- the following generative process produces the target language sentence y from a source language sentence x:
- the IBM-3 model parameters may be first estimated using the MGIZA word alignment tool. Then. English-like target sentences are sampled for the German source sentences following the generative story above. To control the level of uncertainty in the synthetic translation task, the entropies of the n( ⁇
- temperature sampling uses the following distribution for each c ⁇ C:
- a low temperature amplifies large differences in probabilities, and thus leads to a lower entropy and less ambiguity.
- SCONES has one more parameter ( ⁇ ) than softmax that trades off positive and negative examples. This enables SCONES to achieve enhanced performance as shown in the above test results.
- FIG. 14 provides an example implementation of SCONES written in JAX.
- FIGS. 15 A and 15 B are pictorial and functional diagrams, respectively, of an example system 1500 that includes a plurality of computing devices and databases connected via a network.
- computing device(s) 1502 may be implemented as a cloud-based server system.
- Databases 1504 , 1506 and 1508 may store.
- the server system may access the databases via network 1510 .
- Client devices may include one or more of a desktop computer 1512 and a laptop or tablet PC 1514 , for instance to provide the original text or other content, and/or to view the output (e.g., selected translations or use of the assessment or other information in a translation service, app or other program).
- each of the computing devices 1502 and 1512 - 1514 may include one or more processors, memory, data and instructions.
- the memory stores information accessible by the one or more processors, including instructions and data (e.g., models) that may be executed or otherwise used by the processor(s).
- the memory may be of any type capable of storing information accessible by the processor(s), including a computing device-readable medium.
- the memory is a non-transitory medium such as a hard-drive, memory card, optical disk, solid-state, etc. Systems may include different combinations of the foregoing, whereby different portions of the instructions and data are stored on different types of media.
- the instructions may be any set of instructions to be executed directly (such as machine code) or indirectly (such as scripts) by the processor(s).
- the instructions may be stored as computing device code on the computing device-readable medium.
- the terms “instructions”, “modules” and “programs” may be used interchangeably herein.
- the instructions may be stored in object code format for direct processing by the processor, or in any other computing device language including scripts or collections of independent source code modules that are interpreted on demand or compiled in advance.
- the processors may be any conventional processors, such as commercially available CPUs, TPUs, graphical processing units (GPUs), etc.
- each processor may be a dedicated device such as an ASIC or other hardware-based processor.
- FIG. 15 B functionally illustrates the processors, memory, and other elements of a given computing device as being within the same block, such devices may actually include multiple processors, computing devices, or memories that may or may not be stored within the same physical housing.
- the memory may be a hard drive or other storage media located in a housing different from that of the processor(s), for instance in a cloud computing system of server 1502 . Accordingly, references to a processor or computing device will be understood to include references to a collection of processors or computing devices or memories that may or may not operate in parallel.
- the input data such as one or more sentences or sets of textual content
- the client devices may utilize such information in various apps or other programs to perform translations, dialog modeling, spelling or grammatic error corrections, quality assessment or other metric analysis, recommendations, classification, search, etc. This could include assigning quality scores to different translations based upon the results of the processing. Therefore, quality scores can be used to rank translations and prioritize good translations in serving, such as for a video streaming service with subtitles.
- the computing devices may include all of the components normally used in connection with a computing device such as the processor and memory described above as well as a user interface subsystem for receiving input from a user and presenting information to the user (e.g., text, imagery and/or other graphical elements).
- the user interface subsystem may include one or more user inputs (e.g., at least one front (user) facing camera, a mouse, keyboard, touch screen and/or microphone) and one or more display devices (e.g., a monitor having a screen or any other electrical device that is operable to display information (e.g., text, imagery and/or other graphical elements).
- Other output devices, such as speaker(s) may also provide information to users.
- the user-related computing devices may communicate with a back-end computing system (e.g., server 1502 ) via one or more networks, such as network 1510 .
- the network 910 and intervening nodes, may include various configurations and protocols including short range communication protocols such as BluetoothTM.
- Bluetooth LETM the Internet, World Wide Web, intranets, virtual private networks, wide area networks, local networks, private networks using communication protocols proprietary to one or more companies, Ethernet.
- WiFi and HTTP and various combinations of the foregoing.
- Such communication may be facilitated by any device capable of transmitting data to and from other computing devices, such as modems and wireless interfaces.
- computing device 1502 may include one or more server computing devices having a plurality of computing devices, e.g., a load balanced server farm or cloud computing system, that exchange information with different nodes of a network for the purpose of receiving, processing and transmitting the data to and from other computing devices.
- computing device 1502 may include one or more server computing devices that are capable of communicating with any of the computing devices 1512 - 1514 via the network 1510 .
- Model information or other data derived from the SCONES approach may be shared by the server with one or more of the client computing devices.
- the client device(s) may maintain their own databases, models, etc.
- FIG. 16 illustrates a method 1600 for addressing ambiguity in neural machine translation in accordance with aspects of the technology.
- a set of text exemplars is stored in memory.
- the encoder module generates an encoded representation of the given text exemplar.
- a decoder module receives the encoded representation and a set of translation prefixes (y ⁇ i ⁇ y 1 , . . . , y i-1 >).
- the decoder module outputs an unbounded function ⁇ (x, y ⁇ i ) corresponding to a set of tokens associated with each pair of the given text exemplar x and translation prefix from the set of translation prefixes y ⁇ i , wherein each token is assigned a probability between 0 and 1 in a vocabulary of the given text exemplar at each time step.
- a logits module generates, based on the unbounded function, a corresponding bounded conditional probability for each token, wherein the conditional probabilities are not normalized over the vocabulary at each time step.
- a loss function module having a positive loss component and a scaled negative loss component identifies whether each target text of a set of target texts is a valid translation of the given text exemplar.
- Machine translation is a task with high intrinsic uncertainty: a source sentence can have multiple valid translations. It has been demonstrated that NMT models and specifically Transformers, can learn to model mutually non-exclusive target sentences from single-label training data using the SCONES loss function. Rather than learn a single distribution over all target sentences. SCONES learns multiple binary classifiers that indicate whether or not a target sentence is a valid translation of the source sentence. SCONES yields improved translation quality over conventional softmax-based models for six different translation directions, or (alternatively) speed-ups of up to 3.9 ⁇ without any degradation in translation performance.
- SCONES loss function is easy to implement. Adapting standard softmax-based sequence-to-sequence architectures such as Transformers requires only replacing the cross-entropy loss function with SCONES and the softmax with sigmoid activations. The remaining parts of the training and inference pipelines can be kept unchanged. SCONES can be useful in handling uncertainty for a variety of ambiguous NLP problems beyond translation, such as generation and dialog.
Abstract
The technology addresses ambiguity in neural machine translation. An encoder module receives a given text exemplar and generates an encoded representation of it. A decoder module receives the encoded representation and a set of translation prefixes. The decoder module outputs an unbounded function corresponding to a set of tokens associated with each pair of the given text exemplar and translation prefix from the set of translation prefixes. Each token is assigned a probability between 0 and 1 in a vocabulary of the exemplar at each time step. A logits module generates, based on the unbounded function, a corresponding bounded conditional probability for each token, wherein the probabilities are not normalized over the vocabulary at each time step. A loss function module having a positive loss component and a scaled negative loss component identifies whether each target text of a set of target texts is a valid translation of the exemplar.
Description
- The present application is a continuation of International Application No. PCT/US2022/026683, filed Apr. 28, 2022, the entire disclosure of which is hereby incorporated by reference.
- Machine translation (MT) is the automatic translation from a written sentence in one language into another language. Neural models for MT—neural machine translation (NMT) may try to address different kinds of uncertainty. This can include model uncertainty in which the model itself is unsure which of two or more translations is correct, and intrinsic uncertainty in which there is more than one correct translation for an input sentence. Existing NMT models—may use a softmax layer to define a probability distribution over all target language sentences. While this approach can account for uncertainty by spreading the probability mass accordingly, it cannot distinguish between the different kinds of uncertainty.
- This shortcoming may cause many pathologies of neural machine translation models. One such pathology is that when the beam size is increased at inference time (when the model searches over a larger space of translations), the model prefers short translations when compared to the reference translations. This pathology may be addressed by dividing the model score by a function of the length of the translation or using a reward for longer candidate translations. However, such fixes are post-hoc and do not address the underlying causes of the pathologies. Thus, such NMT approaches can produce lower quality results or otherwise suffer a degradation in performance when used with larger beam sizes. As a result, the apps and services that employ such approaches may not provide suitable or appropriate results.
- Aspects of the technology approach machine translation as a multi-label classification task. Rather than learning a single distribution P(y|x) over all target sentences y for a source sentence x, the system learns binary classifiers for each sentence pair (x,y) that indicate whether or not y is a valid translation of x. In this framework, intrinsic uncertainty can be represented by setting the probabilities of two (or more) correct translations y1 and y2 to 1 simultaneously. The probabilities for each translation can be computed using separate binary classifiers, and thus there is no requirement that the probabilities sum to one over all translations. In contrast to a typical machine translation model (e.g., a Transformer model) that uses a softmax output layer, the ambiguity modeling approach herein utilizes sigmoid activations (or another bounded activation function) that assign a probability between 0 and 1 to each token in the vocabulary (the set of all tokens) at each time step. In addition, a loss function, referred to herein as “Single-label Contrastive Objective for Non-Exclusive Sequences” (SCONES) allows models to be trained on single reference training data. This allows for modeling non-exclusive outputs. This approach can provide noticeable improvement over existing techniques regarding intrinsic uncertainty, and mitigates pathologies encountered by those other techniques. While this approach is particularly beneficial for text translation situations, it is also applicable to other types of classification problems with models for which training corpora normally contain single references, but for which multiple labels are acceptable in practice. One such type is text classification, such as when classifying a newspaper article, website content or a medical diagnosis.
- According to one aspect of the technology, a system is configured for a machine translation model. The system comprises memory configured to store a set of text exemplars in a source language and a set of rewritten texts in one or more languages different from the source language, and one or more processing elements operatively coupled to the memory. The one or more processing elements implement the machine translation model as a neural network having an encoder module and a decoder module. The encoder module comprises an encoder neural network configured to receive a given text exemplar (x=<x1, . . . , xx>) and to generate an encoded representation of the given text exemplar. The decoder module comprises a decoder neural network configured to receive the encoded representation and a set of translation prefixes (y<i=<y1, . . . , yi-1>) and to output an unbounded function ƒ(x, y<i) corresponding to a set of tokens associated with each pair of the given text exemplar x and translation prefix from the set of translation prefixes wherein each token is assigned a probability between 0 and 1 in a vocabulary of the given text exemplar at each time step. A logits module is configured to act on the unbounded function to generate a corresponding bounded conditional probability for each token, wherein the conditional probabilities are not normalized over the vocabulary at each time step. A loss function module has a positive loss component and a scaled negative loss component, in which the loss function module is configured to identify whether each target text of a set of target texts is a valid translation of the given text exemplar.
- The set of text exemplars may comprise a set of input sentences, and the system is configured to learn binary classifiers for each sentence pair (x,y) that indicate whether or not y is a valid translation of x. Here, intrinsic uncertainty may be represented by setting the conditional probabilities of at least two correct translations y1 and y2 to a maximum probability simultaneously. Alternatively or additionally, the logits module is configured to generate probabilities for each translation using separate binary classifiers.
- In accordance with any of the above, a probability of a complete translation of the given text exemplar may be decomposed into a product of token-level probabilities. Alternatively or additionally, the logits module is configured to apply sigmoid activations to the unbounded function at each time step. Alternatively or additionally, the positive loss component applies a log function to the bounded conditional probability for each reference token, and the scaled negative loss component applies a log function to the bounded conditional probability for each non-reference token. Alternatively or additionally, during inference the system is configured to search for a translation that has a highest probability of being a translation of text segment to be translated.
- In accordance with any of the above, the system is configured to express intrinsic uncertainty associated with machine translation model. Alternatively or additionally, the loss function module is configured to adjust scaling of the negative loss component to maximize translation performance.
- In accordance with any of the above, the encoder module and the decoder module comprise a self-attention neural network encoder-decoder architecture. Alternatively the encoder module and the decoder module may comprise a sequence to sequence model architecture.
- According to another aspect, a machine translation method employs a neural network, and the method comprises: storing, in memory, a set of text exemplars: receiving, by an encoder module comprising an encoder neural network, a given text exemplar (x=<x1, . . . , x|x|>): generating, by the encoder module, an encoded representation of the given text exemplar; receiving, by a decoder module, the encoded representation and a set of translation prefixes (y<i=y1, . . . , yi-1>): outputting, by the decoder module, an unbounded function ƒ(x, y<i) corresponding to a set of tokens associated with each pair of the given text exemplar x and translation prefix from the set of translation prefixes wherein each token is assigned a probability between 0 and 1 in a vocabulary of the given text exemplar at each time step; generating, by a logits module based on the unbounded function, a corresponding bounded conditional probability for each token, wherein the conditional probabilities are not normalized over the vocabulary at each time step: and identifying, by a loss function module having a positive loss component and a scaled negative loss component, whether each target text of a set of target texts is a valid translation of the given text exemplar.
- In one example, the set of text exemplars comprises a set of input sentences, and the method includes learning binary classifiers for each sentence pair (x,y) that indicate whether or not y is a valid translation of x. Here, intrinsic uncertainty may be represented by setting the conditional probabilities of at least two correct translations y1 and y2 to a maximum probability simultaneously. Alternatively or additionally, generating the corresponding bounded conditional probability for each token comprises generating probabilities for each translation using separate binary classifiers.
- In accordance with any of the above, a probability of a complete translation of the given text exemplar may be decomposed into a product of token-level probabilities. Alternatively or additionally, generating the corresponding bounded conditional probability for each token may comprise applying sigmoid activations to the unbounded function at each time step. Alternatively or additionally, the positive loss component may apply a log function to the bounded conditional probability for each token, and the scaled negative loss component may apply a log function to the bounded conditional probability for each token.
- In accordance with any of the above, the method may further comprise, during inference searching for a translation that has a highest probability of being a translation of text segment to be translated. Alternatively or additionally, the method may further comprise adjusting scaling of the negative loss component to maximize translation performance.
-
FIG. 1 illustrates an example of using a trained NMT model in a text-based application in accordance with aspects of the teleology. -
FIG. 2 illustrates a Transformer-type architecture that may be employed in accordance with aspects of the technology. -
FIG. 3 illustrates a multi-way NMT Transformer architecture for non-exclusive target sequences in accordance with aspects of the technology. -
FIGS. 4A-B are tables showing Transformer hyper-parameters and MT training net sizes in accordance with aspects of the technology. -
FIGS. 5A-B illustrate a comparison of a SCONES-based NMT systems with softmax baselines in accordance with aspects of the technology. -
FIG. 6 illustrates a table of language pairs and a values based on BLEU scores in accordance with aspects of the technology. -
FIGS. 7A-F are plots show BLEU scores for different translation directions as a function of decoding speed in accordance with aspects of the technology. -
FIG. 8 plots BLEU scores as a function of the beam size in accordance with aspects of the technology. -
FIGS. 9A-B plot test results involving length ratio, beam size and a values in accordance with aspects of the technology. -
FIGS. 10A-B illustrate tables comparing results for beam search and exact search in accordance with aspects of the technology. -
FIG. 10C illustrates mean and standard deviation of log-probabilities of the global highest probability translations search in accordance with aspects of the technology. -
FIG. 11 illustrates the percentage of beam search errors for different test criteria in accordance with aspects of the technology. -
FIGS. 12A-B illustrate tables of sampling information when testing according to IBM-3 in accordance with aspects of the technology. -
FIGS. 13A-B present plot of BLEU scores with different sampling temperatures in accordance with aspects of the technology. -
FIG. 14 provides an example implementation of SCONES in JAX in accordance with aspects of the technology. -
FIGS. 15A-B illustrate a system for use with aspects of the technology. -
FIG. 16 illustrates a method in accordance with aspects of the technology. - Overview
-
FIG. 1 illustrates a high-level example 100 of using a trained NMT model in a text-based application. In this example, one or more source files (e.g., curated text files in one or more selected languages) inblock 102 are applied to a trained model atblock 104. The output from the model is translatedtext 106, which is in a different language than the original language. The translated text can be used in a variety of applications, including machine translation, grammatical error correction, dialogue modeling or automatic foreign-language subtitling (e.g., for video content), etc. The translated text can be evaluated via a comparison against a baseline translation (e.g., a human-created gold translation). - Some traditional NMT models may be based on a Transformer architecture. This architecture, as detailed below, employs a softmax function to generate a set of output probabilities (a probability distribution). However, the softmax layer in neural machine translation is designed to model the distribution over mutually exclusive tokens. Machine translation, however, is intrinsically uncertain: the same source sentence can have multiple semantically equivalent translations. Therefore, one aspect of the technology replaces the softmax activation with a multi-label classification layer that can model ambiguity more effectively.
- A SCONES loss function enables the modeling of non-exclusive outputs. The multi-label output layer can still be trained on single reference training data using the SCONES loss function. SCONES yields consistent BLEU score gains across various translation directions, particularly for medium resource language pairs and small beam sizes. By using smaller beam sizes, the approach can speed up inference by a factor on the order of 3.9× and still match or improve the softmax BLEU score, as shown in testing. Furthermore, SCONES can be used to train NMT models that assign the highest probability to adequate translations, thus mitigating the “beam search curse”. As detailed below, additional experiments on synthetic language pairs with varying levels of uncertainty indicate that the improvements from SCONES over other approaches can be attributed to better handling of ambiguity.
- General Transformer Approach
- The SCONES approach may employ a self-attention architecture. e.g., the Transformer neural network encoder-decoder architecture. An exemplary general Transformer-type architecture is shown in
FIG. 2 , which is based on the arrangement shown in U.S. Pat. No. 10,452,978, entitled “Attention-based sequence transduction neural networks”, the entire disclosure of which is incorporated herein by reference. While a Transformer-type architecture may be employed, the approach described herein can also be utilized with different architectures. For instance, sequence to sequence models, such as those that use a long short-term memory (LSTM) architecture. -
System 200 ofFIG. 2 is implementable as computer programs by processors of one or more computers in one or more locations. Thesystem 200 receives aninput sequence 202 and processes theinput sequence 202 to transduce theinput sequence 202 into anoutput sequence 204. Theinput sequence 202 has a respective network input at each of multiple input positions in an input order and theoutput sequence 204 has a respective network output at each of multiple output positions in an output order. -
System 200 can perform any of a variety of tasks that require processing sequential inputs to generate sequential outputs.System 200 includes an attention-based sequence transductionneural network 206, which in turn includes an encoderneural network 208 and a decoderneural network 210. The encoderneural network 208 is configured to receive theinput sequence 202 and generate a respective encoded representation of each of the network inputs in the input sequence. An encoded representation is a vector or other ordered collection of numeric values. The decoderneural network 210 is then configured to use the encoded representations of the network inputs to generate theoutput sequence 204. Generally, both theencoder 208 and thedecoder 210 are attention-based. In some cases, neither the encoder nor the decoder includes any convolutional layers or any recurrent layers. The encoderneural network 208 includes an embedding layer (input embedding) 212 and a sequence of one ormore encoder subnetworks 214. The encoder neural 208 network mayN encoder subnetworks 214. - The embedding
layer 212 is configured, for each network input in the input sequence, to map the network input to a numeric representation of the network input in an embedding space, e.g., into a vector in the embedding space. The embeddinglayer 212 then provides the numeric representations of the network inputs to the first subnetwork in the sequence ofencoder subnetworks 214. The embeddinglayer 212 may be configured to map each network input to an embedded representation of the network input and then combine, e.g., sum or average, the embedded representation of the network input with a positional embedding of the input position of the network input in the input order to generate a combined embedded representation of the network input. In some cases, the positional embeddings are learned. As used herein, “learned” means that an operation or a value has been adjusted during the training of the sequence transductionneural network 206. In other cases, the positional embeddings may be fixed and are different for each position. - The combined embedded representation is then used as the numeric representation of the network input. Each of the
encoder subnetworks 214 is configured to receive a respective encoder subnetwork input for each of the plurality of input positions and to generate a respective subnetwork output for each of the plurality of input positions. The encoder subnetwork outputs generated by the last encoder subnetwork in the sequence are then used as the encoded representations of the network inputs. For the first encoder subnetwork in the sequence, the encoder subnetwork input is the numeric representations generated by the embeddinglayer 212, and, for each encoder subnetwork other than the first encoder subnetwork in the sequence, the encoder subnetwork input is the encoder subnetwork output of the preceding encoder subnetwork in the sequence. - Each
encoder subnetwork 214 includes an encoder self-attention sub-layer 216. The encoder self-attention sub-layer 216 is configured to receive the subnetwork input for each of the plurality of input positions and, for each particular input position in the input order, apply an attention mechanism over the encoder subnetwork inputs at the input positions using one or more queries derived from the encoder subnetwork input at the particular input position to generate a respective output for the particular input position. In some cases, the attention mechanism is a multi-head attention mechanism as shown. In some implementations, each of theencoder subnetworks 214 may also include a residual connection layer that combines the outputs of the encoder self-attention sub-layer with the inputs to the encoder self-attention sub-layer to generate an encoder self-attention residual output and a layer normalization layer that applies layer normalization to the encoder self-attention residual output. These two layers are collectively referred to as an “Add fi Norm” operation inFIG. 2 . - Some or all of the encoder subnetworks can also include a position-wise feed-
forward layer 218 that is configured to operate on each position in the input sequence separately. In particular, for each input position, the feed-forward layer 218 is configured receive an input at the input position and apply a sequence of transformations to the input at the input position to generate an output for the input position. The inputs received by the position-wise feed-forward layer 218 can be the outputs of the layer normalization layer when the residual and layer normalization layers are included or the outputs of the encoder self-attention sub-layer 216 when the residual and layer normalization layers are not included. The transformations applied by thelayer 218 will generally be the same for each input position (but different feed-forward layers in different subnetworks may apply different transformations). - In cases where an
encoder subnetwork 214 includes a position-wise feed-forward layer 218 as shown, the encoder subnetwork can also include a residual connection layer that combines the outputs of the position-wise feed-forward layer with the inputs to the position-wise feed-forward layer to generate an encoder position-wise residual output and a layer normalization layer that applies layer normalization to the encoder position-wise residual output. As noted above, these two layers are also collectively referred to as an “Add & Norm” operation. The outputs of this layer normalization layer can then be used as the outputs of theencoder subnetwork 214. - Once the encoder
neural network 208 has generated the encoded representations, the decoderneural network 210 is configured to generate the output sequence in an auto-regressive manner. That is, the decoderneural network 210 generates the output sequence, by at each of a plurality of generation time steps, generating a network output for a corresponding output position conditioned on (i) the encoded representations and (ii) network outputs at output positions preceding the output position in the output order. In particular, for a given output position, the decoder neural network generates an output that defines a probability distribution over possible network outputs at the given output position. The decoder neural network can then select a network output for the output position by sampling from the probability distribution or by selecting the network output with the highest probability. - Because the decoder
neural network 210 is auto-regressive, at each generation time step, thedecoder network 210 operates on the network outputs that have already been generated before the generation time step, i.e., the network outputs at output positions preceding the corresponding output position in the output order. In some implementations, to ensure this is the case during both inference and training, at each generation time step the decoderneural network 210 shifts the already generated network outputs right by one output order position (i.e., introduces a one position offset into the already generated network output sequence) and (as will be described in more detail below) masks certain operations so that positions can only attend to positions up to and including that position in the output sequence (and not subsequent positions). While the remainder of the description below describes that, when generating a given output at a given output position, various components of thedecoder 210 operate on data at output positions preceding the given output positions (and not on data at any other output positions), it will be understood that this type of conditioning can be effectively implemented using shifting. - The decoder
neural network 210 includes an embedding layer (output embedding) 220, a sequence ofdecoder subnetworks 222, alinear layer 224, and asoftmax layer 226. In particular, the decoder neural network can includeN decoder subnetworks 222. However, while the example ofFIG. 2 shows theencoder 208 and thedecoder 210 including the same number of subnetworks, in some cases theencoder 208 and thedecoder 210 include different numbers of subnetworks. The embeddinglayer 220 is configured to, at each generation time step, for each network output at an output position that precedes the current output position in the output order, map the network output to a numeric representation of the network output in the embedding space. The embeddinglayer 220 then provides the numeric representations of the network outputs to thefirst subnetwork 222 in the sequence of decoder subnetworks. - In some implementations, the embedding
layer 220 is configured to map each network output to an embedded representation of the network output and combine the embedded representation of the network output with a positional embedding of the output position of the network output in the output order to generate a combined embedded representation of the network output. The combined embedded representation is then used as the numeric representation of the network output. The embeddinglayer 220 generates the combined embedded representation in the same manner as described above with reference to the embeddinglayer 212. - Each
decoder subnetwork 222 is configured to, at each generation time step, receive a respective decoder subnetwork input for each of the plurality of output positions preceding the corresponding output position and to generate a respective decoder subnetwork output for each of the plurality of output positions preceding the corresponding output position (or equivalently, when the output sequence has been shifted right, each network output at a position up to and including the current output position). In particular, eachdecoder subnetwork 222 includes two different attention sub-layers: a decoder self-attention sub-layer 228 and an encoder-decoder attention sub-layer 230. Each decoder self-attention sub-layer 228 is configured to, at each generation time step, receive an input for each output position preceding the corresponding output position and, for each of the particular output positions, apply an attention mechanism over the inputs at the output positions preceding the corresponding position using one or more queries derived from the input at the particular output position to generate a updated representation for the particular output position. That is, the decoder self-attention sub-layer 228 applies an attention mechanism that is masked so that it does not attend over or otherwise process any data that is not at a position preceding the current output position in the output sequence. - Each encoder-
decoder attention sub-layer 230, on the other hand, is configured to, at each generation time step, receive an input for each output position preceding the corresponding output position and, for each of the output positions, apply an attention mechanism over the encoded representations at the input positions using one or more queries derived from the input for the output position to generate an updated representation for the output position. Thus, the encoder-decoder attention sub-layer 230 applies attention over encoded representations while the decoder self-attention sub-layer 228 applies attention over inputs at output positions. - In the example of
FIG. 2 , the decoder self-attention sub-layer 228 is shown as being before the encoder-decoder attention sub-layer in the processing order within thedecoder subnetwork 222. In other examples, however, the decoder self-attention sub-layer 228 may be after the encoder-decoder attention sub-layer 230 in the processing order within thedecoder subnetwork 222 or different subnetworks may have different processing orders. In some implementations, eachdecoder subnetwork 222 includes, after the decoder self-attention sub-layer 228, after the encoder-decoder attention sub-layer 230, or after each of the two sub-layers, a residual connection layer that combines the outputs of the attention sub-layer with the inputs to the attention sub-layer to generate a residual output and a layer normalization layer that applies layer normalization to the residual output. These two layers being inserted after each of the two sub-layers, both referred to as an “Add & Norm” operation. - Some or all of the
decoder subnetwork 222 also include a position-wise feed-forward layer 232 that is configured to operate in a similar manner as the position-wise feed-forward layer 218 from theencoder 208. In particular, thelayer 232 is configured to, at each generation time step: for each output position preceding the corresponding output position: receive an input at the output position, and apply a sequence of transformations to the input at the output position to generate an output for the output position. The inputs received by the position-wise feed-forward layer 232 can be the outputs of the layer normalization layer (following the last attention sub-layer in the subnetwork 222) when the residual and layer normalization layers are included or the outputs of the last attention sub-layer in thesubnetwork 222 when the residual and layer normalization layers are not included. In cases where adecoder subnetwork 222 includes a position-wise feed-forward layer 232, the decoder subnetwork can also include a residual connection layer that combines the outputs of the position-wise feed-forward layer with the inputs to the position-wise feed-forward layer to generate a decoder position-wise residual output and a layer normalization layer that applies layer normalization to the decoder position-wise residual output. These two layers are also collectively referred to as an “Add & Norm” operation. The outputs of this layer normalization layer can then be used as the outputs of thedecoder subnetwork 222. - At each generation time step, the
linear layer 224 applies a learned linear transformation to the output of thelast decoder subnetwork 222 in order to project the output of thelast decoder subnetwork 222 into the appropriate space for processing by thesoftmax layer 226. Thesoftmax layer 226 then applies a softmax function over the outputs of thelinear layer 224 to generate the probability distribution (output probabilities) 234 over the possible network outputs at the generation time step. Thedecoder 210 can then select a network output from the possible network outputs using the probability distribution. - Overall SCONES Architecture
- For textual translations using a set of source text exemplars, other neural machine translation (NMT) models may learn the probability P(y|x) of the target sentence y given the source sentence x. This framework implies that there is a single best translation for a given source sentence: if there were multiple valid translations y1 and y2 they would need to share probability mass (e.g. P(y1|x)=0.5 and P(y2|x)=0.5), but such a distribution could also represent model uncertainty, i.e., the case when either y1 or y2 are correct translations. Therefore, learning a single distribution over all target language sentences does not allow the model to naturally express intrinsic uncertainty, the nature of the translation task to allow multiple semantically equivalent translations for a given source sentence. Single distributions over all sequences represent uncertainty by assigning probabilities, but they cannot distinguish between different kinds of uncertainty (e.g., model uncertainty versus intrinsic uncertainty).
- In contrast, aspects of the technology frame machine translation as a multi-label classification task. With this approach, rather than learning a single distribution P(y|x) over all target sentences y for a source sentence x, the system learns binary classifiers for each sentence pair (x, y) that indicate whether or not y is a valid translation of x. In this framework, intrinsic uncertainty can be represented by setting the probabilities of two (or more) correct translations y1 and y2 to a maximum. e.g. a “1” on a scale of 0-1, simultaneously.
- The probabilities for each translation are computed using separate binary classifiers, and thus there is no requirement that the probabilities sum to 1 over all translations. In practice, the probability of a complete translation is decomposed into a product of the token-level probabilities. In one aspect, a softmax output layer in Transformer model (e.g., 226 in
FIG. 2 ) is replaced with sigmoid activations that assign a probability between 0 and 1 to each token in the vocabulary at each time step. Alternatively, instead of sigmoid activations, another bounded activation function may be employed such as tanh. The SCONES loss function allows the system to train models on single reference training data. Unlike noise-contrastive estimation (NCE), which had a primary goal to efficiently train models over large vocabularies, using the SCONES approach enables modeling of non-exclusive outputs. - Testing has demonstrated multiple benefits of training NMT models using SCONES when compared to standard cross-entropy with regular softmax. This can include consistent BLEU score gains between 1%-9% across six different translation directions. SCONES with greedy search typically outperforms softmax with beam search, resulting in inference speed-ups of up to 3.9× compared to softmax without any degradation in the BLEU score.
- hi addition, SCONES mitigates pathologies of traditional NMT models. Softmax-based models have been shown to assign the highest probability to either empty or inadequate translations (modes). This behavior manifests itself as the “beam search curse” where increasing the beam size may lead to worse translation quality, as described in “Six challenges for neural machine translation” by Koehn and Knowles, published in 2017 in the Proceedings of the First Workshop on Neural Machine Translation, pages 28-39, by the Association for Computational Linguistics (the entire disclosure of which is incorporated herein by reference). Testing shows that SCONES can be used to train models that a) assign the highest probability to adequate translations and b) do not suffer from the beam search curse.
- SCONES may also be used to train models on synthetic translation pairs that were generated by sampling from the IBM Model 3 (“IBM-3”) (see “The mathematics of statistical machine translation: Parameter estimation” by Brown et al., published in 1993 in Computational Linguistics, the entire disclosure of which is incorporated herein by reference. By varying the sampling temperature (the entropy of the distribution), one can control the level of ambiguity in the language pair. Testing shows that SCONES is effective in improving the adequacy of the highest probability translation for highly ambiguous translation pairs, confirming that SCONES can handle intrinsic uncertainty highly effectively.
- Training NMT Models with SCONES
- With regard to model training, the (subword) vocabulary is denoted as V={w1, . . . , w|v|}, the special end-of-sentence symbol as w1=</s>, the source sentence as x=
- This approach does not model t(·,·) directly. To guide decoding, variables zx,y are learned, which generalize t(·,·) to translate prefixes:
-
- i.e., zx,y is a binary label for the pair (x,y) associated with source sentence x and the translation prefix y: zx,y=1 iff, y is a prefix of a valid translation of x. Its probability is decomposed as a product of conditionals to facilitate left-to-right beam decoding as follows (as a base case, P(zx,∈=1|x)=1 for the empty translation prefix):
-
- The conditional probabilities are assigned by applying the sigmoid activation function σ(·) to the logits (in which the logits are vectors of raw predictions that the model generates prior to normalization):
-
P(≈x,y <·=1|x,y <i)=σ(ƒ(x,y <i)) - An architectural difference to a standard NMT model is the output activation. In particular, instead of the softmax function that yields a single distribution over the full vocabulary, multiple sigmoid activations are used in each logit component to define separate Bernoulli distributions for each item in the vocabulary. This is illustrated with reference to example 300 of
FIG. 3 , which shows a multi-way NMT Transformer architecture for non-exclusive target sequences. In this figure, the source sentence x is applied totransformer encoder 302 and the output from thetransformer encoder 304 is applied totransformer decoder 304 along with translation prefix y<i. The output of thetransformer decoder 304, ƒ(x, y<i), is applied tologits 306. The transformer decoder output is bounded with a logistic activation function, σ, where σ(f( )) is the bounded activation function. For each token w (e.g., w1, w2, w3, w4, etc.), a correspondingconditional probability P 308 is obtained. - However, using such a multi-label classification view requires a different training loss function because, unlike the logits from a softmax, the logits in equation above for the conditional probabilities do not provide a normalized distribution over the vocabulary. An additional challenge is that existing MT training datasets typically do not provide more than one reference translation. The SCONES loss function aims to balance two token-level objectives using a scaling factor α∈
-
- Here,
x,y ≤i =1|x, y<1) of the gold label yi since it is a valid extension of the translation prefix y<i. By way of example, the positive loss component applies a log function to the bounded conditional probability for each reference token.Block 310 inFIG. 3 illustrates theprobabilities 308 of the bounded activation function being applied to the SCONES loss function. Aspects of the loss function include: -
-
-
- By way of example, the negative loss component applies a log function to the bounded conditional probability for each non-reference token.
- During inference, to generate a translation result, the system searches for the translation y* that ends with </s> and has the highest probability of being a translation of x:
-
- This decision rule can be approximated with a vanilla beam search, which is a standard beam search algorithm for sequence to sequence models. Such a beam search takes the best N tokens, and selects the best N partial sequences (at each time step), considering the probabilities of the combination for all preceding words in addition to the word in the current location. An example is described in “Sequence to Sequence Learning with Neural Networks” by Sutskever et al., published Dec. 14, 2014, the entire disclosure of which is incorporated herein by reference.
- For evaluation purposes, the same inference code is used for both softmax baselines and the SCONES trained models. Here, the only difference would be that the logits from SCONES models are transformed by a sigmoid instead of a softmax activation—in other words no summation over the full vocabulary (set of all tokens) is necessary.
- Relation to Noise-Contrastive Estimation
- The SCONES loss function is related to noise-contrastive estimation (NCE) in the sense that both methods reformulate next word prediction as a multi-label classification problem, and both losses have a “positive” component for the gold label, and a “negative” component for other labels. However, unlike NCE, the negative loss component (
- Experimental Setup
- hi order to understand certain benefits and advantages of the SCONES approach, it is helpful to compare NMT models trained with SCONES with well-trained standard softmax-based models. To do this, the setup can be kept simple, reproducible, and computationally economical. In one situation, Transformer models were trained according to the example of
FIG. 4A , in which Table 1 lists the various Transformer hyper-parameters. Transformer models were trained in six translation directions—German-English (de-en). Finnish-English (en-ft). Lithuanian-English220 (It-en), and the reverse directions—on the WMT19 training sets as provided by TeusorFlow Datasets. These languages pairs were selected to experiment with different training set sizes, as identified in Table 2 ofFIG. 4B . - The training sets were filtered using language ID and simple length-based heuristics, and split into subwords using joint 32K SentencePiece models, as described in “SentencePiece: A simple and language independent subword tokenizer and detokenizer for neural text processing” by Kudo and Richardson, Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing: System Demonstrations, pages 66-71. Brussels, Belgium, the entire disclosure of which is incorporated herein by reference.
- In this experimental setup, all of the models were trained until convergence on the development set (between 100K and 700K training steps) using the LAMB optimizer in JAX. Details about the LAMB optimizer may be found in “Large batch optimization for deep learning: Training BERT in 76 minutes”, by You et al., 2020, in the International Conference on Learning Representations, the entire disclosure of which is incorporated herein by reference. Details about JAX may be found in “JAX: Composable transformations of Python+NumPy programs”, by Bradbury et al. in 2018, the entire disclosure of which is incorporated herein by reference.
- The softmax baselines were trained by minimizing cross-entropy without label smoothing. The multi-way NMT models were trained by minimizing the SCONES loss function described above, also without label smoothing. The models were evaluated on the WMT19 test sets with SacreBLEU, using the WMT18 test sets as development sets to tune a. As an additional optimization, a greedy search implementation is configured to operate directly on the logits without applying the output activations. Details regarding SacreBLEU can be found in “A call for clarity in reporting BLEU scores” by Matt Post. 2018, in Proceedings of the Third Conference on Machine Translation: Research Papers, pages 186-191, the entire disclosure of which is incorporated herein by reference.
- Experimental Results
- The tables 500 and 520 in
FIGS. 5A-B compares a SCONES-based NMT systems with the softmax baselines when a is tuned based on the BLEU score on the development set shown in the table ofFIG. 6 . As shown. SCONES yields consistent improvements across the board. For four of six language pairs (all except en-de and fi-en), SCONES with greedy search is even able to outperform the softmax models with beam search. The language pairs with fewer resources (fi↔en, lt↔en) benefit from SCONES training much more than the high-resource language pairs (de↔en). - The softmax-based models reach their (near) optimum BLEU score with a beam size of around 4. Most of the SCONES models can achieve similar or better BLEU scores with greedy search. Replacing beam-4 search with greedy search corresponds to a 3.9× speed-up (2.76↔10.64 sentences per second) on an entry-level NVIDIA Quadro P1000 GPU with a batch size of 4.8
-
FIGS. 7A-F show the BLEU scores for all six translation directions as a function of decoding speed. Here, the SCONES results are all above the softmax results. Most of the speed-ups are due to choosing a smaller beam size and not due to SCONES avoiding the normalization over the full vocabulary. Further speed-ups from SCONES are expected when comparing models with larger vocabularies. - Mitigating the Beans Search Curse
- As noted above, one of the most irksome pathologies of traditional softmax-based NMT models is the “beam search curse”, in which larger beam sizes improve the log-probability of the translations, but the translation quality gets worse. This happens because with large beam sizes, the model prefers translations that are too short. This phenomenon has been linked to the local normalization in sequence models and poor model calibration. It has been shown that modes are often empty and suggested that the inherent bias of the model towards short translations is often obscured by beam search errors. This length deficiency may be due to the intrinsic uncertainty of the MT task.
- Given that models trained with SCONES explicitly take into account inherent uncertainty, an experiment was conducted to determine whether these models are more robust to the beam search curse compared to softmax trained models.
FIG. 8 plots the BLEU score as a function of the beam size. The sharp decline of thesoftmax curve 802 for large beam sizes reflects the beam search curse for the softmax baseline. The results indicate that SCONES can be less affected at larger beam sizes, particularly for small α-values: the BLEU score for SCONES with α=0:2 (line 804) is stable for beam sizes greater than 100. -
FIG. 9A , which displays the length ratio (the hypothesis length divided by the reference length) versus beam size for a German-English evaluation, suggests that the differences in BLEU trajectories arise due to translation lengths. Translations obtained using softmax (902) become abruptly shorter at higher beam sizes whereas for SCONES with α=0:2 (904), there is no such steep decrease in length. To study the impact of a in the absence of beam search errors the exact depth-first search algorithm of Stahlberg and Byrne (“On NMT search errors and model errors: Cat got your tongue?”, 2019, in Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing and the 9th International Joint Conference on Natural Language Processing (EMNLP-IJCNLP), pages 3356 636 3362, the entire disclosure of which is incorporated herein by reference) was run to find the translation with global 309 highest probability. The adequacy of the translations found by exact search depends heavily on a, which is shown in the plot ofFIG. 9B of German-English BLEU scores (softmax: 912: SCONES: 914) and length ratios (softmax 916: SCONES 918). - With exact search, small a-values yield adequate translations, but α≈1:0 performs similar to the softmax baseline: the BLEU score drops because hypotheses are too short. Tables 1000 and 1020 in
FIGS. 10A-B , respectively, show that SCONES with α=0:2 consistently outperforms the softmax baselines by a large margin with exact search.FIG. 10C , which illustrates mean and standard deviation (error bars) of log-probabilities of the global highest probability translations (found using exact search) and the empty translations for German-English, sheds some light on why SCONES with small a does not prefer empty translations. Here, 1002 shows a softmax empty translation, 1004 shows a softmax exact search translation. 1006 shows a SCONES empty translation, and 1008 shows a SCONES exact search translation. - A small a leads to a larger gap between the log-probabilities of the exact search translation and the empty translation that arises from higher log-probabilities for the exact-search translation along with smaller variances. Intuitively, a small a reduces the importance of the negative loss component (
-
FIG. 11 displays the percentage of beam search errors (for a German-English example), in particular the fraction of sentences for which beam search did not find the global best translation, as a function of beam size. Here. 1102 is the softmax plot and 1104 is the SCONES plot for α=0.2. These test results confirms the findings of Stahlberg and Byrne for softmax models, in particular that the percentage of search errors remains at a relatively high level of around 20% even for very large beam sizes. Increasing the beam size is most effective in reducing the number of search errors for SCONES with a small value of a. However, a small a does not always yield the best overall BLEU score (seeFIG. 8 ). Taken together, these observations provide an insight into model errors in NMT: If one were to describe the “model error” as the mismatch between the global most likely translation and an adequate translation, then a small a would simultaneously lead to both fewer search errors (seeFIG. 11 ) and fewer model errors (see tables 1000 and 1020 ofFIGS. 10A-B ). Counterintuitively, however. BLEU scores peak at slightly higher a-values (see table 4 inFIG. 6 ). - Experiments Wills Synthetic Language Pairs
- A key motivation for SCONES is to equip the model to naturally represent intrinsic uncertainty, i.e., the existence of multiple correct target sentences for the same source sentence. To examine the characteristics of SCONES as a function of uncertainty, synthetic language pairs were generated that differ by the level of ambiguity. For this purpose, an IBM-3 model was trained on German-English training data after subword segmentation using MGIZA. MGIZA is described in “Parallel implementations of word alignment tool” by Gao and Vogel in Software Engineering, Testing, and Quality Assurance for Natural Language Processing”, pages 49-57, 2008, the entire disclosure of which is incorporated by reference herein. IBM-3 is a generative symbolic model that describes the translation process from one language into another with a generative story, and has been used to find word alignments for statistical (phrase-based) machine translation.
- The generative story includes different steps such as distortion (word reordering), fertility (1: n word mappings), and lexical translation (word-to-word translation) that describe the translation process. The parameters of IBM-3 define probability distributions for each step. In the experiments, IBM-3 was not used for finding word alignments. Instead, for the original German sentences synthetic English-like translations were sampled from the model with different sampling temperatures to control the ambiguity levels of the translation task. A low sampling temperature generates sentence pairs that still capture some of the characteristics of MT such as word reorderings, but the mapping is mostly deterministic (i.e., the same source token is almost always translated to the same target token). A high temperature corresponds to more randomness, which is to say more intrinsic uncertainty. NMT models may be trained using either sofimax or SCONES on the synthetic corpora.
- The tables in
FIGS. 12A-B contains more details about sampling from IBM-3. The parameters of the IBM-3 model are composed of a set of fertility probabilities n(·|·), p0, p1, a set of translation probabilities t(·|·), and a set of distortion probabilities d(·|·). According to theIBM Model 3, the following generative process produces the target language sentence y from a source language sentence x: -
- 1. For each source word xi indexed by i=1, 2, . . . , |x|, choose the fertility ϕi with probability n(ϕi|xi).
- 2. Choose the number ϕ0 of “spurious” target words to be generated from x0=NULL, using
- probability p1 and the sum of fertilities from
step 1. - 3. Let m=Σi=0 |x|ϕi.
- 4. For each i=0, 1, 2, . . . , |x| and each k=1, 2, . . . , ϕi, choose a target word τik with probability t(τik|xi)
- 5. For each i=1, 2, . . . , |x| and each k=1, 2, . . . , ϕi, choose a target position πik with probability d(πik|,|x|, m).
- 6. For each k=1, 2, . . . , ϕ0, choose a position π0k from the ϕ0−
k+ 1 remaining vacant positions in 1, 2, . . . , m, for a total probability of
-
-
- 7. Output the target sentence with words τik in positions πik(0≤i≤|x|, 1≤k≤ϕi).
- The IBM-3 model parameters may be first estimated using the MGIZA word alignment tool. Then. English-like target sentences are sampled for the German source sentences following the generative story above. To control the level of uncertainty in the synthetic translation task, the entropies of the n(·|·), t(·|·), and d(·|·), distributions by choosing different sampling temperatures γ∈
- from a categorical distribution P(·) over categories C, temperature sampling uses the following distribution for each c∈C:
-
- A low temperature amplifies large differences in probabilities, and thus leads to a lower entropy and less ambiguity.
-
FIG. 13A presents a plot of BLEU scores with beam search (beam size of 4) for German-to-synthetic-English translation with different IBM-3 sampling temperatures. This plot shows that softmax and SCONES perform similarly using beam search. High IBM-3 sampling temperature translation tasks are less predictable, and thus lead to lower BLEU scores. The difference between both approaches becomes clear with exact search as shown in the plot ofFIG. 13B . While the translations with the global highest probability for high IBM-3 sampling temperatures are heavily degraded for softmax (1300) and SCONES with α=1 (1302), the drop is much less dramatic for SCONES with either α=0.5 (1304) or α=0.2 (1306). Setting α to a low value enables the model to assign its highest probability to adequate translations, even when the translation task is highly uncertain. This scaling factor is adjustable, for instance to maximize translation performance - SCONES has one more parameter (α) than softmax that trades off positive and negative examples. This enables SCONES to achieve enhanced performance as shown in the above test results.
FIG. 14 provides an example implementation of SCONES written in JAX. - Example Computing Architecture
- The models discussed herein may be trained on one or more tensor processing units (TPUs), CPUs or other computing architectures in order to model ambiguity using SCONES in accordance with the features disclosed herein. One example computing architecture is shown in
FIGS. 15A and 15B . In particular,FIGS. 15A and 15B are pictorial and functional diagrams, respectively, of anexample system 1500 that includes a plurality of computing devices and databases connected via a network. For instance, computing device(s) 1502 may be implemented as a cloud-based server system.Databases network 1510. Client devices may include one or more of adesktop computer 1512 and a laptop ortablet PC 1514, for instance to provide the original text or other content, and/or to view the output (e.g., selected translations or use of the assessment or other information in a translation service, app or other program). - As shown in
FIG. 15B , each of thecomputing devices 1502 and 1512-1514 may include one or more processors, memory, data and instructions. The memory stores information accessible by the one or more processors, including instructions and data (e.g., models) that may be executed or otherwise used by the processor(s). The memory may be of any type capable of storing information accessible by the processor(s), including a computing device-readable medium. The memory is a non-transitory medium such as a hard-drive, memory card, optical disk, solid-state, etc. Systems may include different combinations of the foregoing, whereby different portions of the instructions and data are stored on different types of media. The instructions may be any set of instructions to be executed directly (such as machine code) or indirectly (such as scripts) by the processor(s). For example, the instructions may be stored as computing device code on the computing device-readable medium. In that regard, the terms “instructions”, “modules” and “programs” may be used interchangeably herein. The instructions may be stored in object code format for direct processing by the processor, or in any other computing device language including scripts or collections of independent source code modules that are interpreted on demand or compiled in advance. - The processors may be any conventional processors, such as commercially available CPUs, TPUs, graphical processing units (GPUs), etc. Alternatively, each processor may be a dedicated device such as an ASIC or other hardware-based processor. Although
FIG. 15B functionally illustrates the processors, memory, and other elements of a given computing device as being within the same block, such devices may actually include multiple processors, computing devices, or memories that may or may not be stored within the same physical housing. Similarly, the memory may be a hard drive or other storage media located in a housing different from that of the processor(s), for instance in a cloud computing system ofserver 1502. Accordingly, references to a processor or computing device will be understood to include references to a collection of processors or computing devices or memories that may or may not operate in parallel. - The input data, such as one or more sentences or sets of textual content, may be operated on by a SCONES-trained model to generate one or more translations, text quality assessment data, etc. The client devices may utilize such information in various apps or other programs to perform translations, dialog modeling, spelling or grammatic error corrections, quality assessment or other metric analysis, recommendations, classification, search, etc. This could include assigning quality scores to different translations based upon the results of the processing. Therefore, quality scores can be used to rank translations and prioritize good translations in serving, such as for a video streaming service with subtitles.
- The computing devices may include all of the components normally used in connection with a computing device such as the processor and memory described above as well as a user interface subsystem for receiving input from a user and presenting information to the user (e.g., text, imagery and/or other graphical elements). The user interface subsystem may include one or more user inputs (e.g., at least one front (user) facing camera, a mouse, keyboard, touch screen and/or microphone) and one or more display devices (e.g., a monitor having a screen or any other electrical device that is operable to display information (e.g., text, imagery and/or other graphical elements). Other output devices, such as speaker(s) may also provide information to users.
- The user-related computing devices (e.g., 1512-1514) may communicate with a back-end computing system (e.g., server 1502) via one or more networks, such as
network 1510. The network 910, and intervening nodes, may include various configurations and protocols including short range communication protocols such as Bluetooth™. Bluetooth LE™, the Internet, World Wide Web, intranets, virtual private networks, wide area networks, local networks, private networks using communication protocols proprietary to one or more companies, Ethernet. WiFi and HTTP, and various combinations of the foregoing. Such communication may be facilitated by any device capable of transmitting data to and from other computing devices, such as modems and wireless interfaces. - In one example,
computing device 1502 may include one or more server computing devices having a plurality of computing devices, e.g., a load balanced server farm or cloud computing system, that exchange information with different nodes of a network for the purpose of receiving, processing and transmitting the data to and from other computing devices. For instance,computing device 1502 may include one or more server computing devices that are capable of communicating with any of the computing devices 1512-1514 via thenetwork 1510. - Model information or other data derived from the SCONES approach may be shared by the server with one or more of the client computing devices. Alternatively or additionally, the client device(s) may maintain their own databases, models, etc.
-
FIG. 16 illustrates amethod 1600 for addressing ambiguity in neural machine translation in accordance with aspects of the technology. At block 1602 a set of text exemplars is stored in memory. Atblock 1604, an encoder module comprising an encoder neural network receives a given text exemplar (x=x1, . . . , x|x|>). Atblock 1606 the encoder module generates an encoded representation of the given text exemplar. Atblock 1608, a decoder module receives the encoded representation and a set of translation prefixes (y<i<y1, . . . , yi-1>). Atblock 1610, the decoder module outputs an unbounded function ƒ(x, y<i) corresponding to a set of tokens associated with each pair of the given text exemplar x and translation prefix from the set of translation prefixes y<i, wherein each token is assigned a probability between 0 and 1 in a vocabulary of the given text exemplar at each time step. Atblock 1612, a logits module generates, based on the unbounded function, a corresponding bounded conditional probability for each token, wherein the conditional probabilities are not normalized over the vocabulary at each time step. And atblock 1614, a loss function module having a positive loss component and a scaled negative loss component identifies whether each target text of a set of target texts is a valid translation of the given text exemplar. - Machine translation is a task with high intrinsic uncertainty: a source sentence can have multiple valid translations. It has been demonstrated that NMT models and specifically Transformers, can learn to model mutually non-exclusive target sentences from single-label training data using the SCONES loss function. Rather than learn a single distribution over all target sentences. SCONES learns multiple binary classifiers that indicate whether or not a target sentence is a valid translation of the source sentence. SCONES yields improved translation quality over conventional softmax-based models for six different translation directions, or (alternatively) speed-ups of up to 3.9× without any degradation in translation performance.
- It has been demonstrated that SCONES can be tuned to mitigate the beam search curse and the problem of inadequate and empty modes in standard NMT. Experiments on synthetic language translation suggest that, unlike softmax-trained models. SCONES models are able to assign their highest probability to adequate translations even when the underlying task is highly ambiguous.
- The SCONES loss function is easy to implement. Adapting standard softmax-based sequence-to-sequence architectures such as Transformers requires only replacing the cross-entropy loss function with SCONES and the softmax with sigmoid activations. The remaining parts of the training and inference pipelines can be kept unchanged. SCONES can be useful in handling uncertainty for a variety of ambiguous NLP problems beyond translation, such as generation and dialog.
- Although the technology herein has been described with reference to particular embodiments, it is to be understood that these embodiments are merely illustrative of the principles and applications of the present technology. It is therefore to be understood that numerous modifications may be made to the illustrative embodiments and that other arrangements may be devised without departing from the spirit and scope of the present technology as defined by the appended claims.
Claims (21)
1. A system configured for a machine translation model, the system comprising:
memory configured to store a set of text exemplars in a source language and a set of rewritten texts in one or more languages different from the source language; and
one or more processing elements operatively coupled to the memory, the one or more processing elements implementing the machine translation model as a neural network having:
an encoder module comprising an encoder neural network configured to receive a given text exemplar (x=<x1, . . . , x|x|>) and to generate an encoded representation of the given text exemplar:
a decoder module comprising a decoder neural network configured to receive the encoded representation and a set of translation prefixes (y<i=y1, . . . , yi-1>) and to output an unbounded function ƒ(x, y<i) corresponding to a set of tokens associated with each pair of the given text exemplar x and translation prefix from the set of translation prefixes wherein each token is assigned a probability between 0 and 1 in a vocabulary of the given text exemplar at each time step:
a logits module configured to act on the unbounded function to generate a corresponding bounded conditional probability for each token, wherein the conditional probabilities are not normalized over the vocabulary at each time step; and
a loss function module having a positive loss component and a scaled negative loss component, in which the loss function module is configured to identify whether each target text of a set of target texts is a valid translation of the given text exemplar.
2. The system of claim 1 , wherein the set of text exemplars comprises a set of input sentences, and the system is configured to learn binary classifiers for each sentence pair (x,y) that indicate whether or not y is a valid translation of x.
3. The system of claim 2 , wherein intrinsic uncertainty is represented by setting the conditional probabilities of at least two correct translations y1 and y2 to a maximum probability simultaneously.
4. The system of claim 2 , wherein the logits module is configured to generate probabilities for each translation using separate binary classifiers.
5. The system of claim 1 , wherein a probability of a complete translation of the given text exemplar is decomposed into a product of token-level probabilities.
6. The system of claim 1 , wherein the logits module is configured to apply sigmoid activations to the unbounded function at each time step.
7. The system of claim 1 , wherein the positive loss component applies a log function to the bounded conditional probability for each reference token, and the scaled negative loss component applies a log function to the bounded conditional probability for each non-reference token.
8. The system of claim 1 , wherein during inference the system is configured to search for a translation that has a highest probability of being a translation of text segment to be translated.
9. The system of claim 1 , wherein the system is configured to express intrinsic uncertainty associated with machine translation model.
10. The system of claim 1 , wherein the loss function module is configured to adjust scaling of the negative loss component to maximize translation performance.
11. The system of claim 1 , wherein the encoder module and the decoder module comprise a self-attention neural network encoder-decoder architecture.
12. The system of claim 1 , wherein the encoder module and the decoder module comprise a sequence to sequence model architecture.
13. A machine translation method employing a neural network, the method comprising:
storing, in memory, a set of text exemplars:
receiving, by an encoder module comprising an encoder neural network, a given text exemplar (x=<x1, . . . , xx|>):
generating, by the encoder module, an encoded representation of the given text exemplar:
receiving, by a decoder module, the encoded representation and a set of translation prefixes (y<i=<y1, . . . , yi-1>) outputting, by the decoder module, an unbounded function ƒ(x, y<i) corresponding to a set of tokens associated with each pair of the given text exemplar x and translation prefix from the set of translation prefixes y<i, wherein each token is assigned a probability between 0 and 1 in a vocabulary of the given text exemplar at each tune step:
generating, by a logits module based on the unbounded function, a corresponding bounded conditional probability for each token, wherein the conditional probabilities are not normalized over the vocabulary at each time step; and
identifying, by a loss function module having a positive loss component and a scaled negative loss component, whether each target text of a set of target texts is a valid translation of the given text exemplar.
14. The method of claim 13 , wherein the set of text exemplars comprises a set of input sentences, and the method includes learning binary classifiers for each sentence pair (x,y) that indicate whether or not y is a valid translation of x.
15. The method of claim 14 , wherein intrinsic uncertainty is represented by setting the conditional probabilities of at least two correct translations y1 and y2 to a maximum probability simultaneously.
16. The method of claim 14 , wherein generating the corresponding bounded conditional probability for each token comprises generating probabilities for each translation using separate binary classifiers.
17. The method of claim 13 , wherein a probability of a complete translation of the given text exemplar is decomposed into a product of token-level probabilities.
18. The method of claim 13 , wherein generating the corresponding bounded conditional probability for each token comprises applying sigmoid activations to the unbounded function at each time step.
19. The method of claim 13 , wherein the positive loss component applies a log function to the bounded conditional probability for each token, and the scaled negative loss component applies a log function to the bounded conditional probability for each token.
20. The method of claim 13 , further comprising, during inference searching for a translation that has a highest probability of being a translation of text segment to be translated.
21. The method of claim 13 , further comprising adjusting scaling of the negative loss component to maximize translation performance.
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
PCT/US2022/026683 WO2023211446A1 (en) | 2022-04-28 | 2022-04-28 | Modeling ambiguity in neural machine translation |
Related Parent Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
PCT/US2022/026683 Continuation WO2023211446A1 (en) | 2022-04-28 | 2022-04-28 | Modeling ambiguity in neural machine translation |
Publications (1)
Publication Number | Publication Date |
---|---|
US20230351125A1 true US20230351125A1 (en) | 2023-11-02 |
Family
ID=81748992
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US18/089,684 Pending US20230351125A1 (en) | 2022-04-28 | 2022-12-28 | Modeling Ambiguity in Neural Machine Translation |
Country Status (2)
Country | Link |
---|---|
US (1) | US20230351125A1 (en) |
WO (1) | WO2023211446A1 (en) |
Family Cites Families (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
EP4156034A1 (en) | 2017-05-23 | 2023-03-29 | Google LLC | Attention-based sequence transduction neural networks |
US11138392B2 (en) * | 2018-07-26 | 2021-10-05 | Google Llc | Machine translation using neural network models |
US10963652B2 (en) * | 2018-12-11 | 2021-03-30 | Salesforce.Com, Inc. | Structured text translation |
-
2022
- 2022-04-28 WO PCT/US2022/026683 patent/WO2023211446A1/en unknown
- 2022-12-28 US US18/089,684 patent/US20230351125A1/en active Pending
Also Published As
Publication number | Publication date |
---|---|
WO2023211446A1 (en) | 2023-11-02 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
Tang et al. | Aspect level sentiment classification with deep memory network | |
Logeswaran et al. | Sentence ordering and coherence modeling using recurrent neural networks | |
Al Sallab et al. | Deep learning models for sentiment analysis in Arabic | |
Ma et al. | Prompt for extraction? PAIE: Prompting argument interaction for event argument extraction | |
US11544474B2 (en) | Generation of text from structured data | |
US20210232773A1 (en) | Unified Vision and Dialogue Transformer with BERT | |
CN111506714A (en) | Knowledge graph embedding based question answering | |
BakIr | Predicting structured data | |
Kenyon-Dean et al. | Resolving event coreference with supervised representation learning and clustering-oriented regularization | |
CN111401084B (en) | Method and device for machine translation and computer readable storage medium | |
US20230084333A1 (en) | Adversarial generation method for training a neural model | |
Le | Recognizing handwritten mathematical expressions via paired dual loss attention network and printed mathematical expressions | |
CN110427619B (en) | Chinese text automatic proofreading method based on multi-channel fusion and reordering | |
US11875120B2 (en) | Augmenting textual data for sentence classification using weakly-supervised multi-reward reinforcement learning | |
RU2712101C2 (en) | Prediction of probability of occurrence of line using sequence of vectors | |
Logeswaran et al. | Sentence ordering using recurrent neural networks | |
CN110633359A (en) | Sentence equivalence judgment method and device | |
Alsafari et al. | Semi-supervised self-training of hate and offensive speech from social media | |
Peng et al. | Image to LaTeX with graph neural network for mathematical formula recognition | |
US20220139386A1 (en) | System and method for chinese punctuation restoration using sub-character information | |
CN116955644A (en) | Knowledge fusion method, system and storage medium based on knowledge graph | |
US20230351125A1 (en) | Modeling Ambiguity in Neural Machine Translation | |
Sur | AACR: feature fusion effects of algebraic amalgamation composed representation on (de) compositional network for caption generation for images | |
Li et al. | Powering comparative classification with sentiment analysis via domain adaptive knowledge transfer | |
Kelleher | Fundamentals of machine learning for neural machine translation |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:STAHLBERG, FELIX;KUMAR, SHANKAR;SIGNING DATES FROM 20220425 TO 20220426;REEL/FRAME:062221/0458 |