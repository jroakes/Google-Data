CN116661732A - Low-delay matrix multiplication component - Google Patents
Low-delay matrix multiplication component Download PDFInfo
- Publication number
- CN116661732A CN116661732A CN202310556021.0A CN202310556021A CN116661732A CN 116661732 A CN116661732 A CN 116661732A CN 202310556021 A CN202310556021 A CN 202310556021A CN 116661732 A CN116661732 A CN 116661732A
- Authority
- CN
- China
- Prior art keywords
- weight
- input
- register
- array
- matrix
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
- 239000011159 matrix material Substances 0.000 title claims abstract description 229
- 238000000034 method Methods 0.000 claims abstract description 43
- 238000013528 artificial neural network Methods 0.000 claims description 59
- 238000004590 computer program Methods 0.000 claims description 18
- 238000004364 calculation method Methods 0.000 claims description 17
- 238000012545 processing Methods 0.000 description 42
- 230000008569 process Effects 0.000 description 21
- 238000011068 loading method Methods 0.000 description 14
- 230000009467 reduction Effects 0.000 description 9
- 238000012549 training Methods 0.000 description 9
- 238000004891 communication Methods 0.000 description 7
- 230000009471 action Effects 0.000 description 6
- 238000002347 injection Methods 0.000 description 6
- 239000007924 injection Substances 0.000 description 6
- 238000012546 transfer Methods 0.000 description 5
- 230000004913 activation Effects 0.000 description 3
- 230000006870 function Effects 0.000 description 3
- 230000003993 interaction Effects 0.000 description 3
- 230000007704 transition Effects 0.000 description 3
- 238000003491 array Methods 0.000 description 2
- 230000008901 benefit Effects 0.000 description 2
- 238000004422 calculation algorithm Methods 0.000 description 2
- 238000006243 chemical reaction Methods 0.000 description 2
- 230000001186 cumulative effect Effects 0.000 description 2
- 238000010586 diagram Methods 0.000 description 2
- 230000003287 optical effect Effects 0.000 description 2
- 230000004044 response Effects 0.000 description 2
- 238000013515 script Methods 0.000 description 2
- 238000000926 separation method Methods 0.000 description 2
- 230000017105 transposition Effects 0.000 description 2
- 230000005540 biological transmission Effects 0.000 description 1
- 230000008859 change Effects 0.000 description 1
- 230000000295 complement effect Effects 0.000 description 1
- 239000004973 liquid crystal related substance Substances 0.000 description 1
- 238000010801 machine learning Methods 0.000 description 1
- 238000013507 mapping Methods 0.000 description 1
- 230000000873 masking effect Effects 0.000 description 1
- 238000002360 preparation method Methods 0.000 description 1
- 230000000644 propagated effect Effects 0.000 description 1
- 239000004065 semiconductor Substances 0.000 description 1
- 230000001953 sensory effect Effects 0.000 description 1
- 239000000758 substrate Substances 0.000 description 1
- 230000001960 triggered effect Effects 0.000 description 1
- 230000000007 visual effect Effects 0.000 description 1
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F7/00—Methods or arrangements for processing data by operating upon the order or content of the data handled
- G06F7/38—Methods or arrangements for performing computations using exclusively denominational number representation, e.g. using binary, ternary, decimal representation
- G06F7/48—Methods or arrangements for performing computations using exclusively denominational number representation, e.g. using binary, ternary, decimal representation using non-contact-making devices, e.g. tube, solid state device; using unspecified devices
- G06F7/52—Multiplying; Dividing
- G06F7/523—Multiplying only
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F15/00—Digital computers in general; Data processing equipment in general
- G06F15/76—Architectures of general purpose stored program computers
- G06F15/80—Architectures of general purpose stored program computers comprising an array of processing units with common control, e.g. single instruction multiple data processors
- G06F15/8046—Systolic arrays
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F17/00—Digital computing or data processing equipment or methods, specially adapted for specific functions
- G06F17/10—Complex mathematical operations
- G06F17/16—Matrix or vector computation, e.g. matrix-matrix or matrix-vector multiplication, matrix factorization
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F5/00—Methods or arrangements for data conversion without changing the order or content of the data handled
- G06F5/01—Methods or arrangements for data conversion without changing the order or content of the data handled for shifting, e.g. justifying, scaling, normalising
- G06F5/015—Methods or arrangements for data conversion without changing the order or content of the data handled for shifting, e.g. justifying, scaling, normalising having at least two separately controlled shifting levels, e.g. using shifting matrices
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F7/00—Methods or arrangements for processing data by operating upon the order or content of the data handled
- G06F7/38—Methods or arrangements for performing computations using exclusively denominational number representation, e.g. using binary, ternary, decimal representation
- G06F7/48—Methods or arrangements for performing computations using exclusively denominational number representation, e.g. using binary, ternary, decimal representation using non-contact-making devices, e.g. tube, solid state device; using unspecified devices
- G06F7/544—Methods or arrangements for performing computations using exclusively denominational number representation, e.g. using binary, ternary, decimal representation using non-contact-making devices, e.g. tube, solid state device; using unspecified devices for evaluating functions by calculation
- G06F7/5443—Sum of products
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/30003—Arrangements for executing specific machine instructions
- G06F9/30007—Arrangements for executing specific machine instructions to perform operations on data operands
- G06F9/30032—Movement instructions, e.g. MOVE, SHIFT, ROTATE, SHUFFLE
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/30003—Arrangements for executing specific machine instructions
- G06F9/30007—Arrangements for executing specific machine instructions to perform operations on data operands
- G06F9/30036—Instructions to perform operations on packed data, e.g. vector, tile or matrix operations
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/30098—Register arrangements
- G06F9/30101—Special purpose registers
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/06—Physical realisation, i.e. hardware implementation of neural networks, neurons or parts of neurons
- G06N3/063—Physical realisation, i.e. hardware implementation of neural networks, neurons or parts of neurons using electronic means
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
Abstract
Low latency matrix multiplication components are disclosed. Methods, systems, and devices are disclosed that are implemented as matrix multiplication components of an array of systolic cells. Each cell of the matrix multiplication comprises: a weight matrix register configured to receive weight inputs from transposed or non-transposed weight shift registers; a transposed weight shift register configured to receive a weight input from a horizontal direction to be stored in the weight matrix register; a non-transposed weight shift register configured to receive weight inputs from a vertical direction to be stored in the weight matrix register; and a multiplication component coupled to the weight matrix register and configured to multiply the weight input of the weight matrix register with a vector data input to obtain a multiplication result.
Description
Description of the division
The application belongs to a divisional application of Chinese application patent application No.201880004576.1 with the application date of 2018, 5 month and 17 days.
Technical Field
The application relates to a low-latency matrix multiplication unit.
Background
The present description relates to performing neural network calculations in hardware.
Neural networks are machine-learning models that employ one or more layers of the model to generate an output, e.g., a classification, that receives an input. In addition to the output layer, some neural networks include one or more hidden layers. The output of each hidden layer serves as an input to the next layer in the network, the next hidden layer in the network or the output layer. Each layer of the network generates an output from the received inputs based on the current values of the respective set of parameters.
Disclosure of Invention
The present specification describes techniques related to training a neural network, computing neural network reasoning, or both, and in particular to reducing latency on a matrix multiplication component by increasing the rate at which weight values are loaded into weight matrix registers within the matrix multiplication component.
Systolic arrays are connected to perform matrix multiplication and typically have a uniform structure throughout the array. The matrix multiplication component of the systolic array consists of multiply-add sub-components, each of which takes an input operand, multiplies the operand with a stored weight to obtain a result, and adds the result to a partial sum to produce a new partial sum.
One way to reduce latency is to increase the rate at which weights are loaded into the multiply-add component.
In general, one innovative aspect of the subject matter described in this specification can be embodied in special purpose hardware circuits that train neural networks, calculate neural network reasoning, or both.
Other embodiments of this aspect include corresponding computer systems, apparatus, and computer programs recorded on one or more computer storage devices, each configured to perform the actions of the methods. For a system of one or more computers to be configured to perform a particular operation or action, it is meant that the system has software, firmware, hardware, or a combination thereof installed thereon that, when run, causes the system to perform the operation or action. By one or more computer programs to be configured to perform a particular operation or action is meant that the one or more computer programs comprise instructions which, when executed by a data processing apparatus, cause the apparatus to perform the operation or action.
The above and other embodiments may each optionally include one or more of the following features, alone or in combination. Specifically, one embodiment combination includes all of the following features.
The matrix multiplication means may be implemented as an array of dither cells. Each cell of the cell array may include: a weight matrix register configured to receive weight inputs from transposed or non-transposed weight shift registers; a transposed weight shift register configured to receive weight inputs from a horizontal direction to be stored in the weight matrix register; a non-transposed weight shift register configured to receive weight inputs from a vertical direction to be stored in a weight matrix register; and a multiplication component coupled to the weight matrix register and configured to multiply the weight input of the weight matrix register with the vector data input to obtain a multiplication result. Each cell may include a multiplexer configured to select between the transposed weight shift register and the non-transposed weight shift register weight inputs and forward the selected weight inputs to the weight matrix register.
The matrix multiplication unit may comprise a first weight-holding register configured to hold weight values from either the transposed weight shift register or the non-transposed weight shift register.
The matrix multiplication unit may comprise a second weight holding register configured to hold weight values from the transposed weight shift register or the non-transposed weight shift register.
The weight values may be loaded into the matrix multiplication section from the transposed weight shift register in a horizontal direction into the first weight-holding register and from the non-transposed weight shift register in a vertical direction into the second weight-holding register.
The weight matrix register is loaded with values from either the first weight-holding register or the second weight-holding register.
In another embodiment, a matrix multiplication component implemented as a systolic array may include: a plurality of cells arranged in columns of a systolic array; two weight shift register chains per column of systolic array; a weight matrix register per cell, the weight matrix register configured to store weight inputs received from the weight shift register; and a multiplication component coupled to the weight shift register and configured to multiply the weight input of the weight matrix register with the vector data input to obtain a multiplication result. Each weight shift register is connected to only one chain and each cell is connected to only one weight shift register.
The weight values may be sent from a vector register containing pairs of weight values to two weight shift register chains.
When two weight values are not available from the vector registers, a hold register at the top of each column may hold the weight values.
When two weight values are available, the two weight values are shifted to the weight shift registers in the cell in clock cycles.
When two weight values are not available, the holding register is loaded with the first weight value as a holding value at a first clock cycle available at the first weight value and no shift is performed. In the next clock cycle, the second weight value and the hold value are shifted by two shift chains when the second weight value is available. One value is shifted by each shift chain to a weight shift register connected to the shift chain.
Each shift chain may have two injection points for injecting weight values, one at the top of the column and the other at a second point in the column. The vector register may contain a packed set of 4 8-bit integers each representing a separate weight value. 2 of the 4 integers may be injected at the top of the column and the other 2 of the 4 integers may be injected at a second point in the array.
The subject matter described in this specification can be implemented in specific embodiments to realize one or more of the following advantages. A matrix multiplication unit having two weight shift register chains per column of a systolic array may transfer weights from the vector registers to the matrix multiplication unit at twice the rate of a matrix multiplication unit having only one weight shift register chain. In addition, a matrix multiplication element with two weight shift register chains per column that sends weight values to two points in the array, the top and middle points of the array, may pass weights from the vector registers to the matrix multiplication element at a rate four times the rate of the matrix multiplication element with only one weight shift register chain.
Additionally or alternatively, the matrix multiplication unit may have cells containing non-transposed weight shift registers and transposed weight shift registers, respectively. The matrix multiplication unit may then use separate registers of the vertical and horizontal weight shift chains, resulting in the matrix multiplication unit being able to load weight values at twice the rate of the matrix multiplication unit without separate registers of the two weight shift chains.
These weight shift loading methods can be combined to obtain an 8-fold increase in load time from a matrix multiplication unit without separate registers for each column of two weight shift register chains and vertical and horizontal weight shift chains. These weight shift chains and/or separate registers may be added to the matrix multiplication component without significantly increasing the complexity or footprint of the matrix multiplication component.
The details of one or more embodiments of the subject matter of the specification are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the subject matter will become apparent from the description, the drawings, and the claims.
Drawings
FIG. 1A illustrates a high-level diagram of an example dedicated hardware chip for training a neural network.
FIG. 1B illustrates a high level example of a computing core.
FIG. 1C illustrates an example neural network processing system.
FIG. 2 illustrates an example core architecture including a matrix multiplication component. Each matrix multiplication element is a two-dimensional systolic array.
FIG. 3 illustrates an example architecture of multiple cells within a systolic array.
Fig. 4 shows an example of an architecture of a matrix multiplication unit with two weight shift register chains per column in order to increase the rate at which weight values are loaded.
FIG. 5 is a flow chart of an example method of loading weight values into columns of a given multi-cell.
Fig. 6 shows an example of an architecture of a matrix multiplication component with two weight shift register chains per column that sends weight values at two points of the column to increase the rate at which the weight values are loaded.
Fig. 7 shows an example of an architecture of a matrix multiplication component with separate registers for horizontal weight shifting and vertical weight shifting to increase the rate of loading weight values.
FIG. 8 illustrates an example unit having a set of holding registers for increasing the rate at which weight values are loaded.
Like reference numbers and designations in the various drawings indicate like elements.
Detailed Description
A neural network with multiple layers can be trained and then used to compute reasoning. For example, a neural network has parameters, each of which is initialized with a value. During training, the neural network performs a neural network training process to adjust values of parameters of the neural network, e.g., determine training values of the parameters from initial values of the parameters using back propagation. Training the neural network may then compute reasoning, i.e., processing the input through layers of the neural network to generate a neural network output of the input.
For example, in view of the input, the neural network may calculate an inference of the input. The neural network calculates the inference by processing the input through each layer of the neural network. In some embodiments, the layers of the neural network are arranged in a sequence.
Thus, to compute inferences from the received inputs, the neural network receives the inputs and processes the inputs through each of the neural network layers in the sequence to generate inferences, with the output from one neural network layer being provided as input to the next neural network layer. The data input to the neural network layer, for example, the input to the neural network or the output to a layer of the neural network layer that is below a layer in the sequence, may be referred to as an activation input to the layer.
In some embodiments, the layers of the neural network are arranged as a directed graph. That is, any particular layer may receive multiple inputs, multiple outputs, or both. The layers of the neural network may also be arranged such that the output of a layer may be sent back as input to the previous layer.
FIG. 1A illustrates a high-level diagram of an example dedicated hardware chip for training a neural network. As shown, a single dedicated hardware chip includes two independent processors, e.g., 102a, 102b. Each processor 102a, 102b includes two distinct cores: (1) Computing cores, i.e., very Long Instruction Word (VLIW) machines (103 a, 103 b) and (2) sparse computing cores, i.e., embedded layer accelerators (105 a, 105 b).
Each computational core, e.g., 103a and 103b, is optimized for dense linear algebra problems. Each computational core is controlled by a single very long instruction word. Each compute core executes its own stream of very long instruction word instructions.
An example sparse computational core, such as 105a or 105b, maps very sparse high-dimensional data to dense low-dimensional data such that the remaining ones of the layers process densely packed input data. For example, the sparse computational core may perform computations of any embedded layer in the neural network being trained.
To perform such sparse to dense mapping, the sparse computational core uses a pre-built look-up table, embedded into the table. For example, when there is a series of query words that are input by a user, each query word is converted into a hash identifier or a one-hot encoding vector. Using the identifier as a table index, the embedded table returns a corresponding dense vector, which may be an input activation vector to the next layer. The sparse computing core may also perform a reduction operation on the search query term to create a dense activation vector. The sparse compute cores operate together to perform efficient sparse distributed lookups because the embedded tables may be large and unsuitable for high bandwidth memory with limited capacity of one of the dedicated hardware chips. Further details regarding sparse computing core functionality can be found in U.S. patent application Ser. No. 15/016,486, entitled "MATRIX PROCESSING APPARATUS," filed on day 2016, 2, 5.
FIG. 1B illustrates a high level example of a computing core (101). The computational core may be a machine that controls multiple computational components in parallel, i.e., a VLIW machine. Each computing core (101) comprises: scalar memory (104), vector memory (108), scalar processing unit (107), vector register (106), and extension vector unit (i.e., rectangular multiplication unit (MXU) (113), transpose unit (XU) (114), and Reduction and Permutation Unit (RPU) (116)).
An example scalar processor performs VLIW instruction fetch/execute loops and controls a compute core. After fetching and decoding the instruction bundles, the scalar processor itself executes the instructions found in the scalar slots of the bundles using only the multiple multi-bit registers of the scalar processor (107) and scalar memory (104), i.e., 32-bit registers. The scalar instruction set includes normal arithmetic operations, e.g., as used in address calculation, load/store instructions, and branch instructions. The remaining instruction slots encode instructions of vector processing components or other extension vector components (113, 114, 116). The decoded vector instructions are forwarded to a vector processing component.
Along with vector instructions, a scalar processor (107) may forward up to three scalar register values to other processors and components to perform operations. The scalar processor may also retrieve the calculation results directly from the vector processor. However, in some implementations, the example chip has a low bandwidth communication path from the vector processor to the scalar processor.
The vector instruction scheduler is located between the scalar processor and the vector processor. The scheduler receives decoded instructions from non-scalar VLIW slots and broadcasts those instructions to the vector processing unit. The vector processing section is described in detail with respect to fig. 1C.
An example scalar processor (107) accesses a small fast dedicated scalar memory (104), the small fast dedicated scalar memory (104) being supported by a larger but slower High Bandwidth Memory (HBM) (110). Likewise, the example vector processing component accesses a small fast private vector memory (108), the small fast private vector memory (108) also being supported by the HBM (110). Word granularity access occurs between a scalar processor (107) and a scalar memory (104) or between a vector processing component and a vector memory (108). The granularity of the load and store between the vector processor and the vector memory is a vector of 128 32-bit words. Direct memory access occurs between scalar memory (104) and HBM (110) and vector memory (108) and HBM (110). In some embodiments, memory transfer from HBM (110) to processing component (107) may be accomplished only through scalar or vector memory. In addition, there may be no direct memory transfer between the scalar memory and the vector memory.
The instruction may specify an expansion vector component operation. Along with each execution vector unit instruction, there are two-dimensional, i.e. 128 x 8, vector units, each of which can send one register value to the extension vector unit as an input operand. Each expansion vector component takes input operands, performs a corresponding operation, and returns the result to the vector processor (306). The extension vector component is described below with respect to fig. 4.
Fig. 1C illustrates an example application specific integrated circuit 100 for performing neural network computations. As shown, the chip contains two compute cores (103 a, 103 b) and two sparse compute cores (152 a, 152 b).
The chip has a shared area that includes a host interface to a host (150), four high bandwidth memory stacks (156 a-156 d) along the bottom and inter-chip interconnects (148) connecting the interface and memory together, and data from other chips. Two high bandwidth memory stacks (156 a-b, 156 c-d) are associated with each compute core (103 a, 103 b).
The chip stores the data in a high bandwidth memory (156 c-d), reads the data into and out of a vector memory (108) and processes the data. The computing core (103 b) itself includes vector memory (108) as on-chip S-RAM that is divided into two dimensions. The vector memory has an address space in which addresses hold floating point numbers, i.e., 128 numbers of 32 bits, respectively. The computation core (103 b) further includes a computation section that computes a value and a scalar section that controls the computation section.
The vector processing unit consists of a 2-dimensional array of vector processing units, i.e. 128 x 8, all executing the same instruction in a Single Instruction Multiple Data (SIMD) manner. The vector processor has channels and sub-channels, i.e., 128 channels and 8 sub-channels. Within the channel, the vector components communicate with each other through load and store instructions. Each vector component may access a 4 byte value at the same time. Vector components that do not belong to the same channel cannot communicate directly. These vector components must use the reduction/permutation components described below.
The computation unit comprises vector registers, i.e. 32 vector registers, in a vector processing unit (106) which may be used for floating point operations and integer operations. The computation unit includes two Arithmetic Logic Units (ALUs) (126 c-d) for performing computations. One ALU (126 c) performs floating point addition and the other ALU (126 d) performs floating point multiplication. The ALUs (126 c-d) may each perform various other operations, such as shifting, masking, and comparing. For example, the compute core (103 b) may want to add vector register V 1 And a second vector register V 2 And puts the result in the third vector register V 3 Is a kind of medium. To compute the addition, a compute coreThe core (103 b) performs a plurality of operations, that is, 1024 operations, in one clock cycle. Using these registers as operands, each of the vector units can execute two ALU instructions, a load instruction and a store instruction, simultaneously per clock cycle. The base address of a load instruction or store instruction may be calculated with a scalar processor and forwarded to a vector processor. Each of the vector components in each sub-channel may calculate its own offset address using various methods such as stride and special index address registers.
The computation element also includes an Extended Unary Pipeline (EUP) (116) that performs operations such as square root and reciprocal. The compute core (103 b) takes three clock cycles to perform these operations because they fetch one operand at a time. Because the EUP process takes more than one clock cycle, there is a first-in, first-out data store for storing results. When the operation is completed, the result is stored in the FIFO. The compute core may pull the data out of the FIFO and place it in the vector register at a later time using a separate instruction. The random number generator (120) allows the computational core (103 b) to generate a random number per cycle, i.e. 128 random numbers per cycle.
As described above, each processor has three extension vector components: a matrix multiplication section (113), the matrix multiplication section (113) performing a matrix multiplication operation; a cross-channel component (XLU), the cross-channel component (XLU) comprising a transpose operation that performs a matrix, i.e., a 128 x 128 matrix, and a reduction and permutation component, illustrated in fig. 1C as separate components, the reduction component 115 and the permutation component 116.
The matrix multiplication section performs matrix multiplication between two matrices. A matrix multiplication unit (113) receives the data because the computation core needs to load the set of numbers to be multiplied by the matrix. As shown, the data comes from vector registers (106). Each vector register contains digits, i.e. 32-bit digits. However, floating point conversion may occur when data is sent to the matrix multiplication unit (113) to change the number to a smaller bit size, i.e., from 32 bits to 16 bits. The serializer (130) ensures that when a number is read out of the vector register, the two-dimensional array, i.e. the 128 x 8 matrix, is read as a set of 128 numbers that are sent to the matrix multiplication unit (113) in each of the next eight clock cycles. After the matrix multiplication has completed its computation, the results are deserialized (132 a, b), which means that the result matrix is held for a number of clock cycles. For example, for a 128 x 8 matrix, 128 digits are held in each of the 8 clock cycles and then pushed to an appropriate FIFO, such as a Transpose Result FIFO (TRF) 134 or a multiplication result FIFO (TRF) 136, so that a two-dimensional array of 128 x 8 digits can be grabbed in one clock cycle and stored in a vector register contained in the vector processing component (106).
Within a period, i.e. a period of 128 periods, the weights are shifted into the matrix multiplication section (113) as numbers to be multiplied by the matrix. Once the matrix and weights have been loaded, the computation core (103 b) may send the number, i.e. the set of 128 x 8 numbers, to the matrix multiplication component (113). Each row of the set may be multiplied by a matrix to produce a plurality of results, i.e., 128 results per clock cycle. While the computing core is performing matrix multiplication, the computing core also transforms the new set of numbers in the background into the next matrix that will be multiplied by the computing core so that the next matrix is available when the computation of the last matrix has been completed. The matrix multiplication section (113) may process a weight input as data in a matrix to be multiplied and a left-hand side data input as data in a vector to be multiplied with the matrix, and supply the output vector to the vector processing section. The vector processing means may process the outputted vector and store the processed outputted vector to the vector memory. For example, the vector processing component may apply a nonlinear function to the output of the matrix multiplication component to generate the vector data values. In some implementations, the vector processing component 106 generates a normalized value, a pooled value, or both. The vector of processed outputs may be used as a left-hand side data input to the matrix multiplication component 113, for example, for subsequent layers of a neural network.
The transpose unit transposes the matrix. The transpose logic (114) receives the numbers and transposes them such that the numbers on the channels are transposed with numbers of other sizes. In some embodiments, the vector processor includes 128 x 8 vector components. Thus, sixteen separate transpose instructions are required to transpose the 128 x 128 matrix for full matrix transposition. Once transposed, the transposed matrix can be used. However, explicit instructions are required to move the transpose matrix into the vector register file.
The reduction/permutation component (or components 115, 116) solves the problem of cross-channel communication by supporting various operations such as permutation, channel rotation, rotation permutation, channel reduction, permutation channel reduction, and segment permutation channel reduction. As shown, these computations are separate, however, the computational core may use one computation or another computation or one computation linked to another computation. A simplifying unit (115) simplifies each number of digits and supplies the digits to a replacing unit (116). The permutation component alters the data between the different channels. The transposition unit, the simplification unit, the permutation unit and the matrix multiplication unit are respectively completed by adopting more than one clock cycle. Thus, each element has a FIFO associated with it so that the calculation result can be pushed to the FIFO and a separate instruction can be executed at a later time to pull the data out of the FIFO and into the vector register. By using FIFOs, the compute core does not need to hold multiple vector registers for the duration of the long operation. As shown, each of the components obtains data from vector registers in vector processing component (106).
The compute core uses scalar components to control the compute components. Scalar components have two main functions: (1) Performing cycle counting and addressing and (2) generating Direct Memory Address (DMA) requests such that the DMA controller moves data in the background between the high bandwidth memory (156 c-d) and the vector memory (108) and then to inter-chip connections (148) to other chips in the example system. The scalar unit includes an instruction memory (104), instruction decode and issue (102), a scalar processing unit (107) including scalar registers, i.e., 32 bits, a scalar memory (104), and two ALUs (126 a, b) for performing two operations per clock cycle. Scalar components can supply operands and immediate values to vector operations. Each instruction may be issued from the instruction decode and issue (102) as an instruction bundle containing instructions executing on vector registers in the vector processing unit (106). Each instruction bundle is a Very Long Instruction Word (VLIW), where each instruction is multiple bit-widths divided into multiple instruction fields.
Fig. 2 illustrates an example core architecture 200 including matrix multiplication units (MXU) 201a and 201 b. Each MXU is a two-dimensional systolic array. The array is coupled to perform a matrix multiplication operation. MXU multiplies a 128-element vector with a preloaded 128 x 128 vector, the matrix having a constant throughput multiplied once per clock cycle.
Each MXU can have 128 rows and 128 columns. MXU may be divided into identical blocks, referred to as tiles. For example, MXU may be divided into 32 tiles, each tile containing 32 rows and 16 columns. Each tile may be further divided into multiply add subcomponent units. Each unit takes vector data input operands, multiplies the operands with stored weights to obtain a result, and adds the result to the partial sum to produce a new partial sum. In some embodiments, the subcomponent cells may be divided into larger multiple cells, i.e., a 2 x 2 array of multiply-add subcomponent cells or a 4 x 4 array of multiply-add subcomponent cells, referred to as setecim cells. Instead of moving the input data from one multiply-add sub-unit to the next multiply-add sub-unit at a rate of one per clock cycle, the data may be moved across the systolic array in multiple units per clock cycle.
The matrix needs to be preloaded into MXU before starting a series of vector-matrix multiplications. The data of this matrix is referred to as "weight" data. The weight matrix is transferred to the MXU through the source bus by way of a bus connected to the MXU and shifted into the weight shift register. The contents of the weight shift register are then loaded into the weight matrix register so that matrix multiplication can begin. The weight loading process is described in more detail with respect to fig. 3-8.
As shown in fig. 2, each MXU, e.g., 113a and 113b, is connected to three buses, a first source bus (230 a, 230 b) for non-transposed weights, a second source bus (220 a, 220 b) for transposed weights, and a left-hand side bus (210 a, 210 b) for vector data to be multiplied with a matrix stored in the MXU. The MXU is connected to the bus by wires attached to the edge of the MXU. Each transpose unit (XU), e.g., 114a and 114b, is also connected to the first source bus and the second source bus.
The first source bus and the second source bus are multipurpose buses containing data sent from the vector processing unit that would be consumed by an XU or MXU. The data processing occurs in a vector processing data path that includes a vector register 206, a serial processing component 202, and a selection component 204. There are a number of ways in which the vector processing component can send weights on the bus. The weights may be sent normally, "high" or "low". Eight 32-bit floating point numbers per channel (one per sub-channel) are routed to the bfoat, 16-bit floating point number. These values are packaged into four pairs and sent to the MXU every other period over the course of 8 periods. The difference between normal, "high" and "low" is how the vector processing unit performs the floating point 32 to bfoat conversion. The ticket may be encapsulated, meaning that each 32-bit value of the 8 32-bit values per channel contains a bfoat of the encapsulated pair. Instead of 8 values, 16 values are sent to the MXU using the source bus for each of the 8 consecutive cycles. During odd cycles, the lower 16 bits of each subchannel are sent to MXU, and during even cycles, the upper 16 bits of each subchannel are sent. The weights may additionally or alternatively be sent by bytes. Each 32-bit operand contains a packed set of 4 8-bit signed 2's complement integers. Each byte is converted into a modified sign numerical value. These values are sent to the MXU over the source bus in 8 consecutive cycles.
The weights may be sent as non-transposed or transposed instructions using the first source bus or the second source bus and shifted into the weight shift register. When triggered with a load operation, the contents of the weight shift register are loaded into the weight matrix register as follows. The load path from the weight shift register to the weight matrix register is also where the byte pattern data is used to make the transition from modifying the symbol value to the bfoat. The load control bus indicates that the transition is to be made.
Depending on the instruction being executed, a 32-bit value from the source bus may contain: a packed pair of 16-bit floating point values, wherein the value of bits [15:0] represents an earlier value; or 4 encapsulated pairs of 8-bit integers in a modified symbol value format, wherein the value of bits [7:0] represents the (temporally) earliest value and the sequentially following other values. When the MXU receives data from the bus, the data values are evenly distributed over the MXU having a value 0 on the left and a value 127 on the right.
The Left Hand Side (LHS) data bus passes 128 16-bit floating point numbers in a particular format, e.g., bfoat, to be multiplied by a matrix stored in the connected MXU. The data of the LHS data bus comes from the vector processing component and passes through the transpose components, such as 114a and 114b. When the LHS input reaches MXU, the values are evenly distributed over MXU with value 0 on the left and value 127 on the right.
The results of the matrix multiplication are evenly distributed across the MXU and sent from the MXU to a Matrix Result FIFO (MRF), e.g., 136a and 136b. The results from the XU are sent to respective transposed result FIFOs (MRFs), e.g., 136a and 136b.
FIG. 3 illustrates an example architecture of multiple cells within a matrix multiplication component. As described above, each matrix multiplication element is a two-dimensional systolic array. The array includes a plurality of multiply-add sub-components that may be divided into multiple cells. In some embodiments, a first dimension of the systolic array corresponds to a column of cells and a second dimension of the systolic array corresponds to a row of cells. A systolic array may have more rows than columns, more columns than rows, or an equal number of columns and rows. This specification describes certain processes for columns or describes them vertically. However, different designs may perform processing on the rows or horizontally.
In the example shown, the left hand side data registers 315a, 315b send vector data inputs to rows of the array. Weight shift chains 301a and 301b send weight input values to columns of the array, and weight shift chains 302a and 302b send weight input values to rows of the array. The shift chain is a wired path along which values may be passed, for example, from memory to each of the various registers within the matrix multiplication unit.
Each weight shift register 305 is designed to shift the weight content value from the source bus along the chain of weight shift registers 305. After the data is shifted in, the parallel copy operation ensures that all data is copied from the weight shift register 305 to the corresponding weight matrix register 325. When the data is in the weight matrix register 325, the data is for any number of multiplication cycles. During this time more weights may be shifted in the background (typically) into the weight register 305 in preparation for the next multiplication set.
The left hand side data registers 315a, 315b may receive vector data inputs. Each left hand side data register holds one LS data item per clock cycle for one clock cycle. Each vector data input received by the multi-cell may be free flowing in a respective left-hand side register of the multi-cell, such as left-hand side data registers 315a, 315 b. The left hand side data register stores vector data inputs provided by the vector registers through adjacent multi-cells located to the left of a given multi-cell, depending on the location of the multi-cell within the array. For example, if the multi-cell 300 is located at the leftmost position within the systolic array of the matrix multiplication element, the vector data input is provided by a vector register. The vector register may provide a plurality of different vector data inputs to the multi-unit 300, wherein each received vector data input may then be stored by a different one of the left-hand data registers 315. Each row receives a value for each clock cycle, regardless of the number of rows divided into multiple cells.
Each left hand side register may be coupled to a cell along a first dimension of the multi-cell array. The connection of the left hand side register to the cell is indicated by the dashed line in fig. 3. For example, left hand side data register 315a (left hand side data register) in the multi-cell is coupled to cells 350a and 350c of the first row. Likewise, left-hand side data register 315b (second left-hand side register) in the multi-cell is coupled to cells 350b and 350d of the second row. Each left hand side register 315 transfers the stored vector data input to a unit 350 coupled to the left hand side register. Thus, for a given number of cells extending along a first dimension (e.g., along a given row or along a given column), vector data input may be passed to all of the cells in the multi-cell array, rather than just a single cell, such that vector data input is rapidly distributed over the array of cells, thereby improving the efficiency of operation of the multi-cell.
The plurality of vector data inputs may also be sent to an adjacent left-hand side register such that the plurality of vector data inputs may be used at another multi-cell of the array. This process allows vector data input shifting for use in another particular multi-cell of the array.
Each cell 350 of the multi-cell 300 contains a stored weight value. Before starting the matrix multiplication process, the weights are loaded by shifting the weights into cells of the systolic array. Dedicated chains and weight shift registers are provided for weight shifting so that new weights can be shifted while performing the previous matrix multiplication process. The weight inputs may be loaded into the multiple cells in a manner that reduces the latency of the overall matrix multiplication operation process.
As described above, the weight shift chains 301, 302 may receive weight inputs from a memory component, such as the vector memory 108 of fig. 1. The shift chain may send a plurality of corresponding weight inputs to a weight matrix register 325 associated with the multi-cell 300.
In some implementations, the weight shift register will shift vector data inputs across the array in one dimension, e.g., to the right, while shifting weight inputs across the array in one or two dimensions, e.g., to the right or down. For example, each vector data input of the plurality of vector data inputs at the multi-cell 300 may be shifted to a corresponding left-hand side data register in a next multi-cell in the same row within one clock cycle. The horizontal data (left hand side data) and the vertical data (partial sum) are each shifted by one multi-cell per clock cycle. The weights are shifted only when directed by the system and may be shifted by 1, 2 or 4 rows (or columns) depending on the implementation and the additional instructions being executed.
Multiplexer 330 selects weights from weight shift register 305 of either first shift chain 301 or second shift chain 302 and forwards the selected inputs to a single row in weight matrix register 325. Although multiplexer 330 is shown as being outside the boundary rows of cells 350, in some embodiments multiplexer 330 is present within cells 350.
In a clock cycle, each multi-cell may process a plurality of given weight inputs and a plurality of given vector data inputs to generate a plurality of cumulative outputs. In general, the processing includes a multiplication operation that multiplies the vector data input by a stored weight. The cumulative output may also be pure washed down to adjacent multi-cells along the same dimension as the given weight input. In some implementations, the weights are shifted by more than one multi-cell during a given clock cycle to transition from one convolution calculation to another.
The accumulated output may be passed along the same column as the weight input, e.g., toward the bottom of the column in the array. In some implementations, the partial sum registers 310a, 311a pass partial sum values from a previous multi-cell into the multi-cell. The array may include a portion storing the accumulated output from each column of multiple cells and registers 310b, 311b. For each column of multiple cells, the product generated by the sub-unit cells in the column is combined with the input partial sum from the multiple cells above and then forwarded as the next partial sum. For some multi-cells, for example, in the bottom column of the systolic array, the accumulated output may include the last accumulated value that may be transferred to the vector calculation unit. In some embodiments, the last accumulated value is transferred directly from the bottom multiple unit of the array to the vector calculation component, while in other embodiments, the last accumulated value is first stored in memory or processed by a different component before being sent to the vector calculation component.
Fig. 4 shows an example of a multi-cell architecture of a matrix multiplication unit with two weight shift register chains per column in order to increase the rate at which weight values are loaded. As shown in fig. 4, cell 435a and cell 435b comprise one column of multi-cell 400 and cell 435c and cell 435d comprise a second column of multi-cell 400. Each column has two chains of weight shift registers. Each cell in a given column is configured to receive weight inputs from only one of the two chains in the column. As shown in fig. 4, one chain 401 is connected to the weight shift registers in even rows and one chain 402 is connected to the weight shift registers in odd rows. Two new values are shifted into each column per cycle and all existing weight values are shifted down by two rows. Thus, weights can be loaded into the multiple cells at twice the rate of the matrix multiplication elements of the two weight shift register chains without systolic arrays.
As shown, the weight value is shifted in from the vector register 403. In an embodiment, there is one vector register 403 per column of the matrix multiplication unit. Although vector register 403 is illustrated in the example of fig. 3 as being located at the top of the matrix multiplication element, vector register 403 may be physically located at various positions relative to the matrix multiplication element, such as at the bottom of the element.
Vector register 403 may hold register values that are some number greater than or less than the values operated on by the matrix multiplication unit. For example, a register may hold an n-bit value, while a matrix multiplication component operates on an n/2-bit value. In some implementations, each vector register holds a 32-bit value and the matrix multiplication component operates on a 16-bit value. The example matrix multiplication component has a pattern that treats each 32-bit value of a register as a pair of 16-bit values, where one 16-bit value of the pair of 16-bit values is sent to a first weight shift chain 401 and the second 16-bit value of the pair of 16-bit values is sent to a second weight shift chain 402. Although one example register 403 is shown per column, there may be only one vector register 403 per multi-cell. Additionally or alternatively, each chain may be connected to a separate vector register 303 that provides a single 16-bit weight value to the chain. In this case, the 32-bit floating point value in the vector register 403 is converted into a 16-bit value.
In some implementations, the weight value may not be able to send the value at twice the rate of the matrix multiplication unit without two shift chains per column. To handle this, a hold register 445 is placed at the top of each column to hold the weight values until two weight values are available, one for each vertical shift chain. In a first clock cycle, where only one weight value is available, the available weight value is copied into the holding register 445. In the next clock cycle in which new weight values are available, the weight values in the holding registers will be shifted from holding register to weight shift register by one weight shift chain and the new weight values available in that clock cycle will be shifted to the second weight shift register by the second weight shift chain.
The horizontal shift chain 405 may provide weight values to cells as described above. In some embodiments, there may be two horizontal shift chains for reducing weight loading latency in the same manner as the vertical shift chains 401, 402 described above.
The multiplexer 430 determines whether the weight values sent to the weight matrix registers within the cell are from the horizontal shift chain 405 or the vertical shift chain 401b or 402b. Once the weight values have been loaded into the weight matrix registers and the left hand side data registers 415 provide vector data inputs, matrix multiplication may then be performed by unit 435.
FIG. 5 is a flow chart of an example process 500 of loading weight values into columns of a given multi-cell. The interface receives at least one weight value from a vector register (501).
The interface determines whether a plurality of weight values are available (502).
If multiple weight values are available, the interface shifts the weight values through a shift chain to a weight shift register in cell 435 within the multi-cell in a clock cycle (504).
The interface continues to load weight values until all weight values from the weight matrix are loaded in the matrix multiplication component (506).
If both weight values are not available in the same clock cycle, then the holding register 445 is loaded with available weight values and no shift is made in the first cycle in which a single weight value is available (503).
In the next cycle when another weight value becomes available, the interface shifts the new value and the value held in holding register 445 to the weight shift register in the multi-cell through two shift chains (505).
The interface then continues to load weight values until all weight values from the weight matrix are loaded in the matrix multiplication component (506).
In the event that multiple weight values are not available at each cycle, the interface activates the shift chain only every other cycle.
Fig. 6 shows an example of an architecture of a matrix multiplication component with two weight shift register chains per column with weight values injected at two points of the column to increase the rate of loading the weight values by a factor of four. As shown in fig. 3, the matrix multiplication unit has two shift chains per column of the systolic array. Each cell 650 includes a shift register 635 connected to only one shift chain. As described above, the vector register 603 may hold a register value that is some numerical value larger or smaller than the value operated by the matrix multiplication section. For example, a register may hold an n-bit value, while a matrix multiplication component operates on an n/2-bit value. The values in the vector registers may be divided or in some way translated to match the value sizes expected by the matrix multiplication component.
In one embodiment, each register 603 may hold a 32-bit value. The value in each vector register 603 may be considered as four 8-bit signed integers of the packed set, with the united states being a separate weight value. As shown in fig. 3, each 8-bit signed integer may be transmitted over two 16-bit chains. However, integers are sent to two injection points 680, 681 for each column in the systolic array. The integer is sent to the top (680 b ) and the other to the bottom of the array (680 a, 6801 a). Embodiments having multiple injection points as described may be combined with other embodiments and features discussed herein.
In some embodiments, if an integer is sent along the array to an intermediate point, no additional connection is needed to inject the integer, as the chain from the vector register to the top of the array traverses the length of the array from bottom to bottom. At the top of each column, two of the integers are converted to 16-bit floating point values in the format used by the array, which 16-bit floating point values are then injected into the two weight shift chains (680 a, 681 a) described above. The shift chain is cut by the multiplexer at the intermediate point and the second set of integer-to-floating point number converters takes the other two integers from each 32-bit value at that point, converts them, and injects them into that point (680 b, 681 b). For example, a 32-bit word may be divided into 4 equal 8-bit portions: A. b, C and D. The weight interface may send parts a and B to the top of the array and convert them into 16-bit values to be operated on by the matrix multiplication component. The weight interface may also send parts C and D to the middle point of the array via a multiplexer. In this embodiment, parts C and D are not sent to the top of the array, but are injected into the weight shift registers of the cells at the middle point on the shift chain. The multiplexer is present on the shift chain at the intermediate point such that the weight value is selected from the injection point instead of from the previous weight shift register on the shift chain.
The point at which the second weight pair is injected into the array may not go back to the middle point, but some other point. For example, it may be a point along a quarter of the path of the array. In this case, the weights injected at the top are shifted to the first quarter cell of the matrix multiplication unit and the third quarter cell of the matrix multiplication unit, while the weights injected at the quarter points are shifted to the second and fourth quarter cells of the matrix multiplication unit. This process requires additional connections but allows the weights to start shifting earlier while completing the previous matrix multiplication.
As shown, two shift chains exist in each column. However, in some embodiments, two shift chains may additionally or alternatively be present per row, two injection points per shift chain.
Fig. 7 shows an example of an architecture with matrix multiplication components for transpose weight shifting and normal non-transpose weight shifting to increase the rate of loading weight values. Each multi-cell 700 includes a plurality of cells 750 and may be loaded with weight values from either the vertical or horizontal directions. Loading weights from the top in the vertical direction results in a weight matrix being stored in the matrix multiplication unit. Loading the same weights in the same order but from the side results in a transpose of the weight matrix being stored in the matrix multiplication component. In neural network system training, both the non-transposed weight matrix and the transposed weight matrix must be loaded in different steps of the training algorithm. When the weight is loaded in the vertical direction from the top, the weight value is shifted downward by the cell. When the weight is loaded from the left in the horizontal direction, the weight value is shifted rightward by the multiple units 700. Fig. 7 illustrates normal shift chains 701a, 701b connected to a normal shift register 705. The transpose shift chains 702a, 702b are connected to a transpose shift register 705. The multiplexer 730 determines from which shift chains 701, 702 the weight matrix register 725 is loaded.
In some embodiments, n cycles are required to shift a set of weights into the weight matrix registers of the matrix multiplication component. The second set of weights may begin their shifting n/2 cycles after loading the first weight value and a new set of weights may be loaded from the shift register into the weight matrix register every n/2 cycles.
In some embodiments, it is not necessary to always use 128×128 weights for the entire group. The weight at the unused position may be set to zero, effectively making the weight matrix smaller. The matrix multiplication unit then does not need to shift the data into all rows or all columns of the weight shift register. Each weight shift instruction shifts 8 rows of data, or 8 columns of data into a systolic array for transpose loading. The 16 weight shift instruction loads the entire 128 x 128 matrix replacing all the previous data. Each weight shift register is cleared when data is copied from the weight shift register to the corresponding weight matrix register. Shifting new data into the weight shift register may begin immediately after the load and clear signals begin to propagate. The weight shift signal is not available for loading and clearing all of the elements below and to the right of the wavefront so that the data is not shifted until it has an opportunity to load. Because the old data is completely cleared, it is not necessary to shift in the allowed row or column data. Only the top (or left) portion of the shift register will be filled with new data and the remainder will remain zero, resulting in the input data to those rows being omitted (or the output data from those columns being zero).
FIG. 8 illustrates an example unit 800 having a set of holding registers for increasing the rate at which weight values are loaded. Element 800 includes one or more weight-holding register sets that serve as temporary storage for array weights that have been shifted in. Instead of or in addition to being copied to the weight matrix register 825, the values of the weight shift register set 805a may also be copied into the weight holding register set 845 a. Instead of or in addition to being copied to the weight matrix register 825, the values of the second set of weight shift registers 805b may also be copied into the second set of weight holding registers 845 b. When the weight value set is loaded into the weight matrix register, instead of directly acquiring the weight value set from the weight shift registers 805a, 805b, the weight value set may also be acquired from the set of holding registers in the array holding register 845. This process allows the set of weight values to be loaded more than once after shifting into the array. For example, if the algorithm requires switching between two sets of weights, the weight values from one shift chain may be shifted to the hold register between loads. The process also allows decoupling the timing of weight shifting from weight loading. For example, when a new set of weight values starts to shift every n/c cycles, two sets of weight values may be shifted simultaneously and the other set moved to the weight-holding register while the first set is loaded into the weight-matrix register. After an n/2 additional period, the second set is loaded from the holding register to the weight matrix register.
In some embodiments, the two shift chains of fig. 4 and/or 6 may be combined with the addition of normal and transpose shift registers to increase the number of weight values that can be loaded into the matrix multiplication component at a given time.
Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, in tangibly embodied computer software or firmware, in computer hardware including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions encoded on a tangible, non-transitory storage medium for execution by, or to control the operation of, data processing apparatus. The computer storage medium may be a machine-readable storage device, a machine-readable storage substrate, a random or serial access memory device, or a combination of one or more of them. Alternatively or additionally, the program instructions may be encoded on a manually-generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated for encoding information for transmission to a suitable receiver apparatus for execution by a data processing apparatus.
The term "data processing apparatus" refers to data processing hardware and encompasses various apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers. The device may also be or further comprise dedicated logic circuitry, e.g. an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit). In addition to hardware, the device may optionally include code that creates an execution environment for the computer program, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them.
A computer program, which can also be referred to or described as a program, software application, module, software module, script, or code, can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub-programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located on one station or distributed across multiple stations and interconnected by a data communication network.
The processes and logic flows described in this specification can be performed by one or more programmable computers executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by, or combination of, special purpose logic circuitry, e.g., an FPGA or ASIC, and one or more programmed computers.
A computer suitable for executing the computer program may be based on a general-purpose or special-purpose microprocessor or both, or any other kind of central processing unit. Generally, a central processor receives instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a central processing unit for carrying out or executing instructions and one or more memory devices for storing instructions and data. The central processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. However, the computer need not have such devices. Moreover, the computer may be embedded in another device, such as a mobile phone, a Personal Digital Assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., universal Serial Bus (USB) flash drive), to name a few.
Computer readable media suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including, for example: semiconductor memory devices such as EPROM, EEPROM, and flash memory devices, magnetic disks such as internal hard disks or removable disks, magneto-optical disks, CD-ROM disks, and DVD-ROM disks.
To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, such as a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices may also be used to provide for interaction with a user; for example, feedback provided to the user may be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user may be received in any form, including acoustic, speech, or tactile input. In addition, the computer may interact with the user by sending the document to the device used by the user and receiving the document from the device; for example, by sending a web page to a web browser on a user's device in response to a request received from the web browser. Also, a computer may interact with a user by sending text messages or other forms of messages to a personal device, such as a smart phone, running a messaging application, and receiving response messages from the user as answers.
Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a background component (e.g., as a data server), or that includes a middleware component (e.g., an application server), or that includes a foreground component (e.g., a client computer having a graphical user interface, a web browser, or an app through which a user can interact with an implementation of the subject matter described in this specification), or that includes any combination of one or more such background, middleware, or foreground components. The components of the system can be interconnected by any form or medium of digital data communication (e.g., a communication network). Examples of communication networks include a Local Area Network (LAN) and a Wide Area Network (WAN), such as the internet.
The computing system may include clients and servers. The client and server are typically remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other. In some embodiments, the server sends data, such as HTML pages, to the user device, such as to display data to and receive user input from a user interacting with the device. Data generated at the user device, such as the results of a user interaction, may be received from the device at the server.
Embodiment 1 is a matrix multiplication section implemented as a dynamic cell array, each cell of the cell array including: a weight matrix register configured to receive weight inputs from transposed or non-transposed weight shift registers; a transposed weight shift register configured to receive weight inputs from a horizontal direction to be stored in the weight matrix register; a non-transposed weight shift register configured to receive weight inputs from a vertical direction to be stored in a weight matrix register; and a multiplication component coupled to the weight matrix register and configured to multiply the weight input of the weight matrix register with the vector data input to obtain a multiplication result.
Embodiment 2 is the matrix multiplication unit according to embodiment 1, wherein each cell further includes: a multiplexer configured to select between the transposed weight shift register and the non-transposed weight shift register weight inputs and forward the selected weight inputs to the weight matrix register.
Embodiment 3 is the matrix multiplication unit of embodiment 1 or 2, further comprising a first weight-holding register configured to hold weight values from the transposed weight shift register or the non-transposed weight shift register.
Embodiment 4 is the matrix multiplication unit of any one of embodiments 1 to 3, further comprising a second weight-holding register configured to hold weight values from the transposed weight shift register or the non-transposed weight shift register.
Embodiment 5 is the matrix multiplication unit according to any one of embodiments 1 to 4, wherein the weight values are loaded from the transposed weight shift register into the first weight-holding register and the weight values are loaded from the vertical direction into the second weight-holding register.
Embodiment 6 is the matrix multiplication unit of any one of embodiments 1 to 5, wherein the weight matrix register is loaded with values from the first weight holding register or the second weight holding register.
Embodiment 7 is a matrix multiplication unit implemented as a systolic array, the matrix multiplication unit comprising:
A plurality of cells arranged in columns of a systolic array; two weight shift register chains per column of systolic array; wherein each weight shift register is connected to only one chain and each cell is connected to only one weight shift register; a weight matrix register per unit configured to store inputs received from the weight shift register; and a multiplication unit coupled to the weight matrix register and configured to multiply the weight inputs of the weight matrix register with the vector data to obtain a multiplication result.
Embodiment 8 is the matrix multiplication unit of embodiment 7, wherein the weight values are sent from a vector register containing weight pair values onto two weight shift register chains.
Embodiment 9 is the matrix multiplication unit according to embodiment 7 or 8, comprising a holding register at the top of each column for holding weight values when two weight values are not available from the vector register.
Embodiment 10 is the matrix multiplication component of any one of embodiments 7 to 9, wherein when two weight values are available, the two weight values are shifted to the weight shift register in a unit in a clock cycle.
Embodiment 11 is the matrix multiplication component of any one of embodiments 7-10, wherein, when two weight values are not available: in a first clock cycle in which the first weight value is available, the holding register is loaded with the first weight value as a holding value and is not shifted; and at the next clock cycle, when the second weight value is available, shifting the second weight value and the hold value by two shift chains to a weight shift register connected to the shift chains, each shift chain being shifted by one value.
Embodiment 12 is the matrix multiplication unit according to any one of embodiments 7 to 11, further comprising: each shift chain has two injection points for injecting weight values, one at the top of the column and the other at a second point in the column.
Embodiment 13 is the matrix multiplication unit according to any one of embodiments 7 to 12, further comprising: the vector register contains 4 8-bit integers of the packed set, which 8-bit integers represent separate weight values, respectively.
Embodiment 14 is the matrix multiplication unit according to any one of embodiments 7 to 13, further comprising: two of the 4 integers are injected into the top of the column and the other two of the 4 integers are injected into the second point in the array.
While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any invention or of what may be claimed, but rather as descriptions of features specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.
Also, although operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In some circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system modules and components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
Specific embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. For example, the actions recited in the claims can be performed in a different order and still achieve desirable results. As one example, the processes illustrated in the accompanying drawings do not necessarily require the particular order shown or the sequential order to achieve desirable results. In some cases, multitasking and parallel processing may be advantageous.
Claims (52)
1. A matrix multiplication component configured to perform neural network calculations of a neural network, the matrix multiplication component implemented as an array of systolic cells arranged in a two-dimensional format, each cell in the array of cells comprising:
a weight matrix register configured to receive weight inputs from the neural network of one or more weight storage registers;
the one or more weight storage registers, wherein the one or more weight storage registers are configured to receive weight inputs from the neural network to be stored in the weight matrix register from both a first direction of the two-dimensional format and a second direction of the two-dimensional format, the second direction being different from the first direction; and
A multiplication component coupled to the weight matrix register and configured to multiply a weight input of the weight matrix register with a vector data input of the neural network to obtain a multiplication result.
2. The matrix multiplication component of claim 1, wherein each cell further comprises:
a multiplexer configured to:
selecting a weight input from the weight inputs received from the first direction and the second direction; and
the selected weight input is sent to the weight matrix register.
3. The matrix multiplication component of claim 1, further comprising a first weight-holding register configured to hold the weight input from the first direction.
4. A matrix multiplication section according to claim 3, further comprising a second weight holding register configured to hold the weight input from the second direction.
5. The matrix multiplication component of claim 4, wherein the weight input from the first direction is loaded from the one or more weight storage registers into the first weight holding register, wherein the weight input from the second direction is loaded from the one or more weight storage registers into the second weight holding register.
6. The matrix multiplication component of claim 5, wherein the weight matrix register is loaded with one of the weight input from the first direction and the weight input from the second direction.
7. The matrix multiplication component of claim 6, wherein the weight inputs in the weight matrix register are used for any number of multiplication cycles.
8. The matrix multiplication component of claim 7, wherein during the number of multiplication cycles, additional weight inputs are shifted into the one or more weight storage registers to prepare a subsequent set for one or more multiplications.
9. The matrix multiplication component of claim 7, wherein during the number of multiplication cycles, another weight input of the neural network is multiplied with another vector data input of the neural network to obtain another multiplication result.
10. The matrix multiplication component of claim 1, wherein the vector data input is shifted by one multi-cell per clock cycle.
11. The matrix multiplication unit of claim 1, wherein the one or more weight storage registers comprise a transposed weight shift register and a non-transposed weight shift register physically separate from the transposed weight shift register.
12. The matrix multiplication component of claim 1, wherein the one or more weight storage registers configured to receive the weights comprise:
a first weight storage register configured to receive a first weight input from another cell in the array along the first direction via a first wired path; and
a second weight storage register configured to receive a second weight input from another element in the array along the second direction via a second wired path, wherein the weight input is at least one of the first weight input or the second weight input.
13. A cell of a plurality of cells arranged in an array of matrix multiplication components, the cell comprising:
a weight matrix register configured to receive weight inputs from a neural network of one or more weight storage registers, wherein the one or more weight storage registers are configured to receive a plurality of weight inputs from the neural network in a first direction of the array and a second direction of the array, the second direction being different from the first direction; and
A multiplication component coupled to the weight matrix register, wherein the multiplication component is configured to receive weight inputs from the weight matrix register, wherein the multiplication component is configured to multiply the received weight inputs with vector data inputs of the neural network to generate a multiplication result.
14. The unit of claim 13, wherein the multiplication result is part of a plurality of neural network calculations.
15. The unit of claim 14, wherein the multiplication component is configured to multiply the received weight input with another vector data input to generate another multiplication result, wherein the other multiplication result is another portion of the plurality of neural network calculations.
16. The cell of claim 13, wherein the array is a systolic cell array.
17. The unit of claim 13, wherein:
the array has a two-dimensional format;
the first direction of the array is the first direction of the two-dimensional format; and
the second direction of the array is a second direction of the two-dimensional format.
18. The unit of claim 13, further comprising a multiplexer configured to:
Selecting a weight input from the plurality of weight inputs; and
the selected weight input is sent to the weight matrix register.
19. The unit of claim 13, wherein the one or more weight storage registers comprise a transposed weight shift register and a non-transposed weight shift register.
20. The unit of claim 19, wherein the non-transposed weight shift register is physically separate from the transposed weight shift register.
21. The unit of claim 13, wherein the one or more weight storage registers comprise:
a first weight storage register configured to receive a first weight input of the plurality of weight inputs from a first cell of the plurality of cells along the first direction via a first wired path; and
a second weight storage register configured to receive a second weight input from a second cell of the plurality of cells along the second direction via a second wired path,
wherein the weight input is one of the first weight input and the second weight input.
22. A method, comprising:
receiving, by a weight matrix register of cells of a plurality of cells arranged in an array of matrix multiplication components, weight inputs from a neural network of one or more weight storage registers, wherein the one or more weight storage registers receive a plurality of weight inputs from the neural network in a first direction of the array and a second direction of the array, wherein the second direction is different from the first direction; and
the weight inputs are multiplied by vector data inputs of the neural network by a multiplication component coupled to the weight matrix register to generate a multiplication result.
23. The method of claim 22, wherein the multiplication result is part of a plurality of neural network calculations.
24. The method of claim 23, further comprising:
multiplying, by the multiplication component, the received weight input with another vector data input to generate another multiplication result, wherein the other multiplication result is another portion of the plurality of neural network calculations.
25. The method of claim 22, wherein the array is a systolic cell array.
26. The method according to claim 22, wherein:
the array has a two-dimensional format;
the first direction of the array is the first direction of the two-dimensional format; and
the second direction of the array is a second direction of the two-dimensional format.
27. The method of claim 22, further comprising:
selecting, by a multiplexer, a weight input from the plurality of weight inputs; and
the selected weight input is received from the multiplexer by the weight matrix register.
28. The method of claim 22, wherein the one or more weight storage registers comprise a transposed weight shift register and a non-transposed weight shift register.
29. The method of claim 28, wherein the non-transposed weight shift register is physically separate from the transposed weight shift register.
30. The method of claim 22, wherein the one or more weight storage registers comprise:
a first weight storage register configured to receive a first weight input of the plurality of weight inputs from a first cell of the plurality of cells along the first direction via a first wired path; and
A second weight storage register configured to receive a second weight input from a second cell of the plurality of cells along the second direction via a second wired path,
wherein the weight input is one of the first weight input and the second weight input.
31. A non-transitory computer program product storing instructions that, when executed by at least one programmable processor, cause the at least one programmable processor to perform operations comprising:
receiving, by a weight matrix register of cells of a plurality of cells arranged in an array of matrix multiplication components, weight inputs from a neural network of one or more weight storage registers, wherein the one or more weight storage registers receive a plurality of weight inputs from the neural network in a first direction of the array and a second direction of the array, wherein the second direction is different from the first direction; and
the weight inputs are multiplied by vector data inputs of the neural network by a multiplication component coupled to the weight matrix register to generate a multiplication result.
32. The non-transitory computer program product of claim 31, wherein:
the array has a two-dimensional format;
the first direction of the array is the first direction of the two-dimensional format; and
the second direction of the array is a second direction of the two-dimensional format.
33. A cell of a plurality of cells arranged in an array of matrix multiplication components, the cell comprising:
a weight matrix register configured to receive weight inputs from a plurality of weight storage registers, wherein each weight storage register of the plurality of weight storage registers is configured to receive a respective weight input from a respective direction of the array, wherein the respective direction includes a first direction of the array and a second direction of the array that is different from the first direction; and
a multiplication section configured to receive the weight input from the weight matrix register and generate a multiplication result based on the received weight input and another input data.
34. The unit of claim 33, wherein the other input data comprises a vector data input, and wherein the multiplication result is part of a plurality of neural network calculations.
35. The unit of claim 34, wherein the multiplication component is configured to receive a further weight input from the weight matrix register and multiply the further received weight input with a further vector data input to generate a further multiplication result, and wherein the further multiplication result is a further portion of the plurality of neural network calculations.
36. The cell of claim 33, wherein the array is a systolic cell array.
37. The unit of claim 33, wherein:
the array has a two-dimensional format;
the first direction of the array is the first direction of the two-dimensional format; and
the second direction of the array is a second direction of the two-dimensional format.
38. The unit of claim 33, further comprising a multiplexer configured to:
selecting a weight input from at least two respective weight inputs each stored in a corresponding weight storage register; and
the selected weight input is sent to the weight matrix register.
39. The unit of claim 33, wherein the plurality of weight storage registers comprises a transposed weight shift register and a non-transposed weight shift register physically separate from the transposed weight shift register.
40. The unit of claim 33, wherein the plurality of weight storage registers comprise:
a first weight storage register configured to receive a first weight input from a first cell of the plurality of cells along the first direction via a first wired path; and
a second weight storage register configured to receive a second weight input from a second cell of the plurality of cells along the second direction via a second wired path;
wherein the weight input is one of the first weight input and the second weight input.
41. A method, comprising:
receiving, by a weight matrix register of a cell of a plurality of cells arranged in an array of matrix multiplication components, weight inputs from a plurality of weight storage registers, wherein each weight storage register of the plurality of weight storage registers is configured to receive a respective weight input from a respective direction of the array, wherein the respective direction includes a first direction of the array and a second direction of the array that is different from the first direction; and
A multiplication result is obtained by a multiplication component coupled to the weight matrix register based on the received weight input and further input data.
42. The method of claim 41, wherein the other input data comprises a vector data input, and wherein the multiplication result is part of a plurality of neural network calculations.
43. The method of claim 42, further comprising:
receiving, by the multiplication component, another weight input from the weight matrix register; and
multiplying, by the multiplication component, another received weight input with another vector data input to generate another multiplication result, wherein the other multiplication result is another portion of the plurality of neural network calculations.
44. The method of claim 41, wherein the array is a systolic cell array.
45. The method of claim 41, wherein:
the array has a two-dimensional format;
the first direction of the array is the first direction of the two-dimensional format; and
the second direction of the array is a second direction of the two-dimensional format.
46. The method of claim 41, further comprising:
selecting, by the multiplexer, a weight input from at least two respective weight inputs each stored in a corresponding weight storage register; and
The selected weight input is received from the multiplexer by the weight matrix register.
47. The method of claim 41, wherein the plurality of weight storage registers includes a transposed weight shift register and a non-transposed weight shift register physically separate from the transposed weight shift register.
48. The method of claim 41, wherein the plurality of weight storage registers comprises:
a first weight storage register configured to receive a first weight input from a first cell of the plurality of cells along the first direction via a first wired path; and
a second weight storage register configured to receive a second weight input from a second cell of the plurality of cells along the second direction via a second wired path,
wherein the weight input is one of the first weight input and the second weight input.
49. A non-transitory computer program product storing instructions that, when executed by at least one programmable processor, cause the at least one programmable processor to perform operations comprising:
Receiving, by a weight matrix register of a cell of a plurality of cells arranged in an array of matrix multiplication components, weight inputs from a plurality of weight storage registers, wherein each weight storage register of the plurality of weight storage registers is configured to receive a respective weight input from a respective direction of the array, wherein the respective direction includes a first direction of the array and a second direction of the array that is different from the first direction; and
a multiplication result is obtained by a multiplication component coupled to the weight matrix register based on the received weight input and further input data.
50. The non-transitory computer program product of claim 49, wherein:
the array has a two-dimensional format;
the first direction of the array is the first direction of the two-dimensional format; and
the second direction of the array is a second direction of the two-dimensional format.
51. The non-transitory computer program product of claim 49, wherein the plurality of weight storage registers includes a transposed weight shift register and a non-transposed weight shift register physically separate from the transposed weight shift register.
52. The non-transitory computer program product of claim 49, wherein the plurality of weight storage registers comprises:
a first weight storage register configured to receive a first weight input from a first cell of the plurality of cells along the first direction via a first wired path; and
a second weight storage register configured to receive a second weight input from a second cell of the plurality of cells along the second direction via a second wired path;
wherein the weight input is one of the first weight input and the second weight input.
Applications Claiming Priority (4)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201762507766P | 2017-05-17 | 2017-05-17 | |
US62/507,766 | 2017-05-17 | ||
PCT/US2018/033261 WO2018213628A1 (en) | 2017-05-17 | 2018-05-17 | Low latency matrix multiply unit |
CN201880004576.1A CN109997132B (en) | 2017-05-17 | 2018-05-17 | Low-delay matrix multiplication component |
Related Parent Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN201880004576.1A Division CN109997132B (en) | 2017-05-17 | 2018-05-17 | Low-delay matrix multiplication component |
Publications (1)
Publication Number | Publication Date |
---|---|
CN116661732A true CN116661732A (en) | 2023-08-29 |
Family
ID=62815117
Family Applications (4)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN201880004328.7A Active CN109937416B (en) | 2017-05-17 | 2018-05-17 | Low delay matrix multiplication component |
CN201880004576.1A Active CN109997132B (en) | 2017-05-17 | 2018-05-17 | Low-delay matrix multiplication component |
CN202310303331.1A Pending CN116414350A (en) | 2017-05-17 | 2018-05-17 | Low-delay matrix multiplication component |
CN202310556021.0A Pending CN116661732A (en) | 2017-05-17 | 2018-05-17 | Low-delay matrix multiplication component |
Family Applications Before (3)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN201880004328.7A Active CN109937416B (en) | 2017-05-17 | 2018-05-17 | Low delay matrix multiplication component |
CN201880004576.1A Active CN109997132B (en) | 2017-05-17 | 2018-05-17 | Low-delay matrix multiplication component |
CN202310303331.1A Pending CN116414350A (en) | 2017-05-17 | 2018-05-17 | Low-delay matrix multiplication component |
Country Status (8)
Country | Link |
---|---|
US (8) | US10635740B2 (en) |
EP (4) | EP3800563B1 (en) |
JP (3) | JP6929958B2 (en) |
KR (1) | KR102302608B1 (en) |
CN (4) | CN109937416B (en) |
BR (2) | BR112019022916A2 (en) |
TW (5) | TWI685757B (en) |
WO (2) | WO2018213628A1 (en) |
Families Citing this family (60)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US10853448B1 (en) | 2016-09-12 | 2020-12-01 | Habana Labs Ltd. | Hiding latency of multiplier-accumulator using partial results |
CN109937416B (en) | 2017-05-17 | 2023-04-04 | 谷歌有限责任公司 | Low delay matrix multiplication component |
US11409692B2 (en) * | 2017-07-24 | 2022-08-09 | Tesla, Inc. | Vector computational unit |
US10671349B2 (en) | 2017-07-24 | 2020-06-02 | Tesla, Inc. | Accelerated mathematical engine |
US11157287B2 (en) | 2017-07-24 | 2021-10-26 | Tesla, Inc. | Computational array microprocessor system with variable latency memory access |
US11157441B2 (en) | 2017-07-24 | 2021-10-26 | Tesla, Inc. | Computational array microprocessor system using non-consecutive data formatting |
US11893393B2 (en) | 2017-07-24 | 2024-02-06 | Tesla, Inc. | Computational array microprocessor system with hardware arbiter managing memory requests |
US11321092B1 (en) | 2017-11-08 | 2022-05-03 | Habana Labs Ltd. | Tensor-based memory access |
US10915297B1 (en) * | 2017-11-15 | 2021-02-09 | Habana Labs Ltd. | Hardware accelerator for systolic matrix multiplication |
US11373088B2 (en) * | 2017-12-30 | 2022-06-28 | Intel Corporation | Machine learning accelerator mechanism |
US11561791B2 (en) * | 2018-02-01 | 2023-01-24 | Tesla, Inc. | Vector computational unit receiving data elements in parallel from a last row of a computational array |
US11164072B2 (en) | 2018-02-08 | 2021-11-02 | Western Digital Technologies, Inc. | Convolution engines for systolic neural network processor |
US10796198B2 (en) | 2018-02-08 | 2020-10-06 | Western Digital Technologies, Inc. | Adjusting enhancement coefficients for neural network engine |
US11275997B1 (en) * | 2018-04-30 | 2022-03-15 | Amazon Technologies, Inc. | Weight loading in an array |
US10990396B2 (en) | 2018-09-27 | 2021-04-27 | Intel Corporation | Systems for performing instructions to quickly convert and use tiles as 1D vectors |
US10817042B2 (en) * | 2018-09-27 | 2020-10-27 | Intel Corporation | Power savings for neural network architecture with zero activations during inference |
US11494645B2 (en) | 2018-12-06 | 2022-11-08 | Egis Technology Inc. | Convolutional neural network processor and data processing method thereof |
TWI766193B (en) * | 2018-12-06 | 2022-06-01 | 神盾股份有限公司 | Convolutional neural network processor and data processing method thereof |
US20200210517A1 (en) | 2018-12-27 | 2020-07-02 | Intel Corporation | Systems and methods to accelerate multiplication of sparse matrices |
US11928582B1 (en) * | 2018-12-31 | 2024-03-12 | Cadence Design Systems, Inc. | System, media, and method for deep learning |
US20200226473A1 (en) | 2019-01-15 | 2020-07-16 | BigStream Solutions, Inc. | Systems, apparatus, methods, and architectures for heterogeneous precision acceleration of quantized neural networks |
CN111279364A (en) * | 2019-01-31 | 2020-06-12 | 深圳市大疆创新科技有限公司 | Convolution calculation device, convolution calculation method, convolution calculation processor and mobile equipment |
US11526737B2 (en) | 2019-02-01 | 2022-12-13 | Lightelligence, Inc. | Processing matrix operations for rate limited systems |
KR20200107295A (en) * | 2019-03-07 | 2020-09-16 | 에스케이하이닉스 주식회사 | Systolic array and processing system |
US11783176B2 (en) | 2019-03-25 | 2023-10-10 | Western Digital Technologies, Inc. | Enhanced storage device memory architecture for machine learning |
US10929058B2 (en) | 2019-03-25 | 2021-02-23 | Western Digital Technologies, Inc. | Enhanced memory device architecture for machine learning |
US10990397B2 (en) * | 2019-03-30 | 2021-04-27 | Intel Corporation | Apparatuses, methods, and systems for transpose instructions of a matrix operations accelerator |
CN112149049A (en) | 2019-06-26 | 2020-12-29 | 北京百度网讯科技有限公司 | Apparatus and method for transforming matrix, data processing system |
CN110210615A (en) * | 2019-07-08 | 2019-09-06 | 深圳芯英科技有限公司 | It is a kind of for executing the systolic arrays system of neural computing |
US11481471B2 (en) * | 2019-08-16 | 2022-10-25 | Meta Platforms, Inc. | Mapping convolution to a matrix processor unit |
US11188618B2 (en) * | 2019-09-05 | 2021-11-30 | Intel Corporation | Sparse matrix multiplication acceleration mechanism |
US11195818B2 (en) * | 2019-09-12 | 2021-12-07 | Taiwan Semiconductor Manufacturing Company, Ltd. | Backside contact for thermal displacement in a multi-wafer stacked integrated circuit |
US11842169B1 (en) | 2019-09-25 | 2023-12-12 | Amazon Technologies, Inc. | Systolic multiply delayed accumulate processor architecture |
US11409838B2 (en) | 2019-10-29 | 2022-08-09 | Meta Platforms, Inc. | High throughput matrix processor with support for concurrently processing multiple matrices |
US20210149677A1 (en) * | 2019-11-15 | 2021-05-20 | Intel Corporation | Enhanced processor functions for calculation |
US11816446B2 (en) | 2019-11-27 | 2023-11-14 | Amazon Technologies, Inc. | Systolic array component combining multiple integer and floating-point data types |
US11467806B2 (en) | 2019-11-27 | 2022-10-11 | Amazon Technologies, Inc. | Systolic array including fused multiply accumulate with efficient prenormalization and extended dynamic range |
US11809798B2 (en) | 2019-12-13 | 2023-11-07 | Intel Corporation | Implementing large multipliers in tensor arrays |
US11656872B2 (en) | 2019-12-13 | 2023-05-23 | Intel Corporation | Systems and methods for loading weights into a tensor processing block |
WO2021179224A1 (en) * | 2020-03-11 | 2021-09-16 | 深圳市大疆创新科技有限公司 | Data processing device, data processing method and accelerator |
US20210303987A1 (en) * | 2020-03-26 | 2021-09-30 | Advanced Micro Devices, Inc. | Power reduction for machine learning accelerator background |
US20210312266A1 (en) * | 2020-04-01 | 2021-10-07 | Microsoft Technology Licensing, Llc | Deep neural network accelerator with independent datapaths for simultaneous processing of different classes of operations |
US11507817B2 (en) | 2020-04-17 | 2022-11-22 | Samsung Electronics Co., Ltd. | System and method for performing computations for deep neural networks |
GB2594971B (en) * | 2020-05-13 | 2022-10-05 | Advanced Risc Mach Ltd | Variable position shift for matrix processing |
US11422773B1 (en) | 2020-06-29 | 2022-08-23 | Amazon Technologies, Inc. | Multiple busses within a systolic array processing element |
US11308027B1 (en) * | 2020-06-29 | 2022-04-19 | Amazon Technologies, Inc. | Multiple accumulate busses in a systolic array |
US11308026B1 (en) * | 2020-06-29 | 2022-04-19 | Amazon Technologies, Inc. | Multiple busses interleaved in a systolic array |
KR20220015680A (en) | 2020-07-31 | 2022-02-08 | 삼성전자주식회사 | Method and apparatus for performing deep learning operations |
JP7358312B2 (en) | 2020-08-25 | 2023-10-10 | 株式会社東芝 | Memory and neural network devices |
CN112434255B (en) * | 2020-12-03 | 2023-12-08 | 成都海光微电子技术有限公司 | Vector-matrix operation and data processing method, multiplier and processor chip |
CN112434256B (en) * | 2020-12-03 | 2022-09-13 | 海光信息技术股份有限公司 | Matrix multiplier and processor |
WO2022164652A1 (en) * | 2021-02-01 | 2022-08-04 | Microsoft Technology Licensing, Llc | Semi-programmable and reconfigurable co-accelerator for a deep neural network with normalization or non-linearity |
US11734214B2 (en) * | 2021-02-01 | 2023-08-22 | Microsoft Technology Licensing, Llc | Semi-programmable and reconfigurable co-accelerator for a deep neural network with normalization or non-linearity |
KR102597802B1 (en) * | 2021-06-11 | 2023-11-02 | 강원대학교산학협력단 | Time-division multi-channel analog matrix operator, operating method thereof, and device including the same |
US11880682B2 (en) | 2021-06-30 | 2024-01-23 | Amazon Technologies, Inc. | Systolic array with efficient input reduction and extended array performance |
CN113821701B (en) * | 2021-10-14 | 2023-09-26 | 厦门半导体工业技术研发有限公司 | Method and device for improving circuit access efficiency |
US11829321B2 (en) * | 2022-03-24 | 2023-11-28 | Google Llc | General-purpose systolic array |
WO2024025852A1 (en) * | 2022-07-27 | 2024-02-01 | Texas Instruments Incorporated | Transient current management |
CN115469826B (en) * | 2022-09-16 | 2023-04-07 | 深圳思谋信息科技有限公司 | Data processing method and device, computer equipment and computer readable storage medium |
US20240095492A1 (en) * | 2022-09-21 | 2024-03-21 | Qualcomm Incorporated | Memory management for mathematical operations in computing systems with heterogeneous memory architectures |
Family Cites Families (20)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4720780A (en) * | 1985-09-17 | 1988-01-19 | The Johns Hopkins University | Memory-linked wavefront array processor |
US5138695A (en) * | 1989-10-10 | 1992-08-11 | Hnc, Inc. | Systolic array image processing system |
US7161995B1 (en) * | 2002-03-15 | 2007-01-09 | Xilinx, Inc. | Method and apparatus for Viterbi synchronization |
US20040122887A1 (en) * | 2002-12-20 | 2004-06-24 | Macy William W. | Efficient multiplication of small matrices using SIMD registers |
US8577950B2 (en) * | 2009-08-17 | 2013-11-05 | International Business Machines Corporation | Matrix multiplication operations with data pre-conditioning in a high performance computing architecture |
US8620984B2 (en) * | 2009-11-23 | 2013-12-31 | Xilinx, Inc. | Minimum mean square error processing |
CN101968732B (en) * | 2010-10-09 | 2012-12-19 | 中国人民解放军信息工程大学 | Bit parallel systolic array shifted polynomial basis multiplier with function of error detection and construction method |
US20120254591A1 (en) * | 2011-04-01 | 2012-10-04 | Hughes Christopher J | Systems, apparatuses, and methods for stride pattern gathering of data elements and stride pattern scattering of data elements |
WO2013095504A1 (en) * | 2011-12-22 | 2013-06-27 | Intel Corporation | Matrix multiply accumulate instruction |
US8543634B1 (en) * | 2012-03-30 | 2013-09-24 | Altera Corporation | Specialized processing block for programmable integrated circuit device |
CN103246773B (en) * | 2013-05-13 | 2016-12-28 | 句容华正电气有限公司 | The low latency filter design method of sample rate conversion in electronic mutual inductor |
FR3021428B1 (en) * | 2014-05-23 | 2017-10-13 | Kalray | MULTIPLICATION OF BIT MATRICES USING EXPLICIT REGISTERS |
US10049322B2 (en) * | 2015-05-21 | 2018-08-14 | Google Llc | Prefetching weights for use in a neural network processor |
US9747546B2 (en) | 2015-05-21 | 2017-08-29 | Google Inc. | Neural network processor |
US10192162B2 (en) * | 2015-05-21 | 2019-01-29 | Google Llc | Vector computation unit in a neural network processor |
US10438117B1 (en) | 2015-05-21 | 2019-10-08 | Google Llc | Computing convolutions using a neural network processor |
US9805303B2 (en) * | 2015-05-21 | 2017-10-31 | Google Inc. | Rotating data for neural network computations |
US11244225B2 (en) * | 2015-07-10 | 2022-02-08 | Samsung Electronics Co., Ltd. | Neural network processor configurable using macro instructions |
CN109937416B (en) | 2017-05-17 | 2023-04-04 | 谷歌有限责任公司 | Low delay matrix multiplication component |
US11188814B2 (en) * | 2018-04-05 | 2021-11-30 | Arm Limited | Systolic convolutional neural network |
-
2018
- 2018-05-17 CN CN201880004328.7A patent/CN109937416B/en active Active
- 2018-05-17 EP EP20198533.0A patent/EP3800563B1/en active Active
- 2018-05-17 BR BR112019022916-7A patent/BR112019022916A2/en unknown
- 2018-05-17 CN CN201880004576.1A patent/CN109997132B/en active Active
- 2018-05-17 US US15/983,043 patent/US10635740B2/en active Active
- 2018-05-17 CN CN202310303331.1A patent/CN116414350A/en active Pending
- 2018-05-17 KR KR1020197026961A patent/KR102302608B1/en active IP Right Grant
- 2018-05-17 TW TW107116872A patent/TWI685757B/en active
- 2018-05-17 EP EP18738023.3A patent/EP3526683B1/en active Active
- 2018-05-17 WO PCT/US2018/033261 patent/WO2018213628A1/en unknown
- 2018-05-17 JP JP2019553237A patent/JP6929958B2/en active Active
- 2018-05-17 TW TW112131703A patent/TW202349233A/en unknown
- 2018-05-17 EP EP20188875.7A patent/EP3757823B1/en active Active
- 2018-05-17 EP EP18737049.9A patent/EP3500945B1/en active Active
- 2018-05-17 TW TW111127382A patent/TWI816475B/en active
- 2018-05-17 WO PCT/US2018/033270 patent/WO2018213635A1/en unknown
- 2018-05-17 US US15/983,037 patent/US10698974B2/en active Active
- 2018-05-17 BR BR112019023395-4A patent/BR112019023395B1/en active IP Right Grant
- 2018-05-17 CN CN202310556021.0A patent/CN116661732A/en active Pending
- 2018-05-17 TW TW109105071A patent/TW202024961A/en unknown
- 2018-05-17 TW TW110130201A patent/TWI771155B/en active
-
2019
- 2019-08-01 US US16/529,662 patent/US10698976B2/en active Active
-
2020
- 2020-03-26 US US16/830,894 patent/US11500961B2/en active Active
- 2020-06-29 US US16/915,286 patent/US10970362B2/en active Active
-
2021
- 2021-03-23 US US17/210,293 patent/US11599601B2/en active Active
- 2021-08-11 JP JP2021131278A patent/JP7135181B2/en active Active
-
2022
- 2022-08-31 JP JP2022138332A patent/JP7444936B2/en active Active
- 2022-11-10 US US17/985,069 patent/US20230267171A1/en active Pending
-
2023
- 2023-02-17 US US18/111,468 patent/US11907330B2/en active Active
Also Published As
Similar Documents
Publication | Publication Date | Title |
---|---|---|
CN109997132B (en) | Low-delay matrix multiplication component | |
US10831862B2 (en) | Performing matrix multiplication in hardware | |
CN110622134B (en) | Special neural network training chip | |
JP2024063060A (en) | Low Latency Matrix Multiplication Unit |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
SE01 | Entry into force of request for substantive examination |