EP2754073A1 - Exploring information by topic - Google Patents
Exploring information by topicInfo
- Publication number
- EP2754073A1 EP2754073A1 EP12770291.8A EP12770291A EP2754073A1 EP 2754073 A1 EP2754073 A1 EP 2754073A1 EP 12770291 A EP12770291 A EP 12770291A EP 2754073 A1 EP2754073 A1 EP 2754073A1
- Authority
- EP
- European Patent Office
- Prior art keywords
- threadlet
- projection
- thread
- node
- role
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Withdrawn
Links
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F3/00—Input arrangements for transferring data to be processed into a form capable of being handled by the computer; Output arrangements for transferring data from processing unit to output unit, e.g. interface arrangements
- G06F3/01—Input arrangements or combined input and output arrangements for interaction between user and computer
- G06F3/048—Interaction techniques based on graphical user interfaces [GUI]
- G06F3/0484—Interaction techniques based on graphical user interfaces [GUI] for the control of specific functions or operations, e.g. selecting or manipulating an object, an image or a displayed text element, setting a parameter value or selecting a range
- G06F3/04842—Selection of displayed objects or displayed text elements
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/95—Retrieval from the web
- G06F16/953—Querying, e.g. by the use of web search engines
- G06F16/9535—Search customisation based on user profiles and personalisation
Definitions
- This specification relates to providing information about topics.
- one innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of determining, from a user input, a topic; selecting a first node from a plurality of nodes, wherein the first node is a collection of data about the topic; providing, for display in a user interface, a first threadlet, wherein the first threadlet includes an instance of the first node and a projection menu that includes a respective link to each of one or more projections, and wherein each of the one or more projections includes one or more threadlets that are instances of nodes that share a relationship to the topic; receiving a user input selecting a particular projection from the one or more projections; and providing, for display in the user interface, a set of threadlets from the particular projection.
- inventions of this aspect include corresponding computer systems, apparatus, and computer programs recorded on one or more computer storage devices, each configured to perform the actions of the methods.
- a system of one or more computers can be configured to perform particular operations or actions by virtue of having software, firmware, hardware, or a combination of them installed on the system that in operation causes or cause the system to perform the actions.
- One or more computer programs can be configured to perform particular operations or actions by virtue of including instructions that, when executed by data processing apparatus, cause the apparatus to perform the actions.
- the topic can be an entity represented by a node in an online database of structured data, and wherein the first node includes data from the node in the online database of structured data that represents the entity.
- the method can further include updating a thread that identifies threadlets displayed to the user to include the first threadlet, wherein each threadlet in the thread is associated with data that indicates a role of the threadlet in the thread, and wherein updating the thread comprises generating data that indicates that the first threadlet in the thread has a body threadlet role.
- the method can further include in response to receiving the user input selecting the particular projection, modifying the role of the first threadlet to a tail threadlet role.
- Threadlets adjacent to each other in the thread can be displayed adjacent to each other in the user interface.
- the method can further include: determining, for each threadlet in the thread, whether to display a minimized representation or a maximized representation of the threadlet based on the role of the threadlet in the thread, comprising: determining that the first threadlet has a body threadlet role; and providing a maximized representation of the first threadlet for display in the user interface.
- the method can further include: determining that the role of the first threadlet has been modified to a tail threadlet role; and providing a minimized representation of the first threadlet for display adjacent to the set of threadlets from the particular projection.
- the method can further include: receiving a user input selecting a link to a particular projection included in a particular threadlet from the set of threadlets; updating the thread to include the particular threadlet, wherein updating the thread comprises generating data that indicates that the particular threadlet in the thread has a tail threadlet role; and providing the particular projection for display adjacent to a minimized representation of the particular threadlet in the user interface, wherein the minimized representation of the particular threadlet is displayed adjacent to the minimized representation of the first threadlet in the user interface.
- the particular projection can be a topic projection that includes only a single threadlet that includes an instance of a node that represents a particular topic.
- the method can further include: receiving a user input selecting the minimized representation of the first threadlet; and providing the maximized representation of the first threadlet for display in the user interface in place of the particular projection, the minimized representation of the particular threadlet, and the minimized representation of the first threadlet.
- FIG. 1 is a block diagram that shows an example system for processing projection requests.
- FIG. 2 is a block diagram that shows an example projection-request handler.
- FIG. 3 is a block diagram that shows an example web client.
- FIGS. 4A-4G are display diagrams that show the functionality of exploring data in terms of nodes and projections.
- FIG. 5 is a display diagram that shows an example application-launcher threadlet.
- a node is a serializable piece of data that can be interpreted and displayed in a variety of different contexts.
- a projection is an ordered collection of zero or more nodes. For instance, a video resource, defined by its uniform resource locator (URL) and optionally accompanied by additional information, e.g., the video title, is an example of a node.
- URL uniform resource locator
- additional information e.g., the video title
- a list of related videos ordered by popularity is an example of a projection.
- a semantic entity that represents Canadian actress Ellen Page may be a node.
- An example of an online database of structured data that exists is the Freebase database that is accessible on the Internet at http://www.freebase.com.
- the list of nodes that represent films, i.e., film nodes, with Ellen Page in the lead role ordered by the film title is one possible Ellen Page projection.
- the same set of film nodes but ordered by the film release date is another.
- Nodes and projections may be considered to be basic units of information used to describe various entities in terms of their intrinsic qualities and their relationships to other entities, respectively.
- Nodes and projections can also serve as basic units of navigation.
- each node When displayed, each node can lead to zero or more projections, and each projection in turn can lead to zero or more other, possibly different nodes.
- a user By following a series of nodes and projections, a user can explore the data space around a particular starting node, even if nodes and projections in question span data from multiple different sources. For example, by starting from the Ellen Page entity node in the online database of structured data and following the projection of film nodes with Ellen Page in the lead role, a user can get to the "Juno" film entity node.
- the number and order of nodes in a projection as well as their identity does not have to be fixed and can change over time.
- the underlying video stream may be replaced with a more compact version.
- the order of videos in the related-videos projection may depend on the ever-changing popularity of individual videos. Additionally, the number of videos in the same projection may change as videos are added or removed.
- nodes can be fetched and displayed in small groups, also referred to in this specification as "shards.” Generally, only one shard is displayed at a time. The number of nodes in a shard can depend on a variety of factors, e.g., the type of the projection or the size of the target display area.
- Each projection shard is loaded independently in response to a separate projection request.
- a projection request is a serializable piece of data that can be interpreted to decide what nodes must be returned as part of the shard in question.
- pre- load multiple shards for caching or other purposes. If one wants to proceed to the next, return to the previous, or jump to a different shard, they can do so by issuing another projection request, often based on additional information provided as part of the last successful projection response.
- FIG. 1 is a block diagram that shows an example system for processing projection requests.
- the system includes client computers, e.g., client computers 150 and 160, connected to server computers, e.g., server computers 110 and 120, via a computer network 140.
- Each client computer has a web client computer program, e.g., web client program 155, that is used to issue projection requests as well as to process and to visualize projection response data.
- Each server computer has a web server computer program, e.g., web server program 118, and a projection- request handler program, e.g., projection-request handler program 115, that are used to respond to incoming projection requests with projection response data.
- Each projection defines a relationship that separates nodes that are part of the projection from those that are not and organizes nodes in the relationship according to a particular principle or dimension. That is, a number of projections may return the same set of nodes ordered differently.
- related projections e.g., projections that contain the same set of nodes ordered differently, are placed into groups of projections called families. For example, three projections that represent the set of films with Ellen Page in the lead role sorted lexicographically by the film name, the name of the character played by Ellen Page, and the film release date respectively may all belong to the same family of projections.
- the information about its family relations can be used to suggest other projections to the user.
- any projection can be defined by its original projection request, it can also appear as a node in some other projection. For example, it is possible to have a projection of all projections in a particular family. As another example, it is possible to have a projection that consists of a single node that represents the projection itself.
- Each projection defines a relationship that separates nodes that are part of the projection from those that are not. It can also provide information about how different nodes in the projection relate to each other. For example, iri some implementations, nodes in the same projection are organized according to keys. Each key consists of a sequence of one or more delimiter-separated tokens called keylets, which are themselves delimiter-free. A key that can be obtained from another key by appending an instance of the delimiter string followed by a keylet is referred to as a direct child of the latter key, which in turn is referred to as the parent key or simply the parent.
- nodes are organized according to their keys, being able to organize keys in parent-child pairs makes it possible to organize nodes in parent-child pairs and from there into arbitrary tree structures. By maintaining multiple keys per node, the model can be extended to organize nodes into arbitrary acyclic directed graphs. This functionality may be useful in a variety of different situations, e.g., displaying multiple levels of references and replies to a post node in an online discussion, with child post nodes displayed at an offset relatively to their respective parent post nodes.
- the system maintains two keys per node: a forward key used to organize nodes in what is generally perceived as the forward direction and a reverse key used to organize nodes in what is generally perceived as the reverse direction. While maintaining one key per node is usually sufficient, two keys per node are sometimes required to organize nodes in complex projections with multi-keylet keys.
- the same node can appear multiple times in different projections or even as part of the same projection.
- the Ellen Page entity node may appear both in a projection of famous people born in Suite, Nova Scotia and in a projection of actors in "Juno.” If multiple instances of the same node appear in sufficiently different contexts, they may be displayed and handled differently.
- the concept of a threadlet may be introduced. A threadlet is a node instance in a particular context, with each context, and therefore each threadlet, being unique. This leads to a more constructive definition of the projection as an ordered collection of zero or more threadlets.
- threadlets act as unique labels that mark the user path through the space of nodes and projections and provide a way to unroll the path to return to some previous state.
- the path can intersect itself at many different nodes, but the sequence of threadlets that mark the path is always linear.
- This sequence of threadlets is referred to in this specification as a "thread.”
- a thread When a thread is displayed, strictly speaking, it is its threadlets and not nodes that are displayed. Two or more threadlets that refer to the same node may be displayed differently, although given that each node may appear in multiple projections, it is common for the threadlet display functionality to rely on the display functionality of the underlying node. Because of their similarity, terms “node” and “threadlet” are often used interchangeably, with “threadlet” used more often when multiple node instances are discussed in the context of the same projection or thread.
- the functionality of exploring data in terms of nodes and projections can be visualized in a variety of ways.
- One example layout displays the list of nodes visited as a stack of threadlets, starting with the first threadlet visited at the top and growing downwards as the user continues browsing from one node to another.
- Already-visited threadlets, excluding the threadlet visited last, are referred to as tail threadlets.
- the last-visited threadlet is referred to as the body threadlet.
- Each thread can have at most one body threadlet: an empty thread may have no threadlets at all or a single null threadlet that is not displayed but may play the role of the body threadlet.
- the body threadlet may also be accompanied by multiple projections of nodes "reachable" from the body threadlet, usually displayed one projection shard at a time. Threadlets that are part of one of the body threadlet projections are called head threadlets.
- the property that defines if a particular threadlet is a tail, a body, or a head threadlet is referred to as the threadlet role.
- Each live threadlet has a role, but the threadlet role can change many times during the threadlet lifetime.
- a typical thread consists of zero or more tail threadlets, at most one body threadlet, and zero or more head threadlets. If the user selects one of the head threadlets, the body threadlet becomes a tail threadlet, the head threadlet selected becomes the body threadlet, and other head threadlets at the same level are hidden from view. If the user selects one of the tail threadlets, the tail threadlet becomes the body threadlet, and the part of the thread below is truncated. The last scenario usually happens if the user wants to return to a previously-visited threadlet in the thread, possibly to follow a different path from there.
- truncated threadlets If a thread is truncated, what happens to truncated threadlets depends on the implementation. They may be permanently destroyed. Alternatively, they may be removed from the thread but kept in memory or otherwise cached in case the user decides to "undo" the action or decides to re-visit one of the underlying nodes later. As another alternative, some threadlets may be permanently erased and some preserved for future use. In some popular layouts, projection threadlets of the newly-selected body threadlet are not only preserved but are kept as head threadlets and are displayed as such.
- Each threadlet can be displayed either minimized or maximized, depending on the role it plays in the thread. For example, tail threadlets are generally displayed minimized. The body threadlet is generally displayed maximized. Head threadlets are generally displayed minimized. However, a head threadlet is often displayed maximized if it happens to be the only threadlet in a projection.
- the parameter that controls how a threadlet is displayed based on the role it plays in the thread is referred to in this specification as the threadlet type.
- Two example threadlet type values are abbreviated SLS and SIX, where S and L stand for "small” and "large,” respectively.
- the SLS value indicates that the threadlet is to be displayed as minimized when it is a tail threadlet, maximized when it is a body threadlet, and minimized when it is a head threadlet. Similarly, the SLL value indicates that the threadlet is to be displayed minimized when it is part of the thread tail and maximized otherwise.
- a threadlet may have one or more so-called shared id-s. Two threadlets with a matching shared id are recognized as two instances of the same node and are kept in sync to reflect the state of the most recently updated node. In some implementations, the system may impose restrictions on the use of shared id-s to prevent malicious projections from overriding existing nodes from other sources.
- the projection menu is a general way to display information specific to a particular threadlet.
- Each menu item in the projection menu comes accompanied by a label that helps the user recognize and select the item.
- it can either load a new projection, or display additional information, or both.
- it is possible to display an arbitrary node, either statically defined as part of the menu item definition or loaded dynamically as part of an arbitrary projection request.
- the latter functionality is especially useful, because it makes it possible to load additional node- and context-specific information on demand, only when the menu item in question is selected, as opposed to pre-loading the same information for each of what may be many nodes in a projection shard.
- the projection menu can be part of the projection response protocol and may optionally be defined for each threadlet. The type of the node in question, the node data, the type of the projection, and a variety of other factors may be used to decide on the contents of the projection menu for a threadlet.
- Node and threadlet features are used to describe node- and threadlet-specific features, respectively. Features are part of the projection response and are optional. The web client program is free to ignore any node or threadlet feature definition that it does not understand. Node features are specified as part of the node definition and apply to all the instances of the node in question if the node is shared. Threadlet features are defined as part of the threadlet definition and apply only to the threadlet in question.
- a number of services can be built on top of the general platform functionality.
- One such service allows the user to endorse an arbitrary node.
- the implementation makes it possible to classify nodes by type. For example, Ellen Page can be classified as both an actress and a music artist. Therefore, if someone adds Ellen Page to the list of nodes they endorse, it can be filed under both categories, which then makes it easy for the user to find Ellen Page both in the list of their favorite actresses and in the list of their favorite music artists.
- a projection request-response protocol for communication between the web client and the web server can be implemented in a variety of different ways.
- each projection request is encoded as a set of data fields, including the address of the destination web server, the request data, and the request type along with the request-data major and minor encoding version numbers used to interpret the request data.
- the web client program sends the request to the destination web server.
- the destination web server program receives the request and passes it to a projection-request handler program often implemented as part of the web server.
- FIG. 2 is a block diagram that shows an example projection-request handler.
- the projection-request handler can be implemented as one or more computer programs on one or more computers in one or more locations.
- the projection-request handler includes a projection- loader manager 285 and projection loaders, e.g., projection loaders 255 and 265, that are registered with the projection-loader manager.
- Each projection loader handles projection requests with a matching request type and request-data major encoding version number.
- the projection- request handler uses the projection-loader manager to forward the request to the appropriate loader based on the request type and the request-data encoding version information. If a matching loader is found, the loader interprets the request data based on rules defined as part of the loader.
- the loader Based on the interpretation of the request data, the loader makes requests to one or more server computers, e.g., server computers 210 and 220, to retrieve any projection data necessary. Once the data is retrieved, the loader uses the data to construct a projection response.
- the response includes a set of individual threadlet fields as well as up to three projection-request fields: one for the next forward shard, one for the next reverse shard, and one for the current shard, if the canonical projection request for the shard differs from the received request.
- Each individual threadlet field in the projection response is similarly encoded as a set of data fields, including the threadlet forward and reverse keys, the node data, and the node type along with the node-data major and minor encoding version numbers used to interpret the node data.
- the handler returns the response to the web server, which communicates it back to the client that initiated the inquiry.
- FIG. 3 is a block diagram that shows an example web client.
- the web client can be implemented as one or more computer programs on one or more computers in one or more locations.
- the web client includes a node-factory manager 345, a thread-state manager 355, a thread-layout manager 365, and node factories and thread layouts, e.g., node factories 315 and 325 and thread layouts 375 and 385.
- Each node factory is registered with the node-factory manager and is capable of instantiating nodes with a matching node type and node-data major encoding version number.
- Each thread layout is registered with the thread-layout manager.
- the web client For each threadlet in the projection response, the web client uses the node- factory manager and a matching node factory to instantiate the threadlet node, followed by the threadlet itself. Once instantiated, the threadlet node is equipped with display functionality to display itself either as minimized or maximized. The threadlet maintains a reference to its node and, depending on the threadlet type and role in the thread, can display itself either as minimized or maximized, relying on the display functionality of the underlying node.
- the thread-state manager is notified and the state of the thread is updated to include the new shard and its threadlets. It is the thread-state manager that is responsible for updating roles of individual threadlets in the thread. Once the state of the thread is updated, the web client uses the thread-layout manager to locate the currently- active thread layout and uses the layout to visualize the thread in its new state.
- Nodes and projections can be used to describe and to visualize arbitrary data.
- the system is especially powerful when used to explore entities from different data sources and connections between them. For example, using the earlier book example, one may endorse or share a book on a social network, look up the author of the book using an Internet search engine, find an image of the book cover using an image search engine, and explore similar books on an online retailer. By resolving different instances of the same book entity across a number of services to a single well-defined entity, one can display more information about the entity in one place and also use the resolved entity to establish connections between other related entities.
- entities are resolved by taking advantage of the semantic data available as part of an online database of structured data.
- a large number of well-defined entities may be classified by type and expressed in terms of their relationships to other entities as well as identifiers from various authoritative sources.
- This data in the online database can be thought of as a large graph with entities (nodes) connected by relationships (projections) and can provide a way for "stitching" various data sets. For example, if two book entities, one on a social network and one on an online retailer, map to the same resolved entity in the online database of structured data, they can be treated as two different instances of the same entity as opposed to two different entities.
- FIGS. 4A-4G are display diagrams that show the functionality of exploring data in terms of nodes and projections, visualized using a thread layout that displays a thread as a stack of threadlets, starting with the first threadlet visited at the top and growing downwards as the user continues browsing from one node to another.
- FIG. 4A shows the thread in its initial state, instantiated with a threadlet 410.
- Threadlet 410 is a threadlet with a topic-search node 411 that the user can use , to search for a variety of topics of interest.
- the topic-search node provides a list of popular- topic projection links, e.g., projection links 415 and 416. The user can load a topic of interest as a threadlet in a topic projection either by typing the name of the topic inside the search box or by selecting one of the popular-topic projection links.
- threadlet 410 loads threadlet 420 as part of a one-threadlet topic projection, as shown in FIG. 4B.
- threadlet 420 would normally become a head threadlet in the thread and be displayed minimized.
- the projection request-response protocol may provide a way to override the default behavior, and, as the only threadlet in a topic projection, threadlet 420 is loaded as the body threadlet and is displayed maximized. Threadlet 410, in turn, changes its role to a tail threadlet.
- Threadlet 420 is displayed as a combination of an "Ellen Page" topic node 421 and a projection menu 422 immediately below the topic node.
- the projection menu includes menu items, e.g., menu items 423 and 424.
- Menu item 423 is a topic-summary item selected by default and displayed as a topic-summary node, with a list of projection links, e.g., projection links 425 and 426, that the user can use to explore additional information about Ellen Page in terms of nodes and projections.
- threadlet 420 loads a projection of topic threadlets that correspond to various film performances by Ellen Page. Because the number of threadlets in the projection is large, they are displayed as minimized head threadlets in shards of five threadlets at a time.
- FIG. 4C shows the first shard of five film- performance threadlets, e.g., threadlets 440 and 445, displayed in a vertical list below a navigational menu 430 that provides a way to navigate between multiple shards in the same projection if there is more than one. The navigational menu is displayed below topic threadlet 420.
- the thread layout automatically re-aligns the viewport to show the most recently loaded threadlets or any other part of the thread considered important.
- the user can also navigate to any part of the thread by scrolling or using keyboard shortcuts.
- Other techniques for navigating between shards in a projection or through a thread are possible.
- a user may navigate between shards or through the thread using, e.g., touch inputs on a touchscreen device, voice inputs, a motion input using a motion sensing device, and so on.
- the next five film-performance head threadlets e.g., threadlets 450 and 455
- the next five film-performance head threadlets are displayed minimized in a vertical list below the navigational menu, replacing film-performance threadlets of the previous shard, as shown in FIG. 4D.
- the user can further explore information about any particular film performance by selecting and maximizing the threadlet in question.
- the user can select one of the projection links displayed as part of the threadlet, in which case the threadlet is automatically made the body threadlet and displayed maximized before the link projection is loaded.
- threadlet 450 becomes the body threadlet and loads threadlet 460 as part of a topic projection, as shown in FIG. 4E.
- threadlet 460 becomes the body threadlet in the thread of four threadlets, with threadlets 410, 420, and 450 as tail threadlets.
- threadlet 460 is displayed as a combination of a "Juno" topic node 461 and a projection menu 462 immediately below the topic node.
- the projection menu includes menu items, e.g., menu items 465 and 466, with the topic-summary item selected by default.
- the menu changes to display a video-search node 467 associated with the menu item, instead of the topic-summary node associated .with the previous menu selection, as shown in FIG. 4F.
- the video-search node is displayed with a selection of two search engines and a search box 468 pre-populated with a search query "Juno film” based on the name of the context topic and automatically disambiguated to distinguish between a variety of topics named "Juno".
- the user may change the search query by typing inside the search box. If that happens, the query is logged in the context of threadlet 460 and can later be used as a search-suggestion within the same or similar contexts.
- menu item 466 When menu item 466 is selected, it also instructs threadlet 460 to load a projection of video search results, using the pre-populated query. Depending on the search-engine selection, a different video search-results projection is loaded.
- the search-results projection shown in FIG. 4F is an SLL projection that displays video search results one results-page threadlet at a time, e.g., threadlet 470, with individual search results displayed as thumbnails, e.g., thumbnails 475 and 476.
- the user can navigate between multiple shards in the projection, and therefore between multiple pages of search results, by using the navigational menu.
- threadlet 470 loads a one- threadlet video projection with threadlet 480 as the only threadlet, as shown in FIG. 4G.
- Threadlet 480 is displayed as a combination of a video node 481 and a menu 482. Because the nature of threadlet 480 is different from that of topic threadlets considered earlier, menu 482 includes a different list of menu items and does not have a menu item selected by default. The user can use different menu items to continue exploring the data space around threadlet 480 or scroll up to one of the previously loaded threadlets in the thread and continue exploring from there.
- projections are not limited to the default set of projections implemented as part of the system.
- the projection request-response protocol may be general and may be designed to make it simple for anyone with basic development skills to implement a so-called third-party projection.
- a third-party projection may choose to target only a particular node or a collection of nodes of a particular type or some combination of types. This is especially applicable to entity nodes, e.g., entity nodes from the online database of structured data, which, in addition to sharing the same topic node type, are classified in terms of entity types in the online database.
- third-party projections can provide arbitrary application-like functionality, they are also often referred to as applications.
- the user can explore the list of projections that target the node, possibly with projection labels accompanied by user ratings and other helpful information.
- the user can select and load any projection they like.
- a third-party projection gets selected, the target node data is sent to the third-party projection web server as part of the projection request. Because any node of a particular type and encoding version has well-defined encoding and data format, any node can be used for projection targeting.
- the projection web server examines the request along with the embedded node information and generates a response.
- third-party projection requests may be routed via a trusted web server before forwarding them to their respective destination web servers.
- the trusted server can be used to verify the destination web server credentials and possibly "disconnect" malicious third-party servers from the rest of the system.
- a simple weather-forecast projection is one example of a third-party projection. If a projection developer has access to weather-forecast data, say, in the US, they can target their projection to entity nodes that are geographical locations in the US. Then, every time their projection gets selected, a node that represents a geographical location in the US is sent to the projection web server as part of a projection request. Because the developer knows what kind of nodes the weather-forecast projection can target, they can correctly interpret the entity node data in the request, retrieve geographical coordinates of the location in question, use the coordinates to lookup weather-forecast data, and send back a projection response with, e.g., five different nodes, one for each day of the forecast.
- third-party projections are supported and developer tools to hel with projection development and debugging are provided.
- each topic threadlet can be equipped with a projection-menu item labeled "App developer” that loads a special application-launcher proj ection.
- FIG. 5 is a display diagram that shows an example application-launcher threadlet 520.
- the application launcher provides the developer with a way to examine and possibly edit target- topic node data 528 to be sent as part of a third-party projection request of type 523 to the destination projection web server of the developer choice, e.g., web server 524.
- each node type and encoding of the node data for that type and version are well-defined, using nodes for targeting and discoverability of projections provides a number of unique advantages not available anywhere else on the web. Because each projection is likely to target only a subset of nodes, it will appear to the user only for those nodes that it can handle. As a result, at any moment during their browsing experience, the user is exposed only to the projection data that they may actually be interested in.
- the projection web server gets access to the target node and possibly other data sent as part of the projection request, that is, the context and the input data that the server may require to generate a proper projection response, often without any additional involvement from the user.
- the weather-forecast projection described earlier should be able to display weather information for a location entity node solely based on the geographical coordinates retrieved from the projection request. Unlike a typical weather-forecast site, it would not need to request the user to provide the name or other information, e.g., the location ZIP code, to uniquely identify the location in question.
- projections from the same and even different third-parties can be bundled together to form an "application group" - a collection of projections generally installed together. This can serve as a convenience feature or sometimes be necessary to provide the user with the best user experience, if two or more projections are designed to work together.
- Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, in tangibly-embodied computer software or firmware, in computer hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them.
- Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions encoded on a tangible non-transitory program carrier for execution by, or to control the operation of, data processing apparatus.
- the program instructions can be encoded on an artificially-generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus.
- the computer storage medium can be a machine-readable storage device, a machine-readable storage substrate, a random or serial access memory device, or a combination of one or more of them.
- data processing apparatus refers to data processing hardware and encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers.
- the apparatus can also be or further include special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
- the apparatus can optionally include, in addition to hardware, code that creates an execution environment for computer programs, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them.
- a computer program (which may also be referred to or described as a program, software, a software application, a module, a software module, a script, or code) can be written in any form of programming language, including compiled or interpreted languages, or declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment.
- a computer program may, but need not, correspond to a file in a file system.
- a program can be stored in a portion of a file that holds other programs or data, e.g., one or more scripts stored in a markup language document, in a single file dedicated to the program in question, or in multiple coordinated files, e.g., files that store one or more modules, sub-programs, or portions of code.
- a computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
- the processes and logic flows described in this specification can be performed by one or more programmable computers executing one or more computer programs to perform functions by operating on input data and generating output.
- the processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
- special purpose logic circuitry e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
- Computers suitable for the execution of a computer program include, by way of example, can be based on general or special purpose microprocessors or both, or any other kind of central processing unit.
- a central processing unit will receive instructions and data from a read-only memory or a random access memory or both.
- the essential elements of a computer are a central processing unit for performing or executing instructions and one or more memory devices for storing instructions and data.
- a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks.
- mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks.
- a computer need not have such devices.
- a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device, e.g., a universal serial bus (USB) flash drive, to name just a few.
- PDA personal digital assistant
- GPS Global Positioning System
- USB universal serial bus
- Computer-readable media suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks.
- semiconductor memory devices e.g., EPROM, EEPROM, and flash memory devices
- magnetic disks e.g., internal hard disks or removable disks
- magneto-optical disks e.g., CD-ROM and DVD-ROM disks.
- the processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
- a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer.
- a display device e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor
- keyboard and a pointing device e.g., a mouse or a trackball
- Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.
- a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a
- Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back-end, middleware, or front-end components.
- the components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), e.g., the Internet.
- LAN local area network
- WAN wide area network
- the computing system can include clients and servers.
- a client and server are generally remote from each other and typically interact through a communication network.
- the relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other. While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any invention or of what may be claimed, but rather as descriptions of features that may be specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination.
Abstract
Methods, systems, and apparatus, including computer programs encoded on computer storage media, for exploring information by topic. One of the methods includes determining, from a user input, a topic; selecting a first node from a plurality of nodes, wherein the first node is a collection of data about the topic; providing, for display in a user interface, a first threadlet, wherein the first threadlet includes an instance of the first node and a projection menu that includes a respective link to each of one or more projections, and wherein each of the one or more projections includes one or more threadlets that are instances of nodes that share a relationship to the topic; receiving a user input selecting a particular projection from the one or more projections; and providing, for display in the user interface, a set of threadlets from the particular projection.
Description
EXPLORING INFORMATION BY TOPIC
BACKGROUND
This specification relates to providing information about topics.
While the Internet has experienced explosive growth, the basic way we browse information online has remained largely unchanged. In particular, the web is still a predominantly page and site-centric environment with information about the same topic often scattered across a large number of different websites.
SUMMARY
In general, one innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of determining, from a user input, a topic; selecting a first node from a plurality of nodes, wherein the first node is a collection of data about the topic; providing, for display in a user interface, a first threadlet, wherein the first threadlet includes an instance of the first node and a projection menu that includes a respective link to each of one or more projections, and wherein each of the one or more projections includes one or more threadlets that are instances of nodes that share a relationship to the topic; receiving a user input selecting a particular projection from the one or more projections; and providing, for display in the user interface, a set of threadlets from the particular projection.
Other embodiments of this aspect include corresponding computer systems, apparatus, and computer programs recorded on one or more computer storage devices, each configured to perform the actions of the methods. A system of one or more computers can be configured to perform particular operations or actions by virtue of having software, firmware, hardware, or a combination of them installed on the system that in operation causes or cause the system to perform the actions. One or more computer programs can be configured to perform particular operations or actions by virtue of including instructions that, when executed by data processing apparatus, cause the apparatus to perform the actions.
These and other embodiments can optionally include one or more of the following features. The topic can be an entity represented by a node in an online database of structured data, and wherein the first node includes data from the node in the online database of structured data that represents the entity. The method can further include updating a thread that identifies threadlets displayed to the user to include the first threadlet, wherein each threadlet in the thread
is associated with data that indicates a role of the threadlet in the thread, and wherein updating the thread comprises generating data that indicates that the first threadlet in the thread has a body threadlet role. The method can further include in response to receiving the user input selecting the particular projection, modifying the role of the first threadlet to a tail threadlet role. Threadlets adjacent to each other in the thread can be displayed adjacent to each other in the user interface. The method can further include: determining, for each threadlet in the thread, whether to display a minimized representation or a maximized representation of the threadlet based on the role of the threadlet in the thread, comprising: determining that the first threadlet has a body threadlet role; and providing a maximized representation of the first threadlet for display in the user interface. The method can further include: determining that the role of the first threadlet has been modified to a tail threadlet role; and providing a minimized representation of the first threadlet for display adjacent to the set of threadlets from the particular projection. The method can further include: receiving a user input selecting a link to a particular projection included in a particular threadlet from the set of threadlets; updating the thread to include the particular threadlet, wherein updating the thread comprises generating data that indicates that the particular threadlet in the thread has a tail threadlet role; and providing the particular projection for display adjacent to a minimized representation of the particular threadlet in the user interface, wherein the minimized representation of the particular threadlet is displayed adjacent to the minimized representation of the first threadlet in the user interface. The particular projection can be a topic projection that includes only a single threadlet that includes an instance of a node that represents a particular topic. The method can further include: receiving a user input selecting the minimized representation of the first threadlet; and providing the maximized representation of the first threadlet for display in the user interface in place of the particular projection, the minimized representation of the particular threadlet, and the minimized representation of the first threadlet.
Particular embodiments of the subject matter described in this specification can be implemented so as to realize one or more of the following advantages. Information can be organized and explored by topic. A variety of data from any number of sources can be provided to users in one place. By following a link to a projection, a user can explore information about any number of nodes and can understand the additional semantic meaning carried by the projection.
The details of one or more embodiments of the subject matter of this specification are set forth in the accompanying drawings and the description below. Other features, aspects, and
advantages of the subject matter will become apparent from the description, the drawings, and the claims.
BRIEF DESCRIPTION OF THE DRAWINGS FIG. 1 is a block diagram that shows an example system for processing projection requests.
FIG. 2 is a block diagram that shows an example projection-request handler.
FIG. 3 is a block diagram that shows an example web client.
FIGS. 4A-4G are display diagrams that show the functionality of exploring data in terms of nodes and projections.
FIG. 5 is a display diagram that shows an example application-launcher threadlet.
Like reference numbers and designations in the various drawings indicate like elements.
DETAILED DESCRIPTION
Generally, this specification describes systems where data from multiple sources can be represented and displayed in terms of nodes and relationships between nodes, also known as projections. A node is a serializable piece of data that can be interpreted and displayed in a variety of different contexts. A projection is an ordered collection of zero or more nodes. For instance, a video resource, defined by its uniform resource locator (URL) and optionally accompanied by additional information, e.g., the video title, is an example of a node. A list of related videos ordered by popularity is an example of a projection. Similarly, in an online database of structured data, a semantic entity that represents Canadian actress Ellen Page may be a node. An example of an online database of structured data that exists is the Freebase database that is accessible on the Internet at http://www.freebase.com. The list of nodes that represent films, i.e., film nodes, with Ellen Page in the lead role ordered by the film title is one possible Ellen Page projection. The same set of film nodes but ordered by the film release date is another.
Nodes and projections may be considered to be basic units of information used to describe various entities in terms of their intrinsic qualities and their relationships to other entities, respectively. Nodes and projections can also serve as basic units of navigation. When displayed, each node can lead to zero or more projections, and each projection in turn can lead to zero or more other, possibly different nodes. By following a series of nodes and projections, a user can explore the data space around a particular starting node, even if nodes and projections in question span data from multiple different sources. For example, by starting from the Ellen Page entity
node in the online database of structured data and following the projection of film nodes with Ellen Page in the lead role, a user can get to the "Juno" film entity node. From there, by following a projection of "Juno" soundtrack clips on a video hosting website, one can proceed to an "All I Want Is You" soundtrack video. By following a projection that identifies users of an online social network who liked the video, one can find their way to the user of the social network who was the first to like that video, and so on.
The number and order of nodes in a projection as well as their identity does not have to be fixed and can change over time. In the video example above, the underlying video stream may be replaced with a more compact version. Similarly, the order of videos in the related-videos projection may depend on the ever-changing popularity of individual videos. Additionally, the number of videos in the same projection may change as videos are added or removed.
Because the number of nodes in a projection can be large, nodes can be fetched and displayed in small groups, also referred to in this specification as "shards." Generally, only one shard is displayed at a time. The number of nodes in a shard can depend on a variety of factors, e.g., the type of the projection or the size of the target display area. Each projection shard is loaded independently in response to a separate projection request. A projection request is a serializable piece of data that can be interpreted to decide what nodes must be returned as part of the shard in question. Those skilled in the art will recognize that it is also possible to (pre-) load multiple shards for caching or other purposes. If one wants to proceed to the next, return to the previous, or jump to a different shard, they can do so by issuing another projection request, often based on additional information provided as part of the last successful projection response.
FIG. 1 is a block diagram that shows an example system for processing projection requests. The system includes client computers, e.g., client computers 150 and 160, connected to server computers, e.g., server computers 110 and 120, via a computer network 140. Each client computer has a web client computer program, e.g., web client program 155, that is used to issue projection requests as well as to process and to visualize projection response data. Each server computer has a web server computer program, e.g., web server program 118, and a projection- request handler program, e.g., projection-request handler program 115, that are used to respond to incoming projection requests with projection response data.
Each projection defines a relationship that separates nodes that are part of the projection from those that are not and organizes nodes in the relationship according to a particular principle or dimension. That is, a number of projections may return the same set of nodes ordered
differently. In some implementations, related projections, e.g., projections that contain the same set of nodes ordered differently, are placed into groups of projections called families. For example, three projections that represent the set of films with Ellen Page in the lead role sorted lexicographically by the film name, the name of the character played by Ellen Page, and the film release date respectively may all belong to the same family of projections. When a particular projection is displayed, the information about its family relations can be used to suggest other projections to the user. Because any projection can be defined by its original projection request, it can also appear as a node in some other projection. For example, it is possible to have a projection of all projections in a particular family. As another example, it is possible to have a projection that consists of a single node that represents the projection itself.
Each projection defines a relationship that separates nodes that are part of the projection from those that are not. It can also provide information about how different nodes in the projection relate to each other. For example, iri some implementations, nodes in the same projection are organized according to keys. Each key consists of a sequence of one or more delimiter-separated tokens called keylets, which are themselves delimiter-free. A key that can be obtained from another key by appending an instance of the delimiter string followed by a keylet is referred to as a direct child of the latter key, which in turn is referred to as the parent key or simply the parent. Because nodes are organized according to their keys, being able to organize keys in parent-child pairs makes it possible to organize nodes in parent-child pairs and from there into arbitrary tree structures. By maintaining multiple keys per node, the model can be extended to organize nodes into arbitrary acyclic directed graphs. This functionality may be useful in a variety of different situations, e.g., displaying multiple levels of references and replies to a post node in an online discussion, with child post nodes displayed at an offset relatively to their respective parent post nodes.
In some implementations, the system maintains two keys per node: a forward key used to organize nodes in what is generally perceived as the forward direction and a reverse key used to organize nodes in what is generally perceived as the reverse direction. While maintaining one key per node is usually sufficient, two keys per node are sometimes required to organize nodes in complex projections with multi-keylet keys.
The same node can appear multiple times in different projections or even as part of the same projection. For example, the Ellen Page entity node may appear both in a projection of famous people born in Halifax, Nova Scotia and in a projection of actors in "Juno." If multiple
instances of the same node appear in sufficiently different contexts, they may be displayed and handled differently. To distinguish between multiple instances of the same node, the concept of a threadlet may be introduced. A threadlet is a node instance in a particular context, with each context, and therefore each threadlet, being unique. This leads to a more constructive definition of the projection as an ordered collection of zero or more threadlets.
As the user browses from one node to another, threadlets act as unique labels that mark the user path through the space of nodes and projections and provide a way to unroll the path to return to some previous state. The path can intersect itself at many different nodes, but the sequence of threadlets that mark the path is always linear. This sequence of threadlets is referred to in this specification as a "thread." When a thread is displayed, strictly speaking, it is its threadlets and not nodes that are displayed. Two or more threadlets that refer to the same node may be displayed differently, although given that each node may appear in multiple projections, it is common for the threadlet display functionality to rely on the display functionality of the underlying node. Because of their similarity, terms "node" and "threadlet" are often used interchangeably, with "threadlet" used more often when multiple node instances are discussed in the context of the same projection or thread.
The functionality of exploring data in terms of nodes and projections can be visualized in a variety of ways. One example layout displays the list of nodes visited as a stack of threadlets, starting with the first threadlet visited at the top and growing downwards as the user continues browsing from one node to another. Already-visited threadlets, excluding the threadlet visited last, are referred to as tail threadlets. The last-visited threadlet is referred to as the body threadlet. Each thread can have at most one body threadlet: an empty thread may have no threadlets at all or a single null threadlet that is not displayed but may play the role of the body threadlet. The body threadlet may also be accompanied by multiple projections of nodes "reachable" from the body threadlet, usually displayed one projection shard at a time. Threadlets that are part of one of the body threadlet projections are called head threadlets. The property that defines if a particular threadlet is a tail, a body, or a head threadlet is referred to as the threadlet role. Each live threadlet has a role, but the threadlet role can change many times during the threadlet lifetime. Those skilled in the art will recognize that the number and kind of different roles does not have to be limited to tail, body, and head roles.
A typical thread consists of zero or more tail threadlets, at most one body threadlet, and zero or more head threadlets. If the user selects one of the head threadlets, the body threadlet
becomes a tail threadlet, the head threadlet selected becomes the body threadlet, and other head threadlets at the same level are hidden from view. If the user selects one of the tail threadlets, the tail threadlet becomes the body threadlet, and the part of the thread below is truncated. The last scenario usually happens if the user wants to return to a previously-visited threadlet in the thread, possibly to follow a different path from there.
If a thread is truncated, what happens to truncated threadlets depends on the implementation. They may be permanently destroyed. Alternatively, they may be removed from the thread but kept in memory or otherwise cached in case the user decides to "undo" the action or decides to re-visit one of the underlying nodes later. As another alternative, some threadlets may be permanently erased and some preserved for future use. In some popular layouts, projection threadlets of the newly-selected body threadlet are not only preserved but are kept as head threadlets and are displayed as such.
Each threadlet can be displayed either minimized or maximized, depending on the role it plays in the thread. For example, tail threadlets are generally displayed minimized. The body threadlet is generally displayed maximized. Head threadlets are generally displayed minimized. However, a head threadlet is often displayed maximized if it happens to be the only threadlet in a projection. The parameter that controls how a threadlet is displayed based on the role it plays in the thread is referred to in this specification as the threadlet type. Two example threadlet type values are abbreviated SLS and SIX, where S and L stand for "small" and "large," respectively. The SLS value indicates that the threadlet is to be displayed as minimized when it is a tail threadlet, maximized when it is a body threadlet, and minimized when it is a head threadlet. Similarly, the SLL value indicates that the threadlet is to be displayed minimized when it is part of the thread tail and maximized otherwise.
Because a node can change with time, it is possible to encounter multiple versions of the same node of different freshness. From the user perspective, multiple instances of the same node are expected to be in sync to reflect the state of the most recently updated instance. However, this raises the question of the node identity - that is, what nodes must in fact be considered different instances of the same node. Simply comparing nodes based on their contents is not an option as no newly-updated version of the node would match an old one. To address the issue, a threadlet may have one or more so-called shared id-s. Two threadlets with a matching shared id are recognized as two instances of the same node and are kept in sync to reflect the state of the most
recently updated node. In some implementations, the system may impose restrictions on the use of shared id-s to prevent malicious projections from overriding existing nodes from other sources.
It is possible to display two or more threadlets differently in different contexts, even if they refer to the same node. For example, this functionality may be achieved by using the concept of a projection menu as well as so-called node and threadlet features. The projection menu is a general way to display information specific to a particular threadlet. Each menu item in the projection menu comes accompanied by a label that helps the user recognize and select the item. Depending on the nature of the menu item in question, once selected, it can either load a new projection, or display additional information, or both. In particular, as part of a menu item selection, in some implementations, it is possible to display an arbitrary node, either statically defined as part of the menu item definition or loaded dynamically as part of an arbitrary projection request. The latter functionality is especially useful, because it makes it possible to load additional node- and context-specific information on demand, only when the menu item in question is selected, as opposed to pre-loading the same information for each of what may be many nodes in a projection shard. The projection menu can be part of the projection response protocol and may optionally be defined for each threadlet. The type of the node in question, the node data, the type of the projection, and a variety of other factors may be used to decide on the contents of the projection menu for a threadlet.
Node and threadlet features are used to describe node- and threadlet-specific features, respectively. Features are part of the projection response and are optional. The web client program is free to ignore any node or threadlet feature definition that it does not understand. Node features are specified as part of the node definition and apply to all the instances of the node in question if the node is shared. Threadlet features are defined as part of the threadlet definition and apply only to the threadlet in question.
Features are used to provide arbitrary node- and threadlet-~specific functionality that cannot be provided using other mechanisms, e.g., the projection menu. For example, in some implementations, a number of services can be built on top of the general platform functionality. One such service allows the user to endorse an arbitrary node. For nodes that come accompanied with additional type information expressed as a node feature, the implementation makes it possible to classify nodes by type. For example, Ellen Page can be classified as both an actress and a music artist. Therefore, if someone adds Ellen Page to the list of nodes they endorse, it can
be filed under both categories, which then makes it easy for the user to find Ellen Page both in the list of their favorite actresses and in the list of their favorite music artists.
A projection request-response protocol for communication between the web client and the web server can be implemented in a variety of different ways. In some implementations, each projection request is encoded as a set of data fields, including the address of the destination web server, the request data, and the request type along with the request-data major and minor encoding version numbers used to interpret the request data. To load a projection shard as defined by its projection request, the web client program sends the request to the destination web server. The destination web server program receives the request and passes it to a projection-request handler program often implemented as part of the web server.
FIG. 2 is a block diagram that shows an example projection-request handler. The projection-request handler can be implemented as one or more computer programs on one or more computers in one or more locations. The projection-request handler includes a projection- loader manager 285 and projection loaders, e.g., projection loaders 255 and 265, that are registered with the projection-loader manager. Each projection loader handles projection requests with a matching request type and request-data major encoding version number. The projection- request handler uses the projection-loader manager to forward the request to the appropriate loader based on the request type and the request-data encoding version information. If a matching loader is found, the loader interprets the request data based on rules defined as part of the loader. Based on the interpretation of the request data, the loader makes requests to one or more server computers, e.g., server computers 210 and 220, to retrieve any projection data necessary. Once the data is retrieved, the loader uses the data to construct a projection response. The response includes a set of individual threadlet fields as well as up to three projection-request fields: one for the next forward shard, one for the next reverse shard, and one for the current shard, if the canonical projection request for the shard differs from the received request. Each individual threadlet field in the projection response is similarly encoded as a set of data fields, including the threadlet forward and reverse keys, the node data, and the node type along with the node-data major and minor encoding version numbers used to interpret the node data. The handler returns the response to the web server, which communicates it back to the client that initiated the inquiry.
FIG. 3 is a block diagram that shows an example web client. The web client can be implemented as one or more computer programs on one or more computers in one or more locations. The web client includes a node-factory manager 345, a thread-state manager 355, a
thread-layout manager 365, and node factories and thread layouts, e.g., node factories 315 and 325 and thread layouts 375 and 385. Each node factory is registered with the node-factory manager and is capable of instantiating nodes with a matching node type and node-data major encoding version number. Each thread layout is registered with the thread-layout manager.
For each threadlet in the projection response, the web client uses the node- factory manager and a matching node factory to instantiate the threadlet node, followed by the threadlet itself. Once instantiated, the threadlet node is equipped with display functionality to display itself either as minimized or maximized. The threadlet maintains a reference to its node and, depending on the threadlet type and role in the thread, can display itself either as minimized or maximized, relying on the display functionality of the underlying node. Once all threadlets in the projection shard are instantiated, the thread-state manager is notified and the state of the thread is updated to include the new shard and its threadlets. It is the thread-state manager that is responsible for updating roles of individual threadlets in the thread. Once the state of the thread is updated, the web client uses the thread-layout manager to locate the currently- active thread layout and uses the layout to visualize the thread in its new state.
Nodes and projections can be used to describe and to visualize arbitrary data. The system, however, is especially powerful when used to explore entities from different data sources and connections between them. For example, using the earlier book example, one may endorse or share a book on a social network, look up the author of the book using an Internet search engine, find an image of the book cover using an image search engine, and explore similar books on an online retailer. By resolving different instances of the same book entity across a number of services to a single well-defined entity, one can display more information about the entity in one place and also use the resolved entity to establish connections between other related entities.
In some implementations, entities are resolved by taking advantage of the semantic data available as part of an online database of structured data. In the online database of structured data, a large number of well-defined entities may be classified by type and expressed in terms of their relationships to other entities as well as identifiers from various authoritative sources. This data in the online database can be thought of as a large graph with entities (nodes) connected by relationships (projections) and can provide a way for "stitching" various data sets. For example, if two book entities, one on a social network and one on an online retailer, map to the same resolved entity in the online database of structured data, they can be treated as two different instances of the same entity as opposed to two different entities. This makes it possible to display
both social network and online retailer projections for the resolved entity and possibly to build new projections between other related social network and online retailer entities. That is, the book entity from the online database of structured data becomes the common node and a bridge between two separate data sets, something that may be used in some implementations to provide the user with a transparent mechanism for exploring information from multiple sources in one place. ·
FIGS. 4A-4G are display diagrams that show the functionality of exploring data in terms of nodes and projections, visualized using a thread layout that displays a thread as a stack of threadlets, starting with the first threadlet visited at the top and growing downwards as the user continues browsing from one node to another.
FIG. 4A shows the thread in its initial state, instantiated with a threadlet 410. Threadlet 410 is a threadlet with a topic-search node 411 that the user can use, to search for a variety of topics of interest. In addition to a search box 412, the topic-search node provides a list of popular- topic projection links, e.g., projection links 415 and 416. The user can load a topic of interest as a threadlet in a topic projection either by typing the name of the topic inside the search box or by selecting one of the popular-topic projection links.
When the user inputs "Ellen Page" as the topic of interest, threadlet 410 loads threadlet 420 as part of a one-threadlet topic projection, as shown in FIG. 4B. As a threadlet in a newly- loaded SLS projection, threadlet 420 would normally become a head threadlet in the thread and be displayed minimized. However, the projection request-response protocol may provide a way to override the default behavior, and, as the only threadlet in a topic projection, threadlet 420 is loaded as the body threadlet and is displayed maximized. Threadlet 410, in turn, changes its role to a tail threadlet.
Threadlet 420 is displayed as a combination of an "Ellen Page" topic node 421 and a projection menu 422 immediately below the topic node. The projection menu includes menu items, e.g., menu items 423 and 424. Menu item 423 is a topic-summary item selected by default and displayed as a topic-summary node, with a list of projection links, e.g., projection links 425 and 426, that the user can use to explore additional information about Ellen Page in terms of nodes and projections.
When the user selects projection link 425 labeled "Film performances", threadlet 420 loads a projection of topic threadlets that correspond to various film performances by Ellen Page. Because the number of threadlets in the projection is large, they are displayed as minimized head
threadlets in shards of five threadlets at a time. FIG. 4C shows the first shard of five film- performance threadlets, e.g., threadlets 440 and 445, displayed in a vertical list below a navigational menu 430 that provides a way to navigate between multiple shards in the same projection if there is more than one. The navigational menu is displayed below topic threadlet 420. As the number of threadlets in the thread grows and becomes too large for all of them to be displayed in sufficient detail, the thread layout automatically re-aligns the viewport to show the most recently loaded threadlets or any other part of the thread considered important. The user can also navigate to any part of the thread by scrolling or using keyboard shortcuts. Other techniques for navigating between shards in a projection or through a thread are possible. For example, in some implementations, a user may navigate between shards or through the thread using, e.g., touch inputs on a touchscreen device, voice inputs, a motion input using a motion sensing device, and so on.
When the user navigates to the next shard, the next five film-performance head threadlets, e.g., threadlets 450 and 455, are displayed minimized in a vertical list below the navigational menu, replacing film-performance threadlets of the previous shard, as shown in FIG. 4D. The user can further explore information about any particular film performance by selecting and maximizing the threadlet in question. Alternatively, the user can select one of the projection links displayed as part of the threadlet, in which case the threadlet is automatically made the body threadlet and displayed maximized before the link projection is loaded.
When the user selects projection link 451 labeled "Juno", threadlet 450 becomes the body threadlet and loads threadlet 460 as part of a topic projection, as shown in FIG. 4E. As the only threadlet in a topic projection, threadlet 460 becomes the body threadlet in the thread of four threadlets, with threadlets 410, 420, and 450 as tail threadlets. Similarly to threadlet 420, threadlet 460 is displayed as a combination of a "Juno" topic node 461 and a projection menu 462 immediately below the topic node. The projection menu includes menu items, e.g., menu items 465 and 466, with the topic-summary item selected by default.
When the user selects menu item 466 labeled "Videos", the menu changes to display a video-search node 467 associated with the menu item, instead of the topic-summary node associated .with the previous menu selection, as shown in FIG. 4F. The video-search node is displayed with a selection of two search engines and a search box 468 pre-populated with a search query "Juno film" based on the name of the context topic and automatically disambiguated to distinguish between a variety of topics named "Juno". The user may change the search query
by typing inside the search box. If that happens, the query is logged in the context of threadlet 460 and can later be used as a search-suggestion within the same or similar contexts.
When menu item 466 is selected, it also instructs threadlet 460 to load a projection of video search results, using the pre-populated query. Depending on the search-engine selection, a different video search-results projection is loaded. The search-results projection shown in FIG. 4F is an SLL projection that displays video search results one results-page threadlet at a time, e.g., threadlet 470, with individual search results displayed as thumbnails, e.g., thumbnails 475 and 476. As always, the user can navigate between multiple shards in the projection, and therefore between multiple pages of search results, by using the navigational menu.
When the user selects thumbnail 475 on the search-results page, threadlet 470 loads a one- threadlet video projection with threadlet 480 as the only threadlet, as shown in FIG. 4G. Threadlet 480 is displayed as a combination of a video node 481 and a menu 482. Because the nature of threadlet 480 is different from that of topic threadlets considered earlier, menu 482 includes a different list of menu items and does not have a menu item selected by default. The user can use different menu items to continue exploring the data space around threadlet 480 or scroll up to one of the previously loaded threadlets in the thread and continue exploring from there.
In some implementations, projections are not limited to the default set of projections implemented as part of the system. For example, the projection request-response protocol may be general and may be designed to make it simple for anyone with basic development skills to implement a so-called third-party projection. To address discoverability and targeting of projections, in some implementations, it is possible for projections to declare what kind of nodes they can target. For example, a third-party projection may choose to target only a particular node or a collection of nodes of a particular type or some combination of types. This is especially applicable to entity nodes, e.g., entity nodes from the online database of structured data, which, in addition to sharing the same topic node type, are classified in terms of entity types in the online database. Because third-party projections can provide arbitrary application-like functionality, they are also often referred to as applications.
If the user browses a node that is being targeted by one or more projections, the user can explore the list of projections that target the node, possibly with projection labels accompanied by user ratings and other helpful information. The user can select and load any projection they like. If a third-party projection gets selected, the target node data is sent to the third-party projection
web server as part of the projection request. Because any node of a particular type and encoding version has well-defined encoding and data format, any node can be used for projection targeting. The projection web server examines the request along with the embedded node information and generates a response. For security reasons, in some implementations, third-party projection requests may be routed via a trusted web server before forwarding them to their respective destination web servers. The trusted server can be used to verify the destination web server credentials and possibly "disconnect" malicious third-party servers from the rest of the system.
If the user finds a projection that they like, they have an option to associate the projection with their user profile, that is, an option to "install" the projection. For nodes that they target, installed projections appear in a prominent view, making it easier to select them. Those skilled in the art will recognize that installed projections may be presented to the user in a variety of different ways. Making use of the projection "install" feature and other signals can make projection targeting even better.
A simple weather-forecast projection is one example of a third-party projection. If a projection developer has access to weather-forecast data, say, in the US, they can target their projection to entity nodes that are geographical locations in the US. Then, every time their projection gets selected, a node that represents a geographical location in the US is sent to the projection web server as part of a projection request. Because the developer knows what kind of nodes the weather-forecast projection can target, they can correctly interpret the entity node data in the request, retrieve geographical coordinates of the location in question, use the coordinates to lookup weather-forecast data, and send back a projection response with, e.g., five different nodes, one for each day of the forecast.
In some implementations, third-party projections are supported and developer tools to hel with projection development and debugging are provided. For example, each topic threadlet can be equipped with a projection-menu item labeled "App developer" that loads a special application-launcher proj ection.
FIG. 5 is a display diagram that shows an example application-launcher threadlet 520. The application launcher provides the developer with a way to examine and possibly edit target- topic node data 528 to be sent as part of a third-party projection request of type 523 to the destination projection web server of the developer choice, e.g., web server 524.
Given that each node type and encoding of the node data for that type and version are well-defined, using nodes for targeting and discoverability of projections provides a number of
unique advantages not available anywhere else on the web. Because each projection is likely to target only a subset of nodes, it will appear to the user only for those nodes that it can handle. As a result, at any moment during their browsing experience, the user is exposed only to the projection data that they may actually be interested in.
More importantly, once a projection is selected, the projection web server gets access to the target node and possibly other data sent as part of the projection request, that is, the context and the input data that the server may require to generate a proper projection response, often without any additional involvement from the user. For example, the weather-forecast projection described earlier should be able to display weather information for a location entity node solely based on the geographical coordinates retrieved from the projection request. Unlike a typical weather-forecast site, it would not need to request the user to provide the name or other information, e.g., the location ZIP code, to uniquely identify the location in question.
Multiple projections from the same and even different third-parties can be bundled together to form an "application group" - a collection of projections generally installed together. This can serve as a convenience feature or sometimes be necessary to provide the user with the best user experience, if two or more projections are designed to work together.
Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, in tangibly-embodied computer software or firmware, in computer hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions encoded on a tangible non-transitory program carrier for execution by, or to control the operation of, data processing apparatus. Alternatively or in addition, the program instructions can be encoded on an artificially-generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. The computer storage medium can be a machine-readable storage device, a machine-readable storage substrate, a random or serial access memory device, or a combination of one or more of them.
The term "data processing apparatus" refers to data processing hardware and encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers. The apparatus can
also be or further include special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit). The apparatus can optionally include, in addition to hardware, code that creates an execution environment for computer programs, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them.
A computer program (which may also be referred to or described as a program, software, a software application, a module, a software module, a script, or code) can be written in any form of programming language, including compiled or interpreted languages, or declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data, e.g., one or more scripts stored in a markup language document, in a single file dedicated to the program in question, or in multiple coordinated files, e.g., files that store one or more modules, sub-programs, or portions of code. A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
The processes and logic flows described in this specification can be performed by one or more programmable computers executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
Computers suitable for the execution of a computer program include, by way of example, can be based on general or special purpose microprocessors or both, or any other kind of central processing unit. Generally, a central processing unit will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a central processing unit for performing or executing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a
game console, a Global Positioning System (GPS) receiver, or a portable storage device, e.g., a universal serial bus (USB) flash drive, to name just a few.
Computer-readable media suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input. In addition, a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a web browser on a user's client device in response to requests received from the web browser.
Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back-end, middleware, or front-end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network ("LAN") and a wide area network ("WAN"), e.g., the Internet.
The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any invention or of what may be claimed, but rather as descriptions of features that may be specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.
Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system modules and components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
Particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. For example, the actions recited in the claims can be performed in a different order and still achieve desirable results. As one example, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In certain implementations, multitasking and parallel processing may be advantageous.
What is claimed is:
Claims
1. A method performed by one or more computers, the method comprising:
determining, from a user input, a topic;
selecting a first node from a plurality of nodes, wherein the first node is a collection of data about the topic;
providing, for display in a user interface, a first threadlet, wherein the first threadlet includes an instance of the first node and a projection menu that includes a respective link to each of one or more projections, and wherein each of the one or more projections includes one or more threadlets that are instances of nodes that share a relationship to the topic;
receiving a user input selecting a particular projection from the one or more projections; and
providing, for display in the user interface, a set of threadlets from the particular projection.
2. The method of claim 1, wherein the topic is an entity represented by a node in an online database of structured data, and wherein the first node includes data from the node in the online database of structured data that represents the entity.
3. The method of any one of claims 1 or 2, further comprising:
updating a thread that identifies threadlets displayed to the user to include the first threadlet, wherein each threadlet in the thread is associated with data that indicates a role of the threadlet in the thread, and wherein updating the thread comprises generating data that indicates that the first threadlet in the thread has a body threadlet role.
4. The method of claim 3, further comprising:
in response to receiving the user input selecting the particular projection, modifying the role of the first threadlet to a tail threadlet role.
5. The method of claim 4, wherein threadlets adjacent to each other in the thread are displayed adjacent to each other in the user interface.
6. The method of claim 5, further comprising: determining, for each threadlet in the thread, whether to display a minimized representation or a maximized representation of the threadlet based on the role of the threadlet in the thread, comprising:
determining that the first threadlet has a body threadlet role; and
providing a maximized representation of the first threadlet for display in the user interface.
7. The method of claim 6, further comprising:
determining that the role of the first threadlet has been modified to a tail threadlet role; and providing a minimized representation of the first threadlet for display adjacent to the set of threadlets from the particular projection.
8. The method of claim 7, further comprising:
receiving a user input selecting a link to a particular projection included in a particular threadlet from the set of threadlets;
updating the thread to include the particular threadlet, wherein updating the thread comprises generating data that indicates that the particular threadlet in the thread has a tail threadlet role; and
providing the particular projection for display adjacent to a minimized representation of the particular threadlet in the user interface, wherein the minimized representation of the particular threadlet is displayed adjacent to the minimized representation of the first threadlet in the user interface.
9. The method of claim 8, wherein the particular projection is a topic projection that includes only a single threadlet that includes an instance of a node that represents a particular topic.
10. The method of any of claims 8 or 9, further comprising:
receiving a user input selecting the minimized representation of the first threadlet; and providing the maximized representation of the first threadlet for display in the user interface in place of the particular projection, the minimized representation of the particular threadlet, and the minimized representation of the first threadlet.
11. A system comprising one or more computers and one or more storage devices storing instructions that, when executed by the one or more computers, cause the one or more computers to perform operations comprising:
determining, from a user input, a topic;
selecting a first node from a plurality of nodes, wherein the first node is a collection of data about the topic;
providing, for display in a user interface, a first threadlet, wherein the first threadlet includes an instance of the first node and a projection menu that includes a respective link to each of one or more projections, and wherein each of the one or more projections includes one or more threadlets that are instances of nodes that share a relationship to the topic;
receiving a user input selecting a particular projection from the one or more projections; and
providing, for display in the user interface, a set of threadlets from the particular projection.
12. The system of claim 11, wherein the topic is an entity represented by a node in an online database of structured data, and wherein the first node includes data from the node in the online database of structured data that represents the entity.
13. The system of any of claims 11 or 12, the operations further comprising:
updating a thread that identifies threadlets displayed to the user to include the first threadlet, wherein each threadlet in the thread is associated with data that indicates a role of the threadlet in the thread, and wherein updating the thread comprises generating data that indicates that the first threadlet in the thread has a body threadlet role.
14. The system of claim 13, the operations further comprising:
in response to receiving the user input selecting the particular projection, modifying the role of the first threadlet to a tail threadlet role.
15. The system of claim 14, wherein threadlets adjacent to each other in the thread are displayed adjacent to each other in the user interface.
16. The system of claim 15, the operations further comprising: determining, for each threadlet in the thread, whether to display a minimized representation or a maximized representation of the threadlet based on the role of the threadlet in the thread, comprising:
determining that the first threadlet has a body threadlet role; and
providing a maximized representation of the first threadlet for display in the user interface.
17. The system of claim 16, the operations further comprising:
determining that the role of the first threadlet has been modified to a tail threadlet role; and providing a minimized representation of the first threadlet for display adjacent to the set of threadlets from the particular projection.
18. The system of claim 17, the operations further comprising:
receiving a user input selecting a link to a particular projection included in a particular threadlet from the set of threadlets;
updating the thread to include the particular threadlet, wherein updating the thread comprises generating data that indicates that the particular threadlet in the thread has a tail threadlet role; and
providing the particular projection for display adjacent to a minimized representation of the particular threadlet in the user interface, wherein the minimized representation of the particular threadlet is displayed adjacent to the minimized representation of the first threadlet in the user interface.
19. The system of claim 18, wherein the particular projection is a topic projection that includes only a single threadlet that includes an instance of a node that represents a particular topic.
20. The system of any of claims 18 or 19, the operations further comprising:
receiving a user input selecting the minimized representation of the first threadlet; and providing the maximized representation of the first threadlet for display in the user interface in place of the particular projection, the minimized representation of the particular threadlet, and the minimized representation of the first threadlet.
21. A computer storage medium encoded with a computer program, the program comprising instructions that when executed by one or more computers cause the one or more computers to perform operations comprising:
determining, from a user input, a topic;
selecting a first node from a plurality of nodes, wherein the first node is a collection of data about the topic;
providing, for display in a user interface, a first threadlet, wherein the first threadlet includes an instance of the first node and a projection menu that includes a respective link to each of one or more projections, and wherein each of the one or more projections includes one or more threadlets that are instances of nodes that share a relationship to the topic;
receiving a user input selecting a particular projection from the one or more projections; and
providing, for display in the user interface, a set of threadlets from the particular projection.
22. The computer storage medium of claim 21, wherein the topic is an entity represented by a node in an online database of structured data, and wherein the first node includes data from the node in the online database of structured data that represents the entity.
23. The computer storage medium of any of claims 21 or 22, the operations further comprising:
updating a thread that identifies threadlets displayed to the user to include the first threadlet, wherein each threadlet in the thread is associated with data that indicates a role of the threadlet in the thread, and wherein updating the thread comprises generating data that indicates that the first threadlet in the thread has a body threadlet role.
24. The computer storage medium of claim 23, the operations further comprising:
in response to receiving the user input selecting the particular projection, modifying the role of the first threadlet to a tail threadlet role.
25. The computer storage medium of claim 24, wherein threadlets adjacent to each other in the thread are displayed adjacent to each other in the user interface.
26. The computer storage medium of claim 25, the operations further comprising:
determining, for each threadlet in the thread, whether to display a minimized representation or a maximized representation of the threadlet based on the role of the threadlet in the thread, comprising:
determining that the first threadlet has a body threadlet role; and
providing a maximized representation of the first threadlet for display in the user interface.
27. The computer storage medium of claim 26, the operations further comprising:
determining that the role of the first threadlet has been modified to a tail threadlet role; and providing a minimized representation of the first threadlet for display adjacent to the set of threadlets from the particular projection.
28. The computer storage medium of claim 27, the operations further comprising:
receiving a user input selecting a link to a particular projection included in a particular threadlet from the set of threadlets;
updating the thread to include the particular threadlet, wherein updating the thread comprises generating data that indicates that the particular threadlet in the thread has a tail threadlet role; and
providing the particular projection for display adjacent to a minimized representation of the particular threadlet in the user interface, wherein the minimized representation of the particular threadlet is displayed adjacent to the minimized representation of the first threadlet in the user interface.
29. The computer storage medium of claim 28, wherein the particular projection is a topic projection that includes only a single threadlet that includes an instance of a node that represents a particular topic.
30. The computer storage medium of any of claims 28 or 29, the operations further comprising:
receiving a user input selecting the minimized representation of the first threadlet; and providing the maximized representation of the first threadlet for display in the user interface in place of the particular projection, the minimized representation of the particular threadlet, and the minimized representation of the first threadlet.
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201161532485P | 2011-09-08 | 2011-09-08 | |
PCT/UA2012/000084 WO2013048360A1 (en) | 2011-09-08 | 2012-09-07 | Exploring information by topic |
Publications (1)
Publication Number | Publication Date |
---|---|
EP2754073A1 true EP2754073A1 (en) | 2014-07-16 |
Family
ID=47010702
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
EP12770291.8A Withdrawn EP2754073A1 (en) | 2011-09-08 | 2012-09-07 | Exploring information by topic |
Country Status (3)
Country | Link |
---|---|
US (1) | US9870131B2 (en) |
EP (1) | EP2754073A1 (en) |
WO (1) | WO2013048360A1 (en) |
Families Citing this family (10)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
USD750111S1 (en) * | 2012-12-14 | 2016-02-23 | Facebook, Inc. | Display panel of a programmed computer system with a graphical user interface |
US10635856B2 (en) | 2013-06-28 | 2020-04-28 | Honeywell International Inc. | Cross tab editor with reverse editing capability |
TWD166921S (en) * | 2013-08-14 | 2015-04-01 | 新力電腦娛樂股份有限公司 | Graphical user interface for a display panel |
USD752079S1 (en) * | 2013-10-15 | 2016-03-22 | Deere & Company | Display screen with graphical user interface |
US9715658B2 (en) | 2014-02-28 | 2017-07-25 | Honeywell International Inc. | Methods for producing customer configurable technical manuals |
US20150278301A1 (en) * | 2014-03-31 | 2015-10-01 | Honeywell International Inc. | Systems and methods to reduce computing overhead in a data management application |
US11080777B2 (en) * | 2014-03-31 | 2021-08-03 | Monticello Enterprises LLC | System and method for providing a social media shopping experience |
US9881089B2 (en) * | 2014-04-28 | 2018-01-30 | Verizon New Jersey Inc. | Pop-up search box |
WO2015195364A1 (en) * | 2014-06-18 | 2015-12-23 | Thomson Licensing | Method and apparatus for processing search results |
US10212116B2 (en) | 2015-09-29 | 2019-02-19 | International Business Machines Corporation | Intelligently condensing transcript thread history into a single common reduced instance |
Family Cites Families (29)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6453312B1 (en) * | 1998-10-14 | 2002-09-17 | Unisys Corporation | System and method for developing a selectably-expandable concept-based search |
US7237258B1 (en) * | 2002-02-08 | 2007-06-26 | Mcafee, Inc. | System, method and computer program product for a firewall summary interface |
US20050222987A1 (en) * | 2004-04-02 | 2005-10-06 | Vadon Eric R | Automated detection of associations between search criteria and item categories based on collective analysis of user activity data |
US20050283464A1 (en) * | 2004-06-10 | 2005-12-22 | Allsup James F | Method and apparatus for selective internet advertisement |
US20060143568A1 (en) * | 2004-11-10 | 2006-06-29 | Scott Milener | Method and apparatus for enhanced browsing |
US7890503B2 (en) * | 2005-02-07 | 2011-02-15 | Microsoft Corporation | Method and system for performing secondary search actions based on primary search result attributes |
US7788248B2 (en) * | 2005-03-08 | 2010-08-31 | Apple Inc. | Immediate search feedback |
US9507850B1 (en) * | 2005-08-30 | 2016-11-29 | ProQuest, LLC | Method and system for searching databases |
US7953730B1 (en) | 2006-03-02 | 2011-05-31 | A9.Com, Inc. | System and method for presenting a search history |
WO2008021906A2 (en) * | 2006-08-08 | 2008-02-21 | Google Inc. | Interest targeting |
CN100573520C (en) * | 2006-08-29 | 2009-12-23 | 国际商业机器公司 | For retrieval is carried out pretreated method and apparatus to a plurality of documents |
US8082301B2 (en) * | 2006-11-10 | 2011-12-20 | Virtual Agility, Inc. | System for supporting collaborative activity |
US7966321B2 (en) * | 2007-01-17 | 2011-06-21 | Google Inc. | Presentation of local results |
US7987176B2 (en) * | 2007-06-25 | 2011-07-26 | Sap Ag | Mixed initiative semantic search |
US20150242536A1 (en) * | 2007-10-19 | 2015-08-27 | Sergey Surkov | Advanced Search Page with Dynamic Generation of a Search Query String |
US8412702B2 (en) * | 2008-03-12 | 2013-04-02 | Yahoo! Inc. | System, method, and/or apparatus for reordering search results |
US20090327268A1 (en) * | 2008-06-27 | 2009-12-31 | Microsoft Corporation | Providing targeted information for entertainment-oriented searches |
US20100057583A1 (en) * | 2008-08-28 | 2010-03-04 | The Directv Group, Inc. | Method and system for ordering video content using a link |
KR101590357B1 (en) * | 2009-06-16 | 2016-02-01 | 엘지전자 주식회사 | Operating a Mobile Terminal |
KR20120085709A (en) * | 2009-07-17 | 2012-08-01 | 구글 인코포레이티드 | Providing advertisements from related search queries |
US8782066B2 (en) * | 2009-09-04 | 2014-07-15 | Tanya Ward English | Media transcription, synchronization and search |
US9424444B2 (en) * | 2009-10-14 | 2016-08-23 | At&T Mobility Ii Llc | Systems, apparatus, methods and computer-readable storage media for facilitating integrated messaging, contacts and social media for a selected entity |
US8423538B1 (en) * | 2009-11-02 | 2013-04-16 | Google Inc. | Clustering query refinements by inferred user intent |
US8260664B2 (en) * | 2010-02-05 | 2012-09-04 | Microsoft Corporation | Semantic advertising selection from lateral concepts and topics |
US8880548B2 (en) * | 2010-02-17 | 2014-11-04 | Microsoft Corporation | Dynamic search interaction |
US10083248B2 (en) * | 2010-04-07 | 2018-09-25 | Excalibur Ip, Llc | Method and system for topic-based browsing |
US8880520B2 (en) * | 2010-04-21 | 2014-11-04 | Yahoo! Inc. | Selectively adding social dimension to web searches |
US8762360B2 (en) * | 2011-05-06 | 2014-06-24 | Microsoft Corporation | Integrating applications within search results |
US8965788B2 (en) * | 2011-07-06 | 2015-02-24 | Target Brands, Inc. | Search page topology |
-
2012
- 2012-09-07 WO PCT/UA2012/000084 patent/WO2013048360A1/en active Application Filing
- 2012-09-07 EP EP12770291.8A patent/EP2754073A1/en not_active Withdrawn
- 2012-09-07 US US14/343,820 patent/US9870131B2/en not_active Expired - Fee Related
Also Published As
Publication number | Publication date |
---|---|
WO2013048360A1 (en) | 2013-04-04 |
US20140331156A1 (en) | 2014-11-06 |
US9870131B2 (en) | 2018-01-16 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US9870131B2 (en) | Exploring information by topic | |
US11281620B2 (en) | Method of and system for enhanced local-device content discovery | |
US9720672B2 (en) | Searching and accessing application functionality | |
US9251278B2 (en) | Dynamic menus for multi-prefix interactive mobile searches | |
KR101708448B1 (en) | Predictive query suggestion caching | |
US20160191639A1 (en) | Recommending Content Based On User Profiles Clustered By Subscription Data | |
US10871881B2 (en) | Dynamically picking content from social shares to display in a user interface | |
US9733802B2 (en) | Automatic deep view card stacking | |
KR20110099225A (en) | Previewing search results for suggested refinement terms and vertical searches | |
CN103348344A (en) | Composite term index for graph data | |
KR20120073222A (en) | Table of contents for search query refinement | |
JP2006209749A (en) | Method and system for providing automatic search menu to user interface | |
JP2015534192A (en) | System and method for associating online content with indexed second content | |
US20150193117A1 (en) | Changing Icons for a Web Page | |
US10936584B2 (en) | Searching and accessing application-independent functionality | |
US20240086479A1 (en) | Identification and Issuance of Repeatable Queries | |
US11853821B2 (en) | User interface for searching and generating graphical objects linked to third-party content | |
US20160299911A1 (en) | Processing search queries and generating a search result page including search object related information | |
US20160335358A1 (en) | Processing search queries and generating a search result page including search object related information | |
US20170116291A1 (en) | Network caching of search result history and interactions | |
US9529936B1 (en) | Search results using query hints | |
US9311362B1 (en) | Personal knowledge panel interface | |
WO2015198114A1 (en) | Processing search queries and generating a search result page including search object information | |
US10909112B2 (en) | Method of and a system for determining linked objects | |
US20110225502A1 (en) | Accessing web services and presenting web content according to user specifications |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PUAI | Public reference made under article 153(3) epc to a published international application that has entered the european phase |
Free format text: ORIGINAL CODE: 0009012 |
|
17P | Request for examination filed |
Effective date: 20140313 |
|
AK | Designated contracting states |
Kind code of ref document: A1Designated state(s): AL AT BE BG CH CY CZ DE DK EE ES FI FR GB GR HR HU IE IS IT LI LT LU LV MC MK MT NL NO PL PT RO RS SE SI SK SM TR |
|
DAX | Request for extension of the european patent (deleted) | ||
17Q | First examination report despatched |
Effective date: 20161007 |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: THE APPLICATION IS DEEMED TO BE WITHDRAWN |
|
18D | Application deemed to be withdrawn |
Effective date: 20170218 |
|
P01 | Opt-out of the competence of the unified patent court (upc) registered |
Effective date: 20230522 |