US9122705B1 - Scoring hash functions - Google Patents
Scoring hash functions Download PDFInfo
- Publication number
- US9122705B1 US9122705B1 US13/421,750 US201213421750A US9122705B1 US 9122705 B1 US9122705 B1 US 9122705B1 US 201213421750 A US201213421750 A US 201213421750A US 9122705 B1 US9122705 B1 US 9122705B1
- Authority
- US
- United States
- Prior art keywords
- performance indicator
- hash functions
- computed
- image
- hash
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Fee Related, expires
Links
Images
Classifications
-
- G06F17/30247—
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/50—Information retrieval; Database structures therefor; File system structures therefor of still image data
- G06F16/58—Retrieval characterised by using metadata, e.g. metadata not derived from the content or metadata generated manually
- G06F16/583—Retrieval characterised by using metadata, e.g. metadata not derived from the content or metadata generated manually using metadata automatically derived from the content
Definitions
- This specification relates to data processing.
- Hash functions are typically used to represent the extracted features of input data with descriptors that require less storage space and whose similarity determination is computationally less expensive than using the original input data.
- Locality-sensitive hashing is one conventional method that uses a particular family of probabilistic hash functions to map similar input data to similar hashes.
- a hash function maps each element of input data to a sequence of hash characters called a hash, where each hash character corresponds to a unique bit string.
- a hash collision occurs when a hash function maps two input data elements to the same hash.
- the feature representations of the input data elements can be hashed multiple times to generate multiple hashes for each input data element.
- the number of hash collisions between respective hashes for the two input data elements gives an empirical approximation of the overall hash collision probability, which in turn gives an approximation of the distance between the input data elements.
- a computer process can conventionally compute the similarity between two images by extracting features of each image to create a feature representation and can then compare the respective feature representations.
- Features of an image can include, for example, histograms of image color or grayscale data, edges, corners, image centers of gravity, or other image points of interest.
- the features extracted from an image can be concatenated into a feature representation.
- the feature representations are typically compared by various distance metrics, for example, the Jaccard distance, the L1 distance, or the L2 distance. However, these distance metrics may be computationally expensive when performed on the original feature representation.
- the variety of features extracted from an image may require storage space that is orders of magnitude larger than the storage space required to store the image itself. Consequently, hash functions are typically used to reduce the storage requirements of the feature representations and to improve the performance of distance computation between the images.
- This specification describes technologies relating to scoring hash functions.
- Probabilistic hash functions can be used to approximate the similarity or distance between input images.
- a subset of hash functions can be selected from a larger set of hash functions from the same family of probabilistic hash functions. In many applications, it is desirable to select only the best hash functions available for a particular task. To select the best hash functions, a score can be computed for each hash function in the family of hash functions. Highest-scoring hash functions can then be used in a final set of hash functions to be used for the particular task.
- Cross validation methods can be used to select the hash functions in such a way that reduces the probability of overtraining on training data. These methods also allow the hash functions to be evaluated even when used in arbitrarily complex objective functions.
- one innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of computing one or more first performance indicators for an objective function computed on each of one or more sets of input data elements using a set of hash functions; computing a first overall performance indicator using each of the computed performance indicators; adding a candidate hash function to the set of hash functions to generate a second set of hash functions; computing one or more second performance indicators for the objective function computed on each of the one or more sets of input data elements using the second set of hash functions; computing a second overall performance indicator using each of the computed second performance indicators; and computing a score for the candidate hash function using the first overall performance indicator and the second overall performance indicator.
- inventions of this aspect include corresponding computer systems, apparatus, and computer programs recorded on one or more computer storage devices, each configured to perform the actions of the methods.
- a system of one or more computers can be configured to perform particular operations or actions by virtue of having software, firmware, hardware, or a combination of them installed on the system that in operation causes or cause the system to perform the actions.
- One or more computer programs can be configured to perform particular operations or actions by virtue of including instructions that, when executed by data processing apparatus, cause the apparatus to perform the actions.
- the objective function classifies the sets of input data elements using the set of hash functions and the first or second performance indicator is a likelihood of a correct classification.
- the first or second overall performance indicator is a product of the first performance indicator and the second performance indicator or a sum of a logarithm of the first performance indicator and the second performance indicator.
- the score is based on a difference in log likelihood between the second overall performance indicator and the first overall performance indicator.
- the objective function ranks the sets of input data elements using the set of hash functions and the first or second performance indicator is a likelihood of a correct ranking.
- the sets of input data elements are image training triplets, wherein each image training triplet includes a query image Q, a first image A, and a second image B, wherein the first or second performance indicator is a measure of the likelihood that a distance function using the set of hash functions will correctly rank the query image Q of each image training triplet as more similar to the first image A of each image training triplet than to the second image B of each image training triplet.
- the likelihood of a correct triplet ranking is computed based at least in part on a distance between each Q and each A and a distance between each Q and each B.
- the score is based on a difference between the first overall performance indicator and the second overall performance indicator.
- the first or second performance indicator is a likelihood or a probability of the objective function correctly performing a task.
- the first or second overall performance indicator is a product of the first performance indicator and the second performance indicator or a sum of a logarithm of the first performance indicator and the second performance indicator.
- Another innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of selecting a sample size and sampling a number of hash functions from a collection of hash functions, the number being at least equal to the sample size; computing a score for each of the sampled hash functions; selecting one or more of the sampled hash functions for a final set of hash functions based at least in part on the score for each respective hash function; evaluating an objective function on one or more input data elements using the final set of hash functions; and computing a quality score for the sample size based at least in part on a performance of the objective function using the final set of hash functions on the one or more input data elements.
- Selecting one or more of the sampled hash functions for an objective function based at least in part on the score for each respective hash function includes selecting a hash function with a highest score for a final set of hash functions.
- the actions further include dividing a dataset of input data elements into a training subset and a validation subset, and wherein selecting a hash function with a highest score for a final set of hash functions includes computing a score for each of the hash functions in the sample using the training subset, and adding the highest-scoring hash function in the sample to the final set of hash functions; evaluating the objective function on the validation subset using the final set of hash functions; and computing a quality score for the sample size based at least in part on a performance of the objective function on the validation subset using the final set of hash functions.
- the actions further include dividing the dataset into a different training subset and a different validation subset; sampling a number of hash functions from the collection of hash functions, the number being at least the sample size; computing a score for each of one or more sampled hash functions using the different training subset; selecting one or more of the sampled hash functions for a final set of hash functions based at least in part on the score for each respective hash function computed using the different training subset; evaluating the objective function on the different validation subset using the final set of hash functions; computing a second quality score for the sample size based at least in part on a performance of the objective function on the different validation subset; and averaging the quality score and second quality score to compute an overall quality score for the sample size.
- the actions further include selecting a different second sample size and sampling a number of hash functions from a collection of hash functions, the number being at least the second sample size; computing a score for each of the hash functions sampled for the second sample size; selecting one or more of the hash functions sampled for the second sample size for a second final set of hash functions based at least in part on the score for each respective hash function; evaluating an objective function on one or more input data elements using the second final set of hash functions; computing a second quality score for the second sample size based at least in part on a performance of the objective function using the second final set of hash functions on the one or more input data elements; and comparing the quality score and the second quality score and selecting a sample size with a highest quality score.
- the input data elements comprise image training triplets, wherein each triplet comprises a query image Q, a first image A, and second image B, and wherein the objective function calculates whether Q is closer to A or B.
- Scoring hash functions improves the performance of an objective function by providing for selection of only the most effective hash functions.
- the selection process provides a method for selecting the best hash functions even for arbitrarily complex objective functions, such as objective functions used for computing image similarity and ranking.
- FIG. 1 is a diagram of inputs and outputs of a set of hash functions for computing the similarity between two images.
- FIG. 2 is a block diagram representing an example process for scoring a hash function.
- FIG. 3 is a block diagram representing an example process for choosing an optimal size for a sample of hash functions.
- FIG. 4 is a flow chart for an example process for choosing an optimal size for a sample of hash functions.
- FIG. 1 is a diagram of inputs and outputs of a set of hash functions for computing the similarity between two images.
- FIG. 1 is an example application for using a family of random hash functions on a pair of images.
- hash functions can be useful for input data of any type, including text data.
- the similarity between image 104 and image 106 can be approximated by hashing.
- a set of hash functions 110 is used to compute a set of hashes for each image.
- the set of hash functions 110 takes as input data the extracted features of image 104 and produces hashes 120 .
- the same set of hash functions 110 also takes as input the extracted features of image 106 and produces hashes 130 .
- the number of hash collisions between respective hashes in hashes 120 and hashes 130 can be used to approximate the similarity between images 104 and 106 .
- Using an infinite number of hash functions in the set of hash functions 110 would give a complete reconstruction of the probability of a hash collision. However, in practice only a finite subset of hash functions can be used. Identifying the best hash functions to include in the set of hash functions 110 can improve the accuracy of the probability of a hash collision, and can therefore improve the computation of the similarity between images.
- FIG. 2 is a block diagram 200 representing an example process for scoring a hash function.
- a candidate hash function can be assigned a score to indicate the degree to which the hash function improves the performance of a particular objective function.
- the score can indicate the degree to which the candidate hash function improves the accuracy of determining whether two input images are similar.
- the process as shown in FIG. 2 can be used to score any family of random hash functions, including MinHash, random projections, spectral hashing, and other locality sensitive hashing methods.
- the performance of hash functions from these hashing methods can be measured on any objective function.
- the objective function is computed on sets of input data elements with the hash functions operating on each input data element.
- the example process in FIG. 2 uses sets of input data elements that are triplets of training images.
- the dataset 202 contains the triplets of training images (Q i , A i , B i ) that can be used to compute a score for each candidate hash function.
- Each triplet (Q i , A i , B i ) of the dataset 202 contains a query image, Q, and two images A and B such that Q is considered to be more similar to A than B.
- the similarity between A and B is not considered or is undefined.
- the triplet images have been rated by human raters who have determined that Q is more similar to A than B.
- a set of hash functions 210 is used to compute a log likelihood that a given set of hash functions will correctly determine that Q is more similar to A than B when the hash functions are used to compute a distance between 1) Q and A and 2) Q and B, given a defined distance function.
- the example process in FIG. 2 can also be used to score hash functions for a variety of other objective functions.
- the example process can operate on sets of input data elements that are pairs of images, where the process computes a probability of the set of hash functions 210 correctly computing that the similarity of the pair is either above or below a threshold.
- Each triplet (Q i , A i , B i ) of the dataset 202 can be used to compute a performance indicator for the set of hash functions 210 used by the objective function.
- the performance indicator can be a likelihood LH i 206 that a distance function 208 using a set of hash functions 210 will correctly rank the triplet.
- a correct triplet ranking occurs when the distance between Q i and A i is computed to be less than the distance between Q i and B i .
- the likelihood LH i 206 of a correct triplet ranking is computed by likelihood function 204 .
- the likelihood function 204 is a function of a distance function 208 , which depends on a set of hash functions 210 .
- the distance function 208 can be specific to the chosen family of hash functions, from which the set of hash functions 210 is selected. In general, the distance function uses the set of hash functions 210 , which take as input each image of the image triplets and outputs hashes for each image. The hashes for the input images can be used to compute the distances between the images in the input image pairs. In some implementations, the distance is the number of hash collisions between the generated hashes. In some implementations, the distance function also depends on the norms of the feature representations of an input image pair. Norms of the features representations can be, for example, L1 or L2 norms. An L1 norm for a feature representation can be computed as:
- L ⁇ ⁇ 1 ⁇ ⁇ norm ⁇ i ⁇ ⁇ x i ⁇ , for each feature x i in the feature representation.
- An L2 norm for a feature representation can be computed as:
- the likelihood of a correct triplet ranking can be computed as:
- Dist(Q,B) is the distance between each Q i and B i using distance function 208
- Dist (Q, A) is the distance between each Q i and A i using the distance function 208 .
- An additional scaling parameter ⁇ can be optimized for a given distance function.
- the likelihoods LH i 206 can be used to compute an overall performance indicator for the given set of hash functions 210 .
- the product of the likelihoods LH i 206 of each triplet in the dataset 202 is computed to give an overall likelihood of a correct triplet ranking for the given set of hash functions 210 .
- the sum of the logarithms of the likelihoods LH i 206 can be computed with a log likelihood function 212 to give the log likelihood LLH 214 of a correct triplet ranking for the set of hash functions 210 .
- a score for a given candidate hash function can be based on the change in the computed overall performance indicator after the candidate hash function is added to the existing set of hash functions. For example, the score can be based on the change in the computed log likelihood 214 . Adding a candidate hash function to the set of hash functions 210 creates the set of hash functions 220 .
- each triplet (Q i , A i , B i ) of the dataset 202 can similarly be used to compute a performance indicator for the set of hash functions 220 , e.g., the likelihood of a correct triplet ranking
- the new likelihood 207 is denoted by LH* i .
- LH* i the likelihood of a correct triplet ranking
- a new overall performance indicator for the new set of hash functions 220 can be computed.
- the overall performance indicator is computed by the log likelihood function 212 to compute a log likelihood LLH* 216 .
- a scoring function 230 can compute a score for the candidate hash function by comparing the change in overall performance indicators for the set of hash functions 210 and the new set of hash functions 220 .
- the scoring function computes the score as the difference between LLH* 216 and LLH 214 .
- the score can indicate how much better (or worse) the log likelihood of correct rankings is when the candidate hash function is included in the distance computation.
- hash functions can be ranked to indicate which hash functions have the most influence on the log likelihood of a correct triplet ranking.
- a score for the candidate hash function can be computed by evaluating the objective function using only the candidate hash function to be scored.
- the score for the candidate hash function need not depend on other hash functions in a set of hash functions, e.g., the set of hash functions 210 or 220 .
- the score can be computed directly from a performance indicator for the candidate hash function, e.g., the likelihood of a correct triplet ranking.
- FIG. 3 is a block diagram of an example process 300 for choosing an optimal size for a sample of hash functions.
- the process 300 is one example method for using the computed scores of hash functions to select a final subset of hash functions that optimize an objective function.
- the objective function is the particular task for which the set of hash functions are being chosen.
- One example objective function is correctly ranking as many image triplets (Q i , A i , B i ) as possible in a dataset, where a correct ranking occurs when Q i is determined to be more similar to A i than B i .
- Another example objective function is ranking all A i and B i images in a dataset of triplets in order of distance to a particular Q i image.
- the objective function can further assign a reward or penalty based on whether A i and B i were within a threshold number of images T to Q i in the ranking.
- the reward or penalty may also be weighted by the overall ranking of A i and B i .
- This objective function can additionally be iterated for all T values, e.g. from 1 to 30.
- a variety of methods can be used to choose a final set of hash functions, given a score for each hash function. For example, one method is to choose the final set of hash functions as the top N highest-scoring hash functions, for a task that requires N hash functions.
- the process 300 uses cross validation to improve the ability of the selected hash functions to generalize to unseen data. The example process 300 can thus correct for overtraining effects that can occur as a result of using other techniques, for example, selecting only the highest-scoring N hash functions.
- the process 300 can operate on a dataset of triplets (Q i , A i , B i ) 310 , where Q i is considered to be more similar to A i than B i .
- the cross validation procedure divides the dataset 310 into a training subset 314 and a validation subset 312 .
- a sample of S hash functions 322 is chosen.
- the hash functions in the sample are scored with a scoring process 330 .
- the scoring process 330 can be similar to the scoring process described with respect to FIG. 2 .
- One or more of the highest-scoring hash functions is added to a final set of hash functions 342 .
- An objective function 340 is evaluated on the validation subset 312 using the final set of hash functions.
- the performance of the objection function 340 is used to compute the quality 350 of cross validation round i for sample size S.
- the process 300 can be repeated multiple times, each time dividing the dataset 310 into a different training subset 314 and a different validation subset 312 .
- FIG. 4 is a flow chart for an example process 400 for choosing an optimal size for a sample of hash functions.
- the process 400 can be implemented as the cross validation procedure as shown in FIG. 3 .
- the process 400 will be described as being performed by a system that includes one or more computers.
- the system divides a dataset into a training subset and a validation subset ( 405 ).
- the hash functions will be scored using the training subset, and the objective function will be evaluated using the validation subset.
- this process is repeated with different segments of the dataset serving as the validation data, with the remainder serving as the training data.
- the dataset can include image triplets (Q i , A i , B i ). Twenty percent of the triplets can be held out as the validation data on each round, with the other eighty percent of the triplets used as the training subset to score the hash functions, with the process being performed five times.
- the system samples S hash functions from a collection of hash functions ( 410 ).
- the collection of hash functions can be a family of random hash functions. Because the process 400 is designed to find the optimal sample size S, the initial sample size S can be, e.g., 1.
- the system computes a score for each hash function in the sample using the training subset ( 415 ).
- the system can use a scoring process as shown in FIG. 2 to score the hash functions using the training subset.
- the score for each hash function is the change in log likelihood of a correct image triplet ranking over the training subset when that hash function is added to a set of hash functions.
- the system selects a hash function in the sample for a final set of hash functions based on the score for the hash function ( 420 ).
- the system can select the highest-scoring hash function in the sample and add the hash function to a final set of hash functions.
- the remaining S-1 hash functions are cleared from the sample so that S new hash functions can be sampled independently on the next selection. In some other implementations, the remaining S-1 hash functions remain in the sample.
- the system determines whether more hash functions are needed for the objective function ( 425 ). The number of hash functions required depends on the particular objective function, and a particular objective function can require thousands or millions of hash functions. If the final set of hash functions is not yet complete, the system can choose a new sample of random hash functions from the family of hash functions ( 430 ). The system then recomputes scores for the hash functions in the sample (branch to 415 ).
- the system evaluates the objective function on the validation subset using the final set of hash functions to compute a quality score for sample size S for round i ( 435 ).
- the system can compute a performance indicator based on the evaluation of the objective function. For example, using the final set of hash functions, the objective function might correctly rank 70% of image triplets in the validation subset. The system can use the 70% success rate to compute a performance indicator for the objective function. The performance indicator for the objective function can then be used to compute a quality score for sample size S on cross validation round i.
- the system determines whether further cross validation rounds remain ( 440 ). If more cross validation rounds remain, the sample size S can remain the same, and the system repartitions the dataset into a different training subset and a different validation subset (branch to 405 ). In some implementations, the cross validation process ends when all elements in the dataset have been used once in the validation subset.
- the system averages the quality scores from the cross validation rounds to compute an overall quality score for sample size S ( 445 ).
- the system can store the overall quality score for sample size S for later comparison with other overall quality scores for other sample sizes.
- the system determines whether overall quality scores should be computed for more values of the sample size S ( 450 ). If more sample values remain, the system increments the sample size S ( 455 ), and the system repartitions the dataset into a new training subset and validation subset (branch to 405 ).
- the system stores the quality scores for sample sizes that resulted in the best overall quality score for the objective function ( 460 ). For example, a sample size of five can be stored because it resulted in 95% of image triplets in the validation set being correctly ranked, which might be more than any other sample size.
- the system can use the sample size to choose a final set of hash functions for performing a particular task using an objective function.
- Using the optimal sample size can help prevent effects of overtraining and thus improve the ability of the objective function to generalize to unseen data.
- Embodiments of the subject matter and the operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them.
- Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions, encoded on computer storage medium for execution by, or to control the operation of, data processing apparatus.
- the program instructions can be encoded on an artificially-generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus.
- a computer storage medium can be, or be included in, a computer-readable storage device, a computer-readable storage substrate, a random or serial access memory array or device, or a combination of one or more of them.
- a computer storage medium is not a propagated signal, a computer storage medium can be a source or destination of computer program instructions encoded in an artificially-generated propagated signal.
- the computer storage medium can also be, or be included in, one or more separate physical components or media (e.g., multiple CDs, disks, or other storage devices).
- the operations described in this specification can be implemented as operations performed by a data processing apparatus on data stored on one or more computer-readable storage devices or received from other sources.
- the term “data processing apparatus” encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, a system on a chip, or multiple ones, or combinations, of the foregoing.
- the apparatus can include special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
- the apparatus can also include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, a cross-platform runtime environment, a virtual machine, or a combination of one or more of them.
- the apparatus and execution environment can realize various different computing model infrastructures, such as web services, distributed computing and grid computing infrastructures.
- a computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, object, or other unit suitable for use in a computing environment.
- a computer program may, but need not, correspond to a file in a file system.
- a program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub-programs, or portions of code).
- a computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
- the processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform actions by operating on input data and generating output.
- the processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
- processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer.
- a processor will receive instructions and data from a read-only memory or a random access memory or both.
- the essential elements of a computer are a processor for performing actions in accordance with instructions and one or more memory devices for storing instructions and data.
- a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks.
- mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks.
- a computer need not have such devices.
- a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., a universal serial bus (USB) flash drive), to name just a few.
- Devices suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks.
- the processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
- a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer.
- a display device e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor
- keyboard and a pointing device e.g., a mouse or a trackball
- Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.
- a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a
- Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back-end, middleware, or front-end components.
- the components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network.
- Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), an inter-network (e.g., the Internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks).
- LAN local area network
- WAN wide area network
- inter-network e.g., the Internet
- peer-to-peer networks e.g., ad hoc peer-to-peer networks.
- the computing system can include clients and servers.
- a client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
- a server transmits data (e.g., an HTML page) to a client device (e.g., for purposes of displaying data to and receiving user input from a user interacting with the client device).
- client device e.g., for purposes of displaying data to and receiving user input from a user interacting with the client device.
- Data generated at the client device e.g., a result of the user interaction
Abstract
Description
for each feature xi in the feature representation. An L2 norm for a feature representation can be computed as:
where Dist(Q,B) is the distance between each Qi and Bi using
Claims (19)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/421,750 US9122705B1 (en) | 2011-03-15 | 2012-03-15 | Scoring hash functions |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201161453052P | 2011-03-15 | 2011-03-15 | |
US13/421,750 US9122705B1 (en) | 2011-03-15 | 2012-03-15 | Scoring hash functions |
Publications (1)
Publication Number | Publication Date |
---|---|
US9122705B1 true US9122705B1 (en) | 2015-09-01 |
Family
ID=53938893
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US13/421,750 Expired - Fee Related US9122705B1 (en) | 2011-03-15 | 2012-03-15 | Scoring hash functions |
Country Status (1)
Country | Link |
---|---|
US (1) | US9122705B1 (en) |
Cited By (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20140108590A1 (en) * | 2012-10-11 | 2014-04-17 | Simon Hunt | Efficient shared image deployment |
US20210311009A1 (en) * | 2018-07-31 | 2021-10-07 | Nec Corporation | Information processing apparatus, control method, and non-transitory storage medium |
US11640381B2 (en) * | 2019-07-23 | 2023-05-02 | Arm Limited | System, device and/or process for hashing |
Citations (8)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20100027895A1 (en) * | 2006-08-31 | 2010-02-04 | Osaka Prefecture University Public Corporation | Image recognition method, image recognition device, and image recognition program |
US20100158391A1 (en) * | 2008-12-24 | 2010-06-24 | Yahoo! Inc. | Identification and transfer of a media object segment from one communications network to another |
US7761466B1 (en) * | 2007-07-30 | 2010-07-20 | Hewlett-Packard Development Company, L.P. | Hash-based image identification |
US20100185615A1 (en) * | 2009-01-14 | 2010-07-22 | Xerox Corporation | Searching a repository of documents using a source image as a query |
US20110170781A1 (en) * | 2010-01-10 | 2011-07-14 | Alexander Bronstein | Comparison of visual information |
US8352494B1 (en) * | 2009-12-07 | 2013-01-08 | Google Inc. | Distributed image search |
US8768105B2 (en) * | 2011-01-21 | 2014-07-01 | Kodak Alaris Inc. | Method for searching a database using query images and an image anchor graph-based ranking algorithm |
US8792728B2 (en) * | 2010-09-27 | 2014-07-29 | Hewlett-Packard Development Company, L.P. | Near-duplicate image detection |
-
2012
- 2012-03-15 US US13/421,750 patent/US9122705B1/en not_active Expired - Fee Related
Patent Citations (10)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20100027895A1 (en) * | 2006-08-31 | 2010-02-04 | Osaka Prefecture University Public Corporation | Image recognition method, image recognition device, and image recognition program |
US7761466B1 (en) * | 2007-07-30 | 2010-07-20 | Hewlett-Packard Development Company, L.P. | Hash-based image identification |
US20100158391A1 (en) * | 2008-12-24 | 2010-06-24 | Yahoo! Inc. | Identification and transfer of a media object segment from one communications network to another |
US20100185615A1 (en) * | 2009-01-14 | 2010-07-22 | Xerox Corporation | Searching a repository of documents using a source image as a query |
US8195672B2 (en) * | 2009-01-14 | 2012-06-05 | Xerox Corporation | Searching a repository of documents using a source image as a query |
US8352494B1 (en) * | 2009-12-07 | 2013-01-08 | Google Inc. | Distributed image search |
US20110170781A1 (en) * | 2010-01-10 | 2011-07-14 | Alexander Bronstein | Comparison of visual information |
US8712156B2 (en) * | 2010-01-10 | 2014-04-29 | Bronstein Bronstein Kimmel Technologies Ltd. | Comparison of visual information |
US8792728B2 (en) * | 2010-09-27 | 2014-07-29 | Hewlett-Packard Development Company, L.P. | Near-duplicate image detection |
US8768105B2 (en) * | 2011-01-21 | 2014-07-01 | Kodak Alaris Inc. | Method for searching a database using query images and an image anchor graph-based ranking algorithm |
Cited By (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20140108590A1 (en) * | 2012-10-11 | 2014-04-17 | Simon Hunt | Efficient shared image deployment |
US11126418B2 (en) * | 2012-10-11 | 2021-09-21 | Mcafee, Llc | Efficient shared image deployment |
US20210311009A1 (en) * | 2018-07-31 | 2021-10-07 | Nec Corporation | Information processing apparatus, control method, and non-transitory storage medium |
US11640381B2 (en) * | 2019-07-23 | 2023-05-02 | Arm Limited | System, device and/or process for hashing |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
CN107463704B (en) | Search method and device based on artificial intelligence | |
US11036791B2 (en) | Computerized system and method for determining non-redundant tags from a user's network activity | |
CN105719001B (en) | Large scale classification in neural networks using hashing | |
US7961986B1 (en) | Ranking of images and image labels | |
US10311096B2 (en) | Online image analysis | |
US8515212B1 (en) | Image relevance model | |
US8880548B2 (en) | Dynamic search interaction | |
US20160253596A1 (en) | Geometry-directed active question selection for question answering systems | |
CN108833458B (en) | Application recommendation method, device, medium and equipment | |
US20200019881A1 (en) | Feature processing method and feature processing system for machine learning | |
US9110923B2 (en) | Ranking over hashes | |
US10909457B2 (en) | Compound model scaling for neural networks | |
Viladomat et al. | Assessing the significance of global and local correlations under spatial autocorrelation: a nonparametric approach | |
US10915586B2 (en) | Search engine for identifying analogies | |
US10592514B2 (en) | Location-sensitive ranking for search and related techniques | |
US20120117043A1 (en) | Measuring Duplication in Search Results | |
US20210248425A1 (en) | Reinforced text representation learning | |
WO2021007159A1 (en) | Identifying entity attribute relations | |
US20230045330A1 (en) | Multi-term query subsumption for document classification | |
US11269896B2 (en) | System and method for automatic difficulty level estimation | |
US9122705B1 (en) | Scoring hash functions | |
US11341138B2 (en) | Method and system for query performance prediction | |
US11663278B2 (en) | Classifying job search queries for improved precision | |
CN109582802B (en) | Entity embedding method, device, medium and equipment | |
US10108722B2 (en) | Stability score based re-ranking of search results |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:IOFFE, SERGEY;REEL/FRAME:028012/0547Effective date: 20120319 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044334/0466Effective date: 20170929 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 4TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1551); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 4 |
|
LAPS | Lapse for failure to pay maintenance fees |
Free format text: PATENT EXPIRED FOR FAILURE TO PAY MAINTENANCE FEES (ORIGINAL EVENT CODE: EXP.); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
STCH | Information on status: patent discontinuation |
Free format text: PATENT EXPIRED DUE TO NONPAYMENT OF MAINTENANCE FEES UNDER 37 CFR 1.362 |
|
FP | Lapsed due to failure to pay maintenance fee |
Effective date: 20230901 |