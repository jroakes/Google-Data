US20230044078A1 - Unified Sample Reweighting Framework for Learning with Noisy Data and for Learning Difficult Examples or Groups - Google Patents
Unified Sample Reweighting Framework for Learning with Noisy Data and for Learning Difficult Examples or Groups Download PDFInfo
- Publication number
- US20230044078A1 US20230044078A1 US17/816,197 US202217816197A US2023044078A1 US 20230044078 A1 US20230044078 A1 US 20230044078A1 US 202217816197 A US202217816197 A US 202217816197A US 2023044078 A1 US2023044078 A1 US 2023044078A1
- Authority
- US
- United States
- Prior art keywords
- training
- divergence
- batch
- machine learning
- learning model
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N20/00—Machine learning
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
Definitions
- Deep neural networks have been quite successful in driving impressive performance gains in several real-world applications. However, this success primarily relies on the availability of clean training data, and overparameterized deep networks have the ability to easily overfit to noisy or corrupted labels. Consequently, training with noisy labels often leads to degradation in generalization performance on clean test data.
- noisy labels can naturally appear in several real world scenarios, such as labels obtained from the internet, noisy human annotations, automatic labels obtained from legacy rule based systems or from machine learned systems trained on obsolete or shifted data distributions, etc. This brings up the need for designing more effective methods for learning with noisy labels.
- a computer-implemented method includes receiving training data for a machine learning model, the training data comprising a plurality of training examples and a corresponding plurality of labels.
- the method further includes dividing the training data into a plurality of training batches.
- the method additionally includes learning a weight for each training example in the training batch that minimizes a sum of weighted losses for the training batch subject to a divergence constraint, where the divergence constraint limits a divergence of the learned weights for the training batch from a reference distribution, where the divergence is determined according to a chosen divergence measure.
- the method also includes training the machine learning model with each training batch of the plurality of training batches using the learned weight for each training example in the training batch.
- the method additionally includes providing the trained machine learning model.
- a computing system comprising one or more processors and a non-transitory computer readable medium storing program instructions executable by the one or more processors to cause performance of operations.
- the operations include receiving training data for a machine learning model, the training data comprising a plurality of training examples and a corresponding plurality of labels.
- the operations further include dividing the training data into a plurality of training batches.
- the operations additionally include learning a weight for each training example in the training batch that minimizes a sum of weighted losses for the training batch subject to a divergence constraint, where the divergence constraint limits a divergence of the learned weights for the training batch from a reference distribution, where the divergence is determined according to a chosen divergence measure.
- the operations also include training the machine learning model with each training batch of the plurality of training batches using the learned weight for each training example in the training batch.
- the operations additionally include providing the trained machine learning model.
- a non-transitory computer readable medium storing program instructions executable by one or more processors to cause performance of operations.
- the operations include receiving training data for a machine learning model, the training data comprising a plurality of training examples and a corresponding plurality of labels.
- the operations further include dividing the training data into a plurality of training batches.
- the operations additionally include learning a weight for each training example in the training batch that minimizes a sum of weighted losses for the training batch subject to a divergence constraint, where the divergence constraint limits a divergence of the learned weights for the training batch from a reference distribution, where the divergence is determined according to a chosen divergence measure.
- the operations also include training the machine learning model with each training batch of the plurality of training batches using the learned weight for each training example in the training batch.
- the operations additionally include providing the trained machine learning model.
- a computing device in another aspect, includes means for receiving training data for a machine learning model, the training data comprising a plurality of training examples and a corresponding plurality of labels.
- the computing device further includes means for dividing the training data into a plurality of training batches. For each training batch of the plurality of training batches, the computing device additionally includes means for learning a weight for each training example in the training batch that minimizes a sum of weighted losses for the training batch subject to a divergence constraint, where the divergence constraint limits a divergence of the learned weights for the training batch from a reference distribution, where the divergence is determined according to a chosen divergence measure.
- the computing device also includes means for training the machine learning model with each training batch of the plurality of training batches using the learned weight for each training example in the training batch.
- the computing device additionally includes means for providing the trained machine learning model.
- a computer-implemented method includes receiving training data for a machine learning model, the training data comprising a plurality of training examples and a corresponding plurality of labels.
- the method further includes dividing the training data into a plurality of training batches.
- the method additionally includes learning a weight for each training example in the training batch that minimizes a sum of weighted losses over model parameters and maximizes the sum of weighted losses over example weights or group weights for the training batch subject to a divergence constraint, where the divergence constraint limits a divergence of the weights for the training batch from a reference distribution, where the divergence is determined according to a chosen divergence measure.
- the method also includes training the machine learning model with each training batch of the plurality of training batches using the learned weight for each training example in the training batch.
- the method additionally includes providing the trained machine learning model.
- FIG. 1 is a diagram illustrating training and inference phases of a machine learning model, in accordance with example embodiments.
- FIG. 2 depicts a distributed computing architecture, in accordance with example embodiments.
- FIG. 3 is a block diagram of a computing device, in accordance with example embodiments.
- FIG. 4 depicts a network of computing clusters arranged as a cloud-based server system, in accordance with example embodiments.
- FIG. 5 is a flowchart of a method, in accordance with example embodiments.
- FIG. 6 is a flowchart of another method, in accordance with example embodiments.
- FIG. 7 illustrates distribution of weights as a function of loss, in accordance with example embodiments.
- FIG. 8 illustrates level sets of weights as a function of loss, in accordance with example embodiments.
- FIG. 9 illustrates a constrained importance reweighting method on a two-layer neural network, in accordance with example embodiments.
- Example methods described herein allow for dynamically assigning importance weights to each instance and class label in a minibatch of training data for use in training a machine learning model, such as a neural network.
- a class of constrained optimization problems is described where the deviation of these importance weights from a reference weight distribution is controlled.
- the reference weight distribution is chosen to be a uniform distribution.
- group prior information indicative of likelihood of label noise may be available for some or all of the training examples, and this group prior information may be leveraged to select a different reference weight distribution.
- the divergence of the importance weights from the reference weight distribution is measured by a divergence measure of choice.
- Simple closed form updates are described for the importance weights for several common divergence measures, such as alpha-divergence, which include KL-divergence and reverse-KL divergence as special cases. Further example methods involve using these importance weights to generate mixed up minibatches of training data for training a machine learning model, yielding significant empirical improvements.
- Some example methods described herein are directed to training a machine learning model such as a neural network when confronted with noisy label data within training data. Such noisy label data may result from inaccurate human annotations and/or inaccurate machine-generated annotations (e.g., legacy rule based systems or machine learned systems trained on obsolete or shifted data distributions). Further example methods described herein are separately directed to training a machine learning model such as a neural network when confronted with training data that includes some particularly difficult examples for which successful model performance is desired. In contrast to earlier described methods which assign weights to account for label noise in training, these further example methods instead assign weights to improve a model's performance on examples which are inherently more difficult for the model to learn.
- example embodiments described herein are directed to scenarios where data can be naturally partitioned into groups.
- a goal in such examples may be to learn a robust classifier that works well on all these groups.
- This grouping information can be available as part of metadata (e.g., face images that have skin or hair color as metadata).
- example embodiments described herein are configured to ensure or encourage equity in the performance of the learned model over different groups, instead of optimizing for the average performance over full dataset. Such examples may therefore accommodate situations where training a model is more difficult for certain groups of training examples as compared to other groups of training examples.
- Example methods described herein may be applied to a wide range of scenarios that may be encountered in the context of machine learning systems.
- Some examples involved supervised machine learning where the training data includes labeled examples.
- Some of the labels may be associated with varying amounts of noise.
- noise may result from human mislabeling.
- noise may result from machine-generated mislabeling.
- inaccurate labels may be generated from applying a legacy heuristics based system or a machine learned system that has been trained on legacy data which has a different distribution than current data.
- existing deployed systems in a variety of applications may provide relevant and necessary training data that is imperfect.
- Some example applications may refer to such training data as “silver” training data, which may be considered less trustworthy than “gold” training data. However, such gold training data may not be easily available in sufficient quantities to allow for machine learning model training.
- Some examples described herein may be incorporated into a system that provides machine learning as a service to users.
- a user may have developed a proposed machine learning model as well as available training data for the model.
- the training data may include enough noise to make traditional training insufficient to provide an accurate trained model.
- the user may be provided with an interface to provide information about a desired model, as well as training examples.
- the system may use the methods described herein to weight instances within training batches of training data in order to train the model in a more accurate way.
- a trained model may then be provided back to the user via the interface as part of the service.
- the interface may prompt the user with additional information to facilitate the training process.
- the user may be prompted for prior accuracy weighting information indicating expected accuracy of different training examples.
- the prior accuracy weighting information may be used to generate a reference weight distribution as described herein.
- the user may be prompted for expected class distribution information, which may be used to help select alpha or a different parameter as described herein.
- Other examples of gathering prior information from a user to facilitate the provision of machine learning as a service are also contemplated.
- Examples described herein may be applied to a variety of underlying machine learning models to be trained. In particular, as long as a loss function can be defined, the process may be agnostic to the model architecture and loss function.
- the examples are further applicable to a variety of types of training data. Some examples described herein involve image data (e.g., classifying objects in images). Some examples described herein further involve mixing up of image data to generate additional training data. For instance, instances within a minibatch for which higher weights are assigned by the methods described herein may be weighted more than other examples when sampling and/or mixing example images for training. Other example applications may instead include video data, audio data, text data, and a variety of alternatives for the training data and input(s) to the machine learning model.
- Some examples described herein may be directed to handling difficult-to-learn examples or difficult-to-learn groups in training data instead of noisy data.
- the specific models and applications for which difficult-to-learn examples or difficult-to-learn groups are a focus may be different than for noisy examples. For instance, in the context of computer vision, if a model is trained to differentiate between pictures of cats and pictures of dogs, the model may have a particularly difficult time differentiating blurry pictures or pictures where the cat or dog appears far in the distance.
- Example methods described herein upgrade the weight assigned to such difficult examples, which may facilitate faster training (e.g., training with less training data needed) of a model.
- Further examples may involve increasing the weight assigned to difficult-to-learn examples or difficult-to-learn groups for other types of training data, such as video data, audio data, or text data.
- a further example involves handling text sentences with negative sentiments that do not use any negative sentiment words in the task of sentiment classification.
- Some examples described herein provide a benefit of trained machine learning models that produce more accurate outputs (e.g., more accurate class labels).
- techniques are described for addressing the problem of label noise in training data. This has a potential to have positive downstream implications in yielding better performing machine learning models.
- Some examples described herein further provide a benefit of reduced memory storage requirements.
- some of the methods described herein do not need to maintain the weights across the whole training set. Accordingly, the methods may be executed with little computational or memory overhead as compared to alternative cross-entropy loss methods. This is an added benefit compared to some alternative methods that need to keep a record of importance weights over the complete training set which results in increased overhead, particularly for large datasets.
- necessary memory storage may be limited to memory storage sufficient to store information about 200 training examples. This benefit may be particularly significant for applications that involve many different types of examples. For instance, an example application may involve one million different types of training examples for which weights may need to be maintained using alternative methods, which may be more computationally expensive and cumbersome as compared to methods described herein.
- Some examples described herein may further provide benefits associated with faster training of a machine learning model. For instance, some such examples may involve prioritizing difficult-to-learn examples or difficult-to-learn groups. By prioritizing difficult-to-learn examples or difficult-to-learn groups, less training data may be needed to train a model. Accordingly, a model may be trained to produce accurate results (e.g., accurate classifications of training examples) with less training data and requiring fewer computations and less computation time to train an associated machine learning model.
- FIG. 1 shows diagram 100 illustrating a training phase 102 and an inference phase 104 of trained machine learning model(s) 132 , in accordance with example embodiments.
- Some machine learning techniques involve training one or more machine learning algorithms, on an input set of training data to recognize patterns in the training data and provide output inferences and/or predictions about (patterns in the) training data.
- the resulting trained machine learning algorithm can be termed as a trained machine learning model.
- FIG. 1 shows training phase 102 where one or more machine learning algorithms 120 are being trained on training data 110 to become trained machine learning model(s) 132 .
- trained machine learning model(s) 132 can receive input data 130 and one or more inference/prediction requests 140 (perhaps as part of input data 130 ) and responsively provide as an output one or more inferences and/or prediction(s) 150 .
- trained machine learning model(s) 132 can include one or more models of one or more machine learning algorithms 120 .
- Machine learning algorithm(s) 120 may include, but are not limited to: an artificial neural network (e.g., a herein-described convolutional neural networks, a recurrent neural network, a Bayesian network, a hidden Markov model, a Markov decision process, a logistic regression function, a support vector machine, a suitable statistical machine learning algorithm, and/or a heuristic machine learning system).
- Machine learning algorithm(s) 120 may be supervised or unsupervised, and may implement any suitable combination of online and offline learning.
- machine learning algorithm(s) 120 and/or trained machine learning model(s) 132 can be accelerated using on-device coprocessors, such as graphic processing units (GPUs), tensor processing units (TPUs), digital signal processors (DSPs), and/or application specific integrated circuits (ASICs).
- on-device coprocessors can be used to speed up machine learning algorithm(s) 120 and/or trained machine learning model(s) 132 .
- trained machine learning model(s) 132 can be trained, reside and execute to provide inferences on a particular computing device, and/or otherwise can make inferences for the particular computing device.
- machine learning algorithm(s) 120 can be trained by providing at least training data 110 as training input using unsupervised, supervised, semi-supervised, and/or reinforcement learning techniques.
- Unsupervised learning involves providing a portion (or all) of training data 110 to machine learning algorithm(s) 120 and machine learning algorithm(s) 120 determining one or more output inferences based on the provided portion (or all) of training data 110 .
- Supervised learning involves providing a portion of training data 110 to machine learning algorithm(s) 120 , with machine learning algorithm(s) 120 determining one or more output inferences based on the provided portion of training data 110 , and the output inference(s) are either accepted or corrected based on correct results associated with training data 110 .
- supervised learning of machine learning algorithm(s) 120 can be governed by a set of rules and/or a set of labels for the training input, and the set of rules and/or set of labels may be used to correct inferences of machine learning algorithm(s) 120 .
- Individual instances of training data 110 may be weighted according to methods described herein.
- Semi-supervised learning involves having correct results for part, but not all, of training data 110 .
- semi-supervised learning supervised learning is used for a portion of training data 110 having correct results
- unsupervised learning is used for a portion of training data 110 not having correct results.
- Reinforcement learning involves machine learning algorithm(s) 120 receiving a reward signal regarding a prior inference, where the reward signal can be a numerical value.
- machine learning algorithm(s) 120 can output an inference and receive a reward signal in response, where machine learning algorithm(s) 120 are configured to try to maximize the numerical value of the reward signal.
- reinforcement learning also utilizes a value function that provides a numerical value representing an expected total of the numerical values provided by the reward signal over time.
- machine learning algorithm(s) 120 and/or trained machine learning model(s) 132 can be trained using other machine learning techniques, including but not limited to, incremental learning and curriculum learning.
- machine learning algorithm(s) 120 and/or trained machine learning model(s) 132 can use transfer learning techniques.
- transfer learning techniques can involve trained machine learning model(s) 132 being pre-trained on one set of data and additionally trained using training data 110 .
- machine learning algorithm(s) 120 can be pre-trained on data from one or more computing devices and a resulting trained machine learning model provided to computing device CD 1 , where CD 1 is intended to execute the trained machine learning model during inference phase 104 . Then, during training phase 102 , the pre-trained machine learning model can be additionally trained using training data 110 , where training data 110 can be derived from kernel and non-kernel data of computing device CD 1 .
- This further training of the machine learning algorithm(s) 120 and/or the pre-trained machine learning model using training data 110 of CD 1 's data can be performed using either supervised or unsupervised learning.
- training phase 102 can be completed.
- the trained resulting machine learning model can be utilized as at least one of trained machine learning model(s) 132 .
- trained machine learning model(s) 132 can be provided to a computing device, if not already on the computing device.
- Inference phase 104 can begin after trained machine learning model(s) 132 are provided to computing device CD 1 .
- trained machine learning model(s) 132 can receive input data 130 and generate and output one or more corresponding inferences and/or prediction(s) 150 about input data 130 .
- input data 130 can be used as an input to trained machine learning model(s) 132 for providing corresponding inference(s) and/or prediction(s) 150 to kernel components and non-kernel components.
- trained machine learning model(s) 132 can generate inference(s) and/or prediction(s) 150 in response to one or more inference/prediction requests 140 .
- trained machine learning model(s) 132 can be executed by a portion of other software.
- trained machine learning model(s) 132 can be executed by an inference or prediction daemon to be readily available to provide inferences and/or predictions upon request.
- Input data 130 can include data from computing device CD 1 executing trained machine learning model(s) 132 and/or input data from one or more computing devices other than CD 1 .
- Input data 130 can include training data described herein. Other types of input data are possible as well.
- Inference(s) and/or prediction(s) 150 can include task outputs, numerical values, and/or other output data produced by trained machine learning model(s) 132 operating on input data 130 (and training data 110 ).
- trained machine learning model(s) 132 can use output inference(s) and/or prediction(s) 150 as input feedback 160 .
- Trained machine learning model(s) 132 can also rely on past inferences as inputs for generating new inferences.
- the trained version of the neural network can be an example of trained machine learning model(s) 132 .
- an example of the one or more inference/prediction request(s) 140 can be a request to predict a classification for an input training example and a corresponding example of inferences and/or prediction(s) 150 can be a predicted classification output.
- individual instances of training data 110 may also have weights assigned for various possible classes as further described herein.
- one computing device CD_SOLO can include the trained version of the neural network, perhaps after training. Then, computing device CD_SOLO can receive a request to predict a task output, and use the trained version of the neural network to predict the task output.
- two or more computing devices CD_CLI and CD_SRV can be used to provide outputs; e.g., a first computing device CD_CLI can generate and send requests to predict a task output to a second computing device CD_SRV. Then, CD_SRV can use the trained version of the neural network, to predict the task output, and respond to the requests from CD_CLI for the output class. Then, upon reception of responses to the requests, CD_CLI can provide the requested output.
- FIG. 2 depicts a distributed computing architecture 200 , in accordance with example embodiments.
- Distributed computing architecture 200 includes server devices 208 , 210 that are configured to communicate, via network 206 , with programmable devices 204 a , 204 b , 204 c , 204 d , 204 e .
- Network 206 may correspond to a local area network (LAN), a wide area network (WAN), a WLAN, a WWAN, a corporate intranet, the public Internet, or any other type of network configured to provide a communications path between networked computing devices.
- Network 206 may also correspond to a combination of one or more LANs, WANs, corporate intranets, and/or the public Internet.
- FIG. 2 only shows five programmable devices, distributed application architectures may serve tens, hundreds, or thousands of programmable devices.
- programmable devices 204 a , 204 b , 204 c , 204 d , 204 e may be any sort of computing device, such as a mobile computing device, desktop computer, wearable computing device, head-mountable device (HMD), network terminal, a mobile computing device, and so on.
- HMD head-mountable device
- programmable devices can be directly connected to network 206 .
- programmable devices can be indirectly connected to network 206 via an associated computing device, such as programmable device 204 c .
- programmable device 204 c can act as an associated computing device to pass electronic communications between programmable device 204 d and network 206 .
- a computing device can be part of and/or inside a vehicle, such as a car, a truck, a bus, a boat or ship, an airplane, etc.
- a programmable device can be both directly and indirectly connected to network 206 .
- Server devices 208 , 210 can be configured to perform one or more services, as requested by programmable devices 204 a - 204 e .
- server device 208 and/or 210 can provide content to programmable devices 204 a - 204 e .
- the content can include, but is not limited to, web pages, hypertext, scripts, binary data such as compiled software, images, audio, and/or video.
- the content can include compressed and/or uncompressed content.
- the content can be encrypted and/or unencrypted. Other types of content are possible as well.
- Some examples described herein involve machine learning content, such as a trained machine learning model provided as part of machine learning as a service.
- server device 208 and/or 210 can provide programmable devices 204 a - 204 e with access to software for database, search, computation, graphical, audio, video, World Wide Web/Internet utilization, and/or other functions. Many other examples of server devices are possible as well.
- FIG. 3 is a block diagram of an example computing device 300 , in accordance with example embodiments.
- computing device 300 shown in FIG. 3 can be configured to perform at least one function of and/or related to trained machine learning model(s) 132 , and/or method 500 or method 600 .
- Computing device 300 may include a user interface module 301 , a network communications module 302 , one or more processors 303 , data storage 304 , one or more camera(s) 318 , one or more sensors 320 , and power system 322 , all of which may be linked together via a system bus, network, or other connection mechanism 305 .
- User interface module 301 can be operable to send data to and/or receive data from external user input/output devices.
- user interface module 301 can be configured to send and/or receive data to and/or from user input devices such as a touch screen, a computer mouse, a keyboard, a keypad, a touch pad, a trackball, a joystick, a voice recognition module, and/or other similar devices.
- User interface module 301 can also be configured to provide output to user display devices, such as one or more cathode ray tubes (CRT), liquid crystal displays, light emitting diodes (LEDs), displays using digital light processing (DLP) technology, printers, light bulbs, and/or other similar devices, either now known or later developed.
- CTR cathode ray tubes
- LEDs light emitting diodes
- DLP digital light processing
- User interface module 301 can also be configured to generate audible outputs, with devices such as a speaker, speaker jack, audio output port, audio output device, earphones, and/or other similar devices. User interface module 301 can further be configured with one or more haptic devices that can generate haptic outputs, such as vibrations and/or other outputs detectable by touch and/or physical contact with computing device 300 . In some examples, user interface module 301 can be used to provide a graphical user interface (GUI) for utilizing computing device 300 , such as, for example, a graphical user interface of a mobile phone device.
- GUI graphical user interface
- Network communications module 302 can include one or more devices that provide one or more wireless interface(s) 307 and/or one or more wireline interface(s) 308 that are configurable to communicate via a network.
- Wireless interface(s) 307 can include one or more wireless transmitters, receivers, and/or transceivers, such as a BluetoothTM transceiver, a Zigbee® transceiver, a Wi-FiTM transceiver, a WiMAXTM transceiver, an LTETM transceiver, and/or other type of wireless transceiver configurable to communicate via a wireless network.
- Wireline interface(s) 308 can include one or more wireline transmitters, receivers, and/or transceivers, such as an Ethernet transceiver, a Universal Serial Bus (USB) transceiver, or similar transceiver configurable to communicate via a twisted pair wire, a coaxial cable, a fiber-optic link, or a similar physical connection to a wireline network.
- wireline transmitters such as an Ethernet transceiver, a Universal Serial Bus (USB) transceiver, or similar transceiver configurable to communicate via a twisted pair wire, a coaxial cable, a fiber-optic link, or a similar physical connection to a wireline network.
- USB Universal Serial Bus
- network communications module 302 can be configured to provide reliable, secured, and/or authenticated communications.
- information for facilitating reliable communications e.g., guaranteed message delivery
- a message header and/or footer e.g., packet/message sequencing information, encapsulation headers and/or footers, size/time information, and transmission verification information such as cyclic redundancy check (CRC) and/or parity check values.
- CRC cyclic redundancy check
- Communications can be made secure (e.g., be encoded or encrypted) and/or decrypted/decoded using one or more cryptographic protocols and/or algorithms, such as, but not limited to, Data Encryption Standard (DES), Advanced Encryption Standard (AES), a Rivest-Shamir-Adelman (RSA) algorithm, a Diffie-Hellman algorithm, a secure sockets protocol such as Secure Sockets Layer (SSL) or Transport Layer Security (TLS), and/or Digital Signature Algorithm (DSA).
- DES Data Encryption Standard
- AES Advanced Encryption Standard
- RSA Rivest-Shamir-Adelman
- Diffie-Hellman algorithm a secure sockets protocol
- SSL Secure Sockets Layer
- TLS Transport Layer Security
- DSA Digital Signature Algorithm
- Other cryptographic protocols and/or algorithms can be used as well or in addition to those listed herein to secure (and then decrypt/decode) communications.
- One or more processors 303 can include one or more general purpose processors, and/or one or more special purpose processors (e.g., digital signal processors, tensor processing units (TPUs), graphics processing units (GPUs), application specific integrated circuits, etc.).
- processors 303 can be configured to execute computer-readable instructions 306 that are contained in data storage 304 and/or other instructions as described herein.
- Data storage 304 can include one or more non-transitory computer-readable storage media that can be read and/or accessed by at least one of one or more processors 303 .
- the one or more computer-readable storage media can include volatile and/or non-volatile storage components, such as optical, magnetic, organic or other memory or disc storage, which can be integrated in whole or in part with at least one of one or more processors 303 .
- data storage 304 can be implemented using a single physical device (e.g., one optical, magnetic, organic or other memory or disc storage unit), while in other examples, data storage 304 can be implemented using two or more physical devices.
- Data storage 304 can include computer-readable instructions 306 and perhaps additional data.
- data storage 304 can include storage required to perform at least part of the herein-described methods, scenarios, and techniques and/or at least part of the functionality of the herein-described devices and networks.
- data storage 304 can include storage for a trained neural network model 312 (e.g., a model of trained neural networks such as trained machine learning model(s) 132 ).
- computer-readable instructions 306 can include instructions that, when executed by one or more processors 903 , enable computing device 300 to provide for some or all of the functionality of trained neural network model 312 .
- computing device 300 can include one or more camera(s) 318 .
- Camera(s) 318 can include one or more image capture devices, such as still and/or video cameras, equipped to capture light and record the captured light in one or more images; that is, camera(s) 318 can generate image(s) of captured light.
- the one or more images can be one or more still images and/or one or more images utilized in video imagery.
- Camera(s) 318 can capture light and/or electromagnetic radiation emitted as visible light, infrared radiation, ultraviolet light, and/or as one or more other frequencies of light.
- computing device 300 can include one or more sensors 320 .
- Sensors 320 can be configured to measure conditions within computing device 300 and/or conditions in an environment of computing device 300 and provide data about these conditions.
- sensors 320 can include one or more of: (i) sensors for obtaining data about computing device 300 , such as, but not limited to, a thermometer for measuring a temperature of computing device 300 , a battery sensor for measuring power of one or more batteries of power system 322 , and/or other sensors measuring conditions of computing device 300 ; (ii) an identification sensor to identify other objects and/or devices, such as, but not limited to, a Radio Frequency Identification (RFID) reader, proximity sensor, one-dimensional barcode reader, two-dimensional barcode (e.g., Quick Response (QR) code) reader, and a laser tracker, where the identification sensors can be configured to read identifiers, such as RFID tags, barcodes, QR codes, and/or other devices and/or object configured to be read and provide at least identifying information; (i)
- Power system 322 can include one or more batteries 324 and/or one or more external power interfaces 326 for providing electrical power to computing device 300 .
- Each battery of the one or more batteries 324 can, when electrically coupled to the computing device 300 , act as a source of stored electrical power for computing device 300 .
- One or more batteries 324 of power system 322 can be configured to be portable. Some or all of one or more batteries 324 can be readily removable from computing device 300 . In other examples, some or all of one or more batteries 324 can be internal to computing device 300 , and so may not be readily removable from computing device 300 . Some or all of one or more batteries 324 can be rechargeable.
- a rechargeable battery can be recharged via a wired connection between the battery and another power supply, such as by one or more power supplies that are external to computing device 300 and connected to computing device 300 via the one or more external power interfaces.
- one or more batteries 324 can be non-rechargeable batteries.
- One or more external power interfaces 326 of power system 322 can include one or more wired-power interfaces, such as a USB cable and/or a power cord, that enable wired electrical power connections to one or more power supplies that are external to computing device 300 .
- One or more external power interfaces 326 can include one or more wireless power interfaces, such as a Qi wireless charger, that enable wireless electrical power connections, such as via a Qi wireless charger, to one or more external power supplies.
- computing device 300 can draw electrical power from the external power source the established electrical power connection.
- power system 322 can include related sensors, such as battery sensors associated with the one or more batteries or other types of electrical power sensors.
- FIG. 4 depicts a cloud-based server system in accordance with an example embodiment.
- functionality of a neural network, and/or a computing device can be distributed among computing clusters 409 a , 409 b , 409 c .
- Computing cluster 409 a can include one or more computing devices 400 a , cluster storage arrays 44 a , and cluster routers 411 a connected by a local cluster network 412 a .
- computing cluster 409 b can include one or more computing devices 400 b , cluster storage arrays 44 b , and cluster routers 411 b connected by a local cluster network 412 b .
- computing cluster 409 c can include one or more computing devices 400 c , cluster storage arrays 44 c , and cluster routers 411 c connected by a local cluster network 412 c.
- computing clusters 409 a , 409 b , 409 c can be a single computing device residing in a single computing center. In other embodiments, computing clusters 409 a , 409 b , 409 c can include multiple computing devices in a single computing center, or even multiple computing devices located in multiple computing centers located in diverse geographic locations. For example, FIG. 4 depicts each of computing clusters 409 a , 409 b , 409 c residing in different physical locations.
- data and services at computing clusters 409 a , 409 b , 409 c can be encoded as computer readable information stored in non-transitory, tangible computer readable media (or computer readable storage media) and accessible by other computing devices.
- computing clusters 409 a , 409 b , 409 c can be stored on a single disk drive or other tangible storage media, or can be implemented on multiple disk drives or other tangible storage media located at one or more diverse geographic locations.
- each of computing clusters 409 a , 409 b , and 409 c can have an equal number of computing devices, an equal number of cluster storage arrays, and an equal number of cluster routers. In other embodiments, however, each computing cluster can have different numbers of computing devices, different numbers of cluster storage arrays, and different numbers of cluster routers. The number of computing devices, cluster storage arrays, and cluster routers in each computing cluster can depend on the computing task or tasks assigned to each computing cluster.
- computing devices 400 a can be configured to perform various computing tasks of a conditioned, axial self-attention based neural network, and/or a computing device.
- the various functionalities of a neural network, and/or a computing device can be distributed among one or more of computing devices 400 a , 400 b , 400 c .
- Computing devices 400 b and 400 c in respective computing clusters 409 b and 409 c can be configured similarly to computing devices 400 a in computing cluster 409 a .
- computing devices 400 a , 400 b , and 400 c can be configured to perform different functions.
- computing tasks and stored data associated with a neural network, and/or a computing device can be distributed across computing devices 400 a , 400 b , and 400 c based at least in part on the processing requirements of a neural network, and/or a computing device, the processing capabilities of computing devices 400 a , 400 b , 400 c , the latency of the network links between the computing devices in each computing cluster and between the computing clusters themselves, and/or other factors that can contribute to the cost, speed, fault-tolerance, resiliency, efficiency, and/or other design goals of the overall system architecture.
- Cluster storage arrays 44 a , 44 b , 44 c of computing clusters 409 a , 409 b , 409 c can be data storage arrays that include disk array controllers configured to manage read and write access to groups of hard disk drives.
- the disk array controllers alone or in conjunction with their respective computing devices, can also be configured to manage backup or redundant copies of the data stored in the cluster storage arrays to protect against disk drive or other cluster storage array failures and/or network failures that prevent one or more computing devices from accessing one or more cluster storage arrays.
- cluster storage arrays 410 a , 410 b , 410 c can be configured to store one portion of the data of a first layer of a neural network, and/or a computing device, while other cluster storage arrays can store other portion(s) of data of second layer of a neural network, and/or a computing device.
- some cluster storage arrays can be configured to store the data of an encoder of a neural network, while other cluster storage arrays can store the data of a decoder of a neural network. Additionally, some cluster storage arrays can be configured to store backup versions of data stored in other cluster storage arrays.
- Cluster routers 411 a , 411 b , 411 c in computing clusters 409 a , 409 b , 409 c can include networking equipment configured to provide internal and external communications for the computing clusters.
- cluster routers 411 a in computing cluster 409 a can include one or more internet switching and routing devices configured to provide (i) local area network communications between computing devices 400 a and cluster storage arrays 410 a via local cluster network 412 a , and (ii) wide area network communications between computing cluster 409 a and computing clusters 409 b and 409 c via wide area network link 413 a to network 406 .
- Cluster routers 411 b and 411 c can include network equipment similar to cluster routers 411 a , and cluster routers 411 b and 411 c can perform similar networking functions for computing clusters 409 b and 409 b that cluster routers 411 a perform for computing cluster 409 a.
- the configuration of cluster routers 411 a , 411 b , 411 c can be based at least in part on the data communication requirements of the computing devices and cluster storage arrays, the data communications capabilities of the network equipment in cluster routers 411 a , 411 b , 411 c , the latency and throughput of local cluster networks 412 a , 412 b , 412 c , the latency, throughput, and cost of wide area network links 413 a , 413 b , 413 c , and/or other factors that can contribute to the cost, speed, fault-tolerance, resiliency, efficiency and/or other design criteria of the moderation system architecture.
- FIG. 5 is a flowchart of a method 500 , in accordance with example embodiments.
- Method 500 can be executed by a computing device, such as server device 208 - 210 or computing device 300 .
- Method 500 can begin at block 510 , where the computing device receives training data for a machine learning model.
- the training data includes a plurality of training examples and a corresponding plurality of labels.
- the training data includes noisy labels.
- the computing device divides the training data into a plurality of training batches.
- Each training batch may include a portion of the training examples and corresponding labels.
- the training batches may be minibatches which are one or more orders of magnitude smaller in size than the entire training data.
- the computing device learns, for each training batch of the plurality of training batches, a weight for each training example in the batch. For each training batch, the learned weights minimize a sum of weighted losses for the training batch subject to a divergence constraint, where the divergence constraint limits a divergence of the learned weights for the training batch from a reference distribution. The divergence may be determined according to a chosen divergence measure. In some examples, for each training batch of the plurality of training batches, the divergence constraint limits the divergence of the learned weight for the training batch from the reference distribution to be within a delta value. In some examples, the delta value is a hyperparameter that is tuned while training the machine learning model.
- the reference distribution is a uniform distribution assigning an equal weight to each training example within each training batch. Some examples further involve receiving group prior information indicative of likelihood of label noise for a group of training examples within a particular training batch, and determining the reference distribution for the particular training batch based on the group prior information.
- the chosen divergence measure comprises an ⁇ -divergence measure. In some examples, the chosen divergence measure comprises a KL-divergence measure. In some examples, the chosen divergence measure comprises a reverse KL-divergence measure. In some examples, the chosen divergence measure comprises an alpha-divergence measure.
- the computing device learns, for each training batch of the plurality of training batches, the weight for each training example in the training batch by learning a class weight for each class of a plurality of classes for each training example in the training batch. In some examples, the computing device learns, for each training batch of the plurality of training batches, the weight for each training example in the training batch that minimizes the sum of weighted losses for the training batch subject to a class divergence constraint.
- the class divergence constraint limits a class divergence of the class weight determined for each class of the plurality of classes for each training example in the training batch from a one-hot vector that assigns full weight to a single class.
- the class divergence is measured using a total variation distance. In some examples, the class divergence is measured using a squared L2-distance.
- the computing device trains the machine learning model with each training batch of the plurality of training batches using the learned weight for each training example in the training batch.
- the computing devices discards from a computer memory, for each training batch of the plurality of training batches, the weight learned for each training example in the training batch after training the machine learning model with the training batch.
- the computing device provides the trained machine learning model.
- Some examples further involve the computing device using the weight learned for each training example in a particular training batch for mixing training examples from the particular training batch to create a mixed up minibatch for training the machine learning model. Some examples further involve the computing device using the weight learned for each training example in the particular training batch for sampling training examples from the particular training batch to create the mixed up minibatch for training the machine learning model. In some examples, the mixed up minibatch is used to train the machine learning model for processing images.
- FIG. 6 is a flowchart of a method 600 , in accordance with example embodiments.
- Method 600 can be executed by a computing device, such as server device 208 - 210 or computing device 300 .
- Method 600 can begin at block 610 , where the computing device receives training data for a machine learning model.
- the training data includes a plurality of training examples and a corresponding plurality of labels.
- the training data includes hard-to-learn examples that can be prioritized to optimize training of the machine learning model.
- the computing device divides the training data into a plurality of training batches.
- Each training batch may include a portion of the training examples and corresponding labels.
- the training batches may be minibatches which are one or more orders of magnitude smaller than the entire training data.
- the computing device learns, for each training batch of the plurality of training batches, a weight for each training example in the training batch.
- the learned weights minimize a sum of weighted losses over model parameters and maximize the sum of weighted losses over example weights or group weights for the training batch subject to a divergence constraint, where the divergence constraint limits a divergence of the learned weights for the training batch from a reference distribution.
- the divergence may be determined according to a chosen divergence measure.
- the divergence constraint limits the divergence of the learned weights for the training batch from the reference distribution to be within a delta value.
- the delta value is a hyperparameter that is tuned while training the machine learning model.
- the reference distribution is a uniform distribution assigning an equal weight to each training example within each training batch. Some examples further involve receiving group prior information indicative of likelihood of label noise for a group of training examples within a particular training batch, and determining the reference distribution for the particular training batch based on the group prior information.
- the chosen divergence measure comprises an ⁇ -divergence measure. In some examples, the chosen divergence measure comprises a KL-divergence measure. In some examples, the chosen divergence measure comprises a reverse KL-divergence measure. In some examples, the chosen divergence measure comprises an alpha-divergence measure.
- the computing device learns, for each training batch of the plurality of training batches, the weight for each training example in the training batch by learning a class weight for each class of a plurality of classes for each training example in the training batch. In some examples, the computing device learns, for each batch of the plurality of batches, the weight for each training example in the training batch that minimizes the sum of weighted losses for the training batch subject to a class divergence constraint.
- the class divergence constraint limits a class divergence of the class weight determined for each class of the plurality of classes for each training example in the training batch from a one-hot vector that assigns full weight to a single class.
- the class divergence is measured using a total variation distance. In some examples, the class divergence is measured using a squared L2-distance.
- the computing device trains the machine learning model with each training batch of the plurality of training batches using the learned weight for each training example in the training batch.
- the computing devices discards from a computer memory, for each batch of the plurality of training batches, the weight determined for each training example in the training batch after training the machine learning model with the training batch.
- the computing device provides the trained machine learning model.
- Examples described herein involve the classic supervised learning regime (although it is possible to extend the method to other settings such as semi-supervised learning).
- x i ⁇ d we use x i ⁇ d to denote ith training example with its corresponding annotated label y i ⁇ ⁇ 1, . . . , K ⁇ , and use ⁇ to denote model parameters.
- L(x i , y i , ⁇ )>0 be the loss for ith example, for which we will use a shorthand of L(x i , ⁇ ) for simplicity of notation.
- an unknown subset of the training examples has noisy labels (i.e., y i is not the true class).
- D( ⁇ , ⁇ ) is a divergence measure of choice and u denotes the uniform distribution.
- h ⁇ ( ⁇ , ⁇ , v ) min w ⁇ i w i ⁇ L ⁇ ( x i , ⁇ ) + ⁇ ⁇ ( D ⁇ ( w , u ) - ⁇ ) + ⁇ ⁇ ( ⁇ i w i - 1 ) - ⁇ i v i ⁇ w i .
- the Lagrange multipliers ⁇ , ⁇ , and ⁇ i are such that the constraints are satisfied.
- the problem (1) over a single minibatch, there is no extra overhead of maintaining the importance weights over entire training data or across the training iterations.
- KL-divergence belongs to both ⁇ -divergence and Bregman divergence family, and is given by
- Reverse-KL divergence also belongs to both ⁇ -divergence and Bregman divergence family, and is given by
- ⁇ -divergence parameterized by ⁇ ⁇ is a class of ⁇ -divergence which is commonly used in machine learning.
- the ⁇ -divergence is induced by the generating convex function
- Equation (7) can alternatively be viewed in the form of a generalized softmax function. Using the definition of the generalized exponential function
- w i exp ( 2 - ⁇ ) ( - L ⁇ ( x i , ⁇ ) ⁇ ) ⁇ j exp ( 2 - ⁇ ) ( - L ⁇ ( x j , ⁇ ) ⁇ ) .
- FIG. 7 illustrates distribution of weights as a function of loss.
- FIG. 8 illustrates level sets of the weight of an example as a function of its loss in a batch size of 2, where the loss of the other example is fixed to 2.5.
- the level sets are asymmetric across the center line. Also, the level sets become denser along a vertical slice for larger ⁇ , as the distribution becomes less smooth.
- the level sets are again asymmetric across the center line and become denser for smaller ⁇ .
- Our importance reweighting approach is able to successfully rectify the decision boundary by emphasizing on the clean examples in each batch while downweighting the noisy ones.
- FIG. 9 shows our proposed constrained importance reweighting method on a two-layer neural network.
- Plot (a) shows the decision boundary at the beginning of training.
- Plot (b) shows the decision boundary of the baseline model after 6 epochs.
- Plot (c) shows the decision boundary of the baseline model after 20 epochs.
- the large loss of the misclassified noisy examples causes the model to eventually overfit to noise.
- Plot (d) shows a random mini-batch of examples at epoch 6 .
- the baseline model treats these examples as equally important.
- Plot (e) shows the same mini-batch of examples reweighted by our proposed approach (with size of each example indicating its importance).
- Plot (f) shows that b activating the proposed instance reweighting at epoch 6 , the model is able to fit well to the geometry of the data at epoch 20 .
- index i runs over the examples in the minibatch
- index j runs over all the classes
- u is the uniform distribution over examples
- ⁇ ij is the weight for class j for ith example
- e i is the one-hot vector with 1 in the position of annotated class of ith example (i.e., y i ). Since the inner problem for every example is independent of others, we first solve each inner problem independently to get class weights ⁇ and fix them before computing instance weights w using the earlier described closed-form solutions. Next, we consider some special cases for divergence D 2 and derive updates for class weights.
- the effective inner loss in objective (10) is a convex combination of the two losses: loss of the annotated class y i and loss of the predicted class ⁇ i . It can be shown that similar weighting of the two losses, with weights given by (1 ⁇ g( ⁇ )) and g( ⁇ ) for some nonnegative function g, are obtained if we take D 2 ( ⁇ , ⁇ ) to be ⁇ , distance, reverse-KL divergence, or reverse ⁇ -divergence. Since the reference distribution for class reweighting, e i , is one-hot, the ratio divergences such as ⁇ -divergences will result in one-hot ⁇ for any finite ⁇ . However, it is possible to do label smoothing so that e i has support over all classes and then use ⁇ -divergences. This will result in a loss-adaptive version of label smoothing.
- the number of candidate solutions are ⁇ tilde over (y) ⁇ and the correct solution can be identified by checking certain conditions.
- X ⁇ n ⁇ d denote a training minibatch of n examples.
- the labels are also obtained by same mixing proportions.
- Mixup-base Simply compute the base loss L(x i (m) , y i (m) , ⁇ ) for each mixed up example (x i (m) , y i (m) ) and use the average loss
- D ( ⁇ , ⁇ ) is a divergence measure of choice (e.g., KL) and ⁇ is a scalar radius parameter that is fixed a priori or can be varied as learning proceeds. If we take D ( ⁇ , ⁇ ) to be KL or reverse KL divergence as earlier, the updates have similar form. Specifically, for KL divergence, we can write optimal w i in terms of Lagrange multipliers as
- w i exp ⁇ ( - L ⁇ ( x i , ⁇ ) ⁇ ⁇ ( n - 1 ) ) ⁇ j exp ⁇ ( - L ⁇ ( x j , ⁇ ) ⁇ ⁇ ( n - 1 ) )
- the Lagrange multiplier ⁇ will take value to ensure L(x i , ⁇ )+ ⁇ 0 so that w i ⁇ 0.
- optimal weights for problem (13) will be
- this prior can be incorporated in our sample reweighting framework by modifying the uniform prior over examples to a more suitable distribution. For example, if certain group or class is believed to have less amount of label noise, the prior can be modified to be ⁇ tilde over ( ⁇ ) ⁇ with
- k is the total number of groups
- g is a discrete distribution over groups (to be learned)
- ⁇ is a prior distribution over groups (e.g., uniform)
- D ( ⁇ , ⁇ ) is a divergence measure of choice (e.g., KL)
- ⁇ is a scalar radius parameter that is fixed a priori or can be varied as learning proceeds.
- ELM empirical risk minimization
- each block and/or communication may represent a processing of information and/or a transmission of information in accordance with example embodiments.
- Alternative embodiments are included within the scope of these example embodiments.
- functions described as blocks, transmissions, communications, requests, responses, and/or messages may be executed out of order from that shown or discussed, including substantially concurrent or in reverse order, depending on the functionality involved.
- more or fewer blocks and/or functions may be used with any of the ladder diagrams, scenarios, and flow charts discussed herein, and these ladder diagrams, scenarios, and flow charts may be combined with one another, in part or in whole.
- a block that represents a processing of information may correspond to circuitry that can be configured to perform the specific logical functions of a herein-described method or technique.
- a block that represents a processing of information may correspond to a module, a segment, or a portion of program code (including related data).
- the program code may include one or more instructions executable by a processor for implementing specific logical functions or actions in the method or technique.
- the program code and/or related data may be stored on any type of computer readable medium such as a storage device including a disk or hard drive or other storage medium.
- the computer readable medium may also include non-transitory computer readable media such as non-transitory computer-readable media that stores data for short periods of time like register memory, processor cache, and random access memory (RAM).
- the computer readable media may also include non-transitory computer readable media that stores program code and/or data for longer periods of time, such as secondary or persistent long term storage, like read only memory (ROM), optical or magnetic disks, compact-disc read only memory (CD-ROM), for example.
- the computer readable media may also be any other volatile or non-volatile storage systems.
- a computer readable medium may be considered a computer readable storage medium, for example, or a tangible storage device.
- a block that represents one or more information transmissions may correspond to information transmissions between software and/or hardware modules in the same physical device. However, other information transmissions may be between software modules and/or hardware modules in different physical devices.
Abstract
A method includes receiving training data for a machine learning model, the training data comprising a plurality of training examples and a corresponding plurality of labels. The method further includes dividing the training data into a plurality of training batches. For each training batch of the plurality of training batches, the method additionally includes learning a weight for each training example in the training batch that minimizes a sum of weighted losses for the training batch subject to a divergence constraint, where the divergence constraint limits a divergence of the learned weights for the training batch from a reference distribution, where the divergence is determined according to a chosen divergence measure. The method also includes training the machine learning model with each training batch of the plurality of training batches using the learned weight for each training example in the training batch. The method additionally includes providing the trained machine learning model.
Description
- The present application is a non-provisional patent application claiming priority to U.S. Provisional Patent Application No. 63/227,390, filed Jul. 30, 2021, the contents of which are hereby incorporated by reference.
- Deep neural networks have been quite successful in driving impressive performance gains in several real-world applications. However, this success primarily relies on the availability of clean training data, and overparameterized deep networks have the ability to easily overfit to noisy or corrupted labels. Consequently, training with noisy labels often leads to degradation in generalization performance on clean test data. Unfortunately, noisy labels can naturally appear in several real world scenarios, such as labels obtained from the internet, noisy human annotations, automatic labels obtained from legacy rule based systems or from machine learned systems trained on obsolete or shifted data distributions, etc. This brings up the need for designing more effective methods for learning with noisy labels.
- In one aspect, a computer-implemented method is provided. The method includes receiving training data for a machine learning model, the training data comprising a plurality of training examples and a corresponding plurality of labels. The method further includes dividing the training data into a plurality of training batches. For each training batch of the plurality of training batches, the method additionally includes learning a weight for each training example in the training batch that minimizes a sum of weighted losses for the training batch subject to a divergence constraint, where the divergence constraint limits a divergence of the learned weights for the training batch from a reference distribution, where the divergence is determined according to a chosen divergence measure. The method also includes training the machine learning model with each training batch of the plurality of training batches using the learned weight for each training example in the training batch. The method additionally includes providing the trained machine learning model.
- In another aspect, a computing system is disclosed comprising one or more processors and a non-transitory computer readable medium storing program instructions executable by the one or more processors to cause performance of operations. The operations include receiving training data for a machine learning model, the training data comprising a plurality of training examples and a corresponding plurality of labels. The operations further include dividing the training data into a plurality of training batches. For each training batch of the plurality of training batches, the operations additionally include learning a weight for each training example in the training batch that minimizes a sum of weighted losses for the training batch subject to a divergence constraint, where the divergence constraint limits a divergence of the learned weights for the training batch from a reference distribution, where the divergence is determined according to a chosen divergence measure. The operations also include training the machine learning model with each training batch of the plurality of training batches using the learned weight for each training example in the training batch. The operations additionally include providing the trained machine learning model.
- In another aspect, a non-transitory computer readable medium storing program instructions executable by one or more processors is provided to cause performance of operations. The operations include receiving training data for a machine learning model, the training data comprising a plurality of training examples and a corresponding plurality of labels. The operations further include dividing the training data into a plurality of training batches. For each training batch of the plurality of training batches, the operations additionally include learning a weight for each training example in the training batch that minimizes a sum of weighted losses for the training batch subject to a divergence constraint, where the divergence constraint limits a divergence of the learned weights for the training batch from a reference distribution, where the divergence is determined according to a chosen divergence measure. The operations also include training the machine learning model with each training batch of the plurality of training batches using the learned weight for each training example in the training batch. The operations additionally include providing the trained machine learning model.
- In another aspect, a computing device is provided. The computing device includes means for receiving training data for a machine learning model, the training data comprising a plurality of training examples and a corresponding plurality of labels. The computing device further includes means for dividing the training data into a plurality of training batches. For each training batch of the plurality of training batches, the computing device additionally includes means for learning a weight for each training example in the training batch that minimizes a sum of weighted losses for the training batch subject to a divergence constraint, where the divergence constraint limits a divergence of the learned weights for the training batch from a reference distribution, where the divergence is determined according to a chosen divergence measure. The computing device also includes means for training the machine learning model with each training batch of the plurality of training batches using the learned weight for each training example in the training batch. The computing device additionally includes means for providing the trained machine learning model.
- In another aspect, a computer-implemented method is provided. The method includes receiving training data for a machine learning model, the training data comprising a plurality of training examples and a corresponding plurality of labels. The method further includes dividing the training data into a plurality of training batches. For each training batch of the plurality of training batches, the method additionally includes learning a weight for each training example in the training batch that minimizes a sum of weighted losses over model parameters and maximizes the sum of weighted losses over example weights or group weights for the training batch subject to a divergence constraint, where the divergence constraint limits a divergence of the weights for the training batch from a reference distribution, where the divergence is determined according to a chosen divergence measure. The method also includes training the machine learning model with each training batch of the plurality of training batches using the learned weight for each training example in the training batch. The method additionally includes providing the trained machine learning model.
- The foregoing summary is illustrative only and is not intended to be in any way limiting. In addition to the illustrative aspects, embodiments, and features described above, further aspects, embodiments, and features will become apparent by reference to the figures and the following detailed description and the accompanying drawings.
- The patent or application file contains at least one drawing executed in color. Copies of this patent or patent application publication with color drawing(s) will be provided by the Office upon request and payment of the necessary fee.
-
FIG. 1 is a diagram illustrating training and inference phases of a machine learning model, in accordance with example embodiments. -
FIG. 2 depicts a distributed computing architecture, in accordance with example embodiments. -
FIG. 3 is a block diagram of a computing device, in accordance with example embodiments. -
FIG. 4 depicts a network of computing clusters arranged as a cloud-based server system, in accordance with example embodiments. -
FIG. 5 is a flowchart of a method, in accordance with example embodiments. -
FIG. 6 is a flowchart of another method, in accordance with example embodiments. -
FIG. 7 illustrates distribution of weights as a function of loss, in accordance with example embodiments. -
FIG. 8 illustrates level sets of weights as a function of loss, in accordance with example embodiments. -
FIG. 9 illustrates a constrained importance reweighting method on a two-layer neural network, in accordance with example embodiments. - Example methods described herein allow for dynamically assigning importance weights to each instance and class label in a minibatch of training data for use in training a machine learning model, such as a neural network. A class of constrained optimization problems is described where the deviation of these importance weights from a reference weight distribution is controlled. In some examples, the reference weight distribution is chosen to be a uniform distribution. In other examples, group prior information indicative of likelihood of label noise may be available for some or all of the training examples, and this group prior information may be leveraged to select a different reference weight distribution. The divergence of the importance weights from the reference weight distribution is measured by a divergence measure of choice. Simple closed form updates are described for the importance weights for several common divergence measures, such as alpha-divergence, which include KL-divergence and reverse-KL divergence as special cases. Further example methods involve using these importance weights to generate mixed up minibatches of training data for training a machine learning model, yielding significant empirical improvements.
- Some example methods described herein are directed to training a machine learning model such as a neural network when confronted with noisy label data within training data. Such noisy label data may result from inaccurate human annotations and/or inaccurate machine-generated annotations (e.g., legacy rule based systems or machine learned systems trained on obsolete or shifted data distributions). Further example methods described herein are separately directed to training a machine learning model such as a neural network when confronted with training data that includes some particularly difficult examples for which successful model performance is desired. In contrast to earlier described methods which assign weights to account for label noise in training, these further example methods instead assign weights to improve a model's performance on examples which are inherently more difficult for the model to learn.
- Further examples described herein are directed to scenarios where data can be naturally partitioned into groups. A goal in such examples may be to learn a robust classifier that works well on all these groups. This grouping information can be available as part of metadata (e.g., face images that have skin or hair color as metadata). In such cases, example embodiments described herein are configured to ensure or encourage equity in the performance of the learned model over different groups, instead of optimizing for the average performance over full dataset. Such examples may therefore accommodate situations where training a model is more difficult for certain groups of training examples as compared to other groups of training examples.
- Example methods described herein may be applied to a wide range of scenarios that may be encountered in the context of machine learning systems. Some examples involved supervised machine learning where the training data includes labeled examples. Some of the labels may be associated with varying amounts of noise. In the multi-class setting, it may be necessary to classify examples among multiple different classes (e.g., identifying images of dogs vs images of cats). In some examples, noise may result from human mislabeling. In other examples, noise may result from machine-generated mislabeling. For instance, inaccurate labels may be generated from applying a legacy heuristics based system or a machine learned system that has been trained on legacy data which has a different distribution than current data. In general, existing deployed systems in a variety of applications may provide relevant and necessary training data that is imperfect. Some example applications may refer to such training data as “silver” training data, which may be considered less trustworthy than “gold” training data. However, such gold training data may not be easily available in sufficient quantities to allow for machine learning model training.
- Some examples described herein may be incorporated into a system that provides machine learning as a service to users. For instance, a user may have developed a proposed machine learning model as well as available training data for the model. However, the training data may include enough noise to make traditional training insufficient to provide an accurate trained model. In such examples, the user may be provided with an interface to provide information about a desired model, as well as training examples. After collecting relevant information through the interface, the system may use the methods described herein to weight instances within training batches of training data in order to train the model in a more accurate way. A trained model may then be provided back to the user via the interface as part of the service. In further examples, the interface may prompt the user with additional information to facilitate the training process. For instance, the user may be prompted for prior accuracy weighting information indicating expected accuracy of different training examples. The prior accuracy weighting information may be used to generate a reference weight distribution as described herein. In further examples, the user may be prompted for expected class distribution information, which may be used to help select alpha or a different parameter as described herein. Other examples of gathering prior information from a user to facilitate the provision of machine learning as a service are also contemplated.
- Examples described herein may be applied to a variety of underlying machine learning models to be trained. In particular, as long as a loss function can be defined, the process may be agnostic to the model architecture and loss function. The examples are further applicable to a variety of types of training data. Some examples described herein involve image data (e.g., classifying objects in images). Some examples described herein further involve mixing up of image data to generate additional training data. For instance, instances within a minibatch for which higher weights are assigned by the methods described herein may be weighted more than other examples when sampling and/or mixing example images for training. Other example applications may instead include video data, audio data, text data, and a variety of alternatives for the training data and input(s) to the machine learning model.
- Some examples described herein may be directed to handling difficult-to-learn examples or difficult-to-learn groups in training data instead of noisy data. The specific models and applications for which difficult-to-learn examples or difficult-to-learn groups are a focus may be different than for noisy examples. For instance, in the context of computer vision, if a model is trained to differentiate between pictures of cats and pictures of dogs, the model may have a particularly difficult time differentiating blurry pictures or pictures where the cat or dog appears far in the distance. Example methods described herein upgrade the weight assigned to such difficult examples, which may facilitate faster training (e.g., training with less training data needed) of a model. Further examples may involve increasing the weight assigned to difficult-to-learn examples or difficult-to-learn groups for other types of training data, such as video data, audio data, or text data. For instance, a further example involves handling text sentences with negative sentiments that do not use any negative sentiment words in the task of sentiment classification.
- Some examples described herein provide a benefit of trained machine learning models that produce more accurate outputs (e.g., more accurate class labels). In particular, techniques are described for addressing the problem of label noise in training data. This has a potential to have positive downstream implications in yielding better performing machine learning models.
- Some examples described herein further provide a benefit of reduced memory storage requirements. In particular, some of the methods described herein do not need to maintain the weights across the whole training set. Accordingly, the methods may be executed with little computational or memory overhead as compared to alternative cross-entropy loss methods. This is an added benefit compared to some alternative methods that need to keep a record of importance weights over the complete training set which results in increased overhead, particularly for large datasets. For instance, in the methods described herein, if a minibatch size of 200 examples is used, necessary memory storage may be limited to memory storage sufficient to store information about 200 training examples. This benefit may be particularly significant for applications that involve many different types of examples. For instance, an example application may involve one million different types of training examples for which weights may need to be maintained using alternative methods, which may be more computationally expensive and cumbersome as compared to methods described herein.
- Some examples described herein may further provide benefits associated with faster training of a machine learning model. For instance, some such examples may involve prioritizing difficult-to-learn examples or difficult-to-learn groups. By prioritizing difficult-to-learn examples or difficult-to-learn groups, less training data may be needed to train a model. Accordingly, a model may be trained to produce accurate results (e.g., accurate classifications of training examples) with less training data and requiring fewer computations and less computation time to train an associated machine learning model.
-
FIG. 1 shows diagram 100 illustrating atraining phase 102 and aninference phase 104 of trained machine learning model(s) 132, in accordance with example embodiments. Some machine learning techniques involve training one or more machine learning algorithms, on an input set of training data to recognize patterns in the training data and provide output inferences and/or predictions about (patterns in the) training data. The resulting trained machine learning algorithm can be termed as a trained machine learning model. For example,FIG. 1 showstraining phase 102 where one or moremachine learning algorithms 120 are being trained ontraining data 110 to become trained machine learning model(s) 132. Then, duringinference phase 104, trained machine learning model(s) 132 can receiveinput data 130 and one or more inference/prediction requests 140 (perhaps as part of input data 130) and responsively provide as an output one or more inferences and/or prediction(s) 150. - As such, trained machine learning model(s) 132 can include one or more models of one or more
machine learning algorithms 120. Machine learning algorithm(s) 120 may include, but are not limited to: an artificial neural network (e.g., a herein-described convolutional neural networks, a recurrent neural network, a Bayesian network, a hidden Markov model, a Markov decision process, a logistic regression function, a support vector machine, a suitable statistical machine learning algorithm, and/or a heuristic machine learning system). Machine learning algorithm(s) 120 may be supervised or unsupervised, and may implement any suitable combination of online and offline learning. - In some examples, machine learning algorithm(s) 120 and/or trained machine learning model(s) 132 can be accelerated using on-device coprocessors, such as graphic processing units (GPUs), tensor processing units (TPUs), digital signal processors (DSPs), and/or application specific integrated circuits (ASICs). Such on-device coprocessors can be used to speed up machine learning algorithm(s) 120 and/or trained machine learning model(s) 132. In some examples, trained machine learning model(s) 132 can be trained, reside and execute to provide inferences on a particular computing device, and/or otherwise can make inferences for the particular computing device.
- During
training phase 102, machine learning algorithm(s) 120 can be trained by providing atleast training data 110 as training input using unsupervised, supervised, semi-supervised, and/or reinforcement learning techniques. Unsupervised learning involves providing a portion (or all) oftraining data 110 to machine learning algorithm(s) 120 and machine learning algorithm(s) 120 determining one or more output inferences based on the provided portion (or all) oftraining data 110. Supervised learning involves providing a portion oftraining data 110 to machine learning algorithm(s) 120, with machine learning algorithm(s) 120 determining one or more output inferences based on the provided portion oftraining data 110, and the output inference(s) are either accepted or corrected based on correct results associated withtraining data 110. In some examples, supervised learning of machine learning algorithm(s) 120 can be governed by a set of rules and/or a set of labels for the training input, and the set of rules and/or set of labels may be used to correct inferences of machine learning algorithm(s) 120. Individual instances oftraining data 110 may be weighted according to methods described herein. - Semi-supervised learning involves having correct results for part, but not all, of
training data 110. During semi-supervised learning, supervised learning is used for a portion oftraining data 110 having correct results, and unsupervised learning is used for a portion oftraining data 110 not having correct results. Reinforcement learning involves machine learning algorithm(s) 120 receiving a reward signal regarding a prior inference, where the reward signal can be a numerical value. During reinforcement learning, machine learning algorithm(s) 120 can output an inference and receive a reward signal in response, where machine learning algorithm(s) 120 are configured to try to maximize the numerical value of the reward signal. In some examples, reinforcement learning also utilizes a value function that provides a numerical value representing an expected total of the numerical values provided by the reward signal over time. In some examples, machine learning algorithm(s) 120 and/or trained machine learning model(s) 132 can be trained using other machine learning techniques, including but not limited to, incremental learning and curriculum learning. - In some examples, machine learning algorithm(s) 120 and/or trained machine learning model(s) 132 can use transfer learning techniques. For example, transfer learning techniques can involve trained machine learning model(s) 132 being pre-trained on one set of data and additionally trained using
training data 110. More particularly, machine learning algorithm(s) 120 can be pre-trained on data from one or more computing devices and a resulting trained machine learning model provided to computing device CD1, where CD1 is intended to execute the trained machine learning model duringinference phase 104. Then, duringtraining phase 102, the pre-trained machine learning model can be additionally trained usingtraining data 110, wheretraining data 110 can be derived from kernel and non-kernel data of computing device CD1. This further training of the machine learning algorithm(s) 120 and/or the pre-trained machine learning model usingtraining data 110 of CD1's data can be performed using either supervised or unsupervised learning. Once machine learning algorithm(s) 120 and/or the pre-trained machine learning model has been trained on atleast training data 110,training phase 102 can be completed. The trained resulting machine learning model can be utilized as at least one of trained machine learning model(s) 132. - In particular, once
training phase 102 has been completed, trained machine learning model(s) 132 can be provided to a computing device, if not already on the computing device.Inference phase 104 can begin after trained machine learning model(s) 132 are provided to computing device CD1. - During
inference phase 104, trained machine learning model(s) 132 can receiveinput data 130 and generate and output one or more corresponding inferences and/or prediction(s) 150 aboutinput data 130. As such,input data 130 can be used as an input to trained machine learning model(s) 132 for providing corresponding inference(s) and/or prediction(s) 150 to kernel components and non-kernel components. For example, trained machine learning model(s) 132 can generate inference(s) and/or prediction(s) 150 in response to one or more inference/prediction requests 140. In some examples, trained machine learning model(s) 132 can be executed by a portion of other software. For example, trained machine learning model(s) 132 can be executed by an inference or prediction daemon to be readily available to provide inferences and/or predictions upon request.Input data 130 can include data from computing device CD1 executing trained machine learning model(s) 132 and/or input data from one or more computing devices other than CD1. -
Input data 130 can include training data described herein. Other types of input data are possible as well. - Inference(s) and/or prediction(s) 150 can include task outputs, numerical values, and/or other output data produced by trained machine learning model(s) 132 operating on input data 130 (and training data 110). In some examples, trained machine learning model(s) 132 can use output inference(s) and/or prediction(s) 150 as
input feedback 160. Trained machine learning model(s) 132 can also rely on past inferences as inputs for generating new inferences. - After training, the trained version of the neural network can be an example of trained machine learning model(s) 132. In this approach, an example of the one or more inference/prediction request(s) 140 can be a request to predict a classification for an input training example and a corresponding example of inferences and/or prediction(s) 150 can be a predicted classification output. In some examples, individual instances of
training data 110 may also have weights assigned for various possible classes as further described herein. - In some examples, one computing device CD_SOLO can include the trained version of the neural network, perhaps after training. Then, computing device CD_SOLO can receive a request to predict a task output, and use the trained version of the neural network to predict the task output.
- In some examples, two or more computing devices CD_CLI and CD_SRV can be used to provide outputs; e.g., a first computing device CD_CLI can generate and send requests to predict a task output to a second computing device CD_SRV. Then, CD_SRV can use the trained version of the neural network, to predict the task output, and respond to the requests from CD_CLI for the output class. Then, upon reception of responses to the requests, CD_CLI can provide the requested output.
-
FIG. 2 depicts a distributedcomputing architecture 200, in accordance with example embodiments. Distributedcomputing architecture 200 includesserver devices network 206, withprogrammable devices Network 206 may correspond to a local area network (LAN), a wide area network (WAN), a WLAN, a WWAN, a corporate intranet, the public Internet, or any other type of network configured to provide a communications path between networked computing devices.Network 206 may also correspond to a combination of one or more LANs, WANs, corporate intranets, and/or the public Internet. - Although
FIG. 2 only shows five programmable devices, distributed application architectures may serve tens, hundreds, or thousands of programmable devices. Moreover,programmable devices programmable devices network 206. In other examples, such as illustrated byprogrammable device 204 d, programmable devices can be indirectly connected to network 206 via an associated computing device, such asprogrammable device 204 c. In this example,programmable device 204 c can act as an associated computing device to pass electronic communications betweenprogrammable device 204 d andnetwork 206. In other examples, such as illustrated byprogrammable device 204 e, a computing device can be part of and/or inside a vehicle, such as a car, a truck, a bus, a boat or ship, an airplane, etc. In other examples not shown inFIG. 2 , a programmable device can be both directly and indirectly connected tonetwork 206. -
Server devices server device 208 and/or 210 can provide content to programmable devices 204 a-204 e. The content can include, but is not limited to, web pages, hypertext, scripts, binary data such as compiled software, images, audio, and/or video. The content can include compressed and/or uncompressed content. The content can be encrypted and/or unencrypted. Other types of content are possible as well. Some examples described herein involve machine learning content, such as a trained machine learning model provided as part of machine learning as a service. - As another example,
server device 208 and/or 210 can provide programmable devices 204 a-204 e with access to software for database, search, computation, graphical, audio, video, World Wide Web/Internet utilization, and/or other functions. Many other examples of server devices are possible as well. -
FIG. 3 is a block diagram of anexample computing device 300, in accordance with example embodiments. In particular,computing device 300 shown inFIG. 3 can be configured to perform at least one function of and/or related to trained machine learning model(s) 132, and/ormethod 500 ormethod 600. -
Computing device 300 may include a user interface module 301, anetwork communications module 302, one ormore processors 303,data storage 304, one or more camera(s) 318, one ormore sensors 320, andpower system 322, all of which may be linked together via a system bus, network, orother connection mechanism 305. - User interface module 301 can be operable to send data to and/or receive data from external user input/output devices. For example, user interface module 301 can be configured to send and/or receive data to and/or from user input devices such as a touch screen, a computer mouse, a keyboard, a keypad, a touch pad, a trackball, a joystick, a voice recognition module, and/or other similar devices. User interface module 301 can also be configured to provide output to user display devices, such as one or more cathode ray tubes (CRT), liquid crystal displays, light emitting diodes (LEDs), displays using digital light processing (DLP) technology, printers, light bulbs, and/or other similar devices, either now known or later developed. User interface module 301 can also be configured to generate audible outputs, with devices such as a speaker, speaker jack, audio output port, audio output device, earphones, and/or other similar devices. User interface module 301 can further be configured with one or more haptic devices that can generate haptic outputs, such as vibrations and/or other outputs detectable by touch and/or physical contact with
computing device 300. In some examples, user interface module 301 can be used to provide a graphical user interface (GUI) for utilizingcomputing device 300, such as, for example, a graphical user interface of a mobile phone device. -
Network communications module 302 can include one or more devices that provide one or more wireless interface(s) 307 and/or one or more wireline interface(s) 308 that are configurable to communicate via a network. Wireless interface(s) 307 can include one or more wireless transmitters, receivers, and/or transceivers, such as a Bluetooth™ transceiver, a Zigbee® transceiver, a Wi-Fi™ transceiver, a WiMAX™ transceiver, an LTE™ transceiver, and/or other type of wireless transceiver configurable to communicate via a wireless network. Wireline interface(s) 308 can include one or more wireline transmitters, receivers, and/or transceivers, such as an Ethernet transceiver, a Universal Serial Bus (USB) transceiver, or similar transceiver configurable to communicate via a twisted pair wire, a coaxial cable, a fiber-optic link, or a similar physical connection to a wireline network. - In some examples,
network communications module 302 can be configured to provide reliable, secured, and/or authenticated communications. For each communication described herein, information for facilitating reliable communications (e.g., guaranteed message delivery) can be provided, perhaps as part of a message header and/or footer (e.g., packet/message sequencing information, encapsulation headers and/or footers, size/time information, and transmission verification information such as cyclic redundancy check (CRC) and/or parity check values). Communications can be made secure (e.g., be encoded or encrypted) and/or decrypted/decoded using one or more cryptographic protocols and/or algorithms, such as, but not limited to, Data Encryption Standard (DES), Advanced Encryption Standard (AES), a Rivest-Shamir-Adelman (RSA) algorithm, a Diffie-Hellman algorithm, a secure sockets protocol such as Secure Sockets Layer (SSL) or Transport Layer Security (TLS), and/or Digital Signature Algorithm (DSA). Other cryptographic protocols and/or algorithms can be used as well or in addition to those listed herein to secure (and then decrypt/decode) communications. - One or
more processors 303 can include one or more general purpose processors, and/or one or more special purpose processors (e.g., digital signal processors, tensor processing units (TPUs), graphics processing units (GPUs), application specific integrated circuits, etc.). One ormore processors 303 can be configured to execute computer-readable instructions 306 that are contained indata storage 304 and/or other instructions as described herein. -
Data storage 304 can include one or more non-transitory computer-readable storage media that can be read and/or accessed by at least one of one ormore processors 303. The one or more computer-readable storage media can include volatile and/or non-volatile storage components, such as optical, magnetic, organic or other memory or disc storage, which can be integrated in whole or in part with at least one of one ormore processors 303. In some examples,data storage 304 can be implemented using a single physical device (e.g., one optical, magnetic, organic or other memory or disc storage unit), while in other examples,data storage 304 can be implemented using two or more physical devices. -
Data storage 304 can include computer-readable instructions 306 and perhaps additional data. In some examples,data storage 304 can include storage required to perform at least part of the herein-described methods, scenarios, and techniques and/or at least part of the functionality of the herein-described devices and networks. In some examples,data storage 304 can include storage for a trained neural network model 312 (e.g., a model of trained neural networks such as trained machine learning model(s) 132). In particular of these examples, computer-readable instructions 306 can include instructions that, when executed by one or more processors 903, enablecomputing device 300 to provide for some or all of the functionality of trainedneural network model 312. - In some examples,
computing device 300 can include one or more camera(s) 318. Camera(s) 318 can include one or more image capture devices, such as still and/or video cameras, equipped to capture light and record the captured light in one or more images; that is, camera(s) 318 can generate image(s) of captured light. The one or more images can be one or more still images and/or one or more images utilized in video imagery. Camera(s) 318 can capture light and/or electromagnetic radiation emitted as visible light, infrared radiation, ultraviolet light, and/or as one or more other frequencies of light. - In some examples,
computing device 300 can include one ormore sensors 320.Sensors 320 can be configured to measure conditions withincomputing device 300 and/or conditions in an environment ofcomputing device 300 and provide data about these conditions. For example, sensors 320 can include one or more of: (i) sensors for obtaining data about computing device 300, such as, but not limited to, a thermometer for measuring a temperature of computing device 300, a battery sensor for measuring power of one or more batteries of power system 322, and/or other sensors measuring conditions of computing device 300; (ii) an identification sensor to identify other objects and/or devices, such as, but not limited to, a Radio Frequency Identification (RFID) reader, proximity sensor, one-dimensional barcode reader, two-dimensional barcode (e.g., Quick Response (QR) code) reader, and a laser tracker, where the identification sensors can be configured to read identifiers, such as RFID tags, barcodes, QR codes, and/or other devices and/or object configured to be read and provide at least identifying information; (iii) sensors to measure locations and/or movements of computing device 300, such as, but not limited to, a tilt sensor, a gyroscope, an accelerometer, a Doppler sensor, a GPS device, a sonar sensor, a radar device, a laser-displacement sensor, and a compass; (iv) an environmental sensor to obtain data indicative of an environment of computing device 300, such as, but not limited to, an infrared sensor, an optical sensor, a light sensor, a biosensor, a capacitive sensor, a touch sensor, a temperature sensor, a wireless sensor, a radio sensor, a movement sensor, a microphone, a sound sensor, an ultrasound sensor and/or a smoke sensor; and/or (v) a force sensor to measure one or more forces (e.g., inertial forces and/or G-forces) acting about computing device 300, such as, but not limited to one or more sensors that measure: forces in one or more dimensions, torque, ground force, friction, and/or a zero moment point (ZMP) sensor that identifies ZMPs and/or locations of the ZMPs. Many other examples ofsensors 320 are possible as well. -
Power system 322 can include one ormore batteries 324 and/or one or moreexternal power interfaces 326 for providing electrical power tocomputing device 300. Each battery of the one ormore batteries 324 can, when electrically coupled to thecomputing device 300, act as a source of stored electrical power forcomputing device 300. One ormore batteries 324 ofpower system 322 can be configured to be portable. Some or all of one ormore batteries 324 can be readily removable fromcomputing device 300. In other examples, some or all of one ormore batteries 324 can be internal tocomputing device 300, and so may not be readily removable fromcomputing device 300. Some or all of one ormore batteries 324 can be rechargeable. For example, a rechargeable battery can be recharged via a wired connection between the battery and another power supply, such as by one or more power supplies that are external tocomputing device 300 and connected tocomputing device 300 via the one or more external power interfaces. In other examples, some or all of one ormore batteries 324 can be non-rechargeable batteries. - One or more
external power interfaces 326 ofpower system 322 can include one or more wired-power interfaces, such as a USB cable and/or a power cord, that enable wired electrical power connections to one or more power supplies that are external tocomputing device 300. One or moreexternal power interfaces 326 can include one or more wireless power interfaces, such as a Qi wireless charger, that enable wireless electrical power connections, such as via a Qi wireless charger, to one or more external power supplies. Once an electrical power connection is established to an external power source using one or moreexternal power interfaces 326,computing device 300 can draw electrical power from the external power source the established electrical power connection. In some examples,power system 322 can include related sensors, such as battery sensors associated with the one or more batteries or other types of electrical power sensors. -
FIG. 4 depicts a cloud-based server system in accordance with an example embodiment. InFIG. 4 , functionality of a neural network, and/or a computing device can be distributed among computingclusters Computing cluster 409 a can include one ormore computing devices 400 a, cluster storage arrays 44 a, and cluster routers 411 a connected by alocal cluster network 412 a. Similarly,computing cluster 409 b can include one ormore computing devices 400 b, cluster storage arrays 44 b, and cluster routers 411 b connected by alocal cluster network 412 b. Likewise, computing cluster 409 c can include one ormore computing devices 400 c, cluster storage arrays 44 c, andcluster routers 411 c connected by alocal cluster network 412 c. - In some embodiments, computing
clusters clusters FIG. 4 depicts each of computingclusters - In some embodiments, data and services at computing
clusters clusters - In some embodiments, each of computing
clusters - In
computing cluster 409 a, for example,computing devices 400 a can be configured to perform various computing tasks of a conditioned, axial self-attention based neural network, and/or a computing device. In one embodiment, the various functionalities of a neural network, and/or a computing device can be distributed among one or more ofcomputing devices Computing devices respective computing clusters 409 b and 409 c can be configured similarly to computingdevices 400 a incomputing cluster 409 a. On the other hand, in some embodiments,computing devices - In some embodiments, computing tasks and stored data associated with a neural network, and/or a computing device can be distributed across
computing devices computing devices - Cluster storage arrays 44 a, 44 b, 44 c of
computing clusters - Similar to the manner in which the functions of a conditioned, axial self-attention based neural network, and/or a computing device can be distributed across
computing devices computing clusters cluster storage arrays 410 a, 410 b, 410 c. For example, some cluster storage arrays can be configured to store one portion of the data of a first layer of a neural network, and/or a computing device, while other cluster storage arrays can store other portion(s) of data of second layer of a neural network, and/or a computing device. Also, for example, some cluster storage arrays can be configured to store the data of an encoder of a neural network, while other cluster storage arrays can store the data of a decoder of a neural network. Additionally, some cluster storage arrays can be configured to store backup versions of data stored in other cluster storage arrays. -
Cluster routers 411 a, 411 b, 411 c incomputing clusters computing cluster 409 a can include one or more internet switching and routing devices configured to provide (i) local area network communications betweencomputing devices 400 a and cluster storage arrays 410 a vialocal cluster network 412 a, and (ii) wide area network communications betweencomputing cluster 409 a andcomputing clusters 409 b and 409 c via wide area network link 413 a tonetwork 406.Cluster routers 411 b and 411 c can include network equipment similar to cluster routers 411 a, andcluster routers 411 b and 411 c can perform similar networking functions for computingclusters computing cluster 409 a. - In some embodiments, the configuration of
cluster routers 411 a, 411 b, 411 c can be based at least in part on the data communication requirements of the computing devices and cluster storage arrays, the data communications capabilities of the network equipment incluster routers 411 a, 411 b, 411 c, the latency and throughput oflocal cluster networks -
FIG. 5 is a flowchart of amethod 500, in accordance with example embodiments.Method 500 can be executed by a computing device, such as server device 208-210 orcomputing device 300.Method 500 can begin atblock 510, where the computing device receives training data for a machine learning model. The training data includes a plurality of training examples and a corresponding plurality of labels. In some examples, the training data includes noisy labels. - At
block 520, the computing device divides the training data into a plurality of training batches. Each training batch may include a portion of the training examples and corresponding labels. In some examples, the training batches may be minibatches which are one or more orders of magnitude smaller in size than the entire training data. - At
block 530, the computing device learns, for each training batch of the plurality of training batches, a weight for each training example in the batch. For each training batch, the learned weights minimize a sum of weighted losses for the training batch subject to a divergence constraint, where the divergence constraint limits a divergence of the learned weights for the training batch from a reference distribution. The divergence may be determined according to a chosen divergence measure. In some examples, for each training batch of the plurality of training batches, the divergence constraint limits the divergence of the learned weight for the training batch from the reference distribution to be within a delta value. In some examples, the delta value is a hyperparameter that is tuned while training the machine learning model. In some examples, the reference distribution is a uniform distribution assigning an equal weight to each training example within each training batch. Some examples further involve receiving group prior information indicative of likelihood of label noise for a group of training examples within a particular training batch, and determining the reference distribution for the particular training batch based on the group prior information. In some examples, the chosen divergence measure comprises an ƒ-divergence measure. In some examples, the chosen divergence measure comprises a KL-divergence measure. In some examples, the chosen divergence measure comprises a reverse KL-divergence measure. In some examples, the chosen divergence measure comprises an alpha-divergence measure. - In some examples, the computing device learns, for each training batch of the plurality of training batches, the weight for each training example in the training batch by learning a class weight for each class of a plurality of classes for each training example in the training batch. In some examples, the computing device learns, for each training batch of the plurality of training batches, the weight for each training example in the training batch that minimizes the sum of weighted losses for the training batch subject to a class divergence constraint. The class divergence constraint limits a class divergence of the class weight determined for each class of the plurality of classes for each training example in the training batch from a one-hot vector that assigns full weight to a single class. In some examples, the class divergence is measured using a total variation distance. In some examples, the class divergence is measured using a squared L2-distance.
- At block 540, the computing device trains the machine learning model with each training batch of the plurality of training batches using the learned weight for each training example in the training batch. In some examples, the computing devices discards from a computer memory, for each training batch of the plurality of training batches, the weight learned for each training example in the training batch after training the machine learning model with the training batch.
- At
block 550, the computing device provides the trained machine learning model. - Some examples further involve the computing device using the weight learned for each training example in a particular training batch for mixing training examples from the particular training batch to create a mixed up minibatch for training the machine learning model. Some examples further involve the computing device using the weight learned for each training example in the particular training batch for sampling training examples from the particular training batch to create the mixed up minibatch for training the machine learning model. In some examples, the mixed up minibatch is used to train the machine learning model for processing images.
-
FIG. 6 is a flowchart of amethod 600, in accordance with example embodiments.Method 600 can be executed by a computing device, such as server device 208-210 orcomputing device 300.Method 600 can begin atblock 610, where the computing device receives training data for a machine learning model. The training data includes a plurality of training examples and a corresponding plurality of labels. In some examples, the training data includes hard-to-learn examples that can be prioritized to optimize training of the machine learning model. - At
block 620, the computing device divides the training data into a plurality of training batches. Each training batch may include a portion of the training examples and corresponding labels. In some examples, the training batches may be minibatches which are one or more orders of magnitude smaller than the entire training data. - At
block 630, the computing device learns, for each training batch of the plurality of training batches, a weight for each training example in the training batch. For each training batch, the learned weights minimize a sum of weighted losses over model parameters and maximize the sum of weighted losses over example weights or group weights for the training batch subject to a divergence constraint, where the divergence constraint limits a divergence of the learned weights for the training batch from a reference distribution. The divergence may be determined according to a chosen divergence measure. In some examples, for each training batch of the plurality of training batches, the divergence constraint limits the divergence of the learned weights for the training batch from the reference distribution to be within a delta value. In some examples, the delta value is a hyperparameter that is tuned while training the machine learning model. In some examples, the reference distribution is a uniform distribution assigning an equal weight to each training example within each training batch. Some examples further involve receiving group prior information indicative of likelihood of label noise for a group of training examples within a particular training batch, and determining the reference distribution for the particular training batch based on the group prior information. In some examples, the chosen divergence measure comprises an ƒ-divergence measure. In some examples, the chosen divergence measure comprises a KL-divergence measure. In some examples, the chosen divergence measure comprises a reverse KL-divergence measure. In some examples, the chosen divergence measure comprises an alpha-divergence measure. - In some examples, the computing device learns, for each training batch of the plurality of training batches, the weight for each training example in the training batch by learning a class weight for each class of a plurality of classes for each training example in the training batch. In some examples, the computing device learns, for each batch of the plurality of batches, the weight for each training example in the training batch that minimizes the sum of weighted losses for the training batch subject to a class divergence constraint. The class divergence constraint limits a class divergence of the class weight determined for each class of the plurality of classes for each training example in the training batch from a one-hot vector that assigns full weight to a single class. In some examples, the class divergence is measured using a total variation distance. In some examples, the class divergence is measured using a squared L2-distance.
- At block 640, the computing device trains the machine learning model with each training batch of the plurality of training batches using the learned weight for each training example in the training batch. In some examples, the computing devices discards from a computer memory, for each batch of the plurality of training batches, the weight determined for each training example in the training batch after training the machine learning model with the training batch.
- At
block 650, the computing device provides the trained machine learning model. - Examples described herein involve the classic supervised learning regime (although it is possible to extend the method to other settings such as semi-supervised learning). We use xi ∈
-
- where D(⋅,⋅) is a divergence measure of choice and u denotes the uniform distribution. Next, we look into this objective more closely and derive updates for importance weights w for several commonly used divergence measures.
- Let us take D to be ƒ-divergence. For simplicity, we work with the constraint D(w, u)=Σiui ƒ(wi/ui)≤δ where ƒ is a convex function with ƒ(1)=0 (instead of a constraint on D(u, w) which will not lead to simple closed form update rules). Forming the Lagrangian for problem (1), we get equation (2):
-
- where λ≥0, νi≥0, μ are the Lagrange multipliers. The dual function (for a fixed θ) is given by equation (3):
-
- Optimizing over w, the first order condition for optimality is equation (4):
-
- The Lagrange multipliers λ, μ, and νi are such that the constraints are satisfied. We adopt an alternating minimization approach for optimizing over (w, θ): fix θ and optimize for w using equation (4), then take a gradient step for model parameters θ while keeping the importance weights w fixed. As we define the problem (1) over a single minibatch, there is no extra overhead of maintaining the importance weights over entire training data or across the training iterations. We can also obtain closed form solutions for the importance weights when D is taken to be in the family of Bregman divergence.
- We now consider some special cases of divergences that are commonly used in machine learning.
- KL-divergence belongs to both ƒ-divergence and Bregman divergence family, and is given by
-
- It can be obtained by taking the generating function ƒ(t)=t log t in ƒ-divergence, which in turn implies ƒ′−1(t)=et−1. Since ƒ′−1(t)=et−1>0 for all finite t, all weights are non-zero and we will have νi=0. Hence, based on equation (4), the weights are given by equation (5):
-
- The second equality above is obtained by using the fact that Σiwi=1. The Lagrange multiplier is such that the constraint D (w, u)≤δ is active. In our experiments, we use λ as the tunable hyperparameter instead of δ.
- Reverse-KL divergence also belongs to both ƒ-divergence and Bregman divergence family, and is given by
-
- It can be obtained by taking the generating function ƒ(t)=−log t in ƒ-divergence, which in turn implies
-
- Since a zero weight will result in unbounded reverse-KL divergence and violate the constraint, all weights have to be positive and we will have νi=0. Hence, based on equation (4), the weights are given by equation (6):
-
- Again, the second equality above is obtained by using the fact that Σiwi=1. The Lagrange multiplier μ is such that the constraint D (w, u)≤δ is active. In our experiments, we use μ as the tunable hyperparameter instead of δ.
-
-
- for α ∈
-
- which yields the inverse function
-
- Based on equation (4) and the form of the inverse function, the constraint wi≥0 may become active for values of α>1, thus the Lagrange multiplier νi causing the weight to be zero. As a result, the weights are given by equation (7):
-
- where [⋅]+=max(⋅,0). The case of α=1 which corresponds to KL divergence is given in equation (5). Equation (7) can alternatively be viewed in the form of a generalized softmax function. Using the definition of the generalized exponential function
-
-
- As we decrease α, the distribution of weights will have heavier tails (i.e., the difference between the weights for large and small losses will be less, resulting in a flatter distribution). Similarly for a fixed α, we will see heavier tails with increasing μ. We illustrate this behavior in
FIGS. 7 and 8 . -
FIG. 7 illustrates distribution of weights as a function of loss. We sample five loss values on the X-axis and plot the weights with different divergences and parameter μ. Plot (a) shows the effect of different values of a for fixed μ=1. The distribution has a heavier-tail for smaller α values, while α>1 clips the weights to zero for larger losses. Plot (b) shows the effect of different values of μ for fixed α=0. The weights become smoother for larger μ. Plot (c) shows a similar plot for α=1. Larger μ values have the same effect, however, the tail of the distribution is much shorter than the previous case. -
FIG. 8 illustrates level sets of the weight of an example as a function of its loss in a batch size of 2, where the loss of the other example is fixed to 2.5. The horizontal line passing through the middle corresponds to a value of loss equal to 2.5, thus having instance weight=0.5. Points above this line (with loss >2.5) induce weights <0.5 and vice versa. Plot (a) shows the effect of different a for a fixed μ=1. The level sets are asymmetric across the center line. Also, the level sets become denser along a vertical slice for larger α, as the distribution becomes less smooth. Plot (b) shows the effect of μ for a fixed α=1. The level sets are again asymmetric across the center line and become denser for smaller μ. Plot (c) shows a similar plot for α=1. The change in level sets is more rapid as the distribution has shorter tail. - We also show the effect of our instance reweighting approach in a toy noisy binary classification setting in two dimensions. We use a two-layer fully-connected neural network with tan h activations and 10 and 20 hidden layers, respectively. The model is trained on 1000 samples with 30% random flip label noise.
FIG. 9 visualizes the decision boundary of the baseline model, trained with the CE loss, as well as with the reweighted loss via equation (7) (using α=0.5 and μ=0.5). Our importance reweighting approach is able to successfully rectify the decision boundary by emphasizing on the clean examples in each batch while downweighting the noisy ones. -
FIG. 9 shows our proposed constrained importance reweighting method on a two-layer neural network. Plot (a) shows the decision boundary at the beginning of training. Plot (b) shows the decision boundary of the baseline model after 6 epochs. Plot (c) shows the decision boundary of the baseline model after 20 epochs. The large loss of the misclassified noisy examples causes the model to eventually overfit to noise. Plot (d) shows a random mini-batch of examples atepoch 6. The baseline model treats these examples as equally important. Plot (e) shows the same mini-batch of examples reweighted by our proposed approach (with size of each example indicating its importance). Plot (f) shows that b activating the proposed instance reweighting atepoch 6, the model is able to fit well to the geometry of the data atepoch 20. - Instance reweighting presented in the earlier sections assigns high weights to instances with lower losses while not deviating far from a uniform distribution over instances. In this section, we extend this intuition to assign importance weights over all possible class labels. For the mislabeled examples, it is reasonable to assign non-zero weights to classes that could potentially be the true label. Let us denote by Lj(xi, θ) the loss for example xi with the assumption that the true label is class j, i.e., Lj(xi, θ):=L(xi, j, θ) (note that we used L(xi, θ) to denote L(xi, yi, θ) in the earlier sections, where yi was the annotated label). We now consider optimization problem (8):
-
- where index i runs over the examples in the minibatch, index j runs over all the classes, u is the uniform distribution over examples, νij is the weight for class j for ith example, ei is the one-hot vector with 1 in the position of annotated class of ith example (i.e., yi). Since the inner problem for every example is independent of others, we first solve each inner problem independently to get class weights ν and fix them before computing instance weights w using the earlier described closed-form solutions. Next, we consider some special cases for divergence D2 and derive updates for class weights.
- Taking D2 to be the total variation distance will result in a linear program in ν with solution lying on a vertex. We can rewrite the optimization problem (8) in ν (omitting the example index i) as equation (9):
-
- where e is a one-hot vector with ey=1 and ej=0∀j≠y.
The solution to this optimization problem subsequently reduces the objective (8) to objective (10): -
- where ŷl denotes the class with lowest loss. We note that this is same as static bootstrapping which was earlier proposed for label noise in a rather heuristic manner. We show that it can justified in a principled manner from the point of view of constrained optimization over class weights. It is possible to use a per-instance γi, perhaps making it a function of the class losses (i.e., γi=g(L1(xi, θ), . . . , LK(xi, θ)) for some function g), but we work with a γ that is globally fixed for all instances in our experiments for the sake of simplicity.
- Other Divergences that Result in Similar Solution for Class Weights.
- The effective inner loss in objective (10) is a convex combination of the two losses: loss of the annotated class yi and loss of the predicted class ŷi. It can be shown that similar weighting of the two losses, with weights given by (1−g(γ)) and g(γ) for some nonnegative function g, are obtained if we take D2 (⋅,⋅) to be
-
-
- The solution to this can be obtained by sorting the losses {Lj(x, θ)}j=1 k in ascending order and doing a search for the nonzero indices of ν over the possible solution set S={[m]∪{tilde over (y)}}1≤m<{tilde over (y)}, where [m]={1, . . . , m}, and {tilde over (y)} denotes the index where the loss Ly(x, θ) falls in this ranking of losses. The number of candidate solutions are {tilde over (y)} and the correct solution can be identified by checking certain conditions. A first heuristic that often provided correct solutions in our experiments was to compute the mean {tilde over (μ)} of the losses {Lj(x, θ):Lj(x, θ)≤Ly(x, θ)} and set the nonzero indices of ν to be {j:Lj(x, θ)<{tilde over (μ)}}∪{y}. Since the problem (11) is convex, we can also use a convex solver to solve for ν. However, this gives us an interesting insight behind the working of the
- Using Importance Weights with Mixup
- Mixup has been shown to work well in the presence of label noise. We propose two ways to combine Mixup with the instance weights obtained with our method that further provide significant empirical gains against label noise:
- (i) Using importance weights for mixing (IW-Mix). Let X ∈
(ii) Using importance weights for both sampling and mixing (SIW-Mix). In this variant, we importance sample the example indices (with replacement) in the minibatch using instance weights w as probabilities. For the importance sampled indices I, let {tilde over (w)}=w[I], {tilde over (X)}=X[I, :] and {tilde over (Y)}=Y[I, :]. We then construct the mixed up minibatch as earlier, i.e., Xi: (m)=(wiXi:+{tilde over (w)}i{tilde over (X)}i:)/(wi+{tilde over (w)}i) and Yi (m)=(wiYi:+{tilde over (w)}i{tilde over (Y)}i:)/(wi+{tilde over (w)}i) - There are two ways we can use the mixed up batch during training: (i) Mixup-base: Simply compute the base loss L(xi (m), yi (m), θ) for each mixed up example (xi (m), yi (m)) and use the average loss
-
- for backpropagation, (ii) Mixup-reweight: Use the losses for mixed up examples {L(xi (m), yi (m)), θ)}i=1 n as our base losses and plug them into the problem (8), recompute the instance and class weights for the mixed up examples, and use the final reweighted loss for backprogation.
- Here we consider the setting that all samples are valid but there are some hard examples, and we would like the model to do well on these examples too. We consider the following optimization problem (12) to this end:
-
- where D (⋅,⋅) is a divergence measure of choice (e.g., KL) and δ is a scalar radius parameter that is fixed a priori or can be varied as learning proceeds. If we take D (⋅,⋅) to be KL or reverse KL divergence as earlier, the updates have similar form. Specifically, for KL divergence, we can write optimal wi in terms of Lagrange multipliers as
-
- where λ≥0.
When D (⋅,⋅) is reverse KL divergence, we have -
- When L(x, θ) is supervised cross entropy loss, i.e., L(xi, θ)=−log pt
i where pti =pi for yi=1 and pti =(1−pi) for yi=0 (pi being the predicted probability of positive class), the weights are given by -
w i ∝p ti γ, - with γ=1/λ(n−1). The weight for ith example is proportional to (1−κpt
i γ), where κ=1/Σjpti γ. This can be contrasted with the Focal loss where the example weight is given by (1−pti )γ for a hyperparameter γ. - Alternative to the optimization problem (12), if we consider the following optimization problem (13):
-
- we will get the following weights for the KL divergence constraint:
-
- The Lagrange multiplier μ will take value to ensure L(xi, θ)+μ<0 so that wi≥0. For reverse KL divergence constraint, optimal weights for problem (13) will be
-
- For supervised cross-entropy loss, this will imply
-
- This highlights that we can get very different example weighting schemes ((1−κpt
i γ) vs. pti −γ) by parameterizing the problem in different ways. - In further examples, we can do away with the constraint that all weights sum to 1 and use unnormalized KL divergence. For unnormalized reverse KL divergence constraint, the weights for problem (12) are given by
-
- For supervised cross entropy loss, this reduces example weights equal to (1−wi)=(1−pt
i γ) with γ=1/λ(n−1), where pti =pi for yi=1 and pti =(1−pi) for yi=0 (pi being the predicted probability of positive class). This can be contrasted with the Focal loss where the example weight is given by (1−pti )γ for a hyperparameter γ.
Learning with Noisy Labels Under Group Priors - In the cases where we have prior information about certain groups in the training data that are less or more likely to have label noise, this prior can be incorporated in our sample reweighting framework by modifying the uniform prior over examples to a more suitable distribution. For example, if certain group or class is believed to have less amount of label noise, the prior can be modified to be {tilde over (μ)} with
-
- for all example indices i belonging to this group or class, while still constraining {tilde over (μ)} to be a distribution (i.e., Σi{tilde over (μ)}i=1). Similarly, if certain group or class is believed to have more amount of label noise, the prior can be modified to be {tilde over (μ)} with
-
- for all example indices i belonging to this group or class, while still constraining {tilde over (μ)} to be a distribution (i.e., Σi{tilde over (μ)}i=1). If there is an ordering available over groups in terms of their likeliness of having label noise, this ordering can also be reflected in the prior {tilde over (μ)}. All derivations previously described can be easily adapted to the modified prior by plugging in the new prior weights ũi.
- There are scenarios where data can be naturally partitioned into groups and the goal is to learn a robust classifier that works well on all these groups. This grouping information can be available as part of metadata (e.g., face images that have skin or hair color as metadata). In such cases we want to ensure or encourage equity in the performance of the learned model over different groups, instead of optimizing for the average performance over full dataset. Our robust learning via sample reweighting framework can be easily adapted to this scenario. Specifically, we consider the following optimization problem (14) (modifying the problem (12)):
-
- where k is the total number of groups, g is a discrete distribution over groups (to be learned), μ is a prior distribution over groups (e.g., uniform), D (⋅,⋅) is a divergence measure of choice (e.g., KL), and δ is a scalar radius parameter that is fixed a priori or can be varied as learning proceeds. The loss Li(θ)=Σj∈G
i L (xj, θ) is the loss of examples belonging to the group Gi. Having δ to be 0 will reduce the objective to that of empirical risk minimization (ERM) when μ is the uniform distribution. The solution for weights for different divergences can be derived in similar manner as previously described with L(xi, θ) replaced with Li(θ) and n replaced with k. - We can similarly modify the objective of problem (13) for the group robust setting to produce optimization problem (15) as follows:
-
- and derive the solutions for the group weights gi. Again, having δ to be 0 will reduce the objective to that of empirical risk minimization (ERM) when u is the uniform distribution. Another extreme case is for δ=∞, when the objective reduces to that of group distribution robust optimization proposed earlier
-
- where i indexes over all k groups. Our framework provides a principled approach to control the intensity of the worst case optimization by having stochasticity over the groups via group weights gi.
- In addition to addressing group robustness, further examples involve addressing the class imbalance problem where the training data contains classes with highly skewed distribution. In particular, the number of training examples per class may vary significantly across classes. It may therefore be desirable to train a model that is robust to variations around a target distribution (such as uniform, or any other specified target distribution). The formulation for this problem is equivalent to the formulation for group robustness (equations (14) and 15) above) with the adjustment of replacing group-wise losses with class-wise losses.
- The present disclosure is not to be limited in terms of the particular embodiments described in this application, which are intended as illustrations of various aspects. Many modifications and variations can be made without departing from its spirit and scope, as will be apparent to those skilled in the art. Functionally equivalent methods and apparatuses within the scope of the disclosure, in addition to those enumerated herein, will be apparent to those skilled in the art from the foregoing descriptions. Such modifications and variations are intended to fall within the scope of the appended claims.
- The above detailed description describes various features and functions of the disclosed systems, devices, and methods with reference to the accompanying figures. In the figures, similar symbols typically identify similar components, unless context dictates otherwise. The illustrative embodiments described in the detailed description, figures, and claims are not meant to be limiting. Other embodiments can be utilized, and other changes can be made, without departing from the spirit or scope of the subject matter presented herein. It will be readily understood that the aspects of the present disclosure, as generally described herein, and illustrated in the figures, can be arranged, substituted, combined, separated, and designed in a wide variety of different configurations, all of which are explicitly contemplated herein.
- With respect to any or all of the ladder diagrams, scenarios, and flow charts in the figures and as discussed herein, each block and/or communication may represent a processing of information and/or a transmission of information in accordance with example embodiments. Alternative embodiments are included within the scope of these example embodiments. In these alternative embodiments, for example, functions described as blocks, transmissions, communications, requests, responses, and/or messages may be executed out of order from that shown or discussed, including substantially concurrent or in reverse order, depending on the functionality involved. Further, more or fewer blocks and/or functions may be used with any of the ladder diagrams, scenarios, and flow charts discussed herein, and these ladder diagrams, scenarios, and flow charts may be combined with one another, in part or in whole.
- A block that represents a processing of information may correspond to circuitry that can be configured to perform the specific logical functions of a herein-described method or technique. Alternatively or additionally, a block that represents a processing of information may correspond to a module, a segment, or a portion of program code (including related data). The program code may include one or more instructions executable by a processor for implementing specific logical functions or actions in the method or technique. The program code and/or related data may be stored on any type of computer readable medium such as a storage device including a disk or hard drive or other storage medium.
- The computer readable medium may also include non-transitory computer readable media such as non-transitory computer-readable media that stores data for short periods of time like register memory, processor cache, and random access memory (RAM). The computer readable media may also include non-transitory computer readable media that stores program code and/or data for longer periods of time, such as secondary or persistent long term storage, like read only memory (ROM), optical or magnetic disks, compact-disc read only memory (CD-ROM), for example. The computer readable media may also be any other volatile or non-volatile storage systems. A computer readable medium may be considered a computer readable storage medium, for example, or a tangible storage device.
- Moreover, a block that represents one or more information transmissions may correspond to information transmissions between software and/or hardware modules in the same physical device. However, other information transmissions may be between software modules and/or hardware modules in different physical devices.
- While various aspects and embodiments have been disclosed herein, other aspects and embodiments will be apparent to those skilled in the art. The various aspects and embodiments disclosed herein are provided for explanatory purposes and are not intended to be limiting, with the true scope being indicated by the following claims.
Claims (20)
1. A method comprising:
receiving training data for a machine learning model, the training data comprising a plurality of training examples and a corresponding plurality of labels;
dividing the training data into a plurality of training batches;
for each training batch of the plurality of training batches, learning a weight for each training example in the training batch that minimizes a sum of weighted losses for the training batch subject to a divergence constraint, wherein the divergence constraint limits a divergence of the learned weights for the training batch from a reference distribution, wherein the divergence is determined according to a chosen divergence measure;
training the machine learning model with each training batch of the plurality of training batches using the learned weight for each training example in the training batch; and
providing the trained machine learning model.
2. The method of claim 1 , further comprising for each training batch of the plurality of training batches, discarding, from a computer memory, the learned weights for the training batch after training the machine learning model with the training batch.
3. The method of claim 1 , wherein for each training batch of the plurality of training batches, the divergence constraint limits the divergence of the learned weights for the training batch from the reference distribution to be within a delta value.
4. The method of claim 3 , wherein the delta value is a hyperparameter that is tuned while training the machine learning model.
5. The method of claim 1 , wherein the reference distribution is a uniform distribution assigning an equal weight to each training example within each training batch.
6. The method of claim 1 , further comprising:
receiving group prior information indicative of likelihood of label noise for a group of training examples within a particular training batch; and
determining the reference distribution for the particular training batch based on the group prior information.
7. The method of claim 1 , wherein the chosen divergence measure comprises an ƒ-divergence measure.
8. The method of claim 1 , wherein the chosen divergence measure comprises a KL-divergence measure.
9. The method of claim 1 , wherein the chosen divergence measure comprises a reverse KL-divergence measure.
10. The method of claim 1 , wherein the chosen divergence measure comprises an alpha-divergence measure.
11. The method of claim 1 , wherein for each training batch of the plurality of training batches, learning the weight for each training example in the training batch comprises learning a class weight for each class of a plurality of classes for each training example in the training batch.
12. The method of claim 11 , wherein for each training batch of the plurality of training batches, learning the weight for each training example in the training batch that minimizes the sum of weighted losses for the training batch is further subject to a class divergence constraint, wherein the class divergence constraint limits a class divergence of the class weight learned for each class of the plurality of classes for each training example in the training batch from a one-hot vector that assigns full weight to a single class.
13. The method of claim 12 , wherein the class divergence is measured using a total variation distance.
14. The method of claim 12 , wherein the class divergence is measured using a squared L2-distance.
15. The method of claim 1 , further comprising using the weight determined for each training example in a particular training batch for mixing training examples from the particular training batch to create a mixed up minibatch for training the machine learning model.
16. The method of claim 15 , further comprising using the weight determined for each training example in the particular training batch for sampling training examples from the particular training batch to create the mixed up minibatch for training the machine learning model.
17. The method of claim 15 , wherein the mixed up minibatch is used to train the machine learning model for processing images.
18. A computing system comprising one or more processors and a non-transitory computer readable medium storing program instructions executable by the one or more processors to cause performance of operations comprising:
receiving training data for a machine learning model, the training data comprising a plurality of training examples and a corresponding plurality of labels;
dividing the training data into a plurality of training batches;
for each training batch of the plurality of training batches, learning a weight for each training example in the training batch that minimizes a sum of weighted losses for the training batch subject to a divergence constraint, wherein the divergence constraint limits a divergence of the learned weights for the training batch from a reference distribution, wherein the divergence is determined according to a chosen divergence measure;
training the machine learning model with each training batch of the plurality of training batches using the learned weight for each training example in the training batch; and
providing the trained machine learning model.
19. A non-transitory computer readable medium storing program instructions executable by one or more processors to cause performance of operations comprising:
receiving training data for a machine learning model, the training data comprising a plurality of training examples and a corresponding plurality of labels;
dividing the training data into a plurality of training batches;
for each training batch of the plurality of training batches, learning a weight for each training example in the training batch that minimizes a sum of weighted losses for the training batch subject to a divergence constraint, wherein the divergence constraint limits a divergence of the learned weights for the training batch from a reference distribution, wherein the divergence is determined according to a chosen divergence measure;
training the machine learning model with each training batch of the plurality of training batches using the learned weight for each training example in the training batch; and
providing the trained machine learning model.
20. A method comprising:
receiving training data for a machine learning model, the training data comprising a plurality of training examples and a corresponding plurality of labels;
dividing the training data into a plurality of training batches;
for each training batch of the plurality of training batches, learning a weight for each training example in the training batch that minimizes a sum of weighted losses over model parameters and maximizes the sum of weighted losses over example weights or group weights for the training batch subject to a divergence constraint, wherein the divergence constraint limits a divergence of the learned weights for the training batch from a reference distribution, wherein the divergence is determined according to a chosen divergence measure;
training the machine learning model with each training batch of the plurality of training batches using the learned weight for each training example in the training batch; and
providing the trained machine learning model.
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US17/816,197 US20230044078A1 (en) | 2021-07-30 | 2022-07-29 | Unified Sample Reweighting Framework for Learning with Noisy Data and for Learning Difficult Examples or Groups |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US202163227390P | 2021-07-30 | 2021-07-30 | |
US17/816,197 US20230044078A1 (en) | 2021-07-30 | 2022-07-29 | Unified Sample Reweighting Framework for Learning with Noisy Data and for Learning Difficult Examples or Groups |
Publications (1)
Publication Number | Publication Date |
---|---|
US20230044078A1 true US20230044078A1 (en) | 2023-02-09 |
Family
ID=85152085
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US17/816,197 Pending US20230044078A1 (en) | 2021-07-30 | 2022-07-29 | Unified Sample Reweighting Framework for Learning with Noisy Data and for Learning Difficult Examples or Groups |
Country Status (1)
Country | Link |
---|---|
US (1) | US20230044078A1 (en) |
-
2022
- 2022-07-29 US US17/816,197 patent/US20230044078A1/en active Pending
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US20210034985A1 (en) | Unification of models having respective target classes with distillation | |
CN111279362B (en) | Capsule neural network | |
US11776095B2 (en) | Photo relighting using deep neural networks and confidence learning | |
US20230103638A1 (en) | Image-to-Image Mapping by Iterative De-Noising | |
US11769228B2 (en) | Image enhancement via iterative refinement based on machine learning models | |
CN116261731A (en) | Relation learning method and system based on multi-hop attention-seeking neural network | |
US20220366260A1 (en) | Kernelized Classifiers in Neural Networks | |
US11947626B2 (en) | Face recognition from unseen domains via learning of semantic features | |
US20220269977A1 (en) | Federated Learning with Dataset Sketch Commitment Based Malicious Participant Identification | |
US20230081171A1 (en) | Cross-Modal Contrastive Learning for Text-to-Image Generation based on Machine Learning Models | |
US20180330275A1 (en) | Resource-efficient machine learning | |
US20220108423A1 (en) | Conditional Axial Transformer Layers for High-Fidelity Image Transformation | |
US10528889B2 (en) | Stereoscopic learning for classification | |
JP7293387B2 (en) | Data classification method, classifier training method and system | |
US20210303725A1 (en) | Partially customized machine learning models for data de-identification | |
CN115699041A (en) | Extensible transfer learning using expert models | |
US20220076018A1 (en) | Determining Regions of Interest for Photographic Functions | |
US20220198277A1 (en) | Post-hoc explanation of machine learning models using generative adversarial networks | |
US20230044078A1 (en) | Unified Sample Reweighting Framework for Learning with Noisy Data and for Learning Difficult Examples or Groups | |
US11868440B1 (en) | Statistical model training systems | |
Maheswari et al. | Kernelized Spectral Clustering based Conditional MapReduce function with big data | |
US20230153843A1 (en) | System to combine intelligence from multiple sources that use disparate data sets | |
US20210256374A1 (en) | Method and apparatus with neural network and training | |
CN116011509A (en) | Hardware-aware machine learning model search mechanism | |
US20220309292A1 (en) | Growing labels from semi-supervised learning |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:KUMAR, ABHISHEK;AMID, EHSAN;REEL/FRAME:060683/0662Effective date: 20220729 |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: DOCKETED NEW CASE - READY FOR EXAMINATION |