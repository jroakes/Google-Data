US20050259817A1 - Method and apparatus for communication efficient private information retrieval and oblivious transfer - Google Patents
Method and apparatus for communication efficient private information retrieval and oblivious transfer Download PDFInfo
- Publication number
- US20050259817A1 US20050259817A1 US11/133,836 US13383605A US2005259817A1 US 20050259817 A1 US20050259817 A1 US 20050259817A1 US 13383605 A US13383605 A US 13383605A US 2005259817 A1 US2005259817 A1 US 2005259817A1
- Authority
- US
- United States
- Prior art keywords
- database
- value
- modulus
- index
- query
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Granted
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/60—Protecting data
- G06F21/62—Protecting access to data via a platform, e.g. using keys or access control rules
- G06F21/6218—Protecting access to data via a platform, e.g. using keys or access control rules to a system of files or objects, e.g. local or distributed file system or database
- G06F21/6245—Protecting personal data, e.g. for financial or medical purposes
- G06F21/6254—Protecting personal data, e.g. for financial or medical purposes by anonymising data, e.g. decorrelating personal data from the owner's identification
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/60—Protecting data
- G06F21/62—Protecting access to data via a platform, e.g. using keys or access control rules
- G06F21/6218—Protecting access to data via a platform, e.g. using keys or access control rules to a system of files or objects, e.g. local or distributed file system or database
- G06F21/6227—Protecting access to data via a platform, e.g. using keys or access control rules to a system of files or objects, e.g. local or distributed file system or database where protection concerns the structure of data, e.g. records, types, queries
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/30—Public key, i.e. encryption algorithm being computationally infeasible to invert or user's encryption keys not requiring secrecy
- H04L9/3006—Public key, i.e. encryption algorithm being computationally infeasible to invert or user's encryption keys not requiring secrecy underlying computational problems or public-key parameters
- H04L9/3013—Public key, i.e. encryption algorithm being computationally infeasible to invert or user's encryption keys not requiring secrecy underlying computational problems or public-key parameters involving the discrete logarithm problem, e.g. ElGamal or Diffie-Hellman systems
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L2209/00—Additional information or applications relating to cryptographic mechanisms or cryptographic arrangements for secret or secure communication H04L9/00
- H04L2209/16—Obfuscation or hiding, e.g. involving white box
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L2209/00—Additional information or applications relating to cryptographic mechanisms or cryptographic arrangements for secret or secure communication H04L9/00
- H04L2209/50—Oblivious transfer
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99931—Database or file accessing
- Y10S707/99932—Access augmentation or optimizing
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99931—Database or file accessing
- Y10S707/99933—Query processing, i.e. searching
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99931—Database or file accessing
- Y10S707/99937—Sorting
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99931—Database or file accessing
- Y10S707/99938—Concurrency, e.g. lock management in shared database
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99931—Database or file accessing
- Y10S707/99939—Privileged access
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99941—Database schema or data structure
- Y10S707/99942—Manipulating data structure, e.g. compression, compaction, compilation
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99941—Database schema or data structure
- Y10S707/99943—Generating database or data structure, e.g. via user interface
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99941—Database schema or data structure
- Y10S707/99944—Object-oriented database structure
Definitions
- This invention relates in general to cryptography and in particular to the problems of private information retrieval and oblivious transfer.
- PIR Private Information Retrieval
- SPIR Symmetric Private Information Retrieval
- Oblivious Transfer Oblivious Transfer
- Some schemes require total communication that is super logarithmic in the size of the database or in other words, O((log 2 m) d ), where m is the number of items in the database and d is greater than 1.
- O(log 2 m) d ) The best known theoretical lower bound for total communication in such a scenario is O(log 2 m).
- the communication complexity is n O( ⁇ square root ⁇ square root over (c) ⁇ ) .
- the first assumption is the ⁇ -hiding assumption, which states, roughly, that given a composite integer n and a small prime p, it is hard to determine whether p divides ⁇ (n) with probability non-negligibly better than 1 ⁇ 2.
- the second assumption is the ⁇ -sampling assumption, which states, roughly, that it one can efficiently find a random composite n such that p divides ⁇ (n).
- Chang's scheme is a special case of a scheme due to Julian Stern that demonstrated how to construct single database private information retrieval schemes from almost any semantically secure additive homomorphic encryption scheme, of which the Paillier cryptosystem is one such example.
- the user-side communication complexity of Chang's scheme is O(m ⁇ ⁇ log m), which means that the total communication complexity is O(m ⁇ ⁇ log m).
- a method, article of manufacture and apparatus for performing private retrieval of information from a database comprising obtaining an index corresponding to information to be retrieved from the database and generating a query that does not reveal the index to the database.
- the query is an arithmetic function of the index and a secret value, wherein the arithmetic function includes a multiplicative group specified by a modulus of a random value whose order is divisible by a prime power, such that the prime power is an order of the random value.
- the secret value is an arithmetic function of the index that comprises a factorization into prime numbers of the modulus.
- the method further comprises communicating the query to the database for execution of the arithmetic function against the entirety of the database.
- FIG. 1 is a flow diagram of one embodiment of a process for privately retrieving information from a database.
- FIG. 2 is a flow diagram of one embodiment of a process for generating queries.
- FIG. 3 is a flow diagram of one embodiment of a process for generating response.
- FIG. 4 is a flow diagram of a process for performing response retrieval.
- FIG. 5 illustrates one embodiment of a client component.
- FIG. 6 illustrates one embodiment of a server component.
- FIG. 7 illustrates one embodiment of a system configuration with a client component.
- FIG. 8 is a flow diagram of one embodiment of a method for oblivious transfer query generation.
- FIG. 9 is a flow diagram of one embodiment of a process for the oblivious transfer query generation.
- FIG. 10 is a flow diagram of one embodiment of a process for the oblivious transfer response retrieval.
- FIG. 11 is a flow diagram of an alternative embodiment of a process for response generation.
- FIG. 12 is a flow diagram of an alternative embodiment of a process for the oblivious transfer response retrieval.
- FIG. 13 illustrates an example of one embodiment of a computer system.
- Private information retrieval techniques are described herein. These techniques include secure private information retrieval techniques.
- Embodiments of the present invention include schemes for secure private information retrieval that are efficient with respect to the computation requirements of the querying party and the database owner as well as the bandwidth requirements of the channels over which these parties communicate.
- a user can make queries to a database in such a manner that the user obtains the correct answer to the query without allowing the database owner to determine which query was requested.
- the database owner can ensure that the user cannot learn more information than a database might be willing to let it.
- These embodiments include schemes for which that communication is, in total, logarithmic in the size of the database. That is, the communication complexity is O(log 2 m), which falls between total communication complexity of these schema and the theoretical lower bound of O(log m), which is typically sought to be achieved. In other words, the total communication required during the interactions is O(log m).
- the communication occurs between a client and a server, where the client sends O(log m) bits to the server and the server sends O(log m) bits to the client.
- the present invention also relates to apparatus for performing the operations herein.
- This apparatus may be specially constructed for the required purposes, or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer.
- a computer program may be stored in a computer readable storage medium, such as, but is not limited to, any type of disk including floppy disks, optical disks, CD-ROMs, and magnetic-optical disks, read-only memories (ROMs), random access memories (RAMs), EPROMs, EEPROMs, magnetic or optical cards, or any type of media suitable for storing electronic instructions, and each coupled to a computer system bus.
- a machine-readable medium includes any mechanism for storing or transmitting information in a form readable by a machine (e.g., a computer).
- a machine-readable medium includes read only memory (“ROM”); random access memory (“RAM”); magnetic disk storage media; optical storage media; flash memory devices; electrical, optical, acoustical or other form of propagated signals (e.g., carrier waves, infrared signals, digital signals, etc.); etc.
- n denotes a composite modulus that is assumed to be hard to factor efficiently.
- each element of the database is assumed to be a single bit (0 or 1). It will be apparent to a person of ordinary skill in the art after having read the subsequent definition that the methods, components, and systems described herein can be modified to handle an arbitrary number of bits (for example, by simple iteration).
- a function f(n) is negligible if, for any polynomial function q(n), there is a value no such that for all n>n 0 , it holds that f(n) ⁇ 1/q(n).
- the security of many cryptographic inventions relies upon making certain computational intractability assumptions; for example, one may try to prove that a cryptosystem is secure so long as it is difficult to decompose a specific number into its prime factors efficiently.
- the term “computational” is often used to identify this class of cryptosystems (i.e., one that is secure so long as it is difficult to decompose a specific number into its primary factors efficiently.
- single-database computational private information retrieval schemes denote that some computational assumption is required in order to establish the security of the scheme.
- information theoretic” or “unconditional” is often used in the art in conjunction with schemes that are mathematically seen to meet a specific meaningful security definition without making any type of assumption.
- a polylogarithmic single database computational private information retrieval scheme conforms to the following definition.
- Definition 1 Polylogarithmic PIR. Let D( ⁇ , ⁇ , ⁇ ), Q( ⁇ , ⁇ , ⁇ ), and R( ⁇ , ⁇ , ⁇ , ⁇ , ⁇ ), be efficient algorithms.
- (D, Q, R) is a fully polylogarithmic CPIR scheme if there exist contants a, b, c, d>0 such that,
- the original assumption uses the set of k-bit primes for k>h.
- P a set of permissible sets
- the sampling algorithm is uniformly random. This may be generalized by simply requiring that there be some efficiently computable distribution that makes the problem hard. Therefore, the original form is a stronger assumption.
- Definition 3 The ⁇ -Hiding Assumption for P).
- neg(k) be a negligible function in k.
- f a constant such that P ⁇ P and any p 0 ⁇ P
- a distribution D may be defined for which the various ⁇ -hiding assumptions are more likely to hold.
- prime numbers greater than 3 One can make a similar argument for prime numbers greater than 3. For example, suppose D draws two-prime composite numbers uniformly from H max(f
- distribution D is adjusted so that the distinguishing advantage is negligible.
- One solution that achieves this aim is to adjust the distribution D so that, when it samples from H max(f
- FIG. 1 is a flow diagram of one embodiment of a process for privately retrieving information from a database.
- the process is performed by processing logic that may comprise hardware (e.g., circuitry, dedicated logic, etc.), software (such as is run on a general purpose computer system or a dedicated machine), or a combination of both.
- Processing logic may comprise firmware.
- the processing logic is part of a client device (e.g., a computer system, a mobile device (e.g., a cellular phone)).
- the process begins by processing logic obtaining an index corresponding to information to be retrieved from the database (processing block 101 ).
- the index represents an address specifying a specific location in the database.
- processing logic uses the index to generate a query that is an arithmetic function of the index and a secret value that is an arithmetic function of the index (processing block 102 ).
- the arithmetic function includes a modulus and a random value and represents an encoding of the index to avoid revealing the index to the database.
- the secret value comprises the factorization into prime numbers of the modulus.
- the query comprises O(log m) bits, wherein m equals the number of elements stored in the database.
- processing logic After generating the query, processing logic communicates the query to the database for execution of the arithmetic function against the entirety of the database (processing block 103 ).
- processing logic receives results of the execution of the arithmetic function by the database (processing block 104 ) and decodes the results (processing block 105 ).
- the total amount of information exchanged with the database is less than the total amount of information stored in the database.
- FIG. 2 is a flow diagram of one embodiment of a process for generating queries.
- the process is performed by processing logic that may comprise hardware (e.g., circuitry, dedicated logic, etc.), software (such as is run on a general purpose computer system or a dedicated machine), or a combination of both.
- processing logic may comprise firmware.
- the process has a number of values as inputs (m, l, k 0 , P, D, ⁇ ), where m is the number of bits in the database; i ⁇ [1,m] is the index of the database representing the item in which querier is interested; k 0 is a security parameter that can be increased to provide greater security; P is a set of prime powers; D is a distribution over H max(f
- the process begins by processing logic applying a mapping to the index to obtain a prime power (processing block 201 ).
- processing logic samples a sufficiently large modulus according to a distribution function from a set of values that ⁇ -hide the prime power (processing block 202 ). That is, the modulus is large enough to make factoring the modules difficult. For example, in one embodiment, 1024-bits is considered sufficient. However, a larger modulus may be used. In one embodiment, this occurs by generating n ⁇ D H max(f
- processing logic After sampling the modulus, processing logic generates a random value whose order is the prime power in the multiplicative group taken modulo the modulus (processing block 203 ).
- the random value is generated by generating random ⁇ (Z/nZ)* with order divisible by p i′
- processing logic After generating the random value, processing logic outputs the query (processing block 204 ).
- the query q (n; x) and a secret s that represents n's factorization.
- FIG. 3 is a flow diagram of one embodiment of a process for generating response.
- the process is performed by processing logic that may comprise hardware (e.g., circuitry, dedicated logic, etc.), software (such as is run on a general purpose computer system or a dedicated machine), or a combination of both.
- processing logic may comprise firmware.
- the processing logic may be part of the database.
- the process has a number of values as inputs (B, n, x, P, ⁇ ), where B represents the contents of the database viewed as an m-bit string; n is a composite modulus; ⁇ is an element from (Z/n Z)*; P is a set of prime powers; and ⁇ is the above-mentioned mapping from [1,m] to P.
- the process begins by partitioning the database into multiple groups (processing block 301 ).
- l
- processing logic represents each of multiple groups of a database as an integer (processing block 302 ). In one embodiment, this occurs by expressing each C i as a number C′ i ⁇ [0,2 l ⁇ 1]. That is, view C i as the base 2 representation of a number in [0,2 l ⁇ 1] call this number C′ i .
- processing logic computes an integer value that is congruent to each integer representation of each of the groups above modulo a prime power associated with an index of said each group (processing block 303 ).
- computing the integer value occurs by setting e to be the smallest positive integer such that e ⁇ C′ i (mod p i′ ) for all i.
- FIG. 4 is a flow diagram of a process for performing response retrieval.
- the process is performed by processing logic that may comprise hardware (e.g., circuitry, dedicated logic, etc.), software (such as is run on a general purpose computer system or a dedicated machine), or a combination of both.
- processing logic may comprise firmware.
- the processing logic may be part of the database.
- the process has a number of values as inputs (m, i, n, ⁇ , r), where m is the number of bits in the database; i ⁇ [1,m] is the index of the database representing the item in which querier is interested; n is a composite modulus; x is an element from (Z/n Z)*; and r is a value in (Z/n Z)*.
- the process begins by processing logic determining a first value by exponentiating a first input base to a power equal to the Euler totient function applied to a modulus divided by a prime power associated with a specified index and performing a modulo operation using a modulus on a result of exponentiating the first input base (processing block 401 ).
- processing logic determines a second value by exponentiating a second input base to the prime power and performing a modulo operation using the modulus on a result of exponentiating the first input base (processing block 402 ).
- processing logic After determining the second value, processing logic arithmetically determines a third value based on a discrete logarithm of the second value with respect to a base equal to the first value (processing block 403 ).
- the third value is generated by computing C′ i , which is the discrete logarithm (modulo n) of z for base y.
- processing logic generates at least one bit associated with the query from the third value (processing block 404 ).
- generating at least one bit comprises outputting B i , which is the (i mod l) bit of C′ i .
- the client component may be a hardware apparatus (e.g., circuitry, dedicated logic, etc.), software apparatus (such as is run on a general purpose computer system or a dedicated machine), or a combination of both, capable of performing processing logic.
- FIG. 5 is a block diagram of one embodiment of the client. Referring to FIG. 5 , the client comprises an external network interface 501 through which a request for a database item can be made by executing the method of generating queries and transmitting the response; and a processor 502 coupled to external network interface 501 and the memory 503 . In one embodiment, processor 502 receives a response for the database and is capable of applying a method for reconstruction and thereby obtaining the item contained in the database in which it is interested.
- processor 502 receives a response for the database and is capable of applying a method for reconstruction and thereby obtaining the item contained in the database in which it is interested.
- the server component may be a hardware apparatus (e.g., circuitry, dedicated logic, etc.), software apparatus (such as is run on a general purpose computer system or a dedicated machine), or a combination of both, capable of performing processing logic.
- FIG. 6 is a block diagram of one embodiment of the client. Referring to FIG. 6 , the server comprises an external network interface 601 through which a request for a database item can be received; and a processor 602 coupled to the external network interface and the memory. The processor transmits to the network the output given by a method for generating a database response, where the second and third inputs are taken from the request.
- a system for communicating data between a client and server provides single-database computational private information retrieval may be considered.
- Such a system comprises a client component capable of generating database queries and transmitting such queries over a communications network to a server; and receiving a response via a communications network from the server and reconstructing the database item in which it is interested; and a server component is capable of generating a database response and transmitting such response over a communications network to a client.
- the server's privacy is also maintained in the sense that the querier should only be permitted to retrieve a single bit of information.
- the techniques described herein for the private information retrieval scheme can be modified to provide for oblivious transfer.
- a generic composition paradigm for composing a somewhat inefficient oblivious transfer scheme is defined with an efficient private information retrieval scheme to achieve an efficient oblivious transfer scheme.
- the composition paradigm works since the inefficient oblivious transfer component only operates on small inputs, whereas the more efficient private information retrieval component operates on larger size inputs.
- an oblivious transfer scheme is obtained that achieves logarithmic total communication.
- the techniques for the Private Information Retrieval described above allow the querier to recover (at least) log m bits, where m is the size of the database.
- the scheme allows the querier to only recover a single bit from a given l-bit (l ⁇ log m) block C i , but also prevents the querier from recovering bits from more than one block.
- oblivious transfer schemes subject to the constraint that
- O(
- this constraint is used so that the communication complexity of the Oblivious Transfer scheme is O(log m).
- the techniques of the private information retrieval scheme described above may be modified so that it ensures that a querier cannot recover more than a single bit of any block.
- FIG. 8 is a flow diagram of one embodiment of a method for oblivious transfer query generation.
- the process is performed by processing logic that may comprise hardware (e.g., circuitry, dedicated logic, etc.), software (such as is run on a general purpose computer system or a dedicated machine), or a combination of both.
- processing logic may comprise firmware.
- the operations in the flow diagram are performed by a querier.
- the process begins by processing logic mapping database bits in the database B to prime powers (processing block 801 ). This occurs in the same way as above, except that it is possible that the prime powers could be smaller or larger than original (even though the base prime numbers are the same). In one embodiment, since each prime power is greater than 2 max(ri) (as opposed to originally, where each prime power needed to be greater than 2 l ), the database's responses can be encoded losslessly.
- processing logic in the querier generates a modulus n that ⁇ -hides the appropriate prime power p i , as well as a generator ⁇ (processing block 802 ). This supposes that the querier is interested in database bit C ij ⁇ the jth bit, j ⁇ [1,l], in block C i .
- processing logic in the querier generates an Oblivious Transfer query q OT l′j j that encodes an index in j ⁇ [1,l], such that (for any string C i ) the database's Oblivious Transfer response OT l (C i , q OT i′ j )allows the querier to recover C ij (processing block 803 ).
- FIG. 9 is a flow diagram of one embodiment of a process for the oblivious transfer query generation.
- the process is performed by processing logic that may comprise hardware (e.g., circuitry, dedicated logic, etc.), software (such as is run on a general purpose computer system or a dedicated machine), or a combination of both.
- processing logic may comprise firmware.
- the operations in the flow diagram are performed by the database.
- processing logic begins by processing logic computing e such that e ⁇ r ij (modp i ) for all i (processing block 901 ).
- processing logic computes the value x e (modn) (processing block 902 ) and then sends this value to the querier (processing block 903 ).
- FIG. 10 is a flow diagram of one embodiment of a process for the oblivious transfer response retrieval.
- the process is performed by processing logic that may comprise hardware (e.g., circuitry, dedicated logic, etc.), software (such as is run on a general purpose computer system or a dedicated machine), or a combination of both.
- processing logic may comprise firmware.
- the operations set forth in FIG. 10 are performed by the querier.
- processing logic begins by processing logic recovering r ij (processing block 1001 ).
- processing logic performs the recovery in the same way that C i is recovered in the reconstruction processes for private information retrieval.
- processing logic recovers bit C ij from the oblivious transfer response r ij (processing block 1002 ).
- the querier ensures that the querier cannot recover more than one bit from any single block C i , but it does not guarantee that the querier cannot recover one bit from more than one block.
- the querier could choose n so that it ⁇ -hides two prime powers p i1 and p i2 ; in this case, the database's Oblivious-Transfer-supplemented response above would give the querier two database bits—namely, C i1j and C i2j .
- a technique is used to ensure that the database can be sure that the querier cannot benefit from ⁇ -hiding more than one prime power in n. For the sake of argument, imagine that the database could be sure that ⁇ (n) is divisible by only one of the prime powers p i and is relatively prime to the rest.
- e′ is the smallest integer that is congruent to r ij modulo p i
- the querier can obtain any information about the value of C i2j in this scenario if p i2 is relatively prime to ⁇ (n), the answer is that the querier can at best get negligible information, even if it has unbounded computational power and knows every other bit in the database, because the only information that the querier gets about C i2j is embedded in e.
- the only information that the querier can derive about e is as follows:
- the user chooses n such that ⁇ (n) is divisible by only one of the prime powers p i and is relatively prime to the rest. Note if the querier does not cheat (and ⁇ (n) is relatively prime to all of the prime powers except the one (p i ) that divides it), then any number in Z/nZ will have a unique ( ⁇ k ⁇ i P k )-th root modulo n. However, if the user does cheat, the root (if it exists at all) will not be unique.
- the database masks the bits in the block C i with a pseudorandom sequence generated from the unique ( ⁇ k ⁇ i P k )-th root that the non-cheater can compute but the cheater cannot. (It then generates r ij from this masked string rather than the original C i .)
- the process for query generation for oblivious transfer query generation is same as the process described above.
- FIG. 11 is a flow diagram of an alternative embodiment of a process for response generation.
- the process is performed by processing logic that may comprise hardware (e.g., circuitry, dedicated logic, etc.), software (such as is run on a general purpose computer system or a dedicated machine), or a combination of both.
- processing logic may comprise firmware.
- the operations set forth in FIG. 11 are performed by the database.
- FIG. 12 is a flow diagram of an alternative embodiment of a process for the oblivious transfer response retrieval.
- the process is performed by processing logic that may comprise hardware (e.g., circuitry, dedicated logic, etc.), software (such as is run on a general purpose computer system or a dedicated machine), or a combination of both.
- processing logic may comprise firmware.
- the operations set forth in FIG. 12 are performed by the querier.
- processing logic begins by processing logic recovering r ij using the standard mechanism discussed above, namely, exponentiating by ⁇ (n)/p i and then computing the relevant discrete logarithm (processing block 1201 ).
- processing logic recovers the j-th bit of C′ i (processing block 1202 ).
- processing logic recovers y i as the unique (II k ⁇ i P k )-th root of Y modulo n (processing block 1203 ).
- processing logic computes C ij (processing block 1204 ).
- the only security property needed from the function H is that the resulting bit be unpredictable.
- Such methods may include, but are not limited to the use of a hard-core bit; the use of a secure cryptographic hash function such as SHA-1; and the use of a semantically secure encryption scheme.
- the oblivious transfer client component may be a hardware apparatus (e.g., circuitry, dedicated logic, etc.), software apparatus (such as is run on a general purpose computer system or a dedicated machine), or a combination of both, capable of performing processing logic.
- the component has similar components to the client component of FIG. 5 .
- the component comprises an external network interface through which a request for a database item can be made.
- the oblivious transfer client does so by executing the method of generating oblivious transfer queries and transmitting the response.
- the component further comprises a processor coupled to the external network interface and the memory. The processor receives a response for the oblivious transfer database and is capable of applying a reconstruction process to obtain the item contained in the database in which it is interested.
- the oblivious transfer server component may be a hardware apparatus (e.g., circuitry, dedicated logic, etc.), software apparatus (such as is run on a general purpose computer system or a dedicated machine), or a combination of both, capable of performing the processing described above.
- the component has similar components to the client component of FIG. 6 .
- the server component comprises an external network interface through which a request for a database item can be received.
- the component further comprises a processor coupled to the external network interface and the memory. The processor transmits to the network the output given by a process for generating an oblivious transfer database response where the second and third inputs are taken from the request.
- a system communicates data between a client and server to provide single-database oblivious transfer.
- the system comprises a client component is capable of oblivious transfer database queries and transmitting such queries over a communications network to a server and an oblivious transfer response via a communications network from the server and reconstructing the database item in which it is interested.
- the server component generates a database response and transmitting such a response over a communications network to a client.
- An inefficient oblivious transfer scheme may be constructed using the private information retrieval scheme described above.
- this inefficient scheme is composed with the private information retrieval scheme described herein, the resulting scheme is an efficient oblivious transfer scheme.
- the composition is efficient since the “inefficient” oblivious transfer scheme only operates on small input values, whereas the efficient private information retrieval scheme operates on large input values.
- the scheme is a modification of the private information retrieval scheme, wherein the value l is chosen to be equal to m.
- the resulting database is divided into m blocks, each constituting one bit.
- each value is masked using a pseudorandom sequence generated from the unique (II k ⁇ i P k )th root that the non-cheater can compute but the cheater cannot.
- the above Oblivious Transfer scheme has O(m) computation for the querier (rather than the O( ⁇ square root ⁇ square root over (m) ⁇ ) computation as in the private information retrieval scheme), since the querier computes a modular root.
- O(m 1/c ) may be obtained at the expense of increasing the scheme's communication complexity by a factor of f c ⁇ 1 , where f is the constant representing the minimum tolerable value of (log n)/
- the processes described herein can be extended to achieve Oblivious File Transfer.
- the example scenario is that the querier wants a file from the database, and the database wants to limit the user to one file per query. It is possible to construct a more efficient solution than the bit-wise solution by associating each file with a prime power (rather than each l-bit string). A long file can be obliviously transferred with only constant-factor ciphertext expansion.
- FIG. 13 is a block diagram of an exemplary computer system that may perform one or more of the operations described herein.
- the computer system may comprise an exemplary client or server computer system.
- the computer system comprises a communication mechanism or bus for communicating information, and a processor coupled with a bus for processing information.
- the processor includes a microprocessor, but is not limited to a microprocessor, such as, for example, Pentium, PowerPC, Alpha, etc.
- the system further comprises a random access memory (RAM), or other dynamic storage device (referred to as main memory) coupled to the bus for storing information and instructions to be executed by the processor.
- main memory also may be used for storing temporary variables or other intermediate information during execution of instructions by the processor.
- the computer system also comprises a read only memory (ROM) and/or other static storage device coupled to the bus for storing static information and instructions for the processor, an a data storage device, such as a magnetic disk or optical disk and its corresponding disk drive.
- the data storage device is coupled to the bus for storing information and instructions.
- the computer system may further be coupled to a display device, such as a cathode ray tube (CRT) or liquid crystal display (LCD), coupled to the bus for displaying information to a computer user.
- An alphanumeric input device including alphanumeric and other keys, may also be coupled to the bus for communicating information and command selections to the processor.
- An additional user input device is cursor control, such as a mouse, trackball, trackpad, stylus, or cursor direction keys, coupled to the bus for communicating direction information and command selections to the processor, and for controlling cursor movement on the display.
- Another device that may be coupled to the bus is a hard copy device, which may be used for printing instructions, data, or other information on a medium such as paper, film, or similar types of media.
- a sound recording and playback device such as a speaker and/or microphone may optionally be coupled to the bus for audio interfacing with the computer system.
- Another device that may be coupled to the bus is a wired/wireless communication capability to communication to a phone or handheld palm device.
Abstract
Description
- The present patent application claims priority to the corresponding provisional patent application Ser. No. 60/573,573, titled, “Method And Apparatus For Communication Efficient Private Information Retrieval And Oblivious Transfer” filed on May 20, 2004.
- This invention relates in general to cryptography and in particular to the problems of private information retrieval and oblivious transfer.
- Consider, the following scenario with two fictitious parties Alice and Bob. A party Bob owns a database D consisting of m data elements. A user Alice wishes to access this database, and establishes an agreement with Bob whereby she can achieve such access. However, for privacy reasons, Alice does not want Bob to know what items she is querying in the database. Naturally, one can imagine a number of scenarios in which database privacy is desired.
- The problem area to address the above concerns is known in the art and referred to herein as Private Information Retrieval (PIR). When concerned with maintaining database privacy (for example, by preventing the user from learning any more information than it should), the problem area is sometimes referred in the art and herein as either Symmetric Private Information Retrieval (SPIR) or as Oblivious Transfer.
- One trivial scheme for achieving the goal of privacy is for the database owner (in this case Bob) to send the entire database to Alice. If the database contains m bits, then the total communication complexity is O(m), where this notation for purposes herein means a m+b, where a and b are numbers. Alice can make any query, and Bob will trivially have no information about Alice's query. Of course, this solution is completely impractical for even a moderately-sized database. Additionally, this type of scheme does not satisfy the need for maintaining database privacy.
- Some schemes require total communication that is super logarithmic in the size of the database or in other words, O((log2m)d), where m is the number of items in the database and d is greater than 1. The best known theoretical lower bound for total communication in such a scenario is O(log2m).
- Chor, Kushilevitz, Goldreich, and Sudan in Private Information Retrieval, Journal of the ACM, 45, 1998 (earlier version in FOCS 95) considered the information-theoretic case wherein the security analysis requires no computational assumptions. For this case, they show that if only a single database is used, then m bits must be communicated. On the other hand, if several replicas of identical databases are used (subject to the restriction that these databases do not communicate with each other), then one can achieve a scheme that does not require transmitting m bits. They determined that there is a 2-database private information retrieval scheme with communication complexity O(m1/3) subject to the restriction that the databases do no communicate with one another, and for any constant k≧2, there is a k-database private information retrieval scheme with communication complexity O(m1/k) subject to the restriction that the databases do no communicate with one another.
- Ambainis in Upper Bound on the communication complexity of private information retrieval, in Proc. of the 24th ICALP, 1997, showed that for any constant k≧2, there is a k-database private information retrieval scheme with communication complexity
subject to the restriction that the databases do no communicate with one another, and for k=θ(log m), there is a θ(log m)-database private information retrieval scheme with communication complexity O(log2m−log log m), again subject to the restriction that the databases do no communicate with one another. - Chor and N. Gilboa, in Computationally Private Information Retrieval, Proceedings of 29th STOC, pp. 304-313, 1997, show that for every ∈>0, there is a 2-database private information retrieval scheme with communication complexity O(m∈). Their scheme requires the existence of pseudo-random generators. It is well known in the art that such generators can be constructed if one-way functions exist.
- E. Kushilevitz and R. Ostrovsky, in Replication is not needed: single database, computationally private information retrieval, in Proceedings of FOC '97, pp. 364-373, used a computational intractability assumption to achieve a single database (i.e., k=1) private information retrieval scheme whose communication complexity is less than m. Under the well known Quadratic Residuocity assumption, they demonstrated that for any ∈>0, there a single-database computational private information retrieval scheme whose communication complexity is O(m∈). To construct such a scheme, they first demonstrated a basic scheme with communication complexity O((2{square root}{square root over (m)}+1)−k) where k is a security parameter. Under the assumption that k=mc for some constant c, the resulting scheme achieves communication complexity
Next, Kushilevitz and Ostrovsky demonstrated that if one of the steps in this scheme could itself be replaced by a single-database computational private information retrieval protocol, then the resulting communication complexity would be lower. Using this idea, they proposed a recursive scheme whose communication complexity is
where L is the number of levels of recursion. By making an assumption that the security parameter is k=mc for some constant c, and setting L+O({square root}{square root over (log m/log k)}), the communication complexity is nO({square root}{square root over (c)}). - Subsequently, Cachin, Micali, and Stadler in Computational Private Information Retrieval with Polylogarithmic Communication, in Proc. of Eurocrypt 1999, LNCS, pages 402-414. Springer-Verlag, 1999, showed how to construct a single-database computational private information retrieval scheme for which the communication complexity is polylogarithmic in the size of the database; i.e., O(logdm), where d is a constant greater than 1. For the recommended parameters in their scheme, d=6, which makes the actual total communication complexity O(log6 m). The Cachin-Micali-Stadler scheme is based on two computational intractability assumptions. The first assumption is the Φ-hiding assumption, which states, roughly, that given a composite integer n and a small prime p, it is hard to determine whether p divides Ø(n) with probability non-negligibly better than ½. The second assumption is the Φ-sampling assumption, which states, roughly, that it one can efficiently find a random composite n such that p divides Φ(n).
- In order for the user to obtain the i-th bit of an m-bit database, he must at least send some encoding of i. Thus, in any scheme O(log m) bits have to be communicated. However, there is still a gap between the Cachin-Micali-Stadler scheme (which has complexity O(log6 m), and the theoretical lower bound of O(log m).
- Chang in Single-Database Private Information Retrieval with Logarithmic Communication, in Proc. of 9th Australasian Conference on Information Security and Privacy (ACISP 2004), Sydney, Australia, Lecture Notes in Computer Science, Springer Verlag, demonstrated the first single database computational private information retrieval scheme for which the server side communication complexity is O(log m). The scheme utilizes Paillier's cryptosystem as a building block and thus is secure as long as that cryptosystem is. The Paillier cryptosystem, in turn, can be shown to be secure assuming the composite residuosity assumption, which is an extension of the Quadratic-Residuosity assumption (which is the same assumption used in the Kushilevitz-Ostrovsky scheme described above). Roughly speaking, the composite residuosity assumption states that it is computationally intractable to decide whether a random element in (Z/n2Z )* has an nth root modulo n2. Chang's scheme is a special case of a scheme due to Julian Stern that demonstrated how to construct single database private information retrieval schemes from almost any semantically secure additive homomorphic encryption scheme, of which the Paillier cryptosystem is one such example. However, the user-side communication complexity of Chang's scheme is O(m∈·log m), which means that the total communication complexity is O(m∈·log m).
- Thus, from the perspective of overall communication complexity, the Cachin-Micali-Stadler scheme is better. Nonetheless, there was still a significant gap between the O(log6m) complexity of this scheme and the theoretical lower bound of O(log m).
- A method, article of manufacture and apparatus for performing private retrieval of information from a database is disclosed. In one embodiment, the method comprising obtaining an index corresponding to information to be retrieved from the database and generating a query that does not reveal the index to the database. The query is an arithmetic function of the index and a secret value, wherein the arithmetic function includes a multiplicative group specified by a modulus of a random value whose order is divisible by a prime power, such that the prime power is an order of the random value. The secret value is an arithmetic function of the index that comprises a factorization into prime numbers of the modulus. The method further comprises communicating the query to the database for execution of the arithmetic function against the entirety of the database.
- The present invention will be understood more fully from the detailed description given below and from the accompanying drawings of various embodiments of the invention, which, however, should not be taken to limit the invention to the specific embodiments, but are for explanation and understanding only.
-
FIG. 1 is a flow diagram of one embodiment of a process for privately retrieving information from a database. -
FIG. 2 is a flow diagram of one embodiment of a process for generating queries. -
FIG. 3 is a flow diagram of one embodiment of a process for generating response. -
FIG. 4 is a flow diagram of a process for performing response retrieval. -
FIG. 5 illustrates one embodiment of a client component. -
FIG. 6 illustrates one embodiment of a server component. -
FIG. 7 illustrates one embodiment of a system configuration with a client component. -
FIG. 8 is a flow diagram of one embodiment of a method for oblivious transfer query generation. -
FIG. 9 is a flow diagram of one embodiment of a process for the oblivious transfer query generation. -
FIG. 10 is a flow diagram of one embodiment of a process for the oblivious transfer response retrieval. -
FIG. 11 is a flow diagram of an alternative embodiment of a process for response generation. -
FIG. 12 is a flow diagram of an alternative embodiment of a process for the oblivious transfer response retrieval. -
FIG. 13 illustrates an example of one embodiment of a computer system. - Private information retrieval techniques are described herein. These techniques include secure private information retrieval techniques. Embodiments of the present invention include schemes for secure private information retrieval that are efficient with respect to the computation requirements of the querying party and the database owner as well as the bandwidth requirements of the channels over which these parties communicate. In one embodiment, a user can make queries to a database in such a manner that the user obtains the correct answer to the query without allowing the database owner to determine which query was requested. In another embodiment, the database owner can ensure that the user cannot learn more information than a database might be willing to let it. These embodiments include schemes for which that communication is, in total, logarithmic in the size of the database. That is, the communication complexity is O(log2m), which falls between total communication complexity of these schema and the theoretical lower bound of O(log m), which is typically sought to be achieved. In other words, the total communication required during the interactions is O(log m).
- In one embodiment, the communication occurs between a client and a server, where the client sends O(log m) bits to the server and the server sends O(log m) bits to the client.
- It will be apparent, however, to one skilled in the art, that the present invention may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form, rather than in detail, in order to avoid obscuring the present invention.
- Some portions of the detailed descriptions which follow are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here, and generally, conceived to be a self-consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.
- It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion, it is appreciated that throughout the description, discussions utilizing terms such as “processing” or “computing” or “calculating” or “determining” or “displaying” or the like, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.
- The present invention also relates to apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes, or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium, such as, but is not limited to, any type of disk including floppy disks, optical disks, CD-ROMs, and magnetic-optical disks, read-only memories (ROMs), random access memories (RAMs), EPROMs, EEPROMs, magnetic or optical cards, or any type of media suitable for storing electronic instructions, and each coupled to a computer system bus.
- The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein, or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear from the description below. In addition, the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.
- A machine-readable medium includes any mechanism for storing or transmitting information in a form readable by a machine (e.g., a computer). For example, a machine-readable medium includes read only memory (“ROM”); random access memory (“RAM”); magnetic disk storage media; optical storage media; flash memory devices; electrical, optical, acoustical or other form of propagated signals (e.g., carrier waves, infrared signals, digital signals, etc.); etc.
- Definition of Terms
- Throughout the following description, m denotes the number of elements in the database, and n denotes a composite modulus that is assumed to be hard to factor efficiently. For simplicity, each element of the database is assumed to be a single bit (0 or 1). It will be apparent to a person of ordinary skill in the art after having read the subsequent definition that the methods, components, and systems described herein can be modified to handle an arbitrary number of bits (for example, by simple iteration).
- Also for purposes herein, a function f(n) is negligible if, for any polynomial function q(n), there is a value no such that for all n>n0, it holds that f(n)<1/q(n). One example of such a negligible function is f(n)=½n.
- If a and b are two integers with a≦b, let [a, b] denote the set of integers between a and b inclusive. That is, [a,b]={c∈Z|a≦c≦b}. If S is a set of elements, and D is a sample-able probability distribution on S, we denote by s←DS the process of picking an element s from S according to the distribution D.
- The security of many cryptographic inventions relies upon making certain computational intractability assumptions; for example, one may try to prove that a cryptosystem is secure so long as it is difficult to decompose a specific number into its prime factors efficiently. The term “computational” is often used to identify this class of cryptosystems (i.e., one that is secure so long as it is difficult to decompose a specific number into its primary factors efficiently. Thus, single-database computational private information retrieval schemes denote that some computational assumption is required in order to establish the security of the scheme. The term “information theoretic” or “unconditional” is often used in the art in conjunction with schemes that are mathematically seen to meet a specific meaningful security definition without making any type of assumption.
- With respect to assumptions, often times one assumption implies another. Typically this is shown in the art by providing a transformation (often known in the art as a reduction) that converts a mechanism for violating the second assumption to a mechanism for violating the first assumption. In such cases, the first assumption is called “stronger”, while the second is called “weaker.” In general, weaker assumptions are preferable.
- Computational Private Information Retrieval (CPIR)
- For purposes herein, a polylogarithmic single database computational private information retrieval scheme conforms to the following definition.
- Definition 1 (Polylogarithmic PIR). Let D(·,·,·), Q(·,·,·), and R(·,·,·,·,·), be efficient algorithms. By definition, (D, Q, R) is a fully polylogarithmic CPIR scheme if there exist contants a, b, c, d>0 such that,
-
-
- 1. (Correctness) For all m, all m-bit strings B, all i∈[1,m], and all k, Pr[(q,s)←RQ(m,I, 1k); r←RD(B, q, 1k): R(m, i, (q, s), r; 1k)=Bi]>1−2−ak
- 2. (Privacy) For all m, all (I, j)∈[1,m], all k such that k>max(k0, logbm), and all 2ck-gate circuits A, Pr[(q, s)←RQ(m, i, 1k): A(m, q, 1k)=1]−Pr[(q; s)←RQ(m, j, 1k): A(m, q, 1k)=1]<2−dk
where a, b, c and d use the fundamental constants of the CPIR; B constitutes the contents of the database (which may be stored on a server component) and consists of individual bits; D is the database response generation method; the pair (Q,R) constitute the query generation method and the reconstruction method respectively; s is a secret (associated to query q and used to “reconstruct” the response of the database from query q); r is the response; and k is the security parameter. In one embodiment, the security parameter k is set in accordance with the level of security desired by an individual, while the remaining parameters are set based on the features of the database (e.g., its size).
- To ensure that a polylogarithmic scheme has has purely logarithmic total communication complexity, b=1 and |q| and |r| are O(k).
- The Φ-Hiding Assumption and its Variants
- A number of assumptions relevant to proving the security of the embodiment defined herein. These assumptions are defined in terms of a variable sampling distribution D. Thereafter, specific sampling methods that are candidates for D are given.
- The original Φ-Hiding Assumption.
Definition 2 (The Φ-Hiding Assumption). There exist e, f, g, h>0 such that [[1]] for all k>h, there exists a sampling algorithm S(·) such that for all k-bit primes p, S(p) outputs a random kf-bit number n∈Hkf k that φ-hides p, and [[2]] for all k>h and polynomial time algorithms C, - Note that the original assumption uses the set of k-bit primes for k>h. To generalize, consider a set of permissible sets denoted P. For example, the set of permissible sets could be odd prime powers in a certain range. Next, in the original Φ-hiding assumption, the sampling algorithm is uniformly random. This may be generalized by simply requiring that there be some efficiently computable distribution that makes the problem hard. Therefore, the original form is a stronger assumption.
Definition 3 (The Φ-Hiding Assumption for P). There is a constant f, such that for any P∈P, there is an efficiently computable distribution D for which - The above assumption is modified in two ways. First, it is assumed that it is true even if p0 is not randomly chosen. Second, it is assumed that fewer bits are needed in the modulus to maintain security.
- In one embodiment, security for a fixed p0 is assumed since the same prime numbers are used for each new query, whereas the Cachin-Micali-Stadler scheme generates different primes for each database bit for each query. Below is the more formal statement of the definition:
Definition 4 (The Linear Φ-Hiding Assumption for P). Let neg(k) be a negligible function in k. There is a constant f such that for any P∈P, there is an efficiently computable distribution D for which
Definition 5 (The Strong Linear Φ-Hiding Assumption for P). Let neg(k) be a negligible function in k. There is a constant f such that P∈P and any p0∈P, there is an efficiently computable distribution D for which
Note that revealing a large divisor of Φ(n) may compromise n's factorization. Namely, if p>n1/4 is a divisor of Φ(n), then it is known in the prior art that one can easily factor n given (n; p). Consequently, f is at least 4. But nothing similar is known when p is smaller.
The Sampling Distribution - Given a set P, a distribution D may be defined for which the various Φ-hiding assumptions are more likely to hold. In one embodiment, the Φ-hiding assumption does not hold for p=3 when n is the product of two prime numbers and D is the uniform distribution. For example, suppose that n=Q1Q2 ≡2(mod3) for prime numbers Q1 and Q2. Then, one can tell that one of Q1 and Q2 is congruent to 1 mod 3. Thus, it is obvious that 3 divides φ(n)=(Q1−1)(Q2−1).
- One can make a similar argument for prime numbers greater than 3. For example, suppose D draws two-prime composite numbers uniformly from Hmax(f|P|,k) p and {overscore (H)}max(f|P|,k) P. Then, one can distinguish which set D drew from simply by considering D's output modulo p. Essentially, the numbers drawn from the first set will be uniform modulo p, since one prime number is congruent to 1 modulo p and the other prime number can be congruent to anything (except 0) modulo p. However, the numbers from the second set will not be uniform modulo p. In this case, both prime numbers are congruent to some number in [2,p−1] modulo p. Assume p is prime; then, for a ∈[1,p−1], the product n of two such prime numbers has a
probability of satisfying n≡a(modp) if a≠1, but a slightly higher probability of
A similar situation occurs if p is composite. - Accordingly, in one embodiment, distribution D is adjusted so that the distinguishing advantage is negligible. One solution that achieves this aim is to adjust the distribution D so that, when it samples from Hmax(f|p|,k) P, it samples with a distribution modulo p that conforms to the non-uniform distribution described above. This can be accomplished by first sampling with a uniform distribution and then rejecting the output with certain probabilities.
- Database Queries, Responses and Reconstruction
-
FIG. 1 is a flow diagram of one embodiment of a process for privately retrieving information from a database. The process is performed by processing logic that may comprise hardware (e.g., circuitry, dedicated logic, etc.), software (such as is run on a general purpose computer system or a dedicated machine), or a combination of both. Processing logic may comprise firmware. In one embodiment, the processing logic is part of a client device (e.g., a computer system, a mobile device (e.g., a cellular phone)). - Referring to
FIG. 1 , the process begins by processing logic obtaining an index corresponding to information to be retrieved from the database (processing block 101). The index represents an address specifying a specific location in the database. - Using the index, processing logic generates a query that is an arithmetic function of the index and a secret value that is an arithmetic function of the index (processing block 102). The arithmetic function includes a modulus and a random value and represents an encoding of the index to avoid revealing the index to the database. The secret value comprises the factorization into prime numbers of the modulus. In one embodiment, the query comprises O(log m) bits, wherein m equals the number of elements stored in the database.
- After generating the query, processing logic communicates the query to the database for execution of the arithmetic function against the entirety of the database (processing block 103).
- Thereafter, processing logic receives results of the execution of the arithmetic function by the database (processing block 104) and decodes the results (processing block 105). In one embodiment, the total amount of information exchanged with the database is less than the total amount of information stored in the database.
- An Example of a Process for Generating Queries
- In what follows, let σ:[1;m]→P be a mapping of the set of database indices to a set of prime powers given by σ(i)=pil=pi′ ′c
i′ , i′=┌i/l┐, p′j where is prime, and pj is the j-th prime power in P. It is assumed for purposes herein that P and the σ mapping is known to both the querier and the database. -
FIG. 2 is a flow diagram of one embodiment of a process for generating queries. The process is performed by processing logic that may comprise hardware (e.g., circuitry, dedicated logic, etc.), software (such as is run on a general purpose computer system or a dedicated machine), or a combination of both. Processing logic may comprise firmware. - In one embodiment, the process has a number of values as inputs (m, l, k0, P, D, σ), where m is the number of bits in the database; i∈[1,m] is the index of the database representing the item in which querier is interested; k0 is a security parameter that can be increased to provide greater security; P is a set of prime powers; D is a distribution over Hmax(f|P|,k
0) Pi′ and σ is the above-mentioned mapping from [1,m] to P. - Referring to
FIG. 2 , the process begins by processing logic applying a mapping to the index to obtain a prime power (processing block 201). In one embodiment, the prime power is obtained by computing σ(i)=pi′. - With the prime power, processing logic samples a sufficiently large modulus according to a distribution function from a set of values that φ-hide the prime power (processing block 202). That is, the modulus is large enough to make factoring the modules difficult. For example, in one embodiment, 1024-bits is considered sufficient. However, a larger modulus may be used. In one embodiment, this occurs by generating n←DHmax(f|P|,k
0 ) pi′. - After sampling the modulus, processing logic generates a random value whose order is the prime power in the multiplicative group taken modulo the modulus (processing block 203). In one embodiment, the random value is generated by generating random χ∈(Z/nZ)* with order divisible by pi′
- After generating the random value, processing logic outputs the query (processing block 204). In one embodiment, the query q=(n; x) and a secret s that represents n's factorization.
- An Example of a Process for Generating a Response
- The database receives the query from the querier and, in response thereto, generates a response that is sent to the querier.
FIG. 3 is a flow diagram of one embodiment of a process for generating response. The process is performed by processing logic that may comprise hardware (e.g., circuitry, dedicated logic, etc.), software (such as is run on a general purpose computer system or a dedicated machine), or a combination of both. Processing logic may comprise firmware. The processing logic may be part of the database. - In one embodiment, the process has a number of values as inputs (B, n, x, P, σ), where B represents the contents of the database viewed as an m-bit string; n is a composite modulus; χ is an element from (Z/n Z)*; P is a set of prime powers; and σ is the above-mentioned mapping from [1,m] to P.
- Referring to
FIG. 3 , the process begins by partitioning the database into multiple groups (processing block 301). In one embodiment, the database B is partitioned into C1∥C2∥ . . . ∥Cm′ where m′=┌m/l ┐ and |C1|=|C2|=|Cm′−1|=l - After partitioning the database into groups, processing logic represents each of multiple groups of a database as an integer (processing block 302). In one embodiment, this occurs by expressing each Ci as a number C′i∈[0,2l−1]. That is, view Ci as the
base 2 representation of a number in [0,2l−1] call this number C′i. - Next, processing logic computes an integer value that is congruent to each integer representation of each of the groups above modulo a prime power associated with an index of said each group (processing block 303). In one embodiment, computing the integer value occurs by setting e to be the smallest positive integer such that e≡C′i (mod pi′) for all i.
- With the integer value, processing logic generates a response (processing block 304). In one embodiment, processing logic generates a response by exponentiating a base input value provided with an exponent equal to the integer value and performing an arithmetic modulo operation with a modulus value. In one embodiment, generating the response comprises outputting the response r=xe (modn).
- Notice that the first three operations of this technique are independent of the query. Therefore, in an alternate embodiment of the present invention, these three operations can be pre-computed.
- An Example Process for Reconstruction
- After the database provides a response to the query to the querier, the querier performs reconstruction on the results to retrieve the response.
FIG. 4 is a flow diagram of a process for performing response retrieval. The process is performed by processing logic that may comprise hardware (e.g., circuitry, dedicated logic, etc.), software (such as is run on a general purpose computer system or a dedicated machine), or a combination of both. Processing logic may comprise firmware. The processing logic may be part of the database. - In one embodiment, the process has a number of values as inputs (m, i, n, χ, r), where m is the number of bits in the database; i∈[1,m] is the index of the database representing the item in which querier is interested; n is a composite modulus; x is an element from (Z/n Z)*; and r is a value in (Z/n Z)*.
- Referring to
FIG. 4 , the process begins by processing logic determining a first value by exponentiating a first input base to a power equal to the Euler totient function applied to a modulus divided by a prime power associated with a specified index and performing a modulo operation using a modulus on a result of exponentiating the first input base (processing block 401). In one embodiment, the second value is generated by computing y=xφ(n)/Pi′ (mod n). - After determining the first value, processing logic determines a second value by exponentiating a second input base to the prime power and performing a modulo operation using the modulus on a result of exponentiating the first input base (processing block 402). In one embodiment, the second value is generated by computing and z=rφ(n)/P
i′ (mod n) - After determining the second value, processing logic arithmetically determines a third value based on a discrete logarithm of the second value with respect to a base equal to the first value (processing block 403). In one embodiment, the third value is generated by computing C′i, which is the discrete logarithm (modulo n) of z for base y.
- Once the third value is generated, processing logic generates at least one bit associated with the query from the third value (processing block 404). In one embodiment, generating at least one bit comprises outputting Bi, which is the (i mod l) bit of C′i.
- Embodiments of a Client, Server and a System for Single-Database Computational Private Information Retrieval
- The client component may be a hardware apparatus (e.g., circuitry, dedicated logic, etc.), software apparatus (such as is run on a general purpose computer system or a dedicated machine), or a combination of both, capable of performing processing logic.
FIG. 5 is a block diagram of one embodiment of the client. Referring toFIG. 5 , the client comprises anexternal network interface 501 through which a request for a database item can be made by executing the method of generating queries and transmitting the response; and aprocessor 502 coupled toexternal network interface 501 and the memory 503. In one embodiment,processor 502 receives a response for the database and is capable of applying a method for reconstruction and thereby obtaining the item contained in the database in which it is interested. - The server component may be a hardware apparatus (e.g., circuitry, dedicated logic, etc.), software apparatus (such as is run on a general purpose computer system or a dedicated machine), or a combination of both, capable of performing processing logic.
FIG. 6 is a block diagram of one embodiment of the client. Referring toFIG. 6 , the server comprises anexternal network interface 601 through which a request for a database item can be received; and aprocessor 602 coupled to the external network interface and the memory. The processor transmits to the network the output given by a method for generating a database response, where the second and third inputs are taken from the request. - A system for communicating data between a client and server provides single-database computational private information retrieval may be considered. Such a system comprises a client component capable of generating database queries and transmitting such queries over a communications network to a server; and receiving a response via a communications network from the server and reconstructing the database item in which it is interested; and a server component is capable of generating a database response and transmitting such response over a communications network to a client.
- Logarithmic Oblivious Transfer
- In Oblivious Transfer, the server's privacy is also maintained in the sense that the querier should only be permitted to retrieve a single bit of information. The techniques described herein for the private information retrieval scheme can be modified to provide for oblivious transfer.
- In one embodiment, a generic composition paradigm for composing a somewhat inefficient oblivious transfer scheme is defined with an efficient private information retrieval scheme to achieve an efficient oblivious transfer scheme. Next, how the existing private information retrieval scheme described above can be converted to such a somewhat inefficient oblivious transfer scheme is specified. The composition paradigm works since the inefficient oblivious transfer component only operates on small inputs, whereas the more efficient private information retrieval component operates on larger size inputs. By applying the composition paradigm, an oblivious transfer scheme is obtained that achieves logarithmic total communication.
- The techniques for the Private Information Retrieval described above allow the querier to recover (at least) log m bits, where m is the size of the database. To modify the scheme, the scheme allows the querier to only recover a single bit from a given l-bit (l˜log m) block Ci, but also prevents the querier from recovering bits from more than one block.
- In the following, let OTl be an existing oblivious transfer scheme, which takes as input an l-bit string Ci and the querier's query qOTl,j, and outputs a response OTl(Ci,qOT
l ,j)=rij. One can use a variety of oblivious transfer schemes, subject to the constraint that |qOTl ,j|+ri|=O(|Ci|). In one embodiment, this constraint is used so that the communication complexity of the Oblivious Transfer scheme is O(log m). Using this Oblivious Transfer scheme, the techniques of the private information retrieval scheme described above may be modified so that it ensures that a querier cannot recover more than a single bit of any block. - An Example of a Process for Oblivious Transfer Query Generation
-
FIG. 8 is a flow diagram of one embodiment of a method for oblivious transfer query generation. The process is performed by processing logic that may comprise hardware (e.g., circuitry, dedicated logic, etc.), software (such as is run on a general purpose computer system or a dedicated machine), or a combination of both. Processing logic may comprise firmware. In one embodiment, the operations in the flow diagram are performed by a querier. - Referring to
FIG. 8 , the process begins by processing logic mapping database bits in the database B to prime powers (processing block 801). This occurs in the same way as above, except that it is possible that the prime powers could be smaller or larger than original (even though the base prime numbers are the same). In one embodiment, since each prime power is greater than 2max(ri) (as opposed to originally, where each prime power needed to be greater than 2l), the database's responses can be encoded losslessly. - Next, processing logic in the querier generates a modulus n that φ-hides the appropriate prime power pi, as well as a generator χ (processing block 802). This supposes that the querier is interested in database bit Cij−the jth bit, j∈[1,l], in block Ci.
- Thereafter, processing logic in the querier generates an Oblivious Transfer query qOT
l′j j that encodes an index in j∈[1,l], such that (for any string Ci) the database's Oblivious Transfer response OTl(Ci, qOTi′ j)allows the querier to recover Cij (processing block 803). - An Example of a Process for Oblivious Transfer Response Generation
-
FIG. 9 is a flow diagram of one embodiment of a process for the oblivious transfer query generation. The process is performed by processing logic that may comprise hardware (e.g., circuitry, dedicated logic, etc.), software (such as is run on a general purpose computer system or a dedicated machine), or a combination of both. Processing logic may comprise firmware. In one embodiment, the operations in the flow diagram are performed by the database. - Referring to
FIG. 9 , the process begins by processing logic computing e such that e≡rij (modpi) for all i (processing block 901). Next, processing logic computes the value xe (modn) (processing block 902) and then sends this value to the querier (processing block 903). - An Example of a Process for Oblivious Transfer Reconstruction
-
FIG. 10 is a flow diagram of one embodiment of a process for the oblivious transfer response retrieval. The process is performed by processing logic that may comprise hardware (e.g., circuitry, dedicated logic, etc.), software (such as is run on a general purpose computer system or a dedicated machine), or a combination of both. Processing logic may comprise firmware. In one embodiment, the operations set forth inFIG. 10 are performed by the querier. - Referring to
FIG. 10 , the process begins by processing logic recovering rij (processing block 1001). In one embodiment, processing logic performs the recovery in the same way that Ci is recovered in the reconstruction processes for private information retrieval. After recovering rij, processing logic recovers bit Cij from the oblivious transfer response rij (processing block 1002). - Analysis of Oblivious Transfer Processes
- The above approach ensures that the querier cannot recover more than one bit from any single block Ci, but it does not guarantee that the querier cannot recover one bit from more than one block. For example, the querier could choose n so that it φ-hides two prime powers pi1 and pi2; in this case, the database's Oblivious-Transfer-supplemented response above would give the querier two database bits—namely, Ci1j and Ci2j.
- To address this problem, in one embodiment, a technique is used to ensure that the database can be sure that the querier cannot benefit from φ-hiding more than one prime power in n. For the sake of argument, imagine that the database could be sure that φ(n) is divisible by only one of the prime powers pi and is relatively prime to the rest. Further, suppose that e′ is the smallest integer that is congruent to rij modulo pi, and that instead of setting e=e′ (as in the above scheme), the database selects a random number z from a suitably large range (e.g., [1,n2]) and sets e=e′+zπipi and sends xe (modn) to the querier. (Notice that e still satisfies the necessary modular equations when chosen in this way.) With respect to whether the querier can obtain any information about the value of Ci2j in this scenario if pi2 is relatively prime to φ(n), the answer is that the querier can at best get negligible information, even if it has unbounded computational power and knows every other bit in the database, because the only information that the querier gets about Ci2j is embedded in e. In particular, the only information that the querier can derive about e is as follows:
- 1. The value of e mod φ(n). (The querier may be able to recover this value from by computing the discrete logarithm of xe for base x, though this is a hard problem.)
- 2. That e=e′0+zπipi or e=e′1+zπipi for z∈└1,n2┘ where e′=e′0 if Cij=0 and e′=e′1 if Cij=1. (The querier knows this since this is how the database computes e.)
- Now, the question is whether the querier can distinguish which of the two possibilities (e=e′0+zπipi) or (e=e′1+zπipi) is true. It cannot (except with negligible advantage), because the difference between the conditional probabilities (conditional on the querier's information about e) of the two events is negligible. Setting eφ(n)=e mod φ(n), there are either) └n2/φ(n)┘ or ┌n2/φ(n)┐ possible values of e that satisfy e=e φ(n) mod φ(n) and e=e′0+zπipi for z∈[1,n2]. The situation is the same for the second set of equations:e=eφ(n) mod φ(n) and (n) and (e=e′1+zπipi) for z∈[1,n2]. One can verify that the difference between the conditional probabilities is therefore at most 1/(┌n2/φ(n)┐+└n2/φ(n)┘), which is negligible.
- In one embodiment, the user chooses n such that φ(n) is divisible by only one of the prime powers pi and is relatively prime to the rest. Note if the querier does not cheat (and φ(n) is relatively prime to all of the prime powers except the one (pi) that divides it), then any number in Z/nZ will have a unique (πk≠iPk)-th root modulo n. However, if the user does cheat, the root (if it exists at all) will not be unique. To prevent cheating, therefore, the database masks the bits in the block Ci with a pseudorandom sequence generated from the unique (πk≠iPk)-th root that the non-cheater can compute but the cheater cannot. (It then generates rij from this masked string rather than the original Ci.)
- In one embodiment, methods for the overall refined Oblivious Transfer scheme is described below.
- An Alternative Embodiment of a Process for Query Generation for Oblivious Transfer
- In one embodiment, the process for query generation for oblivious transfer query generation is same as the process described above.
- An Alternative Embodiment of a Process for Response Generation
-
FIG. 11 is a flow diagram of an alternative embodiment of a process for response generation. The process is performed by processing logic that may comprise hardware (e.g., circuitry, dedicated logic, etc.), software (such as is run on a general purpose computer system or a dedicated machine), or a combination of both. Processing logic may comprise firmware. In one embodiment, the operations set forth inFIG. 11 are performed by the database. - Referring to
FIG. 11 , the process begins by processing logic processing logic generating a random number y∈(Z/nZ)*, and sets Y=yπk pk (modn)(processing block 1101). For each block Ci, processing logic sets yi=ypi (modn); sets C′i=C′i⊕H(yi); and sets rij=OTl(C′i; qOT,1) (processing block 1102). Then, processing logic generates a random number z∈[1,n2] (or in some other suitable range) (processing block 1103). Afterwards, processing logic sets e′ to be the smallest positive integer satisfying e′≡rij(modpi) for all i, and sets e=e′+zπkpk·(processing block 1104) and sends the response (Y, r), where r=xe (modn) (processing block 1105). -
FIG. 12 is a flow diagram of an alternative embodiment of a process for the oblivious transfer response retrieval. The process is performed by processing logic that may comprise hardware (e.g., circuitry, dedicated logic, etc.), software (such as is run on a general purpose computer system or a dedicated machine), or a combination of both. Processing logic may comprise firmware. In one embodiment, the operations set forth inFIG. 12 are performed by the querier. - Referring to
FIG. 12 , the process begins by processing logic recovering rij using the standard mechanism discussed above, namely, exponentiating by φ(n)/pi and then computing the relevant discrete logarithm (processing block 1201). Using rij, processing logic recovers the j-th bit of C′i (processing block 1202). Then, processing logic recovers yi as the unique (IIk≠iPk)-th root of Y modulo n (processing block 1203). Lastly, from Ci′j and H(yi), processing logic computes Cij (processing block 1204). - The only security property needed from the function H is that the resulting bit be unpredictable. There are numerous methods known to one with ordinary skill in the art for achieving this aim. Such methods may include, but are not limited to the use of a hard-core bit; the use of a secure cryptographic hash function such as SHA-1; and the use of a semantically secure encryption scheme.
- An Example of an Oblivious Transfer Client
- The oblivious transfer client component may be a hardware apparatus (e.g., circuitry, dedicated logic, etc.), software apparatus (such as is run on a general purpose computer system or a dedicated machine), or a combination of both, capable of performing processing logic. In one embodiment, the component has similar components to the client component of
FIG. 5 . For example, the component comprises an external network interface through which a request for a database item can be made. However, the oblivious transfer client does so by executing the method of generating oblivious transfer queries and transmitting the response. The component further comprises a processor coupled to the external network interface and the memory. The processor receives a response for the oblivious transfer database and is capable of applying a reconstruction process to obtain the item contained in the database in which it is interested. - An Example of an Oblivious Transfer Server
- The oblivious transfer server component may be a hardware apparatus (e.g., circuitry, dedicated logic, etc.), software apparatus (such as is run on a general purpose computer system or a dedicated machine), or a combination of both, capable of performing the processing described above. In one embodiment, the component has similar components to the client component of
FIG. 6 . For example, the server component comprises an external network interface through which a request for a database item can be received. The component further comprises a processor coupled to the external network interface and the memory. The processor transmits to the network the output given by a process for generating an oblivious transfer database response where the second and third inputs are taken from the request. - System for Single-Database Computational Private Information Retrieval
- One embodiment of a system communicates data between a client and server to provide single-database oblivious transfer. In one embodiment, the system comprises a client component is capable of oblivious transfer database queries and transmitting such queries over a communications network to a server and an oblivious transfer response via a communications network from the server and reconstructing the database item in which it is interested. In one embodiment, the server component generates a database response and transmitting such a response over a communications network to a client.
- Nesting Private Information Retrieval Methods to Achieve Oblivious Transfer
- An inefficient oblivious transfer scheme may be constructed using the private information retrieval scheme described above. When this inefficient scheme is composed with the private information retrieval scheme described herein, the resulting scheme is an efficient oblivious transfer scheme.
- The composition is efficient since the “inefficient” oblivious transfer scheme only operates on small input values, whereas the efficient private information retrieval scheme operates on large input values. The scheme is a modification of the private information retrieval scheme, wherein the value l is chosen to be equal to m. In this case, the resulting database is divided into m blocks, each constituting one bit. As above, each value is masked using a pseudorandom sequence generated from the unique (IIk≠iPk)th root that the non-cheater can compute but the cheater cannot.
- The above Oblivious Transfer scheme has O(m) computation for the querier (rather than the O({square root}{square root over (m)}) computation as in the private information retrieval scheme), since the querier computes a modular root. However, using a technique known in the art of nested private information retrieval schemes, a user computation of O(m1/c) may be obtained at the expense of increasing the scheme's communication complexity by a factor of fc−1, where f is the constant representing the minimum tolerable value of (log n)/|P|.
- The processes described herein can be extended to achieve Oblivious File Transfer. The example scenario is that the querier wants a file from the database, and the database wants to limit the user to one file per query. It is possible to construct a more efficient solution than the bit-wise solution by associating each file with a prime power (rather than each l-bit string). A long file can be obliviously transferred with only constant-factor ciphertext expansion.
- One Embodiment of a Computer System
-
FIG. 13 is a block diagram of an exemplary computer system that may perform one or more of the operations described herein. Referring toFIG. 13 , the computer system may comprise an exemplary client or server computer system. The computer system comprises a communication mechanism or bus for communicating information, and a processor coupled with a bus for processing information. The processor includes a microprocessor, but is not limited to a microprocessor, such as, for example, Pentium, PowerPC, Alpha, etc. - The system further comprises a random access memory (RAM), or other dynamic storage device (referred to as main memory) coupled to the bus for storing information and instructions to be executed by the processor. Main memory also may be used for storing temporary variables or other intermediate information during execution of instructions by the processor.
- The computer system also comprises a read only memory (ROM) and/or other static storage device coupled to the bus for storing static information and instructions for the processor, an a data storage device, such as a magnetic disk or optical disk and its corresponding disk drive. The data storage device is coupled to the bus for storing information and instructions. The computer system may further be coupled to a display device, such as a cathode ray tube (CRT) or liquid crystal display (LCD), coupled to the bus for displaying information to a computer user. An alphanumeric input device, including alphanumeric and other keys, may also be coupled to the bus for communicating information and command selections to the processor. An additional user input device is cursor control, such as a mouse, trackball, trackpad, stylus, or cursor direction keys, coupled to the bus for communicating direction information and command selections to the processor, and for controlling cursor movement on the display.
- Another device that may be coupled to the bus is a hard copy device, which may be used for printing instructions, data, or other information on a medium such as paper, film, or similar types of media. Furthermore, a sound recording and playback device, such as a speaker and/or microphone may optionally be coupled to the bus for audio interfacing with the computer system. Another device that may be coupled to the bus is a wired/wireless communication capability to communication to a phone or handheld palm device.
- Note that any or all of the components of the system and associated hardware may be used in the present invention. However, it can be appreciated that other configurations of the computer system may include some or all of the devices.
- Whereas many alterations and modifications of the present invention will no doubt become apparent to a person of ordinary skill in the art after having read the foregoing description, it is to be understood that any particular embodiment shown and described by way of illustration is in no way intended to be considered limiting. Therefore, references to details of various embodiments are not intended to limit the scope of the claims which in themselves recite only those features regarded as essential to the invention.
Claims (42)
Priority Applications (7)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US11/133,836 US7620625B2 (en) | 2004-05-20 | 2005-05-19 | Method and apparatus for communication efficient private information retrieval and oblivious transfer |
JP2007527450A JP2008500598A (en) | 2004-05-20 | 2005-05-20 | Method and apparatus for confidential information retrieval and lost communication with good communication efficiency |
PCT/US2005/017618 WO2005114481A1 (en) | 2004-05-20 | 2005-05-20 | Method and apparatus for communication efficient private information retrieval and oblivious transfer |
US12/365,833 US7941422B2 (en) | 2004-05-20 | 2009-02-04 | Method and apparatus for communication efficient private information retrieval and oblivious transfer |
US12/365,840 US20090193033A1 (en) | 2005-05-19 | 2009-02-04 | Method and apparatus for communication efficient private information retrieval and oblivious transfer |
US12/365,830 US8065332B2 (en) | 2005-05-19 | 2009-02-04 | Method and apparatus for communication efficient private information retrieval and oblivious transfer |
US12/365,837 US7987201B2 (en) | 2005-05-19 | 2009-02-04 | Method and apparatus for communication efficient private information retrieval and oblivious transfer |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US57357304P | 2004-05-20 | 2004-05-20 | |
US11/133,836 US7620625B2 (en) | 2004-05-20 | 2005-05-19 | Method and apparatus for communication efficient private information retrieval and oblivious transfer |
Related Child Applications (4)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US12/365,830 Division US8065332B2 (en) | 2005-05-19 | 2009-02-04 | Method and apparatus for communication efficient private information retrieval and oblivious transfer |
US12/365,833 Division US7941422B2 (en) | 2004-05-20 | 2009-02-04 | Method and apparatus for communication efficient private information retrieval and oblivious transfer |
US12/365,837 Division US7987201B2 (en) | 2005-05-19 | 2009-02-04 | Method and apparatus for communication efficient private information retrieval and oblivious transfer |
US12/365,840 Division US20090193033A1 (en) | 2005-05-19 | 2009-02-04 | Method and apparatus for communication efficient private information retrieval and oblivious transfer |
Publications (2)
Publication Number | Publication Date |
---|---|
US20050259817A1 true US20050259817A1 (en) | 2005-11-24 |
US7620625B2 US7620625B2 (en) | 2009-11-17 |
Family
ID=35375179
Family Applications (2)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US11/133,836 Active 2027-11-14 US7620625B2 (en) | 2004-05-20 | 2005-05-19 | Method and apparatus for communication efficient private information retrieval and oblivious transfer |
US12/365,833 Expired - Fee Related US7941422B2 (en) | 2004-05-20 | 2009-02-04 | Method and apparatus for communication efficient private information retrieval and oblivious transfer |
Family Applications After (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US12/365,833 Expired - Fee Related US7941422B2 (en) | 2004-05-20 | 2009-02-04 | Method and apparatus for communication efficient private information retrieval and oblivious transfer |
Country Status (3)
Country | Link |
---|---|
US (2) | US7620625B2 (en) |
JP (1) | JP2008500598A (en) |
WO (1) | WO2005114481A1 (en) |
Cited By (26)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20090268908A1 (en) * | 2008-04-29 | 2009-10-29 | Daniel Martin Bikel | Methods and Apparatus for Securely Classifying Data |
US20100169293A1 (en) * | 2008-12-30 | 2010-07-01 | International Business Machines Corporation | Search engine service utilizing hash algorithms |
US20110191584A1 (en) * | 2009-08-07 | 2011-08-04 | Trostle Jonathan T | System and Method for Computationally Private Information Retrieval |
US20120324240A1 (en) * | 2010-01-13 | 2012-12-20 | Mitsubishi Electric Corporation | Secure search system, public parameter generation device, encryption device, user secret key generation device, query issuing device, search device, computer program, secure search method, public parameter generation method, encryption method, user secret key generation method, query issuing method, and search method |
US20140122476A1 (en) * | 2012-10-25 | 2014-05-01 | Verisign, Inc. | Privacy preserving data querying |
US20140344944A1 (en) * | 2013-04-30 | 2014-11-20 | Pitney Bowes Inc. | Dynamic database update in multi-server private information retrieval scheme |
US9276746B2 (en) | 2011-01-18 | 2016-03-01 | Mitsubishi Electric Corporation | Encryption system, encryption processing method of encryption system, encryption device, decryption device, setup device, key generation device, and key delegation device using a user identifier for a user who belongs to a k-th hierarchy in an organization |
US9363288B2 (en) | 2012-10-25 | 2016-06-07 | Verisign, Inc. | Privacy preserving registry browsing |
US9418238B2 (en) | 2011-02-22 | 2016-08-16 | Mitsubishi Electric Corporation | Search system, search method of search system, and information processing device |
US20180212756A1 (en) * | 2017-01-20 | 2018-07-26 | Enveil, Inc. | Secure Web Browsing via Homomorphic Encryption |
JP2019510261A (en) * | 2016-03-22 | 2019-04-11 | インターナショナル・ビジネス・マシーンズ・コーポレーションＩｎｔｅｒｎａｔｉｏｎａｌ Ｂｕｓｉｎｅｓｓ Ｍａｃｈｉｎｅｓ Ｃｏｒｐｏｒａｔｉｏｎ | Computer-implemented method, server, user device, and computer program product for central data storage with enhanced privacy |
US10382194B1 (en) | 2014-01-10 | 2019-08-13 | Rockwell Collins, Inc. | Homomorphic encryption based high integrity computing system |
US10565394B2 (en) | 2012-10-25 | 2020-02-18 | Verisign, Inc. | Privacy—preserving data querying with authenticated denial of existence |
US10594473B2 (en) * | 2015-02-10 | 2020-03-17 | Kabushikikaisha Rnai | Terminal device, database server, and calculation system |
CN111062052A (en) * | 2019-12-09 | 2020-04-24 | 支付宝(杭州)信息技术有限公司 | Data query method and system |
US10644876B2 (en) | 2017-01-20 | 2020-05-05 | Enveil, Inc. | Secure analytics using homomorphic encryption |
US10817262B2 (en) | 2018-11-08 | 2020-10-27 | Enveil, Inc. | Reduced and pipelined hardware architecture for Montgomery Modular Multiplication |
US10873568B2 (en) | 2017-01-20 | 2020-12-22 | Enveil, Inc. | Secure analytics using homomorphic and injective format-preserving encryption and an encrypted analytics matrix |
US10902133B2 (en) | 2018-10-25 | 2021-01-26 | Enveil, Inc. | Computational operations in enclave computing environments |
CN113297438A (en) * | 2021-05-21 | 2021-08-24 | 深圳市智尊宝数据开发有限公司 | Information retrieval method, electronic equipment and related products |
US11190496B2 (en) * | 2019-02-12 | 2021-11-30 | Visa International Service Association | Fast oblivious transfers |
US11196541B2 (en) | 2017-01-20 | 2021-12-07 | Enveil, Inc. | Secure machine learning analytics using homomorphic encryption |
CN114128208A (en) * | 2019-05-14 | 2022-03-01 | 谷歌有限责任公司 | Outsourcing exponentiation in a private group |
US11507683B2 (en) | 2017-01-20 | 2022-11-22 | Enveil, Inc. | Query processing with adaptive risk decisioning |
US11601258B2 (en) | 2020-10-08 | 2023-03-07 | Enveil, Inc. | Selector derived encryption systems and methods |
US11777729B2 (en) | 2017-01-20 | 2023-10-03 | Enveil, Inc. | Secure analytics using term generation and homomorphic encryption |
Families Citing this family (7)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8055662B2 (en) * | 2007-08-27 | 2011-11-08 | Mitsubishi Electric Research Laboratories, Inc. | Method and system for matching audio recording |
US8615668B2 (en) | 2010-01-15 | 2013-12-24 | Mitsubishi Electric Corporation | Confidential search system and cryptographic processing system |
US9306738B2 (en) * | 2012-12-21 | 2016-04-05 | Microsoft Technology Licensing, Llc | Managed secure computations on encrypted data |
US9268952B2 (en) | 2013-02-15 | 2016-02-23 | International Business Machines Corporation | Scalable precomputation system for host-opaque processing of encrypted databases |
US10333696B2 (en) | 2015-01-12 | 2019-06-25 | X-Prime, Inc. | Systems and methods for implementing an efficient, scalable homomorphic transformation of encrypted data with minimal data expansion and improved processing efficiency |
US10296709B2 (en) | 2016-06-10 | 2019-05-21 | Microsoft Technology Licensing, Llc | Privacy-preserving genomic prediction |
KR102308066B1 (en) * | 2018-05-07 | 2021-09-30 | 구글 엘엘씨 | Privacy retrieval using low-linear public-key operations |
Citations (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6438554B1 (en) * | 1997-10-09 | 2002-08-20 | Telcordia Technologies, Inc. | System and method for private information retrieval from a single electronic storage device using verifiable commodities |
Family Cites Families (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6886098B1 (en) * | 1999-08-13 | 2005-04-26 | Microsoft Corporation | Systems and methods for compression of key sets having multiple keys |
JP3907184B2 (en) * | 2002-06-17 | 2007-04-18 | インターナショナル・ビジネス・マシーンズ・コーポレーション | Database search system and data sharing system |
-
2005
- 2005-05-19 US US11/133,836 patent/US7620625B2/en active Active
- 2005-05-20 JP JP2007527450A patent/JP2008500598A/en active Pending
- 2005-05-20 WO PCT/US2005/017618 patent/WO2005114481A1/en active Application Filing
-
2009
- 2009-02-04 US US12/365,833 patent/US7941422B2/en not_active Expired - Fee Related
Patent Citations (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6438554B1 (en) * | 1997-10-09 | 2002-08-20 | Telcordia Technologies, Inc. | System and method for private information retrieval from a single electronic storage device using verifiable commodities |
Cited By (50)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8903090B2 (en) | 2008-04-29 | 2014-12-02 | International Business Machines Corporation | Securely classifying data |
US20090268908A1 (en) * | 2008-04-29 | 2009-10-29 | Daniel Martin Bikel | Methods and Apparatus for Securely Classifying Data |
US20100169293A1 (en) * | 2008-12-30 | 2010-07-01 | International Business Machines Corporation | Search engine service utilizing hash algorithms |
US8131738B2 (en) | 2008-12-30 | 2012-03-06 | International Business Machines Corporation | Search engine service utilizing hash algorithms |
US20110191584A1 (en) * | 2009-08-07 | 2011-08-04 | Trostle Jonathan T | System and Method for Computationally Private Information Retrieval |
US20120324240A1 (en) * | 2010-01-13 | 2012-12-20 | Mitsubishi Electric Corporation | Secure search system, public parameter generation device, encryption device, user secret key generation device, query issuing device, search device, computer program, secure search method, public parameter generation method, encryption method, user secret key generation method, query issuing method, and search method |
US9276746B2 (en) | 2011-01-18 | 2016-03-01 | Mitsubishi Electric Corporation | Encryption system, encryption processing method of encryption system, encryption device, decryption device, setup device, key generation device, and key delegation device using a user identifier for a user who belongs to a k-th hierarchy in an organization |
US9418238B2 (en) | 2011-02-22 | 2016-08-16 | Mitsubishi Electric Corporation | Search system, search method of search system, and information processing device |
US9202079B2 (en) * | 2012-10-25 | 2015-12-01 | Verisign, Inc. | Privacy preserving data querying |
US9363288B2 (en) | 2012-10-25 | 2016-06-07 | Verisign, Inc. | Privacy preserving registry browsing |
US9866536B2 (en) | 2012-10-25 | 2018-01-09 | Verisign, Inc. | Privacy preserving registry browsing |
US20140122476A1 (en) * | 2012-10-25 | 2014-05-01 | Verisign, Inc. | Privacy preserving data querying |
US10346627B2 (en) | 2012-10-25 | 2019-07-09 | Verisign, Inc. | Privacy preserving data querying |
US10565394B2 (en) | 2012-10-25 | 2020-02-18 | Verisign, Inc. | Privacy—preserving data querying with authenticated denial of existence |
US9141824B2 (en) * | 2013-04-30 | 2015-09-22 | Pitney Bowes Inc. | Dynamic database update in multi-server private information retrieval scheme |
US20140344944A1 (en) * | 2013-04-30 | 2014-11-20 | Pitney Bowes Inc. | Dynamic database update in multi-server private information retrieval scheme |
US10382194B1 (en) | 2014-01-10 | 2019-08-13 | Rockwell Collins, Inc. | Homomorphic encryption based high integrity computing system |
US10594473B2 (en) * | 2015-02-10 | 2020-03-17 | Kabushikikaisha Rnai | Terminal device, database server, and calculation system |
JP2019510261A (en) * | 2016-03-22 | 2019-04-11 | インターナショナル・ビジネス・マシーンズ・コーポレーションＩｎｔｅｒｎａｔｉｏｎａｌ Ｂｕｓｉｎｅｓｓ Ｍａｃｈｉｎｅｓ Ｃｏｒｐｏｒａｔｉｏｎ | Computer-implemented method, server, user device, and computer program product for central data storage with enhanced privacy |
US10728018B2 (en) | 2017-01-20 | 2020-07-28 | Enveil, Inc. | Secure probabilistic analytics using homomorphic encryption |
US10903976B2 (en) | 2017-01-20 | 2021-01-26 | Enveil, Inc. | End-to-end secure operations using a query matrix |
US10644876B2 (en) | 2017-01-20 | 2020-05-05 | Enveil, Inc. | Secure analytics using homomorphic encryption |
US10693627B2 (en) | 2017-01-20 | 2020-06-23 | Enveil, Inc. | Systems and methods for efficient fixed-base multi-precision exponentiation |
US10721057B2 (en) | 2017-01-20 | 2020-07-21 | Enveil, Inc. | Dynamic channels in secure queries and analytics |
US20180212756A1 (en) * | 2017-01-20 | 2018-07-26 | Enveil, Inc. | Secure Web Browsing via Homomorphic Encryption |
US10771237B2 (en) | 2017-01-20 | 2020-09-08 | Enveil, Inc. | Secure analytics using an encrypted analytics matrix |
US10790960B2 (en) | 2017-01-20 | 2020-09-29 | Enveil, Inc. | Secure probabilistic analytics using an encrypted analytics matrix |
US11902413B2 (en) | 2017-01-20 | 2024-02-13 | Enveil, Inc. | Secure machine learning analytics using homomorphic encryption |
US10873568B2 (en) | 2017-01-20 | 2020-12-22 | Enveil, Inc. | Secure analytics using homomorphic and injective format-preserving encryption and an encrypted analytics matrix |
US10880275B2 (en) | 2017-01-20 | 2020-12-29 | Enveil, Inc. | Secure analytics using homomorphic and injective format-preserving encryption |
US11477006B2 (en) | 2017-01-20 | 2022-10-18 | Enveil, Inc. | Secure analytics using an encrypted analytics matrix |
US11451370B2 (en) | 2017-01-20 | 2022-09-20 | Enveil, Inc. | Secure probabilistic analytics using an encrypted analytics matrix |
US10972251B2 (en) * | 2017-01-20 | 2021-04-06 | Enveil, Inc. | Secure web browsing via homomorphic encryption |
US11777729B2 (en) | 2017-01-20 | 2023-10-03 | Enveil, Inc. | Secure analytics using term generation and homomorphic encryption |
US11290252B2 (en) | 2017-01-20 | 2022-03-29 | Enveil, Inc. | Compression and homomorphic encryption in secure query and analytics |
US11196541B2 (en) | 2017-01-20 | 2021-12-07 | Enveil, Inc. | Secure machine learning analytics using homomorphic encryption |
US11196540B2 (en) | 2017-01-20 | 2021-12-07 | Enveil, Inc. | End-to-end secure operations from a natural language expression |
US11558358B2 (en) | 2017-01-20 | 2023-01-17 | Enveil, Inc. | Secure analytics using homomorphic and injective format-preserving encryption |
US11507683B2 (en) | 2017-01-20 | 2022-11-22 | Enveil, Inc. | Query processing with adaptive risk decisioning |
US11704416B2 (en) | 2018-10-25 | 2023-07-18 | Enveil, Inc. | Computational operations in enclave computing environments |
US10902133B2 (en) | 2018-10-25 | 2021-01-26 | Enveil, Inc. | Computational operations in enclave computing environments |
US10817262B2 (en) | 2018-11-08 | 2020-10-27 | Enveil, Inc. | Reduced and pipelined hardware architecture for Montgomery Modular Multiplication |
US20220045994A1 (en) * | 2019-02-12 | 2022-02-10 | Visa International Service Association | Fast oblivious transfers |
US11601407B2 (en) * | 2019-02-12 | 2023-03-07 | Visa International Service Association | Fast oblivious transfers |
US11190496B2 (en) * | 2019-02-12 | 2021-11-30 | Visa International Service Association | Fast oblivious transfers |
CN114128208A (en) * | 2019-05-14 | 2022-03-01 | 谷歌有限责任公司 | Outsourcing exponentiation in a private group |
US11943352B2 (en) | 2019-05-14 | 2024-03-26 | Google Llc | Outsourcing exponentiation in a private group |
CN111062052A (en) * | 2019-12-09 | 2020-04-24 | 支付宝(杭州)信息技术有限公司 | Data query method and system |
US11601258B2 (en) | 2020-10-08 | 2023-03-07 | Enveil, Inc. | Selector derived encryption systems and methods |
CN113297438A (en) * | 2021-05-21 | 2021-08-24 | 深圳市智尊宝数据开发有限公司 | Information retrieval method, electronic equipment and related products |
Also Published As
Publication number | Publication date |
---|---|
US20090190751A1 (en) | 2009-07-30 |
US7620625B2 (en) | 2009-11-17 |
WO2005114481A1 (en) | 2005-12-01 |
US7941422B2 (en) | 2011-05-10 |
JP2008500598A (en) | 2008-01-10 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US7620625B2 (en) | Method and apparatus for communication efficient private information retrieval and oblivious transfer | |
US8065332B2 (en) | Method and apparatus for communication efficient private information retrieval and oblivious transfer | |
Liu et al. | How to build time-lock encryption | |
Atallah et al. | Securely outsourcing linear algebra computations | |
Gilboa et al. | Distributed point functions and their applications | |
Naor et al. | Oblivious transfer with adaptive queries | |
Lindell et al. | Privacy preserving data mining | |
Naor et al. | Oblivious polynomial evaluation | |
Bellare et al. | A new paradigm for collision-free hashing: Incrementality at reduced cost | |
Yi et al. | Single-database private information retrieval from fully homomorphic encryption | |
Indyk et al. | Polylogarithmic private approximations and efficient matching | |
Ishai et al. | Sufficient conditions for collision-resistant hashing | |
Samanthula et al. | Secure multiset intersection cardinality and its application to jaccard coefficient | |
Lu et al. | Privacy-preserving cloud database querying. | |
Tang | Privacy preserving mapping schemes supporting comparison | |
Ning et al. | Constructing ideal secret sharing schemes based on Chinese remainder theorem | |
Yadav et al. | Private computation of the Schulze voting method over the cloud | |
US20120155641A1 (en) | Non-interactive verifiable, delegated computation | |
Chen et al. | Lattice-based threshold ring signature with message block sharing | |
Brunetta et al. | Code-based zero knowledge PRF arguments | |
Schmidt | Fully homomorphic encryption: Overview and cryptanalysis | |
Qin et al. | Leakage-resilient lossy trapdoor functions and public-key encryption | |
Zhang et al. | Efficient cloud-based private set intersection protocol with hidden access attribute and integrity verification | |
Ben-Sasson et al. | On public key encryption from noisy codewords | |
Zhou et al. | Efficient secure multiparty subset computation |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: DOCOMO COMMUNICATIONS LABORATORIES USA, INC., CALIFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:RAMZAN, ZULFIKAR AMIN;GENTRY, GRAIG B;REEL/FRAME:016589/0089Effective date: 20050519 |
|
AS | Assignment |
Owner name: NTT DOCOMO, INC.,JAPANFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:DOCOMO COMMUNICATIONS LABORATORIES, USA, INC.;REEL/FRAME:017237/0313Effective date: 20051107Owner name: NTT DOCOMO, INC., JAPANFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:DOCOMO COMMUNICATIONS LABORATORIES, USA, INC.;REEL/FRAME:017237/0313Effective date: 20051107 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
CC | Certificate of correction | ||
FPAY | Fee payment |
Year of fee payment: 4 |
|
AS | Assignment |
Owner name: GOOGLE INC, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:NTT DOCOMO, INC.;REEL/FRAME:039885/0615Effective date: 20160122 |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044101/0610Effective date: 20170929 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 12TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1553); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 12 |