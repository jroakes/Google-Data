US20090024590A1 - User contributed knowledge database - Google Patents
User contributed knowledge database Download PDFInfo
- Publication number
- US20090024590A1 US20090024590A1 US12/049,145 US4914508A US2009024590A1 US 20090024590 A1 US20090024590 A1 US 20090024590A1 US 4914508 A US4914508 A US 4914508A US 2009024590 A1 US2009024590 A1 US 2009024590A1
- Authority
- US
- United States
- Prior art keywords
- database
- type
- property
- user
- graph
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Abandoned
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/95—Retrieval from the web
- G06F16/958—Organisation or management of web site content, e.g. publishing, maintaining pages or automatic linking
- G06F16/972—Access to data in other repository systems, e.g. legacy data or dynamic Web page generation
Definitions
- the invention relates to the organization and use of information. More particularly, the invention relates to a scalable graph database.
- the Web also affords a new form of communication. Those who grew up with hypertext, or have otherwise become accustomed to it, find the linear arrangement of textbooks and articles confining and inconvenient. In this respect, the Web is clearly better than conventional text.
- the Web knows very little about the user (except maybe a credit card number). It has no model of how the user learns, or what he does and does not know—or, for that matter, what it does and does not know.
- the invention addresses the problem of providing a system that has a very large, e.g. multi-gigabyte, database of knowledge to a very large number of diverse users, which include both human beings and automated processes. There are many aspects of this problem that are significant challenges. Managing a very large database is one of them. Connecting related data objects is another. Providing a mechanism for creating and retrieving metadata about a data object is a third.
- the World Wide Web for example, is an attempt to provide a very large database to a very large number of users. However, it fails to provide reliability or data security, and provides only a limited amount of metadata, and only in some cases. Large relational database systems tackle the problem of reliability and security very well, but are lacking in the ability to support diverse data and diverse users, as well as in metadata support.
- the ideal system should permit the diverse databases that exist today to continue to function, while supporting the development of new data. It should permit a large, diverse set of users to access this data, and to annotate it and otherwise add to it through various types of metadata. Users should be able to obtain a view of the data that is complete, comprehensive, valid, and enhanced based on the metadata.
- the system should support data integrity, redundancy, availability, scalability, ease of use, personalization, feedback, controlled access, and multiple data formats.
- the system must accommodate diverse data and diverse metadata, in addition to diverse user types.
- the access control system must be sufficiently flexible to give different users access to different portions of the database, with distributed management of the access control. Flexible administration must allow portions of the database to be maintained independently, and must allow for new features to added to the system as it grows.
- the preferred embodiment of the invention comprises a large open database of information that is distinguished, in part, from the state of the art by having entries for commonly understood data, such as people, places and objects, which are referred to herein as topics.
- the inventive database contains separate entries for Los Angeles, Calif., Morgan Freeman, and Academy Award for Best Supporting Actor, and can store the relationship between these topics.
- topics There are over three million topics in the initial version of the inventive database and over 100 million relationships between the various items in the database.
- the database has a type system and contains attributes and relationships between topics. So for example, Morgan Freeman is typed as a Film Actor, as a Person, and as a person he has an attribute called birth date.
- the inventive database is intended to be used, and contributed to, by a wide community of users. There is a powerful query language and an open API to access the data and a website where contributors can update the data or add new topics and relationships.
- the invention comprises, inter alia, a database, it is not an ontology. While it attempts to capture the relationships between a large number of topics, it does not contain a set of formal definitions or assertions about those topics. Unlike OWL, for example, the inventive database does not provide a mechanism to assert disjunction or transitivity. Unlike Cyc, the inventive database does not provide a reasoning engine.
- the invention comprises an open database, and its goal is to allow relationships between as many topics as possible. Everything in the inventive database is openly available and so this limits it to storing information that may be linked to by other information on the Web. This means that the inventive database is not a good place to store private or fast changing information.
- the core of the inventive database is a new implementation of a graph database.
- a large number of application domains model information whose logical structure is a graph and which emphasize dynamic interconnectivity between the data. These applications are not well served by relational databases.
- Graph databases have been in use for many decades and have recently seen an increase in popularity with the RDF based Semantic Web project.
- the graph store in this embodiment of the invention emphasizes scalability, performance, and correctness in the face of community built application demands. It is also freely available as a service on the World Wide Web so that any application can use the database as part of its infrastructure, much like the domain name system is a database used by Web applications.
- Objects in the database store are referred to as primitives. All primitives are versioned and attributed to database contributors. Relationships between primitives are implicitly bi-directional.
- All databases present an API and basic type system to its users.
- the type system in the preferred embodiment of the invention is created by the users of the database and is stored in the graph itself.
- a small number of inherent types are provided and all the application types are built on top, such as Company and Disease.
- a unique feature of the invention is that the community of users creates the types that are then instantly available via the query API, so that schema building is not a separate activity from data entry. Existing relationships in the graph continue to function as schemas are expanded, making the schemas accretive, rather than versioned.
- the preferred embodiment of the invention has a namespace model which is built on the core type system, with names such as ‘/music/genre/artists’ being resolved against the dataset rather than being pre-declared.
- the preferred embodiment also has an access control and permissions model which is built on the graph, and which allows permissions to be devolved to groups of database contributors easily.
- the inventive database is accessed via a query language referred to as MQL.
- This query language provides a simple but powerful syntax for making graph queries which are informed by the dynamically generated schemas, for example: query the birth date and all films of an actor whose name and one film is known.
- MQL presents an object and property based interface to the graph database which is more accessible and easy to use than existing graph query languages.
- MQL uses a notion of query trees which are expanded by the system to yield query results.
- a hierarchical query representing a graph constraint is sent to the service which replies with a similarly shaped tree containing the results.
- the API for writing to the database uses a similar tree based model.
- the query language supports explicitly ordering items, sorting result sets, optional constraint clauses, and highly nested queries.
- the present embodiment of MQL is based on the JSON open standard data interchange syntax which is particularly easy for Web developers to use in their applications.
- the inventive database is accessed via the Web using a number of open standard REST APIs.
- the APIs include services for authentication, database query and update, requesting large objects of various media types, and performing search functions including auto-complete. These APIs are intended to be stable and long lived so that developers can use these Web services directly in their own applications.
- the database website is built using a framework of AJAX dynamic HTML components. These components are freely available for developers to re-use in their own applications. The components help provide user interface elements, not just for large scale collaborative editing of the database, but for user input of compound values including dates, auto-completing lists, and image views. While the public APIs can be used with any application framework that understands JSON and HTTP, it is thought that these components help make it easier to build database derived applications with advanced functionality. Notably, the following features of the invention are considered to provide a significant advance in the state of the art:
- the invention provides a large singe database of topics, cross referenced; and collaborative reconciliation and relating of schema and instances.
- the invention provides a dynamic schema.
- the type system provides familiar object->property schemas, which are implemented in the graph store as data.
- Another unique feature of the invention is that the community of users create the types that are then instantly available via the query API, so that schema building is not a separate activity from data entry. Existing relationships in the graph continue to function as schemas are expanded, making the schemas accretive, rather than versioned.
- Topics can be multiply typed and properties are optional. Type hinting is provided rather than inheritance.
- the invention also provides for collaborative schema development.
- a permission system is implemented via data structures in the graph related to properties, user groups, and groups of users.
- the access system takes advantage of the directional nature of the property mechanism.
- a namespace system is implemented via data structures in the graph; e.g. ‘/’ is a primitive with ‘has_key’ of ‘film’ which results in the path ‘/film/’ etc.
- the invention further comprises a query language (MQL) that uses a notion of query trees which are expanded by the system to yield query results.
- MQL query language
- a hierarchical query representing a graph constraint is sent to the service which replies with a similarly shaped tree containing the results.
- the query language supports explicitly ordering items, sorting result sets, optional clauses, and highly nested queries.
- the presently preferred embodiment of MQL is based on the open-source JSON representation syntax which is particularly easy for Web developers to use in their applications.
- this aspect of the invention comprises:
- the invention comprises a similar tree-based write syntax including deep tree writes, unless it exists as a write operator.
- the preferred embodiment provides typed autocomplete of list items.
- this aspect of the invention comprises:
- FIG. 1 is screen shot of a sample page showing the browsing of knowledge at metaweb.com according to the invention
- FIG. 2 is a screen shot of a Web application enabled with various novel features according to the invention.
- FIG. 3 is a schematic diagram showing nodes and relationships according to the invention.
- FIG. 4 is a tree diagram showing categories of types according to the invention.
- FIG. 5 is a screen shot showing types for all domains according to the invention.
- FIGS. 6 a and 6 b are screen shots showing a film filter for types according to the invention.
- FIGS. 7 a and 7 b are screen shots showing user created properties for a film filter type according to the invention.
- FIG. 8 is a screen shot showing an explore view for the user created properties for a film filter type of FIG. 7 , according to the invention.
- the presently preferred embodiment of the invention comprises a vast open online repository of structured knowledge. Users can access and contribute to an inventive database at a website, e.g. http://www.metaweb.com/metaweb/, or through an API described below.
- the inventive database is seeded with detailed information about popular music and movies.
- the invention comprises all of a database, the data itself, a Web service, browser-based Web clients, and other Web client applications.
- the database is a graph database that provides a way to store free-form data.
- the graph database provides for flexible representation, limited central planning, and is similar in some respects to the semantic Web.
- the invention also includes a further database, which is referred to as the blob database.
- blob database For purposes of the discussion herein, traditional flat files are stored as blobs. These items are articles, images, sound bites, and the like. They may be thought of as the leaves of the graph in the graph database. Metadata are stored in the graph, but the blobs are immutable. Some indexing is done on text blobs but, most commonly, a blob is found using the graph database.
- the database in the invention is seeded with many useful topics, referred to as the data. These topics may be such things as Wikipedia topics, articles, images, music, film, books, television, countries, cities, places, people, corporations, agencies, soft drinks, stamp collections, medical conditions, and anything else that people want to talk about.
- the low-level data model used in the invention is similar to RDF, although the client is shielded from this.
- a link connects a pair of concept instances, left and right.
- a link has both a direction and a link type and a link type is itself a node.
- the invention also includes a query language that builds on the raw graph database to provide several facilities.
- User APIs provide a browser-friendly data representation (JSON), and an object-oriented view of the data using types, namespaces and namespace paths, access control, and ordered and partially ordered collections.
- JSON browser-friendly data representation
- a concept may be an instance of more than one type.
- all typing is explicit. There is almost no subtyping.
- Each type has exactly one schema in the present embodiment of the invention.
- a schema maps between small subgraphs and objects. Each type has exactly one schema. Schema is analogous to the object/relational mapping provided by some relational database clients. Globally, the invention provides a graph, but locally it is preferable to look at objects.
- a schema contains a list of named properties. A property maps a text key to a link type, within the context of the particular type. Thus, it is possible to use the same property name in different schemas.
- a property may have an expected type (at most one). The expected type may have a reverse property (at most one). The potential reversibility of all links is one of the things that makes the graph database in the invention uniquely powerful.
- Another novel aspect of the invention is that almost all the properties can be multi-valued.
- a schema may constrain some properties to be unique. This provides a convenient syntax for updating unique values in-place.
- multi-valued properties are transferred as JSON arrays, although the arrays are not themselves values.
- the invention also includes the notion of a namespace, which is a collection of key/value pairs. Each namespace may contain at most one value for a particular key. This leads to the uniqueness property of namespace paths, which allows them to be used as ids. Any object may be referenced from multiple namespaces. Namespaces do not form a strict tree. This allows aliases. Objects within the database that are sufficiently important have a type referred to as /common/topic. Examples of this type include descriptions and nicknames and properties for articles and images. Most objects that are interesting to humans are topics, e.g. “Buster Keaton” or “Sherlock Jr.” Non-topic objects usually glue topics together, e.g. “Buster Keaton's performance in Sherlock, Jr.” Objects may be promoted to topics as needed.
- Graph stores that have been built before have nodes that are connected together, where the nodes are fully connected graphs and do not have to be a tree.
- one of the nodes might be Arnold Schwarzenegger is married to Mariashriver.
- the nodes represent concepts in the real world and the link between them represents a semantic relationship.
- link is “married to.”
- Arnold Schwarzenegger is married to, and Maria Shriver a triple is formed that provides a core way to represent knowledge.
- Such triples are well known.
- One problem is that when knowledge is represented this way, it is difficult to query it in an object-oriented program.
- the invention when one writes a query one finds things by name.
- the invention concerns finding a small subset that meets all the constraints of the query based on identity, rather than as a result of combining things, i.e. by a join.
- the invention thus finds a subset of all the things inside the graph, where the graph comprises virtually hundreds of millions of things. For example, if the query is for a spouse, e.g. finding any person named Arnold whose spouse was born in Moscow, the user gets an answer back quickly. Accordingly, the preferred embodiment of the invention provides a large graph of knowledge representation. All links in the graph are stored as triples. Thus, all links have a left node, a right node, and a type. The format of data in that graph is novel, as are the taxonomy and the organization. The query language is also novel, and the query language works against whatever it's in the graph. In the foregoing example, there are spouses and people named Arnold, but if these things were not in the graph these queries would not work.
- the core database does not understand such things are types.
- the core database is only concerned with triples.
- the core database has an API which is not exposed publicly. The user merely loads the database with the user's sets and the database figures out how to return appropriate subsets to the user.
- the database itself represents the schema.
- a type for example a person type
- a property of the type for example a person type referred to as a spouse.
- the representation of these things is accomplished using the same mechanisms that are used to store the data itself.
- “Austria” and “Moscow” as places are also stored.
- Objects are also bidirectional.
- a property such as “place of birth,” can have another property associated with it, e.g. “person,” and “city/town” can have a property called “people born in.”
- Each property is linked to other properties such that it is bidirectional.
- a triple is a single link between two things. There is a link type and the ends of the link. Thus, the link is attached to a property. It is therefore possible to tell from the properties which constraint to use. So, “place of birth” can be treated in an object-oriented way, but the invention returns an answer from the graph, i.e. the database.
- the novel query language of the invention is made possible by the object model.
- the graph does not know anything about the type system at all. It only knows about the links.
- the type system is built using these links.
- the invention instead of creating a thing called “Arnold Schwarzenegger,” the invention creates a thing called property.
- the schema concerns properties, such as city/town, while the data concerns a thing having that property, such as Menlo Park.
- the schema is implemented in the graph, as well as the instance data.
- the connections between nodes are objects in and of themselves.
- the query language allows meta queries. For example, consider the instance Arnold Schwarzenegger. A query may ask the system what kind of types he has.
- the system responds with everything meta known about him, e.g. he's a person.
- the query language allows the user to know which types Arnold is, e.g. a person, a politician, a film star, and an athlete. That's four different kinds of things.
- the user can then query the system to respond about Arnold Schwarzenegger as a politician, and the user would get a voting record and offices held.
- types such as politician and properties, such as spouse and Austrian.
- Properties are the links, i.e. assertions about something always have a property.
- the middle term in a triple always has a related property somewhere.
- properties are grouped up into types, e.g.
- a type has one or more associated properties. It is an assertion of a fact. The triples are the knowledge base. The invention uses an assertion of fact to find the properties, e.g. of a person to make it as though he's an object called person. If a type has too many properties, then the type may spawn further types.
- a person can have many properties, but being an actor or actress does not go into the person type, it becomes its own type because most people are not actors.
- the type is used to collect up all properties of an instance.
- the properties are contributed by users.
- the user community is able to edit the schema and add properties, which then show up to other people who are querying the system.
- the invention provides end-user schema editing.
- the invention comprises, inter alia, a database, the data in the database, and a Web service for building an application on top of the database.
- the core database is this graph database that comprises a triple store.
- the database contains many nodes and links. Links have a left node, a right node, and a direction, i.e. left to right or right to left.
- the link type itself is a node.
- the type is also a node in the graph and link types are also data in the database.
- the links themselves are not nodes, the type of a link is a node.
- the query language builds on the database to provide a browser-friendly data representation, i.e. an object-oriented view of the data using the types.
- FIG. 1 is screen shot of a sample page showing the browsing of knowledge at a website, e.g. metaweb.com, according to the invention.
- the preferred embodiment of the invention offers a powerful API for making programmatic queries. This allows a user to incorporate knowledge from the inventive database into the user's applications and websites. For example, if a user types the following URL into his Web browser's location bar:
- a database server responds to this query with a response of MIME type application/json.
- the response is plain text, but the user's browser probably does not display it to. Instead, the browser allows the user to save it to a file, which he can then view from the command line or with any text editor. When the user views it, he sees something like this:
- the response has the same braces and quotes that the query did: they provide the structure that makes this response easy to parse for a computer.
- This response begins with an HTTP status code. It repeats the query made, and then provides the response to the query.
- the example query included the text:
- the inventive database is a sea of knowledge organized as a graph, i.e. a set of nodes and a set of links or relationships between those nodes.
- a schema in the invention is the collection of properties, where each type has one schema. Globally, there is a graph that comprises objects and schema contains the main properties of such objects. Properties are a particular link type, and thus provide a way to refer to a link type specifically. Properties have expected types. For example, if there is an object and the object is a person and the person has a place of birth, then the place of birth property has at the other end an expected type. In other words, the thing that is expected to be at the other end is of a certain type. In the case of place and birth, it would be a city or a place.
- This provides a form of type enforcement in the user interface where, for example, when a user is typing in place of birth, the system starts auto completing, and constrains the user input to a particular type.
- auto-completion may apply when an expected type of property is known, such that an input for a user query is constrained to an exact type match.
- an expected type of property is known, such that an input for a user query is constrained to an exact type match.
- a list of relevance ranked terms are provided to the user, which terms are constrained to the type associated with the user query.
- the query “new” would result in a user query list that begins with the term “New York,” depending upon type and other constraints.
- auto-completion involves an enumeration of constrained choices, e.g. a predetermined, fixed size list of possibilities. For example, a gender based type would be constrained to either of “male” or “female” type, and the user could choose between the listed options.
- /type/type/extends provides a mechanism for annotating an included type. For example, an actor is likely also a person. It can therefore be said that /people/person is an included type of /film/actor. During an auto-completion operation in connection with this example, a search is not only performed for actors, but for people as well.
- Expected types i.e. reversibility of all links, refers to the fact that most properties have reciprocal properties. Thus, the properties have the ability to know what the other property is.
- One of the is the so-called master property, where one link is to the master property, i.e. the slave link, and the other one of the two links is the master. Because of the reversibility of all links, it does not matter which direction a user looking at.
- everything is an object, but only some things are topics.
- everything is a topic.
- a topic is a pragmatic thing.
- the platform does not know that a topic is anything different than a person or an actor, it is just another type.
- freebase topics are important because the type that is given to everything is a searchable user concept.
- Topics can have aliases, which means a topic has more than one name.
- the notion of type “/type” is core to the platform.
- a topic is not a /type. However, /type is the core set of things upon which everything else is built.
- FIG. 3 is a schematic diagram showing nodes and relationships according to the invention. This portion of the graph organizes knowledge about something named Arnold. It tells us that Arnold is a Person, Politician, Body Builder, and Actor. It tells us that Arnold's country of birth is Austria, his political party is Republican, and that he acted in something named Terminator, which is an instance of something known as a Film. The relationships in the graph are bi-directional, so FIG. 3 also tells us, for example, that Austria has Arnold as a citizen, the Republican Party has Arnold as a member, and that Terminator has Arnold as a cast member. Note that this is an example only. An Arnold Schwarzenegger node does exist in the present embodiment of the inventive database, but it may nor may not have the particular relationships pictured here.
- This nodes-and-relationships representation of knowledge is ideal for searching algorithms, but is not ideal for human understanding. We quickly become lost in the maze of links.
- the invention allows us to view the graph through an object-oriented lens. Rather than thinking about nodes and their relationships to other nodes, this object-oriented view lets us think about objects and their properties as follows:
- Arnold is an object with a set of properties. Each property has a name and a value. What is missing from the view is any kind of typing. In many object-oriented systems, each property of an object has a known type, and the value of that property must be a member of that type. Look back at FIG. 3 again, and consider the relationships labeled type and instances. Arnold is an instance of Person, Actor, and Politician. Person, Actor, and Politician are types. They are nodes in the graph, but they also impose an object-oriented structure on the graph. Each type defines a set of properties that its instances are expected to have. Each property has a name and a type. An object in the inventive database, therefore, is a node in the graph, plus the type that it should be viewed as, e.g.:
- a type according to the invention may specify whether each of its properties must be unique or not.
- film For the Actor type, we need a non-unique property named film.
- the type of this property is a set of films that Arnold has acted in, e.g.:
- the film property is an unordered set of values, not an ordered list of values. If you wanted to display this set of films to an end user, you would most likely want to arrange them into alphabetical order, or by release date. You can ask Metaweb to order them for you, or you can sort them yourself. Some sets, such as the set of tracks on an album have an implicit order, and you can ask Metaweb to return the members of the set in this order. We'll see how to do this in Chapter 3.
- name This property is a set of human-readable names for the object, suitable for display to the end users of the system. Each name is a /type/text value which holds a string and defines the human language in which it is written.
- name property is special in two ways:
- This property is a set of fully-qualified names for the object. These fully-qualified names are intended for use by developers and scripts and are not typically displayed to end users. Each member of the set is a /type/key value that specifies a namespace object and a name within the namespace. The system guarantees that no two objects ever have the same fully-qualified name.
- guid Every object in the inventive database has a globally unique identifier or guid.
- the guid property specifies the unique identifier for an object.
- a guid is a long string of hexadecimal digits following the hash character and, in one embodiment, is as follows: #0801010a40005e838000000000019bd2. No two objects ever have the same value of the guid property. This property is read-only.
- the id property is a unique name for the object. For most objects, this property has the same values as the guid property. If an object has a key property that defines a fully-qualified name, then that fully-qualified name is used as the id instead. This is common for objects that are instances of core types, such as the type /type/text or the language /lang/en. As with guid, the id property is unique, i.e. no two objects ever have the same value for this property. This property is read-only. One may not set the id property directly, but its value may change if one sets the key property.
- This property is the set of types associated with the object.
- the object can be viewed as an instance of any of these types.
- Each type is itself an object of /type/type.
- This read-only property is a single value of /type/datetime that specifies when the object was created.
- This read-only property is a single link to a /type/user object that specifies which user created the object.
- This read-only property is a single link to a /type/permission object.
- a permission object specifies which user groups are allowed to alter the object.
- the inventive database contains an object that represents the human language English.
- the name property of this object specifies its human-readable name: English.
- Objects can have only a single name in each language.
- An English object might have names Anglais and Ingles in French and Spanish, respectively.
- the human-readable name of an object does not uniquely identify it.
- the name property allows only one name in each language, one cannot use it to specify nicknames for an object.
- /common/topic a type that one can use to specify any number of nicknames for an object.
- the key property of the English object is completely different than the name property. It specifies that the object has the name “en” in a particular namespace object. That namespace object has a key property of its own, which specifies that it has the name “lang” in a special root namespace object.
- the invention uses the slash character to delimit names, so the English object has the fully-qualified name “/lang/en”. Fully-qualified names are intended for developers and are often used in code, so there are usually written in code font as: /lang/en.
- a critical aspect of fully-qualified names is that they are unique.
- the invention ensures that no two objects ever have the same fully-qualified name at the same time.
- Human-readable names and fully-qualified names are optional. Objects are not required to have either. But every object does have a guid value that identifies it uniquely.
- a unique guid is assigned to an object when it is created, and it never changes. It is always possible to identify an object uniquely by specifying the value of its guid property.
- the guid of the /lang/en object is “#9202a8c04000641f8000000000000092.”
- Guids and fully-qualified names are both unique identifiers for objects.
- the id property is flexible and allows one to use either. If one wants to refer to the English object, he could specify an id property of “#9202a8c04000641f80000b0000000092” or “/lang/en.”
- Topics Objects that are displayed to users of metaweb.com are referred to as topics. These are regular objects that are members of the type /common/topic in addition to any of their other, more-specific types. /common/topic defines properties that allow descriptions, nicknames, documents, and images to be associated with an object, and the metaweb.com client uses these properties to assemble an informative Web page that describes the object or topic.
- Topics in the system are also objects. But not all objects are topics. The distinction is that topics are entries that might be of interest to end users. Objects that are not topics are typically part of the system infrastructure, and may be of interest to developers but not end users. Types, properties, domains, and namespaces are not topics, but albums, movies, and restaurants are.
- That of the invention draws a distinction between objects, i.e. arbitrary collections of properties, and values, i.e. single primitives such as numbers, dates and strings.
- the invention defines nine value types. As with all types, value types are identified by type objects. Each type object has a fully-qualified name such as /type/int, which is for the value type that represents integer values.
- Values have a dual nature in the invention. Depending on how one asks about them, they may behave as primitives, or as simple objects. If one queries a value as if it were an object, then it behaves as a simple object with two properties. As discussed below, two of the value types actually include a third property as well, i.e.:
- Values of this type are signed integers.
- the preferred embodiment of the invention uses a 64-bit representation internally, which means that the range of valid values of /type/int is from ⁇ 9223372036854775808 to 9223372036854775807.
- An integer literal is an optional minus sign followed by a sequence of decimal digits.
- the presently preferred embodiment of the invention does not support octal or hexadecimal notation for integers, nor does it allow the use of exponential notation for expressing integers, although other embodiments could support such notation.
- Values of this type are signed numbers that may include an integer part, a fractional part, and an order of magnitude, i.e. a power of ten by which the integer and fractional parts are multiplied.
- the invention uses the 64-bit IEEE-754 floating point representation which supports magnitudes between 10-324 and 10308. C and Java programmers may recognize this as the double datatype.
- the presently preferred embodiment of the invention does not support the special values Infinity and NaN, however.
- a literal of /type/float consists of an optional minus sign, and optional integer part, and optional decimal point and fractional part and an optional exponent.
- the integer and fractional parts are strings of decimal digits.
- the exponent begins with the letter e or E, followed by an optional minus sign, and one to three digits. The following are all valid /type/float literals:
- Values of this type are object identifiers, either guids or fully-qualified names.
- the object properties guid and id have values of this type.
- An instance of /type/text is a string of text plus a value that specifies the human language of that text.
- the name property of an object is a set of values of this type.
- /type/text is unusual. Its value property specifies the text itself, but it also has a lang property that specifies the language in which the text is written.
- the lang property refers to an object of type /type/lang.
- the /lang namespace holds many instances of this type, such as /lang/en for English. /type/lang and the /lang namespace are discussed in greater detail below.
- the text of a /type/text value must be a string of Unicode characters, encoded using the UTF-8 encoding. The encoded string must not occupy more than 4096 bytes. Longer chunks of text, or binary data, can be stored in the database in the form of a /type/content object, which is described later.
- Instances of /type/key represent a fully-qualified name.
- the key property of an object is a set of /type/key values.
- the value property of a /type/key value is the local, or unqualified part of a fully-qualified name.
- /type/key has a third property.
- the namespace property of a key refers to the /type/namespace object that qualifies the local name. The namespace property and the value property combine to produce a fully-qualified name.
- the key property of this object has a value of “int,” and a namespace that refers to the /type namespace.
- the /type namespace is also an object, and its key property has a value of type and a namespace that refers to the root namespace object.
- the value property of a key must be a string of ASCII characters, and may include letters, numbers, underscores, hyphens, and dollar signs. A key may not begin or end with a hyphen or underscore. The dollar sign is special.
- a value of /type/rawstring is a string of bytes with no associated language specification. The length of the string must not exceed 4096 bytes. Use /type/rawstring instead of /type/text for small amounts of binary data and for textual strings that are not intended to be human readable.
- /type/uri represents a URI (Uniform Resource Identifier: see RFC 3986).
- the value property holds the URI text, which should consist entirely of ASCII characters. Any non-ASCII characters, and any characters that are not allowed in URIs should be URI-encoded using hexadecimal escapes of the form % XX to represent arbitrary bytes.
- An instance of /type/datetime represents an instant in time. That instant may be as long as a year or as short as a fraction of a second.
- the value property is a string representation of a date and time formatted according to a subset of the ISO 8601 standard. /type/datetime only supports dates specified using month and day of month. It does not support the ISO 8601 day-of-year, week-of-year and day-of-week representations.
- a /type/datetime value that represents the first millisecond of the 21st century is as follows: 2001-01-01 00:00:00.001Z. Notice the following points about this format:
- a /type/datetime value can represent time at various granularities, and any of the date or time fields on the right-hand side can be omitted to produce a value with a larger granularity.
- the seconds field can be omitted to specify a day, hour, and minute.
- all the time fields and the day-of-month field can be omitted to specify just a year and a month.
- the date fields can be omitted to specify a time that is independent of date.
- a time zone may not be appended to a date alone. There must be at least an hour field specified before a time zone.
- Types that are not value types are object types.
- the invention pre-defines a number of object types that are organized into domains of related types. Users are allowed and encouraged to define new object types as needed.
- Pre-defined object types can be categorized into the core types that are part of the system infrastructure, common types that are used commonly throughout the system, and domain-specific types, such as the music-related types /music/artist, /music/album and /music/track.
- the core types are all part of the /type domain which they share with the value types, and the common types are all part of the /common domain.
- FIG. 4 is a tree diagram showing categories of types according to the invention.
- Types, properties, domains, and namespaces are fundamental to the invention's architecture, but are represented by ordinary types. These most fundamental types are described below.
- all objects share a set of common properties: name, id, key, and so on.
- These universal object properties are defined by a core type named /type/object. If one is an object-oriented programmer familiar with languages such as Java, one might guess that /type/object is the root of the type hierarchy, and that it is the super class of all other object types. In fact, however, the invention does not have a type hierarchy. Types do not have super types. /type/object is not a normal type. Objects are never declared to be instances of this type.
- one of the common object properties is type. It specifies a set of types for the object.
- /type/object never needs to be a member of this set. In fact, an object's set of types can be empty, and the object still has all of the common properties.
- the /type/object type exists as a convenient placeholder. It serves to group the /type/property objects that represent the common object properties.
- This type describes a type, which means that it is the only type that is an instance of itself.
- Types have five properties:
- instance The set of instances of the type. For commonly used properties, this set may obviously grow quite large. Recall, however that all relationship between objects in the database are inherently bi-directional. Because every object has a type property that refers to its type, it follows that every type has a set of incoming links from its instances. Thus, every type automatically maintains a set of its instances.
- expected_by The set of properties whose value is of the type.
- default_property The name of the default property for the type. When one asks the inventive database to return an object as if it were a primitive value, the value of the default property is returned for that type. For value types, the default property is value. For most object types the default property is name. And for core types in the /type domain, the default property is id.
- Every type defines a set of properties for its instances.
- the members of this set are /type/property objects.
- the common name and key properties of a property object specify the human-readable and fully-qualified names for the property.
- properties specific to /type/property specify, e.g.:
- a domain represents a set of related types, and also serves as a namespace for those types.
- each domain object refers to one or more user group objects that own the domain. Only members of the specified user groups are allowed to add new types to the domain or to edit types within the domain.
- This type represents a namespace, and is used by the value type /type/key. It defines the keys property which is a set of /type/key values that specify the names in the namespace.
- a /type/content object is the bridge between the object database and the content store.
- a /type/content object represents an entry in the content store, and the guid of the /type/content object is used as an index for retrieving the content.
- /type/content defines important properties.
- the media_type property specifies the MIME type of the content.
- the text_encoding and language properties specify the encoding and language of the text.
- the length property specifies the size in bytes of the content.
- the source property refers to a /type/content_import object that specifies the source of the content.
- This type describes the source of imported content. Its properties include the URI or filename from which the content was obtained, the user who imported the content, and a timestamp that specifies when the content was imported.
- Instances of this type represent a MIME media type such as “text/html” or “image/png”. Instances are given fully-qualified names within the /media_type namespace, and can be specified with ids such as /media_type/text/html or /media_type/image/png.
- Instances of this type represent standard text encodings, such as ASCII and Unicode UTF-8. Instances are given fully-qualified names within the /media_type/text_encoding namespace, and can be specified with ids such as /media_type/text_encoding/ascii.
- Type/text is special. In most systems, a text is a string with text in it, and if it were internationalized, that string would be in a format such as UTF 8, which is the standard for international codes. In the invention, there is a difference between a text and a raw string. A raw string is a string.
- a type text is a triple where the left-hand side of the triple is the language, such as the English language. For example, the name Arnold Schwarzenegger is an assertion in the database that Arnold Schwarzenegger has a name in the English language called Arnold Schwarzenegger. He might have a similar assertion, for example, in Japanese or in German.
- This type represents a human language. It is used by /type/content objects and also by /type/text values. Pre-defined instances of this type are given fully-qualified names within the /lang namespace, and can be specified with ids like /lang/en and /lang/fr.
- topics objects that are intended for display to end users are called topics.
- Such objects typically have some appropriate domain-specific type, such as /music/artist or /food/restaurant, but are also instances of the type /common/topic.
- This type defines properties that allow documents and images to be associated with the topic.
- Another property allows a set of URLs to be associated with the topic.
- /common/topic has an alias property that allows any number of nicknames to be specified for the topic.
- This type represents a document of some sort.
- /common/topic uses this type to associate documents with topics.
- the most important property is content, which specifies the single /type/content object that refers to the document content.
- Other properties of /common/document provide meta-information about the document, such as authors, publication date, and so on.
- /type/content objects that represent images are typically co-typed with this type.
- /common/image defines a size property that specifies the pixel dimensions of the image.
- Each registered user is represented with an object of /type/user.
- User objects have fully-qualified names in the /user namespace. If a username is joe_developer, then the user's /type/user object is /user/joe_developer.
- This type represents a set of users.
- This type is the key to access control. Its properties specify the set of objects that require this permission for modifications, and also the set of user groups that have the permission.
- a domain is an object of /type/domain. It represents a collection of related types. A number of types, from the /type and /common domains, have already been described herein. The invention pre-defines types in a number of general domains. The set of domains is expected to grow, but at the time of this writing, it includes:
- domain objects are also instances of /type/namespace, and the types contained by domains are members of both the domain and the namespace.
- Every user who registers for an account has their own domain. If a user's username is fred, then his domain is /user/fred/default_domain.
- Beer When one uses the metaweb.com client to define a new type named Beer, it is given the id /user/fred/default_domain/beer. If a user's type becomes an important and commonly used one, it may be promoted by system administrators to a top-level domain. In this case, the type might be given a new fully-qualified name, such as /zymurgy/beer.
- namespaces provide a user with the ability to build a name, such as /film/actor.
- the names are built using links in the graph. For example, there is a node called /, a node called actor, and a node called film, that are linked together with assertions.
- the link is called key and the link type is, itself, a property.
- this aspect of the invention provides for creating a / namespace out of nodes and links.
- Namespaces are useful because one can refer to a name space, for example, such as /film/actor whereas in the prior art one referred to a name, such as Arnold Schwarzenegger.
- Namespaces are a critical part of the system infrastructure because they allow us to refer to important objects, such as types, with simple mnemonic names rather than opaque guids. It would be very inconvenient to query the database if we had to write “#9202a8c04000641f8000000000000565” instead of “/common/topic,” for example.
- a number of important namespaces including /type, /user, /lang, and /media_type, have already been described herein.
- each domain and user object is also a namespace.
- there is the root namespace whose id is simply /.
- a number of important namespaces are populated with pre-defined objects using names defined by international standards.
- the languages in the /lang namespace use language codes, such as “en” for English and “fr” for French, defined by ISO 639.
- the media types in /media_type are defined by IANA and listed at http://www.iana.org/assignments/media-types/.
- the text encodings in /media_type/text_encoding use names defined by IANA at http://www.iana.org/assignments/character-sets.
- a further aspect of the invention concerns the access control system, which is deeply related to the link type system.
- the access control system is the invention's permission system, and is intended to prevent a user from doing certain kinds of writing. In the presently preferred embodiment of the invention, it is not concerned preventing one from reading, although reading could be restricted as well.
- the permission system can prevent the from putting a link in, when a user wants to add a link to connect two things together, based on something that is known about the user. Thus, every node in the system requires write permission. In the invention such permission is another node that indicates who is allowed to write.
- the system is completely open for reading.
- anyone who can connect to the system's servers can read data from them.
- access control comes into play.
- the types /type/user, /type/usergroup, and /type/permission are used for access control.
- One embodiment of the invention provides an access control model that is quite simple. Every object has a permission property that refers to a /type/permission object.
- the permission object specifies a set of user groups whose members have permission to modify the object. If a user is a member of one or more of the specified groups, then that user can edit the object. Otherwise, the user is not allowed to.
- This simple access control model is, by default, also very open.
- a primary exception to this open access control model is type objects. Having a stable type system is very important to the success of the system.
- Each domain has a usergroup associated with it, and only members of that usergroup can create new types in the domain or alter existing types in the domain.
- Each user account has an associated domain.
- Fred's domain is /user/fred/default_domain. This domain has an associated usergroup. Initially, Fred is the only member of this group. He is allowed to add to the usergroup, and if he adds his friend Jill, then she is permitted to create new types in Fred's domain.
- Other key parts of the invention infrastructure also have restrictive access control, of course. Ordinary users are not allowed to insert objects into the /lang namespace or the /type domain, for example.
- FIGS. 5-8 provide examples of the inventive database from a user perspective.
- FIG. 5 is a screen shot showing types for all domains according to the invention.
- a list of public types is presented. Users may add topics. Further, a private list of types (not shown), for example for an enterprise, may be provided as well.
- the invention provides a database the does not require a formal schema in the sense of a traditional database. Thus, the type system provide by the invention is open and users may add types as desired.
- FIG. 6 a is a screen shot showing a film filter for types according to the invention.
- the user has selected the type “film.”
- the user has also set filters for the director, i.e. Ridley Scott, and the starring actor, i.e. Harrison ford ( FIG. 6 b ).
- the view returned to the user shows a list of movies that were directed by Ridley Scott and those that also star Harrison ford.
- FIG. 7 a is a screen shot showing user created properties for a film filter type according to the invention.
- the filter for the type “film” includes, as an example, many parameters 70 . Because the invention allows the community of users to create types that are then instantly available via the query API, schema building is not a separate activity from data entry. Existing relationships in the display graph continue to function as schemas are expanded ( FIG. 7 b ).
- FIG. 8 is a screen shot showing an explore view for the user created properties for a film filter type of FIG. 7 , according to the invention.
- a further aspect of the invention concerns ordered and partially ordered collections. For example, suppose a user wanted to put the tracks on a CD in order. There is a CD that has several tracks on it and the tracks are actually ordered on the CD. To order the tracks in a prior art system, such as RDF, one actually has to order them explicitly. To avoid this, the invention provides a mechanism by which a user makes entries and gives them indices.
Abstract
Description
- This application claims priority to U.S. Provisional Application Ser. No. 60/918,584 filed Mar. 15, 2007, which application is incorporated herein in its entirety by this reference thereto.
- 1. Technical Field
- The invention relates to the organization and use of information. More particularly, the invention relates to a scalable graph database.
- 2. Description of the Prior Art
- There is widespread agreement that the amount of knowledge in the world is growing so fast that even experts have trouble keeping up. Today not even the most highly trained professionals—in areas as diverse as science, medicine, law, and engineering—can hope to have more than a general overview of what is known. They spend a large percentage of their time keeping up on the latest information, and often specialize in highly narrow sub-fields because they find it impossible to keep track of broader developments.
- Education traditionally meant the acquisition of the knowledge people needed for their working lives. Today, however, a college education can only provide an overview of knowledge in a specialized area, and a set of skills for learning new things as the need arises. Professionals need new tools that allow them to access new knowledge as they need it.
- In spite of this explosion of knowledge, mechanisms for distributing it have remained pretty much the same for centuries: personal communication, schools, journals, and books. The World Wide Web is the one major new element in the landscape. It has fundamentally changed how knowledge is shared, and has given us a hint of what is possible. Its most important attribute is that it is accessible—it has made it possible for people to not only learn from materials that have now been made available to them, but also to easily contribute to the knowledge of the world in their turn. As a result, the Web's chief feature now is people exuberantly sharing their knowledge.
- The Web also affords a new form of communication. Those who grew up with hypertext, or have otherwise become accustomed to it, find the linear arrangement of textbooks and articles confining and inconvenient. In this respect, the Web is clearly better than conventional text.
- The Web, however, is lacking in many respects.
- It has no mechanism for the vetting of knowledge. There is a lot of information on the Web, but very little guidance as to what is useful or even correct.
- There are no good mechanisms for organizing the knowledge in a manner that helps users find the right information for them at any time. Access to the (often inconsistent or incorrect) knowledge on the Web thus is often through search engines, which are all fundamentally based on key word or vocabulary techniques. The documents found by a search engine are likely to be irrelevant, redundant, and often just plain wrong.
- The Web knows very little about the user (except maybe a credit card number). It has no model of how the user learns, or what he does and does not know—or, for that matter, what it does and does not know.
- There are several aspects to how learners obtain knowledge—they might look at how authoritative the source is, for example, or how recent the information is, or they might want the ability to ask the author a question or to post a comment. Those with knowledge to share might prefer a simple way to publish that knowledge, or they might seek out a well-known publisher to maintain their authority.
- While books and journals offer the authority that comes with editors and reviewers, as well as the permanence of a durable product, the Web and newsgroups provide immediacy and currency, as well as the ability to publish without the bother of an editorial process. Table “A” is a summary of the affordances of various forms of publishing.
-
TABLE A Affordances of Various Forms of Publishing NEWS TEXT THE WEB GROUPS BOOKS JOURNALS Peer-to-Peer Yes Yes No Limited publishing Supports Yes Limited No Limited linking Ability to add No Yes No No annotations Vetting and No Limited Yes Yes certification Supports Limited No Yes Yes payment model Supports Limited No Yes No guided learning - For institutions, corporations, and governments, failure to keep track of knowledge has consequences that are quite different from those for an individual. Often, institutions make a bad decision due to lack of knowledge on the part of those at the right place and at the right time, even though someone else within the institution may actually hold the relevant knowledge.
- Similarly, within a corporation, the process of filtering and abstracting knowledge as it moves through the hierarchy often leaves the decision-maker (whether the CEO, the design engineer, or the corporate lawyer) in a position of deciding without the benefit of the best information. The institutional problem is made worse by the problem of higher employee turnover in the more fluid job market, so that the traditional depository of knowledge—long-standing employees—is beginning to evaporate, just as the amount of knowledge that needs to be kept track of is exploding.
- The consequences of not having the right knowledge at the right place and time can be very severe: doctors prescribing treatments that are sub-optimal, engineers designing products without the benefit of the latest technical ideas, business executives making incorrect strategic decisions, lawyers making decisions without knowledge of relevant precedents or laws, and scientists working diligently to rediscover things that are already known—all these carry tremendous costs to society.
- The invention addresses the problem of providing a system that has a very large, e.g. multi-gigabyte, database of knowledge to a very large number of diverse users, which include both human beings and automated processes. There are many aspects of this problem that are significant challenges. Managing a very large database is one of them. Connecting related data objects is another. Providing a mechanism for creating and retrieving metadata about a data object is a third.
- In the past, various approaches have been used to solve different parts of this problem. The World Wide Web, for example, is an attempt to provide a very large database to a very large number of users. However, it fails to provide reliability or data security, and provides only a limited amount of metadata, and only in some cases. Large relational database systems tackle the problem of reliability and security very well, but are lacking in the ability to support diverse data and diverse users, as well as in metadata support.
- The ideal system should permit the diverse databases that exist today to continue to function, while supporting the development of new data. It should permit a large, diverse set of users to access this data, and to annotate it and otherwise add to it through various types of metadata. Users should be able to obtain a view of the data that is complete, comprehensive, valid, and enhanced based on the metadata.
- The system should support data integrity, redundancy, availability, scalability, ease of use, personalization, feedback, controlled access, and multiple data formats. The system must accommodate diverse data and diverse metadata, in addition to diverse user types. The access control system must be sufficiently flexible to give different users access to different portions of the database, with distributed management of the access control. Flexible administration must allow portions of the database to be maintained independently, and must allow for new features to added to the system as it grows.
- It would be advantageous to provide a system to organize knowledge in such a way that users can find it, learn from it, and add to it as needed.
- The preferred embodiment of the invention comprises a large open database of information that is distinguished, in part, from the state of the art by having entries for commonly understood data, such as people, places and objects, which are referred to herein as topics. For example the inventive database contains separate entries for Los Angeles, Calif., Morgan Freeman, and Academy Award for Best Supporting Actor, and can store the relationship between these topics. There are over three million topics in the initial version of the inventive database and over 100 million relationships between the various items in the database.
- The database has a type system and contains attributes and relationships between topics. So for example, Morgan Freeman is typed as a Film Actor, as a Person, and as a person he has an attribute called Birth date. The inventive database is intended to be used, and contributed to, by a wide community of users. There is a powerful query language and an open API to access the data and a website where contributors can update the data or add new topics and relationships.
- The invention comprises, inter alia, a database, it is not an ontology. While it attempts to capture the relationships between a large number of topics, it does not contain a set of formal definitions or assertions about those topics. Unlike OWL, for example, the inventive database does not provide a mechanism to assert disjunction or transitivity. Unlike Cyc, the inventive database does not provide a reasoning engine.
- The invention comprises an open database, and its goal is to allow relationships between as many topics as possible. Everything in the inventive database is openly available and so this limits it to storing information that may be linked to by other information on the Web. This means that the inventive database is not a good place to store private or fast changing information.
- There are five major technologies in the presently preferred embodiment of the invention:
-
- A scalable graph database;
- A dynamic user contributed schema representation;
- A tree-based object/property query language;
- A series of new Web service APIs; and
- A set of AJAX dynamic HTML technologies.
- A brief summary of each are provided here with links to extended documentation of the public APIs.
- The core of the inventive database is a new implementation of a graph database. A large number of application domains model information whose logical structure is a graph and which emphasize dynamic interconnectivity between the data. These applications are not well served by relational databases. Graph databases have been in use for many decades and have recently seen an increase in popularity with the RDF based Semantic Web project.
- The graph store in this embodiment of the invention emphasizes scalability, performance, and correctness in the face of community built application demands. It is also freely available as a service on the World Wide Web so that any application can use the database as part of its infrastructure, much like the domain name system is a database used by Web applications.
- Objects in the database store are referred to as primitives. All primitives are versioned and attributed to database contributors. Relationships between primitives are implicitly bi-directional.
- All databases present an API and basic type system to its users. The type system in the preferred embodiment of the invention is created by the users of the database and is stored in the graph itself. A small number of inherent types are provided and all the application types are built on top, such as Company and Disease. A unique feature of the invention is that the community of users creates the types that are then instantly available via the query API, so that schema building is not a separate activity from data entry. Existing relationships in the graph continue to function as schemas are expanded, making the schemas accretive, rather than versioned.
- The preferred embodiment of the invention has a namespace model which is built on the core type system, with names such as ‘/music/genre/artists’ being resolved against the dataset rather than being pre-declared. The preferred embodiment also has an access control and permissions model which is built on the graph, and which allows permissions to be devolved to groups of database contributors easily.
- The inventive database is accessed via a query language referred to as MQL. This query language provides a simple but powerful syntax for making graph queries which are informed by the dynamically generated schemas, for example: query the birth date and all films of an actor whose name and one film is known. MQL presents an object and property based interface to the graph database which is more accessible and easy to use than existing graph query languages. MQL uses a notion of query trees which are expanded by the system to yield query results. A hierarchical query representing a graph constraint is sent to the service which replies with a similarly shaped tree containing the results. The API for writing to the database uses a similar tree based model.
- The query language supports explicitly ordering items, sorting result sets, optional constraint clauses, and highly nested queries. The present embodiment of MQL is based on the JSON open standard data interchange syntax which is particularly easy for Web developers to use in their applications.
- The inventive database is accessed via the Web using a number of open standard REST APIs. To access the database an application only needs to support HTTP and JSON open standard protocols. The APIs include services for authentication, database query and update, requesting large objects of various media types, and performing search functions including auto-complete. These APIs are intended to be stable and long lived so that developers can use these Web services directly in their own applications.
- The database website is built using a framework of AJAX dynamic HTML components. These components are freely available for developers to re-use in their own applications. The components help provide user interface elements, not just for large scale collaborative editing of the database, but for user input of compound values including dates, auto-completing lists, and image views. While the public APIs can be used with any application framework that understands JSON and HTTP, it is thought that these components help make it easier to build database derived applications with advanced functionality. Notably, the following features of the invention are considered to provide a significant advance in the state of the art:
- The invention provides a large singe database of topics, cross referenced; and collaborative reconciliation and relating of schema and instances.
- The invention provides a dynamic schema.
- The type system provides familiar object->property schemas, which are implemented in the graph store as data.
- Another unique feature of the invention is that the community of users create the types that are then instantly available via the query API, so that schema building is not a separate activity from data entry. Existing relationships in the graph continue to function as schemas are expanded, making the schemas accretive, rather than versioned.
- Topics can be multiply typed and properties are optional. Type hinting is provided rather than inheritance.
- The invention also provides for collaborative schema development.
- A permission system is implemented via data structures in the graph related to properties, user groups, and groups of users.
- The access system takes advantage of the directional nature of the property mechanism.
- A namespace system is implemented via data structures in the graph; e.g. ‘/’ is a primitive with ‘has_key’ of ‘film’ which results in the path ‘/film/’ etc.
- The invention further comprises a query language (MQL) that uses a notion of query trees which are expanded by the system to yield query results. A hierarchical query representing a graph constraint is sent to the service which replies with a similarly shaped tree containing the results. Thus, this aspect of the invention comprises:
-
- hierarchical result structure from a graph; and
- query structure same as result structure.
- The query language supports explicitly ordering items, sorting result sets, optional clauses, and highly nested queries. The presently preferred embodiment of MQL is based on the open-source JSON representation syntax which is particularly easy for Web developers to use in their applications. Thus, this aspect of the invention comprises:
-
- use of JSON as a database query language; and
- use of JSON to represent a graph hierarchically.
- The invention comprises a similar tree-based write syntax including deep tree writes, unless it exists as a write operator.
- The preferred embodiment provides typed autocomplete of list items.
- Objects in the database store are referred to as primitives. All primitives are versioned and attributed to contributors. Relationships between primitives are inherently bi-directional. Thus, this aspect of the invention comprises:
-
- Details of graph primitives as a triple store;
- Use of links to store literals;
- Links to Links; and
- Primitive versioning.
-
FIG. 1 is screen shot of a sample page showing the browsing of knowledge at metaweb.com according to the invention; -
FIG. 2 is a screen shot of a Web application enabled with various novel features according to the invention; -
FIG. 3 is a schematic diagram showing nodes and relationships according to the invention; -
FIG. 4 is a tree diagram showing categories of types according to the invention; -
FIG. 5 is a screen shot showing types for all domains according to the invention; -
FIGS. 6 a and 6 b are screen shots showing a film filter for types according to the invention; -
FIGS. 7 a and 7 b are screen shots showing user created properties for a film filter type according to the invention; and -
FIG. 8 is a screen shot showing an explore view for the user created properties for a film filter type ofFIG. 7 , according to the invention. - The presently preferred embodiment of the invention comprises a vast open online repository of structured knowledge. Users can access and contribute to an inventive database at a website, e.g. http://www.metaweb.com/metaweb/, or through an API described below. In a presently preferred embodiment, the inventive database is seeded with detailed information about popular music and movies.
- The invention comprises all of a database, the data itself, a Web service, browser-based Web clients, and other Web client applications. The database is a graph database that provides a way to store free-form data. In the invention, the graph database provides for flexible representation, limited central planning, and is similar in some respects to the semantic Web.
- The invention also includes a further database, which is referred to as the blob database. For purposes of the discussion herein, traditional flat files are stored as blobs. These items are articles, images, sound bites, and the like. They may be thought of as the leaves of the graph in the graph database. Metadata are stored in the graph, but the blobs are immutable. Some indexing is done on text blobs but, most commonly, a blob is found using the graph database. The database in the invention is seeded with many useful topics, referred to as the data. These topics may be such things as Wikipedia topics, articles, images, music, film, books, television, countries, cities, places, people, corporations, agencies, soft drinks, stamp collections, medical conditions, and anything else that people want to talk about. With regard to data in the graph database, the low-level data model used in the invention is similar to RDF, although the client is shielded from this.
- In the graph there are many nodes and many links. A link connects a pair of concept instances, left and right. A link has both a direction and a link type and a link type is itself a node. The invention also includes a query language that builds on the raw graph database to provide several facilities. User APIs provide a browser-friendly data representation (JSON), and an object-oriented view of the data using types, namespaces and namespace paths, access control, and ordered and partially ordered collections.
- An example of a query using the query language of the invention is as follows:
-
{ “name”: “Buster Keaton”, “id”: null, “type”: “/film/actor”, “film”: [{ “film”: { “id”: null, “name”: null, “initial_release_date”: null } }] } - An example of a response to a query is as follows:
-
{ “id”: “#9202a8c04000641f8000000000056600”, “name”: “Buster Keaton”, “film”: [ { “type”: “/film/performance”, “film”: { “id”: “#9202a8c04000641f800000000008910a”, “name”: “Sherlock, Jr.”, “initial_release_date”: “1924-04-21” } }, { “type”: “/film/performance”, “film”: { “id”: “#9202a8c04000641f80000000002c39db”, “name”: “Steamboat Bill Jr.”, “initial_release_date”: “1928-05-19” } }] } - Unique to the invention are types, which provide classification of concept instances. A concept may be an instance of more than one type. In the invention, all typing is explicit. There is almost no subtyping. Each type has exactly one schema in the present embodiment of the invention.
-
- Co-typing refers to the fact that many objects have multiple types. For example, Arnold Schwartzenegger is a person, a bodybuilder, an actor, and a politician. If it is necessary to refer to properties from multiple schemas one must use fully qualified property names, such as:
-
{ “/common/person/birth_date”: “1935-10-30” “/film/actor/films”: [...] } - In the invention, a schema maps between small subgraphs and objects. Each type has exactly one schema. Schema is analogous to the object/relational mapping provided by some relational database clients. Globally, the invention provides a graph, but locally it is preferable to look at objects. In the invention, a schema contains a list of named properties. A property maps a text key to a link type, within the context of the particular type. Thus, it is possible to use the same property name in different schemas. A property may have an expected type (at most one). The expected type may have a reverse property (at most one). The potential reversibility of all links is one of the things that makes the graph database in the invention uniquely powerful.
- Another novel aspect of the invention is that almost all the properties can be multi-valued. In the invention, a schema may constrain some properties to be unique. This provides a convenient syntax for updating unique values in-place. In the invention, multi-valued properties are transferred as JSON arrays, although the arrays are not themselves values.
- The invention also includes the notion of a namespace, which is a collection of key/value pairs. Each namespace may contain at most one value for a particular key. This leads to the uniqueness property of namespace paths, which allows them to be used as ids. Any object may be referenced from multiple namespaces. Namespaces do not form a strict tree. This allows aliases. Objects within the database that are sufficiently important have a type referred to as /common/topic. Examples of this type include descriptions and nicknames and properties for articles and images. Most objects that are interesting to humans are topics, e.g. “Buster Keaton” or “Sherlock Jr.” Non-topic objects usually glue topics together, e.g. “Buster Keaton's performance in Sherlock, Jr.” Objects may be promoted to topics as needed.
- Graph stores that have been built before have nodes that are connected together, where the nodes are fully connected graphs and do not have to be a tree. For example, one of the nodes might be Arnold Schwarzenegger is married to Maria Shriver. The nodes represent concepts in the real world and the link between them represents a semantic relationship. Here, link is “married to.” By connecting Arnold Schwarzenegger, is married to, and Maria Shriver a triple is formed that provides a core way to represent knowledge. Such triples are well known. One problem is that when knowledge is represented this way, it is difficult to query it in an object-oriented program.
- In the invention, when one writes a query one finds things by name. Thus, the invention concerns finding a small subset that meets all the constraints of the query based on identity, rather than as a result of combining things, i.e. by a join.
- The invention thus finds a subset of all the things inside the graph, where the graph comprises virtually hundreds of millions of things. For example, if the query is for a spouse, e.g. finding any person named Arnold whose spouse was born in Moscow, the user gets an answer back quickly. Accordingly, the preferred embodiment of the invention provides a large graph of knowledge representation. All links in the graph are stored as triples. Thus, all links have a left node, a right node, and a type. The format of data in that graph is novel, as are the taxonomy and the organization. The query language is also novel, and the query language works against whatever it's in the graph. In the foregoing example, there are spouses and people named Arnold, but if these things were not in the graph these queries would not work.
- What makes this all work in the invention is an inventive type schema. The core database does not understand such things are types. The core database is only concerned with triples. Further, the core database has an API which is not exposed publicly. The user merely loads the database with the user's sets and the database figures out how to return appropriate subsets to the user. Thus, the database itself represents the schema.
- There is an object in the database referred to as a type, for example a person type, and a property of the type, for example a person type referred to as a spouse. There can also be one or more other properties, such as place of birth. The representation of these things is accomplished using the same mechanisms that are used to store the data itself. Thus, in the same way the that “Arnold was born in Austria” is stored in the graph, “Austria” and “Moscow” as places are also stored. Objects are also bidirectional. Thus, a property such as “place of birth,” can have another property associated with it, e.g. “person,” and “city/town” can have a property called “people born in.” Each property is linked to other properties such that it is bidirectional. In this regard, a triple is a single link between two things. There is a link type and the ends of the link. Thus, the link is attached to a property. It is therefore possible to tell from the properties which constraint to use. So, “place of birth” can be treated in an object-oriented way, but the invention returns an answer from the graph, i.e. the database.
- Key to the novel query language is the schema mechanism described above. With the invention, however, it is possible to create a graph independently. It is straightforward to build a graph system that stores triples and build up a database of hundreds of millions triples quickly. However, a problem arises when trying to query the triples to get a subset fast. One way that this is accomplished in the presently preferred embodiment of the invention is to organize the terms associated with the links into properties which are grouped by type, such that the relations between the nodes, as expressed by the links therebetween, are types. These relationships are assertions of fact that comprise actual data in the database and that are grouped by property into a class of related things. Uniquely in the invention, the properties map directly to the three components of the triple, i.e. the link and the things at the end of the link, resulting in a mapping between the components of the triple and the type system.
- The novel query language of the invention is made possible by the object model. The graph does not know anything about the type system at all. It only knows about the links. The type system is built using these links. For example, instead of creating a thing called “Arnold Schwarzenegger,” the invention creates a thing called property. The schema concerns properties, such as city/town, while the data concerns a thing having that property, such as Menlo Park. Thus, the schema is implemented in the graph, as well as the instance data. Thus, the connections between nodes are objects in and of themselves. Accordingly, the query language allows meta queries. For example, consider the instance Arnold Schwarzenegger. A query may ask the system what kind of types he has. Instead of responding with everything known about Arnold Schwarzenegger, the system responds with everything meta known about him, e.g. he's a person. Thus, the query language allows the user to know which types Arnold is, e.g. a person, a politician, a film star, and an athlete. That's four different kinds of things. The user can then query the system to respond about Arnold Schwarzenegger as a politician, and the user would get a voting record and offices held. Thus, a distinction is made between types, such as politician and properties, such as spouse and Austrian. Properties are the links, i.e. assertions about something always have a property. Thus, the middle term in a triple always has a related property somewhere. However, properties are grouped up into types, e.g. things that are expected of a company, of a restaurant, or of a digital camera. An instance is not expected to have those properties unless its of that kind. In the invention, there is a special link which says that an instance is of that kind, e.g. there is a link which says that Arnold Schwarzenegger is an instance of a person. Thus, a type has one or more associated properties. It is an assertion of a fact. The triples are the knowledge base. The invention uses an assertion of fact to find the properties, e.g. of a person to make it as though he's an object called person. If a type has too many properties, then the type may spawn further types. For example a person can have many properties, but being an actor or actress does not go into the person type, it becomes its own type because most people are not actors. In the invention. there is not an explicit type hierarchy. In other words, there's no inheritance. Rather, it is a very flat system because the assertion of type inclusion is an assertion of fact in the database itself. Thus, knowing that Arnold is an actor is, in and of itself, a piece of information, even if the type system is not used. The type is used to collect up all properties of an instance. In the preferred embodiment, the properties are contributed by users. The user community is able to edit the schema and add properties, which then show up to other people who are querying the system. Thus, the invention provides end-user schema editing.
- As discussed above, the invention comprises, inter alia, a database, the data in the database, and a Web service for building an application on top of the database. The core database is this graph database that comprises a triple store. There is also another store that comprises a database of large files, such as images, large chunks of text, and so on that are not stored in the graph database. These items are stored in a separate, content database. There is a pointer in the graph database that points to the content in this separate database. The database contains many nodes and links. Links have a left node, a right node, and a direction, i.e. left to right or right to left. The link type itself is a node. Thus, the type is also a node in the graph and link types are also data in the database. Thus, while the links themselves are not nodes, the type of a link is a node. As a result, it is possible to query the links. The query language builds on the database to provide a browser-friendly data representation, i.e. an object-oriented view of the data using the types.
-
FIG. 1 is screen shot of a sample page showing the browsing of knowledge at a website, e.g. metaweb.com, according to the invention. The preferred embodiment of the invention offers a powerful API for making programmatic queries. This allows a user to incorporate knowledge from the inventive database into the user's applications and websites. For example, if a user types the following URL into his Web browser's location bar: -
- http://www.metaweb.com/mw/service/mqlread?query=\{“type”:“/music/artist”,“name”:“The Police”,“album”:[ ]}
- There are a lot of braces, quote marks, colons, and commas in that URL, but remember that this is a programmatic API: the query is supposed to be generated by a computer, not pecked out by human fingers.
- Translated into English, this query says:
-
- Find an object in the database whose type is “/music/artist” and whose name is The Police. Then return its array of albums.
- If the user got all of the punctuation correct, a database server responds to this query with a response of MIME type application/json. The response is plain text, but the user's browser probably does not display it to. Instead, the browser allows the user to save it to a file, which he can then view from the command line or with any text editor. When the user views it, he sees something like this:
-
{ “status”: “200 OK”, “query”: { “album”: [ ], “type”: “/music/artist”, “name”: “The Police” }, “messages”: [ ], “result”: { “album”: [ “Outlandos d'Amour”, “Reggatta de Blanc”, “Live in Boston”, “Zenyatta Mondatta”, “Ghost in the Machine”, “Synchronicity”, ], “type”: “/music/artist”, “name”: “The Police” } } - The response has the same braces and quotes that the query did: they provide the structure that makes this response easy to parse for a computer. This response begins with an HTTP status code. It repeats the query made, and then provides the response to the query. The example query included the text:
-
- “album”:[ ]
- In the response, the empty square brackets have been filled in with a long list of album names. For brevity, several live and compilation albums were omitted from the list shown above.
- Making queries from a Web browser's location bar is interesting, but it becomes more interesting if we make the queries under programmatic control. Imagine that a script running on a Web server handles the communication with inventive database. One might write a simple Web application, such as that pictured in
FIG. 2 , which is a screen shot of a Web application enabled with various novel features according to the invention. This album-listing web application was created with the simple PHP code listed below in Table 1. -
TABLE 1 PHP Code for Querying the Inventive Database <head><title>Albums by <?=$_GET[“band”]?></title></head> <body> <h1>Albums by <?=$_GET[“band”]?></h1> <?php // What band are we interested in? $band = $_GET[“band”]; // Compose a Metaweb query for albums by the specified band $query = ‘{“name”:“‘.$band.’”,“type”:“/music/artist”,“album”:[ ]}’; // Encode it for use in a URL $encoded_query = urlencode($query); // This is the complete URL for the query $url = “http://www.metaweb.com/mw/service/mqlread?query=” $encoded_query; // Use the curl library to send the query and get response text in $data $s = curl_init($url); curl_setopt($s, CURLOPT_RETURNTRANSFER, TRUE); $data = curl_exec($s); curl_close($s); // Now parse the response into PHP arrays using parser code in an external file require “JSON.php”; $parser = new Services_JSON(SERVICES_JSON_LOOSE_TYPE); $response = $parser->decode($data); // This is the array of albums we want $albums = $response[“result”][“album”]; // Display the albums, one to a line foreach ($albums as $album) echo $album . “<br>” ?> - The inventive database is a sea of knowledge organized as a graph, i.e. a set of nodes and a set of links or relationships between those nodes. A schema in the invention is the collection of properties, where each type has one schema. Globally, there is a graph that comprises objects and schema contains the main properties of such objects. Properties are a particular link type, and thus provide a way to refer to a link type specifically. Properties have expected types. For example, if there is an object and the object is a person and the person has a place of birth, then the place of birth property has at the other end an expected type. In other words, the thing that is expected to be at the other end is of a certain type. In the case of place and birth, it would be a city or a place. This provides a form of type enforcement in the user interface where, for example, when a user is typing in place of birth, the system starts auto completing, and constrains the user input to a particular type. For example, auto-completion may apply when an expected type of property is known, such that an input for a user query is constrained to an exact type match. Thus, if the user is querying about the type “film,” then only films would be queried for the user, and only films would be used to complete the user input as the user types a query. Further, a list of relevance ranked terms are provided to the user, which terms are constrained to the type associated with the user query. Thus, the query “new” would result in a user query list that begins with the term “New York,” depending upon type and other constraints. The user selects the desired query from the list to complete the query input. Alternatively, auto-completion involves an enumeration of constrained choices, e.g. a predetermined, fixed size list of possibilities. For example, a gender based type would be constrained to either of “male” or “female” type, and the user could choose between the listed options.
- In a further embodiment, /type/type/extends provides a mechanism for annotating an included type. For example, an actor is likely also a person. It can therefore be said that /people/person is an included type of /film/actor. During an auto-completion operation in connection with this example, a search is not only performed for actors, but for people as well.
- In this embodiment, it is important to have only one expected type because it improves the usability of the user interface. Thus, every type has a plurality of properties, and the properties themselves have an expected type. Thus, the thing called /type/property itself has properties, and a user can ask the system to show them to him. It is possible enumerate each individual property and its meaning, such that the system is self-describing to some degree.
- Expected types, i.e. reversibility of all links, refers to the fact that most properties have reciprocal properties. Thus, the properties have the ability to know what the other property is. One of the is the so-called master property, where one link is to the master property, i.e. the slave link, and the other one of the two links is the master. Because of the reversibility of all links, it does not matter which direction a user looking at.
- In the preferred embodiment, everything is an object, but only some things are topics. In an exemplary database, i.e. freebase, everything is a topic. A topic is a pragmatic thing. The platform does not know that a topic is anything different than a person or an actor, it is just another type. In freebase, topics are important because the type that is given to everything is a searchable user concept. Topics can have aliases, which means a topic has more than one name. The notion of type “/type” is core to the platform. A topic is not a /type. However, /type is the core set of things upon which everything else is built.
- The following discussion concerns key features of the system architecture, and explains how types and properties tame this vast graph of knowledge by defining a manageable object-oriented view of it.
-
FIG. 3 is a schematic diagram showing nodes and relationships according to the invention. This portion of the graph organizes knowledge about something named Arnold. It tells us that Arnold is a Person, Politician, Body Builder, and Actor. It tells us that Arnold's country of birth is Austria, his political party is Republican, and that he acted in something named Terminator, which is an instance of something known as a Film. The relationships in the graph are bi-directional, soFIG. 3 also tells us, for example, that Austria has Arnold as a citizen, the Republican Party has Arnold as a member, and that Terminator has Arnold as a cast member. Note that this is an example only. An Arnold Schwarzenegger node does exist in the present embodiment of the inventive database, but it may nor may not have the particular relationships pictured here. This nodes-and-relationships representation of knowledge is ideal for searching algorithms, but is not ideal for human understanding. We quickly become lost in the maze of links. To make the database more understandable to humans, the invention allows us to view the graph through an object-oriented lens. Rather than thinking about nodes and their relationships to other nodes, this object-oriented view lets us think about objects and their properties as follows: -
- Arnold
- sex: male
- birth date: 1947 Jul. 30
- country of birth: Austria
- political party: Republican
- film: Conan the Barbarian
- film: Terminator
- film: Kindergarten Cop
- elected office: Governor of California
- Arnold
- In this view, Arnold is an object with a set of properties. Each property has a name and a value. What is missing from the view is any kind of typing. In many object-oriented systems, each property of an object has a known type, and the value of that property must be a member of that type. Look back at
FIG. 3 again, and consider the relationships labeled type and instances. Arnold is an instance of Person, Actor, and Politician. Person, Actor, and Politician are types. They are nodes in the graph, but they also impose an object-oriented structure on the graph. Each type defines a set of properties that its instances are expected to have. Each property has a name and a type. An object in the inventive database, therefore, is a node in the graph, plus the type that it should be viewed as, e.g.: -
Arnold as Person Arnold as Politician Sex: male Elected Office office: Governor of CA Date birth date: 1947-July-30 Country birthplace: Austria - Next, consider Arnold as an Actor. Notice that the list of properties above included three properties named film. This is perfectly fine for a nodes-and-relationships model, but it does not fit an object-oriented model where we expect each property to have a single value. A type according to the invention may specify whether each of its properties must be unique or not. For the Actor type, we need a non-unique property named film. The type of this property is a set of films that Arnold has acted in, e.g.:
-
- Arnold as Actor
- Set of Film: [Conan the Barbarian, Kindergarten Cop, Terminator]
- Arnold as Actor
- Note that the film property is an unordered set of values, not an ordered list of values. If you wanted to display this set of films to an end user, you would most likely want to arrange them into alphabetical order, or by release date. You can ask Metaweb to order them for you, or you can sort them yourself. Some sets, such as the set of tracks on an album have an implicit order, and you can ask Metaweb to return the members of the set in this order. We'll see how to do this in Chapter 3.
- All objects, regardless of their type or types, define the following properties:
- name This property is a set of human-readable names for the object, suitable for display to the end users of the system. Each name is a /type/text value which holds a string and defines the human language in which it is written. The name property is special in two ways:
-
- An object may have more than one name, but may only have one name per language. That is, it can have only one English name, only one French name, and so on.
- When querying the database, a user treats the name property as if it was a single /type/text value rather than a set of values. The invention automatically returns the object's name, if it has one, in the language of choice.
- key This property is a set of fully-qualified names for the object. These fully-qualified names are intended for use by developers and scripts and are not typically displayed to end users. Each member of the set is a /type/key value that specifies a namespace object and a name within the namespace. The system guarantees that no two objects ever have the same fully-qualified name.
- guid Every object in the inventive database has a globally unique identifier or guid. The guid property specifies the unique identifier for an object. A guid is a long string of hexadecimal digits following the hash character and, in one embodiment, is as follows: #0801010a40005e838000000000019bd2. No two objects ever have the same value of the guid property. This property is read-only.
- id The id property is a unique name for the object. For most objects, this property has the same values as the guid property. If an object has a key property that defines a fully-qualified name, then that fully-qualified name is used as the id instead. This is common for objects that are instances of core types, such as the type /type/text or the language /lang/en. As with guid, the id property is unique, i.e. no two objects ever have the same value for this property. This property is read-only. One may not set the id property directly, but its value may change if one sets the key property.
- type This property is the set of types associated with the object. The object can be viewed as an instance of any of these types. Each type is itself an object of /type/type.
- timestamp This read-only property is a single value of /type/datetime that specifies when the object was created.
- creator This read-only property is a single link to a /type/user object that specifies which user created the object.
- permission This read-only property is a single link to a /type/permission object. A permission object specifies which user groups are allowed to alter the object.
- Notice that four of the eight common properties described above have to do with names and identifiers for objects. It is important to understand the difference between human-readable names, fully-qualified names, and guids. The inventive database contains an object that represents the human language English. The name property of this object specifies its human-readable name: English. Objects can have only a single name in each language. An English object might have names Anglais and Ingles in French and Spanish, respectively. It is important to understand that the human-readable name of an object does not uniquely identify it. There may be many other objects with the name English”. Because the name property allows only one name in each language, one cannot use it to specify nicknames for an object. One cannot, for example, give the English object the name “American English” in addition to “English.”
- As discussed below, most objects that are intended for display to end-users are instances of a type called /common/topic. This type defines a property named alias, which one can use to specify any number of nicknames for an object. The key property of the English object is completely different than the name property. It specifies that the object has the name “en” in a particular namespace object. That namespace object has a key property of its own, which specifies that it has the name “lang” in a special root namespace object. The invention uses the slash character to delimit names, so the English object has the fully-qualified name “/lang/en”. Fully-qualified names are intended for developers and are often used in code, so there are usually written in code font as: /lang/en.
- A critical aspect of fully-qualified names is that they are unique. The invention ensures that no two objects ever have the same fully-qualified name at the same time. Human-readable names and fully-qualified names are optional. Objects are not required to have either. But every object does have a guid value that identifies it uniquely. A unique guid is assigned to an object when it is created, and it never changes. It is always possible to identify an object uniquely by specifying the value of its guid property. The guid of the /lang/en object is “#9202a8c04000641f8000000000000092.” Guids and fully-qualified names are both unique identifiers for objects. The id property is flexible and allows one to use either. If one wants to refer to the English object, he could specify an id property of “#9202a8c04000641f80000b0000000092” or “/lang/en.”
- Objects that are displayed to users of metaweb.com are referred to as topics. These are regular objects that are members of the type /common/topic in addition to any of their other, more-specific types. /common/topic defines properties that allow descriptions, nicknames, documents, and images to be associated with an object, and the metaweb.com client uses these properties to assemble an informative Web page that describes the object or topic.
- All topics in the system are also objects. But not all objects are topics. The distinction is that topics are entries that might be of interest to end users. Objects that are not topics are typically part of the system infrastructure, and may be of interest to developers but not end users. Types, properties, domains, and namespaces are not topics, but albums, movies, and restaurants are.
- As with many object-oriented programming languages, that of the invention draws a distinction between objects, i.e. arbitrary collections of properties, and values, i.e. single primitives such as numbers, dates and strings. The invention defines nine value types. As with all types, value types are identified by type objects. Each type object has a fully-qualified name such as /type/int, which is for the value type that represents integer values.
- Values have a dual nature in the invention. Depending on how one asks about them, they may behave as primitives, or as simple objects. If one queries a value as if it were an object, then it behaves as a simple object with two properties. As discussed below, two of the value types actually include a third property as well, i.e.:
- value this property holds the primitive value
type this property refers to the type object that specifies the type of the value. - If one queries a value as a primitive, then just the value of the value property is returned. The various value types are described below. Notice that value types are in the /type domain, and that their names fall under the /type namespace. Namespaces are discussed in greater detail below.
- /type/int
- Values of this type are signed integers. The preferred embodiment of the invention uses a 64-bit representation internally, which means that the range of valid values of /type/int is from −9223372036854775808 to 9223372036854775807. An integer literal is an optional minus sign followed by a sequence of decimal digits. The presently preferred embodiment of the invention does not support octal or hexadecimal notation for integers, nor does it allow the use of exponential notation for expressing integers, although other embodiments could support such notation.
- /type/float
- Values of this type are signed numbers that may include an integer part, a fractional part, and an order of magnitude, i.e. a power of ten by which the integer and fractional parts are multiplied. The invention uses the 64-bit IEEE-754 floating point representation which supports magnitudes between 10-324 and 10308. C and Java programmers may recognize this as the double datatype. The presently preferred embodiment of the invention does not support the special values Infinity and NaN, however. A literal of /type/float consists of an optional minus sign, and optional integer part, and optional decimal point and fractional part and an optional exponent. The integer and fractional parts are strings of decimal digits. The exponent begins with the letter e or E, followed by an optional minus sign, and one to three digits. The following are all valid /type/float literals:
-
1.0 # integer and fractional part 1 # integer part alone .0 # fractional part alone −1 # minus sign allowed as first character 1E−5 # exponent: 1 × 10−5 or 0.00001 5.98e24 # weight of earth in kg: 5.98 × 1024 - There are an infinite number of real numbers, and a 64-bit representation can only describe a finite subset of them. Any number with twelve or fewer significant digits can be stored and retrieved exactly with no loss of precision. Numbers with more than twelve significant digits may have those digits truncated when they are stored in the inventive database.
- /type/boolean
- There are only two values for this type. They represent the Boolean truth values true and false. Note that the invention sometimes uses the absence of a value, i.e. null, in place of false.
- /type/id
- Values of this type are object identifiers, either guids or fully-qualified names. The object properties guid and id have values of this type.
- /type/text
- An instance of /type/text is a string of text plus a value that specifies the human language of that text. The name property of an object is a set of values of this type.
- /type/text is unusual. Its value property specifies the text itself, but it also has a lang property that specifies the language in which the text is written. The lang property refers to an object of type /type/lang. The /lang namespace holds many instances of this type, such as /lang/en for English. /type/lang and the /lang namespace are discussed in greater detail below. The text of a /type/text value must be a string of Unicode characters, encoded using the UTF-8 encoding. The encoded string must not occupy more than 4096 bytes. Longer chunks of text, or binary data, can be stored in the database in the form of a /type/content object, which is described later.
- /type/key
- Instances of /type/key represent a fully-qualified name. The key property of an object is a set of /type/key values. The value property of a /type/key value is the local, or unqualified part of a fully-qualified name. As with /type/text, /type/key has a third property. The namespace property of a key refers to the /type/namespace object that qualifies the local name. The namespace property and the value property combine to produce a fully-qualified name.
- As an example, consider the object that represents the value type /type/int. The key property of this object has a value of “int,” and a namespace that refers to the /type namespace. The /type namespace is also an object, and its key property has a value of type and a namespace that refers to the root namespace object. The value property of a key must be a string of ASCII characters, and may include letters, numbers, underscores, hyphens, and dollar signs. A key may not begin or end with a hyphen or underscore. The dollar sign is special. It must be followed by four hexadecimal digits, using letters A through F, in uppercase, and is used when it is necessary to map Unicode characters into ASCII so that they can be represented in a key. To represent an extended Unicode character that does not fit in four hexadecimal digits, encode that character in UTF-16 using a surrogate pair, and then express the surrogate pair using two dollar-sign escapes. Keys used as names for domains, types and properties are further restricted. They may not include hyphens or dollar signs, and may not include two underscores in a row.
- /type/rawstring
- A value of /type/rawstring is a string of bytes with no associated language specification. The length of the string must not exceed 4096 bytes. Use /type/rawstring instead of /type/text for small amounts of binary data and for textual strings that are not intended to be human readable.
- /type/uri
- An instance of /type/uri represents a URI (Uniform Resource Identifier: see RFC 3986). The value property holds the URI text, which should consist entirely of ASCII characters. Any non-ASCII characters, and any characters that are not allowed in URIs should be URI-encoded using hexadecimal escapes of the form % XX to represent arbitrary bytes.
- /type/datetime
- An instance of /type/datetime represents an instant in time. That instant may be as long as a year or as short as a fraction of a second. The value property is a string representation of a date and time formatted according to a subset of the ISO 8601 standard. /type/datetime only supports dates specified using month and day of month. It does not support the ISO 8601 day-of-year, week-of-year and day-of-week representations. A /type/datetime value that represents the first millisecond of the 21st century is as follows: 2001-01-01 00:00:00.001Z. Notice the following points about this format:
-
- Longer intervals of time (years, months, etc.) are specified before shorter intervals (minutes, seconds, etc.).
- Years must be specified with a full four digits, even when the leading digits are zeros. Negative years are allowed, but years with more than four digits are not allowed.
- Months and days must always be specified with two digits, starting with 01, even when the first digit is a 0.
- The components of a date are separated from each other with hyphens.
- A date is separated from the time that follows with a space.
- Times are specified using a 24-hour clock. Midnight is hour 00, not
hour 24. Hours and minutes must be specified with two digits, even when the first digit is 0. - Seconds must be specified with two digits, but may also include a decimal point and a fractional second. The database allows up to nine digits after the decimal point.
- The hours, minutes, and seconds components of a time specification are separated from each other with colons.
- A time may be followed by a time zone specification. The capital letter Z is special. It specifies that the time is in Universal Time, or UTC (formerly known as GMT). Local time zones that are later than UTC. i.e. East of the Greenwich meridian, are expressed as a positive offset of hours and minutes such as +05:30 for India. Local times earlier than UTC are expressed with a negative offset, such as −08:00 for US Pacific time. If no time zone is specified, then the /type/datetime value is assumed to be a local time in an unknown time zone. Specifying a time zone of +00:00 is the same as specifying Z. Specifying −00:00 is the same as omitting the time zone altogether.
- All characters used in the /type/datetime representation are from the ASCII character set, so date and time values can be treated as strings of 8-bit ASCII characters.
- A /type/datetime value can represent time at various granularities, and any of the date or time fields on the right-hand side can be omitted to produce a value with a larger granularity. For example, the seconds field can be omitted to specify a day, hour, and minute. Or all the time fields and the day-of-month field can be omitted to specify just a year and a month. Also, the date fields can be omitted to specify a time that is independent of date. A time zone may not be appended to a date alone. There must be at least an hour field specified before a time zone. The following are example /type/datetime values that demonstrate the allowed formats:
-
2001 # The year 20012001-01 # January 2001 2001-01-01 # January 1st 20012001-01-01 01Z # 1 hour past midnight (UTC), January 1st 2001 2000-12-31 23:59Z # 1 minute before midnight (UTC) December 31st, 2000 2000-12-31 23:59:59Z # 1 second before midnight (UTC) December 31st, 2000 2000-12-31 23:59:59.9Z # .1 second before midnight (UTC) December 31st, 2000 00:00:00Z # Midnight, UTC 12:15 # Quarter past noon, local time 17-05:00 # Happy hour, Boston (US Eastern Standard Time) - Types that are not value types are object types. The invention pre-defines a number of object types that are organized into domains of related types. Users are allowed and encouraged to define new object types as needed. Pre-defined object types can be categorized into the core types that are part of the system infrastructure, common types that are used commonly throughout the system, and domain-specific types, such as the music-related types /music/artist, /music/album and /music/track. The core types are all part of the /type domain which they share with the value types, and the common types are all part of the /common domain.
FIG. 4 is a tree diagram showing categories of types according to the invention. - The following discussion introduces important core and common types. It is not necessary to understand these types in detail to make productive use of the invention. Still, knowing what these basic types are is a helpful orientation to the system.
- Types, properties, domains, and namespaces are fundamental to the invention's architecture, but are represented by ordinary types. These most fundamental types are described below.
- /type/object
- As discussed above, all objects share a set of common properties: name, id, key, and so on. These universal object properties are defined by a core type named /type/object. If one is an object-oriented programmer familiar with languages such as Java, one might guess that /type/object is the root of the type hierarchy, and that it is the super class of all other object types. In fact, however, the invention does not have a type hierarchy. Types do not have super types. /type/object is not a normal type. Objects are never declared to be instances of this type. Remember that one of the common object properties is type. It specifies a set of types for the object.
- /type/object never needs to be a member of this set. In fact, an object's set of types can be empty, and the object still has all of the common properties. The /type/object type exists as a convenient placeholder. It serves to group the /type/property objects that represent the common object properties.
- /type/type
- This type describes a type, which means that it is the only type that is an instance of itself.
- Types have five properties:
- properties The set of properties defined by the type.
- instance The set of instances of the type. For commonly used properties, this set may obviously grow quite large. Recall, however that all relationship between objects in the database are inherently bi-directional. Because every object has a type property that refers to its type, it follows that every type has a set of incoming links from its instances. Thus, every type automatically maintains a set of its instances.
- domain The domain to which the type belongs.
- expected_by The set of properties whose value is of the type.
- default_property The name of the default property for the type. When one asks the inventive database to return an object as if it were a primitive value, the value of the default property is returned for that type. For value types, the default property is value. For most object types the default property is name. And for core types in the /type domain, the default property is id.
- /type/property
- Every type defines a set of properties for its instances. The members of this set are /type/property objects. The common name and key properties of a property object specify the human-readable and fully-qualified names for the property. In addition, properties specific to /type/property specify, e.g.:
-
- The expected type of the value of the property
- Whether the property is unique. A unique property may only have a single value, or may have no value). A property that is not unique has a set of zero or more values.
- The reciprocal property, if there is one.
- The type of which this property is a part.
- The notion of a reciprocal property deserves more explanation. Recall that all links in the database are bi-directional. This means that any time a property of type A refers to an object of type B. The invention automatically has a link from that object of type B back to the originating object of type A. Type B can take advantage of this bi-directionality and include a property that links back to objects of type A. As a concrete example, consider the properties property of /type/type. It specifies the set of properties for a type. Its reciprocal is the schema property of /type/property, which specifies the type object or schema of which the property is a part.
- /type/domain
- A domain represents a set of related types, and also serves as a namespace for those types. For access control purposes, each domain object refers to one or more user group objects that own the domain. Only members of the specified user groups are allowed to add new types to the domain or to edit types within the domain.
- /type/namespace
- This type represents a namespace, and is used by the value type /type/key. It defines the keys property which is a set of /type/key values that specify the names in the namespace.
- The following types from the /type and /common domains are important content-related types:
- /type/content
- Large chunks of content, such as HTML documents and graphical images, are not stored in regular nodes. Instead, these large objects, sometimes called lobs, are kept in a separate store. A /type/content object is the bridge between the object database and the content store. A /type/content object represents an entry in the content store, and the guid of the /type/content object is used as an index for retrieving the content. In addition to providing access to the content store, /type/content defines important properties. The media_type property specifies the MIME type of the content. For textual content, the text_encoding and language properties specify the encoding and language of the text. The length property specifies the size in bytes of the content. The source property refers to a /type/content_import object that specifies the source of the content.
- /type/content_import
- This type describes the source of imported content. Its properties include the URI or filename from which the content was obtained, the user who imported the content, and a timestamp that specifies when the content was imported.
- /type/media_type
- Instances of this type represent a MIME media type such as “text/html” or “image/png”. Instances are given fully-qualified names within the /media_type namespace, and can be specified with ids such as /media_type/text/html or /media_type/image/png.
- /type/text_encoding
- Instances of this type represent standard text encodings, such as ASCII and Unicode UTF-8. Instances are given fully-qualified names within the /media_type/text_encoding namespace, and can be specified with ids such as /media_type/text_encoding/ascii. Type/text is special. In most systems, a text is a string with text in it, and if it were internationalized, that string would be in a format such as
UTF 8, which is the standard for international codes. In the invention, there is a difference between a text and a raw string. A raw string is a string. A type text is a triple where the left-hand side of the triple is the language, such as the English language. For example, the name Arnold Schwarzenegger is an assertion in the database that Arnold Schwarzenegger has a name in the English language called Arnold Schwarzenegger. He might have a similar assertion, for example, in Japanese or in German. - /type/lang
- This type represents a human language. It is used by /type/content objects and also by /type/text values. Pre-defined instances of this type are given fully-qualified names within the /lang namespace, and can be specified with ids like /lang/en and /lang/fr.
- /common/topic
- As described above, objects that are intended for display to end users are called topics. Such objects typically have some appropriate domain-specific type, such as /music/artist or /food/restaurant, but are also instances of the type /common/topic. This type defines properties that allow documents and images to be associated with the topic. Another property allows a set of URLs to be associated with the topic. Also, because objects can only have a single name in any given language, /common/topic has an alias property that allows any number of nicknames to be specified for the topic.
- /common/document
- This type represents a document of some sort. /common/topic uses this type to associate documents with topics. The most important property is content, which specifies the single /type/content object that refers to the document content. Other properties of /common/document provide meta-information about the document, such as authors, publication date, and so on.
- /common/image
- /type/content objects that represent images are typically co-typed with this type. /common/image defines a size property that specifies the pixel dimensions of the image.
- The following types are part of the access control framework:
- /type/user
- Each registered user is represented with an object of /type/user. User objects have fully-qualified names in the /user namespace. If a username is joe_developer, then the user's /type/user object is /user/joe_developer.
- /type/usergroup
- This type represents a set of users.
- /type/permission
- This type is the key to access control. Its properties specify the set of objects that require this permission for modifications, and also the set of user groups that have the permission.
- A domain is an object of /type/domain. It represents a collection of related types. A number of types, from the /type and /common domains, have already been described herein. The invention pre-defines types in a number of general domains. The set of domains is expected to grow, but at the time of this writing, it includes:
-
/business /food /measurement_unit /education /language /music /film /location - As can be seen from the names of these domains, domain objects are also instances of /type/namespace, and the types contained by domains are members of both the domain and the namespace. Every user who registers for an account has their own domain. If a user's username is fred, then his domain is /user/fred/default_domain. When one uses the metaweb.com client to define a new type named Beer, it is given the id /user/fred/default_domain/beer. If a user's type becomes an important and commonly used one, it may be promoted by system administrators to a top-level domain. In this case, the type might be given a new fully-qualified name, such as /zymurgy/beer.
- In the invention, namespaces provide a user with the ability to build a name, such as /film/actor. The names are built using links in the graph. For example, there is a node called /, a node called actor, and a node called film, that are linked together with assertions. The link is called key and the link type is, itself, a property. There is the concept of a namespace, and / is a type of namespace. Thus, this aspect of the invention provides for creating a / namespace out of nodes and links. Namespaces are useful because one can refer to a name space, for example, such as /film/actor whereas in the prior art one referred to a name, such as Arnold Schwarzenegger.
- Namespaces are a critical part of the system infrastructure because they allow us to refer to important objects, such as types, with simple mnemonic names rather than opaque guids. It would be very inconvenient to query the database if we had to write “#9202a8c04000641f8000000000000565” instead of “/common/topic,” for example. A number of important namespaces, including /type, /user, /lang, and /media_type, have already been described herein. In addition to these, each domain and user object is also a namespace. Also, there is the root namespace, whose id is simply /. A number of important namespaces are populated with pre-defined objects using names defined by international standards. The languages in the /lang namespace use language codes, such as “en” for English and “fr” for French, defined by ISO 639. The media types in /media_type are defined by IANA and listed at http://www.iana.org/assignments/media-types/. And the text encodings in /media_type/text_encoding use names defined by IANA at http://www.iana.org/assignments/character-sets.
- A further aspect of the invention concerns the access control system, which is deeply related to the link type system. The access control system is the invention's permission system, and is intended to prevent a user from doing certain kinds of writing. In the presently preferred embodiment of the invention, it is not concerned preventing one from reading, although reading could be restricted as well. The permission system can prevent the from putting a link in, when a user wants to add a link to connect two things together, based on something that is known about the user. Thus, every node in the system requires write permission. In the invention such permission is another node that indicates who is allowed to write.
- Thus, the system is completely open for reading. Anyone who can connect to the system's servers can read data from them. When adding or editing data, however, access control comes into play. We've already seen that the types /type/user, /type/usergroup, and /type/permission are used for access control. One embodiment of the invention provides an access control model that is quite simple. Every object has a permission property that refers to a /type/permission object. The permission object specifies a set of user groups whose members have permission to modify the object. If a user is a member of one or more of the specified groups, then that user can edit the object. Otherwise, the user is not allowed to. This simple access control model is, by default, also very open. To allow and encourage free collaboration most objects have a permission object that gives edit permission to all users. If a user, Fred, creates a new object in the database, his friend Jill can freely edit that object. Any other user can edit the object as well, and there is no way for Fred to restrict the permission on his object.
- A primary exception to this open access control model is type objects. Having a stable type system is very important to the success of the system. Each domain has a usergroup associated with it, and only members of that usergroup can create new types in the domain or alter existing types in the domain. Each user account has an associated domain. Fred's domain is /user/fred/default_domain. This domain has an associated usergroup. Initially, Fred is the only member of this group. He is allowed to add to the usergroup, and if he adds his friend Jill, then she is permitted to create new types in Fred's domain. Other key parts of the invention infrastructure also have restrictive access control, of course. Ordinary users are not allowed to insert objects into the /lang namespace or the /type domain, for example.
-
FIGS. 5-8 provide examples of the inventive database from a user perspective. -
FIG. 5 is a screen shot showing types for all domains according to the invention. InFIG. 5 , a list of public types is presented. Users may add topics. Further, a private list of types (not shown), for example for an enterprise, may be provided as well. The invention provides a database the does not require a formal schema in the sense of a traditional database. Thus, the type system provide by the invention is open and users may add types as desired. -
FIG. 6 a is a screen shot showing a film filter for types according to the invention. InFIG. 6 , the user has selected the type “film.” The user has also set filters for the director, i.e. Ridley Scott, and the starring actor, i.e. Harrison ford (FIG. 6 b). The view returned to the user shows a list of movies that were directed by Ridley Scott and those that also star Harrison ford. -
FIG. 7 a is a screen shot showing user created properties for a film filter type according to the invention. InFIG. 7 a, the filter for the type “film” includes, as an example, many parameters 70. Because the invention allows the community of users to create types that are then instantly available via the query API, schema building is not a separate activity from data entry. Existing relationships in the display graph continue to function as schemas are expanded (FIG. 7 b). -
FIG. 8 is a screen shot showing an explore view for the user created properties for a film filter type ofFIG. 7 , according to the invention. - A further aspect of the invention concerns ordered and partially ordered collections. For example, suppose a user wanted to put the tracks on a CD in order. There is a CD that has several tracks on it and the tracks are actually ordered on the CD. To order the tracks in a prior art system, such as RDF, one actually has to order them explicitly. To avoid this, the invention provides a mechanism by which a user makes entries and gives them indices.
- Although the invention is described herein with reference to the preferred embodiment, one skilled in the art will readily appreciate that other applications may be substituted for those set forth herein without departing from the spirit and scope of the present invention. Accordingly, the invention should only be limited by the Claims included below.
Claims (20)
Priority Applications (9)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US12/049,145 US20090024590A1 (en) | 2007-03-15 | 2008-04-22 | User contributed knowledge database |
PCT/US2009/036991 WO2009114714A2 (en) | 2008-03-14 | 2009-03-12 | User contributed knowledge database |
EP09720554A EP2252941A2 (en) | 2008-04-22 | 2009-03-12 | User contributed knowledge database |
CA2719095A CA2719095A1 (en) | 2008-03-14 | 2009-03-12 | User contributed knowledge database |
BRPI0909734A BRPI0909734A2 (en) | 2008-04-22 | 2009-03-12 | user-assisted knowledge database |
AU2009223127A AU2009223127A1 (en) | 2008-03-14 | 2009-03-12 | User contributed knowledge database |
US12/690,696 US8204856B2 (en) | 2007-03-15 | 2010-01-20 | Database replication |
US12/690,642 US20100174692A1 (en) | 2007-03-15 | 2010-01-20 | Graph store |
US12/690,727 US20100121839A1 (en) | 2007-03-15 | 2010-01-20 | Query optimization |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US91858407P | 2007-03-15 | 2007-03-15 | |
US12/049,145 US20090024590A1 (en) | 2007-03-15 | 2008-04-22 | User contributed knowledge database |
Related Child Applications (3)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US12/690,727 Continuation-In-Part US20100121839A1 (en) | 2007-03-15 | 2010-01-20 | Query optimization |
US12/690,696 Continuation-In-Part US8204856B2 (en) | 2007-03-15 | 2010-01-20 | Database replication |
US12/690,642 Continuation-In-Part US20100174692A1 (en) | 2007-03-15 | 2010-01-20 | Graph store |
Publications (1)
Publication Number | Publication Date |
---|---|
US20090024590A1 true US20090024590A1 (en) | 2009-01-22 |
Family
ID=40265668
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US12/049,145 Abandoned US20090024590A1 (en) | 2007-03-15 | 2008-04-22 | User contributed knowledge database |
Country Status (6)
Country | Link |
---|---|
US (1) | US20090024590A1 (en) |
EP (1) | EP2252941A2 (en) |
AU (1) | AU2009223127A1 (en) |
BR (1) | BRPI0909734A2 (en) |
CA (1) | CA2719095A1 (en) |
WO (1) | WO2009114714A2 (en) |
Cited By (57)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20080168396A1 (en) * | 2007-01-07 | 2008-07-10 | Michael Matas | Portable Multifunction Device, Method, and Graphical User Interface for Providing Maps and Directions |
US20080320419A1 (en) * | 2007-06-22 | 2008-12-25 | Michael Matas | Touch Screen Device, Method, and Graphical User Interface for Providing Maps, Directions, and Location-Based Information |
US20090174680A1 (en) * | 2008-01-06 | 2009-07-09 | Freddy Allen Anzures | Portable Multifunction Device, Method, and Graphical User Interface for Viewing and Managing Electronic Calendars |
US20090178007A1 (en) * | 2008-01-06 | 2009-07-09 | Michael Matas | Touch Screen Device, Method, and Graphical User Interface for Displaying and Selecting Application Options |
US20090292718A1 (en) * | 2008-05-26 | 2009-11-26 | Microsoft Corporation | Paging hierarchical data |
US20100023496A1 (en) * | 2008-07-25 | 2010-01-28 | International Business Machines Corporation | Processing data from diverse databases |
US20100031196A1 (en) * | 2008-07-30 | 2010-02-04 | Autodesk, Inc. | Method and apparatus for selecting and highlighting objects in a client browser |
US20100121817A1 (en) * | 2007-03-15 | 2010-05-13 | Scott Meyer | Database replication |
US20100299624A1 (en) * | 2009-04-21 | 2010-11-25 | Melissa Emery | System and method for interactive competitive release board |
US20100309149A1 (en) * | 2009-06-07 | 2010-12-09 | Chris Blumenberg | Device, Method, and Graphical User Interface for Providing Maps, Directions, and Location-Based Information |
US20110022627A1 (en) * | 2008-07-25 | 2011-01-27 | International Business Machines Corporation | Method and apparatus for functional integration of metadata |
US20110060769A1 (en) * | 2008-07-25 | 2011-03-10 | International Business Machines Corporation | Destructuring And Restructuring Relational Data |
US20110093500A1 (en) * | 2009-01-21 | 2011-04-21 | Google Inc. | Query Optimization |
US20110099174A1 (en) * | 2009-10-23 | 2011-04-28 | Intellidimension, Inc. | Data Recovery System and Method In A Resource Description Framework Environment |
US20110138403A1 (en) * | 2009-12-08 | 2011-06-09 | Microsoft Corporation | Push-based application program interface based on duals of a pull-based application program interface |
US20110163874A1 (en) * | 2010-01-06 | 2011-07-07 | Van Os Marcel | Device, Method, and Graphical User Interface for Tracking Movement on a Map |
US20110167058A1 (en) * | 2010-01-06 | 2011-07-07 | Van Os Marcel | Device, Method, and Graphical User Interface for Mapping Directions Between Search Results |
US8122061B1 (en) | 2010-11-10 | 2012-02-21 | Robert Guinness | Systems and methods for information management using socially constructed graphs |
WO2013096887A1 (en) * | 2011-12-23 | 2013-06-27 | Amiato, Inc. | Scalable analysis platform for semi-structured data |
US20130212472A1 (en) * | 2012-02-09 | 2013-08-15 | International Business Machines Corporation | System to view and manipulate artifacts at a temporal reference point |
WO2014028300A1 (en) * | 2012-08-13 | 2014-02-20 | Magnet Systems, Inc. | Managing cross-correlated data |
WO2014036055A1 (en) * | 2012-08-31 | 2014-03-06 | Facebook, Inc. | Api version testing based on query schema |
US20140164899A1 (en) * | 2012-12-10 | 2014-06-12 | International Business Machines Corporation | Utilizing classification and text analytics for annotating documents to allow quick scanning |
US20140215397A1 (en) * | 2013-01-29 | 2014-07-31 | Research In Motion Limited | Apparatus and Method Pertaining to Predicted-Text Derivatives |
US20140280362A1 (en) * | 2010-12-30 | 2014-09-18 | Skai, Inc. | System and method for creating, deploying, integrating, and distributing nodes in a grid of distributed graph databases |
WO2014144889A3 (en) * | 2013-03-15 | 2014-11-06 | Amazon Technologies, Inc. | Scalable analysis platform for semi-structured data |
US8935299B2 (en) | 2012-07-19 | 2015-01-13 | Facebook, Inc. | Identifying relevant data for pages in a social networking system |
US9141707B2 (en) * | 2012-07-19 | 2015-09-22 | Facebook, Inc. | Context-based object retrieval in a social networking system |
US9235609B1 (en) | 2013-10-15 | 2016-01-12 | Amazon Technologies, Inc. | Local emulation of distributed key-value data store |
US20160063106A1 (en) * | 2012-08-08 | 2016-03-03 | Google Inc. | Related Entity Search |
US20160103899A1 (en) * | 2014-10-10 | 2016-04-14 | Salesforce.Com, Inc. | Navigation of a data extraction graph of data and metadata from a data repository |
US9330271B1 (en) | 2013-10-15 | 2016-05-03 | Amazon Technologies, Inc. | Fine-grained access control for synchronized data stores |
US20160253344A1 (en) * | 2015-02-26 | 2016-09-01 | Unisys Corporation | System and method for implementing a multi-word utc time stamp using a single-word utc time stamp and a multi-word key |
US20160261466A1 (en) * | 2014-09-17 | 2016-09-08 | Siemens Aktiengesellschaft | Method and Digital Tool for Engineering Software Architectures of Complex Cyber-Physical Systems of Different Technical Domains |
US20160292301A1 (en) * | 2015-03-31 | 2016-10-06 | International Business Machines Corporation | Distribution of metadata for importation |
US20160314158A1 (en) * | 2015-04-27 | 2016-10-27 | Rovi Guides, Inc. | Systems and methods for updating a knowledge graph through user input |
US9507875B2 (en) | 2012-02-09 | 2016-11-29 | Fujitsu Limited | Symbolic hyper-graph database |
US9646028B2 (en) | 2012-08-31 | 2017-05-09 | Facebook, Inc. | Graph query logic |
US9703814B1 (en) * | 2013-10-15 | 2017-07-11 | Amazon Technologies, Inc. | Local key-value database synchronization |
US9779076B2 (en) | 2013-09-04 | 2017-10-03 | International Business Machines Corporation | Utilizing classification and text analytics for optimizing processes in documents |
US10032045B2 (en) | 2015-10-30 | 2018-07-24 | Raytheon Company | Dynamic runtime field-level access control using a hierarchical permission context structure |
CN108345677A (en) * | 2018-02-13 | 2018-07-31 | 销冠网络科技有限公司 | Data processing method and device for business development |
US10069938B1 (en) * | 2015-03-30 | 2018-09-04 | EMC IP Holding Company LLC | Returning identifiers in default query responses |
US10097597B2 (en) * | 2009-01-08 | 2018-10-09 | Veritas Technologies Llc | Collaborative workbench for managing data from heterogeneous sources |
US10140366B2 (en) * | 2012-04-10 | 2018-11-27 | Microsoft Technology Licensing, Llc | Finding data in connected corpuses using examples |
US10169355B2 (en) * | 2014-10-27 | 2019-01-01 | Tata Consultancy Services Limited | Knowledge representation in a multi-layered database |
US10223637B1 (en) | 2013-05-30 | 2019-03-05 | Google Llc | Predicting accuracy of submitted data |
USRE47594E1 (en) * | 2011-09-30 | 2019-09-03 | Palantir Technologies Inc. | Visual data importer |
US10902026B2 (en) | 2014-11-27 | 2021-01-26 | Longsand Limited | Block classified term |
US20210157883A1 (en) * | 2017-06-02 | 2021-05-27 | Thinkspan, LLC | Universal data scaffold based data management platform |
US20210286848A1 (en) * | 2017-01-20 | 2021-09-16 | Amazon Technologies, Inc. | Query language interoperability in a graph database |
US20220070295A1 (en) * | 2020-08-26 | 2022-03-03 | Avaya Management L.P. | Contact center of celebrities |
WO2022240911A1 (en) * | 2021-05-11 | 2022-11-17 | Cherre, Inc. | Knowledge graph guided database completion and correction system and methods |
USRE49334E1 (en) | 2005-10-04 | 2022-12-13 | Hoffberg Family Trust 2 | Multifactorial optimization system and method |
US20230135929A1 (en) * | 2020-08-24 | 2023-05-04 | Unlikely Artificial Intelligence Limited | Computer implemented method for the automated analysis or use of data |
US11693896B2 (en) * | 2018-09-25 | 2023-07-04 | International Business Machines Corporation | Noise detection in knowledge graphs |
US11977854B2 (en) | 2021-08-24 | 2024-05-07 | Unlikely Artificial Intelligence Limited | Computer implemented methods for the automated analysis or use of data, including use of a large language model |
Families Citing this family (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
EP2463785A1 (en) | 2010-12-13 | 2012-06-13 | Fujitsu Limited | Database and search-engine query system |
Citations (57)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4961139A (en) * | 1988-06-30 | 1990-10-02 | Hewlett-Packard Company | Data base management system for real-time applications |
US5418942A (en) * | 1989-07-06 | 1995-05-23 | Krawchuk; Kenneth V. | System and method for storing and managing information |
US5872973A (en) * | 1995-10-26 | 1999-02-16 | Viewsoft, Inc. | Method for managing dynamic relations between objects in dynamic object-oriented languages |
US5913214A (en) * | 1996-05-30 | 1999-06-15 | Massachusetts Inst Technology | Data extraction from world wide web pages |
US6098078A (en) * | 1995-12-29 | 2000-08-01 | Lucent Technologies Inc. | Maintaining consistency of database replicas |
US6175835B1 (en) * | 1996-07-26 | 2001-01-16 | Ori Software Development, Ltd. | Layered index with a basic unbalanced partitioned index that allows a balanced structure of blocks |
US6208993B1 (en) * | 1996-07-26 | 2001-03-27 | Ori Software Development Ltd. | Method for organizing directories |
US6356916B1 (en) * | 1999-01-13 | 2002-03-12 | Mitsubishi Denki Kabushiki Kaisha | Replica system and method of producing a replica |
US20020049810A1 (en) * | 1993-04-30 | 2002-04-25 | Fitzgerald Albion J. | Distributed computer network including hierarchical resource information structure and related method of distributing resources |
US6408282B1 (en) * | 1999-03-01 | 2002-06-18 | Wit Capital Corp. | System and method for conducting securities transactions over a computer network |
US6477580B1 (en) * | 1999-08-31 | 2002-11-05 | Accenture Llp | Self-described stream in a communication services patterns environment |
US6529948B1 (en) * | 1999-08-31 | 2003-03-04 | Accenture Llp | Multi-object fetch component |
US6578041B1 (en) * | 2000-06-30 | 2003-06-10 | Microsoft Corporation | High speed on-line backup when using logical log operations |
US20030126136A1 (en) * | 2001-06-22 | 2003-07-03 | Nosa Omoigui | System and method for knowledge retrieval, management, delivery and presentation |
US20030163597A1 (en) * | 2001-05-25 | 2003-08-28 | Hellman Ziv Zalman | Method and system for collaborative ontology modeling |
US6626954B1 (en) * | 1998-02-13 | 2003-09-30 | Sony Corporation | Information processing apparatus/method and presentation medium |
US6640242B1 (en) * | 1999-01-29 | 2003-10-28 | Microsoft Corporation | Voice access through a data-centric network to an integrated message storage and retrieval system |
US20030236795A1 (en) * | 2001-05-03 | 2003-12-25 | Kemp Thomas D. | Method and system for identifying objects |
US6799184B2 (en) * | 2001-06-21 | 2004-09-28 | Sybase, Inc. | Relational database system providing XML query support |
US20040225865A1 (en) * | 1999-09-03 | 2004-11-11 | Cox Richard D. | Integrated database indexing system |
US20040230572A1 (en) * | 2001-06-22 | 2004-11-18 | Nosa Omoigui | System and method for semantic knowledge retrieval, management, capture, sharing, discovery, delivery and presentation |
US20040236598A1 (en) * | 2003-03-21 | 2004-11-25 | Thomsen David J. | System and method for providing occupational information |
US20050027725A1 (en) * | 2000-11-17 | 2005-02-03 | Microsoft Corporation | Database schema for structured query language (SQL) Server |
US20050050030A1 (en) * | 2003-01-30 | 2005-03-03 | Decode Genetics Ehf. | Set definition language for relational data |
US20050086256A1 (en) * | 2003-10-21 | 2005-04-21 | United Parcel Service Of America, Inc. | Data structure and management system for a superset of relational databases |
US20050210000A1 (en) * | 2001-11-13 | 2005-09-22 | Inria Institut National De | Semantic web portal graphic interface |
US20050216421A1 (en) * | 1997-09-26 | 2005-09-29 | Mci. Inc. | Integrated business systems for web based telecommunications management |
US20050251805A1 (en) * | 2004-05-06 | 2005-11-10 | Bhuvan Bamba | Importance of semantic web resources and semantic associations between two resources |
US20050289134A1 (en) * | 2004-06-24 | 2005-12-29 | International Business Machines Corporation | Apparatus, computer system, and data processing method for using ontology |
US20060004703A1 (en) * | 2004-02-23 | 2006-01-05 | Radar Networks, Inc. | Semantic web portal and platform |
US20060047615A1 (en) * | 2004-08-25 | 2006-03-02 | Yael Ravin | Knowledge management system automatically allocating expert resources |
US20060075120A1 (en) * | 2001-08-20 | 2006-04-06 | Smit Mark H | System and method for utilizing asynchronous client server communication objects |
US20060100995A1 (en) * | 2004-10-26 | 2006-05-11 | International Business Machines Corporation | E-mail based Semantic Web collaboration and annotation |
US20060100989A1 (en) * | 2004-10-21 | 2006-05-11 | Sybase, Inc. | Database System Providing Methodology for Execution of Functions in XML Queries |
US20060212432A1 (en) * | 1999-01-05 | 2006-09-21 | Tsai Daniel E | Distributed database schema |
US20060218123A1 (en) * | 2005-03-28 | 2006-09-28 | Sybase, Inc. | System and Methodology for Parallel Query Optimization Using Semantic-Based Partitioning |
US20070061487A1 (en) * | 2005-02-01 | 2007-03-15 | Moore James F | Systems and methods for use of structured and unstructured distributed data |
US20070087756A1 (en) * | 2005-10-04 | 2007-04-19 | Hoffberg Steven M | Multifactorial optimization system and method |
US7225249B1 (en) * | 1997-09-26 | 2007-05-29 | Mci, Llc | Integrated systems for providing communications network management services and interactive generating invoice documents |
US7240330B2 (en) * | 2002-02-01 | 2007-07-03 | John Fairweather | Use of ontologies for auto-generating and handling applications, their persistent storage, and user interfaces |
US20070168340A1 (en) * | 2005-01-10 | 2007-07-19 | Instant Information Inc. | Methods and systems for enabling the collaborative management of information using persistent metadata |
US20070233627A1 (en) * | 2006-02-21 | 2007-10-04 | Dolby Julian T | Scalable ontology reasoning |
US20070239694A1 (en) * | 2006-02-27 | 2007-10-11 | Singh Ambuj K | Graph querying, graph motif mining and the discovery of clusters |
US20070255674A1 (en) * | 2005-01-10 | 2007-11-01 | Instant Information Inc. | Methods and systems for enabling the collaborative management of information based upon user interest |
US20070266384A1 (en) * | 2006-03-27 | 2007-11-15 | Fujitsu Limited | Building Computing Applications Based Upon Metadata |
US20070299836A1 (en) * | 2006-06-23 | 2007-12-27 | Xue Qiao Hou | Database query language transformation method, transformation apparatus and database query system |
US20080033993A1 (en) * | 2006-08-04 | 2008-02-07 | International Business Machines Corporation | Database Access Through Ontologies With Semi-Automatic Semantic Mapping |
US20080046474A1 (en) * | 2006-08-17 | 2008-02-21 | John Sismanis | Efficient discovery of keys in a database |
US20080109493A1 (en) * | 2005-08-08 | 2008-05-08 | Arthur Zaifman | Method and apparatus for managing hierarchical collections of data |
US7630986B1 (en) * | 1999-10-27 | 2009-12-08 | Pinpoint, Incorporated | Secure data interchange |
US20100070448A1 (en) * | 2002-06-24 | 2010-03-18 | Nosa Omoigui | System and method for knowledge retrieval, management, delivery and presentation |
US20100121817A1 (en) * | 2007-03-15 | 2010-05-13 | Scott Meyer | Database replication |
US20100121839A1 (en) * | 2007-03-15 | 2010-05-13 | Scott Meyer | Query optimization |
US7726904B2 (en) * | 2007-01-22 | 2010-06-01 | Rexius Forest By-Products, Inc. | Mobile conveying apparatus having a gear-to-gear driven swing assembly |
US20100174692A1 (en) * | 2007-03-15 | 2010-07-08 | Scott Meyer | Graph store |
US20110093500A1 (en) * | 2009-01-21 | 2011-04-21 | Google Inc. | Query Optimization |
US8032503B2 (en) * | 2008-08-05 | 2011-10-04 | Teradata Us, Inc. | Deferred maintenance of sparse join indexes |
Family Cites Families (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20060173873A1 (en) * | 2000-03-03 | 2006-08-03 | Michel Prompt | System and method for providing access to databases via directories and other hierarchical structures and interfaces |
US6999956B2 (en) * | 2000-11-16 | 2006-02-14 | Ward Mullins | Dynamic object-driven database manipulation and mapping system |
-
2008
- 2008-04-22 US US12/049,145 patent/US20090024590A1/en not_active Abandoned
-
2009
- 2009-03-12 BR BRPI0909734A patent/BRPI0909734A2/en not_active IP Right Cessation
- 2009-03-12 AU AU2009223127A patent/AU2009223127A1/en not_active Abandoned
- 2009-03-12 EP EP09720554A patent/EP2252941A2/en not_active Withdrawn
- 2009-03-12 CA CA2719095A patent/CA2719095A1/en not_active Abandoned
- 2009-03-12 WO PCT/US2009/036991 patent/WO2009114714A2/en active Application Filing
Patent Citations (63)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4961139A (en) * | 1988-06-30 | 1990-10-02 | Hewlett-Packard Company | Data base management system for real-time applications |
US5418942A (en) * | 1989-07-06 | 1995-05-23 | Krawchuk; Kenneth V. | System and method for storing and managing information |
US5564119A (en) * | 1989-07-06 | 1996-10-08 | Krawchuk; Kenneth V. | System and method for storing and managing information |
US20020049810A1 (en) * | 1993-04-30 | 2002-04-25 | Fitzgerald Albion J. | Distributed computer network including hierarchical resource information structure and related method of distributing resources |
US6915451B2 (en) * | 1993-04-30 | 2005-07-05 | Hewlett-Packard Company | Distributed computer network including hierarchical resource information structure and related method of distributing resources |
US5872973A (en) * | 1995-10-26 | 1999-02-16 | Viewsoft, Inc. | Method for managing dynamic relations between objects in dynamic object-oriented languages |
US6098078A (en) * | 1995-12-29 | 2000-08-01 | Lucent Technologies Inc. | Maintaining consistency of database replicas |
US6282537B1 (en) * | 1996-05-30 | 2001-08-28 | Massachusetts Institute Of Technology | Query and retrieving semi-structured data from heterogeneous sources by translating structured queries |
US5913214A (en) * | 1996-05-30 | 1999-06-15 | Massachusetts Inst Technology | Data extraction from world wide web pages |
US6175835B1 (en) * | 1996-07-26 | 2001-01-16 | Ori Software Development, Ltd. | Layered index with a basic unbalanced partitioned index that allows a balanced structure of blocks |
US6208993B1 (en) * | 1996-07-26 | 2001-03-27 | Ori Software Development Ltd. | Method for organizing directories |
US20050216421A1 (en) * | 1997-09-26 | 2005-09-29 | Mci. Inc. | Integrated business systems for web based telecommunications management |
US7225249B1 (en) * | 1997-09-26 | 2007-05-29 | Mci, Llc | Integrated systems for providing communications network management services and interactive generating invoice documents |
US6626954B1 (en) * | 1998-02-13 | 2003-09-30 | Sony Corporation | Information processing apparatus/method and presentation medium |
US20060212432A1 (en) * | 1999-01-05 | 2006-09-21 | Tsai Daniel E | Distributed database schema |
US6356916B1 (en) * | 1999-01-13 | 2002-03-12 | Mitsubishi Denki Kabushiki Kaisha | Replica system and method of producing a replica |
US6640242B1 (en) * | 1999-01-29 | 2003-10-28 | Microsoft Corporation | Voice access through a data-centric network to an integrated message storage and retrieval system |
US6408282B1 (en) * | 1999-03-01 | 2002-06-18 | Wit Capital Corp. | System and method for conducting securities transactions over a computer network |
US6529948B1 (en) * | 1999-08-31 | 2003-03-04 | Accenture Llp | Multi-object fetch component |
US6477580B1 (en) * | 1999-08-31 | 2002-11-05 | Accenture Llp | Self-described stream in a communication services patterns environment |
US20040225865A1 (en) * | 1999-09-03 | 2004-11-11 | Cox Richard D. | Integrated database indexing system |
US7630986B1 (en) * | 1999-10-27 | 2009-12-08 | Pinpoint, Incorporated | Secure data interchange |
US6578041B1 (en) * | 2000-06-30 | 2003-06-10 | Microsoft Corporation | High speed on-line backup when using logical log operations |
US20050027725A1 (en) * | 2000-11-17 | 2005-02-03 | Microsoft Corporation | Database schema for structured query language (SQL) Server |
US20030236795A1 (en) * | 2001-05-03 | 2003-12-25 | Kemp Thomas D. | Method and system for identifying objects |
US20030179228A1 (en) * | 2001-05-25 | 2003-09-25 | Schreiber Marcel Zvi | Instance browser for ontology |
US20030163597A1 (en) * | 2001-05-25 | 2003-08-28 | Hellman Ziv Zalman | Method and system for collaborative ontology modeling |
US6799184B2 (en) * | 2001-06-21 | 2004-09-28 | Sybase, Inc. | Relational database system providing XML query support |
US20040230572A1 (en) * | 2001-06-22 | 2004-11-18 | Nosa Omoigui | System and method for semantic knowledge retrieval, management, capture, sharing, discovery, delivery and presentation |
US20030126136A1 (en) * | 2001-06-22 | 2003-07-03 | Nosa Omoigui | System and method for knowledge retrieval, management, delivery and presentation |
US20060075120A1 (en) * | 2001-08-20 | 2006-04-06 | Smit Mark H | System and method for utilizing asynchronous client server communication objects |
US20050210000A1 (en) * | 2001-11-13 | 2005-09-22 | Inria Institut National De | Semantic web portal graphic interface |
US7240330B2 (en) * | 2002-02-01 | 2007-07-03 | John Fairweather | Use of ontologies for auto-generating and handling applications, their persistent storage, and user interfaces |
US20100070448A1 (en) * | 2002-06-24 | 2010-03-18 | Nosa Omoigui | System and method for knowledge retrieval, management, delivery and presentation |
US20050050030A1 (en) * | 2003-01-30 | 2005-03-03 | Decode Genetics Ehf. | Set definition language for relational data |
US20040236598A1 (en) * | 2003-03-21 | 2004-11-25 | Thomsen David J. | System and method for providing occupational information |
US20080027980A1 (en) * | 2003-10-21 | 2008-01-31 | United Parcel Service Of America, Inc. | Data Structure And Management System For A Superset Of Relational Databases |
US20050086256A1 (en) * | 2003-10-21 | 2005-04-21 | United Parcel Service Of America, Inc. | Data structure and management system for a superset of relational databases |
US7305404B2 (en) * | 2003-10-21 | 2007-12-04 | United Parcel Service Of America, Inc. | Data structure and management system for a superset of relational databases |
US20060004703A1 (en) * | 2004-02-23 | 2006-01-05 | Radar Networks, Inc. | Semantic web portal and platform |
US20050251805A1 (en) * | 2004-05-06 | 2005-11-10 | Bhuvan Bamba | Importance of semantic web resources and semantic associations between two resources |
US20050289134A1 (en) * | 2004-06-24 | 2005-12-29 | International Business Machines Corporation | Apparatus, computer system, and data processing method for using ontology |
US20060047615A1 (en) * | 2004-08-25 | 2006-03-02 | Yael Ravin | Knowledge management system automatically allocating expert resources |
US20060100989A1 (en) * | 2004-10-21 | 2006-05-11 | Sybase, Inc. | Database System Providing Methodology for Execution of Functions in XML Queries |
US20060100995A1 (en) * | 2004-10-26 | 2006-05-11 | International Business Machines Corporation | E-mail based Semantic Web collaboration and annotation |
US20070168340A1 (en) * | 2005-01-10 | 2007-07-19 | Instant Information Inc. | Methods and systems for enabling the collaborative management of information using persistent metadata |
US20070255674A1 (en) * | 2005-01-10 | 2007-11-01 | Instant Information Inc. | Methods and systems for enabling the collaborative management of information based upon user interest |
US20070061487A1 (en) * | 2005-02-01 | 2007-03-15 | Moore James F | Systems and methods for use of structured and unstructured distributed data |
US20060218123A1 (en) * | 2005-03-28 | 2006-09-28 | Sybase, Inc. | System and Methodology for Parallel Query Optimization Using Semantic-Based Partitioning |
US20080109493A1 (en) * | 2005-08-08 | 2008-05-08 | Arthur Zaifman | Method and apparatus for managing hierarchical collections of data |
US20070087756A1 (en) * | 2005-10-04 | 2007-04-19 | Hoffberg Steven M | Multifactorial optimization system and method |
US20070233627A1 (en) * | 2006-02-21 | 2007-10-04 | Dolby Julian T | Scalable ontology reasoning |
US20070239694A1 (en) * | 2006-02-27 | 2007-10-11 | Singh Ambuj K | Graph querying, graph motif mining and the discovery of clusters |
US20070266384A1 (en) * | 2006-03-27 | 2007-11-15 | Fujitsu Limited | Building Computing Applications Based Upon Metadata |
US20070299836A1 (en) * | 2006-06-23 | 2007-12-27 | Xue Qiao Hou | Database query language transformation method, transformation apparatus and database query system |
US20080033993A1 (en) * | 2006-08-04 | 2008-02-07 | International Business Machines Corporation | Database Access Through Ontologies With Semi-Automatic Semantic Mapping |
US20080046474A1 (en) * | 2006-08-17 | 2008-02-21 | John Sismanis | Efficient discovery of keys in a database |
US7726904B2 (en) * | 2007-01-22 | 2010-06-01 | Rexius Forest By-Products, Inc. | Mobile conveying apparatus having a gear-to-gear driven swing assembly |
US20100121817A1 (en) * | 2007-03-15 | 2010-05-13 | Scott Meyer | Database replication |
US20100121839A1 (en) * | 2007-03-15 | 2010-05-13 | Scott Meyer | Query optimization |
US20100174692A1 (en) * | 2007-03-15 | 2010-07-08 | Scott Meyer | Graph store |
US8032503B2 (en) * | 2008-08-05 | 2011-10-04 | Teradata Us, Inc. | Deferred maintenance of sparse join indexes |
US20110093500A1 (en) * | 2009-01-21 | 2011-04-21 | Google Inc. | Query Optimization |
Non-Patent Citations (1)
Title |
---|
Krotzsch, Semantic Wikipedia, 2007 * |
Cited By (112)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
USRE49334E1 (en) | 2005-10-04 | 2022-12-13 | Hoffberg Family Trust 2 | Multifactorial optimization system and method |
US8607167B2 (en) * | 2007-01-07 | 2013-12-10 | Apple Inc. | Portable multifunction device, method, and graphical user interface for providing maps and directions |
US20080168396A1 (en) * | 2007-01-07 | 2008-07-10 | Michael Matas | Portable Multifunction Device, Method, and Graphical User Interface for Providing Maps and Directions |
US8204856B2 (en) | 2007-03-15 | 2012-06-19 | Google Inc. | Database replication |
US20100121817A1 (en) * | 2007-03-15 | 2010-05-13 | Scott Meyer | Database replication |
US8302033B2 (en) | 2007-06-22 | 2012-10-30 | Apple Inc. | Touch screen device, method, and graphical user interface for providing maps, directions, and location-based information |
US20080320419A1 (en) * | 2007-06-22 | 2008-12-25 | Michael Matas | Touch Screen Device, Method, and Graphical User Interface for Providing Maps, Directions, and Location-Based Information |
US11849063B2 (en) | 2007-06-22 | 2023-12-19 | Apple Inc. | Touch screen device, method, and graphical user interface for providing maps, directions, and location-based information |
US10686930B2 (en) | 2007-06-22 | 2020-06-16 | Apple Inc. | Touch screen device, method, and graphical user interface for providing maps, directions, and location based information |
US11126326B2 (en) | 2008-01-06 | 2021-09-21 | Apple Inc. | Portable multifunction device, method, and graphical user interface for viewing and managing electronic calendars |
US9792001B2 (en) | 2008-01-06 | 2017-10-17 | Apple Inc. | Portable multifunction device, method, and graphical user interface for viewing and managing electronic calendars |
US10521084B2 (en) | 2008-01-06 | 2019-12-31 | Apple Inc. | Portable multifunction device, method, and graphical user interface for viewing and managing electronic calendars |
US9330381B2 (en) | 2008-01-06 | 2016-05-03 | Apple Inc. | Portable multifunction device, method, and graphical user interface for viewing and managing electronic calendars |
US10503366B2 (en) | 2008-01-06 | 2019-12-10 | Apple Inc. | Portable multifunction device, method, and graphical user interface for viewing and managing electronic calendars |
US20090178007A1 (en) * | 2008-01-06 | 2009-07-09 | Michael Matas | Touch Screen Device, Method, and Graphical User Interface for Displaying and Selecting Application Options |
US8327272B2 (en) | 2008-01-06 | 2012-12-04 | Apple Inc. | Portable multifunction device, method, and graphical user interface for viewing and managing electronic calendars |
US8171432B2 (en) | 2008-01-06 | 2012-05-01 | Apple Inc. | Touch screen device, method, and graphical user interface for displaying and selecting application options |
US20090174680A1 (en) * | 2008-01-06 | 2009-07-09 | Freddy Allen Anzures | Portable Multifunction Device, Method, and Graphical User Interface for Viewing and Managing Electronic Calendars |
US20090292718A1 (en) * | 2008-05-26 | 2009-11-26 | Microsoft Corporation | Paging hierarchical data |
US8825700B2 (en) * | 2008-05-26 | 2014-09-02 | Microsoft Corporation | Paging hierarchical data |
US8972463B2 (en) * | 2008-07-25 | 2015-03-03 | International Business Machines Corporation | Method and apparatus for functional integration of metadata |
US20100023496A1 (en) * | 2008-07-25 | 2010-01-28 | International Business Machines Corporation | Processing data from diverse databases |
US9110970B2 (en) | 2008-07-25 | 2015-08-18 | International Business Machines Corporation | Destructuring and restructuring relational data |
US20110060769A1 (en) * | 2008-07-25 | 2011-03-10 | International Business Machines Corporation | Destructuring And Restructuring Relational Data |
US20110022627A1 (en) * | 2008-07-25 | 2011-01-27 | International Business Machines Corporation | Method and apparatus for functional integration of metadata |
US8943087B2 (en) * | 2008-07-25 | 2015-01-27 | International Business Machines Corporation | Processing data from diverse databases |
US20100031196A1 (en) * | 2008-07-30 | 2010-02-04 | Autodesk, Inc. | Method and apparatus for selecting and highlighting objects in a client browser |
US8407619B2 (en) * | 2008-07-30 | 2013-03-26 | Autodesk, Inc. | Method and apparatus for selecting and highlighting objects in a client browser |
US10097597B2 (en) * | 2009-01-08 | 2018-10-09 | Veritas Technologies Llc | Collaborative workbench for managing data from heterogeneous sources |
US20110093500A1 (en) * | 2009-01-21 | 2011-04-21 | Google Inc. | Query Optimization |
US20100299624A1 (en) * | 2009-04-21 | 2010-11-25 | Melissa Emery | System and method for interactive competitive release board |
US9542058B2 (en) * | 2009-04-21 | 2017-01-10 | Sony Corporation | System and method for interactive competitive release board |
US20100309149A1 (en) * | 2009-06-07 | 2010-12-09 | Chris Blumenberg | Device, Method, and Graphical User Interface for Providing Maps, Directions, and Location-Based Information |
US8464182B2 (en) | 2009-06-07 | 2013-06-11 | Apple Inc. | Device, method, and graphical user interface for providing maps, directions, and location-based information |
US20110099174A1 (en) * | 2009-10-23 | 2011-04-28 | Intellidimension, Inc. | Data Recovery System and Method In A Resource Description Framework Environment |
US8938456B2 (en) * | 2009-10-23 | 2015-01-20 | Intellidimension, Inc. | Data recovery system and method in a resource description framework environment |
US20110138403A1 (en) * | 2009-12-08 | 2011-06-09 | Microsoft Corporation | Push-based application program interface based on duals of a pull-based application program interface |
US8862576B2 (en) | 2010-01-06 | 2014-10-14 | Apple Inc. | Device, method, and graphical user interface for mapping directions between search results |
US20110163874A1 (en) * | 2010-01-06 | 2011-07-07 | Van Os Marcel | Device, Method, and Graphical User Interface for Tracking Movement on a Map |
US8456297B2 (en) | 2010-01-06 | 2013-06-04 | Apple Inc. | Device, method, and graphical user interface for tracking movement on a map |
US10169431B2 (en) | 2010-01-06 | 2019-01-01 | Apple Inc. | Device, method, and graphical user interface for mapping directions between search results |
US20110167058A1 (en) * | 2010-01-06 | 2011-07-07 | Van Os Marcel | Device, Method, and Graphical User Interface for Mapping Directions Between Search Results |
US8122061B1 (en) | 2010-11-10 | 2012-02-21 | Robert Guinness | Systems and methods for information management using socially constructed graphs |
US20140280362A1 (en) * | 2010-12-30 | 2014-09-18 | Skai, Inc. | System and method for creating, deploying, integrating, and distributing nodes in a grid of distributed graph databases |
USRE47594E1 (en) * | 2011-09-30 | 2019-09-03 | Palantir Technologies Inc. | Visual data importer |
WO2013096887A1 (en) * | 2011-12-23 | 2013-06-27 | Amiato, Inc. | Scalable analysis platform for semi-structured data |
US8732213B2 (en) | 2011-12-23 | 2014-05-20 | Amiato, Inc. | Scalable analysis platform for semi-structured data |
US10095732B2 (en) | 2011-12-23 | 2018-10-09 | Amiato, Inc. | Scalable analysis platform for semi-structured data |
US9311623B2 (en) * | 2012-02-09 | 2016-04-12 | International Business Machines Corporation | System to view and manipulate artifacts at a temporal reference point |
US9311624B2 (en) * | 2012-02-09 | 2016-04-12 | International Business Machines Corporation | System to view and manipulate artifacts at a temporal reference point |
US20130212472A1 (en) * | 2012-02-09 | 2013-08-15 | International Business Machines Corporation | System to view and manipulate artifacts at a temporal reference point |
US20130212473A1 (en) * | 2012-02-09 | 2013-08-15 | International Business Machines Corporation | System to view and manipulate artifacts at a temporal reference point |
US9507875B2 (en) | 2012-02-09 | 2016-11-29 | Fujitsu Limited | Symbolic hyper-graph database |
US10140366B2 (en) * | 2012-04-10 | 2018-11-27 | Microsoft Technology Licensing, Llc | Finding data in connected corpuses using examples |
KR101785597B1 (en) * | 2012-07-19 | 2017-10-16 | 페이스북, 인크. | Context-based object retrieval in a social networking system |
US10311063B2 (en) | 2012-07-19 | 2019-06-04 | Facebook, Inc. | Context-based object retrieval in a social networking system |
US9141707B2 (en) * | 2012-07-19 | 2015-09-22 | Facebook, Inc. | Context-based object retrieval in a social networking system |
US8935299B2 (en) | 2012-07-19 | 2015-01-13 | Facebook, Inc. | Identifying relevant data for pages in a social networking system |
US20160063106A1 (en) * | 2012-08-08 | 2016-03-03 | Google Inc. | Related Entity Search |
WO2014028300A1 (en) * | 2012-08-13 | 2014-02-20 | Magnet Systems, Inc. | Managing cross-correlated data |
US8825711B2 (en) | 2012-08-13 | 2014-09-02 | Magnet Systems, Inc. | Managing cross-correlated data |
US9015733B2 (en) | 2012-08-31 | 2015-04-21 | Facebook, Inc. | API version testing based on query schema |
KR101594406B1 (en) | 2012-08-31 | 2016-02-16 | 페이스북, 인크. | Api version testing based on query schema |
US9646028B2 (en) | 2012-08-31 | 2017-05-09 | Facebook, Inc. | Graph query logic |
WO2014036055A1 (en) * | 2012-08-31 | 2014-03-06 | Facebook, Inc. | Api version testing based on query schema |
KR20150040383A (en) * | 2012-08-31 | 2015-04-14 | 페이스북, 인크. | Api version testing based on query schema |
US10430506B2 (en) * | 2012-12-10 | 2019-10-01 | International Business Machines Corporation | Utilizing classification and text analytics for annotating documents to allow quick scanning |
US20140164899A1 (en) * | 2012-12-10 | 2014-06-12 | International Business Machines Corporation | Utilizing classification and text analytics for annotating documents to allow quick scanning |
US10509852B2 (en) | 2012-12-10 | 2019-12-17 | International Business Machines Corporation | Utilizing classification and text analytics for annotating documents to allow quick scanning |
US20140215397A1 (en) * | 2013-01-29 | 2014-07-31 | Research In Motion Limited | Apparatus and Method Pertaining to Predicted-Text Derivatives |
US9613068B2 (en) | 2013-03-15 | 2017-04-04 | Amazon Technologies, Inc. | Scalable analysis platform for semi-structured data |
US10983967B2 (en) | 2013-03-15 | 2021-04-20 | Amazon Technologies, Inc. | Creation of a cumulative schema based on an inferred schema and statistics |
US10275475B2 (en) | 2013-03-15 | 2019-04-30 | Amazon Technologies, Inc. | Scalable analysis platform for semi-structured data |
WO2014144889A3 (en) * | 2013-03-15 | 2014-11-06 | Amazon Technologies, Inc. | Scalable analysis platform for semi-structured data |
US10223637B1 (en) | 2013-05-30 | 2019-03-05 | Google Llc | Predicting accuracy of submitted data |
US11526773B1 (en) | 2013-05-30 | 2022-12-13 | Google Llc | Predicting accuracy of submitted data |
US9779076B2 (en) | 2013-09-04 | 2017-10-03 | International Business Machines Corporation | Utilizing classification and text analytics for optimizing processes in documents |
US10176242B2 (en) | 2013-10-15 | 2019-01-08 | Amazon Technologies, Inc. | Local key-value database synchronization |
US9330271B1 (en) | 2013-10-15 | 2016-05-03 | Amazon Technologies, Inc. | Fine-grained access control for synchronized data stores |
US10242084B2 (en) | 2013-10-15 | 2019-03-26 | Amazon Technologies, Inc. | Local key-value database synchronization |
US9235609B1 (en) | 2013-10-15 | 2016-01-12 | Amazon Technologies, Inc. | Local emulation of distributed key-value data store |
US9703814B1 (en) * | 2013-10-15 | 2017-07-11 | Amazon Technologies, Inc. | Local key-value database synchronization |
US20160261466A1 (en) * | 2014-09-17 | 2016-09-08 | Siemens Aktiengesellschaft | Method and Digital Tool for Engineering Software Architectures of Complex Cyber-Physical Systems of Different Technical Domains |
US9838264B2 (en) * | 2014-09-17 | 2017-12-05 | Siemens Aktiengesellschaft | Method and digital tool for engineering software architectures of complex cyber-physical systems of different technical domains |
US10353912B2 (en) * | 2014-10-10 | 2019-07-16 | Salesforce.Com, Inc. | Navigation of a data extraction graph of data and metadata from a data repository |
US20160103899A1 (en) * | 2014-10-10 | 2016-04-14 | Salesforce.Com, Inc. | Navigation of a data extraction graph of data and metadata from a data repository |
US10296630B2 (en) | 2014-10-10 | 2019-05-21 | Salesforce.Com, Inc. | Graph representation of data extraction for use with a data repository |
US10380136B2 (en) | 2014-10-10 | 2019-08-13 | Salesforce.Com, Inc. | Dataflow optimization for extractions from a data repository |
US10169355B2 (en) * | 2014-10-27 | 2019-01-01 | Tata Consultancy Services Limited | Knowledge representation in a multi-layered database |
US10902026B2 (en) | 2014-11-27 | 2021-01-26 | Longsand Limited | Block classified term |
US20160253344A1 (en) * | 2015-02-26 | 2016-09-01 | Unisys Corporation | System and method for implementing a multi-word utc time stamp using a single-word utc time stamp and a multi-word key |
US10069938B1 (en) * | 2015-03-30 | 2018-09-04 | EMC IP Holding Company LLC | Returning identifiers in default query responses |
US10223473B2 (en) * | 2015-03-31 | 2019-03-05 | International Business Machines Corporation | Distribution of metadata for importation |
US20160292301A1 (en) * | 2015-03-31 | 2016-10-06 | International Business Machines Corporation | Distribution of metadata for importation |
US11934372B2 (en) | 2015-04-27 | 2024-03-19 | Rovi Guides, Inc. | Systems and methods for updating a knowledge graph through user input |
US10929372B2 (en) * | 2015-04-27 | 2021-02-23 | Rovi Guides, Inc. | Systems and methods for updating a knowledge graph through user input |
US20160314158A1 (en) * | 2015-04-27 | 2016-10-27 | Rovi Guides, Inc. | Systems and methods for updating a knowledge graph through user input |
US11561955B2 (en) | 2015-04-27 | 2023-01-24 | Rovi Guides, Inc. | Systems and methods for updating a knowledge graph through user input |
US10078651B2 (en) * | 2015-04-27 | 2018-09-18 | Rovi Guides, Inc. | Systems and methods for updating a knowledge graph through user input |
US10032045B2 (en) | 2015-10-30 | 2018-07-24 | Raytheon Company | Dynamic runtime field-level access control using a hierarchical permission context structure |
US11567997B2 (en) * | 2017-01-20 | 2023-01-31 | Amazon Technologies, Inc. | Query language interoperabtility in a graph database |
US20210286848A1 (en) * | 2017-01-20 | 2021-09-16 | Amazon Technologies, Inc. | Query language interoperability in a graph database |
US20210157883A1 (en) * | 2017-06-02 | 2021-05-27 | Thinkspan, LLC | Universal data scaffold based data management platform |
CN108345677A (en) * | 2018-02-13 | 2018-07-31 | 销冠网络科技有限公司 | Data processing method and device for business development |
US11693896B2 (en) * | 2018-09-25 | 2023-07-04 | International Business Machines Corporation | Noise detection in knowledge graphs |
US20230135929A1 (en) * | 2020-08-24 | 2023-05-04 | Unlikely Artificial Intelligence Limited | Computer implemented method for the automated analysis or use of data |
US11763096B2 (en) | 2020-08-24 | 2023-09-19 | Unlikely Artificial Intelligence Limited | Computer implemented method for the automated analysis or use of data |
US11829725B2 (en) | 2020-08-24 | 2023-11-28 | Unlikely Artificial Intelligence Limited | Computer implemented method for the automated analysis or use of data |
US20220070295A1 (en) * | 2020-08-26 | 2022-03-03 | Avaya Management L.P. | Contact center of celebrities |
US11652921B2 (en) * | 2020-08-26 | 2023-05-16 | Avaya Management L.P. | Contact center of celebrities |
WO2022240911A1 (en) * | 2021-05-11 | 2022-11-17 | Cherre, Inc. | Knowledge graph guided database completion and correction system and methods |
US11977854B2 (en) | 2021-08-24 | 2024-05-07 | Unlikely Artificial Intelligence Limited | Computer implemented methods for the automated analysis or use of data, including use of a large language model |
Also Published As
Publication number | Publication date |
---|---|
CA2719095A1 (en) | 2009-09-17 |
AU2009223127A1 (en) | 2009-09-17 |
EP2252941A2 (en) | 2010-11-24 |
WO2009114714A2 (en) | 2009-09-17 |
WO2009114714A3 (en) | 2010-02-25 |
BRPI0909734A2 (en) | 2019-09-24 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US20090024590A1 (en) | User contributed knowledge database | |
Hyvonen | Publishing and using cultural heritage linked data on the semantic web | |
Hay | Data model patterns: A metadata map | |
Zeng et al. | Knowledge Organization Systems (KOS) in the Semantic Web: a multi-dimensional review | |
Dodds et al. | Linked data patterns | |
Coyle | Linked data tools: connecting on the Web | |
Rabinowitz et al. | Making sense of the ways we make sense of the past: The PeriodO project | |
Ryan et al. | Linked data authority records for Irish place names | |
Fallgren et al. | The missing link: The evolving current state of linked data for serials | |
DeWeese et al. | Libraries and the semantic web | |
Maltese et al. | Foundations of digital universities | |
Peponakis | In the Name of the Name: RDF literals, ER attributes and the potential to rethink the structures and visualizations of catalogs | |
Eito-Brun | Context-based aggregation of archival data: the role of authority records in the semantic landscape | |
Lu et al. | Language engineering for the Semantic Web: A digital library for endangered languages | |
Bagui et al. | Mapping rdf and rdf-schema to the entity relationship model | |
Szeto | Positioning library data for the semantic web: recent developments in resource description | |
Wolpers et al. | Bridging repositories to form the MACE experience | |
Peroni et al. | From markup to linked data: Mapping niso jats v1. 0 to rdf using the spar (semantic publishing and referencing) ontologies | |
Taniguchi | Understanding and reviewing RDA Vocabularies in RDF: a multi-layer framework approach | |
Alemu et al. | Metadata and semantics research: a case of an international conference paving toward a data-driven future | |
Lohmann | Conceptualization and visualization of tagging and folksonomies | |
Akça | Access Beyond Borders: Linked Open Data Applications on Cultural Heritage | |
Hogan et al. | Linked data | |
Meghini et al. | SEMANTIC WEB: Introduction to the Semantic Web languages. Notes of the Semantic Web course University of Pisa | |
Coyle | Metadata elements |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: METAWEB TECHNOLOGIES, INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:STURGE, TIMOTHY;BOLLACKER, KURT;COOK, ROBERT;AND OTHERS;REEL/FRAME:021404/0244;SIGNING DATES FROM 20080312 TO 20080313 |
|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: MERGER;ASSIGNOR:METAWEB TECHNOLOGIES, INC.;REEL/FRAME:025364/0717Effective date: 20100716 |
|
AS | Assignment |
Owner name: METAWEB TECHNOLOGIES, INC., CALIFORNIAFree format text: CORRECTIVE ASSIGNMENT TO CORRECT THE COVER SHEET FOR THE MERGER DOCUMENT FILED ON 11/15/2010 AND PREVIOUSLY RECORDED ON REEL 025364 FRAME 0717. ASSIGNOR(S) HEREBY CONFIRMS THE RECEIVING PARTY DATA SHOULD BE METAWEB TECHNOLOGIES, INC.;ASSIGNOR:METAWEB TECHNOLOGIES, INC.;REEL/FRAME:025675/0981Effective date: 20100716 |
|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:METAWEB TECHNOLOGIES, INC.;REEL/FRAME:025748/0575Effective date: 20110202 |
|
STCB | Information on status: application discontinuation |
Free format text: ABANDONED -- FAILURE TO RESPOND TO AN OFFICE ACTION |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044142/0357Effective date: 20170929 |