US20230289626A1 - Knowledge Graph Completion and Multi-Hop Reasoning in Knowledge Graphs at Scale - Google Patents
Knowledge Graph Completion and Multi-Hop Reasoning in Knowledge Graphs at Scale Download PDFInfo
- Publication number
- US20230289626A1 US20230289626A1 US18/183,410 US202318183410A US2023289626A1 US 20230289626 A1 US20230289626 A1 US 20230289626A1 US 202318183410 A US202318183410 A US 202318183410A US 2023289626 A1 US2023289626 A1 US 2023289626A1
- Authority
- US
- United States
- Prior art keywords
- query
- node
- graph
- nodes
- computation graph
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
- 238000000034 method Methods 0.000 claims abstract description 110
- 238000005070 sampling Methods 0.000 claims abstract description 49
- 230000000295 complement effect Effects 0.000 claims description 10
- 230000009466 transformation Effects 0.000 claims description 5
- 230000008569 process Effects 0.000 description 57
- 238000012549 training Methods 0.000 description 40
- 230000015654 memory Effects 0.000 description 34
- 238000013528 artificial neural network Methods 0.000 description 19
- 238000010586 diagram Methods 0.000 description 16
- 238000012545 processing Methods 0.000 description 16
- 230000002457 bidirectional effect Effects 0.000 description 12
- 230000006870 function Effects 0.000 description 11
- 239000008186 active pharmaceutical agent Substances 0.000 description 7
- 238000012795 verification Methods 0.000 description 6
- HPTJABJPZMULFH-UHFFFAOYSA-N 12-[(Cyclohexylcarbamoyl)amino]dodecanoic acid Chemical compound OC(=O)CCCCCCCCCCCNC(=O)NC1CCCCC1 HPTJABJPZMULFH-UHFFFAOYSA-N 0.000 description 5
- 238000004891 communication Methods 0.000 description 5
- 238000013461 design Methods 0.000 description 5
- 239000011159 matrix material Substances 0.000 description 5
- 230000007246 mechanism Effects 0.000 description 5
- 238000005457 optimization Methods 0.000 description 5
- 230000002441 reversible effect Effects 0.000 description 5
- 230000000007 visual effect Effects 0.000 description 5
- 230000008901 benefit Effects 0.000 description 4
- 230000004075 alteration Effects 0.000 description 3
- 238000013459 approach Methods 0.000 description 3
- 230000001537 neural effect Effects 0.000 description 3
- 230000000306 recurrent effect Effects 0.000 description 3
- 230000011218 segmentation Effects 0.000 description 3
- 238000013519 translation Methods 0.000 description 3
- 238000013473 artificial intelligence Methods 0.000 description 2
- 230000006399 behavior Effects 0.000 description 2
- 230000000903 blocking effect Effects 0.000 description 2
- 238000013527 convolutional neural network Methods 0.000 description 2
- 238000001514 detection method Methods 0.000 description 2
- 238000003709 image segmentation Methods 0.000 description 2
- 238000012986 modification Methods 0.000 description 2
- 230000004048 modification Effects 0.000 description 2
- 230000001360 synchronised effect Effects 0.000 description 2
- 238000012360 testing method Methods 0.000 description 2
- 238000012800 visualization Methods 0.000 description 2
- 235000008694 Humulus lupulus Nutrition 0.000 description 1
- 230000009471 action Effects 0.000 description 1
- 230000006978 adaptation Effects 0.000 description 1
- 238000007792 addition Methods 0.000 description 1
- 230000005540 biological transmission Effects 0.000 description 1
- 238000004364 calculation method Methods 0.000 description 1
- 238000007906 compression Methods 0.000 description 1
- 230000006835 compression Effects 0.000 description 1
- 238000013144 data compression Methods 0.000 description 1
- 230000003111 delayed effect Effects 0.000 description 1
- 239000003814 drug Substances 0.000 description 1
- 238000007876 drug discovery Methods 0.000 description 1
- 230000000694 effects Effects 0.000 description 1
- 238000005516 engineering process Methods 0.000 description 1
- 238000007667 floating Methods 0.000 description 1
- 230000003993 interaction Effects 0.000 description 1
- 238000010801 machine learning Methods 0.000 description 1
- 238000013507 mapping Methods 0.000 description 1
- 230000003287 optical effect Effects 0.000 description 1
- 238000005192 partition Methods 0.000 description 1
- 230000000135 prohibitive effect Effects 0.000 description 1
- 238000011002 quantification Methods 0.000 description 1
- 230000009467 reduction Effects 0.000 description 1
- 238000013341 scale-up Methods 0.000 description 1
- 230000006403 short-term memory Effects 0.000 description 1
- 238000000638 solvent extraction Methods 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/0464—Convolutional networks [CNN, ConvNet]
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N5/00—Computing arrangements using knowledge-based models
- G06N5/02—Knowledge representation; Symbolic representation
- G06N5/022—Knowledge engineering; Knowledge acquisition
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/24—Querying
- G06F16/245—Query processing
- G06F16/2453—Query optimisation
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/95—Retrieval from the web
- G06F16/955—Retrieval from the web using information identifiers, e.g. uniform resource locators [URL]
- G06F16/9554—Retrieval from the web using information identifiers, e.g. uniform resource locators [URL] by using bar codes
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/044—Recurrent networks, e.g. Hopfield networks
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/0495—Quantised networks; Sparse networks; Compressed networks
Definitions
- the present disclosure relates generally to knowledge graphs. More particularly, the present disclosure relates to performing negative sampling over knowledge graphs with improved efficiency.
- a knowledge graph is a graph structure that captures knowledge encoded in a form of head-relation-tail triples, where the head and tail are two entities (i.e., nodes) and the relation is an edge between them (e.g., (Paris, CapitalOf, France)).
- Knowledge graphs form the backbone of many artificial intelligence systems across a wide range of domains, such as recommender systems, question answering, commonsense reasoning, personalized medicine, and drug discovery.
- reasoning over such knowledge graphs includes two types of tasks: (1) single-hop link prediction, where given a head and a relation the goal is to predict one or more tail entities, and (2) multi-hop reasoning, where one needs to predict one or many of the tails of a multi-hop logical query. Finding answers to such a query can involve imputation and prediction of multiple edges across two parallel paths, while also using logical set operations (e.g., intersection, union).
- One example aspect of the present disclosure is directed to a method for negative sampling with improved efficiency.
- the method includes obtaining a knowledge graph comprising a plurality of entities and a plurality of links between the plurality of entities, wherein a link from among the plurality of links is between at least two entities from among the plurality of entities and describes a relation between the at least two entities.
- the method further includes generating, based on the knowledge graph, a query computation graph comprising a plurality of nodes and a plurality of edges, wherein the plurality of nodes comprises one or more anchor nodes, a root node, and one or more intermediate nodes positioned in one or more paths between the one or more anchor nodes and the root node.
- the method further includes determining a node cut of a query of the query computation graph, wherein the node cut comprises at least one node that cuts at least one path between each anchor node from among the one or more anchor nodes of the query computation graph and the root node of the query computation graph.
- the method further includes identifying one or more negative samples for the query computation graph by bidirectionally traversing the query computation graph in a first direction from the one or more anchor nodes to the node cut and in a second direction from the root node to the node cut.
- the computing system includes one or more processors and one or more tangible, non-transitory computer-readable media that collectively store instructions that, when executed by the one or more processors, cause the one or more processors to perform operations.
- the operations include obtaining a knowledge graph comprising a plurality of entities and a plurality of links between the plurality of entities, wherein a link from among the plurality of links is between at least two entities from among the plurality of entities and describes a relation between the at least two entities.
- the operations further include generating, based on the knowledge graph, a query computation graph comprising a plurality of nodes and a plurality of edges, wherein the plurality of nodes comprises one or more anchor nodes, a root node, and one or more intermediate nodes positioned in one or more paths between the one or more anchor nodes and the root node.
- the operations further include determining a node cut of a query of the query computation graph, wherein the node cut comprises at least one node that cuts at least one path between each anchor node from among the one or more anchor nodes of the query computation graph and the root node of the query computation graph.
- the operations further include identifying one or more negative samples for the query computation graph by bidirectionally traversing the query computation graph in a first direction from the one or more anchor nodes to the node cut and in a second direction from the root node to the node cut.
- Another example aspect of the present disclosure is directed to one or more tangible, non-transitory computer-readable media that collectively store instructions that, when executed by one or more processors, cause the one or more processors to perform operations.
- the operations include obtaining a knowledge graph comprising a plurality of entities and a plurality of links between the plurality of entities, wherein a link from among the plurality of links is between at least two entities from among the plurality of entities and describes a relation between the at least two entities.
- the operations further include generating, based on the knowledge graph, a query computation graph comprising a plurality of nodes and a plurality of edges, wherein the plurality of nodes comprises one or more anchor nodes, a root node, and one or more intermediate nodes positioned in one or more paths between the one or more anchor nodes and the root node.
- the operations further include determining a node cut of a query of the query computation graph, wherein the node cut comprises at least one node that cuts at least one path between each anchor node from among the one or more anchor nodes of the query computation graph and the root node of the query computation graph.
- the operations further include identifying one or more negative samples for the query computation graph by bidirectionally traversing the query computation graph in a first direction from the one or more anchor nodes to the node cut and in a second direction from the root node to the node cut.
- FIG. 1 depicts graphical diagrams of a multi-hop logical query and a corresponding query computation plan and knowledge graph according to example embodiments of the present disclosure.
- FIG. 2 depicts graphical diagrams of query instantiation from a query structure and negative entities sampling according to example embodiments of the present disclosure.
- FIG. 3 depicts graphical diagrams of query logical structures according to example embodiments of the present disclosure.
- FIG. 4 depicts a diagram of a training computing system according to example embodiments of the present disclosure.
- FIG. 5 depicts a sequence diagram of a worker process of a training computing system according to example embodiments of the present disclosure.
- FIG. 6 depicts a flow chart diagram of an example method for negative sampling with improved efficiency according to example embodiments of the present disclosure.
- FIGS. 7 A- 7 C depict block diagrams of an example computing system according to example embodiments of the present disclosure.
- the present disclosure is directed to systems and methods for scalable knowledge graph reasoning or query answering.
- systems and methods of the present disclosure provide for the first framework for both single-hop and multi-hop reasoning in knowledge graphs at scale.
- Embedding-based methods can solve both single-hop knowledge graph completion and multi-hop reasoning by first computing an embedding for each entity and relation and then using them to form predictions, however, existing scalable knowledge graph embedding frameworks only support single-hop knowledge graph completion and cannot be applied to the more challenging multi-hop reasoning task.
- systems and methods of the present disclosure can advantageously provide for multi-hop knowledge graph reasoning at scale.
- examples described herein include results processed over an example knowledge graph about 1,500 times larger than the largest knowledge graph previously considered for multi-hop reasoning and improve the worst-case runtime of enumerative search by four orders of magnitude.
- systems and methods of the present disclosure can advantageously provide a framework for single-hop and multi-hop knowledge graph reasoning at scale.
- the systems and methods of the present disclosure can perform algorithm-system co-optimization for scalability by efficiently generating training examples and operating on a full knowledge graph directly in a shared memory environment with multiple graphics processing units (GPUs).
- the training examples can be generated with a set of positive entities and a set of negative entities by instantiating a query on a given knowledge graph from a set of query logical structures.
- the root of the instantiated query can represent a known positive answer entity and negative non-answer entities can be obtained by using a bidirectional rejection sampling approach.
- Bidirectional rejection sampling can efficiently obtain high-quality negative entities for the instantiated query by identifying the optimal node cut of a query computation plan using dynamic programming, then simultaneously performing forward knowledge graph traversal and backward verification.
- the nodes in the optimal node cut cache the intermediate results from the forward knowledge graph traversal.
- positive candidate entities and negative candidate entities can be proposed, then the knowledge graph can be traversed backwards to the optimal node cut and rejection sampling can be performed based on overlap of the forward set and the backwards set.
- worst-case complexity is reduced by a square root, so a training query, a positive answer entity, and negative non-answer entities can be instantly generated.
- the systems and methods of the present disclosure can operate on a full knowledge graph on a shared memory environment with multiple GPUs while storing embedding parameters in the CPU memory to overcome a limited GPU memory.
- an asynchronous scheduler can maximize the throughput of GPU computation by overlapping sampling, asynchronous embedding read and write, neural network feed-forward, and optimizer updates.
- an efficient implementation can be obtained that can achieve near linear speed-up with respect to the number of GPUs.
- Example embodiments of the present disclosure provide a number of technical effects and benefits. For instance, more efficient processing at scale and improved utilization of processing resources can decrease computational costs (e.g., energy expenditure, etc.) associated with performing knowledge graph reasoning. For example, embodiments of the present disclosure can be deployed in a single-machine environment with a minimum requirement on the capacity of GPU memory, improve the worst-case runtime of enumerative search, and run more than twice as fast and with less GPU memory usage than existing multi-hop reasoning frameworks.
- computational costs e.g., energy expenditure, etc.
- Query embedding methods aim to answer multi-hop logical queries by avoiding explicit knowledge graph traversal and executing the query directly in the embedding space by following a query computation plan, which can be robust against missing links.
- multi-hop knowledge graph reasoning one may need to predict one or many of the tail entities of a multi-hop logical query. Finding answers to the multi-hop logical query may require imputation and prediction of multiple edges across two parallel paths, while also using logical set operations, such as intersection and union. For instance, missing links typically need to be implicitly inferred in the knowledge graph in order to determine the entities that are the answer to a complex multi-hop query.
- FIG. 1 depicts graphical diagrams of a multi-hop logical query and a corresponding query computation plan and knowledge graph according to example embodiments of the present disclosure.
- a multi-hop logical query 190 may ask, “Who co-authored with Canadian Turing Award winners.”
- imputation and prediction of multiple edges across two parallel paths while using logical set operations may be used.
- Finding such answers to the multi-hop logical query 190 may be achieved by employing a query computation plan 192 .
- the query computation plan 192 can provide a plan for executing the multi-hop logical query 190 .
- the query computation plan 192 may include a “Turing Award” entity and a “Canada” entity in two parallel paths, one path following the “win” relation and the other path following the “citizen” relation.
- missing links may need to be implicitly inferred in the knowledge graph 194 .
- the intersection logical set operation can be used to find the answer to the multi-hop query 190 of “Who co-authored with Canadian Turing Award winners” and the missing links may be implicitly inferred in the knowledge graph 194 in order to obtain the answer.
- a knowledge graph G (V, E, R) can consist of a set of nodes V, edges ⁇ , and relations R.
- Each edge e ⁇ ⁇ represents a triple (v h , r, v t ) where r ⁇ R and v h , v t ⁇ V.
- Multi-hop reasoning queries can include relation traversals and logical operations, such as conjunction ( ⁇ ), disjunction (V), existential quantification (3), and negation ( ⁇ ), as non-limiting examples.
- first-order logical queries in disjunctive normal form may be used in some implementations.
- a first-order logical query q may consist of a non-variable anchor entity set V q ⁇ V, existentially quantified bound variables V 1 ,..., V k , and a single target variable V 7 , which can represent the answer.
- the disjunctive normal form of a query q can be defined as: q
- each e represents an atomic formula or its negation
- e ij r(v a , V) or ⁇ r(v a , V) or r(V′, V) or ⁇ r(V′, V), where v a ⁇ V q , V ⁇ ⁇ V ? ,V 1 , ..., V k ⁇ , V′ ⁇ ⁇ V 1 , ..., V k ⁇ , V ⁇ V′, r ⁇ R.
- a query computation plan (e.g., query computation plan 192 ) can provide a plan for executing the query (e.g., multi-hop logical query 190 ).
- the query computation plan can consist of nodes V q U ⁇ V 1 , ..., V k , V ? ⁇ , where each node corresponds to a set of entities on the knowledge graph.
- the edges in the query computation plan can represent a logical or relational transformation of this set of entities, such as relation projection, intersection, union, complement, and negation, as non-limiting examples.
- a knowledge graph can be traversed using a query computation plan. For example, assuming no noise and no missing relations in the knowledge graph, a logical query (e.g., a first-order logical query) can be answered by traversing the edges of the knowledge graph.
- the query computation plan may be a tree structure, where the anchor entity set, V q , are the leaves and the target variable, V ? , is the single root, representing the set of answer entities.
- the knowledge graph can be traversed and logical operators can be executed towards the root node. The answers
- Embedding-based reasoning methods avoid explicit knowledge graph traversal. Instead, embedding-based reasoning methods start with the embeddings of anchored entities and then apply a sequence of neural logical operators according to the query computation plan. As a result, the embedding of the query where each embedding-based logical operator can take the current input embedding and transform it into a new output embedding can be obtained. Then the logical operators can be combined according to the query structure. The answers to the query q may be the entities v that are embedded close to the final query embedding.
- the distance can be measured by a pre-defined function Dist (f ⁇ (q), f ⁇ (v)), where f ⁇ (q) and f ⁇ (v) represent the query and the entity embedding, respectively.
- the distance function (Dist) may be tailored to different embedding spaces and model design f ⁇ .
- methods can design a projection operator -T and intersection operator J.
- P can represent a mapping from a set of entities (represented by an embedding) to another set of entities (also represented by an embedding) with one relation (i.e., P : R d ⁇ R ⁇ R d ), assuming the embedding dimension is d.
- the J can take as input multiple embeddings and output the embedding that represents the intersected set of entities: J : R d X ... ⁇ R d ⁇ R d . Different models may have different instantiations of these two operators.
- a data sampler D can be given, where each sample in D is a tuple
- the contrastive loss equation (1) is designed to minimize the distance between the query embedding and the query embedding’s answers
- the systems and methods of the present disclosure can scale up single-hop and multi-hop knowledge graph reasoning methods with an efficient sampling algorithm and parallel training for a given contrastive loss.
- Sampling training data for multi-hop reasoning is more complicated than in link prediction, where sampling the training data (head-relation-tail triple) can be quickly performed by dictionary lookup.
- sampling training data for multi-hop reasoning may involve generating queries q by instantiating query structures and performing knowledge graph traversal to find answers
- the systems and methods of the present disclosure can provide an efficient technique to sample training data for contrastive learning for multi-hop reasoning.
- a knowledge graph with entities or nodes and links or edges between the entities that describe the relation between the entities can be obtained.
- the knowledge graph may be a heterogeneous graph.
- a query structure (also referred to as a query computation graph or query computation plan) can be generated based on the knowledge graph.
- the query structure can contain nodes and edges, and the nodes can include anchor nodes, a root node, and intermediate nodes in the paths between the anchor nodes and the root node, such as in implementations where the query structure is a tree structure.
- a node cut of the query structure can be determined.
- the node cut can correspond to a query of the query structure.
- the node cut can include at least one node that cuts at least one path between each anchor node and the root node of the query structure.
- bidirectional rejection sampling can be used to bidirectionally traverse the query structure in a first direction from the anchor nodes to the node cut and in a second direction from the root node to the node cut. During the traversal in the first direction from the anchor nodes to the node cut, the intermediate nodes obtained while traversing can be cached.
- FIG. 2 depicts graphical diagrams of query instantiation from a query structure and negative entities sampling according to example embodiments of the present disclosure.
- queries can be instantiated using query structures from root to leaves.
- the entity in the root can become a positive answer to the instantiated query.
- bidirectional rejection sampling can be performed, which may have a square root computation complexity compared to the traversal-based method.
- a query is instantiated 202 on a given knowledge graph from a set of query structures, such as query structure 204 .
- the root of the instantiated query 202 can represent a known positive answer entity (e.g., one known positive answer: Radford Neal in the instantiated query 202 ).
- Negative non-answer entities for the instantiated query 202 can be obtained by using a bidirectional rejection sampling approach.
- the optimal node cut e.g., the node after the intersection in the forward knowledge graph traversal 206 of the bidirectional rejection sampling
- Forward knowledge graph traversal 206 and backward verification 208 can then be performed simultaneously.
- the nodes in the optimal node cut can cache the intermediate results from the forward knowledge graph traversal 206 .
- positive candidate entities and negative candidate entities can be proposed, the knowledge graph can be traversed backwards to the optimal node cut, and rejection sampling can be performed based on overlap between the forward traversal set and the backward traversal set.
- rejection sampling can be performed based on overlap between the forward traversal set and the backward traversal set.
- the overlap of the cached intermediate nodes and the nodes traversed while traversing in the second direction from the root node to the node cut can be determined, where a node is a negative non-answer when there is no overlap between the cached intermediate nodes and the traversed nodes.
- the overlap between negative candidate entities and the cached intermediate nodes can be determined.
- a node cut c q of a query q can be a set of nodes in the query computation plan, such that every path between anchor node (leaf) and answer node (root) contains one node in c q .
- a node cut is minimal, meaning that no subset of c q can be a node cut.
- the node after the intersection operation e.g., the “Bengio” node in the instantiated query 202
- the node after the intersection operation can be set as the single node in the node cut.
- the set of “Canadian Turing Award winners” can be obtained by forward knowledge graph traversal 206 caching the intermediate results (e.g., “Bengio”).
- the process can take O(C) computation or memory cost, where C is the degree of the knowledge graph.
- the cost can be O(C) to verify whether the set of co-authors of v overlaps with the cached entities in the node cut.
- a constant number of candidate negative entities can be used, resulting in an overall computation cost of O(C), which is a reduction of square root from O(C 2 ) using exhaustive traversal.
- the computation cost for any given node cut c q can be calculated.
- An efficient algorithm can be used to then find the optimal node cut, which may be the node cut with the lowest cost in bidirectional search.
- Computation costs for the node cuts can be based on paths between each anchor node and the root node. To calculate the computation costs, a maximum number of relation projections in the paths between each anchor node and the root node, a length of a path from each anchor node to the anchor nodes where the length of the path is a number of relation projections on the path, and the optimal costs of resolving the paths between each anchor node and the root node can be determined.
- the optimization problem (2) can be solved with dynamic programming, for instance when the query computation plan is a tree.
- the relation projection operation can enlarge the current set of entities by a factor of C, which is the maximum node degree, in the worst case, so the total cost grows exponentially with the number of relation projection operations in a reasoning path.
- intersection and union operations if the set of entities is a sorted list, then intersection or union of the two sets takes linear time with respect to the number of entities in both sets, so it is not a limiting factor in the overall computation cost if a constant number of sets is merged together.
- the computation cost of a single set complement operation is O(
- the complement operation can be delayed to the next step on the query computation plan (i.e., perform complement and union or intersection simultaneously), which reduces the complexity from O(V) to that of an intersection operation.
- the set difference b - a (of complexity O
- the focus is the maximum number of relation projections in any reasoning path (i.e., a path that connects a leaf/anchor entity v ⁇ V q and the root/answer entity V ? ).
- u(v), s(v), o(v) represent the number of relation projections from v to the root V ? , the maximum length of path from v to any anchors where the length is measured by the number of relation projections on that path, and the optimal cost of resolving all the reasoning paths that include v in the best plan, respectively.
- the dependency of the three functions can be derived recursively, the dynamic program can be solved in a linear time with respect to
- the parent of node v can be denoted p(v) and the set of children nodes can be denoted ch(v).
- ch(v) can be overloaded to denote that specific child.
- the recursion can be taken as:
- o v u v , i f v ⁇ V q m i n m a x z ⁇ c h v o z , m a x u v , s v , else
- IsRel(v ⁇ p(v)) returns 1 if the edge between v and p(v) represents a relation projection and 0 otherwise; NotNeg(ch(v) ⁇ v) returns 1 if the edge between ch(v) and v is not negation and 0 otherwise.
- the node cut can be constructed from solution o( ⁇ ) in a top-down direction: If for any node v there is max z ⁇ ch(v )o( Z ) larger than max ⁇ u(v), s(v) ⁇ , then add v to the node cut; otherwise, do the check recursively for z ⁇ ch(v).
- FIG. 3 depicts graphical diagrams of query logical structures according to example embodiments of the present disclosure.
- the optimal node cuts of the example query structures and the anchor entities V q in the example query structures are represented, showing that different query structures can have different optimal node cuts.
- the example query structures and the optimal node cuts of the example query structures can be used by the bidirectional rejection sampling of the present disclosure.
- a query logical structure (e.g., example query logical structure of FIG. 3 ) can specify the backbone of a query q, including the types of operation (e.g., intersection, relation projection, negation, and union, as non-limiting examples) and the structure of the query.
- the query logical structure can be viewed as an abstraction of the query computation plan, where anchor nodes and relation types may not be grounded.
- Instantiating a query is a way to construct a concrete query given the logical structure of the query.
- Instantiating a query structure involves specifying a relation r ⁇ R for each edge in the structure and the anchor entities V q .
- the systems and methods of the present disclosure allow for instantiating a query logical structure by using reverse directional sampling to construct queries from a knowledge graph, which reduces computation cost compared to current methods. For example, first the root node (i.e., the answer node) of the query structure may be grounded, then the query structure can be processed towards the anchor nodes.
- the overall instantiation process corresponds to a depth-first search where at each step a node/edge on the query structure can be grounded with an entity/relation from the knowledge graph.
- Reverse directional sampling can use depth-first search over the query structure from the root (i.e., the answer node) to the leaves (i.e., the anchor nodes).
- each node on the query structure can be grounded to an entity on the knowledge graph and an edge of the query structure can be grounded to a relation on the knowledge graph associated with the previously grounded entity.
- Reverse directional sampling can return the instantiated query q, the anchor entities V q , and a single positive answer
- the query structure root is “Neal,” which can be a positive answer.
- instantiation starts at the root node “Neal.”
- An entity from the knowledge graph can be randomly sampled, such as the “Neal” entity.
- the edge that points to the root “Neal” in the query structure can be grounded (e.g., “Co-author”) and a relation type from the knowledge graph that points to the entity “Neal” can be sampled.
- the next node which has the relation “Co-author” with “Neal” (e.g., “Bengio”) can be grounded to an entity on the knowledge graph.
- the next node can be directly grounded with the same entity (e.g., “Bengio”) and another relation on the knowledge graph that relates to “Bengio” can be grounded (e.g., “Win”), until finally reaching the anchor entity (leaf) by sampling an entity on the knowledge graph that has the relation “Win” with “Bengio” (e.g., “Turing Award”).
- the instantiated query, the anchor entities (the leaves “Turing Award” and “Canada”), and a positive answer (the root “Neal”) can be returned.
- Reverse directional sampling can obtain valid queries with a non-empty answer set and the overall complexity can be O(C
- the tuple (q, V q , ⁇ a q ⁇ ) can be obtained as a positive sample.
- a single answer entity can be sufficient in each step of stochastic training, while
- the systems and methods of the present disclosure can instead perform bidirectional sampling in order to efficiently obtain negative non-answer entities
- Rejection sampling can be used to locate a subset of negative entities efficiently, as
- a node cut can be obtained on the query computation plan (i.e., a subset of nodes that cut all the paths between each leaf node and the root node), then bidirectional search can be performed.
- the traversal of the query computation plan can be started from the leaves (i.e., the anchor nodes) to the node cut, and the entities obtained in traversal can be cached (e.g., forward caching the intermediate results from the forward knowledge graph traversal 206 ).
- negative entities can be sampled, traversal from the root to the node cut can be performed, and whether the sample negative entities are true negatives can be verified by checking the overlap of the cached entities and the traversed set (e.g., backward verification 208 ).
- the full knowledge graph can be operated on directly in a shared memory environment with multiple GPUs, while storing embedding parameters in the CPU memory to overcome the limited GPU memory.
- the usage of CPU and GPU can be combined, where the dense matrix computations can be deployed on GPUs and the sampling operations can be deployed on CPUs.
- An asynchronous scheduler can be used to maximize the throughput of GPU computation by overlapping sampling, asynchronous embedding read/write, neural network feed-forward, and optimizer updates. As a result, an efficient implementation can be obtained that can achieve near linear speed-up with respect to the number of GPUs.
- FIG. 4 depicts a diagram of a training computing system according to example embodiments of the present disclosure.
- One worker process can be launched per GPU device, where w denotes an index of a worker process.
- Worker w gets the shared access to ⁇ E and local GPU copy of dense parameters ⁇ D .
- Each worker w repeats the following steps until training stops:
- FIG. 5 depicts a sequence diagram of a worker process of a training computing system according to example embodiments of the present disclosure.
- FIG. 5 shows the overlapping sampling, asynchronous embedding read/write, neural network feed-forward, and optimizer updates of the asynchronous scheduler that can be used to maximize the throughput of GPU computation.
- the stages can be virtually categorized into four kinds of meta-threads, where each kind of meta-thread may consist of multiple CPU threads or CUDA streams. These meta-threads can run concurrently, with possible synchronization events for pending resources.
- one meta-thread example is sampler 502 , which can be a multi-thread sampler.
- Each worker w can maintain one sampler D w that has access to the shared knowledge graph.
- the sampler can container a thread pool for sampling queries and the corresponding positive/negative answers in parallel.
- the data sampler can work concurrently with the other meta-threads (e.g., embedding read/write 504 , neural network 506 , sparse optimizer read/write 508 ).
- the pre-fetching mechanism can obtain samples for the next mini-batch while training happens using current batch on other threads, so if the sampler is efficient enough, then the runtime can almost be ignored.
- one meta-thread example is an embedding read/write 504 , such as a sparse embedding read/write.
- a single background thread can be created with a CUDA stream for embedding read and write.
- the background thread may first load that into a pinned memory area, then the CUDA asynchronous stream can perform pinned memory to GPU memory copy.
- This read operator may be non-blocking and may not be synchronized until the CUDA operator in the main CUDA stream asks for it.
- the write operation can work similarly but in the reverse direction.
- one meta-thread example is a neural network 506 , such as neural network feed-forward.
- the feed-forward model f ⁇ can start when training data
- the asynchronous update for ⁇ E can be invoked first without blocking, and at the same time the AllReduce operation can start, followed by the dense parameter update of ⁇ D on the GPU.
- one meta-thread example is a sparse optimizer read/write 508 , such as a sparse optimizer with asynchronous read/write.
- a sparse optimizer read/write 508 such as a sparse optimizer with asynchronous read/write.
- ⁇ E only a small set of rows of ⁇ E may be involved in each stochastic update.
- V q , N q G , and A q G V q , V q , N q G , and A q G .
- the first and second order moments of gradients may also be in CPU and treated in the same manner as ⁇ E , and thus may have the same asynchronous read/write behavior as discussed above.
- the optimizer can also start to pre-fetch the corresponding first/second order moments in a different background thread.
- Each mini-batch data can be formatted as
- N ⁇ V are the shared negative answers for all queries.
- is an indicator matrix.
- Mask i,j specifies whether the j-th entry in N is a negative sample for q i . This sharing also favors the bidirectional rejection sampler, as it is the sample-and-check process, with the adaptation that all the queries in the same mini-batch share the support of negative sampling proposal.
- the computation among worker processes can be balanced since there is the synchronized gradient update for ⁇ D at each step.
- some of the simple structures like 1-hop question can be computed very fast, which others, such as conjunctions with negations, need not only multi-hop computation, but also involve dense neural network calculation.
- the sampler D w of each worker w can sample queries of the same structure in each mini-batch by synchronizing the random seed at the beginning, while not making the actual instantiated query the same.
- FIG. 6 depicts a flow chart diagram of an example method 600 for negative sampling with improved efficiency according to example embodiments of the present disclosure.
- a computing system obtains a knowledge graph comprising a plurality of entities and a plurality of links between the plurality of entities, wherein a link from among the plurality of links is between at least two entities from among the plurality of entities and describes a relation between the at least two entities.
- the knowledge graph can be a heterogeneous graph.
- the computing system generates, based on the knowledge graph, a query computation graph comprising a plurality of nodes and a plurality of edges, wherein the plurality of nodes comprises one or more anchor nodes, a root node, and one or more intermediate nodes positioned in one or more paths between the one or more anchor nodes and the root node.
- the query computation graph can be a plan for executing a query, and the query can be executed in an embedding space.
- Each node from among the plurality of nodes of the query computation graph can correspond to a set of entities on the knowledge graph, and the plurality of edges of the query computation graph can represent a logical relational transformation of the set of entities on the knowledge graph, wherein the logical relational transformation of the set of entities on the knowledge graph can include one or more of relation projection, intersection, union, complement, and negation.
- a depth-first search over the query computation graph from the root node of the query computation graph to the one or more anchor nodes of the query computation graph can be performed, wherein each node of the query computation graph is grounded to an entity on the knowledge graph and an edge of the query computation graph is grounded to a relation on the knowledge graph associated with a previously grounded entity on the knowledge graph.
- the root node of the query computation graph may be a known positive answer to the query.
- the computing system determines a node cut of a query of the query computation graph, wherein the node cut comprises at least one node that cuts at least one path between each anchor node from among the one or more anchor nodes of the query computation graph and the root node of the query computation graph.
- the query can be a first-order logical query.
- the computing system can calculate computation costs for one or more node cuts based on paths between each anchor node from among the one or more anchor nodes of the query computation graph and the root node of the query computation graph, and the node cut can be one of the node cuts with a lowest computation cost.
- the computation costs for the one or more node cuts can include determining a maximum number of relation projections in the paths between each anchor node from among the one or more anchor nodes of the query computation graph and the root node of the query computation graph, determining a length of a path from each anchor node to the anchor nodes where the length of the path is the number of relation projections on the path, and determining optimal costs of resolving the paths between each anchor node from among the one or more anchor nodes of the query computation graph and the root node of the query computation graph.
- the computing system identifies one or more negative samples for the query computation graph by bidirectionally traversing the query computation graph in a first direction from the one or more anchor nodes to the node cut and in a second direction from the root node to the node cut.
- traversing the query computation graph in the first direction from the one or more anchor nodes to the node cut can include caching the one or more intermediate nodes, wherein the intermediate nodes are obtained while traversing the query computation graph in the first direction, comparing overlap of the cached one or more intermediate nodes and a set of nodes traversed while traversing the query computation graph in the second direction from the root node to the node cut, and determining, based on the overlap, that a node from among the set of nodes traversed is a negative non-answer to the query, wherein a negative sample comprises the negative non-answer to the query.
- traversing the query computation graph can include obtaining, from the query computation graph, a candidate negative node and determining whether the candidate negative node overlaps with the cached one or more intermediate nodes. For example, a node from among the set of nodes traversed can be a negative non-answer to the query if there is no overlap between the cached one or more intermediate nodes and the set of nodes traversed while traversing the query computation graph in the second direction from the root node to the node cut.
- bidirectionally traversing the query computation graph in the first direction from the one or more anchor nodes to the node cut and in the second direction from the root node to the node cut can include randomly sampling one or more negative candidate nodes in the second direction.
- FIG. 7 A depicts a block diagram of an example computing system 100 that performs negative sampling with improved efficiency according to example embodiments of the present disclosure.
- the computing system 100 includes a user computing device 102 , a server computing system 130 , and a training computing system 150 that are communicatively coupled over a network 180 .
- the user computing device 102 can be any type of computing device, such as, for example, a personal computing device (e.g., laptop or desktop), a mobile computing device (e.g., smartphone or tablet), a gaming console or controller, a wearable computing device, an embedded computing device, or any other type of computing device.
- a personal computing device e.g., laptop or desktop
- a mobile computing device e.g., smartphone or tablet
- a gaming console or controller e.g., a gaming console or controller
- a wearable computing device e.g., an embedded computing device, or any other type of computing device.
- the user computing device 102 includes one or more processors 112 and a memory 114 .
- the one or more processors 112 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, an FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected.
- the memory 114 can include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof.
- the memory 114 can store data 116 and instructions 118 which are executed by the processor 112 to cause the user computing device 102 to perform operations.
- the user computing device 102 can store or include one or more knowledge graph reasoning models 120 .
- the knowledge graph reasoning models 120 can be or can otherwise include various machine-learned models such as neural networks (e.g., deep neural networks) or other types of machine-learned models, including non-linear models and/or linear models.
- Neural networks can include feed-forward neural networks, recurrent neural networks (e.g., long short-term memory recurrent neural networks), convolutional neural networks or other forms of neural networks.
- Some example machine-learned models can leverage an attention mechanism such as self-attention.
- some example machine-learned models can include multi-headed self-attention models (e.g., transformer models).
- the one or more knowledge graph reasoning models 120 can be received from the server computing system 130 over network 180 , stored in the user computing device memory 114 , and then used or otherwise implemented by the one or more processors 112 .
- the user computing device 102 can implement multiple parallel instances of a single knowledge graph reasoning model 120 (e.g., to perform parallel knowledge graph reasoning across multiple instances).
- one or more knowledge graph reasoning models 140 can be included in or otherwise stored and implemented by the server computing system 130 that communicates with the user computing device 102 according to a client-server relationship.
- the knowledge graph reasoning models 140 can be implemented by the server computing system 130 as a portion of a web service (e.g., a knowledge graph reasoning service).
- a knowledge graph reasoning service e.g., a knowledge graph reasoning service
- one or more knowledge graph reasoning models 120 can be stored and implemented at the user computing device 102 and/or one or more knowledge graph reasoning models 140 can be stored and implemented at the server computing system 130 .
- the user computing device 102 can also include one or more user input components 122 that receives user input.
- the user input component 122 can be a touch-sensitive component (e.g., a touch-sensitive display screen or a touch pad) that is sensitive to the touch of a user input object (e.g., a finger or a stylus).
- the touch-sensitive component can serve to implement a virtual keyboard.
- Other example user input components include a microphone, a traditional keyboard, or other means by which a user can provide user input.
- the server computing system 130 includes one or more processors 132 and a memory 134 .
- the one or more processors 132 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, an FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected.
- the memory 134 can include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof.
- the memory 134 can store data 136 and instructions 138 which are executed by the processor 132 to cause the server computing system 130 to perform operations.
- the server computing system 130 includes or is otherwise implemented by one or more server computing devices. In instances in which the server computing system 130 includes plural server computing devices, such server computing devices can operate according to sequential computing architectures, parallel computing architectures, or some combination thereof.
- the server computing system 130 can store or otherwise include one or more knowledge graph reasoning models 140 .
- the knowledge graph reasoning models 140 can be or can otherwise include various machine-learned models.
- Example machine-learned models include neural networks or other multi-layer non-linear models.
- Example neural networks include feed forward neural networks, deep neural networks, recurrent neural networks, and convolutional neural networks.
- Some example machine-learned models can leverage an attention mechanism such as self-attention.
- some example machine-learned models can include multi-headed self-attention models (e.g., transformer models).
- the user computing device 102 and/or the server computing system 130 can train the knowledge graph reasoning models 120 and/or 140 via interaction with the training computing system 150 that is communicatively coupled over the network 180 .
- the training computing system 150 can be separate from the server computing system 130 or can be a portion of the server computing system 130 .
- the training computing system 150 includes one or more processors 152 and a memory 154 .
- the one or more processors 152 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, an FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected.
- the memory 154 can include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof.
- the memory 154 can store data 156 and instructions 158 which are executed by the processor 152 to cause the training computing system 150 to perform operations.
- the training computing system 150 includes or is otherwise implemented by one or more server computing devices.
- the training computing system 150 can include a model trainer 160 that trains the knowledge graph reasoning models 120 and/or 140 stored at the user computing device 102 and/or the server computing system 130 using various training or learning techniques, such as, for example, backwards propagation of errors.
- a loss function can be backpropagated through the model(s) to update one or more parameters of the model(s) (e.g., based on a gradient of the loss function).
- Various loss functions can be used such as mean squared error, likelihood loss, cross entropy loss, hinge loss, and/or various other loss functions.
- Gradient descent techniques can be used to iteratively update the parameters over a number of training iterations.
- performing backwards propagation of errors can include performing truncated backpropagation through time.
- the model trainer 160 can perform a number of generalization techniques (e.g., weight decays, dropouts, etc.) to improve the generalization capability of the models being trained.
- model trainer 160 can train the knowledge graph reasoning models 120 and/or 140 based on a set of training data 162 .
- the training examples can be provided by the user computing device 102 .
- the knowledge graph reasoning model 120 provided to the user computing device 102 can be trained by the training computing system 150 on user-specific data received from the user computing device 102 . In some instances, this process can be referred to as personalizing the model.
- the model trainer 160 includes computer logic utilized to provide desired functionality.
- the model trainer 160 can be implemented in hardware, firmware, and/or software controlling a general purpose processor.
- the model trainer 160 includes program files stored on a storage device, loaded into a memory and executed by one or more processors.
- the model trainer 160 includes one or more sets of computer-executable instructions that are stored in a tangible computer-readable storage medium such as RAM, hard disk, or optical or magnetic media.
- the network 180 can be any type of communications network, such as a local area network (e.g., intranet), wide area network (e.g., Internet), or some combination thereof and can include any number of wired or wireless links.
- communication over the network 180 can be carried via any type of wired and/or wireless connection, using a wide variety of communication protocols (e.g., TCP/IP, HTTP, SMTP, FTP), encodings or formats (e.g., HTML, XML), and/or protection schemes (e.g., VPN, secure HTTP, SSL).
- the machine-learned models described in this specification may be used in a variety of tasks, applications, and/or use cases.
- the input to the machine-learned model(s) of the present disclosure can be image data.
- the machine-learned model(s) can process the image data to generate an output.
- the machine-learned model(s) can process the image data to generate an image recognition output (e.g., a recognition of the image data, a latent embedding of the image data, an encoded representation of the image data, a hash of the image data, etc.).
- the machine-learned model(s) can process the image data to generate an image segmentation output.
- the machine-learned model(s) can process the image data to generate an image classification output.
- the machine-learned model(s) can process the image data to generate an image data modification output (e.g., an alteration of the image data, etc.).
- the machine-learned model(s) can process the image data to generate an encoded image data output (e.g., an encoded and/or compressed representation of the image data, etc.).
- the machine-learned model(s) can process the image data to generate an upscaled image data output.
- the machine-learned model(s) can process the image data to generate a prediction output.
- the input to the machine-learned model(s) of the present disclosure can be text or natural language data.
- the machine-learned model(s) can process the text or natural language data to generate an output.
- the machine-learned model(s) can process the natural language data to generate a language encoding output.
- the machine-learned model(s) can process the text or natural language data to generate a latent text embedding output.
- the machine-learned model(s) can process the text or natural language data to generate a translation output.
- the machine-learned model(s) can process the text or natural language data to generate a classification output.
- the machine-learned model(s) can process the text or natural language data to generate a textual segmentation output.
- the machine-learned model(s) can process the text or natural language data to generate a semantic intent output.
- the machine-learned model(s) can process the text or natural language data to generate an upscaled text or natural language output (e.g., text or natural language data that is higher quality than the input text or natural language, etc.).
- the machine-learned model(s) can process the text or natural language data to generate a prediction output.
- the input to the machine-learned model(s) of the present disclosure can be speech data.
- the machine-learned model(s) can process the speech data to generate an output.
- the machine-learned model(s) can process the speech data to generate a speech recognition output.
- the machine-learned model(s) can process the speech data to generate a speech translation output.
- the machine-learned model(s) can process the speech data to generate a latent embedding output.
- the machine-learned model(s) can process the speech data to generate an encoded speech output (e.g., an encoded and/or compressed representation of the speech data, etc.).
- an encoded speech output e.g., an encoded and/or compressed representation of the speech data, etc.
- the machine-learned model(s) can process the speech data to generate an upscaled speech output (e.g., speech data that is higher quality than the input speech data, etc.).
- the machine-learned model(s) can process the speech data to generate a textual representation output (e.g., a textual representation of the input speech data, etc.).
- the machine-learned model(s) can process the speech data to generate a prediction output.
- the input to the machine-learned model(s) of the present disclosure can be latent encoding data (e.g., a latent space representation of an input, etc.).
- the machine-learned model(s) can process the latent encoding data to generate an output.
- the machine-learned model(s) can process the latent encoding data to generate a recognition output.
- the machine-learned model(s) can process the latent encoding data to generate a reconstruction output.
- the machine-learned model(s) can process the latent encoding data to generate a search output.
- the machine-learned model(s) can process the latent encoding data to generate a reclustering output.
- the machine-learned model(s) can process the latent encoding data to generate a prediction output.
- the input to the machine-learned model(s) of the present disclosure can be statistical data.
- Statistical data can be, represent, or otherwise include data computed and/or calculated from some other data source.
- the machine-learned model(s) can process the statistical data to generate an output.
- the machine-learned model(s) can process the statistical data to generate a recognition output.
- the machine-learned model(s) can process the statistical data to generate a prediction output.
- the machine-learned model(s) can process the statistical data to generate a classification output.
- the machine-learned model(s) can process the statistical data to generate a segmentation output.
- the machine-learned model(s) can process the statistical data to generate a visualization output.
- the machine-learned model(s) can process the statistical data to generate a diagnostic output.
- the input to the machine-learned model(s) of the present disclosure can be sensor data.
- the machine-learned model(s) can process the sensor data to generate an output.
- the machine-learned model(s) can process the sensor data to generate a recognition output.
- the machine-learned model(s) can process the sensor data to generate a prediction output.
- the machine-learned model(s) can process the sensor data to generate a classification output.
- the machine-learned model(s) can process the sensor data to generate a segmentation output.
- the machine-learned model(s) can process the sensor data to generate a visualization output.
- the machine-learned model(s) can process the sensor data to generate a diagnostic output.
- the machine-learned model(s) can process the sensor data to generate a detection output.
- the machine-learned model(s) can be configured to perform a task that includes encoding input data for reliable and/or efficient transmission or storage (and/or corresponding decoding).
- the task may be an audio compression task.
- the input may include audio data and the output may comprise compressed audio data.
- the input includes visual data (e.g. one or more images or videos), the output comprises compressed visual data, and the task is a visual data compression task.
- the task may comprise generating an embedding for input data (e.g. input audio or visual data).
- the input includes visual data and the task is a computer vision task.
- the input includes pixel data for one or more images and the task is an image processing task.
- the image processing task can be image classification, where the output is a set of scores, each score corresponding to a different object class and representing the likelihood that the one or more images depict an object belonging to the object class.
- the image processing task may be object detection, where the image processing output identifies one or more regions in the one or more images and, for each region, a likelihood that region depicts an object of interest.
- the image processing task can be image segmentation, where the image processing output defines, for each pixel in the one or more images, a respective likelihood for each category in a predetermined set of categories.
- the set of categories can be foreground and background.
- the set of categories can be object classes.
- the image processing task can be depth estimation, where the image processing output defines, for each pixel in the one or more images, a respective depth value.
- the image processing task can be motion estimation, where the network input includes multiple images, and the image processing output defines, for each pixel of one of the input images, a motion of the scene depicted at the pixel between the images in the network input.
- the input includes audio data representing a spoken utterance and the task is a speech recognition task.
- the output may comprise a text output which is mapped to the spoken utterance.
- the task comprises encrypting or decrypting input data.
- the task comprises a microprocessor performance task, such as branch prediction or memory address translation.
- FIG. 7 A illustrates one example computing system that can be used to implement the present disclosure.
- the user computing device 102 can include the model trainer 160 and the training dataset 162 .
- the knowledge graph reasoning models 120 can be both trained and used locally at the user computing device 102 .
- the user computing device 102 can implement the model trainer 160 to personalize the knowledge graph reasoning models 120 based on user-specific data.
- FIG. 7 B depicts a block diagram of an example computing device 10 that performs negative sampling with improved efficiency according to example embodiments of the present disclosure.
- the computing device 10 can be a user computing device or a server computing device.
- the computing device 10 includes a number of applications (e.g., applications 1 through N). Each application contains its own machine learning library and machine-learned model(s). For example, each application can include a machine-learned model.
- Example applications include a text messaging application, an email application, a dictation application, a virtual keyboard application, a browser application, etc.
- each application can communicate with a number of other components of the computing device, such as, for example, one or more sensors, a context manager, a device state component, and/or additional components.
- each application can communicate with each device component using an API (e.g., a public API).
- the API used by each application is specific to that application.
- FIG. 7 C depicts a block diagram of an example computing device 50 that performs negative sampling with improved efficiency according to example embodiments of the present disclosure.
- the computing device 50 can be a user computing device or a server computing device.
- the computing device 50 includes a number of applications (e.g., applications 1 through N). Each application is in communication with a central intelligence layer.
- Example applications include a text messaging application, an email application, a dictation application, a virtual keyboard application, a browser application, etc.
- each application can communicate with the central intelligence layer (and model(s) stored therein) using an API (e.g., a common API across all applications).
- the central intelligence layer includes a number of machine-learned models. For example, as illustrated in FIG. 7 C , a respective machine-learned model can be provided for each application and managed by the central intelligence layer. In other implementations, two or more applications can share a single machine-learned model. For example, in some implementations, the central intelligence layer can provide a single model for all of the applications. In some implementations, the central intelligence layer is included within or otherwise implemented by an operating system of the computing device 50 .
- the central intelligence layer can communicate with a central device data layer.
- the central device data layer can be a centralized repository of data for the computing device 50 . As illustrated in FIG. 7 C , the central device data layer can communicate with a number of other components of the computing device, such as, for example, one or more sensors, a context manager, a device state component, and/or additional components. In some implementations, the central device data layer can communicate with each device component using an API (e.g., a private API).
- an API e.g., a private API
- the technology discussed herein makes reference to servers, databases, software applications, and other computer-based systems, as well as actions taken and information sent to and from such systems.
- the inherent flexibility of computer-based systems allows for a great variety of possible configurations, combinations, and divisions of tasks and functionality between and among components.
- processes discussed herein can be implemented using a single device or component or multiple devices or components working in combination.
- Databases and applications can be implemented on a single system or distributed across multiple systems. Distributed components can operate sequentially or in parallel.
Abstract
Provided are computing systems, methods, and platforms for negative sampling in knowledge graphs with improved efficiency. A knowledge graph comprising entities and links between the entities can be obtained. A query computation graph comprising nodes and edges can be generated based on the knowledge graph. The nodes of the query computation graph can include anchor nodes, a root node, and intermediate nodes positioned in paths between the anchor nodes and the root node. A node cut of a query of the query computation graph can be determined and can include at least one node that cuts at least one path between each anchor node and the root node of the query computation graph. Negative samples can be identified by bidirectionally traversing the query computation graph in a first direction from the anchor nodes to the node cut and in a second direction from the root node to the node cut.
Description
- This application claims priority to and the benefit of U.S. Provisional Pat. Application No. 63/319,558, filed Mar. 14, 2022, which is hereby incorporated by reference in its entirety.
- The present disclosure relates generally to knowledge graphs. More particularly, the present disclosure relates to performing negative sampling over knowledge graphs with improved efficiency.
- A knowledge graph is a graph structure that captures knowledge encoded in a form of head-relation-tail triples, where the head and tail are two entities (i.e., nodes) and the relation is an edge between them (e.g., (Paris, CapitalOf, France)). Knowledge graphs form the backbone of many artificial intelligence systems across a wide range of domains, such as recommender systems, question answering, commonsense reasoning, personalized medicine, and drug discovery. In some cases, reasoning over such knowledge graphs includes two types of tasks: (1) single-hop link prediction, where given a head and a relation the goal is to predict one or more tail entities, and (2) multi-hop reasoning, where one needs to predict one or many of the tails of a multi-hop logical query. Finding answers to such a query can involve imputation and prediction of multiple edges across two parallel paths, while also using logical set operations (e.g., intersection, union).
- Aspects and advantages of embodiments of the present disclosure will be set forth in part in the following description, or can be learned from the description, or can be learned through practice of the embodiments.
- One example aspect of the present disclosure is directed to a method for negative sampling with improved efficiency. The method includes obtaining a knowledge graph comprising a plurality of entities and a plurality of links between the plurality of entities, wherein a link from among the plurality of links is between at least two entities from among the plurality of entities and describes a relation between the at least two entities. The method further includes generating, based on the knowledge graph, a query computation graph comprising a plurality of nodes and a plurality of edges, wherein the plurality of nodes comprises one or more anchor nodes, a root node, and one or more intermediate nodes positioned in one or more paths between the one or more anchor nodes and the root node. The method further includes determining a node cut of a query of the query computation graph, wherein the node cut comprises at least one node that cuts at least one path between each anchor node from among the one or more anchor nodes of the query computation graph and the root node of the query computation graph. The method further includes identifying one or more negative samples for the query computation graph by bidirectionally traversing the query computation graph in a first direction from the one or more anchor nodes to the node cut and in a second direction from the root node to the node cut.
- Another example aspect of the present disclosure is directed to a computing system. The computing system includes one or more processors and one or more tangible, non-transitory computer-readable media that collectively store instructions that, when executed by the one or more processors, cause the one or more processors to perform operations. The operations include obtaining a knowledge graph comprising a plurality of entities and a plurality of links between the plurality of entities, wherein a link from among the plurality of links is between at least two entities from among the plurality of entities and describes a relation between the at least two entities. The operations further include generating, based on the knowledge graph, a query computation graph comprising a plurality of nodes and a plurality of edges, wherein the plurality of nodes comprises one or more anchor nodes, a root node, and one or more intermediate nodes positioned in one or more paths between the one or more anchor nodes and the root node. The operations further include determining a node cut of a query of the query computation graph, wherein the node cut comprises at least one node that cuts at least one path between each anchor node from among the one or more anchor nodes of the query computation graph and the root node of the query computation graph. The operations further include identifying one or more negative samples for the query computation graph by bidirectionally traversing the query computation graph in a first direction from the one or more anchor nodes to the node cut and in a second direction from the root node to the node cut.
- Another example aspect of the present disclosure is directed to one or more tangible, non-transitory computer-readable media that collectively store instructions that, when executed by one or more processors, cause the one or more processors to perform operations. The operations include obtaining a knowledge graph comprising a plurality of entities and a plurality of links between the plurality of entities, wherein a link from among the plurality of links is between at least two entities from among the plurality of entities and describes a relation between the at least two entities. The operations further include generating, based on the knowledge graph, a query computation graph comprising a plurality of nodes and a plurality of edges, wherein the plurality of nodes comprises one or more anchor nodes, a root node, and one or more intermediate nodes positioned in one or more paths between the one or more anchor nodes and the root node. The operations further include determining a node cut of a query of the query computation graph, wherein the node cut comprises at least one node that cuts at least one path between each anchor node from among the one or more anchor nodes of the query computation graph and the root node of the query computation graph. The operations further include identifying one or more negative samples for the query computation graph by bidirectionally traversing the query computation graph in a first direction from the one or more anchor nodes to the node cut and in a second direction from the root node to the node cut.
- Other aspects of the present disclosure are directed to various systems, apparatuses, non-transitory computer-readable media, user interfaces, and electronic devices.
- These and other features, aspects, and advantages of various embodiments of the present disclosure will become better understood with reference to the following description and appended claims. The accompanying drawings, which are incorporated in and constitute a part of this specification, illustrate example embodiments of the present disclosure and, together with the description, serve to explain the related principles.
- Detailed discussion of embodiments directed to one of ordinary skill in the art is set forth in the specification, which makes reference to the appended figures.
-
FIG. 1 depicts graphical diagrams of a multi-hop logical query and a corresponding query computation plan and knowledge graph according to example embodiments of the present disclosure. -
FIG. 2 depicts graphical diagrams of query instantiation from a query structure and negative entities sampling according to example embodiments of the present disclosure. -
FIG. 3 depicts graphical diagrams of query logical structures according to example embodiments of the present disclosure. -
FIG. 4 depicts a diagram of a training computing system according to example embodiments of the present disclosure. -
FIG. 5 depicts a sequence diagram of a worker process of a training computing system according to example embodiments of the present disclosure. -
FIG. 6 depicts a flow chart diagram of an example method for negative sampling with improved efficiency according to example embodiments of the present disclosure. -
FIGS. 7A-7C depict block diagrams of an example computing system according to example embodiments of the present disclosure. - Reference numerals that are repeated across plural figures are intended to identify the same features in various implementations.
- Generally, the present disclosure is directed to systems and methods for scalable knowledge graph reasoning or query answering. Advantageously, systems and methods of the present disclosure provide for the first framework for both single-hop and multi-hop reasoning in knowledge graphs at scale.
- Scaling up embedding-based multi-hop knowledge graph reasoning methods is necessary for many real-world artificial intelligence applications. Currently, there are no frameworks that support multi-hop reasoning on massive knowledge graphs. Prior approaches to knowledge graph reasoning have generally been unable to scale efficiently, especially for multi-hop reasoning. For instance, while there have been some scalable frameworks for single-hop knowledge graph completion, such frameworks generally cannot be directly used for multi-hop reasoning due to the more complex nature of the multi-hop reasoning task. Knowledge graph completion can be viewed as a case of a multi-hop reasoning task when the query consists of a single relation (e.g., (France, CapitalOf, ?). For example, multi-hop reasoning requires traversing multiple relations in the knowledge graph, which may span across multiple partitions. Embedding-based methods can solve both single-hop knowledge graph completion and multi-hop reasoning by first computing an embedding for each entity and relation and then using them to form predictions, however, existing scalable knowledge graph embedding frameworks only support single-hop knowledge graph completion and cannot be applied to the more challenging multi-hop reasoning task.
- In contrast, systems and methods of the present disclosure can advantageously provide for multi-hop knowledge graph reasoning at scale. For instance, examples described herein include results processed over an example knowledge graph about 1,500 times larger than the largest knowledge graph previously considered for multi-hop reasoning and improve the worst-case runtime of enumerative search by four orders of magnitude. Furthermore, systems and methods of the present disclosure can advantageously provide a framework for single-hop and multi-hop knowledge graph reasoning at scale.
- For example, the systems and methods of the present disclosure can perform algorithm-system co-optimization for scalability by efficiently generating training examples and operating on a full knowledge graph directly in a shared memory environment with multiple graphics processing units (GPUs). The training examples can be generated with a set of positive entities and a set of negative entities by instantiating a query on a given knowledge graph from a set of query logical structures. The root of the instantiated query can represent a known positive answer entity and negative non-answer entities can be obtained by using a bidirectional rejection sampling approach. Bidirectional rejection sampling can efficiently obtain high-quality negative entities for the instantiated query by identifying the optimal node cut of a query computation plan using dynamic programming, then simultaneously performing forward knowledge graph traversal and backward verification. The nodes in the optimal node cut cache the intermediate results from the forward knowledge graph traversal. For the backward verification, positive candidate entities and negative candidate entities can be proposed, then the knowledge graph can be traversed backwards to the optimal node cut and rejection sampling can be performed based on overlap of the forward set and the backwards set. As a result, the worst-case complexity is reduced by a square root, so a training query, a positive answer entity, and negative non-answer entities can be instantly generated.
- The systems and methods of the present disclosure can operate on a full knowledge graph on a shared memory environment with multiple GPUs while storing embedding parameters in the CPU memory to overcome a limited GPU memory. For instance, an asynchronous scheduler can maximize the throughput of GPU computation by overlapping sampling, asynchronous embedding read and write, neural network feed-forward, and optimizer updates. As a result, an efficient implementation can be obtained that can achieve near linear speed-up with respect to the number of GPUs.
- Example embodiments of the present disclosure provide a number of technical effects and benefits. For instance, more efficient processing at scale and improved utilization of processing resources can decrease computational costs (e.g., energy expenditure, etc.) associated with performing knowledge graph reasoning. For example, embodiments of the present disclosure can be deployed in a single-machine environment with a minimum requirement on the capacity of GPU memory, improve the worst-case runtime of enumerative search, and run more than twice as fast and with less GPU memory usage than existing multi-hop reasoning frameworks.
- With reference now to the Figures, example embodiments of the present disclosure will be discussed in further detail.
- Query embedding methods aim to answer multi-hop logical queries by avoiding explicit knowledge graph traversal and executing the query directly in the embedding space by following a query computation plan, which can be robust against missing links. In multi-hop knowledge graph reasoning, one may need to predict one or many of the tail entities of a multi-hop logical query. Finding answers to the multi-hop logical query may require imputation and prediction of multiple edges across two parallel paths, while also using logical set operations, such as intersection and union. For instance, missing links typically need to be implicitly inferred in the knowledge graph in order to determine the entities that are the answer to a complex multi-hop query.
-
FIG. 1 depicts graphical diagrams of a multi-hop logical query and a corresponding query computation plan and knowledge graph according to example embodiments of the present disclosure. In the example ofFIG. 1 , a multi-hoplogical query 190 may ask, “Who co-authored with Canadian Turing Award winners.” In order to answer the multi-hoplogical query 190, imputation and prediction of multiple edges across two parallel paths while using logical set operations may be used. Finding such answers to the multi-hoplogical query 190 may be achieved by employing aquery computation plan 192. Thequery computation plan 192 can provide a plan for executing the multi-hoplogical query 190. For example, thequery computation plan 192 may include a “Turing Award” entity and a “Canada” entity in two parallel paths, one path following the “win” relation and the other path following the “citizen” relation. In order to determine the entities that are the answer to themulti-hop query 190, missing links may need to be implicitly inferred in theknowledge graph 194. For example, the intersection logical set operation can be used to find the answer to themulti-hop query 190 of “Who co-authored with Canadian Turing Award winners” and the missing links may be implicitly inferred in theknowledge graph 194 in order to obtain the answer. - A knowledge graph G = (V, E, R) can consist of a set of nodes V, edges ε, and relations R. Each edge e ∈ ε represents a triple (vh, r, vt) where r ∈ R and vh, vt ∈ V. Multi-hop reasoning queries can include relation traversals and logical operations, such as conjunction (Λ), disjunction (V), existential quantification (3), and negation (¬), as non-limiting examples. For example, first-order logical queries in disjunctive normal form may be used in some implementations. A first-order logical query q may consist of a non-variable anchor entity set Vq ⊆ V, existentially quantified bound variables V1,..., Vk, and a single target variable V7, which can represent the answer. The disjunctive normal form of a query q can be defined as: q |V? | = V? 3V, ..., Vk : C1 V C2 V...V cn, where each c represents a conjunction of one or more literals e, ci = ei1 /\ ei2 Λ.. Λ eim, and each e represents an atomic formula or its negation, eij = r(va, V) or ¬ r(va, V) or r(V′, V) or ¬r(V′, V), where va ∈ Vq, V ∈ {V?,V1, ..., Vk}, V′ ∈ {V1, ..., Vk}, V ≠ V′, r ∈R.
- A query computation plan (e.g., query computation plan 192) can provide a plan for executing the query (e.g., multi-hop logical query 190). The query computation plan can consist of nodes Vq U {V1, ..., Vk, V?}, where each node corresponds to a set of entities on the knowledge graph. The edges in the query computation plan can represent a logical or relational transformation of this set of entities, such as relation projection, intersection, union, complement, and negation, as non-limiting examples. For relation projection, given a set of entities 5 ⊆ V and relation type r ∈ 2, adjacent entities UVES Ar(v) related to S via r: Ar(v) Ξ {v′ ∈ V: (v, r, v′) ∈ ε} can be computed. For intersection, given a set of entities {S1, S2, . . ., Sn}, their intersection
-
- can be computed. For complement or negation, given a set of entities S ⊆ V, its complement
S Ξ V\S can be computed. - A knowledge graph can be traversed using a query computation plan. For example, assuming no noise and no missing relations in the knowledge graph, a logical query (e.g., a first-order logical query) can be answered by traversing the edges of the knowledge graph. For a valid query, the query computation plan may be a tree structure, where the anchor entity set, Vq, are the leaves and the target variable, V?, is the single root, representing the set of answer entities. Following the query computation plan, starting with the anchor entities, the knowledge graph can be traversed and logical operators can be executed towards the root node. The answers
-
- to the query q can be stored in the root node after traversing the knowledge graph. In such an example, there may be exponential computational complexity with respect to the number of hops and noisy or missing relations in the knowledge graph may not be handled, which are common in current applications of knowledge graphs.
- Embedding-based reasoning methods avoid explicit knowledge graph traversal. Instead, embedding-based reasoning methods start with the embeddings of anchored entities and then apply a sequence of neural logical operators according to the query computation plan. As a result, the embedding of the query where each embedding-based logical operator can take the current input embedding and transform it into a new output embedding can be obtained. Then the logical operators can be combined according to the query structure. The answers to the query q may be the entities v that are embedded close to the final query embedding. The distance can be measured by a pre-defined function Dist (fθ(q), fθ(v)), where fθ(q) and fθ(v) represent the query and the entity embedding, respectively. The distance function (Dist) may be tailored to different embedding spaces and model design fθ.
- In order to perform logical reasoning in the embedding space, methods can design a projection operator -T and intersection operator J. P can represent a mapping from a set of entities (represented by an embedding) to another set of entities (also represented by an embedding) with one relation (i.e., P : ℝd × R → ℝd), assuming the embedding dimension is d. The J can take as input multiple embeddings and output the embedding that represents the intersected set of entities: J : ℝd X ...× ℝd → ℝd. Different models may have different instantiations of these two operators.
- During training, a data sampler D can be given, where each sample in D is a tuple
-
- which represents a query q, the query’s answer entities
-
- and the negative samples
-
- The contrastive loss equation (1) is designed to minimize the distance between the query embedding and the query embedding’s answers
-
- while maximizing the distance between the query embedding and the negative samples
-
-
- where γ is a hyperparameter that defines the margin and σ is the sigmoid function. (1) This is referred to herein as the contrastive loss equation (1).
- Identifying or computing
-
- involve complex first-order logical operations due to the multi-hop structure in reasoning, which are more expensive than sampling in classical, single-link knowledge graph completion tasks, and is therefore a bottleneck for scaling-up. The systems and methods of the present disclosure can scale up single-hop and multi-hop knowledge graph reasoning methods with an efficient sampling algorithm and parallel training for a given contrastive loss.
- Sampling training data for multi-hop reasoning is more complicated than in link prediction, where sampling the training data (head-relation-tail triple) can be quickly performed by dictionary lookup. For instance, sampling training data for multi-hop reasoning may involve generating queries q by instantiating query structures and performing knowledge graph traversal to find answers
-
- and negative non-answers
-
- which can be computationally expensive. The systems and methods of the present disclosure can provide an efficient technique to sample training data for contrastive learning for multi-hop reasoning. In some implementations, during inference, there may be a pre-generated test set or a user can input a test query of interest.
- A knowledge graph with entities or nodes and links or edges between the entities that describe the relation between the entities can be obtained. The knowledge graph may be a heterogeneous graph. A query structure (also referred to as a query computation graph or query computation plan) can be generated based on the knowledge graph. The query structure can contain nodes and edges, and the nodes can include anchor nodes, a root node, and intermediate nodes in the paths between the anchor nodes and the root node, such as in implementations where the query structure is a tree structure.
- A node cut of the query structure can be determined. The node cut can correspond to a query of the query structure. The node cut can include at least one node that cuts at least one path between each anchor node and the root node of the query structure. In order to efficiently identify negative samples for the query structure, bidirectional rejection sampling can be used to bidirectionally traverse the query structure in a first direction from the anchor nodes to the node cut and in a second direction from the root node to the node cut. During the traversal in the first direction from the anchor nodes to the node cut, the intermediate nodes obtained while traversing can be cached.
-
FIG. 2 depicts graphical diagrams of query instantiation from a query structure and negative entities sampling according to example embodiments of the present disclosure. In the example ofFIG. 2 , queries can be instantiated using query structures from root to leaves. The entity in the root can become a positive answer to the instantiated query. For negative entities, bidirectional rejection sampling can be performed, which may have a square root computation complexity compared to the traversal-based method. - In order to generate a training example with a set of positive and negative entities, first, a query is instantiated 202 on a given knowledge graph from a set of query structures, such as
query structure 204. The root of the instantiatedquery 202 can represent a known positive answer entity (e.g., one known positive answer: Radford Neal in the instantiated query 202). Negative non-answer entities for the instantiatedquery 202 can be obtained by using a bidirectional rejection sampling approach. The optimal node cut (e.g., the node after the intersection in the forwardknowledge graph traversal 206 of the bidirectional rejection sampling) of the query computation plan can be identified by using dynamic programming. Forwardknowledge graph traversal 206 andbackward verification 208 can then be performed simultaneously. The nodes in the optimal node cut can cache the intermediate results from the forwardknowledge graph traversal 206. For thebackward verification 208, positive candidate entities and negative candidate entities can be proposed, the knowledge graph can be traversed backwards to the optimal node cut, and rejection sampling can be performed based on overlap between the forward traversal set and the backward traversal set. As a result, the worst-case complexity is reduced by asquare root 210, so a training query, a positive answer entity, and negative non-answer entities can be instantly generated. The overlap of the cached intermediate nodes and the nodes traversed while traversing in the second direction from the root node to the node cut can be determined, where a node is a negative non-answer when there is no overlap between the cached intermediate nodes and the traversed nodes. In some implementations, the overlap between negative candidate entities and the cached intermediate nodes can be determined. - A node cut cq of a query q can be a set of nodes in the query computation plan, such that every path between anchor node (leaf) and answer node (root) contains one node in cq. By definition, a node cut is minimal, meaning that no subset of cq can be a node cut. For example, in the example of
FIG. 2 , given a two-hop query, “Who co-authored papers with Canadian Turing Award winners,” the node after the intersection operation (e.g., the “Bengio” node in the instantiated query 202) can be set as the single node in the node cut. Then, the set of “Canadian Turing Award winners” can be obtained by forwardknowledge graph traversal 206 caching the intermediate results (e.g., “Bengio”). Overall, the process can take O(C) computation or memory cost, where C is the degree of the knowledge graph. Given a candidate negative entity v, the cost can be O(C) to verify whether the set of co-authors of v overlaps with the cached entities in the node cut. For example, a constant number of candidate negative entities can be used, resulting in an overall computation cost of O(C), which is a reduction of square root from O(C2) using exhaustive traversal. - The computation cost for any given node cut cq can be calculated. An efficient algorithm can be used to then find the optimal node cut, which may be the node cut with the lowest cost in bidirectional search. Computation costs for the node cuts can be based on paths between each anchor node and the root node. To calculate the computation costs, a maximum number of relation projections in the paths between each anchor node and the root node, a length of a path from each anchor node to the anchor nodes where the length of the path is a number of relation projections on the path, and the optimal costs of resolving the paths between each anchor node and the root node can be determined.
- Given a reasoning path P(v
a ,V? ) = [v0 = va, v1,..., vt = V?] in the query computation plan that starts from an anchor node (i.e., leaf) va ∈ Vq and ends at the answer node (i.e., root) V?, for a node cut cq, by definition there exists a unique node vi ∈ cq ∩ P(va ,V? ) Then, the worst-case computation or memory cost for negative sampling for reasoning path PC(va ,V? ) can be estimated as cost (cq, P(va ,V? )) = max{Ci,Ct-i} (i.e., the maximum cost of forward traversal or backward verification). The optimal scheduling can be recast as -
- This is referred to herein as the optimization problem (2).
- The optimization problem (2) can be solved with dynamic programming, for instance when the query computation plan is a tree. The relation projection operation can enlarge the current set of entities by a factor of C, which is the maximum node degree, in the worst case, so the total cost grows exponentially with the number of relation projection operations in a reasoning path. For the intersection and union operations, if the set of entities is a sorted list, then intersection or union of the two sets takes linear time with respect to the number of entities in both sets, so it is not a limiting factor in the overall computation cost if a constant number of sets is merged together. For the negation and complement operations, the computation cost of a single set complement operation is O(|V|) (i.e., the total number of entities in the knowledge graph). The complement operation can be delayed to the next step on the query computation plan (i.e., perform complement and union or intersection simultaneously), which reduces the complexity from O(V) to that of an intersection operation. For example, in (¬a) Λ b, instead of first finding the complement of a (of complexity |O(V)|) and then doing Λ (of complexity O|V - al + |b]), the set difference b - a (of complexity O|a| + |b|) can be done. The focus is the maximum number of relation projections in any reasoning path (i.e., a path that connects a leaf/anchor entity v ∈ Vq and the root/answer entity V?).
- Three functions can be defined, u(v), s(v), o(v), which represent the number of relation projections from v to the root V?, the maximum length of path from v to any anchors where the length is measured by the number of relation projections on that path, and the optimal cost of resolving all the reasoning paths that include v in the best plan, respectively. The dependency of the three functions can be derived recursively, the dynamic program can be solved in a linear time with respect to |q|, and the node cut can be constructed using the function o(·).
- For the dynamic programming, the parent of node v can be denoted p(v) and the set of children nodes can be denoted ch(v). When v has only one child node, then ch(v) can be overloaded to denote that specific child. The recursion can be taken as:
-
-
-
- IsRel(v → p(v)) returns 1 if the edge between v and p(v) represents a relation projection and 0 otherwise; NotNeg(ch(v) → v) returns 1 if the edge between ch(v) and v is not negation and 0 otherwise.
- After solving the dynamic programming recursion, the node cut can be constructed from solution o(·) in a top-down direction: If for any node v there is maxz∈ch(v)o(Z) larger than max{u(v), s(v)}, then add v to the node cut; otherwise, do the check recursively for z ∈ ch(v).
-
FIG. 3 depicts graphical diagrams of query logical structures according to example embodiments of the present disclosure. In the example ofFIG. 3 , the optimal node cuts of the example query structures and the anchor entities Vq in the example query structures are represented, showing that different query structures can have different optimal node cuts. The example query structures and the optimal node cuts of the example query structures can be used by the bidirectional rejection sampling of the present disclosure. - A query logical structure (e.g., example query logical structure of
FIG. 3 ) can specify the backbone of a query q, including the types of operation (e.g., intersection, relation projection, negation, and union, as non-limiting examples) and the structure of the query. The query logical structure can be viewed as an abstraction of the query computation plan, where anchor nodes and relation types may not be grounded. Instantiating a query is a way to construct a concrete query given the logical structure of the query. Instantiating a query structure involves specifying a relation r ∈ R for each edge in the structure and the anchor entities Vq. - Current methods to instantiate a query include first grounding the anchor entities by randomly sampling entities in the knowledge graph and then randomly selecting relations r ∈ R for all the relation projection edges. In most cases, randomly generated queries do not have answers in the knowledge graph because sampled entities may not have relations of predetermined types and intersections of random entities will almost always be empty, therefore such samples are rejected and the sampling process is restarted, which leads to high computation costs.
- The systems and methods of the present disclosure allow for instantiating a query logical structure by using reverse directional sampling to construct queries from a knowledge graph, which reduces computation cost compared to current methods. For example, first the root node (i.e., the answer node) of the query structure may be grounded, then the query structure can be processed towards the anchor nodes. The overall instantiation process corresponds to a depth-first search where at each step a node/edge on the query structure can be grounded with an entity/relation from the knowledge graph.
- Reverse directional sampling can use depth-first search over the query structure from the root (i.e., the answer node) to the leaves (i.e., the anchor nodes). During the depth-first search, each node on the query structure can be grounded to an entity on the knowledge graph and an edge of the query structure can be grounded to a relation on the knowledge graph associated with the previously grounded entity. Reverse directional sampling can return the instantiated query q, the anchor entities Vq, and a single positive answer
-
- which is the instantiated entity at the root.
- For example, in the instantiated
query 202 example ofFIG. 2 , the query structure root is “Neal,” which can be a positive answer. During depth-first search, instantiation starts at the root node “Neal.” An entity from the knowledge graph can be randomly sampled, such as the “Neal” entity. Then, following the query structure, the edge that points to the root “Neal” in the query structure can be grounded (e.g., “Co-author”) and a relation type from the knowledge graph that points to the entity “Neal” can be sampled. Then, the next node which has the relation “Co-author” with “Neal” (e.g., “Bengio”) can be grounded to an entity on the knowledge graph. Because the edge can be a logical operation of intersection, the next node can be directly grounded with the same entity (e.g., “Bengio”) and another relation on the knowledge graph that relates to “Bengio” can be grounded (e.g., “Win”), until finally reaching the anchor entity (leaf) by sampling an entity on the knowledge graph that has the relation “Win” with “Bengio” (e.g., “Turing Award”). The instantiated query, the anchor entities (the leaves “Turing Award” and “Canada”), and a positive answer (the root “Neal”) can be returned. - Reverse directional sampling can obtain valid queries with a non-empty answer set and the overall complexity can be O(C|q|), which is the same as the complexity of depth-first search, where |q| indicates the maximum depth of a path from the root to the leaves in the query structure, and C is the maximum degree of entities in the knowledge graph.
- After instantiating the query structure by grounding the nodes and edges of the query structure, the tuple (q, Vq, {aq}) can be obtained as a positive sample. The negative non-answer entities
-
- then be determined in order to optimize the contrastive loss equation (1). A single answer entity can be sufficient in each step of stochastic training, while
-
- in the contrastive loss equation (1) may be thousands for negative samples in the contrastive learning objective. The set of negative non-answer entities,
-
- can be determined by using bidirectional rejection sampling.
- Current methods may sample negative entities (i.e., non-answers) at random from a knowledge graph, independent of the query q. A valid query may have many answer entities in the order of O(Clql), so many of the sampled negatives are actually answers to the query, which can lead to noisy training data that can confuse the model. An alternative method may be to execute the query q and perform knowledge graph traversal to obtain all the answers
-
- and then obtain negative samples
-
- by sampling from
-
- however,
-
- is still in the order of O(Clql), even with re-ordering of the relation projection operations to get better scheduling. Such exhaustive traversal may be prohibitive for negative sampling on large knowledge graphs.
- The systems and methods of the present disclosure can instead perform bidirectional sampling in order to efficiently obtain negative non-answer entities
-
- large knowledge graphs. Rejection sampling can be used to locate a subset of negative entities efficiently, as
-
- does not need to contain all of the non-answer entities during stochastic training. Starting with a random proposal v ∈ V, it should be determined whether
-
- rather than to enumerate the entire
-
- A node cut can be obtained on the query computation plan (i.e., a subset of nodes that cut all the paths between each leaf node and the root node), then bidirectional search can be performed. The traversal of the query computation plan can be started from the leaves (i.e., the anchor nodes) to the node cut, and the entities obtained in traversal can be cached (e.g., forward caching the intermediate results from the forward knowledge graph traversal 206). Then, negative entities can be sampled, traversal from the root to the node cut can be performed, and whether the sample negative entities are true negatives can be verified by checking the overlap of the cached entities and the traversed set (e.g., backward verification 208).
- The full knowledge graph can be operated on directly in a shared memory environment with multiple GPUs, while storing embedding parameters in the CPU memory to overcome the limited GPU memory. The usage of CPU and GPU can be combined, where the dense matrix computations can be deployed on GPUs and the sampling operations can be deployed on CPUs. As a result, the potential drawbacks of graph partitioning for multi-hop reasoning in current knowledge graph embedding systems can be avoided. An asynchronous scheduler can be used to maximize the throughput of GPU computation by overlapping sampling, asynchronous embedding read/write, neural network feed-forward, and optimizer updates. As a result, an efficient implementation can be obtained that can achieve near linear speed-up with respect to the number of GPUs.
- Most of the knowledge graph embedding methods would maintain an embedding matrix θE ∈ ℝ|v|×d, where d is the embedding dimension, which can typically be 512 or larger. For a large knowledge graph with more than millions of entities, the embeddings θE cannot be stored in GPUs because most GPUs would have a memory of 16 GB or less. Instead, the embedding matrix can be put on shared CPU memory, while putting a copy of other parameters θD = θ\θE, for example neural logical operators, in each individual GPU.
-
FIG. 4 depicts a diagram of a training computing system according to example embodiments of the present disclosure. One worker process can be launched per GPU device, where w denotes an index of a worker process. Worker w gets the shared access to θE and local GPU copy of dense parameters θD. Each worker w repeats the following steps until training stops: - 1. Collect a mini-batch of training samples {Di}w from Dw, which is the sampler.
- 2. Load relevant entity embeddings from CPU to GPU.
- 3. Compute gradients locally and perform gradient AllReduce using
-
- Update local copy θD.
- 4. Update shared θE asynchronously with
-
- In the shared memory with multiple GPU scenario, the heavy CPU/GPU memory read/write with θE is necessary for every round of stochastic gradient update, which significantly lowers the FLOPS (Floating Point Operations Per Second) on GPU devices if the above steps are executed in a serialized manner. Instead, an asynchronous pipeline design can be used.
- The different storage location of parameters also brings different read/update mechanisms. For the embedding parameters θE, because only a small portion may be accessed during each iteration in stochastic training, the asynchronous update on the shared CPU memory can still result in a convergent behavior. Unlike link prediction models, most multi-hop reasoning models are additionally equipped with dense neural logical operators, which can be used in all batches and iterations. In order to minimize the loss of performance of multi-GPU training of these dense parameters, θD can be synchronously updated with AllReduce operations that are available in a multi-GPU environment with the NVIDIA Collective Communication Library (NCCL).
-
FIG. 5 depicts a sequence diagram of a worker process of a training computing system according to example embodiments of the present disclosure.FIG. 5 shows the overlapping sampling, asynchronous embedding read/write, neural network feed-forward, and optimizer updates of the asynchronous scheduler that can be used to maximize the throughput of GPU computation. - An asynchronous mechanism for pipelining the stages in each stochastic gradient update can be employed. The stages can be virtually categorized into four kinds of meta-threads, where each kind of meta-thread may consist of multiple CPU threads or CUDA streams. These meta-threads can run concurrently, with possible synchronization events for pending resources.
- In the example of
FIG. 5 , one meta-thread example issampler 502, which can be a multi-thread sampler. Each worker w can maintain one sampler Dw that has access to the shared knowledge graph. The sampler can container a thread pool for sampling queries and the corresponding positive/negative answers in parallel. The data sampler can work concurrently with the other meta-threads (e.g., embedding read/write 504,neural network 506, sparse optimizer read/write 508). The pre-fetching mechanism can obtain samples for the next mini-batch while training happens using current batch on other threads, so if the sampler is efficient enough, then the runtime can almost be ignored. - In the example of
FIG. 5 , one meta-thread example is an embedding read/write 504, such as a sparse embedding read/write. For the embedding matrix θE, a single background thread can be created with a CUDA stream for embedding read and write. In particular, when loading the embedding of some entities into GPU, the background thread may first load that into a pinned memory area, then the CUDA asynchronous stream can perform pinned memory to GPU memory copy. This read operator may be non-blocking and may not be synchronized until the CUDA operator in the main CUDA stream asks for it. The write operation can work similarly but in the reverse direction. In some implementations, there may be multiple background threads. - In the example of
FIG. 5 , one meta-thread example is aneural network 506, such as neural network feed-forward. The feed-forward model fθ can start when training data -
- is ready and the embedding of the anchor entities Vq is fetched into GPU. The embeddings of
-
- can be fetched as late as when the loss function is computed in order to overlap the computation and memory copy. After obtaining the local gradients
-
- the asynchronous update for θE can be invoked first without blocking, and at the same time the AllReduce operation can start, followed by the dense parameter update of θD on the GPU.
- In the example of
FIG. 5 , one meta-thread example is a sparse optimizer read/write 508, such as a sparse optimizer with asynchronous read/write. Unlike with θD, only a small set of rows of θE may be involved in each stochastic update. Thus, -
- and their gradients may be tracked (i.e., the embeddings that are relevant to positive entities, negative entities, and anchor entities. After the back-propagation is finished,
-
- can be scattered into a single contiguous memory, due to the potential overlap among the sets
-
- The first and second order moments of gradients may also be in CPU and treated in the same manner as θE, and thus may have the same asynchronous read/write behavior as discussed above. When a set of embeddings can be retrieved from θE, the optimizer can also start to pre-fetch the corresponding first/second order moments in a different background thread.
- Additional optimization can further speed up training. For example, although with the asynchronous design the embedding read/write can overlap with GPU computation, the size of the memory exchange should be small. The negative answers can be shared among the queries in a mini-batch. Each mini-batch data can be formatted as
-
- where N ⊂ V are the shared negative answers for all queries. Mask ∈ {0,1}M×|N| is an indicator matrix. Maski,j specifies whether the j-th entry in N is a negative sample for qi. This sharing also favors the bidirectional rejection sampler, as it is the sample-and-check process, with the adaptation that all the queries in the same mini-batch share the support of negative sampling proposal.
- The computation among worker processes can be balanced since there is the synchronized gradient update for θD at each step. For example, with the query tree structures sampled in each mini-batch, some of the simple structures like 1-hop question can be computed very fast, which others, such as conjunctions with negations, need not only multi-hop computation, but also involve dense neural network calculation. In order to balance the workload, the sampler Dw of each worker w can sample queries of the same structure in each mini-batch by synchronizing the random seed at the beginning, while not making the actual instantiated query the same.
-
FIG. 6 depicts a flow chart diagram of anexample method 600 for negative sampling with improved efficiency according to example embodiments of the present disclosure. - At 602, a computing system obtains a knowledge graph comprising a plurality of entities and a plurality of links between the plurality of entities, wherein a link from among the plurality of links is between at least two entities from among the plurality of entities and describes a relation between the at least two entities. For example, the knowledge graph can be a heterogeneous graph.
- At 604, the computing system generates, based on the knowledge graph, a query computation graph comprising a plurality of nodes and a plurality of edges, wherein the plurality of nodes comprises one or more anchor nodes, a root node, and one or more intermediate nodes positioned in one or more paths between the one or more anchor nodes and the root node. For example, the query computation graph can be a plan for executing a query, and the query can be executed in an embedding space. Each node from among the plurality of nodes of the query computation graph can correspond to a set of entities on the knowledge graph, and the plurality of edges of the query computation graph can represent a logical relational transformation of the set of entities on the knowledge graph, wherein the logical relational transformation of the set of entities on the knowledge graph can include one or more of relation projection, intersection, union, complement, and negation. In some implementations, a depth-first search over the query computation graph from the root node of the query computation graph to the one or more anchor nodes of the query computation graph can be performed, wherein each node of the query computation graph is grounded to an entity on the knowledge graph and an edge of the query computation graph is grounded to a relation on the knowledge graph associated with a previously grounded entity on the knowledge graph. The root node of the query computation graph may be a known positive answer to the query.
- At 606, the computing system determines a node cut of a query of the query computation graph, wherein the node cut comprises at least one node that cuts at least one path between each anchor node from among the one or more anchor nodes of the query computation graph and the root node of the query computation graph. For example, the query can be a first-order logical query. In some implementations, the computing system can calculate computation costs for one or more node cuts based on paths between each anchor node from among the one or more anchor nodes of the query computation graph and the root node of the query computation graph, and the node cut can be one of the node cuts with a lowest computation cost. In some implementations, the computation costs for the one or more node cuts can include determining a maximum number of relation projections in the paths between each anchor node from among the one or more anchor nodes of the query computation graph and the root node of the query computation graph, determining a length of a path from each anchor node to the anchor nodes where the length of the path is the number of relation projections on the path, and determining optimal costs of resolving the paths between each anchor node from among the one or more anchor nodes of the query computation graph and the root node of the query computation graph.
- At 608, the computing system identifies one or more negative samples for the query computation graph by bidirectionally traversing the query computation graph in a first direction from the one or more anchor nodes to the node cut and in a second direction from the root node to the node cut. In some implementations, traversing the query computation graph in the first direction from the one or more anchor nodes to the node cut can include caching the one or more intermediate nodes, wherein the intermediate nodes are obtained while traversing the query computation graph in the first direction, comparing overlap of the cached one or more intermediate nodes and a set of nodes traversed while traversing the query computation graph in the second direction from the root node to the node cut, and determining, based on the overlap, that a node from among the set of nodes traversed is a negative non-answer to the query, wherein a negative sample comprises the negative non-answer to the query. In some implementations, traversing the query computation graph can include obtaining, from the query computation graph, a candidate negative node and determining whether the candidate negative node overlaps with the cached one or more intermediate nodes. For example, a node from among the set of nodes traversed can be a negative non-answer to the query if there is no overlap between the cached one or more intermediate nodes and the set of nodes traversed while traversing the query computation graph in the second direction from the root node to the node cut. In some implementations, bidirectionally traversing the query computation graph in the first direction from the one or more anchor nodes to the node cut and in the second direction from the root node to the node cut can include randomly sampling one or more negative candidate nodes in the second direction.
-
FIG. 7A depicts a block diagram of anexample computing system 100 that performs negative sampling with improved efficiency according to example embodiments of the present disclosure. Thecomputing system 100 includes auser computing device 102, aserver computing system 130, and atraining computing system 150 that are communicatively coupled over anetwork 180. - The
user computing device 102 can be any type of computing device, such as, for example, a personal computing device (e.g., laptop or desktop), a mobile computing device (e.g., smartphone or tablet), a gaming console or controller, a wearable computing device, an embedded computing device, or any other type of computing device. - The
user computing device 102 includes one ormore processors 112 and amemory 114. The one ormore processors 112 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, an FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected. Thememory 114 can include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof. Thememory 114 can storedata 116 andinstructions 118 which are executed by theprocessor 112 to cause theuser computing device 102 to perform operations. - In some implementations, the
user computing device 102 can store or include one or more knowledgegraph reasoning models 120. For example, the knowledgegraph reasoning models 120 can be or can otherwise include various machine-learned models such as neural networks (e.g., deep neural networks) or other types of machine-learned models, including non-linear models and/or linear models. Neural networks can include feed-forward neural networks, recurrent neural networks (e.g., long short-term memory recurrent neural networks), convolutional neural networks or other forms of neural networks. Some example machine-learned models can leverage an attention mechanism such as self-attention. For example, some example machine-learned models can include multi-headed self-attention models (e.g., transformer models). - In some implementations, the one or more knowledge
graph reasoning models 120 can be received from theserver computing system 130 overnetwork 180, stored in the usercomputing device memory 114, and then used or otherwise implemented by the one ormore processors 112. In some implementations, theuser computing device 102 can implement multiple parallel instances of a single knowledge graph reasoning model 120 (e.g., to perform parallel knowledge graph reasoning across multiple instances). - Additionally or alternatively, one or more knowledge
graph reasoning models 140 can be included in or otherwise stored and implemented by theserver computing system 130 that communicates with theuser computing device 102 according to a client-server relationship. For example, the knowledgegraph reasoning models 140 can be implemented by theserver computing system 130 as a portion of a web service (e.g., a knowledge graph reasoning service). Thus, one or more knowledgegraph reasoning models 120 can be stored and implemented at theuser computing device 102 and/or one or more knowledgegraph reasoning models 140 can be stored and implemented at theserver computing system 130. - The
user computing device 102 can also include one or moreuser input components 122 that receives user input. For example, theuser input component 122 can be a touch-sensitive component (e.g., a touch-sensitive display screen or a touch pad) that is sensitive to the touch of a user input object (e.g., a finger or a stylus). The touch-sensitive component can serve to implement a virtual keyboard. Other example user input components include a microphone, a traditional keyboard, or other means by which a user can provide user input. - The
server computing system 130 includes one ormore processors 132 and amemory 134. The one ormore processors 132 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, an FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected. Thememory 134 can include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof. Thememory 134 can storedata 136 andinstructions 138 which are executed by theprocessor 132 to cause theserver computing system 130 to perform operations. - In some implementations, the
server computing system 130 includes or is otherwise implemented by one or more server computing devices. In instances in which theserver computing system 130 includes plural server computing devices, such server computing devices can operate according to sequential computing architectures, parallel computing architectures, or some combination thereof. - As described above, the
server computing system 130 can store or otherwise include one or more knowledgegraph reasoning models 140. For example, the knowledgegraph reasoning models 140 can be or can otherwise include various machine-learned models. Example machine-learned models include neural networks or other multi-layer non-linear models. Example neural networks include feed forward neural networks, deep neural networks, recurrent neural networks, and convolutional neural networks. Some example machine-learned models can leverage an attention mechanism such as self-attention. For example, some example machine-learned models can include multi-headed self-attention models (e.g., transformer models). - The
user computing device 102 and/or theserver computing system 130 can train the knowledgegraph reasoning models 120 and/or 140 via interaction with thetraining computing system 150 that is communicatively coupled over thenetwork 180. Thetraining computing system 150 can be separate from theserver computing system 130 or can be a portion of theserver computing system 130. - The
training computing system 150 includes one ormore processors 152 and amemory 154. The one ormore processors 152 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, an FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected. Thememory 154 can include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof. Thememory 154 can storedata 156 andinstructions 158 which are executed by theprocessor 152 to cause thetraining computing system 150 to perform operations. In some implementations, thetraining computing system 150 includes or is otherwise implemented by one or more server computing devices. - The
training computing system 150 can include amodel trainer 160 that trains the knowledgegraph reasoning models 120 and/or 140 stored at theuser computing device 102 and/or theserver computing system 130 using various training or learning techniques, such as, for example, backwards propagation of errors. For example, a loss function can be backpropagated through the model(s) to update one or more parameters of the model(s) (e.g., based on a gradient of the loss function). Various loss functions can be used such as mean squared error, likelihood loss, cross entropy loss, hinge loss, and/or various other loss functions. Gradient descent techniques can be used to iteratively update the parameters over a number of training iterations. - In some implementations, performing backwards propagation of errors can include performing truncated backpropagation through time. The
model trainer 160 can perform a number of generalization techniques (e.g., weight decays, dropouts, etc.) to improve the generalization capability of the models being trained. - In particular, the
model trainer 160 can train the knowledgegraph reasoning models 120 and/or 140 based on a set oftraining data 162. - In some implementations, if the user has provided consent, the training examples can be provided by the
user computing device 102. Thus, in such implementations, the knowledgegraph reasoning model 120 provided to theuser computing device 102 can be trained by thetraining computing system 150 on user-specific data received from theuser computing device 102. In some instances, this process can be referred to as personalizing the model. - The
model trainer 160 includes computer logic utilized to provide desired functionality. Themodel trainer 160 can be implemented in hardware, firmware, and/or software controlling a general purpose processor. For example, in some implementations, themodel trainer 160 includes program files stored on a storage device, loaded into a memory and executed by one or more processors. In other implementations, themodel trainer 160 includes one or more sets of computer-executable instructions that are stored in a tangible computer-readable storage medium such as RAM, hard disk, or optical or magnetic media. - The
network 180 can be any type of communications network, such as a local area network (e.g., intranet), wide area network (e.g., Internet), or some combination thereof and can include any number of wired or wireless links. In general, communication over thenetwork 180 can be carried via any type of wired and/or wireless connection, using a wide variety of communication protocols (e.g., TCP/IP, HTTP, SMTP, FTP), encodings or formats (e.g., HTML, XML), and/or protection schemes (e.g., VPN, secure HTTP, SSL). - The machine-learned models described in this specification may be used in a variety of tasks, applications, and/or use cases.
- In some implementations, the input to the machine-learned model(s) of the present disclosure can be image data. The machine-learned model(s) can process the image data to generate an output. As an example, the machine-learned model(s) can process the image data to generate an image recognition output (e.g., a recognition of the image data, a latent embedding of the image data, an encoded representation of the image data, a hash of the image data, etc.). As another example, the machine-learned model(s) can process the image data to generate an image segmentation output. As another example, the machine-learned model(s) can process the image data to generate an image classification output. As another example, the machine-learned model(s) can process the image data to generate an image data modification output (e.g., an alteration of the image data, etc.). As another example, the machine-learned model(s) can process the image data to generate an encoded image data output (e.g., an encoded and/or compressed representation of the image data, etc.). As another example, the machine-learned model(s) can process the image data to generate an upscaled image data output. As another example, the machine-learned model(s) can process the image data to generate a prediction output.
- In some implementations, the input to the machine-learned model(s) of the present disclosure can be text or natural language data. The machine-learned model(s) can process the text or natural language data to generate an output. As an example, the machine-learned model(s) can process the natural language data to generate a language encoding output. As another example, the machine-learned model(s) can process the text or natural language data to generate a latent text embedding output. As another example, the machine-learned model(s) can process the text or natural language data to generate a translation output. As another example, the machine-learned model(s) can process the text or natural language data to generate a classification output. As another example, the machine-learned model(s) can process the text or natural language data to generate a textual segmentation output. As another example, the machine-learned model(s) can process the text or natural language data to generate a semantic intent output. As another example, the machine-learned model(s) can process the text or natural language data to generate an upscaled text or natural language output (e.g., text or natural language data that is higher quality than the input text or natural language, etc.). As another example, the machine-learned model(s) can process the text or natural language data to generate a prediction output.
- In some implementations, the input to the machine-learned model(s) of the present disclosure can be speech data. The machine-learned model(s) can process the speech data to generate an output. As an example, the machine-learned model(s) can process the speech data to generate a speech recognition output. As another example, the machine-learned model(s) can process the speech data to generate a speech translation output. As another example, the machine-learned model(s) can process the speech data to generate a latent embedding output. As another example, the machine-learned model(s) can process the speech data to generate an encoded speech output (e.g., an encoded and/or compressed representation of the speech data, etc.). As another example, the machine-learned model(s) can process the speech data to generate an upscaled speech output (e.g., speech data that is higher quality than the input speech data, etc.). As another example, the machine-learned model(s) can process the speech data to generate a textual representation output (e.g., a textual representation of the input speech data, etc.). As another example, the machine-learned model(s) can process the speech data to generate a prediction output.
- In some implementations, the input to the machine-learned model(s) of the present disclosure can be latent encoding data (e.g., a latent space representation of an input, etc.). The machine-learned model(s) can process the latent encoding data to generate an output. As an example, the machine-learned model(s) can process the latent encoding data to generate a recognition output. As another example, the machine-learned model(s) can process the latent encoding data to generate a reconstruction output. As another example, the machine-learned model(s) can process the latent encoding data to generate a search output. As another example, the machine-learned model(s) can process the latent encoding data to generate a reclustering output. As another example, the machine-learned model(s) can process the latent encoding data to generate a prediction output.
- In some implementations, the input to the machine-learned model(s) of the present disclosure can be statistical data. Statistical data can be, represent, or otherwise include data computed and/or calculated from some other data source. The machine-learned model(s) can process the statistical data to generate an output. As an example, the machine-learned model(s) can process the statistical data to generate a recognition output. As another example, the machine-learned model(s) can process the statistical data to generate a prediction output. As another example, the machine-learned model(s) can process the statistical data to generate a classification output. As another example, the machine-learned model(s) can process the statistical data to generate a segmentation output. As another example, the machine-learned model(s) can process the statistical data to generate a visualization output. As another example, the machine-learned model(s) can process the statistical data to generate a diagnostic output.
- In some implementations, the input to the machine-learned model(s) of the present disclosure can be sensor data. The machine-learned model(s) can process the sensor data to generate an output. As an example, the machine-learned model(s) can process the sensor data to generate a recognition output. As another example, the machine-learned model(s) can process the sensor data to generate a prediction output. As another example, the machine-learned model(s) can process the sensor data to generate a classification output. As another example, the machine-learned model(s) can process the sensor data to generate a segmentation output. As another example, the machine-learned model(s) can process the sensor data to generate a visualization output. As another example, the machine-learned model(s) can process the sensor data to generate a diagnostic output. As another example, the machine-learned model(s) can process the sensor data to generate a detection output.
- In some cases, the machine-learned model(s) can be configured to perform a task that includes encoding input data for reliable and/or efficient transmission or storage (and/or corresponding decoding). For example, the task may be an audio compression task. The input may include audio data and the output may comprise compressed audio data. In another example, the input includes visual data (e.g. one or more images or videos), the output comprises compressed visual data, and the task is a visual data compression task. In another example, the task may comprise generating an embedding for input data (e.g. input audio or visual data).
- In some cases, the input includes visual data and the task is a computer vision task. In some cases, the input includes pixel data for one or more images and the task is an image processing task. For example, the image processing task can be image classification, where the output is a set of scores, each score corresponding to a different object class and representing the likelihood that the one or more images depict an object belonging to the object class. The image processing task may be object detection, where the image processing output identifies one or more regions in the one or more images and, for each region, a likelihood that region depicts an object of interest. As another example, the image processing task can be image segmentation, where the image processing output defines, for each pixel in the one or more images, a respective likelihood for each category in a predetermined set of categories. For example, the set of categories can be foreground and background. As another example, the set of categories can be object classes. As another example, the image processing task can be depth estimation, where the image processing output defines, for each pixel in the one or more images, a respective depth value. As another example, the image processing task can be motion estimation, where the network input includes multiple images, and the image processing output defines, for each pixel of one of the input images, a motion of the scene depicted at the pixel between the images in the network input.
- In some cases, the input includes audio data representing a spoken utterance and the task is a speech recognition task. The output may comprise a text output which is mapped to the spoken utterance. In some cases, the task comprises encrypting or decrypting input data. In some cases, the task comprises a microprocessor performance task, such as branch prediction or memory address translation.
-
FIG. 7A illustrates one example computing system that can be used to implement the present disclosure. Other computing systems can be used as well. For example, in some implementations, theuser computing device 102 can include themodel trainer 160 and thetraining dataset 162. In such implementations, the knowledgegraph reasoning models 120 can be both trained and used locally at theuser computing device 102. In some of such implementations, theuser computing device 102 can implement themodel trainer 160 to personalize the knowledgegraph reasoning models 120 based on user-specific data. -
FIG. 7B depicts a block diagram of anexample computing device 10 that performs negative sampling with improved efficiency according to example embodiments of the present disclosure. Thecomputing device 10 can be a user computing device or a server computing device. - The
computing device 10 includes a number of applications (e.g.,applications 1 through N). Each application contains its own machine learning library and machine-learned model(s). For example, each application can include a machine-learned model. Example applications include a text messaging application, an email application, a dictation application, a virtual keyboard application, a browser application, etc. - As illustrated in
FIG. 7B , each application can communicate with a number of other components of the computing device, such as, for example, one or more sensors, a context manager, a device state component, and/or additional components. In some implementations, each application can communicate with each device component using an API (e.g., a public API). In some implementations, the API used by each application is specific to that application. -
FIG. 7C depicts a block diagram of anexample computing device 50 that performs negative sampling with improved efficiency according to example embodiments of the present disclosure. Thecomputing device 50 can be a user computing device or a server computing device. - The
computing device 50 includes a number of applications (e.g.,applications 1 through N). Each application is in communication with a central intelligence layer. Example applications include a text messaging application, an email application, a dictation application, a virtual keyboard application, a browser application, etc. In some implementations, each application can communicate with the central intelligence layer (and model(s) stored therein) using an API (e.g., a common API across all applications). - The central intelligence layer includes a number of machine-learned models. For example, as illustrated in
FIG. 7C , a respective machine-learned model can be provided for each application and managed by the central intelligence layer. In other implementations, two or more applications can share a single machine-learned model. For example, in some implementations, the central intelligence layer can provide a single model for all of the applications. In some implementations, the central intelligence layer is included within or otherwise implemented by an operating system of thecomputing device 50. - The central intelligence layer can communicate with a central device data layer. The central device data layer can be a centralized repository of data for the
computing device 50. As illustrated inFIG. 7C , the central device data layer can communicate with a number of other components of the computing device, such as, for example, one or more sensors, a context manager, a device state component, and/or additional components. In some implementations, the central device data layer can communicate with each device component using an API (e.g., a private API). - The technology discussed herein makes reference to servers, databases, software applications, and other computer-based systems, as well as actions taken and information sent to and from such systems. The inherent flexibility of computer-based systems allows for a great variety of possible configurations, combinations, and divisions of tasks and functionality between and among components. For instance, processes discussed herein can be implemented using a single device or component or multiple devices or components working in combination. Databases and applications can be implemented on a single system or distributed across multiple systems. Distributed components can operate sequentially or in parallel.
- While the present subject matter has been described in detail with respect to various specific example embodiments thereof, each example is provided by way of explanation, not limitation of the disclosure. Those skilled in the art, upon attaining an understanding of the foregoing, can readily produce alterations to, variations of, and equivalents to such embodiments. Accordingly, the subject disclosure does not preclude inclusion of such modifications, variations and/or additions to the present subject matter as would be readily apparent to one of ordinary skill in the art. For instance, features illustrated or described as part of one embodiment can be used with another embodiment to yield a still further embodiment. Thus, it is intended that the present disclosure cover such alterations, variations, and equivalents.
Claims (20)
1. A computer-implemented method for negative sampling with improved efficiency, the method performed by one or more computing devices and comprising:
obtaining a knowledge graph comprising a plurality of entities and a plurality of links between the plurality of entities, wherein a link from among the plurality of links is between at least two entities from among the plurality of entities and describes a relation between the at least two entities;
generating, based on the knowledge graph, a query computation graph comprising a plurality of nodes and a plurality of edges, wherein the plurality of nodes comprises one or more anchor nodes, a root node, and one or more intermediate nodes positioned in one or more paths between the one or more anchor nodes and the root node;
determining a node cut of a query of the query computation graph, wherein the node cut comprises at least one node that cuts at least one path between each anchor node from among the one or more anchor nodes of the query computation graph and the root node of the query computation graph; and
identifying one or more negative samples for the query computation graph by bidirectionally traversing the query computation graph in a first direction from the one or more anchor nodes to the node cut and in a second direction from the root node to the node cut.
2. The method of claim 1 , further comprising performing a depth-first search over the query computation graph from the root node of the query computation graph to the one or more anchor nodes of the query computation graph, wherein each node of the query computation graph is grounded to an entity on the knowledge graph and an edge of the query computation graph is grounded to a relation on the knowledge graph associated with a previously grounded entity on the knowledge graph.
3. The method of claim 1 , wherein traversing the query computation graph in the first direction from the one or more anchor nodes to the node cut comprises caching the one or more intermediate nodes, wherein the intermediate nodes are obtained while traversing the query computation graph in the first direction.
4. The method of claim 3 , further comprising:
comparing overlap of the cached one or more intermediate nodes and a set of nodes traversed while traversing the query computation graph in the second direction from the root node to the node cut; and
determining, based on the overlap, that a node from among the set of nodes traversed is a negative non-answer to the query, wherein a negative sample comprises the negative non-answer to the query.
5. The method of claim 4 , wherein determining, based on the overlap, that a node from among the set of nodes traversed is a negative non-answer to the query comprises determining that there is no overlap between the cached one or more intermediate nodes and the set of nodes traversed while traversing the query computation graph in the second direction from the root node to the node cut.
6. The method of claim 3 , further comprising:
obtaining, from the query computation graph, a candidate negative node; and
determining whether the candidate negative node overlaps with the cached one or more intermediate nodes.
7. The method of claim 1 , wherein bidirectionally traversing the query computation graph in the first direction from the one or more anchor nodes to the node cut and in the second direction from the root node to the node cut comprises randomly sampling one or more negative candidate nodes in the second direction.
8. The method of claim 1 , wherein each node from among the plurality of nodes of the query computation graph corresponds to a set of entities on the knowledge graph and the plurality of edges of the query computation graph represent a logical relational transformation of the set of entities on the knowledge graph.
9. The method of claim 8 , wherein the logical relational transformation of the set of entities on the knowledge graph comprises one or more of relation projection, intersection, union, complement, and negation.
10. The method of claim 1 , further comprising:
calculating computation costs for one or more node cuts based on paths between each anchor node from among the one or more anchor nodes of the query computation graph and the root node of the query computation graph; and
wherein the node cut comprises a node cut from among the one or more node cuts with a lowest computation cost.
11. The method of claim 10 , wherein calculating the computation costs for the one or more node cuts comprises:
determining a maximum number of relation projections in the paths between each anchor node from among the one or more anchor nodes of the query computation graph and the root node of the query computation graph;
determining a length of a path from each anchor node from among the one or more anchor nodes of the query computation graph to one or more anchor nodes from among the one or more anchor nodes of the query computation graph, wherein the length of the path comprises a number of relation projections on the path; and
determining optimal costs of resolving the paths between each anchor node from among the one or more anchor nodes of the query computation graph and the root node of the query computation graph.
12. The method of claim 1 , wherein the query computation graph comprises a plan for executing the query, wherein the query is executed in an embedding space.
13. The method of claim 1 , wherein the root node of the query computation graph comprises a known positive answer to the query.
14. The method of claim 1 , wherein the query is a first-order logical query.
15. The method of claim 1 , wherein the knowledge graph is a heterogeneous graph.
16. A computing system for negative sampling with improved efficiency, the computing system comprising:
one or more processors;
one or more non-transitory computer-readable media that collectively store instructions that, when executed by the one or more processors, cause the one or more processors to perform operations, the operations comprising:
obtaining a knowledge graph comprising a plurality of entities and a plurality of links between the plurality of entities, wherein a link from among the plurality of links is between at least two entities from among the plurality of entities and describes a relation between the at least two entities;
generating, based on the knowledge graph, a query computation graph comprising a plurality of nodes and a plurality of edges, wherein the plurality of nodes comprises one or more anchor nodes, a root node, and one or more intermediate nodes positioned in one or more paths between the one or more anchor nodes and the root node;
determining a node cut of a query of the query computation graph, wherein the node cut comprises at least one node that cuts at least one path between each anchor node from among the one or more anchor nodes of the query computation graph and the root node of the query computation graph; and
identifying one or more negative samples for the query computation graph by bidirectionally traversing the query computation graph in a first direction from the one or more anchor nodes to the node cut and in a second direction from the root node to the node cut.
17. The computing system of claim 16 , further comprising performing a depth-first search over the query computation graph from the root node of the query computation graph to the one or more anchor nodes of the query computation graph, wherein each node of the query computation graph is grounded to an entity on the knowledge graph and an edge of the query computation graph is grounded to a relation on the knowledge graph associated with a previously grounded entity on the knowledge graph.
18. The computing system of claim 16 , wherein traversing the query computation graph in the first direction from the one or more anchor nodes to the node cut comprises caching the one or more intermediate nodes, wherein the intermediate nodes are obtained while traversing the query computation graph in the first direction.
19. One or more non-transitory computer-readable media that collectively store instructions that, when executed by one or more processors of a computing system, cause the computing system to perform operations, the operations comprising:
obtaining a knowledge graph comprising a plurality of entities and a plurality of links between the plurality of entities, wherein a link from among the plurality of links is between at least two entities from among the plurality of entities and describes a relation between the at least two entities;
generating, based on the knowledge graph, a query computation graph comprising a plurality of nodes and a plurality of edges, wherein the plurality of nodes comprises one or more anchor nodes, a root node, and one or more intermediate nodes positioned in one or more paths between the one or more anchor nodes and the root node;
determining a node cut of a query of the query computation graph, wherein the node cut comprises at least one node that cuts at least one path between each anchor node from among the one or more anchor nodes of the query computation graph and the root node of the query computation graph; and
identifying one or more negative samples for the query computation graph by bidirectionally traversing the query computation graph in a first direction from the one or more anchor nodes to the node cut and in a second direction from the root node to the node cut.
20. The non-transitory computer-readable medium of claim 19 , further comprising performing a depth-first search over the query computation graph from the root node of the query computation graph to the one or more anchor nodes of the query computation graph, wherein each node of the query computation graph is grounded to an entity on the knowledge graph and an edge of the query computation graph is grounded to a relation on the knowledge graph associated with a previously grounded entity on the knowledge graph.
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US18/183,410 US20230289626A1 (en) | 2022-03-14 | 2023-03-14 | Knowledge Graph Completion and Multi-Hop Reasoning in Knowledge Graphs at Scale |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US202263319558P | 2022-03-14 | 2022-03-14 | |
US18/183,410 US20230289626A1 (en) | 2022-03-14 | 2023-03-14 | Knowledge Graph Completion and Multi-Hop Reasoning in Knowledge Graphs at Scale |
Publications (1)
Publication Number | Publication Date |
---|---|
US20230289626A1 true US20230289626A1 (en) | 2023-09-14 |
Family
ID=87931918
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US18/183,410 Pending US20230289626A1 (en) | 2022-03-14 | 2023-03-14 | Knowledge Graph Completion and Multi-Hop Reasoning in Knowledge Graphs at Scale |
Country Status (1)
Country | Link |
---|---|
US (1) | US20230289626A1 (en) |
-
2023
- 2023-03-14 US US18/183,410 patent/US20230289626A1/en active Pending
Similar Documents
Publication | Publication Date | Title |
---|---|---|
JP7157154B2 (en) | Neural Architecture Search Using Performance Prediction Neural Networks | |
JP6790286B2 (en) | Device placement optimization using reinforcement learning | |
EP3711000B1 (en) | Regularized neural network architecture search | |
CN111950695A (en) | Syntax migration using one or more neural networks | |
JP2021521505A (en) | Application development platform and software development kit that provides comprehensive machine learning services | |
US20220027738A1 (en) | Distributed synchronous training architecture using stale weights | |
US20210303970A1 (en) | Processing data using multiple neural networks | |
JP2022088319A (en) | Analysis of natural language text in document | |
WO2020092020A1 (en) | Learning property graph representations edge-by-edge | |
Wang et al. | Deep learning at scale and at ease | |
US11144291B1 (en) | Loop-oriented neural network compilation | |
US20210182670A1 (en) | Method and apparatus with training verification of neural network between different frameworks | |
US20220366297A1 (en) | Local permutation importance: a stable, linear-time local machine learning feature attributor | |
CN114925846A (en) | Pipeline for efficient training and deployment of machine learning models | |
US20210174202A1 (en) | Method and apparatus with model optimization, and accelerator system | |
Gadiyar et al. | Artificial Intelligence Software and Hardware Platforms | |
US20230267307A1 (en) | Systems and Methods for Generation of Machine-Learned Multitask Models | |
Jena et al. | High-performance computing and its requirements in deep learning | |
Krak et al. | Analysis of Deep Learning Methods in Adaptation to the Small Data Problem Solving | |
US11461662B1 (en) | Compilation time reduction for memory and compute bound neural networks | |
US20220092387A1 (en) | Systems and Methods for Producing an Architecture of a Pyramid Layer | |
Furusho et al. | Roles of pre-training in deep neural networks from information theoretical perspective | |
US20230289626A1 (en) | Knowledge Graph Completion and Multi-Hop Reasoning in Knowledge Graphs at Scale | |
Wei et al. | Deploying and scaling distributed parallel deep neural networks on the Tianhe-3 prototype system | |
Sarang | Ensemble: Bagging and Boosting: Improving Decision Tree Performance by Ensemble Methods |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:DAI, HANJUN;DAI, BO;REN, HONGYU;AND OTHERS;REEL/FRAME:062975/0381Effective date: 20220523 |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: DOCKETED NEW CASE - READY FOR EXAMINATION |