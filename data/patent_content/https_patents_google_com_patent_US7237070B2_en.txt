US7237070B2 - Cache memory, processing unit, data processing system and method for assuming a selected invalid coherency state based upon a request source - Google Patents
Cache memory, processing unit, data processing system and method for assuming a selected invalid coherency state based upon a request source Download PDFInfo
- Publication number
- US7237070B2 US7237070B2 US11/109,085 US10908505A US7237070B2 US 7237070 B2 US7237070 B2 US 7237070B2 US 10908505 A US10908505 A US 10908505A US 7237070 B2 US7237070 B2 US 7237070B2
- Authority
- US
- United States
- Prior art keywords
- cache
- block
- snooper
- coherency
- cache memory
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Fee Related, expires
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F12/00—Accessing, addressing or allocating within memory systems or architectures
- G06F12/02—Addressing or allocation; Relocation
- G06F12/08—Addressing or allocation; Relocation in hierarchically structured memory systems, e.g. virtual memory systems
- G06F12/0802—Addressing of a memory level in which the access to the desired data or data block requires associative addressing means, e.g. caches
- G06F12/0806—Multiuser, multiprocessor or multiprocessing cache systems
- G06F12/0811—Multiuser, multiprocessor or multiprocessing cache systems with multilevel cache hierarchies
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F12/00—Accessing, addressing or allocating within memory systems or architectures
- G06F12/02—Addressing or allocation; Relocation
- G06F12/08—Addressing or allocation; Relocation in hierarchically structured memory systems, e.g. virtual memory systems
- G06F12/0802—Addressing of a memory level in which the access to the desired data or data block requires associative addressing means, e.g. caches
- G06F12/0806—Multiuser, multiprocessor or multiprocessing cache systems
- G06F12/0815—Cache consistency protocols
- G06F12/0831—Cache consistency protocols using a bus scheme, e.g. with bus monitoring or watching means
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F12/00—Accessing, addressing or allocating within memory systems or architectures
- G06F12/02—Addressing or allocation; Relocation
- G06F12/08—Addressing or allocation; Relocation in hierarchically structured memory systems, e.g. virtual memory systems
- G06F12/0802—Addressing of a memory level in which the access to the desired data or data block requires associative addressing means, e.g. caches
- G06F12/0806—Multiuser, multiprocessor or multiprocessing cache systems
- G06F12/0813—Multiuser, multiprocessor or multiprocessing cache systems with a network or matrix configuration
Definitions
- the present invention relates in general to data processing and, in particular, to improved data processing system and cache memories for data processing systems. Still more particularly, the present invention relates to an improved coherency protocol in a cache memory of a data processing system.
- a conventional symmetric multiprocessor (SMP) computer system such as a server computer system, includes multiple processing units all coupled to a system interconnect, which typically comprises one or more address, data and control buses. Coupled to the system interconnect is a system memory, which represents the lowest level of volatile memory in the multiprocessor computer system and which generally is accessible for read and write access by all processing units.
- system memory which represents the lowest level of volatile memory in the multiprocessor computer system and which generally is accessible for read and write access by all processing units.
- each processing unit is typically further supported by a respective multi-level cache hierarchy, the lower level(s) of which may be shared by one or more processor cores.
- cache hierarchies of multiprocessor computer systems typically implement a cache coherency protocol to ensure at least a minimum level of coherence among the various processor core's “views” of the contents of system memory.
- cache coherency requires, at a minimum, that after a processing unit accesses a copy of a memory block and subsequently accesses an updated copy of the memory block, the processing unit cannot again access the old copy of the memory block.
- a cache coherency protocol typically defines a set of cache coherency states stored in a cache directory in association with the cache lines of each cache hierarchy, as well as a set of coherency messages utilized to communicate the cache state information between cache hierarchies.
- the cache state information takes the form of the well-known MESI (Modified, Exclusive, Shared, Invalid) protocol or a variant thereof, and the coherency messages indicate a protocol-defined coherency state transition in the cache directory of the cache at the requestor and/or the recipients of a memory access request.
- MESI Modified, Exclusive, Shared, Invalid
- the present invention provides an improved cache memory, processing unit, data processing system, and method of data processing in which a memory block in a cache memory assumes a selected invalid coherency state based upon a request source.
- an exclusive memory access operation is received via an interconnect fabric coupling the first cache memory to second and third cache memories respectively affiliated with second and third processor cores.
- the exclusive memory access operation specifies a target address.
- the first cache memory detects presence or absence of a source indication indicating that the exclusive memory access operation originated from the second cache memory to which the first cache memory is coupled by a private communication network to which the third cache memory is not coupled.
- a coherency state field of the first cache memory that is associated with the target address is updated to a first data-invalid state.
- the coherency state field of the first cache memory is updated to a different second data-invalid state.
- FIG. 1 is a high level block diagram of an exemplary data processing system in accordance with the present invention
- FIG. 2 is a more detailed block diagram of a processing unit in accordance with the present invention.
- FIG. 3 is a more detailed block diagram of the L2 cache array and directory depicted in FIG. 2 ;
- FIG. 4 is a time-space diagram of an exemplary transaction on the system interconnect of the data processing system of FIG. 1 ;
- FIG. 5 illustrates a domain indicator in accordance with a preferred embodiment of the present invention
- FIGS. 6A–6B together form a high level logical flowchart of an exemplary method of servicing a read operation by a processor core in a data processing system in accordance with the present invention
- FIGS. 7A–7B together form a high level logical flowchart of an exemplary method of servicing a processor update operation in a data processing system in accordance with the present invention
- FIG. 8 is a high level logical flowchart of an exemplary method of performing a local bus read operation in a data processing system in accordance with the present invention
- FIGS. 9A–9B together form a high level logical flowchart of an exemplary method of performing a global bus read operation in a data processing system in accordance with the present invention
- FIG. 10 is a high level logical flowchart of an exemplary method of performing a local bus RWITM operation in a data processing system in accordance with the present invention
- FIGS. 11A–11B together form a high level logical flowchart of an exemplary method of performing a global bus RWITM operation in a data processing system in accordance with the present invention
- FIG. 12 is a high level logical flowchart of an exemplary method of performing a local bus DClaim operation in a data processing system in accordance with the present invention.
- FIG. 13 is a high level logical flowchart of an exemplary method of performing a global bus DClaim operation in a data processing system in accordance with the present invention.
- data processing system 100 includes multiple processing nodes 102 a , 102 b for processing data and instructions.
- Processing nodes 102 a , 102 b are coupled to a system interconnect 110 for conveying address, data and control information.
- System interconnect 110 maybe implemented, for example, as a bused interconnect, a switched interconnect or a hybrid interconnect.
- each processing node 102 is realized as a multi-chip module (MCM) containing four processing units 104 a – 104 d , each preferably realized as a respective single integrated circuit.
- MCM multi-chip module
- the processing units 104 a – 104 d within each processing node 102 are coupled for communication by a local interconnect 114 , which, like system interconnect 110 , may be implemented with one or more buses and/or switches.
- the devices coupled to each local interconnect 114 include not only processing units 104 , but also one or more system memories 108 a – 108 d .
- Data and instructions residing in system memories 108 can generally be accessed and modified by a processor core in any processing unit 104 in any processing node 102 of data processing system 100 .
- one or more system memories 108 can be coupled to system interconnect 110 rather than a local interconnect 114 .
- SMP data processing system 100 can include many additional unillustrated components, such as interconnect bridges, non-volatile storage, ports for connection to networks or attached devices, etc. Because such additional components are not necessary for an understanding of the present invention, they are not illustrated in FIG. 1 or discussed further herein. It should also be understood, however, that the enhancements provided by the present invention are applicable to cache coherent data processing systems of diverse architectures and are in no way limited to the generalized data processing system architecture illustrated in FIG. 1 .
- each processing unit 104 includes two processor cores 200 a , 200 b for independently processing instructions and data.
- Each processor core 200 includes at least an instruction sequencing unit (ISU) for fetching and ordering instructions for execution and one or more execution units for executing instructions.
- the instructions executed by the execution unit(s) include instructions that request access to a memory block or cause the generation of a request for access to a memory block.
- ISU instruction sequencing unit
- each processor core 200 is supported by a multi-level volatile memory hierarchy having at its lowest level shared system memories 108 a – 108 d , and at its upper levels one or more levels of cache memory.
- each processing unit 104 includes an integrated memory controller (IMC) 206 that controls read and write access to a respective one of the system memories 108 a – 108 d within its processing node 102 in response to requests received from processor cores 200 a – 200 b and operations snooped by a snooper (SNP) 222 on the local interconnect 114 .
- IMC 206 determines the addresses for which it is responsible by reference to base address register (BAR) logic 240 .
- BAR base address register
- the cache memory hierarchy of each processor core 200 includes a respective store-through level one (L1) cache 226 within each processor core 200 and a respective private level two (L2) cache 230 .
- L2 cache 230 includes an L2 array and directory 234 and a cache controller comprising a master 232 and a snooper 236 .
- Master 232 initiates transactions on local interconnect 114 and system interconnect 110 and accesses L2 array and directory 234 in response to memory access (and other) requests received from the associated processor cores 200 a – 200 b .
- Snooper 236 snoops operations on local interconnect 114 , provides appropriate responses, and performs any accesses to L2 array and directory 234 required by the operations.
- private L2 caches 230 a , 230 b are coupled for communication by a private communication network 270 by which each of L2 caches 230 a , 230 b , which are otherwise private to their respective cores, can directly intervene read data to the other L2 cache 230 without any related operation being issued or received on shared local interconnect 114 .
- such direct intervention is preferably performed speculatively (e.g., concurrently with the memory access operation in the requesting L2 cache 230 ) and reduces the likelihood of having to issue a read operation on local interconnect 114 responsive to a cache miss.
- a private L2 cache 230 that receives a request for direct intervention from another L2 cache 230 via a private network 270 is referred to herein as an “L2.1” cache and this form of direct cache-to-cache intervention via a private communication network 270 is referred to as an “L2.1 intervention.”
- each of the illustrated cache hierarchies will be hereafter described as including only L1 and L2 caches, those skilled in the art will appreciate that alternative embodiments may include additional levels (L3, L4, L5 etc.) of on-chip or off-chip in-line or lookaside cache, which may be fully inclusive, partially inclusive, or non-inclusive of the contents the upper levels of cache.
- the processing unit 104 may optionally include an L3 cache 250 including a cache controller 252 , an L3 cache array 260 , and an L3 directory 254 of the contents of L3 cache array 260 .
- L3 cache array 260 may be implemented fully on-chip, as shown, in other embodiments L3 cache array 260 is implemented in memory DIMMs external to processing unit 104 in order to permit L3 cache array 260 to have a greater capacity.
- L3 cache 250 may be implemented as inclusive, partially inclusive or non-inclusive of the contents of L2 cache 230 .
- L3 cache 250 may be implemented as an in-line or lookaside cache.
- optional L3 cache 250 is implemented as a “victim” cache that is populated by memory blocks castout or victimized by L2 caches 230 a , 230 b .
- One embodiment of such an arrangement is described in detail, for example, in U.S. patent application Ser. No. 11/055,301, which is assigned to the assignee of the present application and incorporated herein by reference in its entirety.
- Each processing unit 104 further includes an instance of response logic 210 , which as discussed further below, implements a portion of the distributed coherency signaling mechanism that maintains cache coherency within data processing system 100 .
- each processing unit 104 includes an instance of forwarding logic 212 for selectively forwarding communications between its local interconnect 114 and system interconnect 110 .
- each processing unit 104 includes an integrated I/O (input/output) controller 214 supporting the attachment of one or more I/O devices, such as I/O device 216 . As described further below, I/O controller 214 may issue operations on local interconnect 114 and/or system interconnect 110 in response to requests by I/O device 216 .
- L2 array and directory 234 includes a set associative L2 cache array 300 and an L2 cache directory 302 of the contents of L2 cache array 300 .
- memory locations in system memories 108 are mapped to particular congruence classes within cache arrays 300 utilizing predetermined index bits within the system memory (real) addresses.
- the particular cache lines stored within cache array 300 are recorded in cache directory 302 , which contains one directory entry for each cache line in cache array 300 .
- each directory entry in cache directory 302 comprises at least a tag field 304 , which specifies the particular cache line stored in cache array 300 utilizing a tag portion of the corresponding real address, a state field 306 , which indicates the coherency state of the cache line, and a LRU (Least Recently Used) field 308 indicating a replacement order for the cache line with respect to other cache lines in the same congruence class.
- L3 directory 254 may be similarly constructed.
- FIG. 4 there is depicted a time-space diagram of an exemplary operation on a local or system interconnect 110 , 114 of data processing system 100 of FIG. 1 .
- the operation begins when a master 232 of an L2 cache 230 (or another master, such as an I/O controller 214 ) issues a request 402 on a local interconnect 114 and/or system interconnect 110 .
- Request 402 preferably includes a transaction type indicating a type of desired access and a resource identifier (e.g., real address) indicating a resource to be accessed by the request.
- Common types of requests preferably include those set forth below in Table I.
- Request 402 is received by the snooper 236 of L2 caches 230 , as well as the snoopers 222 of memory controllers 206 ( FIG. 1 ).
- the snooper 236 in the same L2 cache 230 as the master 232 of request 402 does not snoop request 402 (i.e., there is generally no self-snooping) because a request 402 is transmitted on local interconnect 114 and/or system interconnect 110 only if the request 402 cannot be serviced internally by a processing unit 104 .
- Each snooper 222 , 236 that receives request 402 provides a respective partial response 406 representing the response of at least that snooper to request 402 .
- a snooper 222 within a memory controller 206 determines the partial response 406 to provide based, for example, whether the snooper 222 is responsible for the request address and whether it has resources available to service the request.
- a snooper 236 of an L2 cache 230 may determine its partial response 406 based on, for example, the availability of its L2 cache directory 302 , the availability of a snoop logic instance within snooper 236 to handle the request, and the coherency state associated with the request address in L2 cache directory 302 .
- response logic 210 provides combined response 410 to master 232 and snoopers 222 , 236 via its local interconnect 114 and/or system interconnect 110 to indicate the system-wide response (e.g., success, failure, retry, etc.) to request 402 .
- CR 410 may indicate, for example, a data source for a requested memory block, a cache state in which the requested memory block is to be cached by master 232 , and whether “cleanup” operations invalidating the requested memory block in one or more L2 caches 230 are required.
- one or more of master 232 and snoopers 222 , 236 In response to receipt of combined response 410 , one or more of master 232 and snoopers 222 , 236 typically perform one or more operations in order to service request 402 . These operations may include supplying data to master 232 , invalidating or otherwise updating the coherency state of data cached in one or more L2 caches 230 , performing castout operations, writing back data to a system memory 108 , etc. As discussed further below, if required by request 402 , a requested or target memory block may be transmitted to or from master 232 before or after the generation of combined response 410 by response logic 210 .
- LPC Lowest Point of Coherency
- An LPC is defined herein as a memory device or I/O device that serves as the repository for a memory block. In the absence of a HPC for the memory block, the LPC holds the true image of the memory block and has authority to grant or deny requests to generate an additional cached copy of the memory block. For a typical request in the data processing system embodiment of FIGS.
- the LPC will be the memory controller 206 for the system memory 108 holding the referenced memory block.
- An HPC is defined herein as a uniquely identified device that caches a true image of the memory block (which may or may not be consistent with the corresponding memory block at the LPC) and has the authority to grant or deny a request to modify the memory block. Descriptively, the HPC may also provide a copy of the memory block to a requestor in response to an operation that does not modify the memory block. Thus, for a typical request in the data processing system embodiment of FIGS. 1 and 2 , the HPC, if any, will be an L2 cache 230 .
- a preferred embodiment of the present invention designates the HPC, if any, for a memory block utilizing selected cache coherency state(s) within the L2 cache directory 302 of an L2 cache 230 , as described further below with reference to Table II.
- the HPC if any, for a memory block referenced in a request 402 , or in the absence of an HPC, the LPC of the memory block, preferably has the responsibility of protecting the transfer of ownership of a memory block in response to a request 402 during a protection window 404 a .
- the snooper 236 that is the HPC for the memory block specified by the request address of request 402 protects the transfer of ownership of the requested memory block to master 232 during a protection window 404 a that extends from the time that snooper 236 determines its partial response 406 until snooper 236 receives combined response 410 .
- snooper 236 protects the transfer of ownership by providing partial responses 406 to other requests specifying the same request address that prevent other masters from obtaining ownership until ownership has been successfully transferred to master 232 .
- Master 232 likewise initiates a protection window 404 b to protect its ownership of the memory block requested in request 402 following receipt of combined response 410 .
- snoopers 222 , 236 all have limited resources for handling the CPU and I/O requests described above, several different levels of partial responses and corresponding CRs are possible. For example, if a snooper 222 within a memory controller 206 that is responsible for a requested memory block has queue available to handle a request, the snooper 222 may respond with a partial response indicating that it is able to serve as the LPC for the request. If, on the other hand, the snooper 222 has no queue available to handle the request, the snooper 222 may respond with a partial response indicating that is the LPC for the memory block, but is unable to currently service the request.
- a snooper 236 in an L2 cache 230 may require an available instance of snoop logic and access to L2 cache directory 302 in order to handle a request. Absence of access to either (or both) of these resources results in a partial response (and corresponding CR) signaling an inability to service the request due to absence of a required resource.
- a snooper 222 , 236 providing a partial response indicating that the snooper has available all internal resources required to service a request, if required, is said to “affirm” the request.
- partial responses affirming a snooped operation preferably indicate the cache state of the requested or target memory block at that snooper 236 .
- a snooper 236 providing a partial response indicating that the snooper 236 does not have available all internal resources required to service the request may be said to be “possibly hidden.”
- Such a snooper 236 is “possibly hidden” because the snooper 236 , due to lack of an available instance of snoop logic or access to L2 cache directory 302 , cannot “affirm” the request in sense defined above and has, from the perspective of other masters 232 and snoopers 222 , 236 , an unknown coherency state.
- broadcast-based data processing systems handle both cache coherency and data delivery through broadcast communication, which in conventional systems is transmitted on a system interconnect to at least all memory controllers and cache hierarchies in the system.
- broadcast-based systems tend to offer decreased access latency and better data handling and coherency management of shared memory blocks.
- traffic volume on the system interconnect is multiplied, meaning that system cost rises sharply with system scale as more bandwidth is required for communication over the system interconnect. That is, a system with m processor cores, each having an average traffic volume of n transactions, has a traffic volume of m ⁇ n, meaning that traffic volume in broadcast-based systems scales multiplicatively not additively.
- an increase in system size has the secondary effect of increasing some access latencies. For example, the access latency of read data is limited, in the worst case, by the combined response latency of the furthest away lower level cache holding the requested memory block in a shared coherency state from which the requested data can be sourced.
- the present invention reduces data access latency by decreasing the average distance between a requesting L2 cache 230 and an data source.
- One technique for do so is to reducing the average distance between a requesting L2 cache 230 and a data source is to permit multiple L2 caches 230 distributed throughout data processing system 100 to hold copies of the same memory block in a “special” shared coherency state that permits these caches to supply the memory block to requesting L2 caches 230 using cache-to-cache intervention via local and system interconnects 114 , 110 .
- each domain within a SMP data processing system where a domain is defined to include one or more lower level (e.g., L2) caches that participate in responding to data requests, is permitted to include only one cache hierarchy that holds a particular memory block in the “special” shared coherency state at a time. That cache hierarchy, if present when a bus read-type (e.g., read or RWITM) operation is initiated by a requesting lower level cache in the same domain, is responsible for sourcing the requested memory block to the requesting lower level cache.
- a bus read-type e.g., read or RWITM
- preferred embodiments of the present invention additionally implement coherency domains, which like the data delivery domains hereinbefore described, can conveniently (but are not required to be) implemented with each processing node 102 forming a separate coherency domain.
- coherency domains can be, but are not required to be coextensive, and for the purposes of explaining exemplary operation of data processing system 100 will hereafter be assumed to have boundaries defined by processing nodes 102 .
- coherency domains reduces system traffic by limiting inter-domain broadcast communication over system interconnect 110 in cases in which requests can be serviced with participation by fewer than all coherency domains. For example, if processing unit 104 a of processing node 102 a has a bus read operation to issue, then processing unit 104 a may elect to first broadcast the bus read operation to all participants within its own coherency domain (e.g., processing node 102 a ), but not to participants in other coherency domains (e.g., processing node 102 b ). A broadcast operation transmitted to only those participants within the same coherency domain as the master of the operation is defined herein as a “local operation”.
- the local bus read operation can be serviced within the coherency domain of processing unit 104 a , then no further broadcast of the bus read operation is performed. If, however, the partial responses and combined response to the local bus read operation indicate that the bus read operation cannot be serviced solely within the coherency domain of processing node 102 a , the scope of the broadcast may then be extended to include, in addition to the local coherency domain, one or more additional coherency domains.
- two broadcast scopes are employed: a “local” scope including only the local coherency domain and a “global” scope including all of the other coherency domains in the SMP data processing system.
- a “local” scope including only the local coherency domain and a “global” scope including all of the other coherency domains in the SMP data processing system is defined herein as a “global operation”.
- cache coherency is maintained across all coherency domains in the SMP data processing system.
- a local/global indicator (signal), which in one embodiment may comprise a 1-bit flag.
- Forwarding logic 212 within processing units 104 preferably determines whether or not to forward an operation received via local interconnect 114 onto system interconnect 110 based upon the setting of the local/global indicator (signal) in the operation.
- FIG. 5 depicts a first exemplary implementation of a domain indicator in accordance with the present invention.
- a system memory 108 which may be implemented in dynamic random access memory (DRAM), stores a plurality of memory blocks 500 .
- System memory 108 stores in association with each memory block 500 an associated error correcting code (ECC) 502 utilized to correct errors, if any, in memory block 500 and a domain indicator 504 .
- ECC error correcting code
- domain indicator 504 may identify a particular coherency domain (i.e., specify a coherency domain or node ID), it is hereafter assumed that domain indicator 504 is a 1-bit indicator that is set (e.g., to ‘1’ to indicate “local”) if the associated memory block 500 is cached, if at all, only within the same coherency domain as the memory controller 206 serving as the LPC for the memory block 500 . Domain indicator 504 is reset (e.g., to ‘0’ to indicate “global”) otherwise.
- the setting of domain indicators 504 to indicate “local” may be implemented imprecisely in that a false setting of “global” will not induce any coherency errors, but may cause unneeded global broadcasts of operations.
- memory controllers 206 that source a memory block in response to an operation preferably transmit the associated domain indicator 504 in conjunction with the requested memory block.
- the present invention preferably implements a cache coherency protocol designed to leverage the implementation of data delivery and coherency domains as described above.
- the cache coherency states within the protocol in addition to providing (1) an indication of whether a cache is the HPC for a memory block, also indicate (2) whether the cached copy is unique (i.e., is the only cached copy system-wide) among caches at that memory hierarchy level, (3) whether and when the cache can provide a copy of the memory block to a master of a request for the memory block, (4) whether the cached image of the memory block is consistent with the corresponding memory block at the LPC (system memory), and (5) whether another cache in a remote coherency domain (possibly) holds a cache entry having a matching address.
- MESI Modified, Exclusive, Shared, Invalid
- the Ig (Invalid global) coherency state is utilized to maintain a domain indication in cases in which no copy of a memory block remains cached in a coherency domain.
- the Ig state is defined herein as a cache coherency state indicating (1) the associated memory block in the cache array is invalid, (2) the address tag in the cache directory is valid, and (3) a copy of the memory block identified by the address tag may possibly be cached in another coherency domain.
- the Ig indication is preferably imprecise, meaning that it may be incorrect without a violation of coherency.
- the Ig state is formed in a lower level cache in response to that cache providing a requested memory block to a requestor in another coherency domain in response to an exclusive access request (e.g., a bus RWITM operation).
- an exclusive access request e.g., a bus RWITM operation
- some mechanism e.g., a partial response by the LPC and subsequent combined response
- an Ig state may be formed any time that a cache sources a memory block to a remote coherency domain in response to an exclusive access request.
- cache directory entries including an Ig state carry potentially useful information
- LRU Least Recently Used
- Ig directory entries are retained in cache, it is possible for some Ig entries to become “stale” over time in that a cache whose exclusive access request caused the formation of the Ig state may deallocate or writeback its copy of the memory block without notification to the cache holding the address tag of the memory block in the Ig state.
- the “stale” Ig state which incorrectly indicates that a global operation should be issued instead of a local operation, will not cause any coherency errors, but will merely cause some operations, which could otherwise be serviced utilizing a local operation, to be issued as global operations. Occurrences of such inefficiencies will be limited in duration by the eventual replacement of the “stale” Ig cache entries.
- the cache selects an Ig entry as the victim for replacement, a castout of the Ig entry is performed (unlike the case when an I entry is selected).
- the cache treats the Ig hit as a cache miss and performs a castout operation with the an Ig entry as the selected victim. The cache thus avoids avoid placing two copies of the same address tag in the cache directory.
- the castout of the Ig state is preferably performed as a local operation, or if performed as a global operation, ignored by the LPC of the castout address.
- the castout of the Ig state is preferably performed as a dataless address-only operation in which the domain indicator is written back to the LPC (if local to the cache performing the castout).
- Implementation of an Ig state in accordance with the present invention improves communication efficiency by maintaining a cached domain indicator for a memory block in a coherency domain even when no valid copy of the memory block remains cached in the coherency domain.
- an HPC for a memory block can service an exclusive access request (e.g., bus RWITM operation) from a remote coherency domain without retrying the request and performing a push of the requested memory block to the LPC.
- an exclusive access request e.g., bus RWITM operation
- the In state is defined herein as a cache coherency state indicating (1) the associated memory block in the cache array is invalid, (2) the address tag in the cache directory is valid, and (3) a copy of the memory block identified by the address tag is likely cached, if at all, only by one or more other cache hierarchies within the local coherency domain.
- the In indication is preferably imprecise, meaning that it may be incorrect without a violation of coherency.
- the In state is formed in a lower level cache in response to that cache providing a requested memory block to a requester in the same coherency domain in response to an exclusive access request (e.g., a bus RWITM operation).
- cache directory entries including an In state carry potentially useful information
- LRU Least Recently Used
- In directory entries are retained in cache, it is possible for some In entries to become “stale” over time in that a cache whose exclusive access request caused the formation of the In state may itself supply a shared copy of the memory block to a remote coherency domain without notification to the cache holding the address tag of the memory block in the In state.
- the “stale” In state which incorrectly indicates that a local operation should be issued instead of a global operation, will not cause any coherency errors, but will merely cause some operations to be erroneously first issued as local operations, rather than as global operations. Occurrences of such inefficiencies will be limited in duration by the eventual replacement of the “stale” In cache entries.
- cache entries in the In coherency state are not subject to castout, but are instead simply replaced. Thus, unlike Ig cache entries, In cache entries are not utilized to update domain indicators 504 in system memories 108 .
- Implementation of an In state in accordance with the present invention improves communication efficiency by maintaining a cached domain indicator for a memory block that may be consulted by a master in order to select a local scope for one of its operations. As a consequence, bandwidth on system interconnect 110 and local interconnects 114 in other coherency domains is conserved.
- a lower level cache holding a shared requested memory block in the Sr coherency state is located within the same domain as the requesting master.
- the presence of a “local” Sr snooper within the same domain as the requesting master can be indicated by the response behavior of a snooper at a lower level cache holding a requested memory block in the Sr coherency state.
- a lower level cache holding a shared memory block in the Sr coherency state can provide a partial response affirming the request in the Sr state only for requests by masters within the same data sourcing domain and provide partial responses indicating the S state for all other requests.
- the response behavior can be summarized as shown in Table III, where prime (′) notation is utilized to designate partial responses that may differ from the actual cache state of the memory block.
- FIGS. 6A–13 several high level logical flowcharts depicting the logical steps involved in servicing exemplary requests of processor cores 200 and L2 caches 230 are given.
- FIGS. 6A–7B depict the various processes within masters of the requests
- FIGS. 8–13 illustrate operations involved with communicating and servicing the requests via local and system interconnects 114 , 110 .
- interconnects 110 , 114 are not necessarily bused interconnects, such operations are termed “bus operations” (e.g., bus read operation, bus write operation, etc.) herein to distinguish them from cache or CPU (processor) operations.
- bus operations e.g., bus read operation, bus write operation, etc.
- FIG. 6A–6B there is depicted a high level logical flowchart of an exemplary method of servicing a processor read operation in a data processing system in accordance with the present invention.
- the process begins at block 600 , which represents a master 232 in an L2 cache 230 a receiving a read request from an associated processor core 200 a .
- the process then proceeds to block 634 , which depicts master 232 initiating a lookup of L2 cache directory 302 to determine the coherency state, if any, recorded within L2 cache directory 302 for the target address specified by the memory access operation.
- master 232 also issues a speculative intervention request via private communication network 270 to the L2.1 cache 230 b (and the optional L3 cache 250 , if any) to determine the coherency state, if any, recorded within its cache directory 302 for the target address specified by the memory access operation.
- master 232 will receive the results of the lookup of its local L2 directory 302 in advance of receipt of the results of the L2.1 intervention request.
- master 232 determines at block 636 whether or not the coherency state, if any, recorded within L2 cache directory 302 for the target address permits the CPU read operation to be serviced without first accessing a lower level of the memory hierarchy (i.e., whether the coherency state for the target memory block is M, Me, Tx (i.e., T, Tn, Ten), Sr, or S).
- the process proceeds from block 636 to block 638 , which illustrates master 232 ignoring the results of the L2.1 intervention request.
- Master 232 then services the CPU read operation by supplying the requested memory block to the requesting processor core 200 a , as illustrated at block 644 .
- the process ends at block 646 .
- Block 634 depicts a determination of whether or not a castout of an existing cache line is required to accommodate the requested memory block in L2 cache 230 a .
- a castout operation is required at block 634 and at similar blocks in succeeding figures if the memory block selected as a victim for eviction from the L2 cache 230 of the requesting processor is marked in L2 directory 302 as being in any of the M, T, Te, Tn or Ig coherency states.
- a cache castout operation is performed, as indicated at block 636 .
- the master 232 determines at block 650 whether or not the coherency state of the target address is in one of the “tagged” I states (e.g., In or Ig) in L2 cache directory 302 . If the target address hit in L2 cache directory 302 in one of the “tagged” I states (e.g., In or Ig), master 232 ignores the results of the L2.1 intervention request when received (block 652 ) and issues a bus read operation for the target address on the interconnect fabric without waiting for the results of the L2.1 intervention request (block 654 ).
- a bus read operation is issued because (as explained further below) the “tagged” coherency states are established when a processing core 200 associated with a different cache hierarchy that is not coupled to the requesting L2 cache 230 by a private communication network 270 successfully issues a memory access request (e.g., RWITM or DClaim) on the interconnect fabric to obtain exclusive access to the target memory block. Consequently, it is preferable to issue the bus read operation on the interconnect fabric without incurring the additional latency associated with waiting for the results of the L2.1 intervention request because it is unlikely that the L2.1 cache 230 b holds the target address in one of the coherency states required to service the CPU read operation, as taught U.S. patent application Ser. No. 11/095,734. After the bus read operation is successfully completed, the process proceeds to blocks 644 and 646 , which have been described.
- a memory access request e.g., RWITM or DClaim
- master 232 in response to master 232 determining that the target address did not hit in L2 cache directory 302 in one of the “tagged” I states (e.g., In or Ig), master 232 awaits the results of the L2.1 intervention request. In response to receipt of the results of the L2.1 intervention request, master 232 determines at block 662 if the target address hit in the L2.1 cache 230 b in a coherency state that permits master 232 to service the CPU read operation (i.e., M, Me, Tx, Sr or S) without issuing a bus operation on the interconnect fabric 114 , 110 . If not, the process passes to block 654 , which has been described.
- the CPU read operation i.e., M, Me, Tx, Sr or S
- master 232 determines at block 662 that the target address hit in the L2.1 directory 302 in a coherency state that permits the CPU read operation to be serviced without issuing a request on the interconnect fabric 114 , 110 .
- the process passes to block 664 , which illustrates L2 cache 230 a receiving the target memory block from L2.1 cache 230 b .
- Master 232 determines at block 668 whether or not it chose to ignore the response to the L2.1 intervention request. If so, master 232 discards the memory block received by direct intervention from L2.1 cache 230 b via private communication network 270 , as shown at block 670 , and instead waits to receive the target memory block in response to the bus read operation via the interconnect fabric 114 , 110 .
- this branch of the illustrated process ends at block 646 . If, on the other hand, master 232 determines at block 668 that it did not choose to ignore the L2.1 intervention response, master 232 services the CPU read operation utilizing the data provided by L2.1 cache 230 b , as shown at block 644 . The process thereafter ends at block 646 .
- L2.1 cache 230 b snoops memory access requests on local interconnect 114 (including those requests issued by the other L2 cache 230 a in the same processing unit 104 ) and responds to those memory access requests via the interconnect fabric 114 , 110 like any other snooper.
- FIG. 6B there is depicted a more detailed flowchart of the issuance of the bus read operation at block 654 of FIG. 6A .
- the process begins at block 602 and then proceeds to block 610 , which illustrates a determination by master 232 of whether the bus read operation should be issued as a local operation having a scope limited to only the local interconnect 114 of L2 cache 230 a or a global operation transmitted on system interconnect 110 and all local interconnects 114 .
- the determination depicted at block 610 can simply represent a determination by the master 232 of whether or not the bus read operation has previously been issued as a local bus read operation.
- the determination depicted at block 610 can represent a determination by the master of whether or not the bus read operation has previously been issued more than a threshold number of times.
- the determination made at block 610 can be based upon a prediction by the master of whether or not a local operation is likely to be successful (e.g., is the HPC or is likely to find the HPC in the local coherency domain).
- the process proceeds from block 610 to block 620 , which is described below. If, on the other hand, a determination is made at block 610 to issue a local bus read operation, master 232 initiates a local bus read operation on its local interconnect 114 , as illustrated at block 612 and described below.
- the local bus read operation is broadcast only within the local coherency domain (e.g., processing node 102 ) containing master 232 .
- master 232 receives a CR indicating “success” (block 614 )
- master 232 receives the requested memory block and returns the requested memory block (or at least a portion thereof) to the requesting processor core 200 , as shown at block 624 . Thereafter, the process returns to FIG. 6A at block 626 .
- the process returns from block 616 to block 610 , which illustrates master 232 again determining whether or not to issue a local bus read operation.
- master 232 may employ in the determination any additional information provided by the CR.
- the process passes to either block 612 , which is described above, or to block 620 .
- Block 620 depicts master 230 issuing a global bus read operation as described below. If the CR of the global bus read operation does not indicate “success” at block 622 , master 232 repeats the global bus read operation at block 620 until a CR indicating “success” is received. If the CR of the global bus read operation indicates “success”, the master 232 receives the requested memory block and returns the requested memory block (or at least a portion thereof) to the requesting processor core 200 at block 624 . The process thereafter returns to FIG. 6A at block 626 .
- the process begins at block 700 in response to receipt by an L2 cache 230 of an update request by an associated one of the processor cores 200 within the same processing unit 104 .
- master 232 of the L2 cache 230 accesses L2 cache directory 302 to determine if the memory block referenced by the request address specified by the update request is cached within L2 cache 230 in M state, as shown at block 702 . If so, the master 232 updates the memory block in L2 cache 232 within the new data supplied by the processor core 200 , as illustrated at block 704 . Thereafter, the update process ends at block 706 .
- master 232 updates the state field 306 for the requested memory block to M state in addition to updating the memory block as shown at block 704 . Thereafter, the process terminates at block 706 .
- L2 cache directory 302 indicates that L2 cache 230 holds the requested memory block in either of the T or Te states (block 720 ), meaning that the L2 cache 230 is the HPC for the requested memory block and the requested memory block may possibly be held in one or more other L2 caches 230 , master 232 must gain exclusive access to the requested memory block in order to perform the requested update to the memory block.
- the process by which master 232 gains exclusive access to the requested memory block is shown at block 722 and following blocks.
- master 232 updates the state of the requested memory block in the associated state field 306 of L2 cache directory 302 to the M state, as depicted at block 722 .
- This upgrade is cache state is permissible without first informing other L2 caches 230 because, as the HPC, the L2 cache 230 has the authority to award itself exclusive access to the requested memory block.
- the snooper 236 of the L2 cache 230 provides “downgrade” partial responses to competing DClaim operations snooped on its local interconnect 114 , if any, by which other masters are seeking ownership of the requested memory block. These partial responses indicate that the other requesters must reissue any such competing operations as bus RWITM operations.
- master 232 issues a global bus kill operation on system interconnect 110 to invalidate any other cached copies of the memory block, as described below.
- Master 232 next determines at blocks 790 and 728 whether or not the CR for the bus kill operation indicates that the bus kill operation successfully invalidated all other cached copies of the requested memory block or whether additional local or global “cleanup” (i.e., invalidation of other cached copies) is required. If the CR indicates that additional cleanup is not required, the process proceeds through page connector C to block 704 of FIG. 7A , which has been described. If the CR indicates that additional cleanup is required, master 232 additionally determines whether the CR indicates that the other cached copy or copies of the requested memory block reside entirely within its local coherency domain or whether at least one copy of the requested memory block is cached outside the local coherency domain of master 232 (blocks 790 and 728 ).
- the snooper 236 of the requesting L2 cache 230 continues to downgrade active bus DClaim operations (block 786 ), and the master 232 of the requesting L2 cache 230 continues to issue local bus kill operation (block 788 ) limited in scope to the local coherency domain of master 232 until all other cached copies of the memory block are invalidated. If the CR indicates that at least one remaining cached copy of the requested memory block resides in a remote coherency domain, the process returns to block 724 , which has been described.
- master 232 if the access to the L2 cache directory 302 indicates that the requested memory block is held in one of the Tn or Ten states, then master 232 knows that the requesting L2 cache 230 is the HPC for the requested memory block and that any other cached copy of the requested memory block is held by a cache in its local coherency domain. Accordingly, master 232 updates the state of the requested memory block in the associated state field 306 of L2 cache directory 302 to the M state, as depicted at block 784 .
- the snooper 236 of the requesting L2 cache 230 provides “downgrade” partial responses to any competing DClaim operations snooped on its local interconnect 114 (block 786 ), and the master 232 of the requesting L2 cache 230 continues to issue local bus kill operation (block 788 ) limited in scope to the local coherency domain of master 232 until any other cached copies of the memory block are invalidated. If the master 232 determines by reference to the CR for a local bus kill operation that no further local cleanup is required (block 790 ), the process passes through block 728 and page connector C to block 704 , which has been described.
- the requesting L2 cache 230 is not the HPC for the requested memory block, and master 232 must gain ownership of the requested memory block from the HPC, if any, or in the absence of an HPC, the LPC, prior to updating the memory block.
- master 232 first determines at block 731 whether to issue a bus DClaim operation as a local or global operation. If master 232 makes a determination to issue a global bus DClaim operation, the process proceeds to block 740 , which is described below. In response to a determination at block 731 to issue a bus DClaim operation as a local operation, master 232 issues a local bus DClaim operation at block 732 , as described below in greater detail. Master 232 then awaits receipt of the CR of the local bus DClaim operation, which is represented by the collection of decision blocks 734 , 736 and 738 . If the CR indicates “retry” (block 734 ), the process returns to block 731 , which has been described.
- the process proceeds to block 740 , which is described below. If the CR alternatively indicates “downgrade”, meaning that another requestor has obtained ownership of the requested memory block via a bus DClaim operation, the process passes to block 748 , which is described below. If the CR alternatively indicates that master 232 has been awarded ownership of the requested memory block by the HPC based upon the local bus DClaim operation, the process passes through page connector D to block 790 of FIG. 7B and following blocks, which have been described.
- Block 740 depicts master 232 issuing a global bus DClaim operation, as described below.
- Master 232 next determines at blocks 742 - 744 whether or not the CR for the global bus DClaim operation indicates that it succeeded, should be retried, or was “downgraded” to a RWITM operation. If the CR indicates that the bus DClaim operation should be retried (block 742 ), master 232 reissues a global bus DClaim operation at block 740 and continues to do so until a CR other than “retry” is received.
- the process proceeds to block 746 , which is described below. If the CR alternatively indicates that master 232 has been awarded ownership of the requested memory block by the HPC based upon the global bus DClaim operation, the process passes through page connector D to block 790 of FIG. 7B and following blocks, which have been described.
- Block 746 depicts master 232 of the requesting L2 cache 230 determining whether or not to issue a bus RWITM operation as a local or global operation. If master 232 elects to issue a global RWITM operation, the process passes to block 754 , which is described below. If, however, master 232 elects to issue a local bus RWITM operation, the process proceeds to block 748 , which illustrates master 232 issuing a local bus RWITM operation and awaiting the associated CR. As indicated at block 750 , if the CR indicates “retry”, the process returns to block 746 , which represents master 232 again determining whether to issue a local or global RWITM operation utilizing the additional information, if any, provided in the retry CR.
- the process passes through page connector D to block 790 of FIG. 7B , which has been described. If master 232 determines at block 752 that the CR to the local bus RWITM operation indicates that the operation cannot be serviced within the local coherency domain, the process passes to block 754 and following blocks.
- Blocks 754 and 756 depict master 232 iteratively issuing a global bus RWITM operation for the requested memory block, as described below, until a CR other than “retry” is received.
- master 232 In response to master 232 receiving a non-retry CR indicating that it succeeded in obtaining ownership of the requested memory block (block 756 ), the process passes through page connector D to block 790 and following blocks, which have been described.
- L2 cache 230 does not hold a valid copy of the requested memory block. Accordingly, as indicated at blocks 760 and 770 , L2 cache 230 performs a cache castout operation if needed to allocate a cache line for the requested memory block. Thereafter, the process passes to block 746 and following blocks as described above.
- Tn and Ten coherency states provides an indication of whether a possibly shared memory block is additionally cached only within the local coherency domain. Consequently, when a requestor within the same coherency domain as a cache holding a memory block in one of the Tn or Ten states issues an exclusive access operation (e.g., a bus DClaim, bus RWITM, bus DCBZ or bus write operation) for the memory block, the scope of broadcast operations, such as bus kill operations, can advantageously be restricted to the local coherency domain, reducing interconnect bandwidth utilization.
- an exclusive access operation e.g., a bus DClaim, bus RWITM, bus DCBZ or bus write operation
- FIG. 8 there is depicted a high level logical flowchart of an exemplary method of performing a local bus read operation in a data processing system in accordance with the present invention.
- the process begins at block 1300 , for example, at block 612 of FIG. 6B , with an L2 cache 230 issuing a local bus read operation on its local interconnect 114 .
- the various partial responses that snoopers 222 , 236 may provide to distributed response logic 210 in response to snooping the local bus read operation are represented in FIG.
- Block 1302 if a snooper 236 of an L2 cache 230 affirms the local bus read operation with a partial response indicating that the L2 cache 230 holds the requested memory block in either the M or Me state, the process proceeds from block 1302 to block 1304 .
- Block 1304 indicates the operations of the requesting L2 cache 230 and the affirming L2 cache 230 in response to the local bus read operation.
- the snooper 236 in the affirming L2 cache 230 updates the cache state of the requested memory block from M to Tn or from Me to Ten.
- the snooper 236 in the affirming L2 cache 230 may initiate transmission of the requested memory block to the requesting L2 cache 230 prior to receipt of the CR (i.e., provides “early” data).
- the master 232 in the requesting L2 cache 230 places the requested memory block in L2 cache array 300 in the Sr state.
- the process ends with distributed response logic 210 generating a CR indicating “success”, as depicted at block 1308 .
- Block 1310 represents the Sr′ snooper 236 updating the cache state of the requested memory block to S and initiating transmission of the requested memory block to the requesting L2 cache 230 prior to receipt of the CR (i.e., provides “early” data).
- the Tx snooper 236 remains unchanged.
- the master 232 in the requesting L2 cache 230 Upon receipt of the requested memory block, the master 232 in the requesting L2 cache 230 places the requested memory block in L2 cache array 300 in the Sr state. The process ends with distributed response logic 210 generating a CR indicating “success”, as depicted at block 1308 .
- Block 1310 If the complex of partial responses includes a Tx snooper 236 affirming the local bus read operation (block 1310 ), no Sr′ snooper 236 affirming the bus read operation (block 1312 ), and a snooper 236 providing an partial response (e.g., a type of retry) indicating that an Sr′ snooper 236 may be possibly hidden in the local data delivery domain (block 1314 ), the process passes to block 1316 .
- Block 1316 represents the Tx snooper 236 that affirmed the bus read operation initiating transmission of the requested memory block to the requesting L2 cache 230 after receipt of the CR (i.e., provides “late” data) and retaining the requested memory block in the Tx state.
- the master 232 in the requesting L2 cache 230 Upon receipt, the master 232 in the requesting L2 cache 230 places the requested memory block in L2 cache directory 300 in the S state (since an Sr′ snooper 236 may be hidden and only one Sr′ snooper 236 is permitted in each data delivery domain for the requested memory block).
- the process ends with distributed response logic 210 generating a CR indicating “success”, as depicted at block 1308 .
- Block 1310 If the complex of partial responses includes a T or Te snooper 236 affirming the local bus read operation (block 1310 ), no Sr′ snooper 236 affirming the bus read operation (block 1312 ), and no snooper 236 providing a partial response that may possibly hide a Sr′ snooper 236 (block 1314 ), the process passes to block 1306 .
- Block 1306 represents the T or Te snooper 236 that affirmed the bus read operation initiating transmission of the requested memory block to the requesting L2 cache 230 after receipt of the CR (i.e., provides “late” data) and retaining the requested memory block in the T or Te state.
- the master 232 in the requesting L2 cache 230 Upon receipt, the master 232 in the requesting L2 cache 230 places the requested memory block in L2 cache array 300 in the Sr state (since no other Sr′ snooper 236 exists for the requested memory block in the local data delivery domain). The process ends with distributed response logic 210 generating a CR indicating “success”, as depicted at block 1308 .
- the local bus read operation is serviced in accordance with block 1322 .
- the Sr′ snooper 236 affirming the bus read operation initiates transmission of the requested memory block to the requesting L2 cache 230 prior to receipt of CR and updates the state of the requested memory block in its L2 cache directory 302 to the S state.
- the master 232 in the requesting L2 cache 230 places the requested memory block in its L2 cache array 300 in the Sr state.
- response logic 210 If, on the other hand, an Ig snooper 236 affirms the local bus read operation and the complex of partial responses indicates an M, Me, Tx or Sr′ snooper 236 is possibly hidden, response logic 210 generates a “retry” CR, as depicted at block 1342 .
- block 1330 if no M, Me, Tx, Sr′ or Ig snooper 236 affirms the local bus read operation, and further, if no snooper 222 provides a partial response indicating that it is responsible (i.e., the LPC) for the requested memory block, the process passes to block 1332 , which has been described. If, however, no M, Me, Tx, Sr′ or Ig snooper 236 affirms the local bus read operation, and further, if a snooper 222 provides a partial response indicating that it is responsible (i.e., the LPC) for the requested memory block, the process proceeds to block 1340 .
- response logic 210 if a snooper 222 provides a partial response indicating that it is responsible (i.e., the LPC) for the requested memory block but does not affirm the local bus read operation, response logic 210 generates a CR indicating “retry”, as depicted at block 1342 . If, however, a snooper 222 affirms the local bus read operation, the process proceeds to block 1344 .
- response logic 210 also generates a “retry” CR at block 1342 if a memory controller snooper 222 affirms the bus read operation and an L2 cache snooper 236 provides a partial response indicating that it may hold the requested memory block in one of the M, Me, Tx or Ig states but cannot affirm the local bus read operation. In each of these cases, response logic 210 generates a “retry” CR because the bus read operation, if reissued as a local operation, may be able to be serviced without resorting to a global broadcast.
- master 232 determines at block 1360 that the domain indicator 3004 is reset to “global”, meaning that a modified copy of the requested memory block may be cached outside the local domain, master 232 of the requesting L2 cache 230 discards the requested memory block, remaining in the I state with respect to the requested memory block.
- master 232 interprets the CR as indicating “go global” (block 1364 ), meaning that master 232 will reissue the bus read operation as a global bus read operation.
- the master 232 of the requesting cache 230 interprets the CR as indicating “success” (block 1308 ) and places both the requested memory block and domain indicator 504 within its L2 cache array 300 .
- the master 232 also sets the state field 306 associated with the requested memory block to a state indicated by the CR.
- the requesting L2 cache 230 holds the requested memory block in the S state (block 1350 ) because only one Sr copy of the memory block is permitted in any domain.
- the requesting L2 cache 236 holds the requested memory block in the Sr state (block 1352 ).
- the requesting L2 cache 230 holds the requested memory block in the Me state (block 1354 ) because the requesting L2 cache 230 is guaranteed to be the only cache system-wide holding the requested memory block.
- FIGS. 9A–9B there is depicted a high level logical flowchart of an exemplary method of performing a global bus read operation in a data processing system implementing Tn and Ten coherency states in accordance with the present invention.
- the process begins at block 1400 , for example, at block 620 of FIG. 6B , with an L2 cache 230 issuing a global bus read operation on its local interconnect 114 .
- the various partial responses that snoopers 222 , 236 may provide to distributed response logic 210 in response to snooping the global bus read operation are represented in FIG.
- Block 1402 if a snooper 236 of an L2 cache 230 affirms the global bus read operation with a partial response indicating that the L2 cache 230 holds the requested memory block in either the M or Me state, the process proceeds from block 1402 through page connector J to block 1480 of FIG. 9B .
- Block 1480 represents the fact that the M or Me snooper 236 updates its cache state differently depending upon whether the M or Me snooper 236 is local (i.e., within the same coherency domain) as the requesting L2 cache 230 as indicated by the scope indicator in the global bus read operation.
- the snooper 236 in the affirming L2 cache 230 may initiate transmission of the requested memory block to the requesting L2 cache 230 prior to receipt of the CR (i.e., provides “early” data), and upon receipt, the master 232 in the requesting L2 cache 230 places the requested memory block in its L2 cache array 300 in the Sr state (blocks 1481 and 1482 ).
- the snooper 236 in the affirming L2 cache 230 updates the state of the requested memory block from M to T or from Me to Te if the snooper 236 is not local to the requesting L2 cache 230 (block 1481 ) and updates the state of the requesting memory block from M to Tn or from Me to Ten if the snooper 236 is local (block 1482 ).
- the process then returns to FIG. 9A through page connector N and ends with distributed response logic 210 generating a CR indicating “success”, as depicted at block 1408 .
- Block 1412 indicates that the affirming Tx snooper 236 updates the state of the requested memory block differently depending upon whether the scope indicator of the global bus read operation indicated that the snooper 236 is within the coherency domain of the requesting L2 cache 230 .
- the Sr′ snooper 236 updates the state of the requested memory block to S and initiates transmission of the requested memory block to the requesting L2 cache 230 prior to receipt of the CR (blocks 1494 and 1495 ).
- the master 232 in the requesting L2 cache 230 places the requested memory block in L2 cache array 300 in the Sr state (blocks 1494 and 1495 ).
- the Tx snooper 236 updates the state of the requested memory block, if necessary, from Tn to T or from Ten to Te if the snooper 236 is not local to the requesting L2 cache 230 (block 1494 ), but leaves the state of the requested memory block unchanged if the Tx snooper 236 is local to the requesting L2 cache (block 1495 ). The process then returns to FIG. 9A through page connector N and ends with distributed response logic 210 generating a CR indicating “success”, as depicted at block 1408 .
- the process passes through page connector L to block 1488 of FIG. 9B .
- Block 1488 indicates that the affirming Tx snooper 236 updates the state of the requested memory block differently depending upon whether the scope indicator of the global bus read operation indicated that the snooper 236 is within the coherency domain of the requesting L2 cache 230 . In either case, the Tx snooper 236 that affirmed the global bus read operation initiates transmission of the requested memory block to the requesting L2 cache 230 after receipt of the CR (blocks 1489 and 1490 ).
- the master 232 in the requesting L2 cache 230 places the requested memory block in L2 cache directory 300 in the S state (since an Sr′ snooper 236 may be hidden within the local domain the requesting cache 236 and only one Sr′ snooper 236 is permitted in each domain for the requested memory block).
- the Tx snooper 236 updates the state of the requested memory block, if necessary, from Tn to T or from Ten to Te if the snooper 236 is not local to the requesting L2 cache 230 (block 1489 ), but leaves the state of the requested memory block unchanged if the Tx snooper 236 is local to the requesting L2 cache (block 1490 ).
- the process then returns to FIG. 9A through page connector N and ends with distributed response logic 210 generating a CR indicating “success”, as depicted at block 1408 .
- Block 1484 indicates that the affirming Tx snooper 236 updates the state of the requested memory block differently depending upon whether the scope indicator of the global bus read operation indicated that the snooper 236 is within the coherency domain of the requesting L2 cache 230 .
- the Tx snooper 236 that affirmed the global bus read operation initiates transmission of the requested memory block to the requesting L2 cache 230 after receipt of the CR (i.e., provides “late” data), the master 232 in the requesting L2 cache 230 places the requested memory block in its L2 cache array 300 in the Sr state (since no other Sr′ snooper 236 exists for the requested memory block in the local domain).
- the Tx snooper 236 updates the state of the requested memory block, if necessary, from Tn to T or from Ten to Te if the snooper 236 is not local to the requesting L2 cache 230 (block 1485 ), but leaves the state of the requested memory block unchanged if the Tx snooper 236 is local to the requesting L2 cache (block 1486 ). The process then returns to FIG. 9A through page connector N and ends with distributed response logic 210 generating a CR indicating “success”, as depicted at block 1408 .
- the global bus read operation is serviced in accordance with block 1422 .
- the Sr′ snooper 236 that affirmed the global bus read operation initiates transmission of the requested memory block to the requesting L2 cache 230 prior to receipt of CR and updates the state of the requested memory block in its L2 cache directory 302 to the S state.
- the master 232 in the requesting L2 cache 230 places the requested memory block in L2 cache array 300 in the Sr state.
- the process ends with distributed response logic 210 generating a CR indicating “success”, as depicted at block 1408 .
- response logic 210 if a snooper 222 provides a partial response indicating that it is responsible (i.e., the LPC) for the requested memory block but does not affirm the global bus read operation, response logic 210 generates a CR indicating “retry”, as depicted at block 1450 . As indicated by decision block 1442 , response logic 210 similarly generates a “retry” CR at block 1450 if a memory controller snooper 222 affirms the global bus read operation and an L2 cache snooper 236 provides a partial response indicating that it may hold the requested memory block in one of the M, Me, or Tx states but cannot affirm the global bus read operation. In each of these cases, response logic 210 generates a “retry” CR to cause the operation to be reissued because one of the possibly hidden snoopers 236 may be required to source the requested memory block to the requesting L2 cache 230 .
- the master 232 of the requesting L2 cache 230 handles the requested memory block in accordance with the partial responses compiled into the “success” CR represented at block 1408 .
- the requesting L2 cache 230 holds the requested memory block in the Me state (block 1456 ); the requesting L2 cache 230 holds the requested memory block in the Sr state if no Sr′ snooper 236 is possibly hidden and a S′ snooper 236 is possibly hidden; and the requesting L2 cache 230 holds the requested memory block in the S state if an Sr′ snooper 236 is possibly hidden.
- the memory controller snooper 222 determines whether to update the domain indicator for the requested memory block, as illustrated at blocks 1460 , 1462 , 1470 , 1472 and 1474 . If the CR indicates that the new cache state for the requested memory block is Me, the LPC snooper 222 determines whether it is within the same domain as the requesting L2 cache 230 (block 1460 ), for example, by reference to the scope indicator in the global bus read operation, and whether the domain indicator 504 indicates local or global (blocks 1460 and 1472 ).
- the LPC snooper 222 sets the domain indicator 504 to “local” if it is reset to “global” (block 1462 and 1464 ). If the LPC is not within the same domain as the requesting L2 cache 230 (block 1460 ), the LPC snooper 222 resets the domain indicator 504 to “global” if it is set to “local” (block 1472 and 1474 ).
- the LPC snooper 222 similarly determines whether it is within the same domain as the requesting L2 cache 230 (block 1470 ) and whether the domain indicator 504 indicates local or global (block 1472 ). If the LPC is within the same domain as the requesting L2 cache 230 (block 1470 ), no update to the domain indicator 504 is required. If, however, the LPC is not within the same domain as the requesting L2 cache 230 (block 1470 ), the LPC snooper 222 resets the domain indicator 504 to “global” if it is set to “local” (block 1472 and 1474 ). Thus, LPC snooper 222 updates the domain indicator 504 , if required, in response to receipt of the CR.
- FIG. 10 there is depicted a high level logical flowchart of an exemplary method of performing a local bus RWITM operation in a data processing system in accordance with the present invention.
- the process begins at block 1500 , for example, with a master 232 of an L2 cache 230 issuing a local bus RWITM operation its local interconnect 114 at block 748 of FIG. 7A .
- the various partial responses that snoopers 222 , 236 may provide to distributed response logic 210 are represented in FIG. 10 by the outcomes of decision blocks 1502 , 1510 , 1512 , 1520 , 1524 , 1530 , 1534 , 1540 and 1544 . These partial responses in turn determine the CR for the local bus RWITM operation.
- Block 1504 indicates the operations of the requesting L2 cache 230 and the affirming L2 cache 230 in response to the local bus RWITM operation.
- the snooper 236 in the affirming L2 cache 230 updates the cache state of the requested memory block from the M or Me state to the In state and may initiate transmission of the requested memory block to the requesting L2 cache 230 prior to receipt of the CR (i.e., provides “early” data).
- the master 232 in the requesting L2 cache 230 Upon receipt of the requested memory block, the master 232 in the requesting L2 cache 230 places the requested memory block in its L2 cache array 300 in the M state. The process ends with distributed response logic 210 generating a CR indicating “success”, as depicted at block 1506 .
- the snooper 236 in the affirming L2 cache 230 preferably updates the coherency state of the target memory block from the M or Me state to the I state (instead of the “tagged” In state) in response to receipt of a “possible intervening source” indication in conjunction with the local bus RWITM operation.
- the “possible intervening source” indication indicates that the requesting L2 cache 230 is coupled to the affirming L2 cache 230 by a private network connection 270 .
- the “possible intervening source” indication may be transmitted via interconnect fabric 114 , 110 as part of the bus operation or via private network connection 270 and may comprise, for example, a 1-bit signal or a multi-bit processor core identifier or cache identifier.
- the snooping L2 cache 230 in the event that it receives a subsequent CPU read request for the same target memory block from its associated processor core 200 while the coherency state with respect to the snooping L2 cache 230 for that memory block is I, will advantageously request the memory block from the requesting L2 cache 230 via L2.1 intervention via private network connection 270 in accordance with blocks 650 and 652 of FIG.
- Block 1510 if a snooper 236 affirms the local bus RWITM operation with a partial response indicating that the L2 cache 230 containing the snooper 236 holds the requested memory block in any of the T, Tn, Te or Ten states (generically designated as Tx in FIG. 10 ) and no Sr′ snooper 236 affirms the local bus RWITM operation (block 1512 ), the process passes to block 1514 .
- Block 1514 represents the Tx snooper 236 that affirmed the local bus RWITM operation initiating transmission of the requested memory block to the requesting L2 cache 230 in response to receipt of the CR from response logic 210 .
- the requesting L2 cache 230 holds the requested memory block in the M state. All valid affirming snoopers 236 update their respective cache states for the requested memory block to In.
- Block 1516 represents the Sr′ snooper 236 that affirmed the local bus RWITM operation initiating transmission of the requested memory block to the requesting L2 cache 230 prior to receipt of the CR provided by response logic 210 .
- the requesting L2 cache 230 holds the requested memory block in the M state. All valid affirming snoopers 236 update their respective cache states for the requested memory block to In.
- response logic 210 generates a CR dependent upon whether the Tx affirming snooper 236 held the requested memory block in one of the T/Te states or the Tn/Ten states. If the Tx snooper 236 was T or Te, response logic 210 generates a CR indicating “cleanup”, as shown at block 1518 . If, however, the Tx snooper 236 was Tn or Ten, response logic 210 advantageously restricts the scope of the cleanup operations to the local domain by generating a CR indicating “local cleanup”, as shown at block 1556 . The limited scope of cleanup operations is permitted because the existence of a Tn or Ten coherency state guarantees that no remote cache holds the requested memory block, meaning that coherency can be maintained without a wider broadcast of the local bus RWITM operation or attendant bus kill operations.
- the local bus RWITM operation cannot be serviced by a L2 cache snooper 236 without retry if no M, Me, or Tx snooper 236 (i.e., HPC) affirms the local bus RWITM operation to signify that it can mediate the data transfer. Accordingly, if an Sr′ snooper 236 affirms the local bus RWITM operation and supplies early data to the requesting L2 cache 230 as shown at block 1520 , the master 232 of the requesting L2 cache 230 discards the data provided by the Sr′ snooper 236 , as depicted at block 1522 .
- M, Me, or Tx snooper 236 i.e., HPC
- Block 1524 represents the differences in handling the local bus RWITM operation depending upon whether a snooper 236 of an L2 cache 230 provides a partial response affirming the local bus RWITM operation and indicating that the L2 cache 230 holds the address tag of the requested memory block in the Ig state. If so, any valid affirming snooper 236 (i.e., not Ig snoopers 236 ) invalidates the relevant cache entry (block 1532 ). If no M, Me, or Tx snooper 236 is possibly hidden by an incomplete partial response (block 1534 ), distributed response logic 210 provides a “go global” CR, as depicted at block 1536 .
- response logic 210 If, on the other hand, an Ig snooper 236 affirms the local bus RWITM operation and the complex of partial responses indicates an M, Me, or Tx snooper 236 is possibly hidden, response logic 210 generates a “retry” CR, as depicted at block 1538 . Thus, the affirmance of the local bus RWITM operation by an Ig snooper 236 will cause the operation to be reissued as a global operation if no HPC is possibly hidden in the local coherency domain.
- an Ig snooper 236 does not affirm the local bus RWITM operation at block 1524 , the local bus RWITM operation is handled in accordance with block 1530 and following blocks.
- no memory controller snooper 222 provides a partial response indicating that it is responsible (i.e., the LPC) for the requested memory block (block 1530 )
- each valid affirming snooper 236 updates the requested memory block in its respective L2 cache directory 302 to the In coherency state (block 1532 ).
- the CR generated by response logic 210 depends upon whether any partial responses indicate that an M, Me, or Tx snooper 236 may be hidden (block 1534 ).
- response logic 210 generates a “go global” CR at block 1536 to inform the master 232 that the local bus RWITM operation must be reissued as a global RWITM operation.
- response logic 210 generates a CR indicating “retry”, as depicted at block 1538 , because the operation may be serviced locally if retried.
- valid affirming snoopers 236 update their respective copies of the requested memory block to the In coherency state (block 1542 ), and response logic 210 provides a “retry” CR for the local bus RWITM operation (block 1538 ) if no M, Me, or Tx snooper 236 affirms the local bus RWITM operation and a snooper 222 provides a partial response indicating that it is the LPC but does not affirm the local bus RWITM operation.
- a “retry” CR is also generated at block 1538 , and snoopers 236 invalidate their respective copies of the requested memory block (block 1542 ) if no M, Me, or Tx snooper 236 affirmed the local bus RWTIM operation (blocks 1502 , 1510 ), a snooper 222 affirmed the local bus RWITM operation (block 1540 ), and an M, Me, Tx or Ig snooper 236 may be possibly hidden (block 1544 ).
- each valid affirming snooper 236 updates its respective copy of the requested memory block to the In coherency state.
- the LPC snooper 222 provides the requested memory block and associated domain indicator 504 to the requesting L2 cache 230 in response to receipt of the CR from response logic 210 .
- the master 232 of the requesting L2 cache 230 handles the data in accordance with the domain indicator 504 .
- master 232 discards the data received from the LPC snooper 222 , maintains an invalid coherency state with respect to the requested memory block (block 1552 ), and interprets the CR provided by response logic 210 as “go global” (block 1536 ).
- the master 232 places the requested memory block and domain indicator 504 in its L2 cache array 300 and sets the associated state field 306 to M (block 1546 ). If the partial responses and hence the CR indicate an S′ or Sr′ snooper 236 is possibly hidden (block 1554 ), the CR indicates local “cleanup” (block 1556 ), meaning that the requesting L2 cache 230 must invalidate the other valid locally cached copies of the requested memory block, if any, through one or more local bus kill operations. If no such S′ or Sr′ snoopers 236 are possibly hidden by incomplete partial responses, the CR indicates “success”, as depicted at block 1506 .
- the master of the local bus RWITM operation may speculatively perform a local cleanup as shown at block 1556 prior to receipt of the domain indicator 3004 from the LPC (block 1550 ). In this manner, the latency associated with data delivery from the LPC can be masked by the one or more local bus kill operations involved in the local cleanup operations.
- FIGS. 11A–11B there is illustrated a high level logical flowchart of an exemplary method of performing a global bus RWITM operation in a data processing system in accordance with the present invention.
- the process begins at block 1600 in response to the master 232 of a requesting L2 cache 230 issuing a global bus RWITM operation, for example, at block 754 of FIG. 7A .
- a snooper 236 affirms the global bus RWITM operation with a partial response indicating that the L2 cache 230 containing the snooper 236 holds the requested memory block in the M or Me state as shown at block 1602 , the M or Me snooper 236 provides early data to the requesting master 232 , which holds the requested memory block in the M state (block 1604 or block 1606 ).
- Response logic 210 generates a CR indicating “success”, as shown at block 1607 .
- the M or Me snooper 236 updates its cache state to either In or Ig depending upon whether or not it is local to (i.e., in the same coherency domain as) the requesting master 232 (block 1603 ).
- the M or Me snooper 236 determines it belongs to the same coherency domain as the requesting master 232 , for example, by reference to the scope indicator in the bus operation, the M or Me snooper 236 updates its cache state for the requested memory block to In (block 1606 ).
- the M or Me snooper 236 determines it does not belong to the same coherency domain as the requesting master 232 , the M or Me snooper 236 updates its cache state for the requested memory block to Ig in order to maintain a cached domain indicator for the requested memory block in its coherency domain (block 1604 ). Consequently, no retry-push is required in response to the global bus RWITM operation in order to update the domain indicator 504 in the LPC system memory 108 .
- block 1610 if a snooper 236 affirms the global bus RWITM operation with a partial response indicating that the L2 cache 230 containing the snooper 236 holds the requested memory block in either the Tn or Ten state, the process passes to block 1612 , which represents the Tn or Ten snooper 236 determining whether or not it is local to the requesting master 232 . If so, the global bus RWITM operation is handled in accordance with blocks 1614 and following blocks, which are described below.
- the global bus RWITM operation is serviced in accordance with either block 1618 or block 1620 , depending upon whether or not an Sr′ snooper 236 also affirmed the global bus RWITM operation.
- any valid affirming snooper 236 i.e., not an Ig snooper 236 ) other than the Tn or Ten snooper 236 updates its respective cache state for the requested memory block to I.
- the Tn or Ten snooper 236 provides late data in response to receipt of the CR.
- the requesting L2 cache 230 holds the requested memory block in the M state.
- the Tn or Ten snooper 236 updates its cache state to Ig, and any other valid affirming snooper 236 (i.e., not an Ig snooper 236 ) updates its respective cache state for the requested memory block to I.
- response logic 210 In either of the cases represented by blocks 1618 and 1620 , response logic 210 generates a CR dependent upon whether an S′ or Sr′ snooper 236 is possibly hidden and thus unable to invalidate its copy of the requested memory block in response to snooping the global bus RWITM operation. If response logic 210 makes a determination at block 1626 based upon the partial responses to the global bus RWITM operation that an S′ or Sr′ snooper 236 is possibly hidden, response logic 210 generates a CR indicating “cleanup”, as shown at block 1628 . Alternatively, if response logic 210 determines that no S′ or Sr′ snooper 236 is possibly hidden, response logic 210 generates a CR indicating “success”, as depicted at block 1607 .
- the Sr′ snooper 236 if an Sr′ snooper 236 affirmed the global bus RWITM operation, the Sr′ snooper 236 provides early data to the requesting master 232 , and each valid snooper 236 that affirmed the global bus RWITM operation updates its respective cache state for the entry containing the requested memory block to In. In response to receipt of the requested memory block, the requesting L2 cache 230 holds the requested memory block in the M state. Alternatively, as depicted at block 1622 , if an Sr′ snooper 236 does not affirm the global bus RWITM operation, the Tn or Ten snooper 236 provides late data in response to receipt of the CR. In response to receipt of the requested memory block, the requesting L2 cache 230 holds the requested memory block in the M state. In addition, each valid affirming snooper 236 updates its respective cache state for the requested memory block to In.
- response logic 210 In either of the cases represented by blocks 1624 and 1622 , response logic 210 generates a CR dependent upon whether an S′ or Sr′ snooper 236 is possibly hidden and thus unable to invalidate its copy of the requested memory block in response to snooping the global bus RWITM operation. If response logic 210 makes a determination at block 1625 based upon the partial responses to the global bus RWITM operation that an S′ or Sr′ snooper 236 is possibly hidden, response logic 210 generates a CR indicating “local cleanup”, as shown at block 1632 .
- the scope of the bus kill operations required to ensure coherency are advantageously limited to the local coherency domain containing the requesting L2 cache 230 and the (former) Tn or Ten snooper 236 .
- response logic 210 determines that no S′ or Sr′ snooper 236 is possibly hidden, response logic 210 generates a CR indicating “success”, as depicted at block 1607 .
- a T or Te snooper 236 affirms the global bus RWITM operation, the process passes to block 1632 , which represents the T or Te snooper 236 determining whether or not it is local to the requesting master 232 . If so, the global bus RWITM operation is handled in accordance with blocks 1638 and following blocks, which are described in detail below.
- the global bus RWITM operation is serviced in accordance with either block 1636 or block 1635 , depending upon whether or not an Sr′ snooper 236 affirmed the global bus RWITM operation.
- an Sr′ snooper 236 affirmed the global bus RWITM operation
- the Sr′ snooper 236 provides early data to the requesting master 232 , and the T or Te snooper 236 that affirmed the global bus RWITM operation updates its cache state for the entry containing the requested memory block to Ig.
- the requesting L2 cache 230 holds the requested memory block in the M state.
- any valid affirming snooper 236 other than the T or Te snooper 236 updates its respective cache state for the requested memory block to I.
- the T or Te snooper 236 if an Sr′ snooper 236 does not affirm the global bus RWITM operation, the T or Te snooper 236 provides late data in response to receipt of a CR. In response to receipt of the requested memory block, the requesting L2 cache 230 holds the requested memory block in the M state. In addition, the T or Te snooper 236 updates its cache state to Ig, and any other valid affirming snooper 236 updates its respective cache state for the requested memory block to I.
- response logic 210 In either of the cases represented by block 1635 or block 1636 , response logic 210 generates a CR dependent upon whether an S′ or Sr′ snooper 236 is possibly hidden and thus unable to invalidate its copy of the requested memory block in response to snooping the global bus RWITM operation. If response logic 210 makes a determination at block 1644 based upon the partial responses to the bus RWITM operation that an S′ or Sr′ snooper 236 is possibly hidden, response logic 210 generates a CR indicating “cleanup”, as shown at block 1626 . Alternatively, if response logic 210 determines that no S′ or Sr′ snooper 236 is possibly hidden, response logic 210 generates a CR indicating “success”, as depicted at block 1607 .
- the global bus RWITM operation is serviced in accordance with either block 1640 or block 1642 , depending upon whether an Sr′ snooper 236 also affirmed the global bus RWITM operation. That is, as shown at block 1640 , if no Sr′ snooper 236 affirms the global bus RWITM operation (block 1638 ), the T or Te snooper 236 that affirmed the global bus RWITM operation initiates transmission of the requested memory block to the requesting L2 cache 230 in response to receipt of the CR (i.e., provides “late” data).
- the requesting L2 cache 230 In response to receipt of the requested memory block, the requesting L2 cache 230 holds the requested memory block in the M state. In addition, each valid affirming snooper 236 updates its respective coherency state for the requested memory block to In. Alternatively, as depicted at block 1642 , if an Sr′ snooper 236 affirms the global bus RWITM operation (block 1638 ), the Sr′ snooper 236 initiates transmission of the requested memory block to the requesting L2 cache 230 prior to receipt of the CR (i.e., provides “early” data). In response to receipt of the requested memory block, the requesting L2 cache 230 holds the requested memory block in the M state.
- each valid affirming snooper 236 within the same coherency domain as the requesting master 232 updates its respective coherency state for the requested memory block to In.
- the process passes to block 1644 , which has been described.
- each valid affirming snooper 236 if any, updates the coherency state of its respective copy of the requested memory block, either to the In coherency state if the affirming snooper 236 is within the same coherency domain as the master 232 or to the I coherency state otherwise (block 1672 ).
- Response logic 210 also generates a CR indicating “retry”, as depicted at block 1674 .
- data provided by an Sr′ snooper 236 affirming the global bus RWITM operation, if any, is discarded by the master 232 (blocks 1668 and 1670 ).
- affirming snoopers 236 similarly update the coherency states of their respective copies of the requested memory block at block 1672 and response logic 210 generates a “retry” CR at block 1674 if a memory controller snooper 222 affirms the global bus RWITM operation (block 1660 ) and an L2 cache snooper 236 provides a partial response indicating that it may hold the requested memory block in one of the M, Me, or Tx states but cannot affirm the global bus RWITM operation (block 1662 ).
- the LPC snooper 222 in response to the CR, provides the requested memory block to the requesting L2 cache 230 , which obtains the requested memory block in the M state.
- each valid affirming snooper 236 if any, updates the coherency state of its respective copy of the requested memory block, either to the In coherency state if the affirming snooper 236 is within the same coherency domain as the master 232 or to the I coherency state otherwise.
- blocks 1680 – 1686 which collectively represent the LPC snooper 222 determining whether or not to update the domain indicator 504 for the requested memory block based upon whether the LPC snooper 222 is local to the requesting master 232 (block 1680 ) and the present state of the domain indicator (blocks 1682 and 1684 ). If the LPC snooper 222 is local to the requesting L2 cache 230 and the domain indicator 504 in system memory 108 is set to indicate “local”, no update is required, and the process passes through page connector P to block 1625 of FIG. 11A , which has been described.
- LPC snooper 222 changes the state of the domain indicator 504 at block 1686 if LPC snooper 222 is local to the requesting master 232 and domain indicator 504 is reset to indicate “global” or if LPC snooper 222 is not local to the requesting master 232 and domain indicator 504 is reset to indicate “local”.
- the requesting L2 cache 230 receives a “cleanup” CR at block 1628 , indicating that it must invalidate any other valid cached copies of the requested memory block. If no S′ or Sr′ snoopers 236 are possibly hidden by incomplete partial responses, response logic 210 generates a “success” CR, as depicted at block 1607 .
- FIG. 12 there is illustrated a high level logical flowchart of an exemplary method of performing a local bus DClaim operation in a data processing system in accordance with the present invention.
- the process begins at block 1700 , for example, with a master 232 issuing a local bus DClaim operation on a local interconnect 114 at block 732 of FIG. 7A .
- the various partial responses that snoopers 236 may provide to distributed response logic 210 in response to the local bus DClaim operation are represented in FIG. 12 by the outcomes of decision blocks 1702 , 1710 , 1720 , 1740 , and 1744 . These partial responses in turn determine what CR response logic 210 generates for the local bus DClaim operation.
- any snooper 236 issues a partial response downgrading the local bus DClaim operation to a bus RWITM operation as illustrated, for example, at blocks 748 and 754 of FIG. 7A , each other affirming snooper 236 holding the requested memory block in a valid state updates the coherency state of its respective copy of the requested memory block to the In state, as shown at block 1703 .
- distributed response logic 210 In response to the local bus DClaim operation and the partial responses, distributed response logic 210 generates a CR indicating “downgrade”, as shown at block 1704 . In response to this CR, the master 232 of the local bus DClaim operation must next attempt to gain ownership of the requested memory block utilizing a local bus RWITM operation, as depicted at block 748 of FIG. 7A .
- a snooper 236 affirms the local bus DClaim operation with a partial response indicating that the L2 cache 230 containing the snooper 236 holds the requested memory block in either the T or Te state as shown at block 1710 , the process passes to block 1712 . Because no data transfer is required in response to a bus DClaim operation, block 1712 indicates that the master 232 in the requesting L2 cache 230 updates the cache state of the requested memory block in L2 cache directory 302 to the M state. In addition, each valid affirming snooper 236 , if any, updates the coherency state of its respective copy of the requested memory block to the In coherency state.
- distributed response logic 210 generates a CR indicating “cleanup”, meaning that the requesting L2 cache 230 must issue one or more bus kill operations to invalidate copies of the requested memory block, if any, held outside of the local coherency domain.
- block 1740 if a Tn or Ten snooper 236 affirms the local bus DClaim operation, the process passes to block 1742 . Because no data transfer is required in response to a bus DClaim operation, block 1742 indicates that the master 232 in the requesting L2 cache 230 updates the cache state of the requested memory block in L2 cache directory 302 to the M state. Each valid affirming snooper 236 , if any, updates the coherency state for the requested memory block to In. As shown at block 1744 , distributed response logic 210 generates a CR that is dependent upon whether the partial responses received by response logic 210 indicate that an Sr′ or S′ snooper 236 may be possibly hidden.
- distributed response logic 210 If not, distributed response logic 210 generates a response indicating “success”, as shown at block 1746 , because the presence of the Tn or Ten coherency state guarantees that no L2 cache 230 outside of the local coherency domain holds a copy of the requested memory block. If the partial responses indicate that an Sr′ or S′ snooper 236 may be possibly hidden, response logic 210 generates a CR indicating “local cleanup”, as shown at block 1748 . Only local cleanup operations are required because the Tn or Ten coherency state again guarantees that no L2 cache 230 outside of the local coherency domain holds a valid copy of the requested memory block.
- each valid affirming snoopers 236 updates its respective coherency state for the requested memory block to the In state (block 1721 ).
- response logic 210 generates a CR indicating “retry”, as depicted at block 1722 .
- the requesting master 232 may reissue the bus DClaim operation as either a local or global operation, as explained above with reference to block 736 of FIG. 7A . If, however, no snooper downgrades the local bus DClaim operation (block 1702 ), no Tx snooper 236 affirms the bus DClaim operation or is possibly hidden (blocks 1702 , 1710 , 1740 , and 1720 ), response logic 210 provides a “go global” CR, as shown at block 1732 , and each affirming snooper 236 , if any, having a valid copy of the requested memory block updates the coherency state of its respective copy of the requested memory block to In, as shown at block 1730 . In response to the “go global” CR, the master 232 reissues the bus DClaim operation as a global operation, as depicted at block 740 of FIG. 7A .
- FIG. 13 there is depicted a high level logical flowchart of an exemplary method of performing a global bus DClaim operation in a data processing system in accordance with the present invention.
- the process begins at block 1800 , for example, with a master 232 of an L2 cache 230 issuing a global bus DClaim operation on system interconnect 110 at block 740 of FIG. 7A .
- the various partial responses that snoopers 222 , 236 may provide to distributed response logic 210 in response to the global bus DClaim operation are represented in FIG. 13 by the outcomes of decision blocks 1802 , 1810 , 1818 , 1830 , 1840 , 1842 and 1819 . These partial responses in turn determine what CR response logic 210 generates for the global bus DClaim operation.
- each valid affirming snooper 236 other than the downgrading snooper 236 updates the coherency state of its copy of the requested memory block, as shown at block 1803 . That is, each valid affirming snooper 236 , if any, updates the coherency state of its respective copy of the requested memory block to the In coherency state if the affirming snooper 236 is within the same coherency domain as the master 232 and to the I coherency state otherwise.
- distributed response logic 210 generates a CR indicating “downgrade”, as shown at block 1804 .
- the master 232 of the global bus DClaim operation must next attempt to gain ownership of the requested memory block utilizing a bus RWITM operation, as depicted at blocks 748 and 754 of FIG. 7A .
- Block 1812 depicts the Tx snooper 236 determining whether it is local to the requesting master 232 . If not, the Tx snooper 236 updates the state of its relevant entry to Ig to maintain a cached domain indicator for the requested memory block as shown at block 1814 .
- Tx e.g., T, Te, Tn, or Ten
- the requesting master 232 updates the coherency state of its copy of the requested memory block to M, and each valid affirming snooper 236 other than the Tx snooper 236 updates its coherency state for the requested memory block to I (block 1814 ).
- the global bus DClaim operation is handled in accordance with block 1816 .
- the master 232 in the requesting L2 cache 230 updates the state of its copy of the requested memory block to the M state.
- each valid affirming snooper 236 if any, updates the coherency state of its respective copy of the requested memory block to the In coherency state if the affirming snooper 236 is within the same coherency domain as the master 232 and to the I coherency state otherwise.
- the process ends with distributed response logic 210 generating a CR indicating “success” (block 1822 ). If, on the other hand, a determination is made at block 1818 that at least one partial response indicating the presence of a possibly hidden S′ or Sr′ snooper 236 was given in response to the global bus DClaim operation, some type of cleanup operation will be required.
- distributed response logic 210 If the affirming Tx snooper 236 is within the same coherency domain as the requesting master 232 and, prior to the operation, was in one of the Te and Ten states, distributed response logic 210 generates a CR indicating “local cleanup” (block 1824 ), meaning that the requesting L2 cache 230 must issue one or more local bus kill operations to invalidate the requested memory block in any such hidden S′ or Sr′ snooper 236 .
- Tx snooper 236 If the affirming Tx snooper 236 is not within the same coherency domain as the requesting master 232 or the affirming Tx snooper 236 was, prior to the operation, in one of the T or Te coherency states, global cleanup is required, and response logic 210 generates a CR indicating “cleanup” (block 1820 ). Thus, the presence of a Tn or Ten coherency state can again be utilized to limit the scope of bus kill operations.
- each valid affirming snooper 236 if any, updates the coherency state of its respective copy of the requested memory block to the In coherency state if the affirming snooper 236 is within the same coherency domain as the master 232 and to the I coherency state otherwise (block 1843 ).
- response logic 210 generates a CR indicating “retry”, as depicted at block 1844 .
- each valid affirming snooper also updates the coherency state of its respective copy of the requested memory block at block 1843 , and response logic 210 similarly generates a “retry” CR at block 1844 if a memory controller snooper 222 affirms the bus DClaim operation (block 1840 ) and an Tx snooper 236 may be possibly hidden (block 1842 ).
- the present invention provides a cache memory, processing unit, data processing system and method in which a snooping cache memory updates a directory entry for a target memory block of an exclusive memory access operation to a selected one of multiple invalid coherency states based upon whether or not its receives indication that the source of the memory access request is a possible direct intervention source coupled to the snooping cache memory by a private network connection.
- the snooping cache can then accurately determine, in response to a subsequent memory access request, whether or not to request direct intervention of the target memory block via the private network connection prior to broadcasting on a shared interconnect fabric a bus operation requesting the target memory block.
- the private network connection 270 by which one cache may request direct intervention from another cache affiliated with a different processing unit is depicted and described as coupling all caches at a particular hierarchy level within a particular single integrated circuit processing unit.
- the private cache-to-cache network connection may have a narrower scope, for example, coupling fewer than all caches at a given hierarchy level within a particular integrated circuit processing unit, or may have a broader scope, for example, coupling caches in multiple different integrated circuit processing units within the same MCM.
Abstract
Description
-
- 1. U.S. patent application Ser. No. 11/055,305;
- 2. U.S. patent application Ser. No. 11/056,673; and
- 3. U.S. patent application Ser. No. 11/095,734.
TABLE I | |
Request | Description |
READ | Requests a copy of the image of a memory |
block for query purposes | |
RWITM (Read-With- | Requests a unique copy of the image of |
Intent-To-Modify) | a memory block with the intent to update |
(modify) it and requires destruction of | |
other copies, if any | |
DCLAIM (Data Claim) | Requests authority to promote an existing |
query-only copy of memory block to a | |
unique copy with the intent to update | |
(modify) it and requires destruction of | |
other copies, if any | |
DCBZ (Data Cache | Requests authority to create a new unique |
Block Zero) | copy of a memory block without regard to |
its present state and subsequently modify | |
its contents; requires destruction of other | |
copies, if any | |
CASTOUT | Copies the image of a memory block from a |
higher level of memory to a lower level | |
of memory in preparation for the | |
destruction of the higher level copy | |
WRITE | Requests authority to create a new unique |
copy of a memory block without regard to | |
its present state and immediately copy the | |
image of the memory block from a higher | |
level memory to a lower level memory in | |
preparation for the destruction of the | |
higher level copy | |
PARTIAL WRITE | Requests authority to create a new unique |
copy of a partial memory block without | |
regard to its present state and immediately | |
copy the image of the partial memory block | |
from a higher level memory to a lower level | |
memory in preparation for the destruction of | |
the higher level copy | |
TABLE II | ||||||
Cache | Consistent | Cached outside | Legal concurrent | |||
state | HPC? | Unique? | Data source? | with LPC? | local domain? | states |
M | yes | yes | yes, before CR | no | no | I, Ig, In (& LPC) |
Me | yes | yes | yes, before CR | yes | no | I, Ig, In (& LPC) |
T | yes | unknown | yes, after CR if none | no | unknown | Sr, S, I, Ig, In (& LPC) |
provided before CR | ||||||
Tn | yes | unknown | yes, after CR if none | no | no | Sr, S, I, Ig, In (& LPC) |
provided before CR | ||||||
Te | yes | unknown | yes, after CR if none | yes | unknown | Sr, S, I, Ig, In (& LPC) |
provided before CR | ||||||
Ten | yes | unknown | yes, after CR if none | yes | no | Sr, S, I, Ig, In (& LPC) |
provided before CR | ||||||
Sr | no | unknown | yes, before CR | unknown | unknown | T, Tn, Te, Ten, S, I, |
Ig, In (& LPC) | ||||||
S | no | unknown | no | unknown | unknown | T, Tn, Te, Ten, Sr, S, |
I, Ig, In (& LPC) | ||||||
I | no | n/a | no | n/a | unknown | M, Me, T, Tn, Te, Ten, Sr, S, |
I, Ig, In (& LPC) | ||||||
Ig | no | n/a | no | n/a | Assumed so, in | M, Me, T, Tn, Te, Ten, Sr, |
absence of other | S, I, Ig, In (& LPC) | |||||
information | ||||||
In | no | n/a | no | n/a | Assumed not, in | M, Me, T, Tn, Te, Ten, Sr, |
absence of other | S, I, Ig, In (& LPC) | |||||
information | ||||||
TABLE III | |||
Domain of master | Cache | Partial response | Partial response |
of read-type | state in | (adequate resources | (adequate resources |
request | directory | available) | unavailable) |
“local” (i.e., | Sr | Sr′ affirm | Sr′ possibly |
within same | hidden | ||
domain) | |||
“remote” (i.e., | Sr | S′ affirm | S′ possibly |
not within same | hidden | ||
domain) | |||
“local” (i.e., | S | S′ affirm | S′ possibly |
within same | hidden | ||
domain) | |||
“remote” (i.e., | S | S′ affirm | S′ possibly |
not within same | hidden | ||
domain) | |||
Assuming the response behavior set forth above in Table III, the average data latency for shared data can be significantly decreased by increasing the number of shared copies of memory blocks distributed within an SMP data processing system that may serve as data sources.
Claims (19)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US11/109,085 US7237070B2 (en) | 2005-04-19 | 2005-04-19 | Cache memory, processing unit, data processing system and method for assuming a selected invalid coherency state based upon a request source |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US11/109,085 US7237070B2 (en) | 2005-04-19 | 2005-04-19 | Cache memory, processing unit, data processing system and method for assuming a selected invalid coherency state based upon a request source |
Publications (2)
Publication Number | Publication Date |
---|---|
US20060236037A1 US20060236037A1 (en) | 2006-10-19 |
US7237070B2 true US7237070B2 (en) | 2007-06-26 |
Family
ID=37109893
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US11/109,085 Expired - Fee Related US7237070B2 (en) | 2005-04-19 | 2005-04-19 | Cache memory, processing unit, data processing system and method for assuming a selected invalid coherency state based upon a request source |
Country Status (1)
Country | Link |
---|---|
US (1) | US7237070B2 (en) |
Cited By (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20080071994A1 (en) * | 2006-09-19 | 2008-03-20 | Fields James S | Processor, Data Processing System and Method Supporting Improved Coherency Management of Castouts |
US20090113140A1 (en) * | 2007-10-31 | 2009-04-30 | Tuan Quach | Reducing latency in responding to a snoop request |
US9727462B2 (en) | 2013-01-30 | 2017-08-08 | Hewlett Packard Enterprise Development Lp | Runtime backup of data in a memory module |
Families Citing this family (12)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20070143546A1 (en) * | 2005-12-21 | 2007-06-21 | Intel Corporation | Partitioned shared cache |
US8108618B2 (en) * | 2007-10-30 | 2012-01-31 | International Business Machines Corporation | Method and apparatus for maintaining memory data integrity in an information handling system using cache coherency protocols |
US8266386B2 (en) | 2007-10-30 | 2012-09-11 | International Business Machines Corporation | Structure for maintaining memory data integrity in a processor integrated circuit using cache coherency protocols |
US20090132060A1 (en) * | 2007-11-21 | 2009-05-21 | Winston Jenks | Foundation fieldbus simulation system |
US7836257B2 (en) * | 2007-12-19 | 2010-11-16 | International Business Machines Corpation | System and method for cache line replacement selection in a multiprocessor environment |
US8296520B2 (en) * | 2007-12-19 | 2012-10-23 | International Business Machines Corporation | System and method for optimizing neighboring cache usage in a multiprocessor environment |
US8397029B2 (en) | 2007-12-19 | 2013-03-12 | International Business Machines Corporation | System and method for cache coherency in a multiprocessor system |
US8635411B2 (en) | 2011-07-18 | 2014-01-21 | Arm Limited | Data processing apparatus and method for managing coherency of cached data |
US9477600B2 (en) | 2011-08-08 | 2016-10-25 | Arm Limited | Apparatus and method for shared cache control including cache lines selectively operable in inclusive or non-inclusive mode |
CN109240945B (en) | 2014-03-26 | 2023-06-06 | 阿里巴巴集团控股有限公司 | Data processing method and processor |
WO2017123208A1 (en) * | 2016-01-12 | 2017-07-20 | Hewlett Packard Enterprise Development Lp | Partially coherent memory transfer |
US11030102B2 (en) * | 2018-09-07 | 2021-06-08 | Apple Inc. | Reducing memory cache control command hops on a fabric |
Citations (6)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20030009637A1 (en) * | 2001-06-21 | 2003-01-09 | International Business Machines Corporation | Decentralized global coherency management in a multi-node computer system |
US6606676B1 (en) * | 1999-11-08 | 2003-08-12 | International Business Machines Corporation | Method and apparatus to distribute interrupts to multiple interrupt handlers in a distributed symmetric multiprocessor system |
US20030154350A1 (en) * | 2002-01-24 | 2003-08-14 | Edirisooriya Samantha J. | Methods and apparatus for cache intervention |
US7096323B1 (en) * | 2002-09-27 | 2006-08-22 | Advanced Micro Devices, Inc. | Computer system with processor cache that stores remote cache presence information |
US20060224833A1 (en) * | 2005-03-31 | 2006-10-05 | International Business Machines Corporation | Data processing system, cache system and method for issuing a request on an interconnect fabric without reference to a lower level cache based upon a tagged cache state |
US7162590B2 (en) * | 2003-07-02 | 2007-01-09 | Arm Limited | Memory bus within a coherent multi-processing system having a main portion and a coherent multi-processing portion |
-
2005
- 2005-04-19 US US11/109,085 patent/US7237070B2/en not_active Expired - Fee Related
Patent Citations (6)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6606676B1 (en) * | 1999-11-08 | 2003-08-12 | International Business Machines Corporation | Method and apparatus to distribute interrupts to multiple interrupt handlers in a distributed symmetric multiprocessor system |
US20030009637A1 (en) * | 2001-06-21 | 2003-01-09 | International Business Machines Corporation | Decentralized global coherency management in a multi-node computer system |
US20030154350A1 (en) * | 2002-01-24 | 2003-08-14 | Edirisooriya Samantha J. | Methods and apparatus for cache intervention |
US7096323B1 (en) * | 2002-09-27 | 2006-08-22 | Advanced Micro Devices, Inc. | Computer system with processor cache that stores remote cache presence information |
US7162590B2 (en) * | 2003-07-02 | 2007-01-09 | Arm Limited | Memory bus within a coherent multi-processing system having a main portion and a coherent multi-processing portion |
US20060224833A1 (en) * | 2005-03-31 | 2006-10-05 | International Business Machines Corporation | Data processing system, cache system and method for issuing a request on an interconnect fabric without reference to a lower level cache based upon a tagged cache state |
Cited By (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20080071994A1 (en) * | 2006-09-19 | 2008-03-20 | Fields James S | Processor, Data Processing System and Method Supporting Improved Coherency Management of Castouts |
US7689771B2 (en) * | 2006-09-19 | 2010-03-30 | International Business Machines Corporation | Coherency management of castouts |
US20090113140A1 (en) * | 2007-10-31 | 2009-04-30 | Tuan Quach | Reducing latency in responding to a snoop request |
US7779211B2 (en) * | 2007-10-31 | 2010-08-17 | Intel Corporation | Reducing latency in responding to a snoop request |
US9727462B2 (en) | 2013-01-30 | 2017-08-08 | Hewlett Packard Enterprise Development Lp | Runtime backup of data in a memory module |
Also Published As
Publication number | Publication date |
---|---|
US20060236037A1 (en) | 2006-10-19 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US8140770B2 (en) | Data processing system and method for predictively selecting a scope of broadcast of an operation | |
US7389388B2 (en) | Data processing system and method for efficient communication utilizing an in coherency state | |
US7536513B2 (en) | Data processing system, cache system and method for issuing a request on an interconnect fabric without reference to a lower level cache based upon a tagged cache state | |
US7237070B2 (en) | Cache memory, processing unit, data processing system and method for assuming a selected invalid coherency state based upon a request source | |
US7716428B2 (en) | Data processing system, cache system and method for reducing imprecise invalid coherency states | |
US7404046B2 (en) | Cache memory, processing unit, data processing system and method for filtering snooped operations | |
US7743218B2 (en) | Updating an invalid coherency state in response to snooping an operation | |
US7543116B2 (en) | Data processing system, cache system and method for handling a flush operation in a data processing system having multiple coherency domains | |
US8495308B2 (en) | Processor, data processing system and method supporting a shared global coherency state | |
US7783841B2 (en) | Efficient coherency communication utilizing an IG coherency state | |
US7467323B2 (en) | Data processing system and method for efficient storage of metadata in a system memory | |
US7480772B2 (en) | Data processing system and method for efficient communication utilizing an Tn and Ten coherency states | |
US7577797B2 (en) | Data processing system, cache system and method for precisely forming an invalid coherency state based upon a combined response | |
US7454578B2 (en) | Data processing system and method for predictively selecting a scope of broadcast of an operation utilizing a location of a memory | |
US7512742B2 (en) | Data processing system, cache system and method for precisely forming an invalid coherency state indicating a broadcast scope | |
US7774555B2 (en) | Data processing system and method for efficient coherency communication utilizing coherency domain indicators | |
US7469322B2 (en) | Data processing system and method for handling castout collisions | |
US7584331B2 (en) | Data processing system and method for selectively updating an invalid coherency state in response to snooping a castout | |
US7725619B2 (en) | Data processing system and method that permit pipelining of I/O write operations and multiple operation scopes |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: INTERNATIONAL BUSINESS MACHINES CORPORATION, NEW YFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:GUTHRIE, GUY L.;SAWDEY, AARON C.;STARKE, WILLIAM J.;AND OTHERS;REEL/FRAME:016188/0443;SIGNING DATES FROM 20050408 TO 20050414 |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
REMI | Maintenance fee reminder mailed | ||
FPAY | Fee payment |
Year of fee payment: 4 |
|
SULP | Surcharge for late payment | ||
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:INTERNATIONAL BUSINESS MACHINES CORPORATION;REEL/FRAME:026664/0866Effective date: 20110503 |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044127/0735Effective date: 20170929 |
|
FEPP | Fee payment procedure |
Free format text: MAINTENANCE FEE REMINDER MAILED (ORIGINAL EVENT CODE: REM.); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
LAPS | Lapse for failure to pay maintenance fees |
Free format text: PATENT EXPIRED FOR FAILURE TO PAY MAINTENANCE FEES (ORIGINAL EVENT CODE: EXP.); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
STCH | Information on status: patent discontinuation |
Free format text: PATENT EXPIRED DUE TO NONPAYMENT OF MAINTENANCE FEES UNDER 37 CFR 1.362 |
|
FP | Lapsed due to failure to pay maintenance fee |
Effective date: 20190626 |