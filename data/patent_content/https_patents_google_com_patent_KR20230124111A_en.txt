KR20230124111A - Secure multi-party reach and frequency estimation - Google Patents
Secure multi-party reach and frequency estimation Download PDFInfo
- Publication number
- KR20230124111A KR20230124111A KR1020237027886A KR20237027886A KR20230124111A KR 20230124111 A KR20230124111 A KR 20230124111A KR 1020237027886 A KR1020237027886 A KR 1020237027886A KR 20237027886 A KR20237027886 A KR 20237027886A KR 20230124111 A KR20230124111 A KR 20230124111A
- Authority
- KR
- South Korea
- Prior art keywords
- processing system
- data processing
- data
- vector
- encrypted
- Prior art date
Links
- 239000013598 vector Substances 0.000 claims abstract description 356
- 238000000034 method Methods 0.000 claims abstract description 326
- 238000012545 processing Methods 0.000 claims description 583
- 230000006870 function Effects 0.000 claims description 161
- 239000011159 matrix material Substances 0.000 claims description 81
- 230000005540 biological transmission Effects 0.000 claims description 9
- 230000006855 networking Effects 0.000 abstract description 9
- 208000031968 Cadaver Diseases 0.000 description 158
- 238000009826 distribution Methods 0.000 description 75
- 238000004422 calculation algorithm Methods 0.000 description 46
- 230000008569 process Effects 0.000 description 46
- 238000010586 diagram Methods 0.000 description 32
- 238000004891 communication Methods 0.000 description 26
- 238000004364 calculation method Methods 0.000 description 22
- 238000013459 approach Methods 0.000 description 18
- 230000035945 sensitivity Effects 0.000 description 17
- 238000003780 insertion Methods 0.000 description 16
- 230000037431 insertion Effects 0.000 description 16
- 230000000694 effects Effects 0.000 description 15
- 230000000670 limiting effect Effects 0.000 description 15
- 230000036961 partial effect Effects 0.000 description 15
- 238000003860 storage Methods 0.000 description 15
- 238000004590 computer program Methods 0.000 description 13
- 239000007788 liquid Substances 0.000 description 13
- 238000012614 Monte-Carlo sampling Methods 0.000 description 12
- 230000003993 interaction Effects 0.000 description 11
- 230000009471 action Effects 0.000 description 9
- 238000012937 correction Methods 0.000 description 9
- 230000006872 improvement Effects 0.000 description 8
- 238000005259 measurement Methods 0.000 description 8
- 230000004931 aggregating effect Effects 0.000 description 7
- 230000007704 transition Effects 0.000 description 7
- 238000004458 analytical method Methods 0.000 description 6
- 238000010276 construction Methods 0.000 description 6
- 238000005516 engineering process Methods 0.000 description 6
- 230000003287 optical effect Effects 0.000 description 6
- 229910052709 silver Inorganic materials 0.000 description 6
- 239000004332 silver Substances 0.000 description 6
- 238000003491 array Methods 0.000 description 5
- 230000004044 response Effects 0.000 description 5
- 238000004088 simulation Methods 0.000 description 5
- 238000004519 manufacturing process Methods 0.000 description 4
- 239000000203 mixture Substances 0.000 description 4
- 230000008901 benefit Effects 0.000 description 3
- 238000007405 data analysis Methods 0.000 description 3
- 238000000354 decomposition reaction Methods 0.000 description 3
- 230000010354 integration Effects 0.000 description 3
- 238000003012 network analysis Methods 0.000 description 3
- 238000010606 normalization Methods 0.000 description 3
- 230000000644 propagated effect Effects 0.000 description 3
- 230000002829 reductive effect Effects 0.000 description 3
- 229920006395 saturated elastomer Polymers 0.000 description 3
- 230000001953 sensory effect Effects 0.000 description 3
- 239000007787 solid Substances 0.000 description 3
- 238000012546 transfer Methods 0.000 description 3
- 241000499489 Castor canadensis Species 0.000 description 2
- 235000011779 Menyanthes trifoliata Nutrition 0.000 description 2
- 239000000654 additive Substances 0.000 description 2
- 230000000996 additive effect Effects 0.000 description 2
- 230000002146 bilateral effect Effects 0.000 description 2
- 230000001413 cellular effect Effects 0.000 description 2
- 230000008859 change Effects 0.000 description 2
- 230000007423 decrease Effects 0.000 description 2
- 230000003247 decreasing effect Effects 0.000 description 2
- 238000009795 derivation Methods 0.000 description 2
- 238000005315 distribution function Methods 0.000 description 2
- 238000007667 floating Methods 0.000 description 2
- 238000012986 modification Methods 0.000 description 2
- 230000004048 modification Effects 0.000 description 2
- 238000005070 sampling Methods 0.000 description 2
- 238000013515 script Methods 0.000 description 2
- 238000000926 separation method Methods 0.000 description 2
- 230000009466 transformation Effects 0.000 description 2
- 230000001131 transforming effect Effects 0.000 description 2
- 238000009827 uniform distribution Methods 0.000 description 2
- 238000012935 Averaging Methods 0.000 description 1
- 238000007476 Maximum Likelihood Methods 0.000 description 1
- 238000000342 Monte Carlo simulation Methods 0.000 description 1
- 230000002776 aggregation Effects 0.000 description 1
- 238000004220 aggregation Methods 0.000 description 1
- 238000000540 analysis of variance Methods 0.000 description 1
- 230000001174 ascending effect Effects 0.000 description 1
- 230000002238 attenuated effect Effects 0.000 description 1
- 238000005284 basis set Methods 0.000 description 1
- 238000012512 characterization method Methods 0.000 description 1
- 239000003795 chemical substances by application Substances 0.000 description 1
- 230000002860 competitive effect Effects 0.000 description 1
- 239000002131 composite material Substances 0.000 description 1
- 230000001010 compromised effect Effects 0.000 description 1
- 230000001186 cumulative effect Effects 0.000 description 1
- 238000013016 damping Methods 0.000 description 1
- 238000012217 deletion Methods 0.000 description 1
- 230000037430 deletion Effects 0.000 description 1
- 238000013461 design Methods 0.000 description 1
- 238000002474 experimental method Methods 0.000 description 1
- 239000000835 fiber Substances 0.000 description 1
- 238000007689 inspection Methods 0.000 description 1
- 230000002452 interceptive effect Effects 0.000 description 1
- 238000012886 linear function Methods 0.000 description 1
- 239000004973 liquid crystal related substance Substances 0.000 description 1
- 238000007726 management method Methods 0.000 description 1
- 238000013507 mapping Methods 0.000 description 1
- 238000000691 measurement method Methods 0.000 description 1
- 230000007246 mechanism Effects 0.000 description 1
- 238000012544 monitoring process Methods 0.000 description 1
- 238000004806 packaging method and process Methods 0.000 description 1
- 230000009467 reduction Effects 0.000 description 1
- 238000013468 resource allocation Methods 0.000 description 1
- 230000000717 retained effect Effects 0.000 description 1
- 238000012552 review Methods 0.000 description 1
- 239000004065 semiconductor Substances 0.000 description 1
- 238000013179 statistical model Methods 0.000 description 1
- 239000000758 substrate Substances 0.000 description 1
- 238000012360 testing method Methods 0.000 description 1
- 238000012795 verification Methods 0.000 description 1
- 230000000007 visual effect Effects 0.000 description 1
- 238000012800 visualization Methods 0.000 description 1
Classifications
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/08—Key distribution or management, e.g. generation, sharing or updating, of cryptographic keys or passwords
- H04L9/0816—Key establishment, i.e. cryptographic processes or cryptographic protocols whereby a shared secret becomes available to two or more parties, for subsequent use
- H04L9/0819—Key transport or distribution, i.e. key establishment techniques where one party creates or otherwise obtains a secret value, and securely transfers it to the other(s)
- H04L9/0825—Key transport or distribution, i.e. key establishment techniques where one party creates or otherwise obtains a secret value, and securely transfers it to the other(s) using asymmetric-key encryption or public key infrastructure [PKI], e.g. key signature or public key certificates
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/06—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols the encryption apparatus using shift registers or memories for block-wise or stream coding, e.g. DES systems or RC4; Hash functions; Pseudorandom sequence generators
- H04L9/0643—Hash functions, e.g. MD5, SHA, HMAC or f9 MAC
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/22—Indexing; Data structures therefor; Storage structures
- G06F16/2228—Indexing structures
- G06F16/2237—Vectors, bitmaps or matrices
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/23—Updating
- G06F16/2379—Updates performed during online database operations; commit processing
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/60—Protecting data
- G06F21/62—Protecting access to data via a platform, e.g. using keys or access control rules
- G06F21/6218—Protecting access to data via a platform, e.g. using keys or access control rules to a system of files or objects, e.g. local or distributed file system or database
- G06F21/6245—Protecting personal data, e.g. for financial or medical purposes
- G06F21/6254—Protecting personal data, e.g. for financial or medical purposes by anonymising data, e.g. decorrelating personal data from the owner's identification
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N7/00—Computing arrangements based on specific mathematical models
- G06N7/01—Probabilistic graphical models, e.g. probabilistic networks
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L63/00—Network architectures or network communication protocols for network security
- H04L63/04—Network architectures or network communication protocols for network security for providing a confidential data exchange among entities communicating through data packet networks
- H04L63/0428—Network architectures or network communication protocols for network security for providing a confidential data exchange among entities communicating through data packet networks wherein the data content is protected, e.g. by encrypting or encapsulating the payload
- H04L63/0442—Network architectures or network communication protocols for network security for providing a confidential data exchange among entities communicating through data packet networks wherein the data content is protected, e.g. by encrypting or encapsulating the payload wherein the sending and receiving network entities apply asymmetric encryption, i.e. different keys for encryption and decryption
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/008—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols involving homomorphic encryption
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/08—Key distribution or management, e.g. generation, sharing or updating, of cryptographic keys or passwords
- H04L9/0861—Generation of secret information including derivation or calculation of cryptographic keys or passwords
- H04L9/0869—Generation of secret information including derivation or calculation of cryptographic keys or passwords involving random numbers or seeds
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L2209/00—Additional information or applications relating to cryptographic mechanisms or cryptographic arrangements for secret or secure communication H04L9/00
- H04L2209/08—Randomization, e.g. dummy operations or using noise
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L2209/00—Additional information or applications relating to cryptographic mechanisms or cryptographic arrangements for secret or secure communication H04L9/00
- H04L2209/46—Secure multiparty computation, e.g. millionaire problem
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L2463/00—Additional details relating to network architectures or network communication protocols for network security covered by H04L63/00
- H04L2463/062—Additional details relating to network architectures or network communication protocols for network security covered by H04L63/00 applying encryption of the keys
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/08—Key distribution or management, e.g. generation, sharing or updating, of cryptographic keys or passwords
- H04L9/0816—Key establishment, i.e. cryptographic processes or cryptographic protocols whereby a shared secret becomes available to two or more parties, for subsequent use
- H04L9/085—Secret sharing or secret splitting, e.g. threshold schemes
Abstract
네트워킹 환경에서 디바이스 식별자 및 속성의 카운트 및 빈도를 결정하기 위해 최소 증가 카운팅 블룸 필터를 생성하기 위한 시스템 및 방법이 개시된다. 시스템은 네트워크의 디바이스와 연관된 디바이스 식별자 및 속성을 포함한 데이터 레코드 세트를 유지할 수 있다. 시스템은 카운터 레지스터에 대응하는 좌표를 포함하는 벡터를 생성할 수 있다. 시스템은 카운팅 블룸 필터를 업데이트하기 위해 해시 함수를 식별할 수 있다. 시스템은 카운터 레지스터 세트를 가리키는 인덱스 값을 추출하기 위해 데이터 레코드를 해싱할 수 있다. 시스템은 카운터 레지스터의 최소값에 대응하는 최소 증가 카운팅 블룸 필터의 포지션을 증가시킬 수 있다. 시스템은 공개 키를 포함하는 집합된 공개 키를 얻을 수 있다. 시스템은 집합된 공유 키를 사용하여 카운터 레지스터를 암호화하여 암호화된 벡터를 생성할 수 있다. 시스템은 암호화된 벡터를 네트워크로 연결된 작업자 컴퓨팅 디바이스에 전송할 수 있다.A system and method for generating a minimum increment counting bloom filter to determine the count and frequency of device identifiers and attributes in a networking environment. The system may maintain a set of data records containing device identifiers and attributes associated with devices in the network. The system may create a vector containing the coordinates corresponding to the counter register. The system can identify a hash function to update the counting bloom filter. The system can hash the data record to extract an index value pointing to a set of counter registers. The system may increment the position of the minimum increment counting bloom filter corresponding to the minimum value of the counter register. The system may obtain an aggregated public key containing the public key. The system can use the aggregated shared key to encrypt the counter register to create an encrypted vector. The system may transmit the encrypted vector to the networked worker computing device.
Description
관련 출원에 대한 상호 참조CROSS REFERENCES TO RELATED APPLICATIONS
본 출원은This application
"SECURE MULTI-PARTY REACH AND FREQUENCY ESTIMATION"이라는 명칭의 2020년 2월 14일 출원된 미국 특허 가출원 번호 제62/977,141호; US Provisional Patent Application Serial No. 62/977,141, filed February 14, 2020, entitled "SECURE MULTI-PARTY REACH AND FREQUENCY ESTIMATION";
"CASCADING LEGIONS CARDINALITY ESTIMATOR"라는 명칭의 2020년 2월 26일 출원된 미국 특허 가출원 번호 제62/981,960호; US Provisional Patent Application Serial No. 62/981,960, filed February 26, 2020, entitled "CASCADING LEGIONS CARDINALITY ESTIMATOR";
"EFFICIENT METHOD FOR DIFFERENTIALLY PRIVATE CARDINALITY ESTIMATION"이라는 명칭의 2020년 3월 10일 출원된 미국 특허 가출원 번호 제62/987,645호; 및US Provisional Patent Application No. 62/987,645, filed March 10, 2020, entitled "EFFICIENT METHOD FOR DIFFERENTIALLY PRIVATE CARDINALITY ESTIMATION"; and
"PRIVACY PRESERVING SECURE CARDINALITY AND FREQUENCY ESTIMATION"이라는 명칭의 2020년 3월 30일 출원된 미국 특허 가출원 번호 제63/002,138호에 대해 우선권을 주장하며,Claiming priority to U.S. Provisional Patent Application No. 63/002,138, filed March 30, 2020, entitled "PRIVACY PRESERVING SECURE CARDINALITY AND FREQUENCY ESTIMATION";
그 각각의 내용은 그 전체가 본원에 참고로서 통합된다.The contents of each of which are incorporated herein by reference in their entirety.
많은 경우에, 컴퓨팅 및 데이터 분석 시스템은 데이터 분석 또는 처리의 일부로서 대규모 데이터 세트의 교차 또는 결합을 결정할 수 있다. 여러 소스에 분산된 대규모 데이터 세트의 통합, 교차 또는 빈도를 계산하려면 일반적으로 여러 소스 간에 대규모 데이터 세트에 대한 정보를 공유해야 한다. 각 소스의 정보는 프라이버시 또는 보호된 정보를 포함할 수 있으며, 이러한 정보를 공유하면 프라이버시 및 보안에 부정적인 영향을 미칠 수 있다.In many cases, computing and data analysis systems may determine intersections or unions of large data sets as part of data analysis or processing. Computing integrations, intersections, or frequencies of large data sets distributed across multiple sources typically requires sharing information about large data sets among multiple sources. Information from each source may contain privacy or protected information, and sharing such information may negatively impact privacy and security.
본 명세서에서 논의된 시스템 및 방법은 암호화된 확률 데이터 구조 및 준동형 암호화 체계의 사용을 통해 데이터 및 데이터 카운팅 시스템의 향상된 보안 및 프라이버시를 제공할 수 있다. 많은 구현에서, 최소 증가 카운팅 블룸 필터, 계단식 군단 행렬, 연속 군단 데이터 구조 등과 같은 확률 데이터 구조가 생성되어 네트워킹 환경에서 디바이스 식별자 및 속성의 카운트와 빈도를 결정할 수 있다. 네트워크의 디바이스와 관련된 디바이스 식별자 및 속성을 포함하는 데이터 레코드 세트가 유지될 수 있으며, 카운터 레지스터에 대응할 수 있는 좌표, 포지션 또는 값을 포함하는 확률 데이터 구조가 생성될 수 있다. 해시 함수를 사용하여 식별될 수 있는 데이터 구조를 업데이트할 수 있으며, 데이터 레코드를 해시하여 인덱스 값, 포지션 값 또는 확률 데이터 구조의 하나 이상의 포지션에 대한 다른 포인터 또는 식별자를 추출할 수 있다. 데이터 구조의 포지션은 증가, 업데이트, 플립핑, 치환 또는 변경될 수 있다. 공개 키를 포함하는 집합된 공개 키가 획득될 수 있으며, 데이터 구조는 암호화된 벡터를 생성하기 위해 상기 집합된 공유 키를 사용하여 암호화될 수 있으며, 암호화된 벡터는 네트워크로 연결된 작업자 컴퓨팅 디바이스로 전송된다. The systems and methods discussed herein may provide enhanced security and privacy of data and data counting systems through the use of encrypted probabilistic data structures and homomorphic encryption schemes. In many implementations, probabilistic data structures such as least incremental counting bloom filters, cascaded swarm matrices, continuous swarm data structures, etc. may be created to determine counts and frequencies of device identifiers and attributes in a networking environment. A set of data records containing device identifiers and attributes associated with devices in the network may be maintained, and probabilistic data structures may be created containing coordinates, positions, or values that may correspond to counter registers. A hash function can be used to update an identifiable data structure, and data records can be hashed to extract index values, position values, or other pointers or identifiers to one or more positions of a probability data structure. A position in a data structure can be incremented, updated, flipped, permuted or changed. An aggregated public key comprising a public key can be obtained, and a data structure can be encrypted using the aggregated shared key to generate an encrypted vector, which is transmitted to a networked worker computing device. do.
이러한 시스템 및 방법은 확률 데이터 구조를 작업자 컴퓨팅 디바이스로 전송할 수 있으며, 이는 데이터 구조를 생성하는데 사용되는 데이터 레코드보다 훨씬 더 작을 수 있으며, 그렇지 않으면 데이터 레코드는 하나 이상의 작업자 컴퓨팅 디바이스로 전송된다. 이는 네트워크를 통해 전송되는 데이터의 양과 각 작업자 컴퓨팅 디바이스에서 처리하는 데이터의 양을 줄일 수 있으며, 이는 다른 다중 멤버십 비교 및 계산 시스템에 비해 상당한 개선이다. 또한 추정된 히스토그램을 사용함으로써, 이 기술 솔루션의 양태는 네트워크를 통해 보호된 또는 프라이버시 정보를 전송하지 않고도 클라이언트 식별자 속성 데이터 빈도의 정확한 추정을 제공할 수 있다. 이는 식별자 서버가 연관 디바이스의 수 또는 속성을 노출하지 않도록 보호할 뿐만 아니라 클라이언트 디바이스가 보호된 또는 프라이버시 정보를 노출하지 않도록 보호하여, 네트워킹 시스템의 보안 및 프라이버시 보호를 크게 향상시킨다.Such systems and methods may transmit probabilistic data structures to worker computing devices, which may be much smaller than the data records used to create the data structures, which data records would otherwise be transmitted to one or more worker computing devices. This can reduce the amount of data transmitted over the network and processed by each worker computing device, which is a significant improvement over other multi-membership comparison and calculation systems. Also by using the estimated histogram, aspects of this technical solution can provide an accurate estimate of the client identifier attribute data frequency without transmitting protected or privacy information over the network. This not only protects the identifier server from exposing the number or attributes of associated devices, but also protects client devices from exposing protected or privacy information, greatly improving the security and privacy protection of the networking system.
본 기술 솔루션의 적어도 하나의 양태는 안전하고 계산적으로 효율적인 전송을 위한 목표 기준을 만족하는 속성을 갖는 식별자 세트를 표현하는 암호화된 확률 데이터 구조를 생성하는 방법에 관한 것이다. 방법은 하나 이상의 프로세서 및 메모리를 포함하는 데이터 프로세싱 시스템에 의해 실행 또는 수행될 수 있다. 방법은 데이터베이스에 디바이스 식별자 세트를 유지하는 단계를 포함할 수 있다. 디바이스 식별자 세트 각각은 디바이스 속성을 포함할 수 있다. 방법은 디바이스 식별자 세트 및 해시 함수를 사용하여 확률 데이터 구조를 생성하는 단계를 포함할 수 있다. 방법은 암호화된 확률 데이터 구조를 생성하기 위해 확률 데이터 구조를 암호화하는 단계를 포함할 수 있고, 암호화된 확률 데이터 구조는 제2 암호화된 확률 데이터 구조와 결합될 수 있도록 한다. 방법은 암호화된 확률 데이터 구조를 작업자 컴퓨팅 디바이스에 전송하는 단계를 포함할 수 있다.At least one aspect of the present technical solution relates to a method of generating an encrypted probabilistic data structure representing a set of identifiers having attributes that satisfy target criteria for secure and computationally efficient transmission. A method may be executed or performed by a data processing system that includes one or more processors and memory. The method may include maintaining a set of device identifiers in a database. Each set of device identifiers may include device attributes. The method may include generating a probabilistic data structure using a set of device identifiers and a hash function. The method may include encrypting the probabilistic data structure to generate an encrypted probabilistic data structure, allowing the encrypted probabilistic data structure to be combined with a second encrypted probabilistic data structure. The method may include transmitting the encrypted probabilistic data structure to a worker computing device.
일부 구현예에서, 방법은 제1 디바이스 속성을 포함하는 제1 디바이스 식별자를 수신하는 단계를 포함할 수 있다. 일부 구현예에서, 방법은 디바이스 식별자 세트의 멤버로서 제1 디바이스 속성을 포함하는 제1 디바이스 식별자를 저장하는 단계를 포함할 수 있다. 일부 구현예에서, 방법은 균일하게 분산된 해시 함수를 상기 해시 함수로서 식별하는 단계를 포함할 수 있고, 상기 균일하게 분산된 해시 함수는 균일하게 분산된 값을 출력한다. 일부 구현예에서, 해시 함수는 복수의 해시 함수일 수 있고, 방법은 각각의 복수의 카운터 레지스터에 대응하는 복수의 좌표를 포함하는 벡터 데이터 구조를 생성하는 단계를 포함할 수 있다. 벡터 데이터 구조는 확률 데이터 구조일 수 있다. 일부 구현예에서, 상기 방법은 상기 디바이스 속성을 포함하는 상기 디바이스 식별자 세트 각각에 대해, 상기 복수의 해시 함수를 사용하여 상기 벡터 데이터 구조의 상기 각각의 복수의 카운터 레지스터의 카운터 레지스터를 업데이트하는 단계를 포함할 수 있다.In some implementations, the method can include receiving a first device identifier that includes a first device attribute. In some implementations, the method can include storing a first device identifier that includes a first device attribute as a member of a device identifier set. In some implementations, a method can include identifying a uniformly distributed hash function as the hash function, wherein the uniformly distributed hash function outputs a uniformly distributed value. In some implementations, the hash function can be a plurality of hash functions, and the method can include creating a vector data structure comprising a plurality of coordinates corresponding to each of the plurality of counter registers. A vector data structure may be a probabilistic data structure. In some implementations, the method further comprises, for each of the device identifier set that includes the device attribute, updating a counter register of each of the plurality of counter registers of the vector data structure using the plurality of hash functions. can include
일부 구현예에서, 상기 방법은 복수의 해시된 데이터 레코드 값을 생성하기 위해 상기 복수의 해시 함수 각각을 사용하여 상기 디바이스 식별자 세트의 디바이스 식별자를 해싱하는 단계를 포함할 수 있다. 일부 구현예에서, 방법은 데이터 프로세싱 시스템에 의해, 복수의 해시된 데이터 레코드 값으로부터 복수의 레지스터 식별자를 추출하는 단계를 포함할 수 있다. 복수의 레지스터 식별자들 각각은 복수의 카운터 레지스터 중 각각의 카운터 레지스터에 대응할 수 있다. 일부 구현예에서, 상기 방법은 최소값 임계치를 만족하는 카운터 레지스터 세트를 식별하기 위해 상기 복수의 레지스터 식별자에 대응하는 상기 복수의 카운터 레지스터 각각에 액세스하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 최소값 임계치를 만족하는 카운터 레지스터 세트 각각을 증가시키는 단계를 포함할 수 있다.In some implementations, the method can include hashing the device identifiers of the device identifier set using each of the plurality of hash functions to generate a plurality of hashed data record values. In some implementations, a method can include extracting, by a data processing system, a plurality of register identifiers from a plurality of hashed data record values. Each of the plurality of register identifiers may correspond to each counter register among the plurality of counter registers. In some implementations, the method can include accessing each of the plurality of counter registers corresponding to the plurality of register identifiers to identify a set of counter registers that satisfy a minimum value threshold. In some implementations, the method can include incrementing each set of counter registers that satisfy the minimum value threshold.
일부 구현예에서, 상기 방법은 디바이스 식별자와 연관하여 상기 복수의 해시된 데이터 레코드 값 각각을 데이터베이스에 저장하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 복수의 카운터 레지스터의 개수를 사용하여 상기 복수의 해시된 데이터 레코드 값 각각에 대해 모듈러스 연산을 수행하는 단계를 포함할 수 있다. 일부 구현예에서, 확률 데이터 구조는 제1 벡터 및 제 2 벡터를 포함하는 행렬 데이터 구조이고, 상기 방법은 상기 해시 함수를 사용하여 선택된 벡터 및 디바이스 식별자 세트의 디바이스 식별자를 선택하는 단계를 포함할 수 있다. 선택된 벡터는 제1 벡터 또는 제2 벡터 중 하나일 수 있다. 일부 구현예에서, 상기 방법은 상기 해시 함수 및 상기 디바이스 식별자 세트의 디바이스 식별자를 사용하여 상기 행렬 데이터 구조의 선택된 벡터의 좌표를 업데이트하는 단계를 포함할 수 있다.In some implementations, the method can include storing each of the plurality of hashed data record values in association with a device identifier in a database. In some implementations, the method can include performing a modulus operation on each of the plurality of hashed data record values using a number of a plurality of counter registers. In some implementations, the probabilistic data structure is a matrix data structure comprising a first vector and a second vector, and the method may include using the hash function to select a selected vector and a device identifier of the set of device identifiers. there is. The selected vector may be either the first vector or the second vector. In some implementations, the method can include updating the coordinates of the selected vector of the matrix data structure using the hash function and a device identifier of the device identifier set.
일부 구현예에서, 상기 방법은 해시된 디바이스 식별자를 생성하기 위해 상기 디바이스 식별자 세트의 디바이스 식별자를 해싱하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 미리 결정된 비트 값을 만족하는 상기 해시된 디바이스 식별자의 최하위 비트의 수를 결정하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 미리 결정된 비트 값을 만족하는 상기 해시된 디바이스 식별자의 상기 최하위 비트 수에 기초하여, 상기 제1 벡터를 선택된 벡터로서 또는 상기 제2 벡터를 선택된 벡터로서 선택하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 카운터 레지스터 인덱스 값을 계산하기 위해 상기 해시된 디바이스 식별자에 대한 모듈러스 연산을 수행하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 카운터 레지스터 인덱스 값을 사용하여 상기 좌표를 선택하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 카운터 레지스터 인덱스 값을 사용하여 선택된 상기 좌표를 증가시키는 단계를 포함할 수 있다.In some implementations, the method can include hashing the device identifiers of the device identifier set to generate a hashed device identifier. In some implementations, the method can include determining the number of least significant bits of the hashed device identifier that satisfy a predetermined bit value. In some implementations, the method further includes selecting the first vector as the selected vector or the second vector as the selected vector based on the number of least significant bits of the hashed device identifier that satisfy the predetermined bit value. can include In some implementations, the method can include performing a modulus operation on the hashed device identifier to compute a counter register index value. In some implementations, the method can include selecting the coordinate using the counter register index value. In some implementations, the method can include incrementing the selected coordinate using the counter register index value.
본 개시의 적어도 하나의 다른 양태는 안전하고 계산적으로 효율적인 전송을 위한 목표 기준을 만족하는 속성을 갖는 식별자 세트를 표현하는 암호화된 확률 데이터 구조를 생성하는 시스템에 관한 것이다. 시스템은 하나 이상의 프로세서들 및 메모리를 포함하는 데이터 프로세싱 시스템을 포함할 수 있다. 시스템은 데이터베이스에서, 디바이스 식별자 세트를 유지할 수 있고, 디바이스 식별자 세트 각각은 디바이스 속성을 포함한다. 시스템은 디바이스 식별자 세트 및 해시 함수를 사용하여 확률 데이터 구조를 생성할 수 있다. 시스템은 암호화된 확률 데이터 구조를 생성하기 위해 확률 데이터 구조를 암호화할 수 있고, 암호화된 확률 데이터 구조는 제2 암호화된 확률 데이터 구조와 결합될 수 있도록 한다. 시스템은 암호화된 확률 데이터 구조를 작업자 컴퓨팅 디바이스에 전송할 수 있다.At least one other aspect of the present disclosure relates to a system for generating an encrypted probabilistic data structure representing a set of identifiers having attributes that satisfy target criteria for secure and computationally efficient transmission. A system may include a data processing system including one or more processors and memory. The system may maintain sets of device identifiers in a database, each set of device identifiers including device attributes. The system can generate a probabilistic data structure using a set of device identifiers and a hash function. The system can encrypt the probabilistic data structure to create an encrypted probabilistic data structure, which allows the encrypted probabilistic data structure to be combined with a second encrypted probabilistic data structure. The system may transmit the encrypted probabilistic data structure to the worker computing device.
일부 구현예에서, 시스템은 제1 디바이스 속성을 포함하는 제1 디바이스 식별자를 수신할 수 있다. 일부 구현예에서, 시스템은 디바이스 식별자 세트의 멤버로서 제1 디바이스 속성을 포함하는 제1 디바이스 식별자를 저장할 수 있다. 일부 구현예에서, 시스템은 균일하게 분산된 해시 함수를 상기 해시 함수로서 식별할 수 있고, 상기 균일하게 분산된 해시 함수는 균일하게 분산된 값을 출력한다. 일부 구현예에서, 해시 함수는 복수의 해시 함수일 수 있고, 시스템은 각각의 복수의 카운터 레지스터에 대응하는 복수의 좌표를 포함하는 벡터 데이터 구조를 생성할 수 있다. 벡터 데이터 구조는 확률 데이터 구조일 수 있다. 일부 구현예에서, 시스템은 상기 디바이스 속성을 포함하는 상기 디바이스 식별자 세트 각각에 대해, 상기 복수의 해시 함수를 사용하여 상기 벡터 데이터 구조의 상기 각각의 복수의 카운터 레지스터의 카운터 레지스터를 업데이트할 수 있다. In some implementations, the system can receive a first device identifier that includes a first device attribute. In some implementations, the system can store the first device identifier including the first device attribute as a member of the device identifier set. In some implementations, the system can identify a uniformly distributed hash function as the hash function, and the uniformly distributed hash function outputs a uniformly distributed value. In some implementations, the hash function can be a plurality of hash functions, and the system can create a vector data structure that includes a plurality of coordinates corresponding to each of the plurality of counter registers. A vector data structure may be a probabilistic data structure. In some implementations, the system can use the plurality of hash functions to update a counter register of each of the plurality of counter registers of the vector data structure for each of the device identifier set that includes the device attribute.
일부 구현예에서, 시스템은 복수의 해시된 데이터 레코드 값을 생성하기 위해 상기 복수의 해시 함수 각각을 사용하여 상기 디바이스 식별자 세트의 디바이스 식별자를 해싱할 수 있다. 일부 구현예에서, 시스템은 복수의 해시된 데이터 레코드 값으로부터 복수의 레지스터 식별자를 추출할 수 있다. 복수의 레지스터 식별자들 각각은 복수의 카운터 레지스터 중 각각의 카운터 레지스터에 대응할 수 있다. 일부 구현예에서, 시스템은 최소값 임계치를 만족하는 카운터 레지스터 세트를 식별하기 위해 상기 복수의 레지스터 식별자에 대응하는 상기 복수의 카운터 레지스터 각각에 액세스할 수 있다. 일부 구현예에서, 시스템은 상기 최소값 임계치를 만족하는 카운터 레지스터 세트 각각을 증가시킬 수 있다.In some implementations, the system can hash the device identifiers of the set of device identifiers using each of the plurality of hash functions to generate a plurality of hashed data record values. In some implementations, the system can extract multiple register identifiers from multiple hashed data record values. Each of the plurality of register identifiers may correspond to each counter register among the plurality of counter registers. In some implementations, the system can access each of the plurality of counter registers corresponding to the plurality of register identifiers to identify a set of counter registers that satisfy a minimum value threshold. In some implementations, the system can increment each set of counter registers that satisfy the minimum value threshold.
일부 구현예에서, 시스템은 디바이스 식별자와 연관하여 상기 복수의 해시된 데이터 레코드 값 각각을 데이터베이스에 저장할 수 있다. 일부 구현예에서, 시스템은 복수의 카운터 레지스터의 개수를 사용하여 상기 복수의 해시된 데이터 레코드 값 각각에 대해 모듈러스 연산을 수행할 수 있다. 일부 구현예에서, 확률 데이터 구조는 제1 벡터 및 제2 벡터를 포함하는 행렬 데이터 구조이고, 시스템은 상기 해시 함수를 사용하여 선택된 벡터 및 디바이스 식별자 세트의 디바이스 식별자를 선택할 수 있고, 상기 선택된 벡터는 상기 제1 벡터 또는 상기 제2 벡터 중 하나이다. 일부 구현예에서, 시스템은 상기 해시 함수 및 상기 디바이스 식별자 세트의 디바이스 식별자를 사용하여 상기 행렬 데이터 구조의 선택된 벡터의 좌표를 업데이트할 수 있다.In some implementations, the system can store each of the plurality of hashed data record values in a database in association with a device identifier. In some implementations, the system can perform a modulus operation on each of the plurality of hashed data record values using a number of counter registers. In some implementations, the probabilistic data structure is a matrix data structure comprising a first vector and a second vector, and the system can use the hash function to select a selected vector and a device identifier of the set of device identifiers, the selected vector being Either the first vector or the second vector. In some implementations, the system can use the hash function and a device identifier in the device identifier set to update the coordinates of the selected vector of the matrix data structure.
일부 구현예에서, 시스템은 해시된 디바이스 식별자를 생성하기 위해 상기 디바이스 식별자 세트의 디바이스 식별자를 해싱할 수 있다. 일부 구현예에서, 시스템은 미리 결정된 비트 값을 만족하는 상기 해시된 디바이스 식별자의 최하위 비트의 수를 결정할 수 있다. 일부 구현예에서, 시스템은 상기 미리 결정된 비트 값을 만족하는 상기 해시된 디바이스 식별자의 상기 최하위 비트 수에 기초하여, 상기 제1 벡터를 선택된 벡터로서 또는 상기 제2 벡터를 선택된 벡터로서 선택할 수 있다. 일부 구현예에서, 시스템은 카운터 레지스터 인덱스 값을 계산하기 위해 상기 해시된 디바이스 식별자에 대한 모듈러스 연산을 수행할 수 있다. 일부 구현예에서, 시스템은 상기 카운터 레지스터 인덱스 값을 사용하여 상기 좌표를 선택할 수 있다. 일부 구현예에서, 시스템은 상기 카운터 레지스터 인덱스 값을 사용하여 선택된 상기 좌표를 증가시킬 수 있다.In some implementations, the system can hash the device identifiers of the device identifier set to create a hashed device identifier. In some implementations, the system can determine the number of least significant bits of the hashed device identifier that satisfy a predetermined bit value. In some implementations, the system can select the first vector as the selected vector or the second vector as the selected vector based on the number of least significant bits of the hashed device identifier that satisfy the predetermined bit value. In some implementations, the system can perform a modulus operation on the hashed device identifier to calculate a counter register index value. In some implementations, the system can use the counter register index value to select the coordinate. In some implementations, the system can increment the selected coordinate using the counter register index value.
본 기술 솔루션의 적어도 하나의 다른 양태는 안전하고 계산적으로 효율적인 네트워크 전송을 위해 식별자 세트를 표현하는 암호화된 확률 데이터 구조를 효율적으로 변환하는 방법에 관한 것이다. 상기 방법은 하나 이상의 프로세서 및 메모리를 포함하는 작업자 컴퓨팅 디바이스에 의해, 집합된 공개 키에 부분적으로 대응하는 개인 복호화 키를 메모리에 유지하는 단계를 포함할 수 있다. 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 퍼블리셔 컴퓨팅 디바이스로부터, 암호화된 확률 데이터 구조를 수신하는 단계를 포함할 수 있다. 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 부분적으로 복호화된 확률 데이터 구조를 생성하기 위해 상기 개인 복호화 키를 사용하여 상기 암호화된 확률 데이터 구조를 복호화하는 단계를 포함할 수 있다. 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 결정론적으로 암호화된 확률 데이터 구조를 생성하기 위해 결정론적 암호화 방식을 사용하여 상기 부분적으로 복호화된 확률 데이터 구조를 암호화하는 단계를 포함할 수 있다. 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 셔플된 결정론적으로 암호화된 데이터 구조를 생성하기 위해 상기 결정론적으로 암호화된 확률 데이터 구조의 적어도 2개의 엘리먼트를 순열하는 단계를 포함할 수 있다. 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 상기 셔플된 결정론적으로 암호화된 확률 데이터 구조를 제2 작업자 컴퓨팅 디바이스에 전송하는 단계를 포함할 수 있다.At least one other aspect of the present technical solution relates to a method of efficiently transforming an encrypted probabilistic data structure representing a set of identifiers for secure and computationally efficient network transmission. The method may include maintaining, by a worker computing device comprising one or more processors and memory, a private decryption key corresponding in part to the aggregated public key in a memory. The method may include receiving, by the worker computing device, an encrypted probabilistic data structure from a publisher computing device. The method may include decrypting, by the worker computing device, the encrypted probabilistic data structure using the private decryption key to produce a partially decrypted probabilistic data structure. The method may include encrypting, by the worker computing device, the partially decrypted probabilistic data structure using a deterministic encryption scheme to produce a deterministically encrypted probabilistic data structure. The method may include permuting, by the worker computing device, at least two elements of the deterministically encrypted probabilistic data structure to produce a shuffled deterministically encrypted data structure. The method may include transmitting, by the worker computing device, the shuffled deterministically encrypted probabilistic data structure to a second worker computing device.
일부 구현예에서, 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 상기 개인 복호화 키 및 상기 제1 공개 암호화 키를 포함하는 키 쌍을 생성하는 단계를 더 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 상기 제2 작업자 컴퓨팅 디바이스로부터 제2 공개 암호화 키를 수신하는 단계를 더 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 상기 집합된 공개 키를 생성하기 위해 상기 제1 공개 암호화 키 및 상기 제2 공개 암호화 키를 집합하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 상기 작업자 컴퓨팅 디바이스의 메모리에 상기 개인 복호화 키 및 상기 집합된 공개 키를 저장하는 단계를 포함할 수 있다.In some implementations, the method can further include generating, by the worker computing device, a key pair comprising the private decryption key and the first public encryption key. In some implementations, the method can further include receiving, by the worker computing device, a second public encryption key from the second worker computing device. In some implementations, the method can include aggregating, by the worker computing device, the first public encryption key and the second public encryption key to generate the aggregated public key. In some implementations, the method can include storing, by the worker computing device, the private decryption key and the aggregated public key in a memory of the worker computing device.
일부 구현예에서, 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 상기 집합된 공개 키를 퍼블리셔 컴퓨팅 디바이스에 전송하는 단계를 더 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 제1 퍼블리셔 컴퓨팅 디바이스로부터, 제1 암호화된 확률 데이터 구조를 수신하는 단계를 더 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 상기 제2 퍼블리셔 컴퓨팅 디바이스로부터 제2 암호화된 데이터 구조를 수신하는 단계를 더 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 암호화된 확률 데이터 구조를 생성하기 위해 제1 암호화된 확률 데이터 구조 및 제2 암호화된 확률 데이터 구조를 결합하는 단계를 더 포함할 수 있다.In some implementations, the method can further include transmitting, by the worker computing device, the aggregated public key to a publisher computing device. In some implementations, the method can further include receiving, by the worker computing device, a first encrypted probabilistic data structure from a first publisher computing device. In some implementations, the method can further include receiving, by the worker computing device, a second encrypted data structure from the second publisher computing device. In some implementations, the method can further include combining, by the worker computing device, a first encrypted probabilistic data structure and a second encrypted probabilistic data structure to create an encrypted probabilistic data structure.
일부 구현예에서, 상기 셔플된 결정론적으로 암호화된 데이터 구조는 제1 암호화된 카운터 레지스터 및 제2 암호화된 카운터 레지스터를 포함하고, 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 상기 셔플된 결정론적으로 암호화된 데이터 구조의 제1 암호화된 카운터 레지스터를 제1 메시지에서 상기 제2 작업자 컴퓨팅 디바이스로 전송하는 단계를 더 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 상기 제2 작업자 컴퓨팅 디바이스에, 상기 셔플된 결정론적으로 암호화된 데이터 구조의 제2 암호화된 카운터 레지스터를 제2 메시지로 제2 작업자 컴퓨팅 디바이스에 전송하는 단계를 더 포함할 수 있다.In some implementations, the shuffled deterministically encrypted data structure comprises a first encrypted counter register and a second encrypted counter register, the method comprising: by the worker computing device, the shuffled deterministically encrypted data structure The method may further include transmitting the first encrypted counter register of the encrypted data structure to the second worker computing device in a first message. In some implementations, the method may further include sending, by the worker computing device, to the second worker computing device, a second encrypted counter register of the shuffled deterministically encrypted data structure in a second message to the second worker computing device. It may further include the step of transmitting to.
일부 구현예에서, 상기 방법은 작업자 컴퓨팅 디바이스에 의해, 부분적으로 복호화된 확률 데이터 구조에 추가할 노이즈의 양을 결정하기 위해 랜덤 변수를 생성하는 단계를 더 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 기준 노이즈 값 및 최대 빈도 값에 기초하여 노이즈 어레이를 생성하는 단계를 더 포함할 수 있고, 상기 노이즈 어레이는 복수의 노이즈 값을 포함한다. 일부 구현예에서, 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 순열된 노이즈 어레이를 생성하기 위해 상기 노이즈 어레이를 순열하는 단계를 더 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 암호화된 노이즈 어레이를 생성하기 위해 상기 집합된 공개 키를 사용하여 상기 순열된 노이즈 어레이를 암호화하는 단계를 더 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 상기 암호화된 노이즈 어레이를 애그리게이터 컴퓨팅 디바이스에 전송하는 단계를 더 포함할 수 있다.In some implementations, the method can further include generating, by the worker computing device, a random variable to determine an amount of noise to add to the partially decoded probabilistic data structure. In some implementations, the method can further include generating, by the worker computing device, a noise array based on a reference noise value and a maximum frequency value, the noise array comprising a plurality of noise values. In some implementations, the method can further include permuting, by the worker computing device, the noise array to generate a permuted noise array. In some implementations, the method can further include encrypting, by the worker computing device, the permuted noise array using the aggregated public key to generate an encrypted noise array. In some implementations, the method can further include transmitting, by the worker computing device, the encrypted noise array to an aggregator computing device.
일부 구현예에서, 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 상기 제2 작업자 컴퓨팅 디바이스로부터 상기 기준 노이즈 값 및 상기 최대 빈도 값을 수신하는 단계를 더 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 제1 암호화된 노이즈 값을 생성하기 위해 상기 집합된 공개 키를 사용하여 상기 순열된 노이즈 어레이의 제1 노이즈 값을 암호화하는 단계를 더 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 제2 암호화된 노이즈 값을 생성하기 위해 상기 집합된 공개 키를 사용하여 상기 순열된 노이즈 어레이의 제2 노이즈 값을 암호화하는 단계를 더 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 상기 암호화된 노이즈 어레이를 생성하기 위해 상기 제1 노이즈 값 및 상기 제2 노이즈 값을 집합하는 단계를 더 포함할 수 있다. In some implementations, the method can further include receiving, by the worker computing device, the reference noise value and the maximum frequency value from the second worker computing device. In some implementations, the method further comprises encrypting, by the worker computing device, a first noise value of the permuted noise array using the aggregated public key to generate a first encrypted noise value. can do. In some implementations, the method further comprises encrypting, by the worker computing device, a second noise value of the permuted noise array using the aggregated public key to generate a second encrypted noise value. can do. In some implementations, the method can further include aggregating, by the worker computing device, the first noise value and the second noise value to generate the encrypted noise array.
일부 구현예에서, 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 결정적 암호화 키 및 결정적 복호화 키를 생성하는 단계를 더 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 상기 작업자 컴퓨팅 디바이스의 메모리에 상기 결정적 암호화 키 및 상기 결정적 복호화 키를 저장하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 결정론적으로 암호화된 확률 데이터 구조를 생성하기 위해 결정론적 암호화 키를 사용하여 상기 부분적으로 복호화된 확률 데이터 구조를 암호화하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 제3 작업자 컴퓨팅 디바이스로부터, 제2 셔플된 결정론적 암호화된 확률 데이터 구조를 수신하는 단계를 더 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 제2 셔플된 부분적으로 복호화된 확률 데이터 구조를 생성하기 위해 상기 결정론적 복호화 키를 사용하여 상기 제2 셔플된 결정론적 암호화된 확률 데이터 구조를 복호화하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 작업자 컴퓨팅 디바이스에 의해, 상기 제2 셔플된 부분적으로 복호화된 확률 데이터 구조를 제2 작업자 컴퓨팅 디바이스에 전송하는 단계를 포함할 수 있다.In some implementations, the method can further include generating, by the worker computing device, a deterministic encryption key and a deterministic decryption key. In some implementations, the method can include storing, by the worker computing device, the deterministic encryption key and the deterministic decryption key in a memory of the worker computing device. In some implementations, the method may include encrypting, by the worker computing device, the partially decrypted probabilistic data structure using a deterministic encryption key to produce a deterministically encrypted probabilistic data structure. there is. In some implementations, the method can further include receiving, by the worker computing device, a second shuffled deterministic encrypted probabilistic data structure from a third worker computing device. In some implementations, the method uses the deterministic decryption key to generate a second shuffled partially decrypted probabilistic data structure, by the worker computing device, the second shuffled deterministic encrypted probabilistic data structure. It may include the step of decoding. In some implementations, the method can include sending, by the worker computing device, the second shuffled partially decrypted probabilistic data structure to a second worker computing device.
본 기술 솔루션의 적어도 하나의 다른 양태는 안전하고 계산적으로 효율적인 네트워크 전송을 위해 식별자 세트를 표현하는 암호화된 확률 데이터 구조를 효율적으로 변환하기 위한 시스템에 관한 것이다. 시스템은 하나 이상의 프로세서 및 메모리를 포함하는 작업자 컴퓨팅 디바이스를 포함할 수 있다. 시스템은 집합된 공개 키에 부분적으로 대응하는 개인 복호화 키를 상기 메모리에 유지할 수 있다. 시스템은 퍼블리셔 컴퓨팅 디바이스로부터 암호화된 확률 데이터 구조를 수신할 수 있다. 시스템은 부분적으로 복호화된 확률 데이터 구조를 생성하기 위해 상기 개인 복호화 키를 사용하여 상기 암호화된 확률 데이터 구조를 복호화할 수 있다. 시스템은 결정론적으로 암호화된 확률 데이터 구조를 생성하기 위해 결정론적 암호화 방식을 사용하여 상기 부분적으로 복호화된 확률 데이터 구조를 암호화할 수 있다. 시스템은 셔플된 결정론적으로 암호화된 데이터 구조를 생성하기 위해 상기 결정론적으로 암호화된 확률 데이터 구조의 적어도 2개의 엘리먼트를 순열할 수 있다. 시스템은 셔플된 결정론적으로 암호화된 확률 데이터 구조를 제2 작업자 컴퓨팅 디바이스에 전송할 수 있다.At least one other aspect of the present technical solution relates to a system for efficiently transforming an encrypted probabilistic data structure representing a set of identifiers for secure and computationally efficient network transmission. A system may include a worker computing device that includes one or more processors and memory. The system may maintain in the memory a private decryption key corresponding in part to the aggregated public key. The system may receive the encrypted probabilistic data structure from the publisher computing device. The system can decrypt the encrypted probabilistic data structure using the private decryption key to produce a partially decrypted probabilistic data structure. The system may encrypt the partially decrypted probabilistic data structure using a deterministic encryption scheme to produce a deterministically encrypted probabilistic data structure. The system may permutate at least two elements of the deterministically encrypted probabilistic data structure to produce a shuffled deterministically encrypted data structure. The system may transmit the shuffled deterministically encrypted probabilistic data structure to the second worker computing device.
일부 구현예에서, 시스템은 상기 개인 복호화 키 및 상기 제1 공개 암호화 키를 포함하는 키 쌍을 생성할 수 있다. 일부 구현예에서, 시스템은 상기 제2 작업자 컴퓨팅 디바이스로부터 제2 공개 암호화 키를 수신할 수 있다. 일부 구현예에서, 시스템은 상기 집합된 공개 키를 생성하기 위해 상기 제1 공개 암호화 키 및 상기 제2 공개 암호화 키를 집합할 수 있다. 일부 구현예에서, 시스템은 상기 작업자 컴퓨팅 디바이스의 메모리에 상기 개인 복호화 키 및 상기 집합된 공개 키를 저장할 수 있다. 일부 구현예에서, 시스템은 상기 집합된 공개 키를 퍼블리셔 컴퓨팅 디바이스에 전송할 수 있다.In some implementations, a system can generate a key pair comprising the private decryption key and the first public encryption key. In some implementations, the system can receive a second public encryption key from the second worker computing device. In some implementations, the system can aggregate the first public encryption key and the second public encryption key to generate the aggregated public key. In some implementations, the system can store the private decryption key and the aggregated public key in memory of the worker computing device. In some implementations, the system can transmit the aggregated public key to a publisher computing device.
일부 구현예에서, 시스템은 제1 퍼블리셔 컴퓨팅 디바이스로부터 제1 암호화된 확률 데이터 구조를 수신할 수 있다. 일부 구현예에서, 시스템은 제2 퍼블리셔 컴퓨팅 디바이스로부터 제2 암호화된 데이터 구조를 수신할 수 있다. 일부 구현예에서, 시스템은 암호화된 확률 데이터 구조를 생성하기 위해 제1 암호화된 확률 데이터 구조 및 제2 암호화된 확률 데이터 구조를 결합할 수 있다. 일부 구현예에서, 상기 셔플된 결정론적으로 암호화된 데이터 구조는 제1 암호화된 카운터 레지스터 및 제2 암호화된 카운터 레지스터를 포함하고, 시스템은 상기 셔플된 결정론적으로 암호화된 데이터 구조의 제1 암호화된 카운터 레지스터를 제1 메시지에서 상기 제2 작업자 컴퓨팅 디바이스로 전송할 수 있다. 일부 구현예에서, 시스템은 상기 제2 작업자 컴퓨팅 디바이스에, 상기 셔플된 결정론적으로 암호화된 데이터 구조의 제2 암호화된 카운터 레지스터를 제2 메시지로 제2 작업자 컴퓨팅 디바이스에 전송할 수 있다.In some implementations, the system can receive the first encrypted probabilistic data structure from the first publisher computing device. In some implementations, the system can receive the second encrypted data structure from the second publisher computing device. In some implementations, the system can combine the first encrypted probabilistic data structure and the second encrypted probabilistic data structure to create an encrypted probabilistic data structure. In some implementations, the shuffled deterministically encrypted data structure includes a first encrypted counter register and a second encrypted counter register, and the system determines the first encrypted counter register of the shuffled deterministically encrypted data structure. A counter register may be sent to the second worker computing device in a first message. In some implementations, the system can send the second encrypted counter register of the shuffled deterministically encrypted data structure to the second worker computing device in a second message to the second worker computing device.
일부 구현예에서, 시스템은 부분적으로 복호화된 확률 데이터 구조에 추가할 노이즈의 양을 결정하기 위해 랜덤 변수를 생성할 수 있다. 일부 구현예에서, 시스템은 기준 노이즈 값 및 최대 빈도 값에 기초하여 노이즈 어레이를 생성할 수 있고, 상기 노이즈 어레이는 복수의 노이즈 값을 포함한다. 일부 구현예에서, 시스템은 순열된 노이즈 어레이를 생성하기 위해 상기 노이즈 어레이를 순열할 수 있다. 일부 구현예에서, 시스템은 암호화된 노이즈 어레이를 생성하기 위해 상기 집합된 공개 키를 사용하여 상기 순열된 노이즈 어레이를 암호화할 수 있다. 일부 구현예에서, 시스템은 상기 암호화된 노이즈 어레이를 애그리게이터 컴퓨팅 디바이스에 전송할 수 있다.In some implementations, the system can generate a random variable to determine the amount of noise to add to the partially decoded probabilistic data structure. In some implementations, a system can generate a noise array based on a reference noise value and a maximum frequency value, the noise array comprising a plurality of noise values. In some implementations, the system can permutate the noise array to generate the permuted noise array. In some implementations, the system can encrypt the permuted noise array using the aggregated public key to create an encrypted noise array. In some implementations, the system can transmit the encrypted noise array to an aggregator computing device.
일부 구현예에서, 시스템은 상기 제2 작업자 컴퓨팅 디바이스로부터 상기 기준 노이즈 값 및 상기 최대 빈도 값을 수신할 수 있다. 일부 구현예에서, 시스템은 제1 암호화된 노이즈 값을 생성하기 위해 상기 집합된 공개 키를 사용하여 상기 순열된 노이즈 어레이의 제1 노이즈 값을 암호화할 수 있다. 일부 구현예에서, 시스템은 제2 암호화된 노이즈 값을 생성하기 위해 상기 집합된 공개 키를 사용하여 상기 순열된 노이즈 어레이의 제2 노이즈 값을 암호화할 수 있다. 일부 구현예에서, 시스템은 상기 암호화된 노이즈 어레이를 생성하기 위해 상기 제1 노이즈 값 및 상기 제2 노이즈 값을 집합할 수 있다.In some implementations, the system can receive the reference noise value and the maximum frequency value from the second worker computing device. In some implementations, the system can encrypt a first noise value of the permuted noise array using the aggregated public key to generate a first encrypted noise value. In some implementations, the system can encrypt the second noise value of the permuted noise array using the aggregated public key to generate a second encrypted noise value. In some implementations, a system can aggregate the first noise value and the second noise value to create the encrypted noise array.
일부 구현예에서, 시스템은 결정론적 암호화 키 및 결정론적 복호화 키를 생성할 수 있다. 일부 구현예에서, 시스템은 상기 작업자 컴퓨팅 디바이스의 메모리에 상기 결정론적 암호화 키 및 상기 결정론적 복호화 키를 저장할 수 있다. 일부 구현예에서, 시스템은 결정론적으로 암호화된 확률 데이터 구조를 생성하기 위해 결정론적 암호화 키를 사용하여 상기 부분적으로 복호화된 확률 데이터 구조를 암호화할 수 있다. 일부 구현예에서, 시스템은 제3 작업자 컴퓨팅 디바이스로부터, 제2 셔플된 결정론적 암호화된 확률 데이터 구조를 수신할 수 있다. 일부 구현예에서, 시스템은 제2 셔플된 부분적으로 복호화된 확률 데이터 구조를 생성하기 위해 상기 결정론적 복호화 키를 사용하여 상기 제2 셔플된 결정론적 암호화된 확률 데이터 구조를 복호화할 수 있다. 일부 구현예에서, 시스템은 상기 제2 셔플된 부분적으로 복호화된 확률 데이터 구조를 제2 작업자 컴퓨팅 디바이스에 전송할 수 있다.In some implementations, the system can generate a deterministic encryption key and a deterministic decryption key. In some implementations, the system can store the deterministic encryption key and the deterministic decryption key in a memory of the worker computing device. In some implementations, the system can encrypt the partially decrypted probabilistic data structure using a deterministic encryption key to produce a deterministically encrypted probabilistic data structure. In some implementations, the system can receive the second shuffled deterministic encrypted probabilistic data structure from a third worker computing device. In some implementations, the system can decrypt the second shuffled deterministic encrypted probabilistic data structure using the deterministic decryption key to produce a second shuffled partially decrypted probabilistic data structure. In some implementations, the system can transmit the second shuffled partially decrypted probabilistic data structure to a second worker computing device.
본 기술 솔루션의 적어도 하나의 다른 양태는 목표 기준을 만족하는 속성을 갖는 멀티세트에서 다수의 멤버를 안전하고 계산적으로 효율적으로 추정하는 방법에 관한 것이다. 방법은 예를 들어 하나 이상의 프로세서들 및 메모리를 포함하는 애그리게이터 컴퓨팅 디바이스에 의해 수행될 수 있다. 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 작업자 컴퓨팅 디바이스로부터 셔플된 암호화된 확률 데이터 구조를 수신하는 단계를 포함할 수 있다. 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 상기 셔플된 암호화된 확률 데이터 구조를 사용하여 히스토그램을 구성하는 단계를 포함할 수 있다. 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 목표 임계치를 만족하는 속성과 연관된 디바이스 식별자의 수를 표현하는 빈도 값을 추정하는 단계를 포함할 수 있다. 상기 방법은 애그리게이터 컴퓨팅 디바이스에 의해, 퍼블리셔 컴퓨팅 디바이스에 목표 임계치를 만족하는 속성과 연관된 디바이스 식별자의 수를 표현하는 빈도 값을 전송하는 단계를 포함할 수 있다.At least one other aspect of the present technical solution relates to a method for safely and computationally efficiently estimating a number of members in a multiset having an attribute that satisfies a target criterion. The method may be performed by, for example, an aggregator computing device including one or more processors and memory. The method may include receiving, by the aggregator computing device, a shuffled encrypted probabilistic data structure from a worker computing device. The method may include constructing, by the aggregator computing device, a histogram using the shuffled encrypted probability data structure. The method may include estimating, by the aggregator computing device, a frequency value representing a number of device identifiers associated with an attribute that satisfies a target threshold. The method may include sending, by the aggregator computing device, to the publisher computing device a frequency value representing a number of device identifiers associated with an attribute that satisfies a target threshold.
일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 상기 셔플된 암호화된 확률 데이터 구조를 제2 작업자 컴퓨팅 디바이스에 전송하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 상기 작업자 컴퓨팅 디바이스로부터 셔플된 부분적으로 복호화된 확률 데이터 구조를 수신하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 셔플된 확률 데이터 구조를 생성하기 위해 상기 결정론적 복호화 키를 사용하여 상기 셔플된 부분적으로 복호화된 확률 데이터 구조를 복호화하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 상기 셔플된 확률 데이터 구조를 사용하여 히스토그램을 구성하는 단계를 포함할 수 있다.In some implementations, the method can include sending, by the aggregator computing device, the shuffled encrypted probability data structure to a second worker computing device. In some implementations, the method can include receiving, by the aggregator computing device, a shuffled partially decrypted probabilistic data structure from the worker computing device. In some implementations, the method may include decrypting, by the aggregator computing device, the shuffled partially decrypted probabilistic data structure using the deterministic decryption key to generate a shuffled probabilistic data structure. can In some implementations, the method can include constructing, by the aggregator computing device, a histogram using the shuffled probability data structure.
일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 복수의 퍼블리셔 컴퓨팅 디바이스 각각으로부터 복수의 암호화된 확률 데이터 구조를 수신하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 복수의 암호화된 확률 데이터 구조를 결합된 암호화된 확률 데이터 구조로 결합하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 상기 결합된 암호화된 확률 데이터 구조를 상기 작업자 컴퓨팅 디바이스에 전송하는 단계를 포함할 수 있다.In some implementations, the method can include receiving, by the aggregator computing device, a plurality of encrypted probabilistic data structures from each of a plurality of publisher computing devices. In some implementations, the method may include combining, by the aggregator computing device, a plurality of encrypted probabilistic data structures into a combined encrypted probabilistic data structure. In some implementations, the method can include transmitting, by the aggregator computing device, the combined encrypted probabilistic data structure to the worker computing device.
일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 동형 추가를 사용하여 상기 복수의 암호화된 확률 데이터 구조를 결합하기 위해 상기 복수의 암호화된 확률 데이터 구조의 제1 암호화된 확률 데이터 구조를 상기 복수의 암호화된 확률 데이터 구조의 제2 암호화된 확률 데이터 구조와 곱하는 단계를 더 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 상기 작업자 컴퓨팅 디바이스로부터 제1 암호화된 노이즈 어레이를 수신하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 제2 작업자 컴퓨팅 디바이스로부터 제2 암호화된 노이즈 어레이를 수신하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 집합된 노이즈 어레이를 생성하기 위해 상기 제1 암호화된 노이즈 어레이 및 상기 제2 암호화된 노이즈 어레이를 집합하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 상기 집합된 노이즈 어레이를 상기 결합된 암호화된 확률 데이터 구조에 첨부하는 단계를 포함할 수 있다.In some implementations, the method uses, by the aggregator computing device, a first encrypted probabilistic data structure of the plurality of encrypted probabilistic data structures to combine the plurality of encrypted probabilistic data structures using isomorphic addition. The method may further include multiplying the plurality of encrypted probability data structures with a second encrypted probability data structure. In some implementations, the method can include receiving, by the aggregator computing device, a first encrypted noise array from the worker computing device. In some implementations, the method can include receiving, by the aggregator computing device, a second encrypted noise array from a second worker computing device. In some implementations, the method can include aggregating, by the aggregator computing device, the first encrypted noise array and the second encrypted noise array to create an aggregated noise array. In some implementations, the method can include appending, by the aggregator computing device, the aggregated noise array to the combined encrypted probability data structure.
일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 평균 노이즈 값을 결정하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 상기 데이터 구조로부터 노이즈를 제거하기 위해 상기 데이터 구조의 적어도 하나의 값으로부터 상기 평균 노이즈 값을 감산하는 단계를 포함할 수 있다. 일부 구현예에서, 셔플된 암호화된 확률 데이터 구조는 노이즈 행렬 세트이고, 상기 노이즈 행렬 세트 각각은 퍼블리셔 컴퓨팅 디바이스의 세트 중 각각에 대응하며, 상기 방법은 애그리게이터 컴퓨팅 디바이스에 의해, 상기 노이즈 행렬 세트의 각 노이즈 행렬에 대한 추정된 카디널리티 값을 추정하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 상기 노이즈 행렬 세트의 각 노이즈 행렬에 대한 추정된 카디널리티 값에 기초하여 상기 노이즈 행렬 세트의 순위를 매기는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 상기 순위에 기초하여 상기 노이즈 행렬 세트의 제1 서브세트 및 상기 노이즈 행렬 세트의 제2 서브세트를 선택하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 상기 노이즈 행렬 세트의 제1 서브세트 및 상기 노이즈 행렬 세트의 제2 서브세트에 기초하여 상기 히스토그램을 구성하는 단계를 포함할 수 있다.In some implementations, the method can include determining, by the aggregator computing device, an average noise value. In some implementations, the method may include subtracting, by the aggregator computing device, the average noise value from at least one value of the data structure to remove noise from the data structure. In some implementations, the shuffled encrypted probabilistic data structure is a set of noise matrices, each set of noise matrices corresponding to a respective one of a set of publisher computing devices, and the method determines, by an aggregator computing device, the set of noise matrices. estimating an estimated cardinality value for each noise matrix. In some implementations, the method may include ranking, by the aggregator computing device, the set of noise matrices based on an estimated cardinality value for each noise matrix in the set of noise matrices. In some implementations, the method may include selecting, by the aggregator computing device, a first subset of the noise matrix set and a second subset of the noise matrix set based on the ranking. In some implementations, the method may include constructing, by the aggregator computing device, the histogram based on the first subset of the noise matrix set and the second subset of the noise matrix set.
일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 상기 노이즈 행렬 행의 포지션의 수의 절반보다 작거나 같은 수의 0을 포함하는 노이즈 행렬의 행을 식별하는 단계를 포함할 수 있고, 상기 노이즈 행렬의 행은 행 인덱스 값에 대응한다. 일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 상기 행 인덱스 값을 사용하여 상기 노이즈 행렬의 추정된 카디널리티 값을 계산하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 상기 노이즈 행렬 세트의 제1 노이즈 행렬의 추정된 카디널리티 값이 상기 노이즈 행렬 세트의 제2 노이즈 행렬의 추정 카디널리티 값보다 크다고 결정하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 제2 순위 값보다 큰 제1 순위 값을 상기 제1 노이즈 행렬에 할당하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 상기 제2 순위 값을 상기 제2 노이즈 행렬에 할당하는 단계를 포함할 수 있다.In some implementations, the method may include identifying, by the aggregator computing device, a row of the noise matrix that contains less than or equal to half the number of zeros in the row of the noise matrix; A row of the noise matrix corresponds to a row index value. In some implementations, the method can include calculating, by the aggregator computing device, an estimated cardinality value of the noise matrix using the row index value. In some implementations, the method further comprises determining, by the aggregator computing device, that an estimated cardinality value of a first noise matrix in the set of noise matrices is greater than an estimated cardinality value of a second noise matrix in the set of noise matrices. can include In some implementations, the method can include assigning, by the aggregator computing device, a first rank value greater than a second rank value to the first noise matrix. In some implementations, the method can include assigning, by the aggregator computing device, the second rank value to the second noise matrix.
일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 상기 노이즈 행렬의 제1 서브세트의 제1 몬테-카를로 샘플링에 기초하여, 제1 디노이징된 유니온 벡터를 생성하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 상기 노이즈 행렬의 제2 서브세트의 제2 몬테-카를로 샘플링에 기초하여, 제2 디노이징된 유니온 벡터를 생성하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 상기 제1 디노이징된 유니온 벡터 및 상기 제2 디노이징된 벡터를 결합된 유니온 데이터 구조로 결합하는 단계를 포함할 수 있다. 일부 구현예에서, 상기 방법은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 상기 결합된 유니온 데이터 구조를 사용하여 히스토그램을 구성하는 단계를 포함할 수 있다.In some implementations, the method may include generating, by the aggregator computing device, a first denoised union vector based on a first Monte Carlo sampling of the first subset of the noise matrix. there is. In some implementations, the method may include generating, by the aggregator computing device, a second denoised union vector based on a second Monte Carlo sampling of the second subset of the noise matrix. there is. In some implementations, the method may include combining, by the aggregator computing device, the first denoised union vector and the second denoised union vector into a combined union data structure. In some implementations, the method can include constructing, by the aggregator computing device, a histogram using the combined union data structure.
본 기술 솔루션의 적어도 하나의 다른 양태는 목표 기준을 만족하는 속성을 갖는 멀티세트에서 다수의 멤버를 안전하고 계산적으로 효율적으로 추정하기 위한 시스템에 관한 것이다. 시스템은 하나 이상의 프로세서 및 메모리를 포함하는 애그리게이터 컴퓨팅 디바이스를 포함할 수 있다. 시스템은 셔플된 확률 데이터 구조를 작업자 컴퓨팅 디바이스로부터 수신할 수 있다. 시스템은 상기 셔플된 암호화된 확률 데이터 구조를 사용하여 히스토그램을 구성할 수 있다. 시스템은 목표 임계치를 만족하는 속성과 연관된 디바이스 식별자의 수를 표현하는 빈도 값을 추정할 수 있다. 시스템은 퍼블리셔 컴퓨팅 디바이스에 목표 임계치를 만족하는 속성과 연관된 디바이스 식별자의 수를 표현하는 빈도 값을 전송할 수 있다.At least one other aspect of the present technical solution relates to a system for safely and computationally efficiently estimating a number of members in a multiset having an attribute that satisfies a target criterion. A system may include an aggregator computing device that includes one or more processors and memory. The system may receive the shuffled probabilistic data structure from the worker computing device. The system may construct a histogram using the shuffled encrypted probability data structure. The system may estimate a frequency value representing the number of device identifiers associated with an attribute that satisfies the target threshold. The system may send the publisher computing device a frequency value representing the number of device identifiers associated with the attribute that satisfy the target threshold.
일부 구현예에서, 시스템은 셔플된 암호화된 확률 데이터 구조를 제2 작업자 컴퓨팅 디바이스에 전송할 수 있다. 일부 구현예에서, 시스템은 제2 셔플된 부분적으로 복호화된 확률 데이터 구조를 작업자 컴퓨팅 디바이스로부터 수신할 수 있다. 일부 구현예에서, 시스템은 셔플된 확률 데이터 구조를 생성하기 위해 상기 결정론적 복호화 키를 사용하여 상기 셔플된 부분적으로 복호화된 확률 데이터 구조를 복호화할 수 있다. 일부 구현예에서, 시스템은 셔플된 확률 데이터 구조를 사용하여 히스토그램을 구성할 수 있다.In some implementations, the system can send the shuffled encrypted probabilistic data structure to the second worker computing device. In some implementations, the system can receive the second shuffled partially decrypted probabilistic data structure from the worker computing device. In some implementations, a system can decrypt the shuffled partially decrypted probabilistic data structure using the deterministic decryption key to produce a shuffled probabilistic data structure. In some implementations, the system can construct the histogram using the shuffled probabilistic data structure.
일부 구현예에서, 시스템은 복수의 퍼블리셔 컴퓨팅 디바이스 각각으로부터 복수의 암호화된 확률 데이터 구조를 수신할 수 있다. 일부 구현예에서, 시스템은 복수의 암호화된 확률 데이터 구조를 결합된 암호화된 확률 데이터 구조로 결합할 수 있다. 일부 구현예에서, 시스템은 결합된 암호화된 확률 데이터 구조를 작업자 컴퓨팅 디바이스에 전송할 수 있다. 일부 구현예에서, 시스템은 동형 추가를 사용하여 상기 복수의 암호화된 확률 데이터 구조를 결합하기 위해 상기 복수의 암호화된 확률 데이터 구조의 제1 암호화된 확률 데이터 구조를 상기 복수의 암호화된 확률 데이터 구조의 제2 암호화된 확률 데이터 구조와 곱할 수 있다.In some implementations, the system can receive a plurality of encrypted probabilistic data structures from each of a plurality of publisher computing devices. In some implementations, the system can combine a plurality of encrypted probabilistic data structures into a combined encrypted probabilistic data structure. In some implementations, the system can transmit the combined encrypted probabilistic data structure to the worker computing device. In some implementations, the system assigns a first encrypted probabilistic data structure of the plurality of encrypted probabilistic data structures to one of the plurality of encrypted probabilistic data structures to combine the plurality of encrypted probabilistic data structures using homomorphic addition. It can be multiplied with a second encrypted probability data structure.
일부 구현예에서, 시스템은 상기 작업자 컴퓨팅 디바이스로부터 제1 암호화된 노이즈 어레이를 수신할 수 있다. 일부 구현예에서, 시스템은 제2 작업자 컴퓨팅 디바이스로부터 제2 암호화된 노이즈 어레이를 수신할 수 있다. 일부 구현예에서, 시스템은 집합된 노이즈 어레이를 생성하기 위해 상기 제1 암호화된 노이즈 어레이 및 상기 제2 암호화된 노이즈 어레이를 집합할 수 있다. 일부 구현예에서, 시스템은 상기 집합된 노이즈 어레이를 상기 결합된 암호화된 확률 데이터 구조에 첨부할 수 있다. 일부 구현예에서, 시스템은 평균 노이즈 값을 결정할 수 있다. 일부 구현예에서, 시스템은 상기 데이터 구조로부터 노이즈를 제거하기 위해 상기 데이터 구조의 적어도 하나의 값으로부터 상기 평균 노이즈 값을 감산할 수 있다.In some implementations, a system can receive a first encrypted noise array from the worker computing device. In some implementations, the system can receive the second encrypted noise array from the second worker computing device. In some implementations, the system can aggregate the first encrypted noise array and the second encrypted noise array to create an aggregated noise array. In some implementations, the system can append the aggregated noise array to the combined encrypted probability data structure. In some implementations, the system can determine an average noise value. In some implementations, the system can subtract the average noise value from at least one value of the data structure to remove noise from the data structure.
일부 구현예에서, 셔플된 암호화된 확률 데이터 구조는 노이즈 행렬 세트이고, 상기 노이즈 행렬 세트 각각은 퍼블리셔 컴퓨팅 디바이스의 세트 중 각각에 대응하며, 시스템은 상기 노이즈 행렬 세트의 각 노이즈 행렬에 대한 추정된 카디널리티 값을 추정할 수 있다. 일부 구현예에서, 시스템은 상기 노이즈 행렬 세트의 각 노이즈 행렬에 대한 추정된 카디널리티 값에 기초하여 상기 노이즈 행렬 세트의 순위를 매길 수 있다. 일부 구현예에서, 시스템은 상기 순위에 기초하여 상기 노이즈 행렬 세트의 제1 서브세트 및 상기 노이즈 행렬 세트의 제2 서브세트를 선택할 수 있다. 일부 구현예에서, 시스템은 상기 노이즈 행렬 세트의 제1 서브세트 및 상기 노이즈 행렬 세트의 제2 서브세트에 기초하여 상기 히스토그램을 구성할 수 있다.In some implementations, the shuffled encrypted probabilistic data structure is a set of noise matrices, each set of noise matrices corresponding to each of a set of publisher computing devices, and the system determines an estimated cardinality for each noise matrix in the set of noise matrices. value can be estimated. In some implementations, the system may rank the set of noise matrices based on an estimated cardinality value for each noise matrix in the set of noise matrices. In some implementations, the system may select the first subset of the noise matrix set and the second subset of the noise matrix set based on the ranking. In some implementations, the system can construct the histogram based on the first subset of the noise matrix set and the second subset of the noise matrix set.
일부 구현예에서, 시스템은 상기 애그리게이터 컴퓨팅 디바이스에 의해, 상기 노이즈 행렬 행의 포지션의 수의 절반보다 작거나 같은 수의 0을 포함하는 노이즈 행렬의 행을 식별할 수 있고, 상기 노이즈 행렬의 행은 행 인덱스 값에 대응한다. 일부 구현예에서, 시스템은 상기 행 인덱스 값을 사용하여 상기 노이즈 행렬의 추정된 카디널리티 값을 계산할 수 있다. 일부 구현예에서, 시스템은 상기 노이즈 행렬 세트의 제1 노이즈 행렬의 추정된 카디널리티 값이 상기 노이즈 행렬 세트의 제2 노이즈 행렬의 추정 카디널리티 값보다 크다고 결정할 수 있다. 일부 구현예에서, 시스템은 상기 제2 순위 값보다 큰 제1 순위 값을 상기 제1 노이즈 행렬에 할당할 수 있다. 일부 구현예에서, 시스템은 상기 제2 순위 값을 상기 제2 노이즈 행렬에 할당할 수 있다.In some implementations, a system may identify, by the aggregator computing device, a row of a noise matrix that contains less than or equal to half the number of positions of the noise matrix row of zeros, the row of the noise matrix corresponds to the row index value. In some implementations, the system can use the row index values to calculate an estimated cardinality value of the noise matrix. In some implementations, the system can determine that an estimated cardinality value of a first noise matrix in the noise matrix set is greater than an estimated cardinality value of a second noise matrix in the noise matrix set. In some implementations, the system can assign a first rank value greater than the second rank value to the first noise matrix. In some implementations, the system can assign the second rank value to the second noise matrix.
일부 구현예에서, 시스템은 상기 노이즈 행렬의 제1 서브세트의 제1 몬테-카를로 샘플링에 기초하여, 제1 디노이징된 유니온 벡터를 생성할 수 있다. 일부 구현예에서, 시스템은 상기 노이즈 행렬의 제2 서브세트의 제2 몬테-카를로 샘플링에 기초하여, 제2 디노이징된 유니온 벡터를 생성할 수 있다. 일부 구현예에서, 시스템은 상기 제1 디노이징된 유니온 벡터 및 상기 제2 디노이징된 벡터를 결합된 유니온 데이터 구조로 결합할 수 있다. 일부 구현예에서, 시스템은 결합된 유니온 데이터 구조를 사용하여 히스토그램을 구성할 수 있다.In some implementations, the system can generate a first denoised union vector based on a first Monte Carlo sampling of the first subset of the noise matrix. In some implementations, the system can generate a second denoised union vector based on a second Monte Carlo sampling of the second subset of the noise matrix. In some implementations, the system can combine the first denoised union vector and the second denoised union vector into a combined union data structure. In some implementations, the system can construct the histogram using a combined union data structure.
본 기술의 이러한 구성과 특징, 그리고 구조의 관련 엘리먼트의 동작 및 기능의 방법 및 부품 및 제조 경제의 조합은 첨부 도면을 참조하여 다음 설명과 첨부된 청구항을 고려하면 더욱 분명해질 것이며, 이들 모두는 본 명세서의 일부를 형성하며, 동일한 참조 번호는 다양한 도면에서 대응하는 부분을 나타낸다. 그러나, 도면은 단지 예시 및 설명을 위한 것이며 본 발명의 한계를 정의하기 위한 것이 아님을 명백히 이해해야 한다. 명세서 및 청구 범위에서 사용된 바와 같이, "a", "an"및 "the"의 단수 형태는 문맥이 달리 명시하지 않는 한 복수의 지시 대상을 포함한다.These constructions and features of the present technology, and methods of operation and function of the relevant elements of the construction, and combinations of parts and manufacturing economies will become more apparent upon consideration of the following description and appended claims, all of which are incorporated herein by reference to the accompanying drawings. Forming a part of the specification, like reference numbers indicate corresponding parts in the various drawings. However, it should be clearly understood that the drawings are for illustration and description only and are not intended to define the limitations of the present invention. As used in the specification and claims, the singular forms of “a”, “an” and “the” include plural referents unless the context dictates otherwise.
첨부된 도면은 일정한 비율로 도시된 것이 아니다. 다양한 도면들에서 동일한 참조 번호 및 기호는 동일한 구성 요소를 표시한다. 명확성을 위해 모든 도면에서 모든 컴포넌트가 라벨링된 것은 아니다. 본 기술 솔루션의 이들 및 다른 양태 및 구성은 첨부 도면과 함께 다음의 설명을 검토하면 통상의 기술자에게 명백해질 것이다.
도 1은 디바이스 식별자의 카운트 및 빈도를 결정하기 위해 카운팅 블룸 필터를 생성하기 위한 시스템의 예시적인 구현예를 도시하는 블록도를 도시한다.
도 2a는 카운팅 블룸 필터로의 제1 데이터 레코드의 삽입을 도시하는 예시적인 시스템 흐름도를 도시한다.
도 2b는 표준 카운팅 블룸 필터로의 제2 데이터 레코드의 삽입을 도시하는 예시적인 시스템 흐름도를 도시한다.
도 2c는 카운팅 블룸 필터로의 제 3 데이터 레코드의 삽입을 도시하는 예시적인 시스템 흐름도를 도시한다.
도 3a는 최소 증가 카운팅 블룸 필터에 제1 데이터 레코드를 삽입하는 예시적인 시스템 흐름도를 도시한다.
도 3b는 최소 증가 카운팅 블룸 필터에 제2 데이터 레코드를 삽입하는 예시적인 시스템 흐름도를 도시한다.
도 3c는 최소 증가 카운팅 블룸 필터에 제 3 데이터 레코드를 삽입하는 예시적인 시스템 흐름도를 도시한다.
도 4a는 동형 암호화 키의 생성 및 분배를 위한 예시적인 시스템의 블록도를 도시한다.
도 4b는 프로세싱을 위해 암호화된 벡터를 생성하고 제1 작업자에게 전송하기 위한 예시적인 시스템의 블록도를 도시한다.
도 4c는 각 작업자에 의해 프로세싱된 결합된 벡터의 부분 복호화 및 셔플링을 위한 예시적인 시스템의 블록도를 도시한다.
도 5는 하나 이상의 데이터 레코드를 표현하는 암호화된 벡터를 생성하는 예시적인 방법을 도시하는 흐름도를 도시한다.
도 6은 작업자 컴퓨팅 디바이스에 의해 집합된 암호화된 벡터를 프로세싱하는 예시적인 방법을 도시하는 흐름도를 도시한다.
도 7은 작업자 컴퓨팅 디바이스에 의한 프로세싱 동안 집합된 암호화된 벡터를 노이즈를 생성하고 통합하는 예시적인 방법을 도시하는 흐름도를 도시한다.
도 8은 본 명세서에서 논의된 임의의 컴퓨터를 구현하기 위해 사용될 수 있는 예시적 컴퓨터 시스템의 일반적인 아키텍처를 도시한다.
도 9a 및 9b는 시스템의 다양한 실험 파라미터의 비교 및 결과 계산에 미치는 영향을 나타내는 예시적 데이터 그래프를 도시한다.
도 10a 및 10b는 시스템의 다양한 실험 파라미터의 비교 및 결과 계산에 미치는 영향을 나타내는 예시적 데이터 그래프를 도시한다.
도 11a 및 11b는 시스템의 다양한 실험 파라미터의 비교 및 결과 계산에 미치는 영향을 나타내는 예시적 데이터 그래프를 도시한다.
도 12는 본 명세서에 기술된 바와 같이 FreqLogLog 구현과 카운팅 블룸 필터 구현 사이의 비교를 도시하는 예시적 데이터 그래프를 도시한다.
도 13a 및 13b는 시스템의 다양한 실험 파라미터의 비교 및 결과 계산에 미치는 영향을 나타내는 예시적 데이터 그래프를 도시한다.
도 14a 및 14b는 시스템의 다양한 실험 파라미터의 비교 및 결과 계산에 미치는 영향을 나타내는 예시적 데이터 그래프를 도시한다.
도 15는 시스템의 다양한 실험 파라미터의 비교 및 노이즈의 추가를 포함하여 결과 계산에 미치는 영향을 나타내는 예시적 데이터 그래프를 도시한다.
도 16a 및 16b는 시스템의 다양한 실험 파라미터의 비교 및 데이터에 노이즈 값의 추가를 포함하여 결과 계산에 미치는 영향을 나타내는 예시적 데이터 그래프를 도시한다.
도 17a 및 17b는 본 명세서에 설명된 바와 같이 대안적 구성에서 노이즈를 구현하는 카운팅 블룸 필터 구현의 다양한 표준 에러 값을 도시하는 예시적 데이터 그래프를 도시한다.
도 18은 계단식 군단 카디널리티 추정기 접근법을 사용한 사용자 식별자 추정의 상대적 오류를 도시한다.
도 19는 계단식 군단 카디널리티 추정기 접근법을 사용하여 사용된 다양한 실험을 예시하는 그래프를 도시한다.
도 20는 하나 이상의 데이터 레코드를 표현하는 암호화된 벡터를 생성하는 예시적인 방법을 도시하는 흐름도를 도시한다.
도 21은 차등적으로 개인 노이징된 계단식 군단 데이터 구조 세트의 카디널리티를 추정하는 예시적인 방법을 도시하는 흐름도를 도시한다.The accompanying drawings are not drawn to scale. Like reference numbers and symbols in the various drawings indicate like elements. For clarity, not all components are labeled in all drawings. These and other aspects and configurations of the present technology solution will become apparent to those skilled in the art upon review of the following description in conjunction with the accompanying drawings.
1 depicts a block diagram illustrating an example implementation of a system for generating a counting bloom filter to determine the count and frequency of device identifiers.
2A shows an exemplary system flow diagram illustrating the insertion of a first data record into a counting bloom filter.
2B depicts an exemplary system flow diagram illustrating the insertion of a second data record into a standard counting Bloom filter.
2C depicts an exemplary system flow diagram illustrating the insertion of a third data record into a counting bloom filter.
3A shows an example system flow diagram for inserting a first data record into a minimum increment counting bloom filter.
3B shows an exemplary system flow diagram for inserting a second data record into a minimum increment counting bloom filter.
3C shows an exemplary system flow diagram for inserting a third data record into a minimum increment counting bloom filter.
4A shows a block diagram of an example system for generating and distributing homomorphic encryption keys.
4B shows a block diagram of an example system for generating and transmitting encrypted vectors to a first operator for processing.
4C shows a block diagram of an exemplary system for partial decoding and shuffling of combined vectors processed by each operator.
5 depicts a flow diagram illustrating an example method for generating an encrypted vector representing one or more data records.
6 depicts a flow diagram illustrating an exemplary method of processing encrypted vectors aggregated by a worker computing device.
7 depicts a flow diagram illustrating an exemplary method for generating noise and integrating aggregated encrypted vectors during processing by a worker computing device.
8 depicts the general architecture of an example computer system that can be used to implement any of the computers discussed herein.
9A and 9B show example data graphs showing comparison of various experimental parameters of the system and their effect on calculation of results.
10A and 10B show exemplary data graphs showing comparison of various experimental parameters of the system and their effect on calculation of results.
11A and 11B show example data graphs showing the comparison of various experimental parameters of the system and their effect on the calculation of results.
12 shows an example data graph illustrating a comparison between a FreqLogLog implementation and a counting bloom filter implementation as described herein.
13A and 13B show example data graphs showing comparison of various experimental parameters of the system and their effect on calculation of results.
14A and 14B show example data graphs showing comparison of various experimental parameters of the system and their effect on calculation of results.
Figure 15 shows an example data graph showing a comparison of various experimental parameters of the system and their effect on the calculation of results, including the addition of noise.
16A and 16B show example data graphs showing a comparison of various experimental parameters of the system and the effect of adding noise values to the data to the resulting calculations.
17A and 17B show example data graphs illustrating various standard error values of counting bloom filter implementations implementing noise in alternative configurations as described herein.
Figure 18 shows the relative error of user identifier estimation using the stepwise corps cardinality estimator approach.
19 shows a graph illustrating various experiments used using the stepwise corps cardinality estimator approach.
20 depicts a flow diagram illustrating an exemplary method for generating an encrypted vector representing one or more data records.
21 depicts a flow diagram illustrating an exemplary method for estimating the cardinality of a set of differentially individual-aged cascaded corps data structures.
다음은 암호화된 확률 데이터 구조에 기초한 대형 멀티세트의 빈도를 추정하는 방법, 장치 및 시스템에 관한 다양한 개념 및 구현의 상세한 설명이다. 상기 소개되고 아래에서 더 자세히 논의되는 다양한 개념들은 기술된 개념들이 임의의 특정한 구현 방식에 제한되지 않기 때문에, 임의의 다수의 방식들로 구현될 수 있다. 특정 구현예 및 적용의 예는 주로 설명적 목적으로 제공된다.The following is a detailed description of various concepts and implementations of a method, apparatus, and system for estimating the frequency of a large multiset based on an encrypted probabilistic data structure. The various concepts introduced above and discussed in more detail below may be implemented in any number of ways, as the described concepts are not limited to any particular implementation manner. Examples of specific implementations and applications are provided primarily for illustrative purposes.
본 명세서에 기술된 기법 다양한 구현예 및 기법에 대한 설명을 읽을 목적으로, 명세서 섹션에 대한 다음의 간단한 설명이 도움이 될 것이다.Techniques Described herein For the purpose of reading a description of various implementations and techniques, the following brief descriptions of sections of the specification will be helpful.
섹션 A는 차등 비공개 방식으로 멀티세트의 빈도와 카디널리티를 추정하기 위해 블룸 필터 카운팅을 구현하는 기법을 설명한다. 하나 이상의 그러한 기법 또는 그 양태는 본 명세서에 기술된 하나 이상의 구현예로 구현될 수 있다.Section A describes a technique for implementing bloom filter counting to estimate the frequency and cardinality of a multiset in a differential privacy manner. One or more such techniques or aspects thereof may be implemented in one or more implementations described herein.
섹션 B는 멀티세트의 빈도와 카디널리티를 추정하기 위해 계단식 군단 데이터 구조를 구현하는 기법을 설명한다. 하나 이상의 그러한 기법 또는 그 양태는 본 명세서에 기술된 하나 이상의 구현예로 구현될 수 있다.Section B describes a technique for implementing a cascading swarm data structure to estimate the frequency and cardinality of a multiset. One or more such techniques or aspects thereof may be implemented in one or more implementations described herein.
섹션 C는 차등 개인 방식에서 멀티세트의 빈도와 카디널리티를 추정하기 위해 차등적으로 개인 계단식 군단 데이터 구조를 구현하는 대안적 기법을 설명한다. 하나 이상의 그러한 기법 또는 그 양태는 본 명세서에 기술된 하나 이상의 구현예로 구현될 수 있다.Section C describes an alternative technique to implement a differentially private cascade data structure to estimate the frequency and cardinality of multisets in a differential private scheme. One or more such techniques or aspects thereof may be implemented in one or more implementations described herein.
섹션 D는 연속 액체 군단을 사용하여 멀티세트의 빈도와 카디널리티를 추정하기 위해 HyperLogLog 스케치의 속성과 카운팅 블룸 필터를 결합하는 기법을 설명한다. 하나 이상의 그러한 기법 또는 그 양태는 본 명세서에 기술된 하나 이상의 구현예로 구현될 수 있다.Section D describes a technique for combining attributes from HyperLogLog sketches with counting bloom filters to estimate the frequency and cardinality of multisets using continuous liquid swarms. One or more such techniques or aspects thereof may be implemented in one or more implementations described herein.
섹션 E는 멀티세트의 빈도와 카디널리티를 추정하기 위해 지수적 일반화 블룸 필터를 구현하는 기법을 설명한다. 하나 이상의 그러한 기법 또는 그 양태는 본 명세서에 기술된 하나 이상의 구현예로 구현될 수 있다.Section E describes a technique for implementing an exponential generalized bloom filter to estimate the frequency and cardinality of a multiset. One or more such techniques or aspects thereof may be implemented in one or more implementations described herein.
본 명세서에서 사용되는 용어 "대안"은 반드시 배타적인 대안 옵션을 지칭하지 않는다 - 서로에 대한 "대안"으로 설명된 다수의 구현예, 기법, 시스템, 방법 또는 프로세스가 적절히 조합되어 사용될 수 있다. The term "alternatives" as used herein does not necessarily refer to exclusive alternative options - the multiple implementations, techniques, systems, methods or processes described as "alternatives" to each other may be used in suitable combination.
본 명세서에서 사용되는 용어 "스케치"는 본 명세서에 기술된 하나 이상의 데이터 엘리먼트, 데이터 레코드, 변수, 카운터 레지스터, 부동 소수점 값, 문자열, 인덱스 값, 메모리 포인터 값 또는 이들의 임의의 조합을 포함하는 하나 이상의 데이터 구조를 의미한다. 용어 "스케치" 및 "데이터 구조"는 때때로 상호 교환적으로 사용될 수 있다.As used herein, the term "sketch" refers to one or more data elements, data records, variables, counter registers, floating point values, strings, index values, memory pointer values, or any combination thereof described herein. above data structure. The terms "sketch" and "data structure" may sometimes be used interchangeably.
A. 시스템 개요 및 카운팅 블룸 필터 빈도 및 카디널리티 추정A. System Overview and Counting Bloom Filter Frequency and Cardinality Estimation
식별자 서버는 예를 들어 각각의 클라이언트 디바이스와 연관된 클라이언트 식별자를 유지함으로써 클라이언트 디바이스 세트와 연관될 수 있다. 각 클라이언트 식별자는 각 식별자 서버와 클라이언트 디바이스 간의 연결을 설명하는 속성 정보를 포함할 수 있다. 속성 정보는 클라이언트 디바이스와 식별자 서버 간의 관계에 대한 정보(예: 웹 브라우징 기록, 인터렉션 데이터, 연결 시간, 네트워크 분석 데이터 등)를 포함할 수 있으며, 각각의 클라이언트 디바이스로부터 수신된 보호된 또는 개인 정보를 포함할 수 있다. 서로 다른 식별자 서버는 동일한 각각의 클라이언트 디바이스에 대응하는 서로 다른 속성 데이터 및 서로 다른 클라이언트 식별자를 유지할 수 있다. 일반적으로 각 식별자 서버 간에 중복된 속성 데이터가 있는지 결정하기 위해 식별자 서버는 보호된 또는 개인 정보를 포함할 수 있는 속성 데이터를 중앙 서버와 공유하여 클라이언트 속성 정보의 중복을 제거할 수 있다. An identifier server may be associated with a set of client devices, for example by maintaining a client identifier associated with each client device. Each client identifier may include attribute information describing a connection between each identifier server and the client device. Attribute information may include information about the relationship between the client device and the identifier server (eg, web browsing history, interaction data, connection time, network analysis data, etc.), and may include protected or personal information received from each client device. can include Different identifier servers may maintain different client identifiers and different attribute data corresponding to the same respective client device. In general, to determine if there is duplicate attribute data between each identifier server, the identifier server may share attribute data, which may contain protected or private information, with the central server to eliminate duplication of client attribute information.
그러나 모든 클라이언트 속성 데이터를 전송하면 확장성에 문제가 발생한다. 클라이언트 식별자 서버 수가 증가하면 일반적으로 네트워크를 통해 전송되는 클라이언트 디바이스 속성 데이터의 양도 증가한다. 속성 데이터는 각 클라이언트 디바이스에 대해 상세하고 상대적으로 클 수 있기 때문에 이러한 정보를 대규모로 전송하면 네트워크 대역폭과 계산 리소스가 소모될 수 있다. 또한 시스템이 총 사용자 식별자 수를 계산하는 것 뿐만 아니라 네트워크를 통해 보호된 또는 개인 속성 정보를 전송하지 않고 특정 속성의 빈도와 같은 특정 속성 데이터 기준을 충족하는 클라이언트 디바이스의 수도 계산하는 것이 유용하다.However, sending all client attribute data causes scalability problems. As the number of client identifier servers increases, the amount of client device attribute data typically transmitted over the network also increases. Because attribute data can be detailed and relatively large for each client device, transmitting this information on a large scale can consume network bandwidth and computational resources. It is also useful for the system to count not only the total number of user identifiers, but also the number of client devices that meet certain attribute data criteria, such as the frequency of certain attributes, without transmitting protected or private attribute information over the network.
앞서 언급한 문제를 해결하기 위해, 이 기술 솔루션의 시스템 및 방법 양태는 카운팅 블룸 필터를 활용하여 다수의 식별자 서버 간에 공통된 클라이언트 디바이스 수를 결정할 수 있다. 각 식별자 서버는 연관된 클라이언트 디바이스 식별자 및 속성 데이터 세트를 표현하는 카운팅 블룸 필터를 생성할 수 있다. 카운팅 블룸 필터는 카운터 레지스터의 벡터("버킷"이라고도 함)일 수 있으며, 각 버킷은 카운팅 블룸 필터의 위치 또는 인덱스 값에 대응하는 버킷 식별자와 연관된다. 각 식별자 서버는 하나 이상의 해시된 식별자를 생성하기 위해 클라이언트 디바이스 식별자 및 속성 데이터에 하나 이상의 해시 함수를 적용할 수 있다. 시스템은 해시된 식별자로부터 카운팅 블룸 필터의 하나 이상의 버킷에 대한 포인터를 추출하고 해당 버킷을 증가시킬 수 있다. 시스템은 블룸 필터의 가장 작은 버킷만 증가되는 최소 증가 기법을 사용할 수 있다. 최소 카운팅 기법을 사용하여, 시스템은 각 식별자 서버와 연관된 총 클라이언트 디바이스 수를 추정할 수 있을 뿐만 아니라 최소 속성 값을 나타내는 속성 데이터와 연관된 클라이언트 디바이스의 수도 추정할 수 있다. 카운팅 블룸 필터는 데이터 세트(예: 블룸 필터 또는 기타 일반화된 데이터 구조)의 아이템 수를 추적할 수 있는 숫자, 정수 또는 값의 문자열일 수 있다. 클라이언트 디바이스 속성의 빈도에 대한 정보를 추정하면 클라이언트 디바이스와 식별자 서버 간의 거시적인 데이터 추세를 결정하는데 유용할 수 있다(예: 네트워크 대역폭 라우팅 및 컴퓨팅 리소스 할당에 대한 결정).To address the foregoing problem, a system and method aspect of this technical solution may utilize a counting bloom filter to determine the number of client devices common among multiple identifier servers. Each identifier server may create a counting bloom filter representing an associated client device identifier and attribute data set. A counting bloom filter can be a vector of counter registers (also referred to as "buckets"), each bucket being associated with a bucket identifier corresponding to the location or index value of the counting bloom filter. Each identifier server may apply one or more hash functions to the client device identifier and attribute data to generate one or more hashed identifiers. The system can extract pointers to one or more buckets of the counting bloom filter from the hashed identifier and increment those buckets. The system may use a least-growth technique in which only the smallest bucket of the bloom filter is incremented. Using the minimum counting technique, the system can estimate the total number of client devices associated with each identifier server, as well as the number of client devices associated with attribute data representing the minimum attribute value. A counting bloom filter can be a number, integer, or string of values that keeps track of the number of items in a data set (e.g., a bloom filter or other generalized data structure). Estimating information about the frequency of client device attributes can be useful in determining macro data trends between client devices and identifier servers (eg, decisions about network bandwidth routing and computing resource allocation).
각 식별자 서버의 카운팅 블룸 필터의 차등 프라이버시를 유지하기 위해, 시스템은 카운팅 블룸 필터의 버킷 히스토그램을 구성하여 버킷을 추상화할 수 있다. 버킷 히스토그램을 생성하기 위해, 각 식별자 서버는 각각의 식별자 서버에만 알려진 개인 키를 사용하여 버킷 단위로 카운팅 블룸 필터를 암호화하고 암호화된 블룸 필터를 알려진 작업자 컴퓨팅 디바이스(예: 작업자 컴퓨팅 디바이스(405), 애그리게이터 컴퓨팅 디바이스(410) 등)에 전송할 수 있다. 작업자 컴퓨팅 디바이스는 모든 식별자 서버 암호화 카운팅 블룸 필터를 하나의 결합된 암호화된 데이터 구조로 결합할 수 있다. 결합된 블룸 필터는 여전히 각 식별자 서버의 개인 키로 암호화된다. 그 후, 결합된 블룸 필터는 공유 키를 사용하여 결합된 필터를 복호화하고 각 버킷을 (예: 결정론적, 비결정론적으로 등) 암호화할 수 있는 각 작업자 컴퓨팅 디바이스에 순차적으로 전달된다. 그 후, 작업은 여러 추가 버킷을 추가 및/또는 제거하여 노이즈를 적용하여, 버킷 히스토그램이 생성될 때 차등적 비공개된다. 작업자는 블룸 필터를 재배치(예: 순열 등)하여 다음 작업자에게 보낼 수 있다. 이는 제1 작업자가 최종 블룸 필터를 다시 수신할 때까지 계속된다. 그 후, 작업자는 각 작업자의 결정론적 키를 사용하여 0에서 원하는 최대 빈도까지 각 값을 암호화할 수 있다. 제1 작업자는 버킷 히스토그램을 구성할 수 있으며, 복호화될 수 없는 임의의 값은 최대 빈도와 동일한 것으로 가정되어 해당 버킷에 추가된다. 최종 히스토그램은 원하는 속성 데이터의 대응 빈도와 함께 모든 식별자 서버에서 고유한 클라이언트 디바이스의 총 수를 추정하는데 사용된다.To maintain the differential privacy of each identifier server's counting bloom filter, the system can abstract buckets by constructing a bucket histogram of the counting bloom filter. To generate the bucket histogram, each identifier server encrypts the counting bloom filter on a bucket-by-bucket basis using a private key known only to each identifier server and sends the encrypted bloom filter to a known worker computing device (e.g. worker computing device 405; aggregator computing device 410, etc.). The worker computing device may combine all identifier server cryptographic counting bloom filters into one combined encrypted data structure. The combined bloom filter is still encrypted with each identifier server's private key. The combined bloom filter is then sequentially passed to each worker computing device, which can decrypt the combined filter using the shared key and encrypt each bucket (eg, deterministically, nondeterministically, etc.). After that, the operation applies noise by adding and/or removing several additional buckets, resulting in differential privacy when the bucket histogram is created. Workers can rearrange bloom filters (e.g. permutations, etc.) and send them to the next worker. This continues until the first operator receives the final bloom filter again. The worker can then use each worker's deterministic key to encrypt each value from 0 to the maximum desired frequency. The first worker can construct a bucket histogram, and any value that cannot be decrypted is assumed to be equal to the maximum frequency and added to that bucket. The resulting histogram is used to estimate the total number of unique client devices at every identifier server, along with corresponding frequencies of the desired attribute data.
따라서 이 기술 솔루션의 양태는 클라이언트 디바이스 식별자 및 데이터 카운팅 시스템의 보안을 강화할 수 있다. 암호화된 카운팅 블룸 필터와 동형 암호화 방식을 사용함으로써, 이 기술 솔루션의 양태는 네트워크를 통해 전송되는 데이터의 양을 줄일 수 있으며, 이는 다른 속성 데이터 카운팅 및 비교 시스템에 비해 상당한 개선이다. 또한 추정된 히스토그램을 사용함으로써, 이 기술 솔루션은 네트워크를 통해 보호된 또는 프라이버시 정보를 전송하지 않고도 클라이언트 식별자 속성 데이터 빈도의 정확한 추정을 제공할 수 있다. 이는 식별자 서버가 연관 디바이스의 수 또는 속성을 노출하지 않도록 보호할 뿐만 아니라 클라이언트 디바이스가 보호된 또는 프라이버시 정보를 노출하지 않도록 보호하여, 네트워킹 시스템의 보안을 크게 향상시킨다.Aspects of this technical solution may thus enhance the security of the client device identifier and data counting system. By using encrypted counting bloom filters and homomorphic encryption schemes, aspects of this technical solution can reduce the amount of data transmitted over the network, which is a significant improvement over other attribute data counting and comparison systems. Also, by using the estimated histogram, this technical solution can provide an accurate estimate of the client identifier attribute data frequency without transmitting protected or privacy information over the network. This not only protects the identifier server from exposing the number or attributes of associated devices, but also protects client devices from exposing protected or privacy information, greatly improving the security of the networking system.
일부 구현예에서, 디바이스 식별자 및 속성 데이터는 식별자 서버에 걸쳐 프라이버시 보존 방식으로 K+ 값을 계산하는데 사용될 수 있다. 특정 속성이 식별자 서버에서 K회 이상 나타나는 빈도를 반영할 수 있는 K+에 대한 값은 본 명세서에 기술된 카운팅 블룸 필터를 사용하여 계산될 수 있다. 측정 방법이 논의되면, 차등 비공개 방식으로 여러 당사자에 걸쳐 블룸 필터를 집합하기 위한 보안 MPC(다자간 통신) 프로토콜이 제공된다.In some implementations, the device identifier and attribute data can be used to calculate the K+ value in a privacy preserving manner across identifier servers. A value for K+, which may reflect the frequency with which a particular attribute appears K or more times in the identifier server, may be calculated using the counting bloom filter described herein. Once the measurement method is discussed, a secure multiparty communication (MPC) protocol is provided for aggregating bloom filters across multiple parties in a differentially private manner.
이 기술 솔루션의 시스템 및 방법은 안전하고 개인 정보를 보호하는 방식으로 다수의 식별자 서버(예: 퍼블리셔, 공급자 등)에서 교차 미디어 도달 및 속성을 측정하려는 업계 전반의 노력을 설명할 수 있다. 수백 또는 수천 개의 식별자 서버가 이 시스템에 참여할 수 있다. K+ 값, 인터섹션, 유니온 및 속성 빈도를 계산하기 위해 여기에 자세히 설명된 알고리즘은 빈도 추정을 위한 카운팅 블룸 필터 및 퍼블리셔 간 블룸 필터를 결합하기 위한 보안 MPC 프로토콜의 사용을 통해 규모의 문제와 엄격한 개인 정보 요구 사항을 모두 해결한다. 마지막으로, 본 솔루션의 양태에 대한 이러한 시스템 및 방법은 임의의 엔터티 세트가 관련된 다른 당사자의 개인 정보 또는 보호된 정보를 침해할 염려없이 상이한 엔터티에 의해 수행, 실행 또는 달리 운영될 수 있다는 것이 중요하다. The systems and methods of this technology solution can address industry-wide efforts to measure cross-media reach and attribution across multiple identifier servers (e.g., publishers, suppliers, etc.) in a secure and privacy-preserving manner. Hundreds or thousands of identifier servers may participate in this system. The algorithm detailed here for computing K+ values, intersections, unions, and attribute frequencies solves the problem of scale and rigorous individual through the use of a counting bloom filter for frequency estimation and a secure MPC protocol for combining inter-publisher bloom filters. Address all your information needs. Finally, it is important that such systems and methods for aspects of the present solution can be performed, executed or otherwise operated by different entities without fear of violating the privacy or protected information of any other party to which any set of entities are involved. .
특정 속성 세트의 도달 범위는 각각의 속성에 노출되었거나 반영된 클라이언트 디바이스의 수로 정의될 수 있다. 빈도는 클라이언트 디바이스가 특정 속성과 연관된 횟수로 정의될 수 있다. K+ 값(예: K+ 도달 범위 등)은 특정 속성에 대해 주어진 값 K보다 큰 빈도를 가진 클라이언트 디바이스의 수를 반영하는 측정치를 기술할 수 있다. 즉, 특정 속성 K 이상과 연관된 클라이언트 디바이스의 수이다. The reach of a particular attribute set can be defined by the number of client devices exposed to or reflected in each attribute. Frequency may be defined as the number of times a client device is associated with a particular attribute. A K+ value (eg, K+ reach, etc.) can describe a measure that reflects the number of client devices with a frequency greater than a given value K for a particular attribute. That is, the number of client devices associated with a particular attribute K or higher.
HyperLogLog(HLL)를 카디널리티 추정기로서 사용될 수 있다. 카디널리티 추정기는 실제로 매우 큰 일부 멀티세트 M의 엘리먼트 수를 추정할 수 있다. HLL은 낮은 오류률, 낮은 분산 및 낮은 메모리 사용량을 특징으로 할 수 있다. 또한 두 HLL의 유니온은 계산하기가 간단할 수 있다. 즉, 분산 카운팅 애플리케이션에서 HLL이 구현될 수 있다. FreqLogLog(FLL)라고 하는 HLL의 확장을 사용하면 M의 엘리먼트 수와 그들의 빈도가 추정되게 할 수 있다. HyperLogLog (HLL) can be used as a cardinality estimator. The cardinality estimator can estimate the number of elements of some multiset M, which is actually very large. HLL can be characterized by low error rate, low variance and low memory usage. Also, the union of the two HLLs can be simple to compute. That is, HLL can be implemented in distributed counting applications. An extension of HLL called FreqLogLog (FLL) allows the number of elements in M and their frequencies to be estimated.
블룸 필터는 세트의 간결한 표현을 제공할 수 있다. 블룸 필터는 insert 및 contains method를 모두 구현할 수 있지만, 간결한 표현으로 인해 contains method가 거짓 긍정을 반환할 가능성이 적다. 즉, 엘리먼트가 세트에 없을 때 세트에 있다고 말할 수 있다. 반면에 거짓 부정은 배제된다. 즉, contains method가 거짓을 반환하면 항상 정확할 수 있다.A bloom filter can provide a concise representation of a set. A bloom filter can implement both the insert and contains methods, but the contains method is less likely to return false positives due to its concise wording. That is, an element can be said to be in a set when it is not in the set. On the other hand, false negatives are excluded. In other words, it can always be correct if the contains method returns false.
빈 블룸 필터는 모든 비트가 0으로 설정된 m 크기의 비트 어레이일 수 있다. 엘리먼트 x는 k 해시 함수 모듈러스 m을 통해 전달한 다음 Bloom 필터의 해당 비트를 1로 설정하여 삽입할 수 있다(아래 예 참조). contains method는 비슷한 방식으로 작동할 수 있으며, x 모듈러스 m의 모든 k 해시가 1로 설정되면 true를 반환하고 그렇지 않으면 false를 반환할 수 있다. 빈 블룸 필터의 예는 아래 표 1에 도시된다.An empty bloom filter can be a bit array of size m with all bits set to 0. Element x can be inserted by passing it through the k hash function modulus m and then setting the corresponding bit in the Bloom filter to 1 (see example below). The contains method can work in a similar way, returning true if all k hashes of x modulus m are set to 1, and false otherwise. An example of an empty bloom filter is shown in Table 1 below.
'값'행으로 표시된 비트 스트링은 빈 블룸 필터를 표현하며, 여기서 블룸 필터의 각 포지션(예: 'ID'행의 숫자 열로 표시됨)는 이진 0 값으로 설정된다. 여기서 m의 값은 11이고 m 포지션의 식별자는 0에서 10까지이다. 비교적 높은 메모리 요구 사항(예: HLL과 관련하여)으로 인해, 일반적으로 블룸 필터는 카디널리티 추정에 사용되지 않을 수 있지만, 블룸 필터의 카디널리티는 다음 공식을 평가하여 결정될 수 있다:The bit string represented by the 'value' row represents an empty bloom filter, where each position of the bloom filter (e.g. represented by a column of numbers in the 'ID' row) is set to a binary zero value. Here, the value of m is 11 and the identifier of position m ranges from 0 to 10. Due to their relatively high memory requirements (e.g. with respect to HLL), bloom filters may not normally be used for cardinality estimation, but the cardinality of a bloom filter can be determined by evaluating the following formula:
위의 식에서 k는 블룸 필터에 사용되는 해시 수, m은 블룸 필터의 비트 수, x는 블룸 필터에 채워진 버킷 수, n은 블룸 필터의 카디널리티 추정의 수일 수 있다.In the above equation, k may be the number of hashes used in the bloom filter, m may be the number of bits of the bloom filter, x may be the number of buckets filled in the bloom filter, and n may be the number of cardinality estimates of the bloom filter.
추정기의 분산은 다음 식으로 근사화된다.The variance of the estimator is approximated by the equation
분산은 테일러 확장(Taylor expansion)에 기초될 수 있다.The variance may be based on Taylor expansion.
편향의 추정치는 다음 방정식에 의해 제공될 수 있다.An estimate of the bias can be given by the equation
CBF(카운팅 블룸 필터)는 삭제 작업을 제공할 수 있는 표준 블룸 필터의 확장이다. 블룸 필터 계산은 표준 블룸 필터와 유사하게 작동한다. 블룸 필터 계산에서 비트 어레이는 카운트 어레이로 대체된다. 완전성을 위해 삭제 동작을 사용하면 거짓 부정 가능성이 발생할 수 있다. 도 2a-2c에 도시된 예는 엘리먼트(x) 중 하나가 두 번 삽입되는 CBF에 3개의 엘리먼트를 삽입하는 것을 표시한다.CBF (Counting Bloom Filter) is an extension of the standard Bloom filter that can provide a deletion operation. Bloom filter calculations work similarly to standard bloom filters. In bloom filter calculations, bit arrays are replaced with count arrays. For completeness, using the delete action can lead to false negatives. The example shown in FIGS. 2A-2C shows inserting three elements into a CBF where one of element x is inserted twice.
최소 증가는 많은 삽입 동작 과정에서 CBF 카운터 값을 최소화할 수 있는 기법을 설명한다. 최소 증가를 사용하여 CBF에 일부 엘리먼트를 삽입할 때, 증가되어야 하는 버킷은 최소값을 가진 버킷이다. 최소 버킷 값은 삽입되는 엘리먼트가 이전에 카운팅 블룸 필터에 삽입되었을 수 있는 최대 횟수를 나타낼 수 있다. 이 기법은 컴퓨터 네트워크에서 트래픽 흐름을 기록하는데 사용될 수 있지만, CBF의 버킷을 1씩 증가시키는 대신 트래픽 흐름 모니터링 애플리케이션은 패킷의 바이트 수만큼 버킷 값을 증가시킬 수 있다. 이렇게 하면 트래픽 과대 평가를 피할 수 있다. 최소 증가 카운팅 블룸 필터의 예가 도 3a-c에 도시된다.Minimum Increment describes a technique that can minimize the CBF counter value over the course of many insert operations. When inserting some elements into a CBF using minimum increment, the bucket that should be incremented is the one with the minimum value. The minimum bucket value may indicate the maximum number of times the inserted element may have previously been inserted into the counting bloom filter. This technique can be used to record traffic flow in a computer network, but instead of incrementing the buckets of the CBF by one, the traffic flow monitoring application can increment the bucket value by the number of bytes in the packet. This avoids overestimating traffic. An example of a minimum increment counting bloom filter is shown in Figures 3a-c.
카운팅 블룸 필터를 사용하여 K+ 값을 추정하는 것은 위에 표시된 블룸 필터 카디널리티 추정 공식을 반복적으로 적용하는 것으로 구성될 수 있다. 기본(1+) 값의 경우 이 기술 솔루션은 공식을 직접 적용할 수 있는 반면 K+ 값의 경우 이 기술 솔루션은 K보다 크거나 같은 값으로 버킷을 채운 다음 동일한 공식을 적용할 수 있다. 예를 들어, 값이 0, 1 또는 2인 모든 버킷을 0으로 카운팅하여 3+ 값을 결정할 수 있다. 중요한 관찰은 이 방법이 히스토그램 빈(bin) 범위가 [0, 1), [1, 2), [2, 3) 등인 CBF 버킷 값의 히스토그램을 사용할 수 있다는 것이다. 멀티 식별자 서버의 경우는 CBF가 동일한 구성(즉, 동일한 m, k 및 해시 함수)을 가지고 있고, 동일한 식별자 공간으로부터 채워졌다고 가정하고, CBF를 버킷 단위로 합산하여 CBF의 유니온(union)을 달성할 수 있음을 관찰하여 해결할 수 있다. Estimating the K+ value using a counting bloom filter can consist of iteratively applying the bloom filter cardinality estimation formula shown above. For base (1+) values, this technical solution can directly apply the formula, whereas for K+ values, this technical solution can fill the bucket with values greater than or equal to K and then apply the same formula. For example, all buckets with a value of 0, 1 or 2 can be counted as 0 to determine the 3+ value. An important observation is that this method can use a histogram of CBF bucket values with histogram bin ranges [0, 1), [1, 2), [2, 3), and so on. In the case of a multi-identifier server, assuming that CBFs have the same configuration (i.e., the same m, k and hash function) and are populated from the same identifier space, CBFs can be summed in bucket units to achieve union of CBFs. Observe that it can be resolved.
CBF 히스토그램의 안전한 계산Safe calculation of CBF histogram
이 프로토콜에 대한 입력은 많은 수의 식별자 서버(예: 퍼블리셔, 공급자 등)(수백 또는 수천 개)에서 나올 수 있으므로, 단순한 MPC 접근 방식을 너무 비효율적이다. 대신, "작업자/클라이언트" MPC 패턴을 따를 것이고, 이 패턴에서는 적은 수의 작업자(예: 3)가 많은 퍼블리셔의 데이터를 사용하여 인터렉티브 MPC 프로토콜에 참여할 수 있다. 제공되는 보안은 모든 작업자 당사자가 손상되지 않는 한 식별자 서버의 데이터가 비공개로 유지될 수 있다는 것이다. 이 방식에서, 다른 엔터티는 다른 작업자를 동작할 수 있다. Inputs to this protocol can come from a large number of identifier servers (e.g. publishers, suppliers, etc.) (hundreds or thousands), making a simple MPC approach too inefficient. Instead, it will follow the “worker/client” MPC pattern, where a small number of workers (e.g. 3) can participate in an interactive MPC protocol using data from many publishers. The security provided is that the data on the identifier server can remain private as long as all worker parties are not compromised. In this way, different entities can operate different workers.
프로토콜은 작업자 역할을 하는 임의의 많은 당사자에게 공개될 수 있다. 많은 구현예에서, 작업자 수는 고정되어 있고 작업자 세트는 프로토콜 존재를 실행하기 전에 나머지 작업자가 알고 있다. 프로토콜 초기화는 작업자 수에서 2차 통신이 필요할 수 있다.The protocol may be open to any number of parties acting as actors. In many implementations, the number of workers is fixed and the set of workers is known to the rest of the workers prior to executing the protocol existence. Protocol initialization may require a secondary communication from the number of workers.
프로토콜에 대한 간단한 설명이 아래에 제공된다.A brief description of the protocol is provided below.
각 작업자(W)는 추가 동형(예: ElGamal) 키 쌍(SK, PK)을 생성할 수 있다. 모든 작업자의 공개 키가 결합되어 각 식별자 서버에 배포되는 UPK(uber-public key)를 생성한다.Each worker (W) can generate additional isomorphic (eg ElGamal) key pairs (SK, PK). All workers' public keys are combined to create an uber-public key (UPK) that is distributed to each identifier server.
각 퍼블리셔(P)는 CBF를 생성하고 UPK를 사용하여 버킷 단위로 암호화하여 잘 알려진 단일 작업자(예: 신뢰할 수 있는 작업자, 임의 작업자 등)에게 보낼 수 있다.Each publisher (P) can generate a CBF, encrypt it on a bucket-by-bucket basis using UPK, and send it to a single well-known worker (e.g. trusted worker, random worker, etc.).
그 다음 제1 작업자는 퍼블리셔 CBF를 버킷 단위로 합산하여 최종 결합 CBF로 결합할 수 있다. 최종 CBF는 여전히 각 작업자의 개인 키로 암호화된다.The first worker may then sum up the publisher CBFs in buckets and combine them into a final combined CBF. The final CBF is still encrypted with each worker's private key.
다음으로, 블룸 필터를 각 작업자에게 전달될 수 있다.Next, a bloom filter may be passed to each operator.
작업자는 SK로 CBF를 복호화하고, 각 버킷을 결정론적으로 암호화할 수 있다.The worker can decrypt the CBF with SK and encrypt each bucket deterministically.
작업자는 버킷 히스토그램이 생성될 때 차등적으로 비공개되도록 여러 추가 버킷을 추가하거나 제거하여 노이즈를 적용할 수 있다. The operator can apply noise by adding or removing several additional buckets to make them differentially private when the bucket histogram is created.
그 다음 작업자는 블룸 필터를 순열할 수 있다.The operator can then permutate the bloom filter.
그 다음 작업자는 순열된 블룸 필터를 다음 작업자에게 보낼 수 있다.The operator can then send the permuted bloom filter to the next operator.
이 프로세스는 제1 작업자가 완전히 결정론적 암호화 방식으로 암호화된 순열된 블룸 필터(예: 링 구성 등)를 다시 받을 때까지 반복된다.This process is repeated until the first worker receives back a permuted bloom filter (eg ring configuration, etc.) encrypted with a fully deterministic encryption scheme.
다음으로, 작업자는 각 작업자의 결정론적 키를 사용하여 0에서 원하는 최대 빈도까지 각 값을 암호화할 수 있다.Next, the worker can use each worker's deterministic key to encrypt each value from 0 to the maximum desired frequency.
제1 작업자는 버킷 히스토그램을 구성할 수 있다. 복호화될 수 없는 임의의 값은 최대 빈도와 동일한 것으로 간주되며 해당 버킷에 추가될 수 있다.The first operator may construct a bucket histogram. Any value that cannot be decrypted is considered equal to the maximum frequency and can be added to that bucket.
마지막으로, 히스토그램은 최대 주파수까지 도달 범위와 빈도를 추정하는데 사용되며 이러한 추정치는 프로토콜의 최종 출력이다.Finally, the histogram is used to estimate the range and frequency of reach up to the maximum frequency, and these estimates are the final output of the protocol.
*ElGamal 암호화 * ElGamal encryption
ElGamal 암호화는 임계치 복호화를 지원하도록 적응될 수 있는 간단한 공개 키 암호화 방식이다. Diffie-Hellman 키 교환 프로토콜의 오프라인 변형으로 볼 수 있으며, 타원 곡선 암호화를 사용하여 구현될 수 있다. 생성기 G가 있는 타원 곡선 그룹의 기본 방식은 다음과 같다.ElGamal cryptography is a simple public key cryptographic scheme that can be adapted to support threshold decryption. It can be viewed as an offline variant of the Diffie-Hellman key exchange protocol, and can be implemented using elliptic curve cryptography. The basic scheme for a group of elliptic curves with generator G is:
KeyGen: 랜덤 정수 X modulo q(타원 곡선 그룹의 순서)를 선택한다. 이는 복호화에 사용되는 개인 키이다; 공개 키는 G^X이다.KeyGen: Choose a random integer X modulo q (order of elliptic curve groups). This is the private key used for decryption; The public key is G^X.
Encrypt(pk, m): 랜덤 정수 R modulo q를 선택한다. 암호문은(G^R, m pk^R), 즉(G^R, m G^(XR))이다.Encrypt(pk, m): Choose a random integer R modulo q. The ciphertext is (G^R, m pk^R), i.e. (G^R, m G^(XR)).
Decrypt(sk, m): 비밀 키를 사용하여 G^(XR)을 계산한 다음 m = m pk^R/G^(XR).Decrypt(sk, m): Compute G^(XR) using the secret key, then m = m pk^R/G^(XR).
이 방식의 임계 버전은 비밀 키 X가 비밀 공유 방식(예: Shamir의 비밀 키 공유 방식 등)을 사용하여 공유로 배포되도록 제공할 수 있다. 각 당사자는 비밀 키의 공유를 사용하여 "공개 키 공유"를 계산할 수 있으며, 그 후 지수에서 비밀 키 공유를 결합함으로써 "진정한" 공개 키를 계산할 수 있다(공유 결합은 선형 작업이므로 그룹 연산을 사용하여 지수로 수행). 임계치가 N-of-N 인 경우, 모든 "공개 키 공유"를 함께 단순히 곱하면 된다. 복호화 공유는 비밀 키 공유를 사용하여 복호화를 수행하고 공개 키가 계산된 것과 동일한 방식으로 결과를 결합하여 계산될 수 있다.A critical version of this scheme may provide that the secret key X is distributed as a share using a secret-sharing scheme (eg Shamir's secret-key-sharing scheme). Each party can compute a "public key share" using its share of the secret key, then compute the "true" public key by combining the secret key shares on exponents (using a group operation since shared combination is a linear operation). and do it exponentially). If the threshold is N-of-N, simply multiply all "public key shares" together. The decryption share can be computed by performing decryption using a secret key share and combining the results in the same way the public key is computed.
임계치 변형의 간단한 예는 다음과 같습니다: 두 작업자가 G^X 및 G^Y 키를 생성한다. 이 공개 키를 곱하면, 암호화를 위한 공개 키로 사용될 수 있는 G^(X + Y)를 얻고, 대응 비밀 키는 X+Y이다. 그러나 복호화를 위해 원래 비밀 키를 (순서에 관계없이) 하나씩 적용할 수 있으므로 단일 당사자가 공동 개인 키를 알 필요가 없다.A simple example of threshold transformation is as follows: Two workers generate keys G^X and G^Y. Multiplying this public key, we get G^(X + Y), which can be used as the public key for encryption, and the corresponding private key is X+Y. However, since the original secret keys can be applied one-by-one (in any order) for decryption, no single party needs to know the joint private key.
ElGamal 암호화는 추가적인 유용한 속성을 포함할 수 있다: 곱셈 동형을 지원할 수 있다. 두 개의 암호문(G^ R1, M1 G^X R1), (G^R2, M2 G^X R2)이 주어지면, (G^(R1 + R2), M1 M2 G^X(R1 + R2))를 계산할 수 있고, 두 메시지의 곱으로 복호화할 수 있다. 이것은 메시지의 이산 로그에 대한 추가 동형이다; 즉, 우리는 작은 메시지 공간(이산 로그를 효율적으로 계산하는데 충분하게 작은)에서 작동하는 (G^(R1 + R2), G^(M1+M2) G^X(R1 + R2))를 계산하기 위해 이것을 사용할 수 있었다.ElGamal encryption can include an additional useful property: it can support multiplicative isomorphism. Given two ciphertexts (G^R1, M1 G^X R1), (G^R2, M2 G^X R2), (G^(R1 + R2), M1 M2 G^X(R1 + R2)) can be calculated, and can be decoded by multiplying two messages. This is an additional isomorphism for the discrete logarithm of a message; That is, we need to compute (G^(R1 + R2), G^(M1+M2) G^X(R1 + R2)) operating in a small message space (small enough to compute the discrete logarithm efficiently). could use this for
우리의 경우, 지수에서 합계를 수행하는 것으로 충분할 수 있다. 카운팅 블룸 필터 추정은 임계 K 미만의 엘리먼트 카운트를 사용할 수 있으며, 이는 룩업 테이블이 디코딩에 충분할 만큼 작다. 여기에 작은 보안 이점도 있다: 애그리게이터는 해당 값이 무엇인지 알지 않고도 임계치를 초과하는 값의 카운트를 학습할 수 있다. 이를 위해, 작업자는 결정론적 암호화(예: Pohlig-Hellman 암호 등)를 사용할 수 있으며, 이는 각 작업자가 부분적으로 복호화된 모든 버킷에 적용되는 비밀 지수를 선택하는 것을 포함할 수 있다; 이것은 동형을 통해서도 수행될 수 있다(이것은 생성기 G를 임의의 그룹 엘리먼트로 변경하는 것과 같다).In our case, performing sums on exponents may be sufficient. Counting bloom filter estimates can use element counts below the threshold K, which are small enough for the lookup table to decode. There's also a small security benefit here: the aggregator can learn counts of values that exceed a threshold without knowing what those values are. To do this, workers can use deterministic cryptography (such as the Pohlig-Hellman cipher), which can involve each worker choosing a secret exponent that applies to all partially decrypted buckets; This can also be done via isomorphism (this is like changing generator G to any group element).
블룸 필터를 사용한 접근법, (n-1) 공모(Collusion) HBCApproach using bloom filter, (n-1) Collusion HBC
이 접근법에서 작업자는 임계 개인 키와 함께 추가 동형 암호화를 사용하여, 카운팅 블룸 필터의 합계를 계산한 다음, 애그리게이터에게 결과를 공개하기 전에 보안 셔플 및 결정적 암호화를 수행할 수 있다. 합산은 가산적 동형을 사용하여 한 당사자가 직접 계산할 수 있다(예: 퍼블리셔가 블룸 필터의 암호화를 지정된 작업자에게 보내도록 함 등). In this approach, a worker can use additional homomorphic encryption with a critical private key to compute the sum of a counting bloom filter, then perform a secure shuffle and deterministic encryption before revealing the result to the aggregator. The sum can be computed directly by one party using additive isomorphism (e.g. by having the publisher send the bloom filter's encryption to a designated worker).
효율적으로 순열하기 위해, 이 기술 솔루션은 암호화 방식의 임계 속성을 사용할 수 있다. 단일 당사자가 순열을 수행하는 것을 신뢰하지 않도록, 솔루션은 각 당사자가 무작위로 필터를 순열하도록 할 수 있다(두 순열의 구성은 순열임을 기억). 암호화된 블룸 필터를 수신하고 초기 합산을 계산한 제1 당사자가 제1 순열을 수행할 수 있다. 그 후, 해당 당사자는 암호화된 블룸 필터를 다시 랜덤화한 다음, 복호화 키 공유를 적용하여 결과를 부분적으로 복호화하고 마지막으로 결정론적 방식의 키 공유를 적용할 수 있다. 그 후, 셔플/재랜덤화된 암호문은 다음 당사자에게 전송될 수 있으며, 마지막에는 최종 복호화를 위해 애그리게이터에게 전송될 수 있다.To permutate efficiently, this technical solution can use the critical properties of cryptography. To avoid trusting a single party to perform the permutation, the solution could be to have each party randomly permutate the filter (remember that the composition of two permutations is a permutation). A first party that receives the encrypted bloom filter and computes the initial summation may perform the first permutation. Then, that party can randomize the encrypted bloom filter again, apply decryption key sharing to partially decrypt the result, and finally apply deterministic key sharing. The shuffled/rerandomized ciphertext can then be sent to the next party and finally to the aggregator for final decryption.
1 단계 : ElGamal 키 설정Step 1: Set up the ElGamal key
제1 단계로, 작업자는 위에서 설명한 대로 임계 ElGamal 키를 설정한 다음, 결합된 키를 각 퍼블리셔가 사용할 수 있게 한다. As a first step, the operator establishes a critical ElGamal key as described above, then makes the combined key available to each publisher.
2 단계 : 입력Step 2: Enter
이 프로토콜은 합계를 계산할 수 있다. 식별자 서버는 작업자가 제공한 복합 공개 키를 사용하여 버킷 단위로 카운팅 블룸 필터를 암호화하고, 임의로 선택할 수 있는 "제1" 당사자에게 암호문을 보낼 수 있다. 그 후, 해당 당사자는 암호문에 대한 동형 더하기 연산을 사용하여 합계를 계산할 수 있으며, 결정론적 암호화 하에서 애그리게이터가 학습할 수 있는 값을 암호화하여 디코딩 룩업 테이블을 추가할 수 있다. 이 당사자가 애그리게이터 자체가 될 수 있지만, 이 경우 애그리게이터는 암호문을 순열을 위해 다음 당사자에게 보내기 전에 부분적으로 암호를 복호화해서는 안된다. - 애그리게이터의 복호화는 애그리게이터가 결과를 학습하도록 보장하는 마지막 단계여야 한다(순열되고 결정론적으로 암호화된 블룸 필터).This protocol can compute sums. The identifier server may encrypt the counting bloom filter on a bucket-by-bucket basis using the operator-provided composite public key, and send the ciphertext to a "first" party that may be arbitrarily selected. Then, that party can compute the sum using an isomorphic addition operation on the ciphertext, and under deterministic encryption encrypt the values the aggregator can learn, adding a decoding lookup table. This party could be the aggregator itself, but in that case the aggregator MUST NOT partially decrypt the ciphertext before sending it to the next party for permutation. - Decryption of the aggregator should be the last step to ensure that the aggregator learns the result (permuted and deterministically encrypted bloom filter).
3 단계: 셔플링Step 3: Shuffling
다음으로, 제1 당사자는 암호문을 부분적으로 복호화하고, 결정론적 암호화 키를 적용하고, 암호화된 필터(룩업 테이블이 아님)를 셔플링하고, 모든 것을 제2 당사자에게 전달할 수 있다. 그 후, 제2 당사자는 부분적으로 암호를 복호화하고, 그 키 하에서 결정론적 암호화를 적용하고, 유일한 남은 복호화가 애그리게이터의 키와 관련될 때까지 셔플(예: 확률적 데이터 구조에서 순열, 순서 변경 또는 포지션 스왑 등)하고, 모든 것을 제3 당사자 등에게 전달할 수 있다.Next, the first party can partially decrypt the ciphertext, apply the deterministic encryption key, shuffle the encrypted filter (not the lookup table), and pass everything on to the second party. The second party then partially decrypts the cipher, applies deterministic encryption under that key, and shuffles it until the only remaining decryption involves the aggregator's key (e.g. permutation, reordering in probabilistic data structures). or position swap, etc.), and pass everything on to a third party, etc.
비밀 공유 방식에 대해 임계치 N을 설정함으로써, 이 기술 솔루션은 작업자의 공모 서브세트가 다른 당사자의 개인 정보를 침해할 수 없도록 한다. 작업자 중 한 명만 순열을 비밀로 유지해야 하기 때문에, 순열은 작업자 간의 임의 공모에 대해 비밀로 유지될 수도 있다. 또 다른 옵션은 MPC 프로토콜을 사용하여 K보다 큰 값의 합계를 계산하는 것이지만 그렇게하는 것은 훨씬 더 많이 계산 집약적일 수 있다.By setting a threshold N for secret-sharing schemes, this technical solution ensures that a colluding subset of workers cannot compromise the privacy of other parties. Since only one of the workers must keep the permutation secret, the permutation may be kept secret against any collusion between the workers. Another option is to compute the sum of values greater than K using the MPC protocol, but doing so can be much more computationally intensive.
분산된 차등 비공개 노이즈 생성Distributed differential private noise generation
노이즈의 추가는 분산된 방식으로 발생하므로, 각 히스토그램 빈에 추가된 총 노이즈는 본 명세서에 기술된 양측 기하학적 분포(two-tailed geometric distribution)를 따를 수 있다. 특히, 각 히스토그램 빈, [0, 최대 빈도]에 대해 각 작업자는 작업자가 각 빈에 추가할 수 있는 노이즈의 양을 결정할 수 있는 랜덤 변수(예: Polya(음이 항의 특수한 경우) 랜덤 변수 등)를 생성할 수 있다. 따라서, 적절하게 구성된 랜덤 변수의 합이 양측 기하학적 랜덤 변수와 같을 수 있으므로, 각 빈은 원하는 양의 노이즈를 수신할 수 있다. 이를 달성하기 위해 위에서 설명한 프로토콜에 몇 가지 수정 사항이 있다.Since the addition of noise occurs in a distributed manner, the total noise added to each histogram bin may follow the two-tailed geometric distribution described herein. In particular, for each histogram bin, [0, max frequency], each operator has a random variable (e.g., Polya (a special case of negative term) random variable, etc.) that allows the operator to determine how much noise the operator can add to each bin. can create Thus, each bin can receive a desired amount of noise, since the sum of a properly constructed random variable can be equal to both geometric random variables. There are several modifications to the protocol described above to achieve this.
셔플(예: 각 작업자의 순열)이 시작되기 전에 다음이 발생할 수 있다.Before the shuffle (e.g. permutation of each worker) starts, the following can happen:
작업자는 노이즈 기준에 동의할 수 있으며, 이는 높은 확률로 개별 작업자가 생성한 음의 노이즈 값보다 클 수 있는 정수일 수 있다. 이 값을 B라고 한다.Operators can agree on a noise criterion, which can be an integer that can with high probability be greater than the negative noise value generated by an individual operator. Let this value be B.
각 작업자는 max_frequency + 1 개의 랜덤 변수(예: Polya 랜덤 변수 등) [X0, X1, ... Xi, ..., Xmf]를 생성할 수 있고, 크기 B - X i 의 어레이를 생성한다. 이것을 노이즈 어레이라고 한다.Each worker can generate max_frequency + 1 random variables (e.g. Polya random variables, etc.) [X 0 , X 1 , ... X i , ..., X mf ], arrays of size B - X i generate This is called a noise array.
그 후, 각 i에 대해, 노이즈 어레이를 i의 B - X i 사본으로 채울 수 있다.Then, for each i , we can fill the noise array with B - X i copies of i .
그 후, 각 작업자는 노이즈 어레이를 셔플링하고 ElGamal 공개 키로 각 값을 암호화할 수 있다.After that, each worker can shuffle the noise array and encrypt each value with the ElGamal public key.
그 후, 각 작업자는 셔플을 시작할 작업자에게 노이즈 어레이를 보낼 수 있다.After that, each worker can send a noise array to the worker who will start the shuffle.
그 후, 제1 작업자는 위의 프로토콜에 설명된 대로 모든 CBF를 합산하기 전에 모든 노이즈 어레이를 CBF에 첨부할 수 있다.After that, the first operator can append all the noise arrays to the CBF before summing all the CBFs as described in the protocol above.
마지막으로, 히스토그램이 구성된 후 애그리게이터는 B * 각 히스토그램 버킷에서 작업자 수를 빼면, 기본적으로 각 빈에서 노이즈 기준을 제거하고 양면 기하학적 노이즈만 남길 수 있다.Finally, after the histogram is constructed, the aggregator can subtract B * the number of workers in each histogram bucket, essentially removing the noise criterion from each bin and leaving only the two-sided geometric noise.
위의 프로토콜에 대한 적어도 하나의 보호는 식별자 서버가 자체 임계치를 유지하여 N 클라이언트 식별자 또는 속성을 이미 포함하지 않는 한 계산에 대한 세트를 제공하지 않는 것이다. 셔플 단계 동안에 블룸 필터에 DP 노이즈를 추가하면 문제를 완화하는 데 도움이 된다.At least one protection against the above protocol is that the identifier server maintains its own threshold to not provide a set for computation unless it already contains N client identifiers or attributes. Adding DP noise to the bloom filter during the shuffle phase helps alleviate the problem.
카디널리티/주파수 추정에 CBF를 사용할 때의 근본적인 문제는 고정 오류율을 유지하는데 필요한 버킷 수가 추정되는 세트의 크기에서 선형적으로 확장된다는 것이다. 또한 보안 프로토콜에서는 각 퍼블리셔가 생성되는 모든 CBF의 각 버킷을 암호화해야 한다.A fundamental problem with using CBF for cardinality/frequency estimation is that the number of buckets required to keep a fixed error rate scales linearly with the size of the set being estimated. Security protocols also require each publisher to encrypt each bucket of every CBF created.
문제의 규모는 다양한 속성에서 도달 값을 계산하기 위해 하루에 약 500억 개의 식별자를 프로세싱될 수 있다고 가정할 수 있다. 블룸 필터가 여기에 3배의 오버 헤드를 추가한다고 가정하면 각 식별자 서버는 1,500 억 개의 버킷 암호화를 수행할 수 있으며, 위 문서의 숫자를 사용하면 ~42 CPU 시간이 필요함을 의미한다. 64 바이트 암호 텍스트를 가정하면, 하루에 약 9.6TB의 데이터 전송을 제공할 수 있다. 이는 특히 모든 규모의 퍼블리셔에게 적용되는 상수라는 점을 반영할 때 상당할 수 있다. 다행히, 이 오버 헤드를 완화할 수 있는 몇 가지 방법이 있다.For the scale of the problem, it can be assumed that about 50 billion identifiers can be processed per day to calculate reach values for various attributes. Assuming the bloom filter adds 3x the overhead to this, each identifier server can do 150 billion bucket encryptions, which using the numbers from the document above means it will take ~42 CPU hours. Assuming 64-byte ciphertext, it can provide about 9.6TB of data transfer per day. This can be significant, especially when you consider that it is a constant that applies to publishers of all sizes. Fortunately, there are several ways to mitigate this overhead.
첫째, 식별자 서버 측 암호화를 제거할 수 있으며 이에 따라 수반되는 암호문 확장으로 인한 통신 오버 헤드를 제거할 수 있다. 여기서, 각 버킷에 대해, 식별자 서버는 CBF가 합산된 엘리먼트가 CBF와 동일한 k 어레이로 표현되도록 버킷 값에 합산되는 k 개의 난수를 생성할 수 있다. 그 후, 식별자 서버는 위에서 설명한 대로 El Gamal 암호화 레이어를 적용하기 전에 퍼블리셔 간에 CBF 공유를 합산할 수 있는 개별 MPC 작업자에게 CBF 공유라고 하는 어레이를 보낼 수 있다. 암호화되면 각 작업자는 암호화된 CBF 공유를 결합할 수 있는 단일 작업자에게 보낼 수 있으며, 그 결과 완전히 결합된 x-pub CBF가 된다. 여기에서 위에서 설명한 프로토콜의 복호화/셔플 단계가 시작될 수 있다. 이 옵션에서, 버킷 공유의 크기는 1 바이트, 2 바이트 또는 4 바이트가 될 수 있으며 결과적으로 하루에 450GB, 900GB 또는 1800GB의 데이터 전송이 가능하다. 여기서 1 바이트의 경우(3 공유 * 1 바이트 * 500억). 이것은 MPC 시스템, 보안 식별자 카운팅 시스템, 빈도 카운팅 시스템 및 식별자 통신 시스템에 실질적 개선을 제공할 수 있다.First, the identifier server-side encryption can be eliminated, thereby eliminating the communication overhead due to the accompanying ciphertext expansion. Here, for each bucket, the identifier server may generate k random numbers that are added to the bucket value so that the elements to which the CBF is summed are expressed in k arrays equal to the CBF. The identifier server can then send an array called CBF shares to individual MPC workers who can sum the CBF shares between publishers before applying the El Gamal encryption layer as described above. Once encrypted, each worker can send its encrypted CBF shares to a single worker that can combine them, resulting in a fully combined x-pub CBF. This is where the decryption/shuffle phase of the protocol described above can begin. In this option, the size of the bucket share can be 1 byte, 2 bytes or 4 bytes, resulting in a transfer of 450GB, 900GB or 1800GB of data per day. For 1 byte here (3 shares * 1 byte * 50 billion). This can provide substantial improvements to MPC systems, secure identifier counting systems, frequency counting systems and identifier communication systems.
적어도 한 가지 개선 사항은 식별자 서버가 작업자 중 하나를 신뢰하고 해당 작업자에게 CBF를 전송하는 것이다. 그 후, 단일 작업자의 CBF를 명확하게 결합할 수 있으며, 해당 작업자는 부분 x-pub CBF를 암호화하는 부담을 감당할 수 있다. 이러한 부분적 x-pub CBF는 동형으로 결합할 수 있는 단일 작업자에게 보낼 수 있다. 그리고, 여기에 설명된 바와 같이, 복호화/셔플 단계가 시작될 수 있다. 이 경우 버킷 당 1 바이트를 가정하면 하루에 150GB의 데이터 전송이 있다. 이것은 MPC 시스템, 보안 식별자 카운팅 시스템, 빈도 카운팅 시스템 및 식별자 통신 시스템에 실질적 개선을 제공할 수 있다.At least one improvement would be for the identifier server to trust one of the workers and send the CBF to that worker. After that, you can unambiguously combine a single worker's CBF, and that worker can bear the burden of encrypting the partial x-pub CBF. These partial x-pub CBFs can be sent to a single worker that can be isomorphically combined. And, as described herein, a decryption/shuffle step may begin. In this case, assuming 1 byte per bucket, we have 150 GB of data transfer per day. This can provide substantial improvements to MPC systems, secure identifier counting systems, frequency counting systems and identifier communication systems.
흥미롭게도, 여기에 설명된 구현예는 위에서 설명된 두 가지 대안과 결합될 수 있으며, 각 식별자 서버(예를 들어, 퍼블리셔)는 시스템과 상호 작용하는 방법을 독립적으로 선택할 수 있다. 덧산의 연관성에 의해 각 작업자는 CBF 공유와 일반 텍스트 CBF를 쉽게 결합할 수 있다. 그 후, 모든 작업자가 그들의 암호화된 부분 x-pub CBF를 상기 암호화된 부분 x-pub CBF를 동형으로 결합하여 완전한 x-pub CBF를 얻을 수 있는 단일 작업자에게 전송하기 전에 이러한 조합을 암호화하고 작업자 별로 다른 암호화된 CBF와 결합할 수 있고, 다시 원래 프로토콜의 셔플 단계를 시작할 수 있다. 이것은 MPC 시스템, 보안 식별자 카운팅 시스템, 빈도 카운팅 시스템 및 식별자 통신 시스템에 실질적 개선을 제공할 수 있다.Interestingly, the implementations described herein can be combined with the two alternatives described above, with each identifier server (eg, publisher) independently choosing how to interact with the system. By the associativity of addition, each worker can easily combine CBF sharing and plain text CBF. Then, all workers encrypt their encrypted partial x-pub CBFs before sending them to a single worker that can isomorphically combine the encrypted partial x-pub CBFs to obtain a complete x-pub CBF, You can combine it with another encrypted CBF, and start the shuffle phase of the original protocol again. This can provide substantial improvements to MPC systems, secure identifier counting systems, frequency counting systems and identifier communication systems.
다음은 차등 비공개 CBF 히스토그램을 계산하기 위한 암호화 보안 프로토콜을 설명한다.The following describes a cryptographically secure protocol for computing differential private CBF histograms.
차등 비공개 CBF 버킷Differential Private CBF Buckets
전체 CBF를 쿼리의 출력으로 사용하는 제1 작업은 민감도를 결정하는 것이다. 이는 먼저 단일 속성의 경우에 수행된 다음, 단일 클라이언트 디바이스와 연관된 모든 속성으로 확장될 수 있다. 충돌을 무시하고, 최대 k(해시 수) 버킷이 삽입 당 증가한다. 최소 증가 사례의 경우 더 작을 수 있지만, 최악의 경우 개인 정보를 손상시키지 않으며, 최소 증가 사례를 특성화하는 것은 다루기 어려운 것처럼 보인다.The first task of using the full CBF as the output of a query is to determine the sensitivity. This can be done first in the case of a single attribute and then extended to all attributes associated with a single client device. Ignoring collisions, up to k (number of hashes) buckets are incremented per insert. For the minimally increasing case it may be smaller, but in the worst case it does not compromise privacy, and characterizing the minimally increasing case seems intractable.
단일 노출에 대한 쿼리 민감도를 고려하는 적어도 한 가지 방법은 각 해시 함수의 출력을 L1 민감도가 1인 별개의 쿼리로 간주하는 것이다. 이 경우 전체 CBF 쿼리의 민감도는 k이다. 다른 극단은 전체 CBF 쿼리의 민감도를 1로 선언하는 것이다. 다음은 이 특성화를 진행하며, 이 완화된 가정에서도 버킷 수준의 DP가 실행 가능하지 않음을 보여준다.At least one way to consider the sensitivity of a query to a single impression is to consider the output of each hash function as a separate query with an L1 sensitivity of 1. In this case, the sensitivity of the entire CBF query is k. The other extreme is to declare the sensitivity of the entire CBF query as 1. The following proceeds with this characterization, showing that even with this relaxed assumption, bucket-level DP is not feasible.
민감도는 인접한 두 데이터베이스 간의 최대 거리로 정의할 수 있다. 그 후, 단일 노출에 대한 CBF의 민감도가 1이라고 가정하면, 이를 클라이언트 식별자로 확장하면, 민감도가 특정 속성과 가장 많이 연관된 클라이언트 식별자와 연관된 속성의 총 수와 같을 수 있다. 다시 말해, 이것은 최대 빈도가 될 수 있으며, 이는 k 개의 가장 큰 버킷의 최소값에 의해 제한될 수 있고, 여기서 이에 대한 인수는 최소 증가의 유효성에 대한 인수와 유사하다.Sensitivity can be defined as the maximum distance between two adjacent databases. Then, assuming that the sensitivity of the CBF for a single exposure is 1, extending this to the client identifier, the sensitivity can be equal to the total number of attributes associated with the client identifier most associated with a specific attribute. In other words, this can be the maximum frequency, which can be bounded by the minimum of the k largest buckets, where the factor for this is similar to the factor for the effectiveness of the minimum increment.
그 다음 CBF를 차등적 비공개로 하려면, 설명된 바와 같이 최대 빈도를 추정하고, 각 버킷에 양면 기하학적 노이즈를 적용하여, 음이 되는 버킷이 0값을 갖도록 노이즈를 잘라 내면 충분한다. 다음 표는 다양한 엡실론 및 민감도 값에 대한 기하학적 분포에 대한 파라미터를 도시한다.Then, to make the CBF differentially private, it is sufficient to estimate the maximum frequency as described, apply a two-sided geometrical noise to each bucket, and clip the noise so that the buckets that become negative have zero values. The following table shows the parameters for the geometric distribution for various epsilon and sensitivity values.
한 가지 관찰은 엡실론과 민감도의 적당한 값 조차도 분포의 꼬리가 상당히 길 수 있다는 것이다. 예를 들어, 최대 빈도에 대한 일반적인 값이 상당히 과소 평가될 수 있는 8이라고 가정하면, 엡실론이 1인 경우에도 필요한 노이즈의 양은 견딜 수 없는 것처럼 보이기 시작한다. 그러나 버킷 카운트의 히스토그램을 추정에 사용할 수 있으므로, 집합에서 노이즈가 제거될 수 있는 가능성이 있다. 특히, 노이즈가 있는 히스토그램은 양면 기하 분포의 기대치에 기초하여 디노이징된 히스토그램을 생성하는 보정 행렬로 곱해질 수 있다.One observation is that even moderate values of epsilon and sensitivity can have quite long tails in the distribution. Assuming, for example, that a typical value for maximum frequency is 8, which can be significantly underestimated, even with epsilon equal to 1, the amount of noise needed starts to seem unbearable. However, since the histogram of bucket counts can be used for estimation, there is a possibility that noise can be removed from the set. In particular, the noisy histogram can be multiplied with a correction matrix that creates a denoised histogram based on the expected value of the two-sided geometric distribution.
X는 버킷에 양면 기하학적 노이즈를 적용한 후 CBF 버킷의 히스토그램이 될 수 있는 노이즈이 있는 히스토그램이다. Y는 원래 CBF에서 생성된 히스토그램이다. 그러면:X is the histogram with noise that would be the histogram of the CBF buckets after applying the two-sided geometric noise to the buckets. Y is the histogram generated from the original CBF. then:
E[X] = A * YE[X] = A * Y
여기서:here:
A = [a0, a1, a2, …, ai, ... an]T A = [a 0 , a 1 , a 2 , … , a i , ... a n ] T
그리고 각 ai는 n+1 엘리먼트를 가진 행 벡터일 수 있다.And each ai can be a row vector with n+1 elements.
a0 =[P(Z <= 0), …, P(Z <= n)]a0 = [P(Z <= 0), ... , P(Z <= n)]
ai =[P(Z = i - j)] - for j in [0, n]ai = [P(Z = i - j)] - for j in [0, n]
an =[P(Z >= n), …, P(Z >= 0)]an = [P(Z >= n), … , P(Z >= 0)]
그리고 Z는 양면 기하 랜덤 변수일 수 있다. 기본적으로, a i *Y는 Y의 엘리먼트가 X의 특정 빈에 할당될 예상치일 수 있다. A는 열 확률적일 수 있다.and Z may be a two-sided geometric random variable. Basically, a i *Y can be an estimate that elements of Y will be assigned to specific bins of X. A can be ten stochastic.
그 다음, =A -1 * X이고, 여기서 는 카디널리티를 추정하는데 사용될 수 있는 디노이징된 히스토그램일 수 있다.next, = A -1 * X , where can be a denoised histogram that can be used to estimate cardinality.
적어도 하나의 다른 구현예에서, K+ 값 추정 함수는 다음과 같이 진행될 수 있다.In at least one other implementation, the K+ value estimation function can proceed as follows.
카운팅 블룸 필터의 각 항목에 대해, 항목이 K보다 크면, 출력 합계에 포함하고 그렇지 않으면 무시한다. MPC에서 이를 계산하기 위해, 시스템은 세트의 각 엘리먼트에 대해 비교, 합계 및 단일 비트 곱(product)을 수행할 수 있다.For each item in the counting bloom filter, if the item is greater than K, include it in the output sum, otherwise ignore it. To compute this in MPC, the system can perform comparisons, sums, and single-bit products on each element of the set.
b ← x[i] >= K // b 는 0 또는 1 값b ← x[i] >= K // b is a value of 0 or 1
sum ← sum + x[i]*bsum ← sum + x[i]*b
비교 함수를 계산하면, 필터 엘리먼트의 비트 단위 분해를 사용할 수 있으며, 이는 더 많은 통신을 요구하여 전체 프로토콜의 계산 비용을 높일 수 있다. 비교 자체에는 산술 회로를 계산하는 "일반적인" MPC 구성이 필요하며, 이는 라운드 수를 크게 늘리지 않고도 SPDZ 프로토콜 변형을 사용하여 달성될 수 있다.Computing the comparison function allows the use of a bitwise decomposition of the filter elements, which may require more communication and thus increase the computational cost of the overall protocol. The comparison itself requires a "regular" MPC construct that computes an arithmetic circuit, which can be achieved using a variant of the SPDZ protocol without significantly increasing the number of rounds.
산술 회로를 사용하여 비교를 수행하기 위해, 시스템은 "textbook" 감산 알고리즘인 "ripple-borrow" 감산기를 평가할 수 있다. 직관은 X의 상위 비트를 지나서 차용할 필요없이 XY가 계산될 수 있다면 X>=Y이다. 이를 수행하는 한 가지 방법은 함수에 대한 부울 회로를 시뮬레이션하여, "산술 회로"를 생성하는 것이다. 예를 들어, 2 비트 숫자를 비교하려면:To perform the comparison using an arithmetic circuit, the system can evaluate a "ripple-borrow" subtractor, which is a "textbook" subtraction algorithm. The intuition is that X>=Y if XY can be computed without needing to borrow past the upper bits of X. One way to do this is to simulate a Boolean circuit for a function, creating an "arithmetic circuit". For example, to compare 2-bit numbers:
[a0, a1] < [b0, b1][a0, a1] < [b0, b1]
다음 부울 공식을 사용할 수 있다:The following Boolean formula can be used:
((! a1) && ((! a0) && b0)) || ((! a1) && b1) || ((! a0) && b0) && b1)((! a1) && ((! a0) && b0)) || ((! a1) && b1) || ((! a0) && b0) && b1)
이제 이들이 0/1 값들이라고 가정한다(필드에서, 따라서 비트 분해가 필요함). 다음 규칙을 사용하여 동일한 공식을 시뮬레이션할 수 있다:Assume now that these are 0/1 values (in the field, so bitwise decomposition is required). The same formula can be simulated using the following rules:
! x → (1-x)! x → (1-x)
x && y → x * yx && y → x * y
x || y → x + y-x * yx || y → x + y - x * y
따라서 콤퍼레이터는 다음과 같다:So the comparator is:
c1 = ((1 - a1) * ((1 - a0) * b0))c1 = ((1 - a1) * ((1 - a0) * b0))
c2 = ((1 - a1) * b1)c2 = ((1 - a1) * b1)
c3 = ((1 - a0) * b0 * b1)c3 = ((1 - a0) * b0 * b1)
out ← c1 + c2 + c3-c1 * c2-c1 * c3-c2 * c3 + c1 * c2 * c3out ← c1 + c2 + c3-c1 * c2-c1 * c3-c2 * c3 + c1 * c2 * c3
이것은 임의로 많은 비트들로 확장될 수 있다. 최종 출력은 0/1 값이므로 상기 기술된 바와 같이 합계에 값을 선택적으로 포함하는데 사용할 수 있다.This can be extended to arbitrarily many bits. Since the final output is a 0/1 value, it can be used to optionally include a value in the sum as described above.
이 경우 결합된 블룸 필터에 관한 부분적인 정보가 공개되지 않으므로 MPC 프로토콜 자체의 보안을 통해 프라이버시를 보호할 수 있다. 이 경우 필터가 일반으로 표시되지 않기 때문에 필터에서 임의의 순열을 수행할 필요가 없다. 프로토콜의 끝에서 작업자는 합계의 지분을 갖게 되며, 이를 누산기 또는 출력을 받을 자격이 있는 다른 작업자에게 보낼 수 있다.In this case, since partial information about the combined bloom filter is not disclosed, privacy can be protected through the security of the MPC protocol itself. In this case, there is no need to perform any permutations on the filter because the filter is not marked as normal. At the end of the protocol, workers get their share of the sum, which they can send to accumulators or other workers who are entitled to the output.
K가 2의 거듭 제곱인 경우 온라인 프로토콜을 개선할 수 있다. 제1 단계는 각 당사자의 개별 Bloom 필터에 대한 합계를 계산하는 것임을 기억하고; 그 다음 K 값을 초과하지 않는 엘리먼트를 카운트한다. K가 2의 거듭 제곱이면, 이는 특정 포지션을 넘어가는 비트가 있는지 확인하는 것에 해당하고, 콤퍼레이터를 완전히 피하고 덧셈 회로만 온라인으로 계산할 수 있다.Online protocols can be improved if K is a power of two. Remember that the first step is to compute the sum for each party's individual Bloom filters; Then count elements that do not exceed the K value. If K is a power of 2, this corresponds to checking if there is a bit beyond a certain position, and the comparator can be completely avoided and only the addition circuit can be computed online.
곱셈 게이트 당 하나의 브로드캐스트 라운드를 가정하면, 블룸 필터 엘리먼트가 4비트이면 9개의 브로드캐스트 라운드가 필요하다(가산 회로에 8회, 추가에서 수행된 OR에 대해 1회; 최종 합계는 곱셈이 필요없는 선형 조합). 임의의 공모에 대한 보안을 위해, 정직하지만 호기심 많은 설정(honest-but-curious setting)에서 SPDZ 프로토콜을 사용하면 주요 계산 비용은 Beaver 트리플을 계산하는 것이다.Assuming one broadcast round per multiplication gate, if the bloom filter element is 4 bits, then 9 broadcast rounds are required (8 for the add circuit and 1 for the OR performed in the addition; the final sum requires multiplication). linear combinations). For security against arbitrary collusion, using the SPDZ protocol in an honest-but-curious setting, the main computational cost is computing Beaver triples.
곱셈 게이트 당 하나의 브로드캐스트 라운드를 가정하면, 블룸 필터 엘리먼트가 4비트이면 9개의 브로드캐스트 라운드가 필요하다(가산 회로에 8회, 추가에서 수행된 OR에 대해 1회; 최종 합계는 곱셈이 필요없는 선형 조합). 임의의 공모에 대한 보안을 위해, 정직하지만 호기심 많은 설정(honest-but-curious setting)에서 SPDZ 프로토콜을 사용하면 주요 계산 비용은 Beaver 트리플을 계산하는 것이다.Assuming one broadcast round per multiplication gate, if the bloom filter element is 4 bits, then 9 broadcast rounds are required (8 for the add circuit and 1 for the OR performed in the addition; the final sum requires multiplication). linear combinations). For security against arbitrary collusion, using the SPDZ protocol in an honest-but-curious setting, the main computational cost is computing Beaver triples.
이제 도 1을 참조하면, 도시된 것은 네트워킹 환경에서 클라이언트 디바이스 식별자의 카운트 및 빈도를 결정하기 위해 카운팅 블룸 필터를 생성하기 위한 시스템(100)이다. 시스템(100)은 분산 동형 암호화를 사용하여 벡터로부터 추정된 데이터 빈도의 히스토그램을 생성할 수 있다. 시스템(100)은 적어도 하나의 데이터 프로세싱 시스템(105A-N)(때로는 일반적으로 데이터 프로세싱 시스템(105)이라고도 함), 적어도 하나의 네트워크(110), 적어도 하나의 데이터베이스(115) 및 적어도 하나의 클라이언트 디바이스(120A-N)(때로는 일반적으로 클라이언트 디바이스(120)라고 함)를 포함할 수 있다. 데이터 프로세싱 시스템(105)은 적어도 하나의 벡터 생성기(130), 적어도 하나의 해시 식별자(134), 적어도 하나의 데이터 레코드 해시기(140), 적어도 하나의 암호화 키 생성기(145), 적어도 하나의 벡터 암호화기(150), 적어도 하나의 암호화된 벡터 통신기(155), 적어도 하나의 벡터 결합기(160), 적어도 하나의 히스토그램 생성자(165) 및 적어도 하나의 카디널리티 추정기(170)를 포함할 수 있다. 데이터베이스(115)는 적어도 하나의 데이터 레코드(122A-N)(때로는 일반적으로 데이터 레코드(120)로 지칭됨)를 포함할 수 있다. 각각의 데이터 레코드(122)는 적어도 하나의 클라이언트 식별자(125A-N)(때로는 일반적으로 클라이언트 식별자(125)로 지칭됨) 및 적어도 하나의 속성(127A-N)(때로는 일반적으로 속성(127)으로 지칭됨)을 포함할 수 있다.Referring now to FIG. 1 , shown is a system 100 for generating a counting Bloom filter to determine the count and frequency of client device identifiers in a networked environment. System 100 may generate a histogram of estimated data frequencies from vectors using distributed homomorphic encryption. System 100 includes at least one data processing system 105A-N (sometimes generically referred to as data processing system 105), at least one network 110, at least one database 115, and at least one client. devices 120A-N (sometimes commonly referred to as client device 120). The data processing system (105) comprises at least one vector generator (130), at least one hash identifier (134), at least one data record hash generator (140), at least one encryption key generator (145), at least one vector It may include an encryptor 150, at least one encrypted vector communicator 155, at least one vector combiner 160, at least one histogram generator 165, and at least one cardinality estimator 170. Database 115 may include at least one data record 122A-N (sometimes commonly referred to as data record 120). Each data record 122 includes at least one client identifier 125A-N (sometimes commonly referred to as client identifier 125) and at least one attribute 127A-N (sometimes commonly referred to as attribute 127). referred to).
시스템(100)의 각 컴포넌트(예: 데이터 프로세싱 시스템(105), 네트워크(110), 데이터베이스(115), 클라이언트 디바이스(120), 벡터 생성기(130), 해시 식별자(135), 데이터 레코드 해시기(140), 암호화 키 생성기(145), 벡터 암호화기(150), 암호화된 벡터 통신기(155), 벡터 결합기(160), 히스토그램 구성기(165), 카디널리티 추정기(170), 데이터 레코드(122), 클라이언트 식별자(125) 및 속성(127) 등)은 도 8과 관련하여 본 명세서에 상세화된 컴퓨팅 시스템(800)의 하드웨어 컴포넌트와 소프트웨어의 조합 또는 하드웨어 컴포넌트를 사용하여 구현될 수 있다. 예를 들어, 데이터 프로세싱 시스템(105)은 서버 또는 다른 컴퓨팅 디바이스를 포함할 수 있다. 클라이언트 디바이스(120)는 서버 또는 다른 컴퓨팅 디바이스를 포함할 수 있다. 데이터 프로세싱 시스템(105)의 각 컴포넌트들은 본 명세서에 상세히 설명된 기능을 수행할 수 있다.Each component of system 100 (e.g., data processing system 105, network 110, database 115, client device 120, vector generator 130, hash identifier 135, data record hasher ( 140), encryption key generator 145, vector encryptor 150, encrypted vector communicator 155, vector combiner 160, histogram constructor 165, cardinality estimator 170, data record 122, Client identifier 125 and attributes 127, etc.) may be implemented using hardware components or a combination of hardware and software components of computing system 800 detailed herein with respect to FIG. 8 . For example, data processing system 105 may include a server or other computing device. Client device 120 may include a server or other computing device. Each of the components of data processing system 105 may perform functions detailed herein.
네트워크(110)는 인터넷, 로컬, 와이드, 메트로 또는 다른 영역 네트워크, 인트라넷, 위성 네트워크, 음성 또는 데이터 모바일폰 통신 네트워크와 같은 다른 컴퓨터 네트워크들 및 이들의 조합과 같은 컴퓨터 네트워크를 포함할 수 있다. 시스템(100)의 데이터 프로세싱 시스템(105)은 예를 들어 적어도 하나의 콘텐츠 제공자(115) 및 적어도 하나의 데이터베이스(120)와 네트워크(110)를 통해 통신할 수 있다. 네트워크(110)는 콘텐츠 제공자(115), 데이터 프로세싱 시스템(105) 및 특히 웹 서버와 같은 하나 이상의 콘텐츠 소스들 간의 정보를 중계하는 임의의 형태의 컴퓨터 네트워크일 수 있다. 일부 구현예들에서, 네트워크(110)는 근거리 통신망(LAN), 광역 통신망(WAN), 셀룰러 네트워크, 위성 네트워크 또는 다른 유형의 데이터 네트워크와 같은 인터넷 및/또는 다른 유형의 데이터 네트워크를 포함할 수 있다. 네트워크(110)는 또한 네트워크(110) 내에서 데이터를 수신 및/또는 전송하도록 구성된 임의의 수의 컴퓨팅 디바이스(예를 들어, 컴퓨터, 서버, 라우터, 네트워크 스위치 등)를 포함할 수 있다. 네트워크(110)는 임의의 수의 고정 배선 및/또는 무선 연결을 더 포함할 수 있다. 콘텐츠 제공자(115)는(예를 들어, 광섬유 케이블, CAT5 케이블 등을 통해) 배선된 송수신기와 무선으로(예를 들어, WiFi, 셀룰러, 라디오 등을 통해) 네트워크(110) 내 다른 컴퓨팅 디바이스들과 통신할 수 있다. 콘텐츠 제공자(115)는 또한 프록시 디바이스(예를 들어, 라우터, 네트워크 스위치 또는 게이트웨이)를 통해 네트워크(110)의 컴퓨팅 디바이스와 무선으로 통신할 수 있다.Network 110 may include a computer network, such as the Internet, other computer networks such as local, wide, metro or other area networks, intranets, satellite networks, voice or data mobile phone communications networks, and combinations thereof. Data processing system 105 of system 100 may communicate with at least one content provider 115 and at least one database 120 via network 110 , for example. Network 110 may be any form of computer network that relays information between one or more content sources, such as content provider 115, data processing system 105 and, in particular, a web server. In some implementations, network 110 may include the Internet and/or other type of data network, such as a local area network (LAN), wide area network (WAN), cellular network, satellite network, or other type of data network. . Network 110 may also include any number of computing devices (eg, computers, servers, routers, network switches, etc.) configured to receive and/or transmit data within network 110 . Network 110 may further include any number of hard-wired and/or wireless connections. Content provider 115 communicates with other computing devices in network 110 wirelessly (eg, via WiFi, cellular, radio, etc.) with hardwired transceivers (eg, via fiber optic cable, CAT5 cable, etc.). can communicate Content provider 115 may also communicate wirelessly with a computing device in network 110 via a proxy device (eg, a router, network switch, or gateway).
보다 상세하게는, 데이터 프로세싱 시스템(105)은 적어도 하나의 프로세서 및 메모리, 즉 프로세싱 회로를 포함할 수 있다. 메모리는 프로세서에 의해 실행될 때 프로세서로 하여금 본 명세서에 기술된 하나 이상의 동작들을 수행하게 하는 프로세서 실행가능 명령어들을 저장한다. 프로세서는 마이크로 프로세서, 주문형 집적 회로(ASIC), 필드 프로그래머블 게이트 어레이(FPGA) 등, 또는 이들의 조합을 포함할 수 있다. 메모리는 전자, 광학, 자기 또는 프로세서에 프로그램 명령어들을 제공할 수 있는 임의의 다른 저장 또는 전송 디바이스를 포함할 수 있지만, 이에 한정되지 않는다. 메모리는 플로피 디스크, CD-ROM, DVD, 자기 디스크, 메모리 칩, ASIC, FPGA, ROM, RAM, EEPROM(electrically-erasable programmable ROM), EPROM(erasable-programmable ROM), 플래시 메모리, 광학 매체, 또는 프로세서가 명령어들을 판독할 수 있는 임의의 기타 적절한 메모리를 포함할 수 있다. 명령어들은 임의의 적절한 컴퓨터 프로그래밍 언어의 코드가 포함될 수 있다. 데이터 프로세싱 시스템(105)은 예를 들어 본 명세서에 기술된 기능 또는 방법을 포함하는 다양한 기능들을 수행할 수 있는 하나 이상의 컴퓨팅 디바이스들 또는 서버들을 포함할 수 있다.More specifically, data processing system 105 may include at least one processor and memory, or processing circuitry. Memory stores processor executable instructions that, when executed by a processor, cause the processor to perform one or more operations described herein. The processor may include a microprocessor, an application specific integrated circuit (ASIC), a field programmable gate array (FPGA), or the like, or a combination thereof. Memory may include, but is not limited to, electronic, optical, magnetic, or any other storage or transmission device capable of providing program instructions to a processor. Memory may include floppy disks, CD-ROMs, DVDs, magnetic disks, memory chips, ASICs, FPGAs, ROMs, RAMs, electrically-erasable programmable ROMs (EEPROMs), erasable-programmable ROMs (EPROMs), flash memory, optical media, or processors. may include any other suitable memory capable of reading instructions. Instructions may include code in any suitable computer programming language. Data processing system 105 may include one or more computing devices or servers capable of performing various functions including, for example, a function or method described herein.
데이터베이스(115)는 본 명세서에 기술된 임의의 정보를 저장 및/또는 유지하도록 구성된 데이터베이스일 수 있다. 데이터베이스(115)는 본 명세서에서 설명된 각각의 값, 복수 또는 임계치를 포함 또는 색인할 수 있는 하나 이상의 데이터 구조를 유지할 수 있다. 데이터베이스(115)는 하나 이상의 메모리 어드레스 또는 인덱스 값을 사용하여 액세스될 수 있다. 데이터베이스(115)는 데이터 프로세싱 시스템(105)의 컴포넌트 또는 네트워크(110)를 통해 클라이언트 디바이스(120)에 의해 액세스될 수 있다. 일부 구현예에서, 데이터베이스(115)는 데이터 프로세싱 시스템(105)에 내부적일 수 있다. 일부 구현예에서, 시스템(100)은 다수의 데이터베이스를 포함할 수 있으며, 각각의 데이터베이스(115)는 적어도 하나의 데이터 프로세싱 시스템(105A-N)에 대응한다. 예를 들어, 데이터 프로세싱 시스템(105A-N) 각각은 자신의 데이터베이스를 포함하거나 그와 통신할 수 있다. 일부 구현예에서, 데이터베이스(115)는 데이터 프로세싱 시스템(105) 외부에 존재할 수 있고 네트워크(110)를 통해 액세스될 수 있다. 데이터베이스(115)는 많은 상이한 컴퓨터 시스템들 또는 저장 엘리먼트들에 걸쳐 분산될 수 있고, 네트워크(110) 또는 적절한 컴퓨터 버스 인터페이스를 통해 액세스될 수 있다. 데이터 프로세싱 시스템(105)은 임의의 또는 모든 계산, 결정, 선택, 식별, 생성, 구성 또는 연산의 결과를 적절한 값으로 인덱스된 하나 이상의 데이터 구조로 데이터베이스(115)에 저장할 수 있으며, 이들 각각은 본 명세서에 기술된 기능 또는 함수 중 하나를 수행하기 위해 데이터 프로세싱 시스템(105) 또는 클라이언트 디바이스(120)에 의해 액세스될 수 있다. Database 115 may be a database configured to store and/or maintain any of the information described herein. Database 115 may maintain one or more data structures that may contain or index each value, plurality or threshold described herein. Database 115 may be accessed using one or more memory addresses or index values. Database 115 may be accessed by a component of data processing system 105 or by client device 120 via network 110 . In some implementations, database 115 may be internal to data processing system 105 . In some implementations, system 100 may include multiple databases, each database 115 corresponding to at least one data processing system 105A-N. For example, each of the data processing systems 105A-N may include or communicate with its own database. In some implementations, database 115 can exist external to data processing system 105 and can be accessed via network 110 . Database 115 may be distributed across many different computer systems or storage elements, and may be accessed via network 110 or a suitable computer bus interface. The data processing system 105 may store the results of any or all calculations, decisions, selections, identifications, creations, constructions or operations in the database 115 in one or more data structures indexed with appropriate values, each of which is present in the present invention. It can be accessed by data processing system 105 or client device 120 to perform one of the functions or functions described in the specification.
클라이언트 디바이스(120)는 네트워크(110)를 통해 통신하여 데이터 프로세싱 시스템(105)에 의해 제공되는 표시(예를 들어, 클라이언트 식별자 세트(125), 속성(127), 빈도 값 또는 본 명세서에 기술된 임의의 기타 값 등의 카디널리티를 디스플레이하는 표시)와 같은 데이터를 디스플레이하도록 구성된 컴퓨팅 디바이스일 수 있다. 클라이언트 디바이스(120)는 다른 것들 중에서도 특히, 데스크톱 컴퓨터, 랩톱 컴퓨터, 태블릿 컴퓨터, 스마트폰, 개인 휴대 정보 단말기, 모바일 디바이스, 컨슈머 컴퓨팅 디바이스, 서버, 클라이언트, 디지털 비디오 레코더, 텔레비전용 셋톱 박스, 비디오 게임 콘솔 또는 네트워크(110)를 통해 통신하도록 구성된 임의의 기타 컴퓨팅 디바이스일 수 있다. 클라이언트 디바이스(120)는 하나 이상의 클라이언트 식별자(125) 또는 하나 이상의 속성(127)을 데이터 프로세싱 시스템으로 전송 또는 수신할 수 있다. 클라이언트 디바이스(120)는 각각의 클라이언트 디바이스(120)와 연관하여 클라이언트 식별자(125) 또는 속성(127)을 저장하기 위해 적어도 하나의 데이터베이스(115)와 통신할 수 있다.Client device 120 communicates over network 110 to provide an indication provided by data processing system 105 (e.g., client identifier set 125, attribute 127, frequency value, or other information described herein). It may be a computing device configured to display data, such as an indication to display the cardinality of any other value, etc. Client device 120 may include, among other things, desktop computers, laptop computers, tablet computers, smartphones, personal digital assistants, mobile devices, consumer computing devices, servers, clients, digital video recorders, set top boxes for televisions, video games. It may be a console or any other computing device configured to communicate over network 110 . A client device 120 may send or receive one or more client identifiers 125 or one or more attributes 127 to or from the data processing system. Client devices 120 may communicate with at least one database 115 to store a client identifier 125 or attribute 127 associated with each client device 120 .
클라이언트 디바이스(120)는 프로세서 및 메모리, 즉 프로세싱 회로를 포함할 수 있다. 메모리는 프로세서에 의해 실행될 때 프로세서로 하여금 본 명세서에 기술된 하나 이상의 동작들을 수행하게 하는 기계 명령어들을 저장한다. 프로세서는 마이크로 프로세서, 주문형 집적 회로(ASIC), 필드 프로그래머블 게이트 어레이(FPGA) 등, 또는 이들의 조합을 포함할 수 있다. 메모리는 전자, 광학, 자기 또는 프로세서에 프로그램 명령어들을 제공할 수 있는 임의의 다른 저장 또는 전송 디바이스를 포함할 수 있지만, 이에 한정되지 않는다. 메모리는 플로피 디스크, CD-ROM, DVD, 자기 디스크, 메모리 칩, ASIC, FPGA, ROM, RAM, EEPROM(electrically-erasable programmable ROM), EPROM(erasable-programmable ROM), 플래시 메모리, 광학 매체, 또는 프로세서가 명령어들을 판독할 수 있는 임의의 기타 적절한 메모리를 포함할 수 있다. 명령어는 임의의 적절한 컴퓨터 프로그래밍 언어의 코드를 포함할 수 있다.Client device 120 may include a processor and memory, i.e., processing circuitry. Memory stores machine instructions that, when executed by a processor, cause the processor to perform one or more operations described herein. The processor may include a microprocessor, an application specific integrated circuit (ASIC), a field programmable gate array (FPGA), or the like, or a combination thereof. Memory may include, but is not limited to, electronic, optical, magnetic, or any other storage or transmission device capable of providing program instructions to a processor. Memory may include floppy disks, CD-ROMs, DVDs, magnetic disks, memory chips, ASICs, FPGAs, ROMs, RAMs, electrically-erasable programmable ROMs (EEPROMs), erasable-programmable ROMs (EPROMs), flash memory, optical media, or processors. may include any other suitable memory capable of reading instructions. Instructions may include code in any suitable computer programming language.
클라이언트 디바이스(120)는 또한 하나 이상의 사용자 인터페이스 디바이스를 포함할 수 있다. 일반적으로, 사용자 인터페이스 디바이스는 감각 정보(예를 들어, 디스플레이상의 시각화, 하나 이상의 사운드 등)를 생성함으로써 사용자에게 데이터를 전달하고 및/또는 사용자로부터 수신된 감각 정보를 전자 신호(예를 들어, 키보드, 마우스, 포인팅 디바이스, 터치 스크린 디스플레이, 마이크로폰 등)로 변환하는 임의의 전자 디바이스를 지칭한다. 하나 이상의 사용자 인터페이스 디바이스들은 클라이언트 디바이스(120)의 하우징 내부(예: 내장 디스플레이, 마이크로폰 등) 또는 클라이언트 디바이스(120)의 하우징 외부(예: 클라이언트 디바이스(120)에 연결된 모니터, 클라이언트 디바이스(120)에 연결된 스피커 등)에 있을 수 있다. 일부 구현예에서, 클라이언트 디바이스(120)는 클라이언트 디바이스(120)에서 실행되는 운영 체제에 의해 제공되거나, 데이터베이스(115)로부터 검색되거나, 데이터 프로세싱 시스템(105)에 의해 제공되는 인터페이스 데이터를 사용하여 인터페이스를 시각적으로 디스플레이하는 전자 디스플레이를 포함할 수 있다.Client device 120 may also include one or more user interface devices. Generally, a user interface device communicates data to a user by generating sensory information (eg, a visualization on a display, one or more sounds, etc.) and/or converts sensory information received from the user into an electronic signal (eg, a keyboard , mouse, pointing device, touch screen display, microphone, etc.) One or more user interface devices may be inside the housing of the client device 120 (eg, a built-in display, microphone, etc.) or outside the housing of the client device 120 (eg, a monitor connected to the client device 120, a monitor connected to the client device 120, connected speakers, etc.). In some implementations, client device 120 interfaces using interface data provided by an operating system running on client device 120, retrieved from database 115, or provided by data processing system 105. It may include an electronic display that visually displays.
데이터 프로세싱 시스템(105)은 데이터베이스(115)에서 적어도 하나의 데이터 레코드(122)를 유지할 수 있다. 데이터 레코드는 예를 들어, 적어도 하나의 클라이언트 식별자(125) 및 적어도 하나의 속성(127)을 포함할 수 있다. 클라이언트 식별자(125)는 클라이언트 디바이스(120) 각각에 대응할 수 있다. 속성은 데이터 레코드(122)의 클라이언트 식별자(125)와 연관될 수 있고, 각각의 클라이언트 디바이스(120)의 속성에 대한 정보를 포함할 수 있다. 속성은 예를 들어, 클라이언트 디바이스 위치 데이터, 클라이언트 디바이스 메타 데이터, 클라이언트 디바이스 파라미터, 설정 및 기타 정보, 사용자 프로필 데이터, 클라이언트 디바이스에서 수행한 인터렉션, 애플리케이션 검색 기록, 웹 페이지 검색 기록, 활동 정보, 디바이스 특성, 클라이언트 디바이스가 콘텐츠 아이템을 보거나 인터렉션했는지 여부, 네트워크 사용 정보, 전력 사용 정보, 디바이스 운영 체제 버전, 설정 및 기타 정보를 포함할 수 있다. 데이터 프로세싱 시스템은 각각의 클라이언트 디바이스로부터 디바이스 식별자 및 속성 데이터를 수신하고, 데이터베이스(115)에서 각각의 클라이언트 디바이스에 대응하는 각각의 데이터 레코드를 생성하고 유지할 수 있다. 모든 클라이언트 디바이스(120)가 각각의 데이터 프로세싱 시스템(105A-N)과 통신하고 있다고 도 1에 도시되어 있지만, 각각의 데이터 프로세싱 시스템은 클라이언트 디바이스(120)의 특정 세트로부터만 클라이언트 디바이스 식별자 및 정보를 수신할 수 있다는 것을 이해해야 한다. 마찬가지로, 데이터 프로세싱 시스템(105A-N)은 다른 데이터 프로세싱 시스템(105A-N)에 의해 액세스될 수 없는 자신의 데이터베이스(115)에 각각의 데이터 레코드를 유지할 수 있다. 일부 구현예에 따르면, 클라이언트 디바이스(120)의 상이한 그룹은 상이한 식별자 서버(예를 들어, 데이터 프로세싱 시스템(105))에 의해 서비스될 수 있고, 각각의 데이터 프로세싱 시스템은 클라이언트 디바이스 세트(120) 중 각각의 클라이언트 디바이스에 대응하는 데이터 레코드의 고유 세트를 유지할 수 있다.Data processing system 105 may maintain at least one data record 122 in database 115 . A data record may include, for example, at least one client identifier 125 and at least one attribute 127 . The client identifier 125 may correspond to each of the client devices 120 . The attribute may be associated with the client identifier 125 of the data record 122 and may include information about the attribute of each client device 120 . Attributes include, for example, client device location data, client device metadata, client device parameters, settings and other information, user profile data, interactions performed on the client device, application search history, web page search history, activity information, and device characteristics. , whether the client device viewed or interacted with the content item, network usage information, power usage information, device operating system version, settings, and other information. The data processing system may receive device identifier and attribute data from each client device, and create and maintain a respective data record corresponding to each client device in database 115 . Although all client devices 120 are shown in FIG. 1 as being in communication with each data processing system 105A-N, each data processing system receives client device identifiers and information only from a specific set of client devices 120. You have to understand that you can receive it. Similarly, data processing systems 105A-N may maintain each data record in their database 115 that cannot be accessed by other data processing systems 105A-N. According to some implementations, different groups of client devices 120 can be serviced by different identifier servers (eg, data processing systems 105 ), each data processing system of a set of client devices 120 . It is possible to maintain a unique set of data records corresponding to each client device.
벡터 생성기(130)는 복수의 좌표를 포함하는 벡터를 생성할 수 있다. 벡터를 생성하기 위해, 벡터 생성기(130)는 적어도 하나의 카운터 레지스터를 수용하기 위해 데이터 프로세싱 시스템(105)에 하나 이상의 메모리 영역을 할당할 수 있다. 할당된 카운터 레지스터는 벡터의 적어도 하나의 좌표에 대응할 수 있다. 하나 이상의 카운터 레지스터에 대한 메모리를 생성 및 할당함으로써, 벡터 생성기(130)는 카운터 레지스터를 포함하는 벡터를 생성할 수 있다. 벡터 생성기(130)는 벡터의 카운터 레지스터 각각을 초기화 값, 예를 들어 0 또는 1로 초기화할 수 있다. 벡터 생성기(130)는 임의의 수의 카운터 레지스터(때로는 "버킷"이라고도 함)를 갖도록 최소 증가 카운팅 블룸 필터에 대응할 수 있는 벡터를 생성할 수 있다. 예를 들어, 벡터 생성기(130)는 n개의 버킷을 갖는 최소 증가 카운팅 블룸 필터를 생성하기 위한 표시를 수신할 수 있거나, 버킷 또는 카운터 레지스터 수에 의해 최소 증가 카운팅 블룸의 크기를 특정하는 외부 컴퓨팅 디바이스에 의해 제공되는 내부 구성 설정에 액세스할 수 있다.The vector generator 130 may generate a vector including a plurality of coordinates. To create a vector, vector generator 130 may allocate one or more memory regions in data processing system 105 to accommodate at least one counter register. The assigned counter register may correspond to at least one coordinate of the vector. By creating and allocating memory for one or more counter registers, vector generator 130 can create vectors containing the counter registers. The vector generator 130 may initialize each counter register of the vector to an initialization value, for example 0 or 1. Vector generator 130 can generate a vector that can correspond to a minimum increment counting Bloom filter to have an arbitrary number of counter registers (sometimes referred to as "buckets"). For example, vector generator 130 may receive an indication to create a minimum incremental counting bloom filter with n buckets, or an external computing device that specifies the size of minimum incremental counting bloom by number of buckets or counter registers. You can access the internal configuration settings provided by
해시 식별자(135)는 카운팅 블룸 필터 데이터 구조를 업데이트하는데 사용할 수 있는 해시 함수 목록으로부터 하나 이상의 해시 함수를 식별할 수 있다. 예를 들어, 해시 목록에서 식별된 각 해시는 입력 값에 기초하여 정규 분포 또는 임의성 기대치를 제공할 수 있다. 즉, 예를 들어 해시 함수에 대한 유사한 입력이 반드시 해시 함수와 유사한 출력을 갖는 것은 아니다. 해시 함수는 블룸 필터를 카운팅하기 위한 최적의 해시 함수로 선택할 수 있다. 예를 들어, 해시 식별자(135)는 독립적이고 균일하게 분포된 해시 함수를 선택할 수 있다. 이러한 해시 함수는 예를 들어 murmur 해시, Fowler-Noll-Vo 시리즈 해시 또는 Jenkins 해시 등을 포함할 수 있다. 해시 식별자(135)는 다수의 해시 함수를 선택하거나 식별할 수 있고, 각각의 해시 함수를 각 데이터 레코드에 적용하여 해시된 데이터 레코드 세트를 생성할 수 있다.Hash identifier 135 may identify one or more hash functions from a list of hash functions that may be used to update the counting bloom filter data structure. For example, each hash identified in the list of hashes can provide a normal distribution or expected randomness based on the input value. That is, for example, similar inputs to a hash function do not necessarily have similar outputs to a hash function. The hash function can be selected as the optimal hash function for counting the bloom filter. For example, hash identifier 135 may choose an independent, uniformly distributed hash function. Such hash functions may include, for example, murmur hashes, Fowler-Noll-Vo series hashes, or Jenkins hashes. Hash identifier 135 may select or identify multiple hash functions, and each hash function may be applied to each data record to create a set of hashed data records.
데이터 레코드 해시(140)는 각각의 데이터 프로세싱 시스템(105)에 의해 유지되는 각각의 데이터 레코드를 해시하여 각각의 해시된 데이터 레코드 세트를 생성할 수 있다. 해시 데이터 레코드를 적용하는 것은 해시 식별자(135)에 의해 식별된 해시 함수에 대한 인수로서 데이터 레코드를 사용하는 것을 포함할 수 있다. 데이터 레코드 해시(140)는 해시 식별자(135)에 의해 식별된 각각의 해시를 사용하여 각각의 데이터 레코드를 해시할 수 있으며, 그 결과 데이터 레코드 각각에 대응하는 다수의 해시된 값이 생성된다. 이와 같이, 데이터 레코드 해시(140)는 루프의 각 데이터 레코드에 대해 반복할 수 있고, 선택될 때 각각의 데이터 레코드에 각각의 해시 함수를 적용할 수 있다. 해시 함수를 적용한 후, 데이터 레코드 해시(140)는 각각의 데이터 프로세싱 시스템(105)의 메모리에 각각의 데이터 레코드과 연관하여 해시된 데이터 레코드 각각을 저장할 수 있다. Data record hash 140 may hash each data record maintained by each data processing system 105 to create a respective set of hashed data records. Applying the hash data record may include using the data record as an argument to a hash function identified by hash identifier 135 . Data record hash 140 may hash each data record using each hash identified by hash identifier 135, resulting in multiple hashed values corresponding to each data record. As such, the data record hash 140 can iterate through each data record in a loop and apply each hash function to each data record as it is selected. After applying the hash function, the data record hash 140 may store each hashed data record associated with each data record in the memory of each data processing system 105 .
데이터 레코드 해시(140)는 각각의 데이터 프로세싱 시스템(105)에 의해 유지되는 데이터 레코드 각각에 대응하는 해시된 데이터 레코드들 각각으로부터 레지스터 식별자를 추가로 추출할 수 있다. 해시된 데이터 레코드 세트의 각각의 해시된 데이터 레코드는 벡터 생성기(130)에 의해 생성된 벡터의 카운터 레지스터에 대응할 수 있다. 대응하는 카운터 레지스터를 식별하기 위해, 데이터 레코드 해시(140)는 해시된 데이터 레코드 각각에서 레지스터 식별자를 추출할 수 있다. 데이터 레코드 해시(140)는 예를 들어 최소 증가 카운팅 블룸 필터의 카운터 레지스터의 수로 각 해시된 데이터 식별자에 대해 모듈러스 연산을 수행함으로써 레지스터 식별자를 추출할 수 있다. 예를 들어, 해시된 데이터 레코드 중 하나가 500과 같고 최소 증가 카운팅 블룸 필터에 15개의 포지션이 있는 경우, 데이터 프로세싱 시스템은 500 % 15 = 5를 계산하여 해시된 데이터 레코드가 최소 증가 카운팅 블룸 필터의 다섯 번째 카운터 레지스터에 대응하는지 결정할 수 있다. 일부 구현예에서, 최소 증가 블룸 필터의 카운터 레지스터 수가 2의 거듭 제곱이면 데이터 레코드 해시(140)는 log2(b)와 동일한 비트 수를 선택할 수 있으며, 여기서 b는 최소 증가 카운팅 블룸 필터의 카운터 레지스터의 수와 동일하다.Data record hash 140 may further extract a register identifier from each of the hashed data records corresponding to each data record maintained by each data processing system 105 . Each hashed data record in the set of hashed data records may correspond to a counter register of a vector created by vector generator 130 . To identify the corresponding counter register, data record hash 140 may extract a register identifier from each hashed data record. The data record hash 140 may extract register identifiers, for example, by performing a modulus operation on each hashed data identifier with the number of counter registers of the minimum increment counting bloom filter. For example, if one of the hashed data records is equal to 500 and there are 15 positions in the least incremental counting bloom filter, the data processing system calculates 500 % 15 = 5 so that the hashed data record is equal to 500 in the least incremental counting bloom filter. It can be determined whether it corresponds to the fifth counter register. In some implementations, data record hash 140 may choose a number of bits equal to log2(b) if the number of counter registers of the least incremental bloom filter is a power of two, where b is the number of bits of the counter register of the least incremental counting bloom filter. equal to the number
벡터 생성기(130)는 최소 레지스터 값을 결정하기 위해 데이터 레코드 해시기(140)에 의해 식별된 레지스터 식별자에 대응하는 벡터 생성기(130)에 의해 생성된 카운팅 블룸 필터의 카운터 레지스터 각각에 액세스할 수 있다. 최소 증가 블룸 필터 구현예에서, 벡터 생성기(130)는 버킷 값 세트를 검색하기 위해 데이터 레코드 해시(140)에 의해 추출된 레지스터 식별자들 각각과 연관된 카운터 레지스터 버킷에 추가로 액세스할 수 있다. 증가할 버킷 값을 결정하기 위해, 벡터 생성기(130)는 카운터 레지스터 버킷 중 최소값과 동일한 카운터 레지스터 버킷의 서브세트를 결정할 수 있다. 최소값은 각 카운터 레지스터 버킷을 비교하고 가장 작은 버킷 값(예: 0에 가장 가까운 값 등)을 식별하여 결정할 수 있다. 예를 들어 각 값이 3, 91, 30, 88 및 10인 5 개의 버킷이 있는 경우 최소 버킷 값은 3이다. 하나의 버킷만 최소값과 동일한 것으로 설명되어 있지만 최소값과 동일한 버킷의 임의의 수가 있을 수 있다. 이 개념을 설명하기 위해, 다섯 개의 버킷이 각각 5, 10, 30, 5 및 28과 동일한 두 번째 예를 고려한다. 이 예에는 5와 동일한 두 개의 버킷이 있다. 모든 버킷의 최소값도 5이다. 그 후, 벡터 생성기(130)는 카운터 레지스터 버킷의 서브세트에 포함시키기 위한 최소값과 동일한 버킷을 선택할 수 있다. 즉, 버킷이 각각 3, 91, 30, 88, 10과 동일한 첫 번째 예시에서, 벡터 생성기(130)는 최소값인 3과 동일한 버킷을 서브세트에서 카운터 레지스터로 선택할 수 있다. 두 번째 예시에서, 5개의 버킷이 각각 5, 10, 30, 5 및 28과 동일한 경우, 벡터 생성기(130)는 카운터 레지스터 버킷의 최소값인 5와 동일한 두 버킷을 모두 선택할 수 있다. 카운터 레지스터의 선택은 각각의 데이터 프로세싱 시스템(105)의 메모리 내의 데이터 구조에서 대응하는 버킷을 식별하는 레지스터 식별자를 저장하는 것을 포함할 수 있다. 블룸 필터의 최소값을 정확하게 결정하기 위해, 벡터 생성기(130)는 각각의 데이터 레코드에 대해 반복할 수 있고, 각각의 식별자의 해시된 값으로부터 추출된 레지스터 식별자에 액세스할 수 있다. Vector generator 130 may access each counter register of the counting bloom filter generated by vector generator 130 that corresponds to the register identifier identified by data record hasher 140 to determine the minimum register value. . In the minimum increment bloom filter implementation, vector generator 130 may further access the counter register bucket associated with each of the register identifiers extracted by data record hash 140 to retrieve the set of bucket values. To determine the bucket value to increment, vector generator 130 may determine a subset of counter register buckets equal to the smallest of the counter register buckets. The minimum value can be determined by comparing each counter-register bucket and identifying the smallest bucket value (eg, closest to zero, etc.). For example, if there are 5 buckets with values 3, 91, 30, 88, and 10 each, the minimum bucket value is 3. Although only one bucket is described as being equal to the minimum, there may be any number of buckets equal to the minimum. To illustrate this concept, consider a second example where the five buckets are equal to 5, 10, 30, 5 and 28, respectively. In this example, there are two buckets equal to 5. The minimum value of all buckets is also 5. Vector generator 130 may then select a bucket equal to the minimum value for inclusion in the subset of counter register buckets. That is, in the first example where the buckets are equal to 3, 91, 30, 88, and 10, respectively, vector generator 130 may select buckets equal to the minimum value of 3 as counter registers from the subset. In the second example, if the five buckets are equal to 5, 10, 30, 5, and 28, respectively, the vector generator 130 may select both buckets equal to 5, the minimum value of the counter register bucket. Selecting a counter register may include storing a register identifier that identifies a corresponding bucket in a data structure in memory of each data processing system 105 . To accurately determine the minimum value of the bloom filter, vector generator 130 can iterate over each data record and access the register identifier extracted from the hashed value of each identifier.
벡터 생성기(130)는 전술한 바와 같이 카운터 레지스터의 최소값 임계 값을 만족하는 카운터 레지스터 각각을 증가시킬 수 있다. 레지스터 식별자를 증가시키는 것은 각각의 레지스터 식별자에 대응하는 카운터 레지스터에 하나를 추가하는 것을 포함할 수 있다. 일부 구현예에서, 카운터 레지스터에 추가되는 양은 1이 아닌 값일 수 있다. 예를 들어, 벡터 생성기(130)는 여기서 결정, 생성 또는 계산된 임의의 값에 대응할 수 있는 각 카운터 레지스터에 다른 값을 추가할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 본 명세서에서 논의되는 다양한 이유로 카운터 레지스터로부터 감산될 수 있다. 일부 구현예에서, 감산에 대한 대안으로서, 벡터 생성기(130)는 벡터 생성기(130)에 의해 현재 선택되지 않은 다른 카운터 레지스터 버킷 각각에 양(예를 들어, 1 또는 일부 다른 값 등)을 더할 수 있다. 카운터 레지스터 버킷 또는 좌표를 증가시킴으로써, 벡터 생성기(130)는 각각의 데이터 프로세싱 시스템(105)에 의해 유지되는 데이터 레코드에 기초하여 전체적으로 카운팅 블룸 필터를 업데이트할 수 있다. 시스템의 컨텍스트에서, 표준 카운팅 블룸 필터를 업데이트하는 프로세스는 도 2a-2c와 관련하여 아래에서 간략하게 설명되며, 최소 증가 카운팅 블룸 필터를 업데이트하는 프로세스(도 1과 관련하여 설명됨)는 도 3a-c와 관련하여 아래에 설명된다.As described above, the vector generator 130 may increment each counter register that satisfies the minimum value threshold of the counter register. Incrementing the register identifiers may include adding one to the counter register corresponding to each register identifier. In some implementations, the amount added to the counter register can be a non-one value. For example, vector generator 130 may add another value to each counter register, which may correspond to any value determined, generated, or calculated herein. In some implementations, the data processing system may subtract from the counter register for various reasons discussed herein. In some implementations, as an alternative to subtraction, vector generator 130 may add an amount (eg, 1 or some other value, etc.) to each of the other counter register buckets not currently selected by vector generator 130. there is. By incrementing the counter register bucket or coordinate, vector generator 130 may update the counting bloom filter as a whole based on data records maintained by each data processing system 105 . In the context of a system, the process of updating a standard counting bloom filter is briefly described below with respect to Figs. It is explained below with respect to c.
이제 도 2a를 참조하면, 도시된 것은 적어도 하나의 데이터 프로세싱 시스템(예를 들어, 데이터 프로세싱 시스템(105) 중 적어도 하나 등)에 의해 데이터 레코드 X를 표준 카운팅 블룸 필터에 삽입하는 것을 도시하는 흐름도(200A)의 예시적인 도시이다. 블록(202)에서, 데이터 프로세싱 시스템은 카운팅 블룸 필터에 삽입할 데이터 레코드를 표시할 수 있다. 표시된 데이터 레코드는 예를 들어 데이터베이스(예를 들어, 데이터베이스(115))로부터 선택될 수 있다. 데이터 프로세싱 시스템은 여기에서 h1, h2 및 h3으로 표시된 여러 해시 함수를 선택할 수 있다. 3개의 해시 함수만 도시되었지만, 데이터 프로세싱 시스템은 표준 카운팅 블룸 필터에 데이터 레코드를 삽입하기 위해 임의의 수의 해시 함수를 사용할 수 있음을 이해해야 한다. 블록(204A-C)에서, 데이터 프로세싱 시스템은 식별된 각각의 해시 함수를 사용하여 데이터 레코드 X를 적어도 한 번 복제하고 해시할 수 있다. 해시 함수는 예를 들어, 본 명세서에 설명된 바와 같은 ElGamal 해시일 수 있거나, 특히 SHA-1, SHA-2, MD5와 같은 임의의 다른 유형의 해시일 수 있다. 데이터 레코드 X를 3번 복제하고 해싱함으로써, 데이터 프로세싱 시스템은 도 2a에서 h1(x), h2(x) 및 h3(x)로 표시된 3개의 해시된 데이터 레코드를 생성했다. 여전히 블록(204A-C)를 참조하면, 데이터 프로세싱 시스템은 각각의 해시된 데이터 레코드로부터 인덱스 값을 추출할 수 있다. 추출된 인덱스 값은 카운팅 블룸 필터에서 적어도 하나의 개별 포지션에 대응할 수 있다. 도 2a에 제공된 예시에서, 각 해시는 카운팅 블룸 필터의 레지스터 포지션의 수인 11의 모듈러스로 계산된다. 11개의 레지스터 포지션만이 블룸 필터로 사용되지만, 블룸 필터를 구현하는데 임의의 수의 카운팅 레지스터를 사용할 수 있다. Referring now to FIG. 2A , shown is a flow diagram illustrating the insertion of data record X into a standard counting Bloom filter by at least one data processing system (e.g., at least one of data processing systems 105, etc.) ( 200A) is an exemplary illustration. At block 202, the data processing system may mark data records for insertion into the counting bloom filter. The displayed data record may be selected from, for example, a database (eg, database 115). The data processing system can select several hash functions, denoted here as h1, h2 and h3. Although only three hash functions are shown, it should be understood that a data processing system may use any number of hash functions to insert data records into a standard counting bloom filter. At blocks 204A-C, the data processing system may duplicate and hash the data record X at least once using each hash function identified. The hash function may be, for example, an ElGamal hash as described herein, or may be any other type of hash, such as SHA-1, SHA-2, MD5 among others. By duplicating and hashing data record X three times, the data processing system generated three hashed data records, denoted h1(x), h2(x), and h3(x) in FIG. 2A. Still referring to blocks 204A-C, the data processing system can extract an index value from each hashed data record. The extracted index value may correspond to at least one individual position in the counting bloom filter. In the example provided in Figure 2a, each hash is computed with a modulus of 11, which is the number of register positions of the counting bloom filter. Only 11 register positions are used as bloom filters, but any number of counting registers can be used to implement a bloom filter.
도 2a에서, h1(x)의 모듈러스 11은 1과 같고, h2(x)의 모듈러스 11은 3과 같고, h3(x)의 모듈러스 11은 9와 같다. 이들 값 각각은 카운팅 블룸 필터에서 각각의 포지션(예를 들어, ID 값 등)와 연관된 카운터 레지스터에 대한 포인터로서 데이터 프로세싱 시스템에 의해 사용될 수 있다. 예를 들어, 1과 같은 h1(x)의 모듈러스 11은 카운팅 블룸 필터에서 포지션 '1'을 가리킬 수 있으며, h2(x)의 모듈러스 11은 3과 같고, 카운팅 블룸 필터에서 포지션 '3'을 가리킬 수 있다. 이들은 블룸 필터 카운팅와 관련된 작업을 설명하기 위한 목적으로 순전히 예제 값이며, 카운팅 블룸 필터를 설명하는 구현 범위를 제한하는 것으로 해석되어서는 안된다. 데이터 프로세싱 시스템은 각각의 해시 함수에 의해 가리키는 카운터 레지스터 각각을 증가시킴으로써 카운팅 블룸 필터를 업데이트(예를 들어, 데이터 레코드 삽입)할 수 있으며, 그 결과 업데이트된 카운팅 블룸 필터(206)가 생성된다. 비록 도 2a는 각각의 카운터 레지스터를 1만큼만 증가시키는 것을 도시하고 있지만, 데이터 프로세싱 시스템은 임의의 값, 예를 들어 바이트 수, 비트 수 또는 임의의 다른 값, 임계치 또는 본 명세서에 기술된 추정치에 상대적으로 카운터 레지스터 중 임의의 값을 증가시킬 수 있음을 이해해야 한다.In FIG. 2A , the modulus 11 of h1(x) equals 1, the modulus 11 of h2(x) equals 3, and the modulus 11 of h3(x) equals 9. Each of these values may be used by the data processing system as a pointer to a counter register associated with each position (eg, ID value, etc.) in the counting bloom filter. For example, a modulus 11 of h1(x) equal to 1 could point to position '1' in the Counting Bloom filter, and a modulus 11 of h2(x) equal to 3 would point to position '3' in the Counting Bloom filter. can These are purely example values for purposes of illustrating operations related to counting bloom filters, and should not be construed as limiting the scope of implementations that describe counting bloom filters. The data processing system may update the Counting Bloom filter (eg, insert a data record) by incrementing each of the counter registers pointed to by the respective hash function, resulting in an updated Counting Bloom filter 206 . Although FIG. 2A shows incrementing each counter register by only one, the data processing system may be relative to any value, e.g., number of bytes, number of bits, or any other value, threshold, or estimate described herein. It should be understood that any value of the counter register can be incremented with .
이제 도 2b를 참조하면, 도시된 것은 적어도 하나의 데이터 프로세싱 시스템(예를 들어, 데이터 프로세싱 시스템(105) 중 적어도 하나 등)에 의해 데이터 레코드 Y를 도 2a와 관련하여 상기 기술된 업데이트된 카운팅 블룸 필터에 삽입하는 것을 도시하는 흐름도(200B)의 예시적인 도시이다. 블록(208)에서, 데이터 프로세싱 시스템은 카운팅 블룸 필터에 삽입할 데이터 레코드를 표시할 수 있다. 표시된 데이터 레코드는 예를 들어 데이터베이스(예를 들어, 데이터베이스(115))로부터 선택될 수 있다. 데이터 프로세싱 시스템은 여기에서 h1, h2 및 h3으로 표시된 여러 해시 함수를 선택할 수 있다. 3개의 해시 함수만 도시되었지만, 데이터 프로세싱 시스템은 표준 카운팅 블룸 필터에 데이터 레코드를 삽입하기 위해 임의의 수의 해시 함수를 사용할 수 있음을 이해해야 한다. 블록(210A-C)에서, 데이터 프로세싱 시스템은 식별된 각각의 해시 함수를 사용하여 데이터 레코드 Y를 적어도 한 번 복제하고 해시할 수 있다. 해시 함수는 예를 들어, 본 명세서에 설명된 바와 같은 ElGamal 해시일 수 있거나, 특히 SHA-1, SHA-2, MD5와 같은 임의의 다른 유형의 해시일 수 있다. 데이터 레코드 Y를 3번 복제하고 해싱함으로써(예: 각 해시에 대해 한번씩), 데이터 프로세싱 시스템은 도 2b에서 h1(y), h2(y) 및 h3(y)로 표시된 3개의 해시된 데이터 레코드를 생성했다. 여전히 블록(210A-C)를 참조하면, 데이터 프로세싱 시스템은 각각의 해시된 데이터 레코드로부터 인덱스 값을 추출할 수 있다. 추출된 인덱스 값은 카운팅 블룸 필터에서 적어도 하나의 개별 포지션에 대응할 수 있다. 도 2a에 제공된 예시에서, 각 해시는 카운팅 블룸 필터의 레지스터 포지션의 수인 11의 모듈러스로 계산된다. 11개의 레지스터 포지션만이 카운팅 블룸 필터로 사용되지만, 카운팅 블룸 필터를 구현하는데 임의의 수의 카운팅 레지스터를 사용할 수 있다. Referring now to FIG. 2B , shown is the updated counting bloom described above with respect to FIG. Here is an exemplary illustration of a flow chart 200B showing insertion into a filter. At block 208, the data processing system may mark data records for insertion into the counting bloom filter. The displayed data record may be selected from, for example, a database (eg, database 115). The data processing system can select several hash functions, denoted here as h1, h2 and h3. Although only three hash functions are shown, it should be understood that a data processing system may use any number of hash functions to insert data records into a standard counting bloom filter. At blocks 210A-C, the data processing system may duplicate and hash data record Y at least once using each hash function identified. The hash function may be, for example, an ElGamal hash as described herein, or may be any other type of hash, such as SHA-1, SHA-2, MD5 among others. By duplicating and hashing data record Y three times (e.g., once for each hash), the data processing system obtains three hashed data records, denoted h1(y), h2(y), and h3(y) in FIG. 2B. Created. Still referring to blocks 210A-C, the data processing system can extract an index value from each hashed data record. The extracted index value may correspond to at least one individual position in the counting bloom filter. In the example provided in Figure 2a, each hash is computed with a modulus of 11, which is the number of register positions of the counting bloom filter. Only 11 register positions are used as a counting bloom filter, but any number of counting registers can be used to implement a counting bloom filter.
도 2b에서, h1(y)의 모듈러스 11은 1과 같고, h2(y)의 모듈러스 11은 5과 같고, h3(y)의 모듈러스 11은 7와 같다. 이들 값 각각은 카운팅 블룸 필터에서 각각의 포지션(예를 들어, ID 값 등)와 연관된 카운터 레지스터에 대한 포인터로서 데이터 프로세싱 시스템에 의해 사용될 수 있다. 예를 들어, 1과 같은 h1(y)의 모듈러스 11은 카운팅 블룸 필터에서 포지션 '1'을 가리킬 수 있으며, h2(y)의 모듈러스 11은 5과 같고, 카운팅 블룸 필터에서 포지션 '5'을 가리킬 수 있다. 이들은 블룸 필터 카운팅와 관련된 작업을 설명하기 위한 목적으로 순전히 예제 값이며, 카운팅 블룸 필터를 설명하는 구현 범위를 제한하는 것으로 해석되어서는 안된다. 데이터 프로세싱 시스템은 각각의 해시 함수에 의해 가리키는 카운터 레지스터 각각을 증가시킴으로써 카운팅 블룸 필터를 업데이트(예를 들어, 데이터 레코드 삽입)할 수 있으며, 그 결과 업데이트된 카운팅 블룸 필터(212)가 생성된다. 비록 도 2b는 각각의 카운터 레지스터를 1만큼만 증가시키는 것을 도시하고 있지만, 데이터 프로세싱 시스템은 임의의 값, 예를 들어 바이트 수, 비트 수 또는 임의의 다른 값, 임계치 또는 본 명세서에 기술된 추정치에 상대적으로 카운터 레지스터 중 임의의 값을 증가시킬 수 있음을 이해해야 한다. 도 2b에 도시된 바와 같이, 포지션 '1'에 대응하는 카운터 레지스터는 이미 1인 값을 가지므로 1씩 증가하면 2가 된다. 마찬가지로 포지션 '5'및 '7'에 대응하는 각 카운터 레지스터는 0이므로, 증가되면 각각 1이 된다. 따라서, 업데이트된 카운팅 블룸 필터(212)는 포지션 '1'에서 2, 포지션 '3'에서 1, 포지션 '5'에서 1, 포지션 '7'에서 1, 포지션 '9'에서 1의 값을 갖는다. In FIG. 2B, the modulus 11 of h1(y) equals 1, the modulus 11 of h2(y) equals 5, and the modulus 11 of h3(y) equals 7. Each of these values may be used by the data processing system as a pointer to a counter register associated with each position (eg, ID value, etc.) in the counting bloom filter. For example, a modulus 11 of h1(y) equal to 1 could point to position '1' in the Counting Bloom filter, and a modulus 11 of h2(y) equal to 5 would point to position '5' in the Counting Bloom filter. can These are purely example values for purposes of illustrating operations related to counting bloom filters, and should not be construed as limiting the scope of implementations that describe counting bloom filters. The data processing system may update the Counting Bloom filter (eg, insert a data record) by incrementing each of the counter registers pointed to by the respective hash function, resulting in an updated Counting Bloom filter 212 . Although FIG. 2B shows incrementing each counter register by only one, the data processing system may be relative to any value, e.g., number of bytes, number of bits, or any other value, threshold, or estimate described herein. It should be understood that any value of the counter register can be incremented with . As shown in FIG. 2B, since the counter register corresponding to the position '1' already has a value of 1, if it is increased by 1, it becomes 2. Likewise, since each counter register corresponding to positions '5' and '7' is 0, it becomes 1 when incremented. Accordingly, the updated counting bloom filter 212 has a value of 2 at position '1', 1 at position '3', 1 at position '5', 1 at position '7', and 1 at position '9'.
이제 도 2c를 참조하면, 도시된 것은 적어도 하나의 데이터 프로세싱 시스템(예를 들어, 데이터 프로세싱 시스템(105) 중 적어도 하나 등)에 의해 데이터 레코드 X를 도 2c와 관련하여 상기 기술된 업데이트된 카운팅 블룸 필터(212)에 삽입하는 것을 도시하는 흐름도(200C)의 예시적인 도시이다. 블록(214)에서, 데이터 프로세싱 시스템은 카운팅 블룸 필터에 삽입할 데이터 레코드 X를 표시할 수 있다. 데이터 레코드 X는 도 2a와 관련하여 전술한 바와 같이 카운팅 블룸 필터에 이미 삽입되었지만, 이것은 카운팅 블룸 필터의 특성으로 인해 동일한 데이터 레코드가 카운팅 블룸에 한 번 이상 삽입되는 것을 반드시 배제하지는 않는다. 이는 예를 들어 각 포지션이 카운터 레지스터 대신 이진 값에 대응할 수 있는 표준 블룸 필터와 다르다. 표시된 데이터 레코드는 예를 들어 데이터베이스(예를 들어, 데이터베이스(115))로부터 선택될 수 있다. 데이터 프로세싱 시스템은 여기에서 h1, h2 및 h3으로 표시된 여러 해시 함수를 선택할 수 있다. 3개의 해시 함수만 도시되었지만, 데이터 프로세싱 시스템은 표준 카운팅 블룸 필터에 데이터 레코드를 삽입하기 위해 임의의 수의 해시 함수를 사용할 수 있음을 이해해야 한다. 블록(216A-C)에서, 데이터 프로세싱 시스템은 식별된 각 해시 함수를 사용하여 데이터 레코드 X를 적어도 한 번 복제하고 해시할 수 있다. 해시 함수는 예를 들어, 본 명세서에 설명된 바와 같은 ElGamal 해시일 수 있거나, 특히 SHA-1, SHA-2, MD5와 같은 임의의 다른 유형의 해시일 수 있다. 데이터 레코드 X를 3번 복제하고 해싱함으로써(예: 각 해시에 대해 한번씩), 데이터 프로세싱 시스템은 도 2c에서 h1(x), h2(x) 및 h3(x)로 표시된 3개의 해시된 데이터 레코드를 생성했다. 여전히 블록(214A-C)를 참조하면, 데이터 프로세싱 시스템은 각각의 해시된 데이터 레코드로부터 인덱스 값을 추출할 수 있다. 추출된 인덱스 값은 카운팅 블룸 필터에서 적어도 하나의 개별 포지션에 대응할 수 있다. 도 2c에 제공된 예시에서, 각 해시는 카운팅 블룸 필터의 레지스터 포지션의 수인 11의 모듈러스로 계산된다. 11개의 레지스터 포지션만이 카운팅 블룸 필터로 사용되지만, 카운팅 블룸 필터를 구현하는데 임의의 수의 카운팅 레지스터를 사용할 수 있다. Referring now to FIG. 2C , shown is the updated counting bloom described above with respect to FIG. An exemplary illustration of flow chart 200C illustrating insertion into filter 212. At block 214, the data processing system may indicate data record X for insertion into the counting bloom filter. Although data record X has already been inserted into the counting bloom filter as described above with respect to Fig. 2a, this does not necessarily preclude the same data record being inserted into counting bloom more than once due to the nature of the counting bloom filter. This differs from standard bloom filters where each position can correspond to a binary value instead of a counter register, for example. The displayed data record may be selected from, for example, a database (eg, database 115). The data processing system can select several hash functions, denoted here as h1, h2 and h3. Although only three hash functions are shown, it should be understood that a data processing system may use any number of hash functions to insert data records into a standard counting bloom filter. At blocks 216A-C, the data processing system may replicate and hash the data record X at least once using each hash function identified. The hash function may be, for example, an ElGamal hash as described herein, or may be any other type of hash, such as SHA-1, SHA-2, MD5 among others. By duplicating and hashing data record X three times (e.g., once for each hash), the data processing system obtains three hashed data records, denoted h1(x), h2(x), and h3(x) in FIG. 2C. Created. Still referring to blocks 214A-C, the data processing system can extract an index value from each hashed data record. The extracted index value may correspond to at least one individual position in the counting bloom filter. In the example provided in Figure 2c, each hash is computed with a modulus of 11, which is the number of register positions of the counting bloom filter. Only 11 register positions are used as a counting bloom filter, but any number of counting registers can be used to implement a counting bloom filter.
도 2c에서, h1(x)의 모듈러스 11은 1과 같고, h2(x)의 모듈러스 11은 3과 같고, h3(x)의 모듈러스 11은 9와 같다. 이들 각각의 값은 도 2a에서 결정된 것과 동일하다. 이는 데이터 프로세싱 시스템이 동일한 해시 함수를 사용하여 동일한 데이터 레코드를 해싱하고 있기 때문에, 각 해시의 값은 도 2에서 이전에 계산된 것과 동일한 값이 된다. 데이터 프로세싱 시스템은 카운팅 블룸 필터에서 각각의 포지션(예를 들어, ID 값 등)과 연관된 카운터 레지스터에 대한 포인터로서 이들 인덱스 값 각각을 사용할 수 있다. 예를 들어, 1과 같은 h1(x)의 모듈러스 11은 카운팅 블룸 필터에서 포지션 '1'을 가리킬 수 있으며, h2(x)의 모듈러스 11은 3과 같고, 카운팅 블룸 필터에서 포지션 '3'을 가리킬 수 있다. 이들은 블룸 필터 카운팅와 관련된 작업을 설명하기 위한 목적으로 순전히 예제 값이며, 카운팅 블룸 필터를 설명하는 구현 범위를 제한하는 것으로 해석되어서는 안된다. 데이터 프로세싱 시스템은 각각의 해시 함수에 의해 가리키는 카운터 레지스터 각각을 증가시킴으로써 카운팅 블룸 필터를 업데이트(예를 들어, 데이터 레코드 삽입)할 수 있으며, 그 결과 업데이트된 카운팅 블룸 필터(218)가 생성된다. 비록 도 2c는 각각의 카운터 레지스터를 1만큼만 증가시키는 것을 도시하고 있지만, 데이터 프로세싱 시스템은 임의의 값, 예를 들어 바이트 수, 비트 수 또는 임의의 다른 값, 임계치 또는 본 명세서에 기술된 추정치에 상대적으로 카운터 레지스터 중 임의의 값을 증가시킬 수 있음을 이해해야 한다. 도 2c에 도시된 바와 같이, 포지션 '1'에 대응하는 카운터 레지스터는 이미 2인 값을 가지므로 1씩 증가하면 3이 된다. 마찬가지로, 포지션 '3'과 '9'에 대응하는 각 카운터 레지스터는 1이므로 증가되면 2가 된다. 따라서, 업데이트된 카운팅 블룸 필터(218)는 포지션 '1'에서 3, 포지션 '3'에서 2, 포지션 '5'에서 1, 포지션 '7'에서 1, 포지션 '9'에서 2의 값을 갖는다. In Fig. 2C, the modulus 11 of h1(x) equals 1, the modulus 11 of h2(x) equals 3, and the modulus 11 of h3(x) equals 9. Each of these values is the same as determined in FIG. 2A. This is because the data processing system is hashing the same data record using the same hash function, so the value of each hash will be the same as previously calculated in FIG. 2 . The data processing system can use each of these index values as a pointer to a counter register associated with each position (eg, ID value, etc.) in the counting bloom filter. For example, a modulus 11 of h1(x) equal to 1 could point to position '1' in the Counting Bloom filter, and a modulus 11 of h2(x) equal to 3 would point to position '3' in the Counting Bloom filter. can These are purely example values for purposes of illustrating operations related to counting bloom filters, and should not be construed as limiting the scope of implementations that describe counting bloom filters. The data processing system may update the Counting Bloom filter (eg, insert a data record) by incrementing each of the counter registers pointed to by the respective hash function, resulting in an updated Counting Bloom filter 218 . Although FIG. 2C shows incrementing each counter register by only one, the data processing system may be relative to any value, e.g., number of bytes, number of bits, or any other value, threshold, or estimate described herein. It should be understood that the arbitrary value of the counter register can be incremented with . As shown in FIG. 2C, since the counter register corresponding to position '1' already has a value of 2, increasing by 1 becomes 3. Similarly, since each counter register corresponding to positions '3' and '9' is 1, it becomes 2 when incremented. Accordingly, the updated counting bloom filter 218 has values of 3 at position '1', 2 at position '3', 1 at position '5', 1 at position '7', and 2 at position '9'.
이제 도 3a를 참조하면, 도시된 것은 적어도 하나의 데이터 프로세싱 시스템(예를 들어, 데이터 프로세싱 시스템(105) 중 적어도 하나 등)에 의해 데이터 레코드 X를 최소 증가 카운팅 블룸 필터에 삽입하는 것을 도시하는 흐름도(300A)의 예시적인 도시이다. 블록(302)에서, 데이터 프로세싱 시스템은 카운팅 블룸 필터에 삽입할 데이터 레코드(예: 데이터 레코드 X)를 표시할 수 있다. 표시된 데이터 레코드는 예를 들어 데이터베이스(예를 들어, 데이터베이스(115))로부터 선택될 수 있다. 데이터 프로세싱 시스템은 여기에서 h1, h2 및 h3으로 표시된 여러 해시 함수를 선택할 수 있다. 3개의 해시 함수만 도시되었지만, 데이터 프로세싱 시스템은 표준 카운팅 블룸 필터에 데이터 레코드를 삽입하기 위해 임의의 수의 해시 함수를 사용할 수 있음을 이해해야 한다. 블록(304A-C)에서, 데이터 프로세싱 시스템은 식별된 각 해시 함수를 사용하여 선택된 데이터 레코드(예: 데이터 레코드 X)를 적어도 한 번 복제하고 해시할 수 있다. 해시 함수는 예를 들어, 본 명세서에 설명된 바와 같은 ElGamal 해시일 수 있거나, 특히 SHA-1, SHA-2, MD5와 같은 임의의 다른 유형의 해시일 수 있다. 데이터 레코드 X를 3번 복제하고 해싱함으로써, 데이터 프로세싱 시스템은 도 3a에서 h1(x), h2(x) 및 h3(x)로 표시된 3개의 해시된 데이터 레코드를 생성했다. 여전히 블록(304A-C)를 참조하면, 데이터 프로세싱 시스템은 각각의 해시된 데이터 레코드로부터 인덱스 값을 추출할 수 있다. 추출된 인덱스 값은 카운팅 블룸 필터에서 적어도 하나의 개별 포지션에 대응할 수 있다. 도 3a에 제공된 예시에서, 각 해시는 카운팅 블룸 필터의 레지스터 포지션의 수인 11의 모듈러스로 계산된다. 11개의 레지스터 포지션만이 블룸 필터로 사용되지만, 블룸 필터를 구현하는데 임의의 수의 카운팅 레지스터를 사용할 수 있다. Referring now to FIG. 3A , shown is a flow diagram illustrating the insertion of data record X into a minimum increment counting bloom filter by at least one data processing system (e.g., at least one of data processing systems 105, etc.) 300A is an exemplary illustration. At block 302, the data processing system can indicate a data record (eg, data record X) for insertion into the counting bloom filter. The displayed data record may be selected from, for example, a database (eg, database 115). The data processing system can select several hash functions, denoted here as h1, h2 and h3. Although only three hash functions are shown, it should be understood that a data processing system may use any number of hash functions to insert data records into a standard counting bloom filter. At blocks 304A-C, the data processing system may duplicate and hash the selected data record (eg, data record X) at least once using each hash function identified. The hash function may be, for example, an ElGamal hash as described herein, or may be any other type of hash, such as SHA-1, SHA-2, MD5 among others. By duplicating and hashing data record X three times, the data processing system generated three hashed data records, denoted h1(x), h2(x), and h3(x) in FIG. 3A. Still referring to blocks 304A-C, the data processing system can extract an index value from each hashed data record. The extracted index value may correspond to at least one individual position in the counting bloom filter. In the example provided in Figure 3a, each hash is computed with a modulus of 11, which is the number of register positions of the counting bloom filter. Only 11 register positions are used as bloom filters, but any number of counting registers can be used to implement a bloom filter.
도 3a에서, h1(x)의 모듈러스 11은 1과 같고, h2(x)의 모듈러스 11은 3과 같고, h3(x)의 모듈러스 11은 9와 같다. 이들 값 각각은 카운팅 블룸 필터에서 각각의 포지션(예를 들어, ID 값 등)와 연관된 카운터 레지스터에 대한 포인터로서 데이터 프로세싱 시스템에 의해 사용될 수 있다. 예를 들어, 1과 같은 h1(x)의 모듈러스 11은 카운팅 블룸 필터에서 포지션 '1'을 가리킬 수 있으며, h2(x)의 모듈러스 11은 3과 같고, 카운팅 블룸 필터에서 포지션 '3'을 가리킬 수 있다. 이들은 블룸 필터 카운팅와 관련된 작업을 설명하기 위한 목적으로 순전히 예제 값이며, 카운팅 블룸 필터를 설명하는 구현 범위를 제한하는 것으로 해석되어서는 안된다. 최소 증가 카운팅 블룸 필터에 데이터 레코드를 삽입하기 위해, 데이터 프로세싱 시스템은 계산된 인덱스 값이 가리키는 카운터 레지스터의 최소값에 대응하는 카운터 레지스터를 증가시킬 수 있다. 예를 들어, 데이터 프로세싱 시스템은 계산된 인덱스 값이 가리키는 각 카운터 레지스터에 액세스할 수 있다. 도 3a에 도시된 바와 같이, 이들은 포지션 '1', '3', '9'에 대응하는 카운터 레지스터이다. 최소 증가 카운팅 블룸 필터가 아직 업데이트되지 않았기 때문에 이러한 각 포지션은 0이다. In FIG. 3A , the modulus 11 of h1(x) equals 1, the modulus 11 of h2(x) equals 3, and the modulus 11 of h3(x) equals 9. Each of these values may be used by the data processing system as a pointer to a counter register associated with each position (eg, ID value, etc.) in the counting bloom filter. For example, a modulus 11 of h1(x) equal to 1 could point to position '1' in the Counting Bloom filter, and a modulus 11 of h2(x) equal to 3 would point to position '3' in the Counting Bloom filter. can These are purely example values for purposes of illustrating operations related to counting bloom filters, and should not be construed as limiting the scope of implementations describing counting bloom filters. To insert a data record into the minimum increment counting bloom filter, the data processing system may increment the counter register corresponding to the minimum value of the counter register to which the computed index value points. For example, the data processing system can access each counter register pointed to by the computed index value. As shown in Fig. 3A, these are counter registers corresponding to positions '1', '3', and '9'. Each of these positions is 0 because the minimum increment counting bloom filter has not yet been updated.
데이터 프로세싱 시스템은 이러한 액세스된 데이터 레지스터 각각을 비교하여 카운터 레지스터 간의 최소값을 결정할 수 있다. 예를 들어 최소값은 액세스된 카운터 레지스터의 가장 작은 카운터 레지스터 값일 수 있다. 둘 이상의 카운터 레지스터가 최소값과 동일할 수 있다. 데이터 프로세싱 시스템은 카운터 레지스터의 결정된 최소값과 동일한 값으로 액세스된 카운터 레지스터의 서브세트를 선택할 수 있다. 도 3a에 표시된 바와 같이, 각각의 액세스된 카운터 레지스터는 0과 같고, 따라서 각각의 액세스된 카운터 레지스터는 최소값(여기서는 0)과 같다. 따라서, 액세스된 각 카운터 레지스터가 선택된다. 데이터 프로세싱 시스템은 카운터 레지스터의 선택된 서브세트 각각을 증가시킴으로써 최소 증가 카운팅 블룸 필터를 업데이트(예를 들어, 데이터 레코드 삽입)하여, 업데이트된 카운팅 블룸 필터(306)를 생성할 수 있다. 비록 도 3a는 각각의 카운터 레지스터를 1만큼만 증가시키는 것을 도시하고 있지만, 데이터 프로세싱 시스템은 임의의 값, 예를 들어 바이트 수, 비트 수 또는 임의의 다른 값, 임계치 또는 본 명세서에 기술된 추정치에 상대적으로 카운터 레지스터의 선택된 서브세트의 임의의 값을 증가시킬 수 있음을 이해해야 한다.The data processing system can compare each of these accessed data registers to determine the minimum value between the counter registers. For example, the minimum value may be the smallest counter register value of the counter registers accessed. More than one counter register may be equal to the minimum value. The data processing system may select the subset of counter registers accessed with a value equal to the determined minimum value of the counter register. As indicated in Fig. 3A, each accessed counter register is equal to zero, and thus each accessed counter register is equal to a minimum value (zero here). Thus, each counter register accessed is selected. The data processing system may update the minimum increment counting bloom filter by incrementing each selected subset of counter registers (eg, insert a data record), resulting in updated counting bloom filter 306 . Although FIG. 3A shows incrementing each counter register by only one, the data processing system may be relative to any value, e.g., number of bytes, number of bits, or any other value, threshold, or estimate described herein. It is to be understood that can increment any value of a selected subset of the counter registers with .
이제 도 3b를 참조하면, 도시된 것은 적어도 하나의 데이터 프로세싱 시스템(예를 들어, 데이터 프로세싱 시스템(105) 중 적어도 하나 등)에 의해 데이터 레코드 Y를 최소 증가 카운팅 블룸 필터에 삽입하는 것을 도시하는 흐름도(300B)의 예시적인 도시이다. 블록(308)에서, 데이터 프로세싱 시스템은 카운팅 블룸 필터에 삽입할 데이터 레코드(예: 데이터 레코드 Y)를 표시할 수 있다. 표시된 데이터 레코드는 예를 들어 데이터베이스(예를 들어, 데이터베이스(115))로부터 선택될 수 있다. 데이터 프로세싱 시스템은 여기에서 h1, h2 및 h3으로 표시된 여러 해시 함수를 선택할 수 있다. 3개의 해시 함수만 도시되었지만, 데이터 프로세싱 시스템은 표준 카운팅 블룸 필터에 데이터 레코드를 삽입하기 위해 임의의 수의 해시 함수를 사용할 수 있음을 이해해야 한다. 블록(304A-C)에서, 데이터 프로세싱 시스템은 식별된 각 해시 함수를 사용하여 선택된 데이터 레코드(예: 데이터 레코드 Y)를 적어도 한 번 복제하고 해시할 수 있다. 해시 함수는 예를 들어, 본 명세서에 설명된 바와 같은 ElGamal 해시일 수 있거나, 특히 SHA-1, SHA-2, MD5와 같은 임의의 다른 유형의 해시일 수 있다. 데이터 레코드 Y를 3번 복제하고 해싱함으로써, 데이터 프로세싱 시스템은 도 3b에서 h1(y), h2(y) 및 h3(y)로 표시된 3개의 해시된 데이터 레코드를 생성했다. 여전히 블록(310A-C)를 참조하면, 데이터 프로세싱 시스템은 각각의 해시된 데이터 레코드로부터 인덱스 값을 추출할 수 있다. 추출된 인덱스 값은 카운팅 블룸 필터에서 적어도 하나의 개별 포지션에 대응할 수 있다. 도 3b에 제공된 예시에서, 각 해시는 카운팅 블룸 필터의 레지스터 포지션의 수인 11의 모듈러스로 계산된다. 11개의 레지스터 포지션만이 블룸 필터로 사용되지만, 블룸 필터를 구현하는데 임의의 수의 카운팅 레지스터를 사용할 수 있다. Referring now to FIG. 3B , shown is a flow diagram illustrating the insertion of data record Y into a minimum increment counting bloom filter by at least one data processing system (e.g., at least one of data processing systems 105, etc.) 300B is an exemplary illustration. At block 308, the data processing system can indicate a data record (eg, data record Y) for insertion into the counting bloom filter. The displayed data record may be selected from, for example, a database (eg, database 115). The data processing system can select several hash functions, denoted here as h1, h2 and h3. Although only three hash functions are shown, it should be understood that a data processing system may use any number of hash functions to insert data records into a standard counting bloom filter. At blocks 304A-C, the data processing system may duplicate and hash the selected data record (eg, data record Y) at least once using each hash function identified. The hash function can be, for example, an ElGamal hash as described herein, or any other type of hash, such as SHA-1, SHA-2, MD5 among others. By duplicating and hashing data record Y three times, the data processing system generated three hashed data records, denoted h1(y), h2(y), and h3(y) in FIG. 3B. Still referring to blocks 310A-C, the data processing system can extract an index value from each hashed data record. The extracted index value may correspond to at least one individual position in the counting bloom filter. In the example provided in Figure 3b, each hash is computed with a modulus of 11, which is the number of register positions of the counting bloom filter. Only 11 register positions are used as bloom filters, but any number of counting registers can be used to implement a bloom filter.
도 3b에서, h1(y)의 모듈러스 11은 1과 같고, h2(y)의 모듈러스 11은 5과 같고, h3(y)의 모듈러스 11은 7와 같다. 이들 값 각각은 최소 증가 카운팅 블룸 필터에서 각각의 포지션(예를 들어, ID 값 등)와 연관된 카운터 레지스터에 대한 포인터로서 데이터 프로세싱 시스템에 의해 사용될 수 있다. 예를 들어, 1과 같은 h1(y)의 모듈러스 11은 카운팅 블룸 필터에서 포지션 '1'을 가리킬 수 있으며, h2(y)의 모듈러스 11은 5과 같고, 카운팅 블룸 필터에서 포지션 '5'을 가리킬 수 있다. 이들은 블룸 필터 카운팅와 관련된 작업을 설명하기 위한 목적으로 순전히 예제 값이며, 카운팅 블룸 필터를 설명하는 구현 범위를 제한하는 것으로 해석되어서는 안된다. 최소 증가 카운팅 블룸 필터에 데이터 레코드를 삽입하기 위해, 데이터 프로세싱 시스템은 계산된 인덱스 값이 가리키는 카운터 레지스터의 최소값에 대응하는 카운터 레지스터를 증가시킬 수 있다. 예를 들어, 데이터 프로세싱 시스템은 계산된 인덱스 값이 가리키는 각 카운터 레지스터에 액세스하여, 업데이트 동작 전에 그들의 값을 결정할 수 있다. 도 3b에 도시된 바와 같이, 이들은 포지션 '1', '5', '7'에 대응하는 카운터 레지스터이다. 업데이트 이전에, 포지션 '1'에 대응하는 값은 1이고, 포지션 '5'에 대응하는 값은 0이고, 포지션 '7'에 해당하는 값도 0이다. In FIG. 3B, the modulus 11 of h1(y) equals 1, the modulus 11 of h2(y) equals 5, and the modulus 11 of h3(y) equals 7. Each of these values may be used by the data processing system as a pointer to a counter register associated with each position (eg, ID value, etc.) in the minimum increment counting bloom filter. For example, a modulus 11 of h1(y) equal to 1 could point to position '1' in the Counting Bloom filter, and a modulus 11 of h2(y) equal to 5 would point to position '5' in the Counting Bloom filter. can These are purely example values for purposes of illustrating operations related to counting bloom filters, and should not be construed as limiting the scope of implementations describing counting bloom filters. To insert a data record into the minimum increment counting bloom filter, the data processing system may increment the counter register corresponding to the minimum value of the counter register to which the computed index value points. For example, the data processing system can access each counter register pointed to by the computed index value and determine their value prior to the update operation. As shown in Fig. 3B, these are counter registers corresponding to positions '1', '5', and '7'. Before the update, the value corresponding to position '1' is 1, the value corresponding to position '5' is 0, and the value corresponding to position '7' is also 0.
데이터 프로세싱 시스템은 이러한 액세스된 데이터 레지스터 각각을 비교하여 카운터 레지스터 간의 최소값을 결정할 수 있다. 예를 들어 최소값은 액세스된 카운터 레지스터의 가장 작은 카운터 레지스터 값일 수 있다. 둘 이상의 카운터 레지스터가 최소값과 동일할 수 있다. 이 경우, 최소값은 포지션 '5' 및 '7'에 표시되며, 업데이트 단계 이전은 모두 0이다. 데이터 프로세싱 시스템은 카운터 레지스터의 결정된 최소값과 동일한 값으로 액세스된 카운터 레지스터의 서브세트를 선택할 수 있고, 이 경우 포지션 '5' 및 '7'에 대응하는 카운터 레지스터를 선택하는 것을 의미한다. 데이터 프로세싱 시스템은 카운터 레지스터의 선택된 서브세트 각각을 증가시킴으로써 최소 증가 카운팅 블룸 필터를 업데이트(예를 들어, 데이터 레코드 삽입)하여, 업데이트된 카운팅 블룸 필터(312)를 생성할 수 있다. h1(y)가 포지션 '1'을 가리키지만, 가리키는 카운터 레지스터의 최소값과 같지 않기 때문에 증가되지 않는다. 비록 도 3b는 각각의 카운터 레지스터를 1만큼만 증가시키는 것을 도시하고 있지만, 데이터 프로세싱 시스템은 임의의 값, 예를 들어 바이트 수, 비트 수 또는 임의의 다른 값, 임계치 또는 본 명세서에 기술된 추정치에 상대적으로 카운터 레지스터의 선택된 서브세트의 임의의 값을 증가시킬 수 있음을 이해해야 한다.The data processing system can compare each of these accessed data registers to determine the minimum value between the counter registers. For example, the minimum value may be the smallest counter register value of the counter registers accessed. More than one counter register may be equal to the minimum value. In this case, the minimum values are displayed at positions '5' and '7', and are all zeros before the update step. The data processing system may select the subset of counter registers accessed with a value equal to the determined minimum value of the counter register, in this case meaning selecting the counter registers corresponding to positions '5' and '7'. The data processing system may update (eg, insert a data record) the minimum increment counting bloom filter by incrementing each selected subset of counter registers, resulting in an updated counting bloom filter 312 . Although h1(y) points to position '1', it is not incremented because it is not equal to the minimum value of the counter register it points to. Although FIG. 3B shows incrementing each counter register by only one, the data processing system may be relative to any value, e.g., number of bytes, number of bits, or any other value, threshold, or estimate described herein. It is to be understood that can increment any value of a selected subset of counter registers with .
이제 도 3c를 참조하면, 도시된 것은 적어도 하나의 데이터 프로세싱 시스템(예를 들어, 데이터 프로세싱 시스템(105) 중 적어도 하나 등)에 의해 데이터 레코드 X를 최소 증가 카운팅 블룸 필터에 삽입하는 것을 도시하는 흐름도(300C)의 예시적인 도시이다. 블록(314)에서, 데이터 프로세싱 시스템은 최소 증가 카운팅 블룸 필터에 삽입할 데이터 레코드(예: 데이터 레코드 X)를 표시할 수 있다. 데이터 레코드 X는 도 3a와 관련하여 위에서 설명한 바와 같이 최소 증가 블룸 필터에 이미 삽입되었지만, 이것은 데이터 프로세싱 시스템이 데이터 레코드 X를 두 번 이상 삽입하는 것을 반드시 배제하지는 않는다. 표시된 데이터 레코드는 예를 들어 데이터베이스(예를 들어, 데이터베이스(115))로부터 선택될 수 있다. 데이터 프로세싱 시스템은 여기에서 h1, h2 및 h3으로 표시된 여러 해시 함수를 선택할 수 있다. 3개의 해시 함수만 도시되었지만, 데이터 프로세싱 시스템은 표준 카운팅 블룸 필터에 데이터 레코드를 삽입하기 위해 임의의 수의 해시 함수를 사용할 수 있음을 이해해야 한다. 블록(316A-C)에서, 데이터 프로세싱 시스템은 식별된 각 해시 함수를 사용하여 선택된 데이터 레코드(예: 데이터 레코드 X)를 적어도 한 번 복제하고 해시할 수 있다. 해시 함수는 예를 들어, 본 명세서에 설명된 바와 같은 ElGamal 해시일 수 있거나, 특히 SHA-1, SHA-2, MD5와 같은 임의의 다른 유형의 해시일 수 있다. 데이터 레코드 X를 3번 복제하고 해싱함으로써, 데이터 프로세싱 시스템은 도 3c에서 h1(x), h2(x) 및 h3(x)로 표시된 3개의 해시된 데이터 레코드를 생성했다. 여전히 블록(316A-C)를 참조하면, 데이터 프로세싱 시스템은 각각의 해시된 데이터 레코드로부터 인덱스 값을 추출할 수 있다. 추출된 인덱스 값은 카운팅 블룸 필터에서 적어도 하나의 개별 포지션에 대응할 수 있다. 도 3c에 제공된 예시에서, 각 해시는 카운팅 블룸 필터의 레지스터 포지션의 수인 11의 모듈러스로 계산된다. 11개의 레지스터 포지션만이 블룸 필터로 사용되지만, 블룸 필터를 구현하는데 임의의 수의 카운팅 레지스터를 사용할 수 있다. Referring now to FIG. 3C , shown is a flow diagram illustrating the insertion of data record X into a minimum increment counting bloom filter by at least one data processing system (e.g., at least one of data processing systems 105, etc.) (300C) is an exemplary illustration. At block 314, the data processing system can indicate a data record (eg, data record X) for insertion into the least incremental counting bloom filter. Although data record X has already been inserted into the minimum increment bloom filter as described above with respect to FIG. 3A, this does not necessarily preclude the data processing system from inserting data record X more than once. The displayed data record may be selected from, for example, a database (eg, database 115). The data processing system can select several hash functions, denoted here as h1, h2 and h3. Although only three hash functions are shown, it should be understood that a data processing system may use any number of hash functions to insert data records into a standard counting bloom filter. At blocks 316A-C, the data processing system may duplicate and hash the selected data record (eg, data record X) at least once using each hash function identified. The hash function may be, for example, an ElGamal hash as described herein, or may be any other type of hash, such as SHA-1, SHA-2, MD5 among others. By duplicating and hashing data record X three times, the data processing system generated three hashed data records, denoted h1(x), h2(x), and h3(x) in FIG. 3C. Still referring to blocks 316A-C, the data processing system can extract an index value from each hashed data record. The extracted index value may correspond to at least one individual position in the counting bloom filter. In the example provided in Figure 3c, each hash is computed with a modulus of 11, which is the number of register positions of the counting bloom filter. Only 11 register positions are used as bloom filters, but any number of counting registers can be used to implement a bloom filter.
도 3b에서, h1(x)의 모듈러스 11은 1과 같고, h2(x)의 모듈러스 11은 3과 같고, h3(x)의 모듈러스 11은 9와 같다. 이들 값 각각은 최소 증가 카운팅 블룸 필터에서 각각의 포지션(예를 들어, ID 값 등)와 연관된 카운터 레지스터에 대한 포인터로서 데이터 프로세싱 시스템에 의해 사용될 수 있다. 예를 들어, 1과 같은 h1(x)의 모듈러스 11은 카운팅 블룸 필터에서 포지션 '1'을 가리킬 수 있으며, h2(x)의 모듈러스 11은 3과 같고, 카운팅 블룸 필터에서 포지션 '3'을 가리킬 수 있다. 이들은 블룸 필터 카운팅와 관련된 작업을 설명하기 위한 목적으로 순전히 예제 값이며, 카운팅 블룸 필터를 설명하는 구현 범위를 제한하는 것으로 해석되어서는 안된다. 최소 증가 카운팅 블룸 필터에 데이터 레코드를 삽입하기 위해, 데이터 프로세싱 시스템은 계산된 인덱스 값이 가리키는 카운터 레지스터의 최소값에 대응하는 카운터 레지스터를 증가시킬 수 있다. 예를 들어, 데이터 프로세싱 시스템은 계산된 인덱스 값이 가리키는 각 카운터 레지스터에 액세스하여, 업데이트 동작 전에 그들의 값을 결정할 수 있다. 도 3c에 도시된 바와 같이, 이들은 포지션 '1', '3', '9'에 대응하는 카운터 레지스터이다. 업데이트하기 전에 포지션 '1', '3', '9'에 대응하는 값은 각각 1이다. In FIG. 3B, the modulus 11 of h1(x) equals 1, the modulus 11 of h2(x) equals 3, and the modulus 11 of h3(x) equals 9. Each of these values may be used by the data processing system as a pointer to a counter register associated with each position (eg, ID value, etc.) in the minimum increment counting bloom filter. For example, a modulus 11 of h1(x) equal to 1 could point to position '1' in the Counting Bloom filter, and a modulus 11 of h2(x) equal to 3 would point to position '3' in the Counting Bloom filter. can These are purely example values for purposes of illustrating operations related to counting bloom filters, and should not be construed as limiting the scope of implementations that describe counting bloom filters. To insert a data record into the minimum increment counting bloom filter, the data processing system may increment the counter register corresponding to the minimum value of the counter register to which the computed index value points. For example, the data processing system can access each counter register pointed to by the computed index value and determine their value prior to the update operation. As shown in Fig. 3c, these are counter registers corresponding to positions '1', '3', and '9'. Before updating, the values corresponding to positions '1', '3', and '9' are respectively 1.
데이터 프로세싱 시스템은 이러한 액세스된 데이터 레지스터 각각을 비교하여 카운터 레지스터 간의 최소값을 결정할 수 있다. 예를 들어 최소값은 액세스된 카운터 레지스터의 가장 작은 카운터 레지스터 값일 수 있다. 둘 이상의 카운터 레지스터가 최소값과 동일할 수 있다. 이 경우 최소값은 포지션 '1', '3', '9'에서 공유되며, 업데이트 단계 이전의 위치는 각각 1이다. 데이터 프로세싱 시스템은 카운터 레지스터의 결정된 최소값과 동일한 값으로 액세스된 카운터 레지스터의 서브세트를 선택할 수 있고, 이 경우 포지션 '1', '3' 및 '9'에 대응하는 카운터 레지스터를 선택하는 것을 의미한다. 데이터 프로세싱 시스템은 카운터 레지스터의 선택된 서브세트 각각을 증가시킴으로써 최소 증가 카운팅 블룸 필터를 업데이트(예를 들어, 데이터 레코드 삽입)하여, 업데이트된 카운팅 블룸 필터(318)를 생성할 수 있다. 업데이트된 최소 증가 블룸 필터(318)에서, 포지션 '1', '3' 및 '9' 각각은 2의 값을 갖도록 증가되고 다른 위치는 변경되지 않은 상태로 유지된다. 비록 도 3c는 각각의 카운터 레지스터를 1만큼 증가시키는 것을 도시하고 있지만, 데이터 프로세싱 시스템은 임의의 값, 예를 들어 바이트 수, 비트 수 또는 임의의 다른 값, 임계치 또는 본 명세서에 기술된 추정치에 상대적으로 카운터 레지스터의 선택된 서브세트의 임의의 값을 증가시킬 수 있음을 이해해야 한다.The data processing system can compare each of these accessed data registers to determine the minimum value between the counter registers. For example, the minimum value may be the smallest counter register value of the counter registers accessed. More than one counter register may be equal to the minimum value. In this case, the minimum value is shared by positions '1', '3', and '9', and the positions before the update step are each 1. The data processing system may select the subset of counter registers accessed with a value equal to the determined minimum value of the counter register, in this case meaning selecting the counter registers corresponding to positions '1', '3' and '9'. . The data processing system may update the minimum increment counting bloom filter by incrementing each selected subset of counter registers (eg, insert a data record) to produce the updated counting bloom filter 318 . In the updated minimum increment bloom filter 318, each of positions '1', '3' and '9' is incremented to have a value of 2 and the other positions remain unchanged. Although FIG. 3C illustrates incrementing each counter register by 1, the data processing system may be relative to any value, e.g. number of bytes, number of bits or any other value, threshold or estimate described herein. It is to be understood that can increment any value of a selected subset of the counter registers with .
이제 다시 도 1을 참조하면, 우리는 작업자 컴퓨팅 디바이스의 동작과 관련하여 데이터 프로세싱 시스템의 기능 및 모듈에 대한 설명을 계속한다. 동일한 데이터 프로세싱 시스템(105)의 일부로 도시되어 있지만, 아래에서 설명하는 각 컴포넌트(예를 들어, 암호화 키 생성기(145), 벡터 암호화기(150), 암호화된 벡터 통신기(155), 벡터 결합기(160), 히스토그램 구성기(165) 및 카디널리티 추정기(165)) 및 도 4a-c에서 수반되는 설명은 동일한 모듈 기능을 포함하고 구현하는 작업자 컴퓨팅 디바이스에 의해 수행될 수 있다. 이와 같이, 데이터 프로세싱 시스템(105)이 이러한 모듈을 포함할 수 있지만, 다른 구현예는 이러한 동작 및 컴포넌트가 하나 이상의 작업 컴퓨팅 디바이스에서 실행, 유지 및 구현되도록 제공할 수 있음을 이해해야 한다. 또한, 다음 컴포넌트의 서브세트만이 작업자 컴퓨팅 디바이스, 예를 들어 암호화 키 생성기(145), 암호화된 벡터 통신기(155), 벡터 결합기(160), 히스토그램 구성기(165) 및 카디널리티 추정기(170)를 포함하는 작업자 컴퓨팅 디바이스에 상주할 수 있음을 이해해야 한다. 따라서, 그러한 작업자 컴퓨팅 디바이스는 예를 들어 네트워크(110)를 통해 데이터 프로세싱 시스템(105)과 통신할 수 있고, 시스템의 전체 차등적 프라이버시를 유지하기 위해 암호화된 벡터 또는 암호화 키만 교환할 수 있다.Referring now again to FIG. 1 , we continue the description of the functions and modules of the data processing system with respect to the operation of the worker computing device. Although shown as part of the same data processing system 105, each of the components described below (e.g., encryption key generator 145, vector encryptor 150, encrypted vector communicator 155, vector combiner 160) ), histogram configurator 165 and cardinality estimator 165) and the accompanying descriptions in FIGS. 4A-C can be performed by a worker computing device that includes and implements the same module functions. As such, while data processing system 105 may include such modules, it should be understood that other implementations may provide for these operations and components to be executed, maintained, and implemented on one or more working computing devices. In addition, only a subset of the following components can be used on worker computing devices, e.g., cryptographic key generator 145, encrypted vector communicator 155, vector combiner 160, histogram constructor 165, and cardinality estimator 170. It should be understood that it may reside on a worker computing device that includes. Accordingly, such worker computing devices may communicate with data processing system 105 over network 110, for example, and only exchange encrypted vectors or encryption keys to maintain the overall differential privacy of the system.
암호화 키 생성기(145)는 적어도 하나의 벡터를 암호화하기 위해 하나 이상의 개인 및 공개 키를 생성할 수 있다. 암호화 키 생성기(145)는 또한 자신의 공개 및 개인 키 쌍을 생성했던 다른 작업자 컴퓨팅 디바이스를 식별하거나 그로부터 데이터를 수신할 수 있다. 암호화 키 생성기(145)는 적어도 하나의 다른 공개 키를 수신하기 위해 다른 작업자 컴퓨팅 디바이스와 통신할 수 있다. 암호화 키 생성기(145)는 수집된(예를 들어, 결합된) 암호화 키를 생성하기 위해 암호화 키 생성기(145)에 의해 생성된 공개 키와 함께 수신된 공개 키 각각을 통합, 연결 또는 결합할 수 있다. 생성된 암호화 키는 모든 종류의 동형 암호화 키 또는 방식(예: ElGamal 암호화 키)일 수 있다. 암호화 키 생성기(145)는 생성 및 집합된 암호화 키를 벡터 암호화기(150)에 통신하여 각각의 데이터 프로세싱 시스템(105)에 의해 유지되는 최소 증가 카운팅 블룸 필터를 암호화할 수 있다. 암호화 키 생성기(145)는 각각의 집합된 암호화 키를 각각의 데이터 프로세싱 시스템(105A-N)(예를 들어, 각각의 식별자 서버 등)에 추가로 분배할 수 있다.The encryption key generator 145 can generate one or more private and public keys to encrypt the at least one vector. Encryption key generator 145 may also identify or receive data from other worker computing devices that have generated its own public and private key pair. The cryptographic key generator 145 can communicate with other worker computing devices to receive at least one other public key. Encryption key generator 145 may aggregate, concatenate, or combine each received public key with the public key generated by encryption key generator 145 to generate a collected (e.g., combined) encryption key. there is. The generated encryption key can be any kind of homomorphic encryption key or scheme (eg ElGamal encryption key). The encryption key generator 145 may communicate the generated and aggregated encryption key to the vector encryptor 150 to encrypt the minimum increment counting bloom filter maintained by each data processing system 105 . Encryption key generator 145 may further distribute each aggregated encryption key to each data processing system 105A-N (eg, each identifier server, etc.).
벡터 암호화기(150)는 암호화된 벡터를 생성하기 위해 암호화 키 생성기(145)에 의해 수신된 통합 암호화 키를 사용하여 최소 증가 카운팅 블룸 필터의 하나 이상의 카운터 레지스터 각각을 암호화할 수 있다. 최소 증가 카운팅 블룸 필터의 차등 프라이버시를 보장하기 위해, 벡터 암호화 기(150)는 각각의 데이터 프로세싱 시스템(105)(예를 들어, 각각의 식별자 서버)에 의해 생성 및 유지되는 벡터를 암호화하기 위해 하나 이상의 암호화 기법을 사용할 수 있다. 예를 들어, 데이터 프로세싱 시스템은 암호화 체계(예를 들어, ElGamal 암호화, 임계값 복호화를 지원하는 암호화 체계, 동형 암호화 등)를 사용하여 암호화 키 생성기로부터 수신된 집합된 공개 키를 사용할 수 있다. 일부 구현예에서, 벡터 암호화기(150)는 집합된 암호화 키를 사용하여 개별적으로 벡터의 좌표에 대응하는 카운터 레지스터들 각각을 암호화할 수 있다. 이러한 구현예에서, 암호화된 카운터 레지스터 각각은 최소 증가 계수 블룸 필터를 나타내는 암호화된 벡터를 생성하기 위해 집합될 수 있다.Vector encryptor 150 may encrypt each of the one or more counter registers of the minimum increment counting bloom filter using the combined encryption key received by encryption key generator 145 to generate an encrypted vector. To ensure differential privacy of the least incremental counting bloom filter, vector encryptor 150 uses one to encrypt vectors generated and maintained by each data processing system 105 (e.g., each identifier server). Any of the above encryption techniques can be used. For example, the data processing system may use an aggregated public key received from an encryption key generator using an encryption scheme (eg, ElGamal encryption, an encryption scheme that supports threshold decryption, homomorphic encryption, etc.). In some implementations, vector encryptor 150 can encrypt each of the counter registers individually corresponding to the vector's coordinates using the aggregated encryption key. In such an implementation, each of the encrypted counter registers can be aggregated to create an encrypted vector representing a minimum increment factor bloom filter.
암호화된 벡터 통신기(155)는 암호화된 벡터를 적어도 하나의 작업자 컴퓨팅 디바이스에 통신할 수 있다. 일부 구현예에서, 암호화된 벡터 통신기(155)는 암호화된 벡터에 대한 하나 이상의 요청을 수신할 수 있으며, 이는 본 명세서에 설명된 바와 같이 암호화된 벡터의 생성 또는 통신을 차례로 트리거할 수 있다. 요청은 예를 들어 적어도 하나의 작업자 컴퓨팅 디바이스에 의해 수신될 수 있다. 암호화된 벡터를 전송하는 것은 네트워크(110)를 통해 작업자 컴퓨팅 디바이스에 암호화된 벡터를 제공하는 것을 포함할 수 있다. 암호화된 벡터 통신기(155)는 암호화된 벡터를 프로세싱하기 위해 하나 이상의 작업자 컴퓨팅 디바이스 중 첫 번째로 작업자 컴퓨팅 디바이스를 선택할 수 있다. 일부 구현예에서, 암호화된 벡터 통신기(155)는 암호화된 벡터를 버킷 단위로 전송할 수 있으며, 여기서 각 버킷은 작업자 컴퓨팅 디바이스에 개별적으로 전송된다. 일부 구현예에서, 암호화된 벡터 통신기(155)는 암호화된 벡터를 대량 트랜잭션으로 전송할 수 있으며, 여기서 암호화된 벡터의 대부분 또는 전체가 단일 메시지로 전송된다.Encrypted vector communicator 155 can communicate the encrypted vector to at least one worker computing device. In some implementations, encrypted vector communicator 155 can receive one or more requests for encrypted vectors, which in turn can trigger generation or communication of encrypted vectors as described herein. The request may be received by at least one worker computing device, for example. Sending the encrypted vector may include providing the encrypted vector to a worker computing device over the network 110 . The encrypted vector communicator 155 can select a first of the one or more worker computing devices to process the encrypted vectors. In some implementations, encrypted vector communicator 155 can transmit encrypted vectors in buckets, where each bucket is individually transmitted to a worker computing device. In some implementations, encrypted vector communicator 155 can transmit encrypted vectors in bulk transactions, where most or all of the encrypted vectors are transmitted in a single message.
벡터 결합기(160)는 하나 이상의 식별자 서버(예를 들어, 데이터 프로세싱 시스템(105A-N))로부터 하나 이상의 암호화된 벡터를 수신할 수 있다. 수신된 암호화 벡터 각각은 암호화된 벡터의 좌표에 대응하는 적어도 하나의 암호화된 카운터 레지스터를 포함할 수 있다. 일부 구현예에서, 벡터 결합기(160)는 벡터를 주기적으로 또는 버스트 트랜잭션으로 수신할 수 있다. 각 벡터는 벡터가 수신되었던 식별자 서버를 반영하는 각각의 식별자와 연관될 수 있다. 식별자 서버로부터 수신된 암호화된 벡터 각각은 암호화 키 생성기(145)에 의해 생성된 결합된 공개 키를 사용하여 암호화될 수 있고, 각각의 식별자 서버(예를 들어, 데이터 프로세싱 시스템(105A-N))에 분배될 수 있다. 결합된 공개 키는 작업자 컴퓨팅 디바이스가 식별자 서버로부터 수신된 암호화된 벡터를 부분적으로 복호화할 수 있게 한다. 이들 동작은 도 4a-c와 관련하여 아래에서 더 상세히 설명된다.Vector combiner 160 may receive one or more encrypted vectors from one or more identifier servers (eg, data processing systems 105A-N). Each received encryption vector may include at least one encrypted counter register corresponding to the coordinates of the encrypted vector. In some implementations, vector combiner 160 may receive vectors periodically or in burst transactions. Each vector may be associated with a respective identifier reflecting the identifier server from which the vector was received. Each encrypted vector received from the identifier server may be encrypted using the combined public key generated by the encryption key generator 145, and the respective identifier server (e.g., data processing systems 105A-N) can be distributed to The combined public key enables the worker computing device to partially decrypt the encrypted vector received from the identifier server. These operations are described in more detail below with respect to FIGS. 4A-C.
이제 도 4a를 참조하면, 도시된 것은 작업자 컴퓨팅 디바이스에 의한 암호화 키의 생성 및 배포를 위한 시스템 흐름도(400A)이다. 시스템 흐름도(400A)는 하나 이상의 작업자 컴퓨팅 디바이스(405A-C)(때로는 일반적으로 작업자들(405) 또는 작업자(405)로 지칭됨)를 포함할 수 있다. 작업자 컴퓨팅 디바이스는 3개 뿐이지만 여기에 설명된 기능을 구현하기 위해 임의의 수의 작업자 컴퓨팅 디바이스를 사용할 수 있음을 이해해야 한다. 작업자(405)는 데이터 프로세싱 시스템(105) 중 적어도 하나일 수 있거나, 데이터 프로세싱 시스템(105)의 컴포넌트의 서브세트, 예를 들어 암호화 키 생성기(145), 암호화된 벡터 통신기(155), 벡터 결합기(160), 히스토그램 구성기(165) 및 카디널리티 추정기(170)를 포함할 수 있다.Referring now to FIG. 4A , shown is a system flow diagram 400A for generation and distribution of encryption keys by worker computing devices. System flow diagram 400A may include one or more worker computing devices 405A-C (sometimes commonly referred to as workers 405 or worker 405). Although there are only three worker computing devices, it should be understood that any number of worker computing devices may be used to implement the functionality described herein. Worker 405 can be at least one of data processing system 105, or a subset of components of data processing system 105, such as cryptographic key generator 145, encrypted vector communicator 155, vector combiner. (160), histogram constructor 165 and cardinality estimator 170.
도 4a에 도시된 바와 같이, 작업자(405)는 결합된 키를 생성할 수 있다. 결합된 키를 생성하는 것은 적어도 하나의 공개 키와 적어도 하나의 개인 키를 생성하는 것을 포함할 수 있다. 일부 구현예에서, 작업자(405)는 적어도 ElGamal 암호화 기법의 일부로서 구현될 수 있는 키를 생성할 수 있다. 예를 들어, 작업자(405)는 랜덤(예를 들어, 의사 랜덤 등) 정수 X modulo q(예를 들어, 타원 곡선 그룹의 순서)를 생성하거나 선택할 수 있다. 작업자(405)는 정수 X를 복호화를 위한 개인 키로 사용할 수 있고, gX를 공개 키로 사용할 수 있으며, 여기서 g는 생성기이다. 예를 들어 생성기는 순환 그룹의 멤버일 수 있다. 공개 키는 예를 들어 하나 이상의 다른 작업자(405)와 공유될 수 있다. 다른 작업자(405) 각각은 자신의 공개 및 개인 키 쌍을 생성하여 다른 작업자(405) 각각에 전송할 수 있다. 결합된 키를 생성하기 위해 각 작업자(405)는 다른 작업자(405)로부터 수신된 각 공개 키를 자신의 공개 키와 결합할 수 있다.As shown in FIG. 4A, operator 405 can generate a combined key. Generating the combined key may include generating at least one public key and at least one private key. In some implementations, worker 405 can generate a key that can be implemented at least as part of an ElGamal cryptographic technique. For example, operator 405 may generate or select a random (eg, pseudorandom, etc.) integer X modulo q (eg, order of a group of elliptic curves). Worker 405 can use integer X as the private key for decryption and gX as the public key, where g is the generator. For example, a generator can be a member of a recursive group. The public key may be shared with one or more other workers 405, for example. Each of the other workers 405 can generate its own public and private key pair and transmit it to each of the other workers 405 . Each worker 405 may combine each public key received from another worker 405 with its own public key to generate a combined key.
이제 도 4b를 참조하면, 도시된 것은 식별자 서버에 의한 암호화된 벡터의 분배를 위한 시스템 흐름도(400B)이다. 시스템 흐름도(400B)는 적어도 하나의 식별자 서버(415A-N) 및 적어도 하나의 작업자(405A-N)를 포함할 수 있다. 작업자(405)는 도 4a와 관련하여 위에서 더 설명된다. 각각의 식별자 서버(415A-N)는 예를 들어, 도 1과 관련하여 위에서 설명된 데이터 프로세싱 시스템(105) 중 하나 이상일 수 있다. 흐름도(400B)에서, 작업자(405A)는 제1 작업자(405)로서(예를 들어, 요청에 의해, 내부 구성 설정 등에 의해 임의로) 선택되었다. 각각의 식별자 서버는 위에서 설명한 바와 같이 암호화된 레지스터 버킷을 포함할 수 있는 연관된 암호화된 벡터를 제공할 수 있다. Referring now to FIG. 4B, shown is a system flow diagram 400B for distribution of encrypted vectors by an identifier server. System flow diagram 400B may include at least one identifier server 415A-N and at least one worker 405A-N. Worker 405 is further described above with respect to FIG. 4A. Each identifier server 415A-N may be, for example, one or more of the data processing systems 105 described above with respect to FIG. 1 . In flowchart 400B, worker 405A has been selected (eg, by request, arbitrarily by internal configuration settings, etc.) as first worker 405 . Each identifier server may provide an associated encrypted vector that may include an encrypted register bucket as described above.
식별자 서버에 의해 암호화를 위해 결합된 키를 전송한 후, 작업자(405)(예를 들어, 제1 작업자(405A))는 식별자 서버(415A-N) 각각으로부터 적어도 하나의 암호화된 벡터를 수신할 수 있다. 일부 구현예에서, 제1 작업자(405A)는 벡터를 주기적으로 또는 버스트 트랜잭션으로 수신할 수 있다. 각 벡터는 벡터가 수신되었던 식별자 서버(415A-N)를 반영하는 각각의 식별자와 연관될 수 있다. 식별자 서버(415A-N)로부터 수신된 각각의 암호화된 벡터는 도 1 및 도 4a와 관련하여 위에서 설명된 바와 같이 생성된 결합된 공개 키를 사용하여 암호화될 수 있다. 결합된 공개 키는 각 작업자(405)가 식별자 서버로부터 수신된 암호화된 벡터를 부분적으로 복호화하게 할 수 있다.After sending the combined key for encryption by the identifier server, worker 405 (e.g., first worker 405A) may receive at least one encrypted vector from each of identifier servers 415A-N. can In some implementations, first worker 405A may receive the vectors periodically or in burst transactions. Each vector may be associated with a respective identifier that reflects the identifier server 415A-N from which the vector was received. Each encrypted vector received from the identifier server 415A-N may be encrypted using a combined public key generated as described above with respect to FIGS. 1 and 4A. The combined public key enables each worker 405 to partially decrypt the encrypted vector received from the identifier server.
이제 도 4c를 참조하면, 도시된 것은 노이즈가 있는 집합된 벡터의 순차 복호화에 대한 시스템 흐름도(400C)이다. 시스템 흐름도(400C)는 적어도 하나의 작업자(405A-N)를 포함할 수 있다. 작업자(405)는 도 4a 및 4b와 관련하여 위에서 더 설명된다. 흐름도(400C)에서, 제1 작업자(405A)는 도 4b와 관련하여 전술한 바와 같이 식별자 서버(415A-N)로부터 수신된 암호화된 벡터를 프로세싱할 수 있다. 암호화된 벡터를 프로세싱하기 위해, 제1 작업자(405A)는 도 6 및 도 7과 관련하여 이하에서 설명되는 바와 같이 방법(600) 및 방법(700)의 단계를 수행할 수 있다. 식별자 서버(415A-N)로부터 수신된 벡터를 프로세싱한 후, 작업자(415)는 프로세싱된 암호화된 벡터를 그 첨부된 디코딩 룩업 테이블과 함께 애그리게이터 컴퓨팅 디바이스(410)로 전달할 수 있다.Referring now to FIG. 4C, shown is a system flow diagram 400C for sequential decoding of noisy aggregated vectors. System flow diagram 400C may include at least one operator 405A-N. Worker 405 is further described above with respect to FIGS. 4A and 4B . In flow diagram 400C, first worker 405A may process the encrypted vectors received from identifier servers 415A-N as described above with respect to FIG. 4B. To process the encrypted vector, the first operator 405A may perform the steps of method 600 and method 700 as described below with respect to FIGS. 6 and 7 . After processing the vectors received from identifier servers 415A-N, worker 415 may pass the processed encrypted vector along with its attached decoding lookup table to aggregator computing device 410 .
애그리게이터(410) 컴퓨팅 디바이스는 데이터 프로세싱 시스템(105A-N)의 하나 이상의 모듈 또는 위에서 설명한 바와 같이 작업자 컴퓨팅 디바이스의 하나 이상의 모듈을 포함할 수 있다. 예를 들어, 애그리게이터(410)는 데이터 프로세싱 시스템(105)의 모든 컴포넌트(예: 벡터 생성기(130), 해시 식별자(135), 데이터 레코드 해시기(140), 암호화 키 생성기(145), 벡터 암호화기(150), 암호화된 벡터 통신기(155), 벡터 결합기(160), 히스토그램 구성기(165) 및 카디널리티 추정기(170) 등)를 포함할 수 있다. 일부 구현예에서, 애그리게이터(410)는 데이터 프로세싱 시스템(105)의 일부 컴포넌트(예를 들어, 암호화 키 생성기(145), 암호화된 벡터 통신기(155), 벡터 결합기(160), 히스토그램 구성기(165) 및 카디널리티 추정기(170))를 포함할 수 있다. 일부 구현예에서, 애그리게이터(410)는 암호화된 벡터 통신기(155), 히스토그램 구성기(165) 및 카디널리티 추정기(170)를 포함할 수 있다. 애그리게이터(410)는 데이터 프로세싱 시스템(105A-N) 중 적어도 하나, 작업자(405A-N) 중 적어도 하나, 또는 작업자(405A-N) 및 데이터 프로세싱 시스템(105A-N)과 통신하는 별도의 개별 컴퓨팅 디바이스일 수 있다. The aggregator 410 computing device may include one or more modules of the data processing systems 105A-N or one or more modules of a worker computing device as described above. For example, aggregator 410 may include all components of data processing system 105 (e.g., vector generator 130, hash identifier 135, data record hash 140, encryption key generator 145, vector encryptor 150, encrypted vector communicator 155, vector combiner 160, histogram constructor 165 and cardinality estimator 170, etc.). In some implementations, aggregator 410 is some component of data processing system 105 (e.g., encryption key generator 145, encrypted vector communicator 155, vector combiner 160, histogram constructor ( 165) and a cardinality estimator 170). In some implementations, aggregator 410 may include encrypted vector communicator 155 , histogram constructor 165 and cardinality estimator 170 . The aggregator 410 may be at least one of the data processing systems 105A-N, at least one of the workers 405A-N, or a separate individual in communication with the workers 405A-N and the data processing systems 105A-N. It can be a computing device.
다시 도 1을 참조하여 (적어도 하나의 데이터 프로세싱 시스템(105A-N) 또는 적어도 하나의 작업자(405) 등일 수 있는) 애그리게이터(410)의 동작과 관련하여 다음 컴포넌트를 설명하면, 암호화된 벡터 통신기(155)는 작업자 컴퓨팅 디바이스(예: 작업자(405) 등)로부터의 암호화된 순열된 벡터를 수신할 수 있다. 암호화된 순열 벡터는 아래에 설명된 방법(500) 및 방법(600)과 함께 각각의 작업자 컴퓨팅 디바이스(예를 들어, 작업자(405))에 의해 프로세싱되는 집합 벡터일 수 있다. 암호화된 벡터 통신기(155)는 컴퓨터 메모리의 하나 이상의 데이터 구조에 암호화된 순열 벡터를 저장할 수 있다. 일부 구현예에서, 암호화된 벡터 통신기(155)는 순열된 암호화된 벡터와 연관된 디코딩 룩업 테이블을 수신할 수 있다. 일부 구현예에서, 순열된 암호화 벡터는 디코딩 룩업 테이블과 연결되거나 그렇지 않으면 추가될 수 있다.Referring again to FIG. 1 , the following components are described in relation to the operation of the aggregator 410 (which may be at least one data processing system 105A-N, or at least one worker 405, etc.): an encrypted vector communicator 155 may receive an encrypted permuted vector from a worker computing device (eg, worker 405, etc.). The encrypted permutation vector may be an aggregate vector that is processed by each worker computing device (eg, worker 405 ) in conjunction with method 500 and method 600 described below. Encrypted vector communicator 155 may store encrypted permutation vectors in one or more data structures in computer memory. In some implementations, encrypted vector communicator 155 can receive a decoding lookup table associated with the permuted encrypted vector. In some implementations, the permuted encryption vector may be concatenated with or otherwise appended to the decoding lookup table.
히스토그램 구성기(165)는 암호화된 순열 벡터의 좌표 값에 기초하여 버킷 히스토그램을 구성할 수 있다. 히스토그램 구성은 암호화된 순열 벡터에 추가되거나 연결된 디코딩 룩업 테이블을 사용하여 암호화된 순열 벡터를 디코딩하는 것을 포함할 수 있다. 디코딩 룩업 테이블은 예를 들어 작업자(405) 중 적어도 하나에 의해 생성된 대응 디코딩 키일 수 있다. 히스토그램 구성기(165)는 식별자 서버에 대응하는 집합된 벡터의 값을 나타내기 위해 디코딩 룩업 테이블을 사용할 수 있다. 복호화되면 집합된 벡터는 목표 빈도 값에 대응하는 복호화된 버킷 값을 포함할 수 있다. 목표 빈도 값은 내부 구성 설정에 의해 제공될 수 있으며, 시스템(100)의 임의의 컴퓨팅 디바이스로부터 수신된 요청으로 제공되거나 작업자(405) 또는 애그리게이터(410) 중 하나로부터 제공될 수 있다. 목표 빈도 값은 0보다 크거나 같은 모든 종류의 숫자 값을 포함할 수 있으며, 히스토그램 구성기(165)가 목표 빈도 값을 사용하여 값이 목표 빈도보다 크거나 같은 암호화된 벡터의 버킷을 디코딩하게 할 수 있다. 예를 들어, 목표 빈도 값이 3이면 히스토그램 구성기(165)는 3개 이상의 암호화된 벡터의 버킷을 디코딩할 수 있고, 목표 빈도 값보다 작은 버킷의 값은 디코딩할 수 없다. The histogram constructor 165 may construct a bucket histogram based on the coordinate values of the encrypted permutation vector. Histogram construction may include decoding the encrypted permutation vector using a decoding lookup table appended to or concatenated with the encrypted permutation vector. The decoding lookup table may be, for example, a corresponding decoding key generated by at least one of the workers 405 . Histogram constructor 165 may use the decoding lookup table to indicate the values of the aggregated vectors corresponding to the identifier server. When decrypted, the aggregated vector may include a decoded bucket value corresponding to the target frequency value. The target frequency value may be provided by an internal configuration setting, and may be provided in a request received from any computing device in system 100 or may be provided from either worker 405 or aggregator 410 . The target frequency value can contain any kind of numeric value greater than or equal to zero, which causes the histogram constructor 165 to use the target frequency value to decode buckets of encrypted vectors whose values are greater than or equal to the target frequency. can For example, if the target frequency value is 3, the histogram constructor 165 can decode buckets of 3 or more encrypted vectors, and cannot decode buckets of values less than the target frequency value.
일부 구현예에서, 작업자(405)는 디코딩 룩업 테이블을 생성할 때 목표 빈도 값을 통합할 수 있다. 이러한 구현예에서, 작업자(405)는 목표 빈도 값보다 크거나 같은 값을 갖는 버킷만을 디코딩하도록 디코딩 룩업 테이블을 구성할 수 있다. 작업자(405)는 예를 들어 시스템(100)의 임의의 컴퓨팅 디바이스로부터 또는 내부 구성 설정으로부터 요청 또는 메시지에서 목표 빈도 값을 획득할 수 있다. 그러한 구현예에서, 디코딩 룩업 테이블은 목표 빈도 값과 같거나 더 큰 값을 갖는 버킷을 디코딩하도록 구성될 수 있다. 각각의 작업자(405)는 암호화된 벡터의 자신의 몫을 부분적으로 복호화할 때 결정론적 암호화 키의 몫으로 디코딩 룩업 테이블을 업데이트할 수 있다. 작업자(405)는 임계치보다 크거나 같은 암호화된 벡터의 버킷의 자신의 몫을 디코딩하도록 디코딩 룩업 테이블을 구성할 수 있지만 임계치보다 작은 값에 대응하는 버킷은 복호화할 수 없다. 이와 같이 히스토그램 구성기(165)가 암호화된 벡터를 디코딩하여 히스토그램을 생성할 때, 디코딩 룩업 테이블을 사용하여 목표 빈도 임계치보다 크거나 같은 각 버킷이 디코딩될 수 있고, 목표보다 작은 버킷은 암호화된 상태로 유지될 수 있다. 버킷 히스토그램을 구성할 때 암호화된 상태로 남아있는 각 버킷은 여기에 설명된 대로 max_frequency 값으로 설정될 수 있다. 히스토그램 구성기(165)는 예를 들어 시스템(100)의 임의의 컴퓨팅 디바이스로부터의 요청 또는 메시지로부터 또는 내부 구성 설정으로부터 max_frequency 값을 수신할 수 있다. 암호화된 벡터를 디코딩함으로써, 히스토그램 구성기(165)는 암호화된 벡터의 디코딩된 값들 각각을 포함하는 디코딩된 벡터를 생성할 수 있다.In some implementations, worker 405 can incorporate target frequency values when creating a decoding lookup table. In this implementation, worker 405 can configure the decoding lookup table to decode only those buckets with a value greater than or equal to the target frequency value. Worker 405 can obtain the target frequency value in a request or message, for example, from any computing device in system 100 or from an internal configuration setting. In such an implementation, the decoding lookup table can be configured to decode buckets with values greater than or equal to the target frequency value. When each worker 405 partially decrypts its share of the encrypted vector, it can update the decode lookup table with its share of the deterministic encryption key. Worker 405 can configure the decoding lookup table to decode its share of the buckets of encrypted vectors greater than or equal to the threshold, but cannot decrypt buckets corresponding to values less than the threshold. In this way, when the histogram constructor 165 decodes the encrypted vector to generate a histogram, each bucket greater than or equal to the target frequency threshold can be decoded using the decoding lookup table, and buckets less than the target remain encrypted. can be maintained as When constructing a bucket histogram, each bucket that remains encrypted can be set to a max_frequency value as described here. Histogram configurator 165 can receive the max_frequency value from an internal configuration setting or from a request or message from any computing device in system 100, for example. By decoding the encrypted vector, histogram constructor 165 can produce a decoded vector containing each of the decoded values of the encrypted vector.
디코딩 룩업 테이블을 사용하여 암호화된 벡터를 디코딩 한 후, 히스토그램 구성기(165)는 디코딩된 벡터의 버킷 또는 카운터 레지스터를 사용하여 버킷 히스토그램을 생성할 수 있다. 버킷 히스토그램은 디코딩된 벡터의 각 버킷 값의 빈도에 대응할 수 있다. 예를 들어 버킷 히스토그램의 각 빈은 [0, 1); [1, 2); [2, 3); [3, 4); 등과 같은 범위를 가질 수 있다. 버킷 히스토그램을 생성하기 위해, 히스토그램 구성기(165)는 디코딩된 벡터의 각 좌표에 액세스하여 그 값을 결정할 수 있다. 그 값을 결정한 후, 히스토그램 구성기(165)는 버킷 히스토그램에서 대응하는 빈을 증가시키거나 추가할 수 있다. 예를 들어, 히스토그램 구성기(165)가 51과 동일한 디코딩된 벡터 좌표 값에 액세스하면, 히스토그램 구성기(165)는 범위 [51, 52)에 대응하는 버킷 히스토그램 빈을 증가시킬 수 있다. 이러한 예에서, 히스토그램 빈 범위가 단일 정수 범위와 동일하다고 설명되었지만, 버킷 히스토그램 빈은 모든 유형의 숫자 범위를 반영하는 빈에 대응할 수 있음을 이해해야 한다. 따라서 일부 구현예에서 버킷 히스토그램 빈은 단일 정수 값 범위보다 더 넓거나 좁은 범위에 대응할 수 있다. After decoding the encrypted vector using the decoding lookup table, the histogram constructor 165 may use the decoded vectors' buckets or counter registers to generate a bucket histogram. The bucket histogram may correspond to the frequency of each bucket value of the decoded vector. For example, each bin in a bucket histogram is [0, 1); [1, 2); [2, 3); [3, 4); ranges such as To create a bucket histogram, histogram constructor 165 can access each coordinate of the decoded vector to determine its value. After determining that value, the histogram constructor 165 may increment or add the corresponding bin in the bucket histogram. For example, if histogram constructor 165 accesses a decoded vector coordinate value equal to 51, histogram constructor 165 can increment the bucket histogram bin corresponding to the range [51, 52]. In these examples, although histogram bin ranges have been described as being equivalent to single integer ranges, it should be understood that bucket histogram bins may correspond to bins reflecting any type of numeric range. Thus, in some implementations, bucket histogram bins may correspond to ranges wider or narrower than a range of single integer values.
히스토그램 구성기(165)는 디코딩된 벡터의 각 값을 반복할 수 있고, 전술한 바와 같이 히스토그램을 업데이트할 수 있다. 히스토그램 구성기(165)는 컴퓨터 메모리의 하나 이상의 데이터 구조에 히스토그램을 저장할 수 있다. 디코딩된 벡터의 각 좌표 버킷을 반복한 후, 히스토그램 구성기(165)는 히스토그램에서 노이즈를 제거할 수 있다. 벡터를 부분적으로 복호화하고 셔플링하기 전에 하나 이상의 작업자(405)가 추가 버킷을 추가했음을 기억해야 한다. 노이즈 버킷 값을 암호화된 벡터에 첨부하기 전에, 작업자(405) 각각은 기준 노이즈 값 B에 동의했다. 이와 같이, 히스토그램에 제시된 결과가 편향되고, 정확한 측정을 달성하기 위해 노이즈가 제거될 수 있다. 노이즈를 제거하기 위해, 히스토그램 구성기(165)는 각각의 버킷 히스토그램 빈을 반복하고, B*w를 뺄 수 있으며, 여기서 w는 버킷에 노이즈를 추가한 작업자(405)의 수이다. 히스토그램 구성기(165)는 하나 이상의 작업자(405)로부터 기준 노이즈 값과 함께 암호화된 벡터에 노이즈를 추가한 작업자(405)의 수를 수신할 수 있다. 일부 구현예에서, 히스토그램 구성기(165)는 기준 노이즈 값 B에 대해 이미 동의한 작업자(405)에서 실행 중이다. 이와 같이, 컴퓨터 메모리에 상주할 수 있는 기준 노이즈 값을 요청하거나 수신할 필요가 있을 수 있다. 히스토그램의 각 빈으로부터 노이즈를 감산함으로써, 히스토그램 구성기(165)는 필터링된 히스토그램을 생성할 수 있다. 기준(baseline)이 제거되었지만 필터링된 히스토그램에 양측 기하학적 노이즈가 여전히 존재할 수 있음을 이해해야 한다. 이는 카디널리티 또는 빈도 추정 결과에 큰 영향을 미치지 않으면서, 노이즈가 히스토그램의 값을 더 난독화하므로 시스템의 보안을 더욱 향상시킬 수 있다. Histogram constructor 165 can iterate over each value of the decoded vector and update the histogram as described above. Histogram configurator 165 may store the histogram in one or more data structures in computer memory. After iterating through each coordinate bucket of the decoded vector, histogram constructor 165 may remove noise from the histogram. It should be remembered that one or more workers 405 added additional buckets before partially decrypting and shuffling the vectors. Before attaching the noise bucket values to the encrypted vector, each of the workers 405 agreed on a baseline noise value B. In this way, the results presented in the histogram can be biased and noise removed to achieve an accurate measurement. To remove noise, histogram constructor 165 iterates through each bucket histogram bin and may subtract B*w, where w is the number of operators 405 that added noise to the bucket. The histogram constructor 165 may receive a reference noise value from one or more operators 405 and the number of operators 405 that added noise to the encrypted vector. In some implementations, histogram configurator 165 is running on worker 405 that has already agreed on a reference noise value B. As such, it may be necessary to request or receive a reference noise value that may reside in computer memory. By subtracting the noise from each bin of the histogram, histogram constructor 165 may produce a filtered histogram. It should be understood that although the baseline has been removed, there may still be bilateral geometric noise present in the filtered histogram. This can further improve the security of the system because the noise further obfuscates the histogram values without significantly affecting the cardinality or frequency estimation results.
카디널리티 추정기(170)는 히스토그램 생성기(165)에 의해 생성된 필터링된 히스토그램에 기초하여 디바이스 식별자 및 디바이스 속성 세트의 카디널리티(예를 들어, 멀티세트의 고유 멤버의 수 등)를 추정할 수 있다. 멀티세트의 총 카디널리티를 추정하기 위해, 카디널리티 추정기(170)는 아래에 포함된 공식을 사용할 수 있다.Cardinality estimator 170 may estimate the cardinality of the device identifier and device attribute set (e.g., the number of unique members of the multiset, etc.) based on the filtered histogram generated by histogram generator 165. To estimate the total cardinality of the multiset, cardinality estimator 170 may use the formula included below.
위 식에서, n은 멀티세트의 카디널리티, k는 각 최소 증가 계수 블룸 필터를 채우는데 사용되는 해시 함수의 수, m은 디코딩된 벡터의 카운터 레지스터 버킷 수, x는 디코딩된 벡터의 채워진 버킷의 수이다. 카디널리티 추정기(170)는 필터링된 히스토그램에서 1보다 크거나 같은 각각의 빈을 카운팅함으로써 채워진 버킷의 수를 결정할 수 있다. 카디널리티 추정기(170)는 시스템(100)의 하나 이상의 컴퓨팅 디바이스 또는 작업자(405) 또는 애그리게이터(410) 중 임의의 것으로부터, 각각의 다른 값(예를 들어, 해시 함수의 수, 각각의 디코딩된 벡터 내의 카운터 레지스터 버킷의 수 등)을 수신할 수 있다. 멀티세트의 K+ 빈도를 추정하기 위해, 카디널리티 추정기(170)는 하나 이상의 대안으로 위에서 제공된 식을 이용할 수 있다. K+ 빈도를 추정하기 위해, 카디널리티 추정기(170)는 카디널리티 추정기(170)가 목표 빈도 값 K보다 작은 범위에 대응하는 필터링된 히스토그램의 빈을 비어있는 것으로 취급하도록 히스토그램을 추가로 필터링할 수 있다. 예를 들어, 목표 빈도가 3인 경우, 카디널리티 추정기(170)는 3미만의 모든 범위(예: [0, 1), [1, 2), [2, 3) 등)를 비어있는 것으로 취급할 수 있고, 카디널리티 추정에 해당 버킷을 포함하지 않는다. 이와 같이, 위 식에서 x의 값은 빈도 임계 값보다 크거나 같은 디코딩된 벡터의 버킷 수로 취급된다. 카디널리티 추정기(170)는 예를 들어, 내부 구성 설정으로부터 또는 시스템(100)의 하나 이상의 컴퓨팅 디바이스로부터, 또는 작업자(405) 또는 애그리게이터(410)로부터 빈도 임계 값을 수신할 수 있다. 멀티세트의 카디널리티 또는 빈도를 계산한 후, 카디널리티 추정기(170)는 하나 이상의 메시지에서 카디널리티 또는 빈도를 요청하는 컴퓨팅 디바이스에 제공(예를 들어, 전송 또는 통신하는 등)할 수 있다. 카디널리티 추정기(170)는 시스템(100)의 임의의 컴퓨팅 디바이스, 예를 들어 데이터 프로세싱 시스템(105A-N), 클라이언트 디바이스(120) 또는 시스템(100)에 도시되지 않았지만 네트워크(110)에 통신적으로 연결되고 요청을 통신하고 카디널리티 추정기(170)로부터 카디널리티 데이터를 수신하도록 구성된 다른 외부 컴퓨팅 디바이스로부터 카디널리티에 대한 요청을 수신할 수 있다.In the above equation, n is the cardinality of the multiset, k is the number of hash functions used to fill each minimum increment factor bloom filter, m is the number of counter register buckets in the decoded vector, and x is the number of filled buckets in the decoded vector. . Cardinality estimator 170 may determine the number of filled buckets by counting each bin greater than or equal to 1 in the filtered histogram. Cardinality estimator 170 calculates each other value (e.g., the number of hash functions, each decoded number of counter register buckets in a vector, etc.). To estimate the K+ frequencies of the multiset, cardinality estimator 170 may use the equations provided above as one or more alternatives. To estimate K+ frequencies, cardinality estimator 170 may further filter the histogram such that cardinality estimator 170 treats bins in the filtered histogram corresponding to a range less than the target frequency value K as empty. For example, if the target frequency is 3, the cardinality estimator 170 will treat all ranges less than 3 (e.g., [0, 1), [1, 2), [2, 3), etc.) as empty. possible, and the corresponding bucket is not included in the cardinality estimation. As such, the value of x in the above equation is treated as the number of buckets of the decoded vector greater than or equal to the frequency threshold. Cardinality estimator 170 may receive frequency thresholds from internal configuration settings or from one or more computing devices in system 100 , or from worker 405 or aggregator 410 , for example. After calculating the cardinality or frequency of the multiset, the cardinality estimator 170 may provide (eg, transmit, communicate, etc.) the cardinality or frequency in one or more messages to the requesting computing device. Cardinality estimator 170 is not shown on any computing device in system 100, such as data processing systems 105A-N, client device 120, or system 100 but is communicatively connected to network 110. A request for cardinality may be received from another external computing device that is connected and configured to communicate the request and receive cardinality data from cardinality estimator 170 .
이제 도 5를 참조하면, 도시된 것은 식별자 값 및 속성 데이터에 기초하여 암호화된 벡터를 생성하기 위한 방법(500)의 흐름도이다. 방법(500)은 예를 들어, 적어도 하나의 데이터 프로세싱 시스템(예를 들어, 적어도 하나의 데이터 프로세싱 시스템(105) 등) 또는 여기에 설명된 임의의 다른 컴퓨팅 디바이스에 의해 수행될 수 있다. 데이터 프로세싱 시스템은 데이터 레코드를 유지할 수 있다(동작 502). 데이터 프로세싱 시스템은 벡터를 생성할 수 있다(동작 504). 데이터 프로세싱 시스템은 k번째 데이터 레코드를 선택할 수 있다(동작 506). 데이터 프로세싱 시스템은 선택된 데이터 레코드를 해시할 수 있다(동작 508). 데이터 프로세싱 시스템은 레지스터 식별자를 추출할 수 있다(동작 510). 데이터 프로세싱 시스템은 j번째 레지스터 식별자를 선택할 수 있다(동작 512). 데이터 프로세싱 시스템은 선택된 레지스터 식별자를 증가시킬 수 있다(동작 514). 데이터 프로세싱 시스템은 카운터 레지스터 j가 레지스터 식별자의 수 m과 동일한지 여부를 결정할 수 있다(동작 516). 데이터 프로세싱 시스템은 카운터 레지스터 j를 증가시킬 수 있다(동작 518). 데이터 프로세싱 시스템은 카운터 레지스터 k가 데이터 레코드의 수 n과 동일한지 여부를 결정할 수 있다(동작 520). 데이터 프로세싱 시스템은 카운터 레지스터 k를 증가시킬 수 있다(동작 522). 데이터 프로세싱 시스템은 집합된 암호화 키를 획득할 수 있다(동작 524). 데이터 프로세싱 시스템은 벡터 카운터 레지스터를 암호화할 수 있다(동작 526). 데이터 프로세싱 시스템은 암호화된 벡터를 전송할 수 있다(동작 528).Referring now to FIG. 5 , shown is a flow diagram of a method 500 for generating an encrypted vector based on identifier values and attribute data. Method 500 may be performed by, for example, at least one data processing system (eg, at least one data processing system 105 , etc.) or any other computing device described herein. The data processing system may maintain data records (act 502). The data processing system may generate the vector (act 504). The data processing system may select the kth data record (act 506). The data processing system may hash the selected data record (act 508). The data processing system may extract the register identifier (act 510). The data processing system may select the jth register identifier (act 512). The data processing system may increment the selected register identifier (Act 514). The data processing system may determine whether the counter register j is equal to the number m of register identifiers (act 516). The data processing system may increment the counter register j (act 518). The data processing system may determine whether the counter register k is equal to the number of data records n (act 520). The data processing system may increment the counter register k (act 522). The data processing system may obtain the aggregated encryption key (act 524). The data processing system may encrypt the vector counter register (act 526). The data processing system may transmit the encrypted vector (act 528).
데이터 프로세싱 시스템은 데이터 레코드를 유지할 수 있다(동작 502). 데이터 레코드(예를 들어, 데이터 레코드(122A-N))는 예를 들어 하나 이상의 디바이스 식별자(예를 들어, 클라이언트 식별자(122A-N)) 및 하나 이상의 속성(예를 들어, 속성(127A-N))을 포함할 수 있다. 데이터 레코드는 데이터 프로세싱 시스템에 통신적으로 결합된 데이터베이스(예를 들어, 데이터베이스(115))에 저장된 하나 이상의 데이터 구조일 수 있다. 데이터 레코드를 유지하는 것은 컴퓨터 메모리에 하나 이상의 데이터 레코드를 저장하는 것을 포함할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 하나 이상의 메시지(예를 들어, 요청, 표시, 데이터 패킷 등)를 수신하는 것에 응답하여 데이터 레코드를 적어도 하나의 클라이언트 디바이스(예를 들어, 적어도 하나의 클라이언트 디바이스(120))에 유지할 수 있다. 데이터 프로세싱 시스템은 메시지의 속성과 함께 메시지로부터 적어도 하나의 식별자를 추출하고 식별자 및 속성을 포함하는 데이터 레코드를 생성할 수 있다. 데이터 프로세싱 시스템은 데이터베이스, 하나 이상의 데이터 구조 또는 비휘발성 컴퓨터 판독가능 매체와 같은 컴퓨터 메모리에 데이터 레코드를 유지(예를 들어, 저장, 로드 또는 기록)할 수 있다.The data processing system may maintain data records (act 502). Data records (eg, data records 122A-N) may include, for example, one or more device identifiers (eg, client identifiers 122A-N) and one or more attributes (eg, attributes 127A-N). )) may be included. A data record may be one or more data structures stored in a database (eg, database 115) communicatively coupled to the data processing system. Maintaining data records may include storing one or more data records in a computer memory. In some implementations, the data processing system, in response to receiving one or more messages (eg, requests, indications, data packets, etc.), sends data records to at least one client device (eg, at least one client device ( 120)). The data processing system may extract at least one identifier from the message along with attributes of the message and create a data record containing the identifier and attributes. A data processing system may maintain (eg, store, load, or write) records of data in computer memory, such as a database, one or more data structures, or non-volatile computer-readable media.
데이터 프로세싱 시스템은 벡터를 생성할 수 있다(동작 504). 벡터를 생성하기 위해, 데이터 프로세싱 시스템은 적어도 하나의 카운터 레지스터를 수용하기 위해 하나 이상의 메모리 영역을 할당할 수 있다. 할당된 카운터 레지스터는 벡터의 적어도 하나의 좌표에 대응할 수 있다. 하나 이상의 카운터 레지스터에 대한 메모리를 생성하고 할당함으로써, 데이터 프로세싱 시스템은 카운터 레지스터를 포함하는 벡터를 생성할 수 있다. 데이터 프로세싱 시스템은 벡터의 카운터 레지스터 각각을 초기화 값(예: 0 또는 1)으로 초기화할 수 있다. 데이터 프로세싱 시스템은 임의의 수의 카운터 레지스터(때로는 "버킷"이라고도 함)를 갖도록 최소 증가 카운팅 블룸 필터에 대응할 수 있는 벡터를 생성할 수 있다. 예를 들어, 데이터 프로세싱 시스템은 n개의 버킷을 갖는 최소 증가 카운팅 블룸 필터를 생성하기 위한 표시를 수신할 수 있거나, 버킷 또는 카운터 레지스터 수에 의해 최소 증가 카운팅 블룸의 크기를 특정하는 외부 컴퓨팅 디바이스에 의해 제공되는 내부 구성 설정에 액세스할 수 있다.The data processing system may generate the vector (act 504). To create the vector, the data processing system may allocate one or more memory regions to accommodate at least one counter register. The assigned counter register may correspond to at least one coordinate of the vector. By creating and allocating memory for one or more counter registers, the data processing system can create vectors containing the counter registers. The data processing system may initialize each of the vector's counter registers to an initialization value (eg, 0 or 1). A data processing system can create a vector that can correspond to a minimum increment counting Bloom filter to have an arbitrary number of counter registers (sometimes referred to as "buckets"). For example, the data processing system may receive an indication to create a minimum increment counting bloom filter with n buckets, or by an external computing device specifying the size of the minimum increment counting bloom by number of buckets or counter registers. Provides access to internal configuration settings.
데이터 프로세싱 시스템은 k번째 데이터 레코드를 선택할 수 있다(동작 506). 생성된 최소 증가 카운팅 블룸 필터에 (동작 502)에서 유지되는 각 데이터 레코드를 프로세싱하고 추가하기 위해, 데이터 프로세싱 시스템은 데이터 프로세싱 시스템에서 유지하는 데이터 레코드 각각에 대해 반복할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 카운터 레지스터 k에 기초하여 데이터 레코드 각각을 반복적으로 루프할 수 있다. 예를 들면, 데이터 레코드 각각은 인덱스 값(예를 들어, 인덱스 0, 인덱스 1, 인덱스 2 등)에 의해 데이터 구조에서 인덱스될 수 있다. 데이터 레코드를 프로세싱하기 위해, 데이터 프로세싱 시스템은 카운터 레지스터 k와 동일한(거의 동일한) 인덱스 값을 포함하거나 그와 연관된 데이터 레코드를 선택할 수 있다. 그것이 루프의 첫 번째 반복이라면, 카운터 레지스터 k는 k번째 데이터 레코드를 선택하기 전에 초기화 값(예를 들어, k = 0, k = 1 등)으로 초기화될 수 있다. 데이터 레코드를 선택하는 것은 데이터 레코드와 연관된 데이터를 데이터 프로세싱 시스템의 컴퓨터 메모리의 다른 영역, 예를 들어 메모리의 작업 영역에 복사하는 것을 포함할 수 있다. 데이터 레코드를 선택하는 것은 데이터 레코드가 데이터베이스에 있는 경우 데이터베이스에서 데이터 레코드를 검색하고, 샘플과 연관된 데이터를 데이터 프로세싱 시스템의 다른 컴퓨터 메모리 영역(예: 메모리의 작업 영역)에 복사하는 것을 포함할 수 있다.The data processing system may select the kth data record (act 506). To process and add each data record retained in operation 502 to the generated minimum increment counting bloom filter, the data processing system may iterate for each data record maintained by the data processing system. In some implementations, the data processing system can iteratively loop through each data record based on the counter register k. For example, each data record may be indexed in the data structure by an index value (eg, index 0, index 1, index 2, etc.). To process a data record, the data processing system can select a data record that contains or is associated with the same (almost the same) index value as counter register k. If it is the first iteration of the loop, the counter register k may be initialized to an initialization value (e.g., k = 0, k = 1, etc.) prior to selecting the kth data record. Selecting the data record may include copying data associated with the data record to another area of computer memory of the data processing system, for example a working area of memory. Selecting the data record may include retrieving the data record from the database, if the data record exists in the database, and copying the data associated with the sample to another computer memory area (eg, a working area of memory) of the data processing system. .
데이터 프로세싱 시스템은 선택된 데이터 레코드를 해시할 수 있다(동작 508). 데이터 프로세싱 시스템은 최소 증가 카운팅 블룸 필터를 채우기 위해 하나 이상의 해시 함수를 식별하고 실행할 수 있다. 예를 들어, 해시 목록에서 식별된 각 해시는 입력 값에 기초하여 정규 분포 또는 임의성 기대치를 제공할 수 있다. 즉, 예를 들어 해시 함수에 대한 유사한 입력이 반드시 해시 함수와 유사한 출력을 갖는 것은 아니다. 해시 함수는 블룸 필터를 카운팅하기 위한 최적의 해시 함수로 선택할 수 있다. 예를 들어, 데이터 프로세싱 시스템은 독립적이고 균일하게 분포된 해시 함수를 선택할 수 있다. 이러한 해시 함수는 예를 들어 murmur 해시, Fowler-Noll-Vo 시리즈 해시 또는 Jenkins 해시 등을 포함할 수 있다. 데이터 프로세싱 시스템은 다수의 해시 함수를 선택하거나 식별할 수 있고, 각각의 해시 함수를 선택된 데이터 레코드에 적용하여 해시된 데이터 레코드 세트를 생성할 수 있다.The data processing system may hash the selected data record (act 508). The data processing system can identify and execute one or more hash functions to populate the minimum increment counting bloom filter. For example, each hash identified in the list of hashes can provide a normal distribution or expected randomness based on the input value. That is, for example, similar inputs to a hash function do not necessarily have similar outputs to a hash function. The hash function can be selected as the optimal hash function for counting the bloom filter. For example, the data processing system may select an independent uniformly distributed hash function. Such hash functions may include, for example, murmur hashes, Fowler-Noll-Vo series hashes, or Jenkins hashes. The data processing system may select or identify multiple hash functions and apply each hash function to the selected data records to create a set of hashed data records.
데이터 프로세싱 시스템은 레지스터 식별자를 추출할 수 있다(동작 510). 해시된 데이터 레코드 세트의 각각의 해시된 데이터 레코드는 동작 504에 의해 생성된 벡터의 카운터 레지스터에 대응할 수 있다. 대응하는 카운터 레지스터를 식별하기 위해, 데이터 프로세싱 시스템은 해시된 데이터 레코드 각각에서 레지스터 식별자를 추출할 수 있다. 데이터 프로세싱 시스템은 예를 들어 최소 증가 카운팅 블룸 필터의 카운터 레지스터의 수로 각 해시된 데이터 식별자에 대해 모듈러스 연산을 수행함으로써 레지스터 식별자를 추출할 수 있다. 예를 들어, 해시된 데이터 레코드 중 하나가 500과 같고 최소 증가 카운팅 블룸 필터에 15개의 포지션이 있는 경우, 데이터 프로세싱 시스템은 500 % 15 = 5를 계산하여 해시된 데이터 레코드가 최소 증가 카운팅 블룸 필터의 다섯 번째 카운터 레지스터에 대응하는지 결정할 수 있다. 일부 구현예에서, 최소 증가 블룸 필터의 카운터 레지스터 수가 2의 거듭 제곱이면 데이터 프로세싱 시스템은 log2(b)와 동일한 비트 수를 선택할 수 있으며, 여기서 b는 최소 증가 카운팅 블룸 필터의 카운터 레지스터의 수와 동일하다. The data processing system may extract the register identifier (act 510). Each hashed data record in the set of hashed data records may correspond to a counter register in the vector created by operation 504 . To identify the corresponding counter register, the data processing system can extract a register identifier from each hashed data record. The data processing system can extract the register identifiers, for example, by performing a modulus operation on each hashed data identifier with the number of counter registers of the least incremental counting bloom filter. For example, if one of the hashed data records is equal to 500 and there are 15 positions in the least incremental counting bloom filter, the data processing system calculates 500 % 15 = 5 so that the hashed data record is equal to 500 in the least incremental counting bloom filter. It can be determined whether it corresponds to the fifth counter register. In some implementations, the data processing system may select a number of bits equal to log2(b) if the number of counter registers in the minimum incremental bloom filter is a power of two, where b is equal to the number of counter registers in the minimum increment counting bloom filter. do.
최소 증가 블룸 필터 구현예에서, 데이터 프로세싱 시스템은 버킷 값 세트를 검색하기 위해 동작 510에 의해 추출된 레지스터 식별자들 각각과 연관된 카운터 레지스터 버킷에 추가로 액세스할 수 있다. 증가할 버킷 값을 결정하기 위해, 데이터 프로세싱 시스템은 카운터 레지스터 버킷 중 최소값과 동일한 카운터 레지스터 버킷의 서브세트를 결정할 수 있다. 최소값은 각 카운터 레지스터 버킷을 비교하고 가장 작은 버킷 값(예: 0에 가장 가까운 값)을 식별하여 결정할 수 있다. 예를 들어 각 값이 3, 91, 30, 88 및 10인 5 개의 버킷이 있는 경우 최소 버킷 값은 3이다. 하나의 버킷만 최소값과 동일한 것으로 설명되어 있지만 최소값과 동일한 버킷의 임의의 수가 있을 수 있다. 이 개념을 설명하기 위해, 다섯 개의 버킷이 각각 5, 10, 30, 5 및 28과 동일한 두 번째 예를 고려한다. 이 예에는 5와 동일한 두 개의 버킷이 있다. 모든 버킷의 최소값도 5이다. 그 후, 데이터 프로세싱 시스템은 카운터 레지스터 버킷의 서브세트에 포함시키기 위한 최소값과 동일한 버킷을 선택할 수 있다. 즉, 버킷이 각각 3, 91, 30, 88, 10과 동일한 첫 번째 예시에서, 데이터 프로세싱 시스템은 최소값인 3과 동일한 버킷을 서브세트에서 카운터 레지스터로 선택할 수 있다. 두 번째 예시에서, 5개의 버킷이 각각 5, 10, 30, 5 및 28과 동일한 경우, 데이터 프로세싱 시스템은 카운터 레지스터 버킷의 최소값인 5와 동일한 두 버킷을 모두 선택할 수 있다. 카운터 레지스터의 선택은 데이터 프로세싱 시스템의 메모리 내의 데이터 구조에서 대응하는 버킷을 식별하는 레지스터 식별자를 저장하는 것을 포함할 수 있다. 그 후, 데이터 프로세싱 시스템은 동작 512의 레지스터 식별자 서브세트 목록에 대해 반복할 수 있다. In the minimum increment bloom filter implementation, the data processing system may further access the counter register bucket associated with each of the register identifiers extracted by operation 510 to retrieve the set of bucket values. To determine the bucket value to increment, the data processing system can determine a subset of counter register buckets equal to the smallest of the counter register buckets. The minimum value can be determined by comparing each counter register bucket and identifying the smallest bucket value (i.e. closest to zero). For example, if there are 5 buckets with values 3, 91, 30, 88, and 10 each, the minimum bucket value is 3. Although only one bucket is described as being equal to the minimum, there may be any number of buckets equal to the minimum. To illustrate this concept, consider a second example where the five buckets are equal to 5, 10, 30, 5 and 28, respectively. In this example, there are two buckets equal to 5. The minimum value of all buckets is also 5. The data processing system can then select a bucket equal to the minimum value for inclusion in the subset of counter register buckets. That is, in the first example where the buckets are equal to 3, 91, 30, 88, and 10, respectively, the data processing system may select a bucket equal to the minimum value of 3 as the counter register in the subset. In the second example, if the five buckets are equal to 5, 10, 30, 5, and 28, respectively, the data processing system can select both buckets equal to 5, the minimum value of the counter register bucket. Selecting a counter register may include storing a register identifier that identifies a corresponding bucket in a data structure within a memory of the data processing system. The data processing system can then iterate over the list of register identifier subsets of operation 512 .
데이터 프로세싱 시스템은 j번째 레지스터 식별자를 선택할 수 있다(동작 512). 동작 510에서 추출된 각 레지스터 식별자를 프로세싱하고 업데이트하기 위해, 데이터 프로세싱 시스템은 각 레지스터 식별자에 대해 반복할 수 있다. 데이터 프로세싱 시스템은 카운터 레지스터 j에 기초하여 레지스터 식별자 각각을 반복적으로 루프할 수 있다. 예를 들면, 레지스터 식별자 각각은 인덱스 값(예를 들어, 인덱스 0, 인덱스 1, 인덱스 2 등)에 의해 데이터 구조에서 인덱스될 수 있다. 레지스터 식별자 및 그것의 연관된 카운터 레지스터를 프로세싱하기 위해, 데이터 프로세싱 시스템은 카운터 레지스터 j와 동일한(거의 동일한) 인덱스 값을 포함하거나 그와 연관된 레지스터 식별자를 선택할 수 있다. 그것이 루프의 첫 번째 반복이라면, 카운터 레지스터 j는 j번째 레지스터 식별자를 선택하기 전에 초기화 값(예를 들어, k = 0, k = 1 등)으로 초기화될 수 있다. 레지스터 식별자를 선택하는 것은 레지스터 식별자와 연관된 데이터를 데이터 프로세싱 시스템의 컴퓨터 메모리의 다른 영역, 예를 들어 메모리의 작업 영역에 복사하는 것을 포함할 수 있다. The data processing system may select the jth register identifier (act 512). To process and update each register identifier extracted in operation 510, the data processing system may iterate for each register identifier. The data processing system can iteratively loop through each register identifier based on the counter register j. For example, each register identifier may be indexed in the data structure by an index value (eg, index 0, index 1, index 2, etc.). To process the register identifier and its associated counter register, the data processing system can select a register identifier associated with or containing the same (almost the same) index value as counter register j. If it is the first iteration of the loop, the counter register j may be initialized to an initialization value (e.g., k = 0, k = 1, etc.) prior to selecting the jth register identifier. Selecting the register identifier may include copying data associated with the register identifier to another area of computer memory of the data processing system, for example a working area of memory.
데이터 프로세싱 시스템은 선택된 레지스터 식별자를 증가시킬 수 있다(동작 514). 레지스터 식별자를 증가시키는 것은 레지스터 식별자에 대응하는 카운터 레지스터에 하나를 추가하는 것을 포함할 수 있다. 일부 구현예에서, 카운터 레지스터에 추가되는 양은 1이 아닌 값일 수 있다. 예를 들어, 데이터 프로세싱 시스템은 여기서 결정, 생성 또는 계산된 임의의 값에 대응할 수 있는 각 카운터 레지스터에 다른 값을 추가할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 본 명세서에서 논의되는 다양한 이유로 카운터 레지스터로부터 감산될 수 있다. 일부 구현예에서, 감산에 대한 대안으로서, 데이터 프로세싱 시스템은 데이터 프로세싱 시스템에 의해 현재 선택되지 않은 다른 카운터 레지스터 버킷 각각에 양(예를 들어, 1 또는 일부 다른 값 등)을 더할 수 있다.The data processing system may increment the selected register identifier (Act 514). Incrementing the register identifier may include adding one to the counter register corresponding to the register identifier. In some implementations, the amount added to the counter register can be a non-one value. For example, the data processing system may add another value to each counter register that may correspond to any value determined, generated, or calculated herein. In some implementations, the data processing system may subtract from the counter register for various reasons discussed herein. In some implementations, as an alternative to subtraction, the data processing system can add an amount (eg, 1 or some other value, etc.) to each of the other counter register buckets not currently selected by the data processing system.
데이터 프로세싱 시스템은 카운터 레지스터 j가 레지스터 식별자의 수 m과 동일한지 여부를 결정할 수 있다(동작 516). 데이터 프로세싱 시스템이 추출된 레지스터 식별자에 대응하는 카운터 레지스터 버킷 각각을 증가 또는 업데이트했는지 여부를 결정하기 위해, 데이터 프로세싱 시스템은 각 레지스터 식별자를 선택하는데 사용된 카운터 레지스터(예: j)를 총 추출된 레지스터 식별자의 수 m과 비교할 수 있다. 카운터 레지스터 j가 총 추출된 레지스터 식별자의 수 m과 동일하지 않으면(예를 들어, 그보다 작은 경우), 데이터 프로세싱 시스템은 동작 518를 실행할 수 있다. 카운터 레지스터 j가 총 추출된 레지스터 식별자의 수 m과 같거나(예를 들어, 크거나 같으면), 데이터 프로세싱 시스템은 동작 520를 실행할 수 있다.The data processing system may determine whether the counter register j is equal to the number m of register identifiers (act 516). To determine whether the data processing system has incremented or updated each of the counter register buckets corresponding to the extracted register identifier, the data processing system calculates the total number of extracted register registers (e.g., j) used to select each register identifier. It can be compared with the number m of identifiers. If the counter register j is not equal to (eg, less than) the total number of extracted register identifiers m, the data processing system may execute operation 518 . If the counter register j is equal to (eg, greater than or equal to) the total number of extracted register identifiers m, then the data processing system can execute operation 520 .
데이터 프로세싱 시스템은 카운터 레지스터 j를 증가시킬 수 있다(동작 518). 일부 구현예에서, 데이터 프로세싱 시스템은 추출된 레지스터 식별자의 세트(예를 들어, 추출된 레지스터 식별자들의 서브세트 등)에서 다음 프로세싱되지 않은 레지스터 식별자를 나타내기 위해 레지스터 j에 하나를 추가할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 카운터 레지스터 j를 다음 프로세싱되지 않은 추출된 레지스터 식별자의 메모리 어드레스 값(예를 들어, 컴퓨터 메모리에서의 위치)으로 설정할 수 있다. 일부 구현예에서, 다음 프로세싱되지 않은 추출된 레지스터 식별자의 메모리 어드레스 값은 현재(예를 들어, 선택된) 레지스터 식별자의 위치에서 데이터 구조에 포함될 수 있다. 카운터 레지스터 j의 값을 증가시킨 후, 데이터 프로세싱 시스템은 동작 512를 실행할 수 있다.The data processing system may increment the counter register j (act 518). In some implementations, the data processing system can add one to register j to indicate the next unprocessed register identifier in the extracted set of register identifiers (eg, a subset of extracted register identifiers, etc.). In some implementations, the data processing system can set counter register j to the memory address value (eg, location in computer memory) of the next unprocessed extracted register identifier. In some implementations, the memory address value of the next unprocessed extracted register identifier may be included in the data structure at the location of the current (eg, selected) register identifier. After incrementing the value of counter register j, the data processing system can execute operation 512.
데이터 프로세싱 시스템은 카운터 레지스터 k가 데이터 레코드의 수 n과 동일한지 여부를 결정할 수 있다(동작 520). 데이터 프로세싱 시스템이 각 데이터 레코드를 사용하여 최소 증가(예: 또는 표준) 카운팅 블룸 필터를 업데이트했는지 여부를 결정하기 위해, 데이터 프로세싱 시스템은 각 데이터 레코드를 선택하는데 사용된 카운터 레지스터(예: k)를 총 데이터 레코드의 수 n과 비교할 수 있다. 카운터 레지스터 k가 총 데이터 레코드의 수 n과 동일하지 않으면(예를 들어, 그보다 작은 경우), 데이터 프로세싱 시스템은 동작 522를 실행할 수 있다. 카운터 레지스터 k가 총 데이터 레코드의 수 n과 같으면(예를 들어, 동일하거나 그보다 큰 경우), 데이터 프로세싱 시스템은 동작 524를 실행할 수 있다.The data processing system may determine whether the counter register k is equal to the number of data records n (act 520). To determine whether the data processing system has updated the least incremental (e.g. or normal) counting bloom filter with each data record, the data processing system may use the counter register (e.g. k) used to select each data record. It can be compared with the total number of data records n. If the counter register k is not equal to (eg, less than) the total number of data records n, the data processing system may execute operation 522 . If the counter register k is equal to (eg, equal to or greater than) the total number of data records n, then the data processing system can execute operation 524 .
데이터 프로세싱 시스템은 카운터 레지스터 k를 증가시킬 수 있다(동작 522). 일부 구현예에서, 데이터 프로세싱 시스템은 유지된 데이터 레코드 세트(예를 들어, 동작 502에서 데이터 프로세싱 시스템에 의해 유지되는 데이터 레코드 등)에서 다음 프로세싱되지 않은 데이터 레코드를 나타내기 위해 레지스터 k에 하나를 추가할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 카운터 레지스터 k를 다음 프로세싱되지 않은 데이터 레코드의 메모리 어드레스 값(예를 들어, 컴퓨터 메모리에서의 위치)으로 설정할 수 있다. 일부 구현예에서, 다음 프로세싱되지 않은 데이터 레코드의 메모리 어드레스 값은 현재(예를 들어, 선택된) 데이터 레코드의 위치에서 데이터 구조에 포함될 수 있다. 카운터 레지스터 k의 값을 증가시킨 후, 데이터 프로세싱 시스템은 동작 524를 실행할 수 있다.The data processing system may increment the counter register k (act 522). In some implementations, the data processing system adds one to register k to indicate the next unprocessed data record in the held data record set (e.g., the data record maintained by the data processing system in operation 502). can do. In some implementations, the data processing system can set the counter register k to the memory address value (eg, location in computer memory) of the next unprocessed data record. In some implementations, the memory address value of the next unprocessed data record may be included in the data structure at the location of the current (eg, selected) data record. After incrementing the value of counter register k, the data processing system can execute operation 524.
데이터 프로세싱 시스템은 집합된 암호화 키를 획득할 수 있다(동작 524). 예를 들어, 데이터 프로세싱 시스템은 하나 이상의 작업자 컴퓨팅 디바이스에 의해 생성된 집합된 공개 키를 수신할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 다른 컴퓨팅 디바이스(예를 들어, 다른 데이터 프로세싱 시스템, 작업자 컴퓨팅 디바이스 등)로부터 하나 이상의 공개 키를 수신하고, 공개 키를 집합된 공개 암호화 키로 집합할 수 있다. 일부 구현예에서, 집합된 키는 하나 이상의 벡터(예를 들어, 업데이트된 카운터 레지스터 버킷을 포함하는 카운팅 블룸 필터 벡터 등)를 부분적으로 또는 완전히 암호화하는데 사용될 수 있다. 일부 구현예에서, 집합된 키는 데이터 프로세싱 시스템에 의해 유지되는 카운팅 블룸 필터를 암호화하기 위해 데이터 프로세싱 시스템에 배포되는 단일 공개 키일 수 있다. 일부 구현예에서, 집합된 암호화 키는 하나 이상의 ElGamal 암호화 키, 또는 임의의 다른 유형의 동형 암호화 체계를 포함할 수 있다. 일부 구현예에서, 집합된 암호화 키는 임계 복호화 방식을 지원하는 모든 종류의 공개 암호화 키일 수 있다.The data processing system may obtain the aggregated encryption key (act 524). For example, the data processing system may receive an aggregated public key generated by one or more worker computing devices. In some implementations, the data processing system can receive one or more public keys from other computing devices (eg, other data processing systems, worker computing devices, etc.) and aggregate the public keys into an aggregated public encryption key. In some implementations, the aggregated key can be used to partially or fully encrypt one or more vectors (eg, a counting bloom filter vector comprising an updated counter register bucket, etc.). In some implementations, the aggregated key may be a single public key distributed to the data processing system to encrypt the counting bloom filter maintained by the data processing system. In some implementations, the aggregated encryption key may include one or more ElGamal encryption keys, or any other type of homomorphic encryption scheme. In some implementations, the aggregated encryption key can be any type of public encryption key that supports a criticality decryption scheme.
데이터 프로세싱 시스템은 벡터 카운터 레지스터를 암호화할 수 있다(동작 526). 최소 증가 카운팅 블룸 필터의 차등 프라이버시를 보장하기 위해, 데이터 프로세싱 시스템은 데이터 프로세싱 시스템에 의해 생성 및 유지되는 벡터를 암호화하기 위해 하나 이상의 암호화 기법을 사용할 수 있다. 예를 들어, 데이터 프로세싱 시스템은 암호화 체계(예를 들어, ElGamal 암호화, 임계값 복호화를 지원하는 암호화 체계, 동형 암호화 등)을 사용하여 동작 526에서 획득된 집합된 공개 키를 사용할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 집합된 암호화 키를 사용하여 개별적으로 벡터의 좌표에 대응하는 카운터 레지스터들 각각을 암호화할 수 있다. 이러한 구현예에서, 암호화된 카운터 레지스터 각각은 최소 증가 계수 블룸 필터를 나타내는 암호화된 벡터를 생성하기 위해 집합될 수 있다. The data processing system may encrypt the vector counter register (act 526). To ensure differential privacy of the minimum increment counting bloom filter, the data processing system may use one or more encryption techniques to encrypt the vectors generated and maintained by the data processing system. For example, the data processing system may use the aggregated public key obtained at operation 526 using an encryption scheme (eg, ElGamal encryption, an encryption scheme supporting threshold decryption, homomorphic encryption, etc.). In some implementations, the data processing system can encrypt each of the counter registers individually corresponding to the vector's coordinates using the aggregated encryption key. In such an implementation, each of the encrypted counter registers can be aggregated to create an encrypted vector representing a minimum increment factor bloom filter.
데이터 프로세싱 시스템은 암호화된 벡터를 전송할 수 있다(동작 528). 암호화된 벡터를 전송하는 것은 작업자 컴퓨팅 디바이스에 암호화된 벡터를 제공하는 것을 포함할 수 있다. 데이터 프로세싱 시스템은 암호화된 벡터를 프로세싱하기 위해 하나 이상의 작업자 컴퓨팅 디바이스 중 첫 번째로 작업자 컴퓨팅 디바이스를 선택할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 암호화된 벡터를 버킷 단위로 전송할 수 있으며, 여기서 각 버킷은 작업자 컴퓨팅 디바이스에 개별적으로 전송된다. 일부 구현예에서, 데이터 프로세싱 시스템은 암호화된 벡터를 대량 트랜잭션으로 전송할 수 있으며, 여기서 암호화된 벡터의 대부분 또는 전체가 단일 메시지로 전송된다. The data processing system may transmit the encrypted vector (act 528). Sending the encrypted vector may include providing the encrypted vector to a worker computing device. The data processing system can select a first of the one or more worker computing devices to process the encrypted vector. In some implementations, the data processing system can transmit the encrypted vector in buckets, where each bucket is sent individually to the worker computing device. In some implementations, the data processing system can send encrypted vectors in bulk transactions, where most or all of the encrypted vectors are sent in a single message.
이제 도 6을 참조하면, 도시된 것은 작업자 컴퓨팅 디바이스에 의해 암호화된 벡터를 프로세싱하기 위해 암호화 키를 생성 및 집합하는 방법(600)의 흐름도이다. 방법(600)은 예를 들어, 적어도 하나의 데이터 프로세싱 시스템(예를 들어, 적어도 하나의 데이터 프로세싱 시스템(105) 등) 또는 여기에 설명된 임의의 다른 컴퓨팅 디바이스에 의해 수행될 수 있다. 데이터 프로세싱 시스템은 결합된 키를 생성할 수 있다(동작 602). 데이터 프로세싱 시스템은 결합된 키를 식별자 서버로 전송할 수 있다(동작 604). 데이터 프로세싱 시스템은 암호화된 벡터를 수신할 수 있다(동작 606). 데이터 프로세싱 시스템은 k번째 암호화된 벡터를 선택할 수 있다(동작 608). 데이터 프로세싱 시스템은 동형 암호화로 합계를 계산할 수 있다(동작 610). 데이터 프로세싱 시스템은 카운터 레지스터 k가 암호화된 벡터의 수 n과 동일한지 여부를 결정할 수 있다(동작 612). 데이터 프로세싱 시스템은 암호화된 벡터에 디코딩 룩업 테이블을 첨부할 수 있다(동작 614). 데이터 프로세싱 시스템은 디코딩 룩업 테이블을 첨부할 수 있다(동작 616). 데이터 프로세싱 시스템은 암호화된 벡터를 부분적으로 복호화할 수 있다(동작 618). 데이터 프로세싱 시스템은 결정론적 암호화를 적용할 수 있다(동작 620). 데이터 프로세싱 시스템은 암호화된 벡터를 셔플할 수 있다(동작 622). 데이터 프로세싱 시스템은 프로세싱된 암호화된 벡터를 제2 작업자에게 포워딩할 수 있다(동작 624).Referring now to FIG. 6 , shown is a flow diagram of a method 600 of generating and aggregating encryption keys for processing encrypted vectors by a worker computing device. Method 600 may be performed by, for example, at least one data processing system (eg, at least one data processing system 105 , etc.) or any other computing device described herein. The data processing system may generate the combined key (act 602). The data processing system may transmit the combined key to the identifier server (act 604). The data processing system may receive the encrypted vector (act 606). The data processing system may select the kth encrypted vector (act 608). The data processing system may compute the sum with homomorphic encryption (act 610). The data processing system may determine whether the counter register k is equal to the number n of encrypted vectors (act 612). The data processing system may append a decode lookup table to the encrypted vector (act 614). The data processing system can append the decoding lookup table (act 616). The data processing system may partially decrypt the encrypted vector (act 618). The data processing system may apply deterministic encryption (act 620). The data processing system may shuffle the encrypted vector (act 622). The data processing system may forward the processed encrypted vector to the second worker (act 624).
데이터 프로세싱 시스템은 결합된 키를 생성할 수 있다(동작 602). 결합된 키를 생성하는 것은 적어도 하나의 공개 키와 적어도 하나의 개인 키를 생성하는 것을 포함할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 적어도 ElGamal 암호화 기법의 일부로서 구현될 수 있는 키를 생성할 수 있다. 예를 들어, 데이터 프로세싱 시스템은 랜덤(예를 들어, 의사 랜덤 등) 정수 X modulo q(예를 들어, 타원 곡선 그룹의 순서)를 생성하거나 선택할 수 있다. 데이터 프로세싱 시스템은 정수 X를 복호화를 위한 개인 키로 사용할 수 있고, gX를 공개 키로 사용할 수 있으며, 여기서 g는 생성기이다. 예를 들어 생성기는 순환 그룹의 멤버일 수 있다. 공개 키는 예를 들어 하나 이상의 다른 작업자 컴퓨팅 디바이스와 공유될 수 있다. 다른 작업자 컴퓨팅 디바이스는 자신의 공개 및 개인 키 쌍을 생성하여 데이터 프로세싱 시스템에 전송할 수 있다. 결합된 키를 생성하기 위해, 데이터 프로세싱 시스템은 다른 작업자 컴퓨팅 디바이스로부터 수신된 각 공개 키를 자신의 공개 키와 결합할 수 있다.The data processing system may generate the combined key (act 602). Generating the combined key may include generating at least one public key and at least one private key. In some implementations, the data processing system can generate a key that can be implemented at least as part of an ElGamal cryptographic technique. For example, the data processing system may generate or select a random (eg, pseudorandom, etc.) integer X modulo q (eg, the order of a group of elliptic curves). The data processing system can use integer X as the private key for decryption and gX as the public key, where g is the generator. For example, a generator can be a member of a recursive group. The public key may be shared with one or more other worker computing devices, for example. Other worker computing devices can generate their public and private key pairs and send them to the data processing system. To generate a combined key, the data processing system can combine each public key received from other worker computing devices with its own public key.
데이터 프로세싱 시스템은 결합된 키를 식별자 서버로 전송할 수 있다(동작 604). 식별자 서버는 예를 들어, 도 5와 관련하여 위에서 설명한 방법(500)을 실행하는 데이터 프로세싱 시스템일 수 있다. 식별자 서버는 도 1과 관련하여 위에서 설명된 데이터 프로세싱 시스템(105A-N)일 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 동작 602에서 생성된 결합된 키의 각 공개 키를 한 번에 하나씩 전송할 수 있으며, 여기서 공개 키 각각은 단일 메시지를 차지한다. 일부 구현예에서, 데이터 프로세싱 시스템은 단일 메시지의 결합된 키를 식별자 서버(예를 들어, 단일 패킷, 단일 트랜잭션 또는 일련의 패킷 등)에 전송할 수 있다. The data processing system may transmit the combined key to the identifier server (act 604). The identifier server may be, for example, a data processing system that executes method 500 described above with respect to FIG. 5 . The identifier server may be the data processing systems 105A-N described above with respect to FIG. In some implementations, the data processing system can transmit each public key of the combined key generated in operation 602 one at a time, where each public key occupies a single message. In some implementations, the data processing system may send the combined key in a single message to the identifier server (eg, a single packet, single transaction, or series of packets, etc.).
데이터 프로세싱 시스템은 암호화된 벡터를 수신할 수 있다(동작 606). 식별자 서버에 의해 암호화를 위해 결합된 키를 전송한 후, 데이터 프로세싱 시스템은 식별자 서버 각각으로부터 적어도 하나의 암호화된 벡터를 수신할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 벡터를 주기적으로 또는 버스트 트랜잭션으로 수신할 수 있다. 각 벡터는 벡터가 수신되었던 식별자 서버를 반영하는 각각의 식별자와 연관될 수 있다. 식별자 서버로부터 수신된 각각의 암호화된 벡터는 동작 602에서 생성된 결합된 공개 키를 사용하여 암호화될 수 있다. 결합된 공개 키는 각 작업자가 식별자 서버로부터 수신된 암호화된 벡터를 부분적으로 복호화하게 할 수 있다. The data processing system may receive the encrypted vector (act 606). After transmitting the combined keys for encryption by the identifier server, the data processing system may receive at least one encrypted vector from each identifier server. In some implementations, the data processing system can receive the vectors periodically or in burst transactions. Each vector may be associated with a respective identifier reflecting the identifier server from which the vector was received. Each encrypted vector received from the identifier server may be encrypted using the combined public key generated in operation 602. The combined public key allows each worker to partially decrypt the encrypted vector received from the identifier server.
데이터 프로세싱 시스템은 k번째 암호화된 벡터를 선택할 수 있다(동작 608). 동형 추가를 사용하여 동작 606에서 수신된 각 암호화된 벡터를 프로세싱하고 집합하기 위해, 데이터 프로세싱 시스템은 데이터 프로세싱 시스템에서 수신된 각 암호화된 벡터에 대해 반복할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 카운터 레지스터 k에 기초하여 암호화된 벡터 각각을 반복적으로 루프할 수 있다. 암호화된 벡터 각각은 인덱스 값(예를 들어, 인덱스 0, 인덱스 1, 인덱스 2 등)에 의해 데이터 구조에서 인덱스될 수 있다. 암호화된 벡터를 프로세싱하기 위해, 데이터 프로세싱 시스템은 카운터 레지스터 k와 동일한(거의 동일한) 인덱스 값을 포함하거나 그와 연관된 암호화된 벡터를 선택할 수 있다. 그것이 루프의 첫 번째 반복이라면, 카운터 레지스터 k는 k번째 암호화된 벡터를 선택하기 전에 초기화 값(예를 들어, k = 0, k = 1 등)으로 초기화될 수 있다. 암호화된 벡터를 선택하는 것은 암호화된 벡터와 연관된 데이터를 데이터 프로세싱 시스템의 컴퓨터 메모리의 다른 영역, 예를 들어 메모리의 작업 영역에 복사하는 것을 포함할 수 있다. The data processing system may select the kth encrypted vector (act 608). To process and aggregate each encrypted vector received at operation 606 using homomorphic addition, the data processing system may iterate over each encrypted vector received at the data processing system. In some implementations, the data processing system can iteratively loop through each encrypted vector based on the counter register k. Each encrypted vector may be indexed in the data structure by an index value (eg, index 0, index 1, index 2, etc.). To process the encrypted vector, the data processing system can select an encrypted vector that contains or is associated with the same (almost the same) index value as the counter register k. If it is the first iteration of the loop, the counter register k may be initialized to an initialization value (e.g., k = 0, k = 1, etc.) prior to selecting the kth encrypted vector. Selecting the encrypted vector may include copying data associated with the encrypted vector to another area of computer memory of the data processing system, for example a working area of memory.
데이터 프로세싱 시스템은 동형 추가를 사용하여 암호화된 벡터의 합계를 계산할 수 있다(동작 610). 데이터 프로세싱 시스템은 암호화된 벡터 각각을 집합 암호화된 벡터로 누적, 추가 또는 집합할 수 있다. 집합 암호화된 벡터는 예를 들어, 식별자 서버에 의해 업데이트된 각 암호화된 카운터 레지스터 버킷의 집합된 총합을 포함할 수 있다. 식별자 서버는 각각 최소 증가 카운팅 블룸 필터를 유지하고 업데이트하여 각 식별자 서버와 연관된 디바이스의 수 및 속성을 나타낸다. 동형 암호화를 사용하여 서버를 암호화함으로써 각 식별자 서버는 서버와 연관된 디바이스 수 또는 속성 유형에 대한 정보나 데이터를 숨길 수 있다. 이 단계에서, 데이터 프로세싱 시스템(예를 들어, 작업자 컴퓨팅 디바이스 등)은 암호화된 벡터 각각을 집합하여, 모든 식별자 서버에 걸쳐 디바이스의 총 수 및 속성을 나타내는 집합된 벡터를 생성할 수 있다. 동형 추가를 사용함으로써, 데이터 프로세싱 시스템은 집합 전에 암호화된 벡터를 복호화할 필요가 없으므로 시스템의 차등 프라이버시를 보존할 수 있다. 동형 추가를 수행하기 위해, 데이터 프로세싱 시스템은 선택한 암호화된 벡터를 누산기 벡터에 동형 추가할 수 있다. 루프의 첫 번째 반복(예: k가 초기화 값과 같음 등)이면, 데이터 프로세싱 시스템은 선택된 벡터를 누산기 암호화 벡터로 저장할 수 있다. 루프의 첫 번째 반복이 아닌 경우, 데이터 프로세싱 시스템은 선택된 벡터와 누산기 벡터간에 동형 추가를 수행하고, 동형 추가의 결과를 누산기 벡터로 저장할 수 있다. The data processing system may compute the sum of the encrypted vectors using homomorphic addition (act 610). The data processing system may accumulate, add or aggregate each of the encrypted vectors into a set encrypted vector. The aggregated encrypted vector may include, for example, the aggregated sum of each encrypted counter register bucket updated by the identifier server. The identifier server maintains and updates each minimum increment counting bloom filter to indicate the number and attributes of devices associated with each identifier server. By encrypting servers using homomorphic encryption, each identifier server can hide information or data about the number of devices or attribute types associated with the server. At this stage, the data processing system (eg, worker computing device, etc.) may aggregate each encrypted vector to produce an aggregated vector representing the total number and attributes of devices across all identifier servers. By using homomorphic addition, the data processing system does not need to decrypt the encrypted vectors prior to aggregation, thus preserving the differential privacy of the system. To perform homomorphic addition, the data processing system can homomorphically add the selected encrypted vector to the accumulator vector. On the first iteration of the loop (eg k equals the initialization value, etc.), the data processing system can store the selected vector as the accumulator encryption vector. For non-first iterations of the loop, the data processing system may perform isomorphic addition between the selected vector and the accumulator vector, and store the result of the isomorphic addition into the accumulator vector.
데이터 프로세싱 시스템은 카운터 레지스터 k가 암호화된 벡터의 수 n과 동일한지 여부를 결정할 수 있다(동작 612). 데이터 프로세싱 시스템이 각각의 암호화된 벡터를 동형적으로 추가했는지 여부를 결정하기 위해, 데이터 프로세싱 시스템은 각 데이터 레코드를 선택하는데 사용되는 카운터 레지스터(예를 들어, k)를 총 암호화된 벡터의 수 n과 비교할 수 있다. 카운터 레지스터 k가 총 암호화된 벡터의 수 n과 동일하지 않으면(예를 들어, 그보다 작은 경우), 데이터 프로세싱 시스템은 동작 614를 실행할 수 있다. 카운터 레지스터 k가 총 암호화된 벡터의 수 n과 같으면(예를 들어, 동일하거나 그보다 큰 경우), 데이터 프로세싱 시스템은 동작 616를 실행할 수 있다. 암호화된 벡터를 모두 추가한 후, 데이터 프로세싱 시스템은 누산기 벡터를 컴퓨터 메모리의 다른 영역에 복사하여, 누적된 또는 집합된 암호화된 벡터를 생성할 수 있다.The data processing system may determine whether the counter register k is equal to the number n of encrypted vectors (act 612). To determine whether the data processing system has added each encrypted vector isomorphically, the data processing system assigns a counter register (e.g., k) used to select each data record to the total number of encrypted vectors, n. can be compared with If the counter register k is not equal to (eg, less than) the total number of encrypted vectors n, then the data processing system can execute operation 614 . If the counter register k is equal to (eg, equal to or greater than) the total number of encrypted vectors n, then the data processing system can execute operation 616 . After adding all the encrypted vectors, the data processing system can copy the accumulator vector to another area of computer memory to create an accumulated or aggregated encrypted vector.
데이터 프로세싱 시스템은 암호화된 벡터에 디코딩 룩업 테이블을 첨부할 수 있다(동작 614). 일부 구현예에서, 데이터 프로세싱 시스템은 암호화된 벡터 세트(예를 들어, 동작 606에서 데이터 프로세싱 시스템에 의해 암호화된 벡터 등)에서 다음 프로세싱되지 않은 암호화된 벡터를 나타내기 위해 레지스터 k에 하나를 추가할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 카운터 레지스터 k를 다음 프로세싱되지 않은 암호화된 벡터의 메모리 어드레스 값(예를 들어, 컴퓨터 메모리에서의 위치)으로 설정할 수 있다. 일부 구현예에서, 다음 프로세싱되지 않은 암호화된 벡터의 메모리 어드레스 값은 현재(예를 들어, 선택된) 암호화된 벡터의 위치에서 데이터 구조에 포함될 수 있다. 카운터 레지스터 k의 값을 증가시킨 후, 데이터 프로세싱 시스템은 동작 608를 실행할 수 있다.The data processing system may append a decode lookup table to the encrypted vector (act 614). In some implementations, the data processing system may add one to register k to indicate the next unprocessed encrypted vector in the set of encrypted vectors (e.g., vectors encrypted by the data processing system at operation 606, etc.). can In some implementations, the data processing system can set the counter register k to the memory address value (eg, location in computer memory) of the next unprocessed encrypted vector. In some implementations, the memory address value of the next unprocessed encrypted vector may be included in the data structure at the location of the current (eg, selected) encrypted vector. After incrementing the value of counter register k, the data processing system can execute operation 608.
데이터 프로세싱 시스템은 암호화된 벡터 버킷을 부분적으로 복호화할 수 있다(동작 616). 집합되거나 누적된 암호화된 벡터의 각 버킷을 결정론적으로 암호화하기 위해, 데이터 프로세싱 시스템은 데이터 프로세싱 시스템에 대응하는 값을 부분적으로 복호화할 수 있다. 예를 들어, 집합된 암호화된 벡터의 특정 버킷은 데이터 프로세싱 시스템에 의해 유지되는 하나 이상의 키를 사용하여 복호화될 수 있다. 예를 들어, 하나 이상의 키는 동작 602의 데이터 프로세싱 시스템에 의해 생성된 비밀 키를 포함할 수 있다. 예를 들어, 동작 602에서, 데이터 프로세싱 시스템은 공개 키와 개인 키를 생성하고 데이터 프로세싱 시스템과 통신하는 다른 작업자 컴퓨팅 디바이스와 공개 키를 교환한다. 결합된 키를 생성하기 위해, 데이터 프로세싱 시스템은 개인 키를 연결, 집합 또는 결합할 수 있다. ElGamal 또는 동형 암호화 키의 특성으로 인해, 데이터 프로세싱 시스템은 집합된 공개 키를 사용하여 암호화된 임의의 값을 부분적으로 복호화할 수 있다. 분산된 동형 암호화 체계를 사용하는 부분 복호화만을 허용함으로써, 방법(600)은 식별자 서버에 의해 생성된 벡터의 차등 프라이버시를 보존할 수 있다. The data processing system may partially decrypt the encrypted vector bucket (act 616). To deterministically encrypt each bucket of the aggregated or accumulated encrypted vector, the data processing system can partially decrypt the value corresponding to the data processing system. For example, a particular bucket of aggregated encrypted vectors may be decrypted using one or more keys maintained by the data processing system. For example, the one or more keys may include a secret key generated by the data processing system of operation 602. For example, at operation 602, the data processing system generates public and private keys and exchanges the public keys with other worker computing devices that communicate with the data processing system. To create a combined key, the data processing system may concatenate, aggregate, or combine private keys. Due to the nature of ElGamal or homomorphic encryption keys, a data processing system can partially decrypt any value encrypted using the aggregated public key. By allowing only partial decryption using a distributed homomorphic encryption scheme, method 600 can preserve the differential privacy of the vectors generated by the identifier server.
데이터 프로세싱 시스템은 결정론적 암호화를 적용할 수 있다(동작 618). 결정론적 암호화는 예를 들어 동작 616의 데이터 프로세싱 시스템에 의해 생성된 부분적으로 복호화된 값에 적용될 수 있다. 결정론적 암호화는 데이터 프로세싱 시스템에만 알려진 비밀 키를 적용하여 달성될 수 있다. 예를 들어, 데이터 프로세싱 시스템은 동작 616에서 생성된 부분적으로 복호화된 모든 버킷에 비밀 지수를 적용할 수 있다. 이 동작은 동형(homomorphism)(예: 생성기 g를 임의의 그룹 엘리먼트 등으로 변경하는 것과 동일)을 통해 수행할 수 있다. 비밀 키는 특정 임계 값을 만족하는 값만 암호화하거나 복호화할 수 있는 임계 비밀 키일 수 있다. 이러한 방식으로 데이터 프로세싱 시스템은 시스템의 전반적인 프라이버시 및 보안을 유지할 수 있다. 비밀 키는 결정론적 암호화의 결과를 디코딩하는데 사용될 수 있는 룩업 테이블 또는 모든 작업자 컴퓨팅 디바이스에서 집합된 결정론적 암호화와 연관될 수 있다.The data processing system may apply deterministic encryption (act 618). Deterministic encryption may be applied to the partially decrypted value generated by the data processing system of operation 616, for example. Deterministic encryption can be achieved by applying a secret key known only to the data processing system. For example, the data processing system may apply a secret index to all partially decrypted buckets created in operation 616. This operation can be done through homomorphism (e.g. equivalent to changing the generator g to an arbitrary group element, etc.). The secret key may be a threshold secret key capable of encrypting or decrypting only values satisfying a specific threshold value. In this way, the data processing system can maintain the overall privacy and security of the system. The secret key may be associated with the deterministic encryption aggregated at all worker computing devices or a lookup table that may be used to decode the result of the deterministic encryption.
데이터 프로세싱 시스템은 디코딩 룩업 테이블을 첨부할 수 있다(동작 620). 디코딩 룩업 테이블은 동작 616에서 부분적으로 복호화된 결정론적으로 암호화된 벡터에 첨부될 수 있다. 디코딩 룩업 테이블은 예를 들어, 모든 작업자 컴퓨팅 디바이스에 걸쳐 분산 결정론적 암호화 체계의 최종 출력을 디코딩하는데 사용될 수 있다. 결정론적 암호화 체계와 값의 부분적인 복호화를 사용하여, 데이터 프로세싱 시스템은 시스템의 차등 프라이버시를 보존하고, 최소 증가 블룸 필터에서 식별자 서버에 의해 표시되는 임의의 개인 또는 보호된 데이터를 보호할 수 있다. 디코딩 룩업 테이블을 첨부하는 것은 예를 들어 룩업 테이블을 결정론적으로 암호화되고 부분적으로 복호화된 벡터에 연결하는 것을 포함할 수 있다. 룩업 테이블은 복호화에 대한 작업자 기여만 복호화할 수 있으므로, 작업자 컴퓨팅 디바이스의 서브세트는 데이터 세트를 완전히 복호화할 수 없다. 임계 암호화를 사용함으로써 시스템의 보안이 더욱 향상되며, 임계치를 만족하는 값만 복호화하여 작업자 컴퓨팅 디바이스에 제공한다. 암호화된 벡터 버킷을 셔플링하기 전에, 데이터 프로세싱 시스템은 도 7에서 아래에 설명된 방법(700)에 요약된 프로세스를 사용하여 벡터에 노이즈 값을 첨부할 수 있다.The data processing system can append the decoding lookup table (act 620). A decode lookup table can be appended to the partially decrypted deterministically encrypted vector in operation 616 . The decoding lookup table can be used, for example, to decode the final output of a distributed deterministic encryption scheme across all worker computing devices. Using deterministic encryption schemes and partial decryption of values, the data processing system can preserve the differential privacy of the system and protect any personal or protected data presented by the identifier server in a minimal incremental bloom filter. Appending the decode lookup table may include concatenating the lookup table to the deterministically encrypted and partially decrypted vector, for example. Because the lookup table can only decrypt worker contributions to decryption, a subset of worker computing devices cannot fully decrypt the data set. Security of the system is further improved by using threshold encryption, and only values satisfying the threshold are decrypted and provided to the worker computing device. Prior to shuffling the encrypted vector buckets, the data processing system may append a noise value to the vectors using the process outlined in method 700 described below in FIG. 7 .
데이터 프로세싱 시스템은 암호화된 벡터 버킷을 셔플링할 수 있다(동작 622). 암호화된 벡터 버킷 셔플은 벡터 버킷을 무작위로 순열하는 것을 포함할 수 있다. 예를 들어, 데이터 프로세싱 시스템은 암호화된 벡터의 각 버킷에 액세스하고 랜덤(예: 의사 랜덤 등) 방식으로 순서를 변경할 수 있다. 데이터 프로세싱 시스템은 다른 컴퓨팅 디바이스가 순열된 버킷의 순열 순서를 알거나 결정할 수 없도록 비밀리에 버킷을 셔플링하거나 순열할 수 있다. 암호화된 벡터의 순열 또는 셔플링은 암호화된 벡터에 첨부된 룩업 테이블의 순서를 셔플하는 것은 포함하지 않는다. 이렇게 하면 암호화된 벡터 값의 최종 결정이 룩업 테이블을 사용하여 계산될 수 있다.The data processing system may shuffle the encrypted vector buckets (act 622). Encrypted vector bucket shuffling may include randomly permuting the vector buckets. For example, a data processing system can access each bucket of encrypted vectors and change their order in a random (eg, pseudo-random, etc.) fashion. The data processing system may shuffle or permutate the buckets secretly so that other computing devices cannot know or determine the permutation order of the permuted buckets. Permutation or shuffling of encrypted vectors does not include shuffling the order of lookup tables appended to encrypted vectors. This allows the final determination of the encrypted vector values to be computed using the lookup table.
데이터 프로세싱 시스템은 프로세싱된 암호화된 벡터를 제2 작업자에게 포워딩할 수 있다(동작 624). 전체 벡터를 완전히 프로세싱하고 결정적으로 암호화하기 위해, 암호화된 벡터는 동작 602에서 생성된 결합된 키에 기여한 각 작업자 컴퓨팅 디바이스에 의해 프로세싱될 수 있다. 결합된 키 값은 각 작업자 컴퓨팅 디바이스(및 데이터 프로세싱 시스템 포함)에 의해 생성된 각 공개 키로 포함한다. 암호화 체계가 동형이기 때문에, 작업자의 각 개인 키는 동형 방식을 사용하여 결합된 집합된 암호화 벡터를 부분적으로 복호화할 수 있지만, 작업자 컴퓨팅 디바이스는 벡터를 완전히 복호화할 수 없다. 이를 통해 각 작업자 컴퓨팅 디바이스는 부분적으로 복호화된 값을 결정론적으로 암호화하고 다음 작업자 디바이스로 포워딩할 수 있다. 작업자 디바이스가 부분 복호화에 기초하여 벡터를 결정론적으로 암호화한 후 결과를 집합하고 암호화된 벡터에 첨부된 룩업 테이블을 사용하여 최종 결과를 계산할 수 있다.The data processing system may forward the processed encrypted vector to the second worker (act 624). To fully process and deterministically encrypt the entire vector, the encrypted vector may be processed by each worker computing device that contributed to the combined key generated in operation 602 . The combined key value includes with each public key generated by each worker computing device (and data processing system included). Because the cryptographic scheme is isomorphic, each private key of the worker can partially decrypt the aggregated cryptographic vector combined using an isomorphic scheme, but the worker computing device cannot fully decrypt the vector. This allows each worker computing device to deterministically encrypt the partially decrypted value and forward it to the next worker device. After the worker device deterministically encrypts the vector based on partial decryption, it can aggregate the results and calculate the final result using a lookup table attached to the encrypted vector.
이제 도 7을 참조하면, 도시된 것은 작업자 컴퓨팅 디바이스들 사이에 차등 프라이버시를 제공하기 위해 노이즈를 암호화된 집합된 벡터에 통합하는 방법(700)의 흐름도이다. 방법(700)은 예를 들어, 적어도 하나의 데이터 프로세싱 시스템(예를 들어, 적어도 하나의 데이터 프로세싱 시스템(105) 등) 또는 여기에 설명된 임의의 다른 컴퓨팅 디바이스에 의해 수행될 수 있다. 데이터 프로세싱 시스템은 노이즈 기준 B에 동의할 수 있다(동작 702). 데이터 프로세싱 시스템은 랜덤 변수의 수를 생성할 수 있다(동작 704). 데이터 프로세싱 시스템은 노이즈 어레이를 생성할 수 있다(동작 706). 데이터 프로세싱 시스템은 k번째 노이즈 어레이 값을 선택할 수 있다(동작 708). 데이터 프로세싱 시스템은 랜덤 변수를 사용하여 노이즈 배열을 채울 수 있다(동작 710). 데이터 프로세싱 시스템은 k가 노이즈 어레이 값의 수 n과 동일한지 여부를 결정할 수 있다(동작 712). 데이터 프로세싱 시스템은 카운터 레지스터 k를 증가시킬 수 있다(동작 714). 데이터 프로세싱 시스템은 노이즈 어레이를 셔플링할 수 있다(동작 716). 데이터 프로세싱 시스템은 노이즈 어레이를 암호화할 수 있다(동작 718). 데이터 프로세싱 시스템은 부분 복호화 전에 암호화된 벡터에 노이즈를 첨부할 수 있다(동작 720). Referring now to FIG. 7 , shown is a flow diagram of a method 700 of integrating noise into an encrypted aggregated vector to provide differential privacy between worker computing devices. Method 700 may be performed by, for example, at least one data processing system (eg, at least one data processing system 105 , etc.) or any other computing device described herein. The data processing system may agree on noise criterion B (act 702). The data processing system may generate a number of random variables (act 704). The data processing system may generate a noise array (act 706). The data processing system may select the kth noise array value (act 708). The data processing system may populate the noise array using random variables (act 710). The data processing system may determine whether k is equal to n, the number of noise array values (act 712). The data processing system may increment the counter register k (Act 714). The data processing system may shuffle the noise array (act 716). The data processing system may encrypt the noise array (act 718). The data processing system may append noise to the encrypted vector prior to partial decryption (act 720).
데이터 프로세싱 시스템은 노이즈 기준 B에 동의할 수 있다(동작 702). 노이즈 기준은 예를 들어 개별 작업자 컴퓨팅 디바이스(예를 들어, 데이터 프로세싱 시스템, 다른 데이터 프로세싱 시스템 등)에 의해 생성된 임의의 음의 노이즈 값보다 클 수 있는 정수일 수 있다. 예를 들어, 데이터 프로세싱 시스템은 임의의 생성된 노이즈가 임계치를 초과하지 않거나 초과할 수 없도록 노이즈 계산에 대한 특정 임계치를 사용할 수 있다. 노이즈 기준은 기준 값(예: 정수 값 등)에 더하거나 빼는 노이즈가 음수가 되지 않도록 구성될 수 있다. 기준 노이즈 값에 동의하기 위해, 각 작업자 컴퓨팅 디바이스는 각 작업자가 기준 노이즈 값이 음수 값이 되지 않는다 것이 만족될 때까지 생성된 기준 값을 교환할 수 있다. 작업자 컴퓨팅 디바이스가 기준 노이즈 값에 동의하면, 작업자 컴퓨팅 디바이스는 기준 노이즈 값과 함께 동의 메시지를 다른 컴퓨팅 디바이스에 브로드캐스트할 수 있다. 각 작업자 컴퓨팅 디바이스에서 동의 메시지가 수신되면, 그 디바이스는 기준 노이즈 값에 동의한 것이다.The data processing system may agree on noise criterion B (act 702). The noise criterion may be, for example, an integer number that may be greater than any negative noise value generated by an individual worker computing device (eg, data processing system, other data processing system, etc.). For example, the data processing system may use a specific threshold for noise calculation such that any generated noise does not or cannot exceed the threshold. A noise criterion may be configured such that noise added to or subtracted from a reference value (eg, an integer value, etc.) is non-negative. To agree on a reference noise value, each worker computing device may exchange the generated reference value until each worker is satisfied that the reference noise value does not become a negative value. If the worker computing device agrees on the reference noise value, the worker computing device can broadcast an agreement message to the other computing devices along with the reference noise value. When an agreement message is received at each worker computing device, the device agrees on the reference noise value.
데이터 프로세싱 시스템은 랜덤 변수의 수를 생성할 수 있다(동작 704). 랜덤 변수의 수는 예를 들어 시스템에 의해 측정될 최대 원하는 빈도(예: K+ 빈도 등)에 1을 더한 값일 수 있다. 이는 max_frequency + 1로 지정될 수 있다. 랜덤 변수는 모든 종류의 랜덤 변수일 수 있다(예: Polya 랜덤 변수 등). 랜덤 변수는 랜덤 변수 세트로 생성될 수 있다. 예를 들어, 랜덤 변수 세트는 [X0, X1, X2,…, Xi,…, Xmf]로 구성될 수 있고, 여기서 Xi는 세트의 인덱스 값(예: 랜덤 변수 세트의 Xi)을 표시하며, Xmf는 시스템에 의해 측정될 최대 빈도를 표시한다. The data processing system may generate a number of random variables (act 704). The number of random variables may be, for example, the maximum desired frequency to be measured by the system (eg, K+ frequency, etc.) plus one. This can be specified as max_frequency + 1. The random variable can be any kind of random variable (eg Polya random variable, etc.). A random variable can be created as a set of random variables. For example, the set of random variables is [X 0 , X 1 , X 2 ,… , X i , . . . , X mf ], where Xi denotes the index value of the set (eg X i of the set of random variables), and X mf denotes the maximum frequency to be measured by the system.
데이터 프로세싱 시스템은 노이즈 어레이를 생성할 수 있다(동작 706). 데이터 프로세싱 시스템은 특정 크기의 노이즈 어레이를 할당할 수 있다. 노이즈 어레이의 크기는 예를 들어 동작 704에서 생성된 랜덤 변수 세트의 각 Xi에 대한 Σ(B - X i ) 일 수 있다. 데이터 프로세싱 시스템은 예를 들어 각 랜덤 변수와 기준 노이즈 값의 차이를 계산하고 각 차이를 누적하여 기준의 총합에서 랜덤 변수를 뺀 값을 결정할 수 있다. 노이즈 어레이의 총 크기는 차이의 합과 같을 수 있다. 노이즈 어레이를 생성하는 것은 노이즈 어레이의 크기와 동일한 메모리 영역을 할당하는 것을 포함할 수 있다. The data processing system may generate a noise array (act 706). The data processing system may allocate a noise array of a particular size. The size of the noise array may be, for example, Σ( B - X i ) for each X i of the random variable set generated in operation 704 . The data processing system may, for example, calculate the difference between each random variable and the reference noise value and accumulate each difference to determine the sum of the criteria minus the random variable. The total size of the noise array may be equal to the sum of the differences. Creating the noise array may include allocating a memory region equal to the size of the noise array.
데이터 프로세싱 시스템은 k번째 노이즈 어레이 값을 선택할 수 있다(동작 708). 동작 704에서 생성된 각 랜덤 변수에 기초하여 노이즈 어레이를 채우기 위해, 데이터 프로세싱 시스템은 각 노이즈 어레이 값(예를 들어, 동작 704에서 생성된 각 랜덤 변수 등)에 대해 반복할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 카운터 레지스터 k에 기초하여 노이즈 값 각각을 반복적으로 루프할 수 있다. 노이즈 값 각각은 인덱스 값(예를 들어, 인덱스 0, 인덱스 1, 인덱스 2 등)에 의해 데이터 구조에서 인덱스될 수 있다. 노이즈 값을 프로세싱하기 위해, 데이터 프로세싱 시스템은 카운터 레지스터 k와 동일한(거의 동일한) 인덱스 값을 포함하거나 그와 연관된 노이즈 값을 선택할 수 있다. 그것이 루프의 첫 번째 반복이라면, 카운터 레지스터 k는 k번째 노이즈 값을 선택하기 전에 초기화 값(예를 들어, k = 0, k = 1 등)으로 초기화될 수 있다. 노이즈 값을 선택하는 것은 노이즈 값과 연관된 데이터를 데이터 프로세싱 시스템의 컴퓨터 메모리의 다른 영역, 예를 들어 메모리의 작업 영역에 복사하는 것을 포함할 수 있다.The data processing system may select the kth noise array value (act 708). To populate the noise array based on each random variable generated in operation 704, the data processing system can iterate for each noise array value (eg, each random variable generated in operation 704, etc.). In some implementations, the data processing system can iteratively loop through each noise value based on the counter register k. Each noise value may be indexed in the data structure by an index value (eg, index 0, index 1, index 2, etc.). To process the noise value, the data processing system can select a noise value that includes or is associated with the same (nearly the same) index value as the counter register k. If it is the first iteration of the loop, the counter register k may be initialized to an initialization value (e.g., k = 0, k = 1, etc.) prior to selecting the kth noise value. Selecting the noise value may include copying data associated with the noise value to another area of computer memory of the data processing system, for example a working area of memory.
데이터 프로세싱 시스템은 랜덤 변수를 사용하여 노이즈 배열을 채울 수 있다(동작 710). 선택 노이즈 값(예: 선택된 랜덤 변수 Xk)을 사용하여, 데이터 프로세싱 시스템은 기준 노이즈 값과 랜덤 변수 간의 차이를 계산할 수 있다. 이 값은 식 D = B - X k 를 사용하여 계산할 수 있고, 여기서 D는 각각의 차이 값이다. 그 후, 데이터 프로세싱 시스템은 k의 D 사본으로 노이즈 어레이를 채울 수 있고, 여기서 k의 값은 노이즈 값과 동일하다. 예를 들어, 이는 노이즈 어레이의 k 번째 포지션에 액세스하고 노이즈 어레이에 k * D를 추가하는 것을 포함할 수 있다. 이러한 방식으로 노이즈 어레이의 각 포지션은 기준 값과 시스템에서 생성된 랜덤 변수에 기초하여 의사 랜덤 노이즈 값으로 채워질 수 있다. The data processing system may populate the noise array using random variables (act 710). Using the selected noise value (eg, the selected random variable X k ), the data processing system can calculate the difference between the reference noise value and the random variable. This value can be calculated using the formula D = B - X k , where D is the value of each difference. The data processing system can then fill the noise array with D copies of k , where the value of k is equal to the noise value. For example, this may involve accessing the kth position of the noise array and adding k * D to the noise array. In this way, each position of the noise array can be filled with a pseudo-random noise value based on a reference value and a random variable generated in the system.
데이터 프로세싱 시스템은 k가 노이즈 어레이 값의 수 n과 동일한지 여부를 결정할 수 있다(동작 712). 데이터 프로세싱 시스템이 노이즈 벡터의 각 포지션을 업데이트했는지 여부를 결정하기 위해, 데이터 프로세싱 시스템은 각 노이즈 값을 선택하는데 사용되는 카운터 레지스터(예를 들어, k)를 노이즈 값의 총 수 n과 비교할 수 있다. 카운터 레지스터 k가 총 노이즈 값의 수 n과 동일하지 않으면(예를 들어, 그보다 작은 경우), 데이터 프로세싱 시스템은 동작 714를 실행할 수 있다. 카운터 레지스터 k가 총 노이즈 값의 수 n과 같으면(예를 들어, 동일하거나 그보다 큰 경우), 데이터 프로세싱 시스템은 동작 716를 실행할 수 있다. The data processing system can determine whether k is equal to the number n of noise array values (act 712). To determine whether the data processing system has updated each position of the noise vector, the data processing system can compare the counter register used to select each noise value (eg, k ) with the total number n of noise values. . If the counter register k is not equal to (eg, less than) the total number of noise values n , then the data processing system can execute operation 714. If the counter register k is equal to (eg, equal to or greater than) the total number of noise values n , then the data processing system can execute operation 716 .
데이터 프로세싱 시스템은 카운터 레지스터 k를 증가시킬 수 있다(동작 714). 일부 구현예에서, 데이터 프로세싱 시스템은 유지된 데이터 레코드 세트(예를 들어, 동작 502에서 데이터 프로세싱 시스템에 의해 유지되는 데이터 레코드 등)에서 다음 프로세싱되지 않은 데이터 레코드를 나타내기 위해 레지스터 k에 하나를 추가할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 카운터 레지스터 k를 다음 프로세싱되지 않은 데이터 레코드의 메모리 어드레스 값(예를 들어, 컴퓨터 메모리에서의 위치)으로 설정할 수 있다. 일부 구현예에서, 다음 프로세싱되지 않은 데이터 레코드의 메모리 어드레스 값은 현재(예를 들어, 선택된) 데이터 레코드의 위치에서 데이터 구조에 포함될 수 있다. 카운터 레지스터 k의 값을 증가시킨 후, 데이터 프로세싱 시스템은 동작 524를 실행할 수 있다.The data processing system may increment the counter register k (act 714). In some implementations, the data processing system adds one to register k to indicate the next unprocessed data record in the held data record set (e.g., the data record maintained by the data processing system in operation 502, etc.) can do. In some implementations, the data processing system can set counter register k to the memory address value (eg, location in computer memory) of the next unprocessed data record. In some implementations, the memory address value of the next unprocessed data record may be included in the data structure at the location of the current (eg, selected) data record. After incrementing the value of counter register k , the data processing system can execute operation 524.
데이터 프로세싱 시스템은 노이즈 어레이를 셔플링할 수 있다(동작 716). 노이즈 어레이를 셔플링하는 것은 노이즈 어레이에서 값의 포지션을 무작위로(예를 들어, 의사-랜덤하게 등) 스와핑하는 것을 포함할 수 있으며, 그에 따라 랜덤하게 순열된 노이즈 어레이를 생성한다. k의 크기가 증가할수록 노이즈 어레이의 각 포지션의 값이 더 커지기 때문이다(예: 노이즈 어레이의 각 포지션 k에 대해, 노이즈 값은 k * D이며, 여기서 D는 기준 노이즈 레벨 빼기 랜덤 변수 X k 임). 일 실시예에서, 노이즈 어레이를 셔플링하는 것은 노이즈 어레이의 랜덤(예를 들어, 의사-랜덤 등) 포지션을 선택하는 것, 및 노이즈 어레이의 다른 의사-랜덤 위치로 그것을 스와핑하는 것을 포함할 수 있다. 다른 실시예에서, 노이즈 어레이를 셔플링하는 것은 제2 노이즈 어레이의 포지션에 의사-랜덤하게 할당된 노이즈 어레이의 값을 포함하는 제2 노이즈 어레이를 생성하는 것을 포함할 수 있다. 이것은 데이터 프로세싱 시스템이 어레이 포지션에 대해 적어도 의사 랜덤하게 분포된 노이즈 어레이를 생성하도록 보장할 수 있다. The data processing system may shuffle the noise array (act 716). Shuffling the noise array may include randomly (eg, pseudo-randomly, etc.) swapping positions of values in the noise array, thereby generating a randomly permuted noise array. This is because as the magnitude of k increases, the value of each position in the noise array becomes larger (e.g., for each position k in the noise array, the noise value is k * D , where D is the reference noise level minus the random variable X k ). In one embodiment, shuffling the noise array may include selecting a random (eg, pseudo-random, etc.) position of the noise array, and swapping it with another pseudo-random position of the noise array. . In another embodiment, shuffling the noise array may include generating a second noise array that includes values of the noise array pseudo-randomly assigned to positions of the second noise array. This can ensure that the data processing system generates an array of noise that is at least pseudorandomly distributed over the array position.
데이터 프로세싱 시스템은 노이즈 어레이를 암호화할 수 있다(동작 718). 데이터 프로세싱 시스템은 도 6과 관련하여 위에서 설명한 방법(600)의 동작(602)에서 생성된 결합된 키를 사용하여 노이즈 어레이의 각 포지션을 암호화할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 노이즈 어레이의 각각의 포지션을 개별적으로 암호화하지 않고 단일 단계에서 결합된 키를 사용하여 전체 노이즈 어레이를 암호화할 수 있다. 집합된 벡터를 암호화하는데 사용되는 것과 동일한 공개 키를 사용하여 노이즈 어레이를 암호화함으로써, 데이터 프로세싱 시스템은 시스템의 차등 프라이버시를 개선하기 위해 향후 단계에서 노이즈 어레이를 집합된 벡터와 결합할 수 있다. 나중에, 데이터 프로세싱 시스템이 집합된 결과를 디코딩할 때, 데이터 프로세싱 시스템은 결과에서 노이즈를 "추출"하기 위해 추가 계산을 수행하여, 디바이스 식별자 및 속성의 K+ 빈도에 대한 차등 계산만 남길 수 있다.The data processing system may encrypt the noise array (act 718). The data processing system may encrypt each position of the noise array using the combined key generated in operation 602 of method 600 described above with respect to FIG. 6 . In some implementations, the data processing system can encrypt the entire noise array using the combined key in a single step, rather than individually encrypting each position in the noise array. By encrypting the noise array using the same public key used to encrypt the aggregated vector, the data processing system can combine the noise array with the aggregated vector at a later stage to improve the differential privacy of the system. Later, when the data processing system decodes the aggregated results, the data processing system may perform additional calculations to "extract" the noise from the results, leaving only the device identifier and differential calculations for K+ frequencies of attributes.
데이터 프로세싱 시스템은 부분 복호화 전에 암호화된 벡터에 노이즈를 첨부할 수 있다(동작 720). 암호화된 벡터에 노이즈를 첨부하는 것은 암호화된 벡터 값에 노이즈 자체를 추가하는 것을 포함할 수 있으므로, 데이터의 전체 정확도를 감소시키지 않고 데이터 벡터에 추가적인 수준의 프라이버시를 도입할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 부분 복호화 단계(예를 들어, 동작 616) 이전에 암호화된 벡터에 각 노이즈 값(예를 들어, 노이즈 어레이의 각 포지션)을 첨부할 수 있다. 이는 누산기 컴퓨팅 디바이스에 의해 최종 히스토그램이 구성될 때, 데이터 프로세싱 시스템은 히스토그램의 각 버킷에서 B*노이즈 벡터의 수를 간단히 제거하여 데이터에서 노이즈를 제거할 수 있음을 의미할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 각 작업자 컴퓨팅 디바이스로부터 노이즈 벡터를 수신하고, 부분 복호화 단계 전에 각 노이즈 값을 암호화된 벡터에 첨부할 수 있다. 이러한 방식으로, 데이터 프로세싱 시스템은 벡터가 시스템 전체를 이동할 때 순열되는 많은 노이즈 값이 있는 큰 벡터를 생성할 수 있다. 어떤 작업자 디바이스도 어떤 값이 노이즈 값인지 알지 못하기 때문에, 단일 작업자는 식별자 서버로부터 데이터 프로세싱 시스템에 제공된 원본 데이터를 결정할 수 없다. 이는 데이터 분석 시스템의 보안을 크게 향상시킨다.The data processing system may append noise to the encrypted vector prior to partial decryption (act 720). Appending noise to the encrypted vector may include adding the noise itself to the encrypted vector value, thereby introducing an additional level of privacy to the data vector without reducing the overall accuracy of the data. In some implementations, the data processing system can append each noise value (eg, each position in the noise array) to the encrypted vector prior to the partial decryption step (eg, operation 616). This may mean that when the final histogram is constructed by the accumulator computing device, the data processing system can remove noise from the data by simply removing the number of B* noise vectors in each bucket of the histogram. In some implementations, the data processing system can receive a noise vector from each worker computing device and append each noise value to the encrypted vector prior to the partial decryption step. In this way, the data processing system can produce large vectors with many noisy values permuted as the vector moves through the system. Since no worker device knows which value is the noise value, a single worker cannot determine the original data provided to the data processing system from the identifier server. This greatly improves the security of the data analysis system.
도 8은 일부 구현예에 따라 본 명세서에서 논의된 임의의 컴퓨터 시스템을 구현하기 위해 사용될 수 있는 예시적 컴퓨터 시스템(800)의 일반적 아키텍처를 도시한다. 컴퓨터 시스템(800)은 디스플레이를 위해 네트워크(110)를 통해 정보를 제공하는데 사용될 수 있다. 도 8의 컴퓨터 시스템(800) 도 5의 컴퓨터 시스템(600)은 메모리(825)에 통신적으로 연결된 하나 이상의 프로세서들(820), 하나 이상의 통신 인터페이스(805), 및 하나 이상의 출력 디바이스들(810)(예를 들어, 하나 이상의 디스플레이 유닛들) 및 하나 이상의 입력 디바이스들(815)을 포함한다. 프로세서(820)는 예를 들어, 데이터 프로세싱 시스템(105A-N) 또는 클라이언트 디바이스(120A-N)와 같은 시스템(100)의 다른 컴포넌트들에 포함될 수 있다.8 illustrates the general architecture of an example computer system 800 that can be used to implement any of the computer systems discussed herein, in accordance with some implementations. Computer system 800 may be used to present information over network 110 for display. Computer system 800 of FIG. 8 computer system 600 of FIG. 5 includes one or more processors 820 communicatively coupled to memory 825, one or more communication interfaces 805, and one or more output devices 810. ) (eg, one or more display units) and one or more input devices 815 . Processor 820 may be included in other components of system 100, such as, for example, data processing system 105A-N or client device 120A-N.
도 8의 컴퓨터 시스템(800)에서, 메모리(825)는 임의의 컴퓨터 판독가능 저장 매체를 포함할 수 있고, 각각의 시스템들에 대해 본 명세서에서 기술된 다양한 기능들을 구현하기 위한 프로세서-실행가능 명령어들과 같은 컴퓨터 명령어들 뿐만 아니라 그와 연관된 임의의 데이터, 그에 의해 생성된 임의의 데이터 또는 통신 인터페이스(들) 또는 입력 디바이스(들)(있는 경우)을 통해 수신된 임의의 데이터를 저장할 수 있다. 다시 도 8의 시스템(800)을 참조하면, 데이터 프로세싱 시스템(105A-N)은 특히 사용자 식별자들의 세트, 생성된 벡터들과 관련된 정보를 저장하는 메모리(825)를 포함할 수 있다. 도 8에 도시된 프로세서(들)(820)는 메모리(825)에 저장된 명령어를 실행하는데 사용될 수 있고, 그렇게 함으로써, 명령어의 실행에 따라 프로세싱되거나 생성된 다양한 정보를 메모리로부터 판독하거나 메모리에 기록할 수 있다. In the computer system 800 of FIG. 8 , the memory 825 may include any computer readable storage medium and may include processor-executable instructions for implementing the various functions described herein for respective systems. may store computer instructions, such as , as well as any data associated therewith, any data generated thereby or received via communication interface(s) or input device(s) (if any). Referring back to system 800 of FIG. 8 , data processing systems 105A-N may include a memory 825 that stores information relating to generated vectors, in particular a set of user identifiers. The processor(s) 820 shown in FIG. 8 can be used to execute instructions stored in memory 825 and, in doing so, to read from or write to memory various information processed or generated in response to the execution of the instructions. can
도 8에 도시된 컴퓨터 시스템(800)의 프로세서(820)는 또한 명령어들의 실행에 따라 다양한 정보를 전송 또는 수신하도록 통신 인터페이스(들)(805)에 통신적으로 연결되거나 제어될 수 있다. 예를 들어, 통신 인터페이스(들)(805)는 유선 또는 무선 네트워크, 버스 또는 기타 통신 수단에 연결될 수 있으며, 따라서 컴퓨터 시스템(800)이 다른 디바이스들(예를 들어, 다른 컴퓨터 시스템들)에 정보를 전송하거나 또는 그로부터 정보를 수신하게 할 수 있다. 도 8의 시스템에서 명시적으로 도시되지 않았지만, 하나 이상의 통신 인터페이스는 시스템(800)의 컴포넌트들 간의 정보 흐름을 용이하게 한다. 일부 구현예에서, 통신 인터페이스(들)는 컴퓨터 시스템(800)의 적어도 일부 양태들에 대한 액세스 포털로서 웹사이트를 제공하도록(예를 들어, 다양한 하드웨어 컴포넌트들 또는 소프트웨어 컴포넌트들을 통해) 구성될 수 있다. 통신 인터페이스(805)의 예는 사용자가 컴퓨터 시스템(800)과 통신할 수 있는 사용자 인터페이스(예를 들어, 웹페이지)를 포함한다.Processor 820 of computer system 800 shown in FIG. 8 may also be communicatively coupled to or controlled by communication interface(s) 805 to transmit or receive various information upon execution of instructions. For example, communication interface(s) 805 can be coupled to a wired or wireless network, bus, or other means of communication so that computer system 800 can communicate information to other devices (eg, other computer systems). It can transmit or receive information from it. Although not explicitly shown in the system of FIG. 8 , one or more communication interfaces facilitate the flow of information between components of system 800 . In some implementations, the communication interface(s) can be configured (e.g., via various hardware components or software components) to provide a website as an access portal to at least some aspects of computer system 800. . Examples of communication interface 805 include a user interface (eg, a webpage) through which a user may communicate with computer system 800 .
도 8에 도시된 컴퓨터 시스템(800)의 출력 디바이스들(810)은 예를 들어, 명령어들의 실행과 관련하여 다양한 정보가 보여 지거나 인식될 수 있도록 제공될 수 있다. 입력 디바이스(들)(815)은 예를 들어, 사용자가 수동 조절을 하거나, 선택을 하거나, 데이터를 입력하거나 또는 명령어들의 실행 중에 프로세서와 다양한 방식으로 인터렉션할 수 있도록 제공될 수 있다. 본 명세서에서 논의된 다양한 시스템들에 이용될 수 있는 일반적인 컴퓨터 시스템 아키텍처에 관한 추가 정보가 본 명세서에서 더 제공된다.The output devices 810 of the computer system 800 shown in FIG. 8 may be provided so that various information may be viewed or recognized, for example, related to the execution of instructions. Input device(s) 815 may be provided, for example, to allow a user to make manual adjustments, make selections, enter data, or interact with the processor in various ways during execution of instructions. Additional information is provided herein further regarding a general computer system architecture that may be used in the various systems discussed herein.
측정 정확도measurement accuracy
이 섹션은 다양한 구성에서 FreqLogLog(FLL), CBF 및 최소 증가 CBF(MICBF) 방법을 비교하는데 중점을 둔다. 도 9a-17b와 관련하여 다음 표, 데이터 및 설명은 예시이며 어떤식으로든 제한하는 것으로 해석되어서는 안된다. 각 구성은 시뮬레이션의 파라미터가 될 수 있는 특정 빈도 분포에 따라 1백만 개의 엘리먼트를 삽입하는 것으로 구성된 각 시도에서 100회 이상의 시도를 시뮬레이션할 수 있다. 예를 들어, 엘리먼트 1234는 시뮬레이션의 빈도 분포에서 가져온 그림에 따라 1회 이상 삽입될 것이다. 즉, 아래에서 설명하는 균일 분포의 경우 총 약 220,000개의 고유 엘리먼트에 대해 8개 빈도 각각에 대해 약 27,500개의 고유 엘리먼트를 삽입한다. 마지막으로, 카디널리티와 엘리먼트 빈도가 추정되는 세트가 각 구성에 대해 동일한지 확인하기 위해 고정 랜덤 시드가 구성 전반에 사용된다. This section focuses on comparing the FreqLogLog (FLL), CBF, and Minimum Increment CBF (MICBF) methods in various configurations. The following tables, data, and descriptions with respect to FIGS. 9A-17B are illustrative and should not be construed as limiting in any way. Each configuration can simulate over 100 trials, with each trial consisting of inserting 1 million elements according to a particular frequency distribution that can be parameters of the simulation. For example, element 1234 will be inserted one or more times according to the picture taken from the simulation's frequency distribution. That is, for the uniform distribution described below, we insert approximately 27,500 unique elements for each of the 8 frequencies for a total of approximately 220,000 unique elements. Finally, a fixed random seed is used across configurations to ensure that the set from which cardinality and element frequencies are estimated is the same for each configuration.
측정 정확도가 엘리먼트 빈도 분포에 의존하지 않음을 입증하기 위해 다음 빈도 분포를 고려한다. 이를 보다 확실하게 증명하기 위해 여기에서 더 많은 작업을 수행할 수 있지만 전체적 분포는 효과가 없는 것으로 보인다. 따라서 초기 시뮬레이션 세트 후에는 "UNIFORM 1 ~ 8"만 사용된다. 아래의 표 2에 표시된 설명은 도 9a-17b에 표시된 데이터와 함께 제공된다.To demonstrate that the measurement accuracy does not depend on the element frequency distribution, consider the following frequency distribution: More work could be done here to prove this more definitively, but the overall distribution doesn't seem to work. Therefore, only "UNIFORM 1 to 8" are used after the initial set of simulations. The description shown in Table 2 below is provided along with the data shown in FIGS. 9A-17B.
FLL과 CBF의 여러 상이한 구성이 고려될 수 있다. FLLS의 경우, 기본 파라미터는 사용할 버킷 수이며, 2의 제곱이다. 따라서 FLL_2_16은 2^16 버킷이 사용되었음을 나타낸다. CBF의 경우, 최소 증가 구성 사용 여부, 버킷 수(m) 및 해시 함수 수(k)의 세 가지 파라미터가 있다. 다음 표는 메모리 사용량과 함께 시뮬레이션되었던 구성 세트를 보여준다. CBF의 경우 버킷 당 1바이트로 가정하는 총 메모리 사용량을 보고하지만, 측정하려는 최대 빈도에 따라 이를 버킷 당4 비트 또는 그 이하로 줄일 수 있다. 그러나 MPC 프로토콜의 관점에서 고려할 때 이러한 감소의 실용성은 그다지 중요하지 않고, MPC 프로토콜은 여기에 설명된 대로 일반 텍스트 크기에 관계없이 버킷에 동등한 암호문 확장을 가져올 수 있다. FLL의 경우, 버킷 당 3바이트를 가정하여 총 메모리를 보고한다. Bloom 필터는 HLL보다 훨씬 더 많은 메모리를 사용할 수 있지만, 더 정확한 측정을 제공할 수 있으며, 매우 적은 정보를 유출하는 안전한 다자간 프로토콜을 사용할 수 있다.Several different configurations of FLL and CBF are contemplated. For FLLS, the default parameter is the number of buckets to use, a power of two. So FLL_2_16 indicates that 2^16 buckets were used. In the case of CBF, there are three parameters: whether to use the minimum increment configuration, the number of buckets (m), and the number of hash functions (k). The following table shows the set of configurations that were simulated along with their memory usage. For CBF, it reports total memory usage assuming 1 byte per bucket, but you can reduce this to 4 bits per bucket or less, depending on the maximum frequency you want to measure. However, the practicality of this reduction is not so important when considered from the MPC protocol's point of view, and the MPC protocol can bring equivalent ciphertext expansion to buckets of any plaintext size, as described here. For FLL, report total memory assuming 3 bytes per bucket. Bloom filters can use significantly more memory than HLLs, but can provide more accurate measurements, and can use secure multiparty protocols that leak very little information.
도 9a-17n에 도시된 차트는 평균 절대 오차의 로그(log10(MAE)), 평균 절대 오차율(MAER), 루트 평균 제곱 오차의 로그(log10(RMSE)) 및 평균 오차(ME)이다. 오류를 보고하는 차트는 최대 10개의 값에 대한 k+ 도달을 표시하는 반면, 비율을 보고하는 차트는 최대 8개의 값만 표시한다. 이는 시뮬레이션된 최대 빈도가 항상 8이기 때문에 9+ 및 10+ 값에 대해 0이 아닌 값은 오류이다.도 9a-b는 CBF 및 FLL_2_14_Uniform의 여러 구성을 고려한다. CBF가 경쟁력이 있으려면, 최소 증가 구성을 활성화해야 할 수 있으므로 향후 모든 결과에서 MICBF를 활용할 수 있다. 최소 증가 CBF는 FLL의 오류율이 상당히 우수한 약 1%에 불과하지만 FLL을 크게 능가할 수 있다. 반면에 최상의 MICBF는 오류가 거의 0에 가깝지만 메모리 비용이 훨씬 더 많이든다. 모든 방법은 ME 플롯에 표시된 것처럼 과잉 추정쪽으로 편향되어 있다. 빈도 8에서 MI_CBF_0_4는 FLL과 비슷한 성능을 갖지만 메모리 사용량은 ~50배이다. 그러나 MICBF는 더 낮은 빈도에서 훨씬 더 잘 수행한다.The charts shown in FIGS. 9A-17N are log of mean absolute error (log10(MAE)), mean absolute error rate (MAER), log of root mean squared error (log10(RMSE)), and mean error (ME). Charts reporting errors show reaching k+ for up to 10 values, while charts reporting percentages show only up to 8 values. This is because the maximum simulated frequency is always 8. Non-zero values for 9+ and 10+ values are errors. Figures 9a-b consider several configurations of CBF and FLL_2_14_Uniform. For CBF to be competitive, it may be necessary to enable the least incremental configuration, so that all future outcomes can utilize MICBF. The minimum incremental CBF can significantly outperform FLL, although the error rate of FLL is only about 1%, which is quite good. On the other hand, the best MICBF has near-zero error, but the memory cost is much higher. All methods are biased toward over-estimation, as indicated by the ME plot. At frequency 8, MI_CBF_0_4 has similar performance to FLL, but uses ~50x the memory. However, MICBF performs much better at lower frequencies.
다음으로, 도 10a-b에서, 몇 가지 더 높은 메모리 FLL이 테스트되었다. MICBF 및 3개의 더 높은 메모리 FLL에 대해 위와 동일한 메트릭이 설명되어 있다. 주된 관찰은 12.6MB의 메모리를 사용하는 가장 높은 메모리 FLL, FLL_2_22(노란색 선) 조차도 9.6MB의 메모리를 사용하는 CBF_MI_0_01보다 성능이 우수하다는 것이다. 또 다른 관찰은 FLL이 더 높은 빈도를 덜 정확하게 추정하는 반면 MICBF는 빈도에서 더 일관된 오류를 갖는다는 것이다. 마지막으로 흥미롭고 다소 혼란스러운 결과는 곡선의 모양과 관련이 있다. log10(MAE) 플롯을 보면 MICBF 및 FLL 오류의 일반적인 모양이 파라미터화 전반에 걸쳐 동일한 것으로 보이지만, 자세히 살펴보면 FLL_2_18의 곡선은 MICBF 패밀리 곡선과 매우 유사하며 CBF_MI_0_1은 FLL 패밀리 곡선과 유사해 보인다. 이것은 오류가 아니며, 결과는 여러 번 확인되었다.Next, in Figures 10a-b, several higher memory FLLs were tested. The same metrics as above are described for MICBF and the three higher memory FLLs. The main observation is that even the highest memory FLL, FLL_2_22 (yellow line), using 12.6MB of memory, outperforms CBF_MI_0_01, which uses 9.6MB of memory. Another observation is that FLL estimates higher frequencies less accurately, whereas MICBF has more consistent errors in frequencies. A final interesting and somewhat confusing result has to do with the shape of the curve. Looking at the log10(MAE) plots, the general shapes of the MICBF and FLL errors appear to be the same throughout the parameterization, but upon closer inspection, the curves for FLL_2_18 look very similar to the MICBF family curves, and CBF_MI_0_1 looks similar to the FLL family curves. This is not an error, and the results have been checked multiple times.
기준 측정 세트에 대한 또 다른 고려 사항은 두 가지 방법이 서로 다른 빈도 분포와 관련하여 수행하는 방식이다. 여기서, FLL_2_14 및 CBF_MI_0_01은 위에서 설명한 빈도 분포에 대해 테스트되었으며, 그 결과는 도 11a-b에 도시되어 있다. 전반적으로, MICBF는 빈도 분포의 변화에 탄력적이며, 세 분포에서 거의 제로에 가까운 오류율을 안정적으로 나타내는 반면, FLL의 오류율은 빈도 분포에 따라 최대 2.5%까지 변동한다. 특히, 빈도 분포가 덜 조밀한 경우 FLL은 카디널리티를 과대 평가하는 경향이 더 크다. 이는 LINEAR_8_1 분포에 대한 1+ 도달 범위의 과대 추정(~ 1.5 %)과 LINEAR_1_8 분포에 대한 8+ 도달 범위의 과대 추정(~ 4.5 %)으로 표시된다. 아마도 후자는 1+ 도달이 모든 빈도를 포함하는 반면 8+는 그렇지 않기 때문에 더 큰 오류를 나타낸다.Another consideration for the baseline measurement set is how the two methods perform with respect to different frequency distributions. Here, FLL_2_14 and CBF_MI_0_01 were tested for the frequency distribution described above, and the results are shown in Figures 11a-b. Overall, MICBF is resilient to changes in the frequency distribution and shows stable near-zero error rates across the three distributions, whereas FLL's error rate fluctuates up to 2.5% with the frequency distribution. In particular, when the frequency distribution is less dense, FLL has a greater tendency to overestimate the cardinality. This is indicated by an overestimation of 1+ coverage for the LINEAR_8_1 distribution (~1.5%) and an overestimation of 8+ coverage for the LINEAR_1_8 distribution (~4.5%). Perhaps the latter represents a larger error since the arrival of 1+ covers all frequencies whereas 8+ does not.
마지막으로, 도 12는 추정기의 변동성을 고려한다. 여기서, 로그 스케일 플롯이 생략되고(MAER 및 ME만 도시됨), 차트가 너무 복잡하지 않도록 하기 위해 두 개의 추정치만 도시된다. 또한, 완전히 공정한 비교를 위해 CBF_MI_0_25_Uniform을 FLL_2_14_Uniform과 비교한다. 분명한 것은 FLL이 더 높은 빈도에서 변동성이 증가한다는 것이고, 위와 같이 더 높은 빈도에서 더 적은 수의 버킷을 평균화할 수 있다는 사실로 설명될 수 있다. 그러나 가장 낮은 빈도에서도 FLL은 모든 빈도에서 일관되게 작은 변동성을 갖는 MICBF보다 훨씬 더 많은 변동성을 갖는다.Finally, Fig. 12 considers the variability of the estimator. Here, log scale plots are omitted (only MAER and ME are shown), and only two estimates are shown to avoid overcomplicating the chart. Also, for a completely fair comparison, compare CBF_MI_0_25_Uniform to FLL_2_14_Uniform. Clearly, FLL increases volatility at higher frequencies, which can be explained by the fact that it can average fewer buckets at higher frequencies, as above. However, even at the lowest frequency, FLL has much more variability than MICBF, which has consistently small variability at all frequencies.
전반적으로, FLL에 비해 MICBF는 훨씬 더 많은 메모리 사용에도 불구하고 더 정확하고 더 넓은 범위의 빈도 분포에서 변동성이 적다. 다음은 MICBF에 차등 프라이버시를 적용하는 방법을 고려할 것이다.Overall, compared to FLL, MICBF is more accurate and has less variability over a wider range of frequency distributions despite using much more memory. Next, we will consider how to apply differential privacy to MICBF.
MICBF를 차등적으로 비공개로 만드는 적어도 두 가지 접근법이 여기에 제시되어 있으며, 둘 다 노이즈에 대해 양면 기하학적 분포를 사용한다. 첫 번째는 개별 CBF 버킷에 차등 프라이버시(DP)를 적용하는 것이며, 이로 인해 측정 품질이 상당히 저하되며 자세한 내용은 아래에서 검토한다. 반면에, 버킷 값의 히스토그램에 DP를 적용하는 두 번째 방법은 확실한 결과를 가진다.At least two approaches to differentially private MICBF are presented here, both using a two-sided geometric distribution for noise. The first is to apply differential privacy (DP) to individual CBF buckets, which significantly reduces measurement quality, reviewed in detail below. On the other hand, the second method of applying DP to the histogram of bucket values has solid results.
카디널리티 추정이 버킷 값의 히스토그램을 사용할 수 있고, 다음 섹션에서 가능함을 보여줄 버킷 값을 표시하지 않고 히스토그램을 계산할 수 있다고 가정하면, 버킷 값 히스토그램 자체에 차등 프라이버시가 적용될 수 있다. 이제, 일반적으로 히스토그램 쿼리의 민감도는 1이 될 수 있지만, 버킷 값의 히스토그램을 고려하고 각 클라이언트 디바이스 식별자 또는 속성 데이터가 k번 표현되므로, 민감도는 실제로 k이거나 단지 해시 함수의 수이다. CBF_MI_0_01 패밀리의 경우, 이 값은 7이다.Assuming that cardinality estimation can use a histogram of bucket values, and compute the histogram without marking the bucket values, which we will show in the next section that this is possible, differential privacy can be applied to the bucket value histogram itself. Now, in general the sensitivity of a histogram query can be 1, but since we consider a histogram of bucket values and each client device identifier or attribute data is represented k times, the sensitivity is actually k or just a number of hash functions. For the CBF_MI_0_01 family, this value is 7.
도 13a-b는 0.1, 0.5, 1, 2의 엡실론 값에 대해 주어진 추정치를 도시한다. 이들은 각각 0.0142, 0.0689, 0.1331 및 0.2485의 양면 기하 분포 파라미터에 대응한다. 히스토그램에 노이즈를 추가하는 것은 적당한 엡실론 값에 상대적으로 영향을 미치지 않으며 엡실론이 0.1인 경우에도 측정이 합리적이다.Figures 13a-b show the estimates given for epsilon values of 0.1, 0.5, 1, and 2. These correspond to two-sided geometric distribution parameters of 0.0142, 0.0689, 0.1331 and 0.2485, respectively. Adding noise to the histogram has relatively little effect on the reasonable epsilon value, and the measurement is reasonable even with an epsilon of 0.1.
마지막으로, 도 14a-b는 1의 엡실론에 대한 MICBF의 여러 파라미터화 정확도이다. 여기서, 차등 프라이버시를 사용하더라도, CBF_MI_0_4는 더 높은 빈도에서 FLL만큼 성능을 계속 유지한다.Finally, Figures 14a-b are the various parameterization accuracies of the MICBF for an epsilon of 1. Here, even with differential privacy, CBF_MI_0_4 continues to perform as well as FLL at higher frequencies.
도 15는 노이즈가 추가되지 않은(Uniform), 노이즈이 추가되고 수정되지 않은(GEO_NOCOR), 그리고 보정 후 노이즈(GEO_COR)가 있는 CBF_MI_0_01에 대한 MAE의 log10을 보여준다. 엡실론 1이 사용되고 쿼리 민감도는 8로 설정되며, 이는 파라미터 0.1175가 있는 양면 기하 분포가 사용되었음을 의미한다. 참고로 FLL_2_14도 도시된다. 보정 전에 기하학적 노이즈가 있는 CBF는 사용할 수 없지만, 디노이징된 버전도 FLL보다 훨씬 더 많은 오류를 나타낸다. 도 16a-b는 전체 차트 세트를 도시하지만 GEO_NOCOR를 제거한다. 평균 오차의 플롯을 조사하여 얻은 한 가지 관찰은 빈도가 변함에 따라 추정치가 과다 추정과 과소 추정 사이에서 변동한다는 것이다.15 shows the log10 of MAE for CBF_MI_0_01 with noise added (Uniform), noise added and uncorrected (GEO_NOCOR), and with noise after correction (GEO_COR). Epsilon 1 is used and the query sensitivity is set to 8, which means that a two-sided geometric distribution with parameter 0.1175 is used. For reference, FLL_2_14 is also shown. CBF with geometric noise before correction cannot be used, but even the denoised version exhibits significantly more errors than FLL. 16a-b show the full chart set but remove GEO_NOCOR. One observation made by examining the plot of the mean error is that estimates fluctuate between overestimation and underestimation as the frequency changes.
관찰은 단일 CBF를 취하고 100개의 서로 다른 노이즈 벡터를 적용하여 조사되었던 디노이징(denoised) 체제 하에서 추정의 분산에 대한 또 다른 질문으로 이어진다. 이것은 민감도가 8이고 엡실론의 4가지 다른 값(0.5, 1, 2 및 3)을 갖는 쿼리에 대해 수행되었지만, 중요한 것은 이러한 값이 의미하는 기하학적 분포에 대한 파라미터이며, 이는 도 17a-b에 나열된다. p = 0.06인 경우, 추정값의 표준 편차가 평균을 기준으로 약 5%씩 달라진다. 또한 쿼리의 민감도가 8보다 훨씬 높을 가능성이 있으므로, p = 0.06이 노이즈 분포에 대해 예상할 수 있는 최대 값일 것이다.The observation leads to another question about the variance of the estimate under the denoised regime, which was investigated by taking a single CBF and applying 100 different noise vectors. This was done for a query with a sensitivity of 8 and four different values of epsilon (0.5, 1, 2 and 3), but the important ones are the parameters for the geometric distribution implying these values, which are listed in Fig. 17a-b . For p = 0.06, the standard deviation of the estimate differs by about 5% from the mean. Also, since the sensitivity of the query is likely to be much higher than 8, p = 0.06 is probably the maximum value you can expect for a noise distribution.
B. 계단식 군단 빈도 및 카디널리티 추정B. Cascading swarm frequency and cardinality estimation
이 섹션에 설명된 구현예, 기술, 시스템, 방법 또는 프로세스는 위 섹션 A에 설명된 컴퓨터 시스템 또는 이 섹션에 설명된 컴퓨터 시스템에 의해 수행 또는 실행될 수 있다.Any implementation, technique, system, method or process described in this section may be performed or executed by the computer system described in Section A above or the computer system described in this section.
식별자 서버는 예를 들어 각각의 클라이언트 디바이스와 연관된 클라이언트 식별자를 유지함으로써 클라이언트 디바이스 세트와 연관될 수 있다. 각 클라이언트 식별자는 각 식별자 서버와 클라이언트 디바이스 간의 연결을 설명하는 속성 정보를 포함할 수 있다. 속성 정보는 클라이언트 디바이스와 식별자 서버 간의 관계에 대한 정보(예: 웹 브라우징 기록, 인터렉션 데이터, 연결 시간, 네트워크 분석 데이터 등)를 포함할 수 있으며, 각각의 클라이언트 디바이스로부터 수신된 보호된 또는 개인 정보를 포함할 수 있다. 서로 다른 식별자 서버는 동일한 각각의 클라이언트 디바이스에 대응하는 서로 다른 속성 데이터 및 서로 다른 클라이언트 식별자를 유지할 수 있다. 일반적으로 각 식별자 서버 간에 중복된 속성 데이터가 있는지 결정하기 위해 식별자 서버는 보호된 또는 개인 정보를 포함할 수 있는 속성 데이터를 중앙 서버와 공유하여 클라이언트 속성 정보의 중복을 제거할 수 있다. An identifier server may be associated with a set of client devices, for example by maintaining a client identifier associated with each client device. Each client identifier may include attribute information describing a connection between each identifier server and the client device. Attribute information may include information about the relationship between the client device and the identifier server (eg, web browsing history, interaction data, connection time, network analysis data, etc.), and may include protected or personal information received from each client device. can include Different identifier servers may maintain different client identifiers and different attribute data corresponding to the same respective client device. In general, to determine if there is duplicate attribute data between each identifier server, the identifier server may share attribute data, which may contain protected or private information, with the central server to eliminate duplication of client attribute information.
그러나 모든 클라이언트 속성 데이터를 전송하면 확장성에 문제가 발생한다. 클라이언트 식별자 서버 수가 증가하면 일반적으로 네트워크를 통해 전송되는 클라이언트 디바이스 속성 데이터의 양도 증가한다. 속성 데이터는 각 클라이언트 디바이스에 대해 상세하고 상대적으로 클 수 있기 때문에 이러한 정보를 대규모로 전송하면 네트워크 대역폭과 계산 리소스가 소모될 수 있다. 또한 시스템이 총 사용자 식별자 수를 계산하는 것 뿐만 아니라 네트워크를 통해 보호된 또는 개인 속성 정보를 전송하지 않고 특정 속성의 빈도와 같은 특정 속성 데이터 기준을 충족하는 클라이언트 디바이스의 수도 계산하는 것이 유용하다. 또한, 이러한 이슈를 해결하는데 사용되는 암호화된 확률 데이터 구조의 구현예는 비현실적으로 큰(예: 기가 바이트 정도) 스케치 크기로 인해 어려움을 겪는다.However, sending all client attribute data causes scalability problems. As the number of client identifier servers increases, the amount of client device attribute data typically transmitted over the network also increases. Because attribute data can be detailed and relatively large for each client device, transmitting this information on a large scale can consume network bandwidth and computational resources. It is also useful for the system to count not only the total number of user identifiers, but also the number of client devices that meet certain attribute data criteria, such as the frequency of certain attributes, without transmitting protected or private attribute information over the network. Additionally, implementations of encrypted probabilistic data structures used to address this issue suffer from unrealistically large (e.g., on the order of gigabytes) sketch sizes.
앞서 언급한 이슈를 해결하기 위해, 이 기술 솔루션의 시스템 및 방법의 양태에서 계단식 군단 방식을 활용할 수 있다. 본 명세서에 설명된 확률적 데이터 구조는 클라이언트 디바이스 식별자의 멀티세트 내의 멤버의 수에 기초하여 크기가 대수적으로 증가할 수 있다. 퍼블리셔 컴퓨팅 디바이스는 연관된 클라이언트 디바이스 세트로서의 해시 및 활동 빈도(예를 들어, 콘텐츠 아이템과의 인터렉션 빈도 등)를 계산하여 해시된 디바이스 식별자인 경우 세트를 생성할 수 있다. 퍼블리셔는 비트 값 행렬을 포함하는 계단식 군단 데이터 구조를 생성할 수 있다. 행렬의 각 행은 각 해시 데이터 레코드의 최하위 0의 수에 대응할 수 있다. 행렬의 각 열은 각 해시된 데이터 레코드의 모듈러스 값에 대응할 수 있다.In order to address the aforementioned issues, a cascade approach may be utilized in the system and method aspects of this technical solution. The probabilistic data structures described herein can grow logarithmically in size based on the number of members in the multiset of client device identifiers. A publisher computing device may compute a hash and activity frequency (eg, frequency of interaction with an item of content, etc.) as a set of associated client devices to create a set if a hashed device identifier. A publisher may create a cascaded swarm data structure containing a matrix of bit values. Each row of the matrix may correspond to the number of least significant 0s in each hash data record. Each column of the matrix may correspond to the modulus value of each hashed data record.
퍼블리셔 컴퓨팅 디바이스는 데이터 레코드에서 최하위 0의 수를 결정하여 계단식 군단 행렬을 채울 수 있다. 예를 들어, 행렬의 제1 행은 단일 최하위 0(예: 1111 1110)에 대응할 수 있고, 제2 행은 두 개의 최하위 0(예: 1111 1100)에 대응할 수 있다. 균일하게 분산된 출력을 생성하는 해시 함수를 사용하여 각 디바이스 식별자를 해시할 수 있다. 따라서, 행렬의 행에 대응하는 임의의 해시 식별자의 확률 p는 2-k일 수 있고, 여기서 k는 행렬의 인덱스이다. 예를 들어, 임의의 주어진 해시된 식별자는 제1 행을 채울 확률이 50%(예: p = 0.5), 행렬의 제2 행을 채울 확률이 25%(예: p = 0.25)일 수 있다. 퍼블리셔 컴퓨팅 디바이스가 해시된 식별자가 행렬의 행에 대응한다고 결정하면, 퍼블리셔는 해시된 데이터 레코드에 대해 모듈러스 연산을 수행하여 해당 행의 포지션을 선택하고 해당 포지션의 비트를 1로 설정할 수 있다. 퍼블리셔 컴퓨팅 디바이스는 퍼블리셔와 연관된 모든 식별자에 대해 이 동작을 수행할 수 있다. 퍼블리셔 컴퓨팅 디바이스가 모든 식별자로 행렬을 채운 후, 퍼블리셔 컴퓨팅 디바이스는 확률 p로 행렬의 각 행의 비트를 무작위로 플립핑하여 스케치를 차등적으로 비공개로 만들 수 있다. The publisher computing device may determine the number of least significant 0's in the data record to populate the cascading corps matrix. For example, the first row of the matrix may correspond to a single least significant 0 (eg 1111 1110) and the second row may correspond to two least significant 0s (eg 1111 1100). Each device identifier can be hashed using a hash function that produces a uniformly distributed output. Thus, the probability p of any hash identifier corresponding to a row of the matrix may be 2-k, where k is the index of the matrix. For example, any given hashed identifier may have a 50% chance of filling the first row (e.g. p = 0.5) and a 25% chance of filling the second row of the matrix (e.g. p = 0.25). If the publisher computing device determines that the hashed identifier corresponds to a row of the matrix, the publisher may perform a modulus operation on the hashed data record to select a position in that row and set a bit in that position to one. The publisher computing device may perform this operation for all identifiers associated with the publisher. After the publisher computing device has filled the matrix with all identifiers, the publisher computing device can make the sketch differentially private by randomly flipping the bits in each row of the matrix with probability p.
계단식 군단 데이터 구조를 구현하는 기법은 HyperLogLog의 문제를 해결할 수 있다. 카운팅 블룸 필터와 관련하여 위에서(예를 들어, 섹션 A 및 전체 등에서) 설명된 바와 같이, 계단식 군단 데이터 구조는 하나 이상의 식별자 서버(예를 들어, 데이터 프로세싱 시스템(105A-N) 등)에 의해 생성될 수 있고, 스케치는 안전한 다자간 계산(예: 동형 암호화 기반 등)과 차등 프라이버시 노이즈를 추가의 조합을 통해 프라이버시 보호 방식으로 병합될 수 있다.A technique to implement a cascading swarm data structure can solve the problem of HyperLogLog. As described above with respect to counting bloom filters (e.g., in Section A and overall, etc.), the cascade data structure is generated by one or more identifier servers (e.g., data processing systems 105A-N, etc.) , and the sketches can be merged in a privacy-preserving manner through an additional combination of secure multiparty computation (e.g., based on homomorphic encryption) and differential privacy noise.
위 섹션 A에서 설명한 CBF(Counting Bloom Filters)에 기초한 접근법을 사용하면, 다수의 퍼블리셔에 걸쳐 프라이버시 도달 범위 및 빈도 중복 제거를 제공할 수 있다. 이러한 해결책은 곱셈 동형을 가진 암호화 체계를 구현하여 분산 검증 기법의 계산 성능을 향상시킬 수 있다. 이러한 접근법에서, 스케치의 크기는 전체 인터넷 인구 또는 다양한 규모의 다른 인구에 가까운 크기의 청중을 저장할 수 있다. 이러한 접근법을 통해 각 퍼블리셔는 각 요청에 대해 몇 기가 바이트의 데이터 세트 또는 일부 형태의 피드백 루프를 업로드할 수 있고, 여기서 시스템은 작은 스케치로 시작한 다음 청중이 많은 경우 또는 다른 방법의 양태에 기초하여 더 큰 스케치를 요청할 수 있다.Using an approach based on Counting Bloom Filters (CBF) described in Section A above, it is possible to provide privacy coverage and frequency deduplication across multiple publishers. This solution can improve the computational performance of distributed verification techniques by implementing an encryption scheme with multiplicative isomorphism. In this approach, the size of the sketch can hold an audience close to the size of the entire internet population or other populations of varying sizes. This approach allows each publisher to upload a few gigabytes of data set for each request, or some form of feedback loop, where the system starts with a small sketch and then expands further based on the large audience or other aspects of the method. Larger sketches may be requested.
HLL(HyperLogLog) 기반 접근법은 계산 비용이 더 많이 드는 암호화를 활용할 수 있는 최소/최대 동작을 구현할 수 있다. HLL 구현예에서 스케치에 배치된 사용자 식별자의 차등 프라이버시를 유지하는 것도 어려운 과제다.A HyperLogLog (HLL) based approach can implement min/max operations that can utilize computationally more expensive cryptography. Maintaining the differential privacy of user identifiers placed in sketches in HLL implementations is also a challenge.
여기에 설명된 CLCE(Cascading Legions Cardinality Estimator) 기법을 구현하는 접근법은 카운팅 블룸 필터(예를 들어, 섹션 A 등에서 위에 설명됨) 및 HyperLogLog의 아이디어를 결합하여 적어도 앞서 언급한 이슈를 해결할 수 있다. 따라서, 여기에 설명된 CLCE 구현예는 디바이스 식별자의 차등 프라이버시를 손상시키지 않으면서, 여러 데이터 세트에 걸쳐 카디널리티 결정 알고리즘에 대한 개선을 제시한다. 다른 구현예 및 기법과 달리, 계단식 군단 스케치의 크기는 특정 식별자 서버(예를 들어, 데이터 프로세싱 시스템(105) 등)와 연관된 식별자의 수의 크기에 따라 대수적으로 증가할 수 있다. 이러한 기법을 구현하는데 최소/최대 동작이 필요하지 않으므로, CLCE에 대해 계산적으로 저렴한 암호화 체계를 사용할 수 있다. 스케치의 구조는 위의 섹션 A에서 설명한 카운팅 블룸 필터 접근법과 유사하므로, CBF용으로 개발된 MPC(다자간 계산)(예: 섹션 A에서 위의 설명)를 CLCE 스케치에 적용하여 디바이스 식별자 및 목표 속성 세트의 빈도 및 카디널리티를 계산한다.The approach to implementing the Cascading Legions Cardinality Estimator (CLCE) technique described here combines the ideas of a counting bloom filter (e.g., described above in Section A, etc.) and HyperLogLog to address at least the aforementioned issues. Thus, the CLCE implementation described herein presents improvements to the cardinality determination algorithm across multiple data sets without compromising the differential privacy of device identifiers. Unlike other implementations and techniques, the size of the cascading corps sketch can grow logarithmically with the size of the number of identifiers associated with a particular identifier server (eg, data processing system 105, etc.). Since min/max operations are not required to implement these techniques, a computationally inexpensive encryption scheme can be used for CLCE. Since the structure of the sketch is similar to the counting bloom filter approach described in Section A above, the multiparty computation (MPC) developed for CBF (e.g. described above in Section A) can be applied to the CLCE sketch to obtain a set of device identifiers and target attributes. Calculate the frequency and cardinality of
동시에, CLCE에 의해 획득된 카디널리티 추정치는 편향되지 않을 수 있으며, 유니온 연산은 교환적이므로 다른 구현과 비교할 때 높은 품질의 결과를 제공할 수 있다. CLCE 스케치는 적어도 두 개의 파라미터: 군단의 수 l 및 군단에서 포지션의 수 n을 포함할 수 있다. 스케치는 2차원 n x l 비트 어레이일 수 있다. 일부 구현예에서, 스케치는 카운터 레지스터의 2차원 n x l 어레이, 또는 컴퓨터 메모리(예를 들어, 데이터 프로세싱 시스템의 메모리(105) 등)의 하나 이상의 데이터 구조에 저장될 수 있는 다른 유형의 변수 또는 데이터 유형일 수 있다. 빈 스케치는 초기화 값(예: 0)으로 초기화될 수 있다.At the same time, the cardinality estimate obtained by CLCE may be unbiased, and the union operation may be commutative, thus providing high quality results when compared to other implementations. A CLCE sketch may contain at least two parameters: the number of corps l and the number of positions in the corps n. A sketch can be a two-dimensional n x l bit array. In some implementations, a sketch can be a two-dimensional n x l array of counter registers, or other type of variable or data type that can be stored in one or more data structures in computer memory (eg, memory 105 of a data processing system, etc.) can An empty sketch can be initialized with an initialization value (eg 0).
추정기의 예시적 표현은 다음 의사 코드에 포함되어 있다:An example representation of an estimator is included in the following pseudocode:
class CascadingLegions: class CascadingLegions:
def __init__(self, l, n): def __init__(self, l, n):
self.l = l # number of legions self.l = l # number of legions
self.n = n # number of positions in a legion self.n = n # number of positions in a legion
self.legions = new array l by n filled with zeros self.legions = new array l by n filled with zeros
def Add(self, element): def Add(self, element):
binary_fingerprint = binary fingerprint of element binary_fingerprint = binary fingerprint of element
legion = number of least significant zeros in binary_fingerprint legion = number of least significant zeros in binary_fingerprint
# Elements that belong beyond the last legion are placed into the last # Elements that belong beyond the last legion are placed into the last
# legion. # legion.
if legion >= self.l: if legion >= self.l:
legion = self.l - 1 legion = self. l - 1
# Position uses the bits of binary_fingerprint that # Position uses the bits of binary_fingerprint that
# remain after removing trailing 0s and the 1. # remain after removing trailing 0s and the 1.
position = (binary_fingerprint // 2 ** (legion + 1)) % self.n position = (binary_fingerprint // 2 ** (legion + 1)) % self.n
self.legions[legion, position] = 1 self.legions[legion, position] = 1
@staticmethod @staticmethod
def ExpectedBits(num_elements): def ExpectedBits(num_elements):
# It is easy to see that the following is the formula for expected number of # It is easy to see that the following is the formula for expected number of
# bits activated after num_elements elements were added. # bits activated after num_elements elements were added.
return sum( return sum(
1 - exp(num_elements / (2 ** i * self.n)) * self.n 1 - exp(num_elements / (2 ** i * self.n)) * self.n
for i in range(1, self.l)) + ( for i in range(1, self.l)) + (
1 - exp(num_elements / (2 ** (self.l - 1) * self.n)) * self.n 1 - exp(num_elements / (2 ** (self.l - 1) * self.n)) * self.n
def EstimateCardinality(self): def EstimateCardinality(self):
b = count bits in self.legions b = count bits in self.legions
return average num_elements for which int(ExpectedBits) is equal to b return average num_elements for which int(ExpectedBits) is equal to b
def Merge(self, other_sketch): def Merge(self, other_sketch):
self.legions = elementwise OR of self.legions and other_sketch.legions. self.legions = elementwise OR of self.legions and other_sketch.legions.
위의 추정기 표현은 추정기의 기능(예: 계단식 군단 스케치의 구성, 스케치에 엘리먼트 추가, 군단에 기초하여 예상 비트 수 결정, 스케치에 기초하여 한 세트의 카디널리티 추정 및 다른 스케치의 병합 등)이 단일 클래스의 일부로서 단일 컴퓨팅 디바이스에서 발생할 수 있다는 것을 표시할 수 있지만, 위의 의사 코드는 순전히 예를 들어 알고리즘 표현과 같은 방식으로 구성되며, 이러한 기법을 수행하는 시스템의 구성을 설명하는 것으로 해석되면 안된다. 여기에 설명된 임의의 컴퓨팅 디바이스는 위에 설명된 기능 중 임의의 기능을 수행할 수 있으며, 이러한 기법은 하나 이상의 컴퓨팅 디바이스(예를 들어, 데이터 프로세싱 시스템(105A-N), 작업자 컴퓨팅 디바이스(405A-N), 애그리게이터 컴퓨팅 디바이스(410) 등)에 걸쳐 분산될 수 있다. 위의 의사 코드는 본 명세서에 기술된 시스템 및 방법에 대해 어떠한 측면에서든 제한하는 것으로 해석되어서는 안되며, 위의 표현은 순전히 예시적 목적이며 본 명세서에 기술된 구현예의 하나 이상의 양태만 설명할 수 있음을 이해해야 한다.The estimator representation above is such that the function of the estimator (e.g. constructing a cascading swarm sketch, adding elements to the sketch, determining the expected number of bits based on the swarm, estimating the cardinality of one set based on the sketch and merging the other sketches) is a single class. Although it may indicate that it may occur on a single computing device as part of a , the pseudocode above is constructed purely in such a way that it is eg an algorithmic representation and should not be construed as describing the configuration of a system that performs such a technique. Any computing device described herein may perform any of the functions described above, and such techniques may include one or more computing devices (eg, data processing systems 105A-N), worker computing devices (405A-N), N), aggregator computing devices 410, etc.). The pseudocode above should not be construed as limiting in any respect to the systems and methods described herein, and the above representation is purely for illustrative purposes and may only describe one or more aspects of the implementations described herein. should understand
파라미터(l, n)를 가진 계단식 군단 스케치는 표준 편차가 를 가지는(예: 같음, 대략 같음 등) 상대 오차로 최대 크기 세트의 카디널리티를 추정할 수 있다. The cascading corps sketch with parameters (l, n) has a standard deviation (e.g., equal to, approximately equal to, etc.) The cardinality of a size set can be estimated.
이제 도 18에 도시된 그래프를 참조하면, 도시된 것은 10개의 시뮬레이션과 함께 스케치에 추가된 디바이스 식별자가 차지하는 이론적으로 추정된 비트 수이다. n = 10K, l = 7의 CLCE 파라미터가 사용된다. 도 18에 표현된 데이터는 순전히 예시적 데이터로 간주되어야 하며, 여기에 설명된 기법의 구현예는 다른 결과를 생성할 수 있다. 따라서 데이터는 순전히 예시 데이터이며, 어떤 측면에서든 제한적인 것으로 간주되어서는 안된다.Referring now to the graph shown in Figure 18, what is shown is the theoretically estimated number of bits occupied by the device identifier added to the sketch with 10 simulations. CLCE parameters of n = 10K and l = 7 are used. The data represented in FIG. 18 should be considered purely illustrative, and implementations of the techniques described herein may produce different results. The data are therefore purely illustrative and should not be considered limiting in any way.
도 18의 선은 시각적으로 구분할 수 없다. 도 18에서, 군단 수에서 디바이스 식별자 추정의 상대 오차는 2%미만으로 유지된다. 단순성을 위해, 마지막 군단을 넘어서는 사용자 식별자를 삭제하기 때문에, 소규모 청중의 경우 오류가 4%에 이른다. 일부 구현예에서, 마지막 군단을 넘어서는 사용자 식별자는 삭제되지 않는다.The lines in FIG. 18 are visually indistinguishable. 18, the relative error of device identifier estimation in corps count remains less than 2%. For simplicity, we delete user identifiers beyond the last corps, so the error reaches 4% for small audiences. In some implementations, user identifiers beyond the last corps are not deleted.
도 19는 32개의 군단이 있는 스케치의 예시 데이터를 도시하며, 10K 포지션은 임의의 최신 디바이스 식별자 세트를 정확하게 측정하는데 충분할 수 있다. 이 스케치는 320 킬로 비트를 포함할 수 있지만, 다양한 파라미터를 가진 다른 수의 비트, 군단 또는 군단 포지션을 포함할 수 있다. Figure 19 shows example data for a sketch with 32 corps, where 10K positions may be sufficient to accurately measure any current set of device identifiers. This sketch may contain 320 kilobits, but may contain other numbers of bits, swarms or swarm positions with various parameters.
계단식 군단 카디널리티 또는 빈도 추정을 수행하기 위해, 시스템(예를 들어, 시스템(100), 시스템(400A-C), 이들의 임의의 조합 등)은 다음 프로세스의 임의의 조합을 수행할 수 있다. 첫째, 시스템은 스케치(예를 들어, 여기에 설명된 계단식 군단 스케치, 여기에 설명된 다른 데이터 구조 또는 스케치 등)를 생성할 수 있는 다수의(예를 들어, 1, 10, 100, 1000 또는 10000 등을 초과하는) 퍼블리셔 컴퓨팅 디바이스(예: 데이터 프로세싱 시스템(105A-N), 여기에 설명된 다른 컴퓨팅 디바이스, 식별자 서버 등) 및 작은 수의 작업자(예를 들어, 작업자 컴퓨팅 디바이스(405A-N), 여기에 설명된 다른 컴퓨팅 디바이스 등)을 포함하여, 스케치를 결합하기 위한 보안 프로토콜을 실행한다. 스케치를 결합하기 위한 보안 프로토콜은 이 섹션에 설명된 계단식 군단 스케치를 사용하여, 섹션 A에서 위에 설명된 MPC 프로토콜일 수 있다. 다음으로, 시스템은 ElGamal 암호화 시스템을 사용하여 스케치를 암호화할 수 있으며, 섹션 A에서 위에서 설명한 CBF 설계와 마찬가지로 공지된 값을 복호화하기 위해 시스템은 곱셈 동형화(예: ElGamal 암호화 사용 등)를 사용하여 지수가 같은 밑수를 곱하면 가산된다는 것을 관찰함으로써 추가를 달성할 수 있다. 예를 들어 2 ^ 5 * 2 ^ 5 = 2 ^ 10이다. 셋째, 고유한 ElGamal 공개 키가 결합될 수 있으며 해당 복호화(또는 일부 개인 키만 사용되는 경우 부분 복호화 등)은 해당 공용 키가 조합의 일부인 각 개인 키를 적용할 수 있다. 각 작업자는 키 쌍을 생성할 수 있고, 결합된 공개 키는 퍼블리셔 컴퓨팅 디바이스(예를 들어, 데이터 프로세싱 시스템(105A-N), 여기에 설명된 다른 컴퓨팅 디바이스, 식별자 서버 등)에 의해 사용되어 스케치를 암호화할 수 있다.To perform cascade swarm cardinality or frequency estimation, a system (eg, system 100, system 400A-C, any combination thereof, etc.) may perform any combination of the following processes. First, the system can generate multiple (e.g., 1, 10, 100, 1000, or 10000 publisher computing devices (e.g., data processing systems 105A-N, other computing devices described herein, identifier servers, etc.) and a small number of workers (e.g., worker computing devices 405A-N) , other computing devices described herein, etc.) to execute secure protocols for combining sketches. A secure protocol for combining sketches may be the MPC protocol described above in Section A, using the cascading corps sketch described in this section. Next, the system can encrypt the sketch using the ElGamal cryptosystem, and similar to the CBF design described above in Section A, to decrypt the known value, the system uses multiplicative isomorphism (e.g., using ElGamal cryptography) to exponentiate Addition can be achieved by observing that multiplied by the same base adds up. For example 2^5 * 2^5 = 2^10. Third, unique ElGamal public keys can be combined, and corresponding decryption (or partial decryption, etc. if only some private keys are used) can be applied to each private key for which that public key is part of the combination. Each worker can generate a key pair, and the combined public key is used by a publisher computing device (eg, data processing systems 105A-N, other computing devices described herein, identifier servers, etc.) to sketch can be encrypted.
각각의 작업자 컴퓨팅 디바이스(예를 들어, 작업자 컴퓨팅 디바이스(405A-N), 애그리게이터 컴퓨팅 디바이스(410) 등))는 여기에 설명된 바와 같이 공개 키를 교환하고 결합하여 집합된 공개 키를 생성할 수 있다. 집합된 공개 키(예: 결합된 ElGamal 또는 동형 추가 암호화 체계 키 등)가 생성되면 프로토콜은 다음과 같이 진행될 수 있다. 각 퍼블리셔 컴퓨팅 디바이스는 스케치를 암호화하여 적어도 하나의 작업자 컴퓨팅 디바이스(예: 작업자 컴퓨팅 디바이스(405A), 애그리게이터 컴퓨팅 디바이스(410 등))에 제공할 수 있고, 이는 때때로 제1 작업자 컴퓨팅 디바이스로 지칭될 수 있다. Each of the worker computing devices (eg, worker computing devices 405A-N, aggregator computing devices 410, etc.) may exchange and combine public keys to generate an aggregated public key as described herein. can Once the aggregated public key (e.g. combined ElGamal or Homomorphic Addition Cryptographic Scheme key, etc.) is generated, the protocol can proceed as follows. Each publisher computing device may encrypt and provide the sketch to at least one worker computing device (eg, worker computing device 405A, aggregator computing device 410, etc.), which will sometimes be referred to as a first worker computing device. can
상기 제1 작업자 컴퓨팅 디바이스는 각 스케치 포지션 별(예를 들어, 버킷 별, 각 카운터 레지스터, 변수 또는 유사한 인덱스 값 또는 포지션을 가진 데이터 항목의 결합 또는 각각의 각 군단의 각 포지션)을 합산하여 결합된 스케치를 생성할 수 있다. 결합된 스케치는 각각의 식별자 서버(예를 들어, 때때로 퍼블리셔 컴퓨팅 디바이스로 지칭되는 데이터 프로세싱 시스템(105A-N))로부터 수신된 각각의 스케치와 동일한 규모일 수 있거나 규모를 수용하도록 구성될 수 있다. 일부 구현예에서, 계단식 군단 스케치가 비트 행렬 데이터 구조인 경우, 스케치를 결합하는 것은 결합될 모든 스케치에 대해 비트 OR 연산을 수행하는 것을 포함할 수 있다. 일부 구현예에서, 계단식 군단 스케치가 값 행렬 데이터 구조(예를 들어, 다른 유형의 변수, 값 또는 카운터 레지스터 등의 행렬)인 경우, 제1 작업자는 다른 유형의 조합 연산(예를 들어, 추가, 곱셈, 동형 추가 등)을 본 명세서에 기술된, 결합될 스케치에 걸쳐 수행할 수 있다. The first worker computing device sums each sketch position (eg, each bucket, each counter register, variable, or combination of data items having similar index values or positions, or each position of each group) to combine You can create sketches. The combined sketch may be of the same scale as each sketch received from each identifier server (eg, the data processing systems 105A-N, sometimes referred to as publisher computing devices) or may be configured to accommodate the scale. In some implementations, where the cascading corps sketches are bit matrix data structures, combining the sketches can include performing a bitwise OR operation on all sketches to be combined. In some implementations, if the cascading corps sketch is a value matrix data structure (e.g., a matrix of different types of variables, values, or counter registers), the first operator may perform other types of combinatorial operations (e.g., add, multiplication, isomorphic addition, etc.) can be performed across the sketches to be combined, as described herein.
시스템(예를 들어, 시스템(405A-C))의 작업자 컴퓨팅 디바이스(예를 들어, 작업자 컴퓨팅 디바이스(405A-N), 애그리게이터 컴퓨팅 디바이스(410) 등))는 섹션 A에 설명된 MPC 프로토콜과 관련하여 위에서 설명한 바와 같이, 결정론적 암호화 레이어를 적용하고 비결정론적 암호화 레이어를 제거하면서 결합된 스케치를 셔플링할 수 있다. 예를 들어, 제1 작업자 컴퓨팅 디바이스는 포지션 및 군단에 걸쳐 비트(또는 행렬의 다른 유형의 데이터 등)를 셔플링하고, 그 결과를 제2 작업자 컴퓨팅 디바이스로 전달한다. 암호화되고 결합된 스케치를 셔플링하기 전에, 각 작업자 컴퓨팅 디바이스는 집합된 암호화 키에 대한 해당 작업자 기여에 대응하는 개인 복호화 키(예: 작업자 컴퓨팅 디바이스에 의해 생성된 집합된 ElGamal 암호화 키 등)를 사용하여 스케치를 부분적으로 복호화할 수 있다. 개인 복호화 키를 사용하여 스케치를 부분적으로 복호화한 후, 현재 스케치를 프로세싱 중인 작업자 컴퓨팅 디바이스는 스케치에 결정론적 암호화 체계를 적용할 수 있다. 결정론적 암호화 레이어를 적용한 후, 작업자 컴퓨팅 디바이스는 암호화된 데이터 구조의 포지션을 순열하거나 셔플링할 수 있다. 데이터 구조가 계단식 군단 데이터 구조인 경우, 작업자 컴퓨팅 디바이스는 l군단 각각에서 n개의 포지션을 순열할 수 있다. 일부 구현예에서, 작업자 컴퓨팅 디바이스는 l 군단의 순서를 순열화할 수 있다. The worker computing devices (eg, worker computing devices 405A-N, aggregator computing devices 410, etc.) of the system (eg, systems 405A-C) may use the MPC protocol described in Section A and As described above, the combined sketch can be shuffled while applying a deterministic encryption layer and removing a non-deterministic encryption layer. For example, a first worker computing device shuffles bits (or other types of data in a matrix, etc.) across positions and corps, and passes the result to a second worker computing device. Prior to shuffling the encrypted and combined sketches, each worker compute device uses a private decryption key corresponding to its worker contribution to the aggregated encryption key (e.g., the aggregated ElGamal encryption key generated by the worker compute device). to partially decrypt the sketch. After partially decrypting the sketch using the private decryption key, a worker computing device currently processing the sketch may apply a deterministic encryption scheme to the sketch. After applying the deterministic encryption layer, the worker computing device may permutate or shuffle the positions of the encrypted data structure. If the data structure is a cascaded corps data structure, the worker computing device may permutate n positions in each of the l corps. In some implementations, the worker computing device may permutate the order of the corps.
이 프로세스는 작업자 컴퓨팅 디바이스(405) 각각에 대해 계속될 수 있다. 예를 들어, 제2 작업자 컴퓨팅 디바이스(예를 들어, 작업자(405B) 등)는 비결정론적 암호화 레이어를 제거하고, 결정론적 암호화 레이어를 추가하고, 선택적으로 순열화할 수 있다. 그 다음, 제2 작업자는 프로세싱된 스케치 결과를 제3 작업자 컴퓨팅 디바이스(예를 들어, 작업자(405C) 등)에 전송할 수 있다. 이 프로세스는 각 작업자 컴퓨팅 디바이스가 비결정론적 암호화 레이어를 제거(예: 집합된 암호화 키를 생성하는데 사용되는 공개 암호화 키로 생성된 개인 복호화 키 사용하여)할 때까지 계속할 수 있고, 결정론적 암호화 레이어를 적용하고, 선택적으로 스케치를 순열화할 수 있다.This process may continue for each worker computing device 405 . For example, a second worker computing device (eg, worker 405B, etc.) can remove a non-deterministic encryption layer, add a deterministic encryption layer, and optionally permutate. The second worker may then transmit the processed sketch result to a third worker computing device (eg, worker 405C, etc.). This process can continue until each worker computing device has removed the non-deterministic encryption layer (e.g., using a private decryption key generated with the public encryption key used to generate the aggregated encryption key), and applies the deterministic encryption layer. and optionally permutate the sketch.
작업자(예를 들어, 작업자(405A-N), 애그리게이터 컴퓨팅 디바이스(410) 등)는 링 구성으로 배열될 수 있다. 이러한 구성에서, 제1 작업자 컴퓨팅 디바이스(예: 작업자(405A) 또는 애그리게이터 컴퓨팅 디바이스(410) 등)는 암호화된 스케치를 프로세싱하고, 출력을 제2 작업자 컴퓨팅 디바이스에 전송할 수 있으며, 제2 작업자는 출력을 제3 작업자 컴퓨팅 디바이스에 전송할 수 있다. 최종 작업자 컴퓨팅 디바이스(예를 들어, 작업자(405N), 여기서 N은 작업자 컴퓨팅 디바이스의 수 등)가 스케치를 프로세싱하면, 출력을 제1 작업자 컴퓨팅 디바이스(예: 작업자 컴퓨팅 디바이스(405A), 애그리게이터 컴퓨팅 디바이스(410) 등)에 전송할 수 있다. 그 후, 제1 작업자 컴퓨팅 디바이스는 비결정론적 암호화를 제거하고, 프로세스의 제1 단계에서 아직 수행하지 않은 경우, 결정론적 암호화 레이어를 추가할 수 있다. 일부 구현예에서, 제1 작업자 컴퓨팅 디바이스는 각각의 스케치를 결합하고, 결합된 암호화된 스케치를 제2 작업자 컴퓨팅 디바이스에 전송할 수 있으며, 비결정론적 암호화 레이어를 제거하고, 링 구성의 각 작업자 컴퓨팅 디바이스에 의해 스케치를 프로세싱한 후 최종 프로세싱 단계로서 결정론적 암호화 레이어를 적용할 수 있다.Workers (eg, workers 405A-N, aggregator computing devices 410 , etc.) may be arranged in a ring configuration. In this configuration, a first worker computing device (such as worker 405A or aggregator computing device 410 ) may process the encrypted sketch and send output to a second worker computing device, which may The output can be sent to a third worker computing device. Once the final worker computing device (e.g., worker 405N, where N is the number of worker computing devices, etc.) processes the sketch, the output is sent to a first worker computing device (e.g., worker computing device 405A, aggregator computing device 410, etc.). The first worker computing device may then remove the non-deterministic encryption and add a layer of deterministic encryption if it has not already done so in the first step of the process. In some implementations, a first worker computing device may combine each sketch, send the combined encrypted sketch to a second worker computing device, remove the non-deterministic encryption layer, and send each worker computing device in a ring configuration. After processing the sketch by , a deterministic encryption layer can be applied as a final processing step.
다음으로, 값 0은 각 작업자에 의해 결정론적으로 암호화되어, 스케치에 있는 0의 수를 나타낸다. 여기에서 카디널리티의 추정치가 계산될 수 있다.Next, the value 0 is deterministically encrypted by each operator, representing the number of 0s in the sketch. An estimate of the cardinality can be calculated here.
일부 구현예에서, 결정론적 암호화 없이 0의 수를 카운팅할 수 있다. 메시지가 지수에 있기 때문에, 시스템은 암호화 0이 그룹의 아이덴티티 엘리먼트일 뿐이라는 사실에 의존할 수 있다. 따라서 결정론적 암호화 대신, 시스템은 모든 암호문에 대해 랜덤 지수를 선택할 수 있다(결정론적 암호화가될 수 있는 모두에 대해 동일한 지수를 사용하는 대신). '0' 엘리먼트는 0으로 유지될 수 있고, 나머지는 랜덤화될 수 있다. 이것은 0의 수만 나타내므로, 시스템의 전반적인 프라이버시를 향상시킬 수 있다. 이 시스템은 전체 카디널리티에서 '참조 군단'을 결정하고, 상기 군단을 골든 업워드로 셔플링할 수 있다.In some implementations, the number of zeros can be counted without deterministic encryption. Since the message is in the exponent, the system can rely on the fact that encryption 0 is only the identity element of the group. So instead of deterministic encryption, the system can choose a random exponent for all ciphertexts (instead of using the same exponent for all that can be deterministic encryption). The '0' element may be maintained as 0, and the rest may be randomized. Since this represents only the number of zeros, it can improve the overall privacy of the system. The system may determine a 'reference corps' from the total cardinality and shuffle the corps into golden upwards.
추정을 위해, 시스템은 버킷 값의 부분 히스토그램을 나타낼 수 있다. 즉, 시스템은 존재하는 0의 카운트를 알 수 있고, 다른 모든 값의 카운트는 1이라고 가정할 수 있다. 다음으로, 스케치에 추가되었던 사용자 식별자에 대해, 히스토그램에 대한 기여도는 "1"의 카운트를 최대 1씩 증가시킬 수 있고, 여기서 히스토그램에 대한 단일 식별자의 기여도는 실제로 해시 충돌로 인해 0일 수 있다. 따라서, 쿼리의 민감도는 1일 수 있다.For estimation purposes, the system can present a partial histogram of bucket values. That is, the system can know how many counts of zeros exist, and can assume that all other values count as one. Next, for user identifiers that have been added to the sketch, the contribution to the histogram can increase the count of "1" by at most one, where the contribution of a single identifier to the histogram can actually be zero due to hash collisions. Therefore, the sensitivity of the query may be 1.
양측 기하학적 분포에서 추출될 수 있는 노이즈 추가는 두 가지 방법 중 하나 이상으로 수행될 수 있다. 더 간단한 구현예는 히스토그램을 작업자에게 마스킹 해제한 다음 추정을 계산하기 전에 각 히스토그램 버킷에 정확한 양의 노이즈를 추가하는 것을 포함할 수 있다. 이로 인해, 계산 결과가 차등적으로 비공개로 할 수 있지만, 작업자는 실제 히스토그램 값을 학습한다.Noise addition, which can be extracted from the bilateral geometric distribution, can be done in one or more of two ways. A simpler implementation might involve unmasking the histogram to the operator and then adding the correct amount of noise to each histogram bucket before calculating the estimate. This allows the calculation results to be differentially private, but the operator learns the actual histogram values.
더 복잡하지만 더 안전한, 노이즈 추가 구현예는 생성을 작업자에게 분산시키는 것을 포함할 수 있다. 이러한 구현예에서, 각 작업자는 두 개의 Polya 랜덤 변수(Xi, Yi)를 그릴 수 있으며, 이는 i번째 작업자에 의해 히스토그램에 추가될 0의 수와 1의 수를 각각 나타낸다. 음이 항의 특수한 경우인 Polya 랜덤 변수는 양측 기하 랜덤 변수를 합산하도록 구성될 수 있다.A more complex, but safer, noise addition implementation may include distributing the production to operators. In this implementation, each operator can draw two Polya random variables (Xi, Yi), representing the number of zeros and the number of ones, respectively, that will be added to the histogram by the ith operator. A Polya random variable, which is a special case of negative terms, can be constructed to sum two-sided geometric random variables.
첫째, 작업자는 각 버킷에 추가될 노이즈의 임의 기준에 동의하는 것으로 시작할 수 있다. 이 값을 B라고 한다. 그 다음 셔플 단계 동안, 각 작업자는 B-X 0을 스케치에 추가하고 B-Y 1을 스케치에 추가할 수 있다. 마지막으로, 히스토그램을 집합하는 작업자는 각 히스토그램 버킷에서 B * W 값을 뺄 수 있고, 여기서 W는 작업자 수이다. 그 후, 필요한 노이즈 분포가 남는다.First, operators can start by agreeing on an arbitrary criterion of noise to be added to each bucket. Let this value be B. During the next shuffle phase, each operator can add B-X 0 to the sketch and B-Y 1 to the sketch. Finally, the worker aggregating the histogram can subtract B * W values from each histogram bucket, where W is the number of workers. After that, the required noise distribution remains.
확률적 디컨벌루션 및 빈도 히스토그램 추정을 포함하여 빈도 히스토그램 추정을 위한 두 가지 이상의 옵션이 있다.There are at least two options for frequency histogram estimation, including stochastic deconvolution and frequency histogram estimation.
계단식 군단을 사용하여 멀티세트의 빈도를 추정하는 적어도 하나의 기법은 확률적 디컨벌루션에 기초한다. 확률적 디컨벌루션 기법은 작업자 컴퓨팅 디바이스(예를 들어, 작업자 컴퓨팅 디바이스(405A-N), 애그리게이터 컴퓨팅 디바이스(410) 등)에 의해 생성된 최종 복호화된, 집합된 및 선택적으로 셔플링된 계단식 군단 스케치에 기초하여 빈도 히스토그램을 생성할 수 있다. 빈도 히스토그램을 추정하기 위해, self.legions(예: legions 데이터 구조 등)는 약간의 존재가 아닌 사용자 식별자와 연관된 빈도를 저장할 수 있다. 이러한 구현예에서, 계단식 군단 데이터 구조는 비트 값의 행렬이 아니라, 대신 여기에 설명된 대로 업데이트되는 빈도 값의 행렬이 되도록 생성된다. 작업자 컴퓨팅 디바이스(405A-N)에 의해 생성된 집합된 공개 키를 사용하여 암호화될 때, 각 군단의 각 포지션의 빈도 값은 일부 소수의 거듭 제곱으로 바뀔 수 있다(예를 들어, 각 군단의 각 포지션은 집합된 키를 사용하여 독립적으로 암호화된다). 일부 구현예에서, 다른 암호화 체계가 사용되며, 각 군단은 집합된 공개 키를 사용하여 독립적으로 암호화된다. 일부 구현예에서, 전체 계단식 군단 데이터 구조는 포지션별 또는 군단별이 아닌 집합된 공개 키를 사용하여 한 번 암호화된다.At least one technique for estimating the frequencies of multisets using cascades is based on stochastic deconvolution. The stochastic deconvolution technique uses the final decrypted, aggregated and optionally shuffled cascade swarm generated by worker computing devices (e.g., worker computing devices 405A-N, aggregator computing devices 410, etc.) You can create a frequency histogram based on your sketch. To estimate the frequency histogram, self.legions (e.g. the legions data structure, etc.) can store the frequencies associated with some non-existent user identifier. In such an implementation, the cascade corps data structure is created to be not a matrix of bit values, but instead a matrix of frequency values that are updated as described herein. When encrypted using the aggregated public key generated by worker computing devices 405A-N, the frequency value of each position in each corps can be changed by some power of a prime number (e.g., each position in each corps Positions are independently encrypted using the aggregated key). In some implementations, other cryptographic schemes are used, and each corps is independently encrypted using an aggregated public key. In some implementations, the entire cascade corps data structure is encrypted once using an aggregated public key that is neither position-specific nor corp-specific.
시스템은 참조 군단(예: 포지션의 절반 미만이 활성화된 첫 군단 등)에 도달할 때까지 왼쪽에서 오른쪽으로(예: 군단 색인의 오름차순 또는 내림차순 등) 군단을 복호화할 수 있다. 예를 들어, 집합된 데이터 구조가 각각의 작업자 컴퓨팅 디바이스(예: 작업자 컴퓨팅 디바이스(405), 애그리게이터 컴퓨팅 디바이스(410) 등)에 의해 프로세싱되면, 애그리게이터 컴퓨팅 디바이스는 계단식 군단 데이터 구조의 각 군단을 점진적으로 복호화할 수 있다. 군단이 복호화되면, 애그리게이터 컴퓨팅 디바이스는 군단에 채워지는 포지션의 수를 결정할 수 있다. 애그리게이터 컴퓨팅 디바이스는 복호화된 군단의 각 포지션을 반복하고 포지션 값이 0인지(또는 임계 값 미만 또는 다른 미리 결정된 값과 같은지 또는 일부 다른 비-집단 기준을 만족하는지 여부)를 결정함으로써 채워지는 군단의 포지션의 수를 결정할 수 있다. 애그리게이터 컴퓨팅 디바이스는 해당 군단의 포지션의 절반 미만이 채워지면 특정 군단이 참조 군단이라고 결정할 수 있다. 애그리게이터 컴퓨팅 디바이스가 군단이 참조 군단이 아니라고 결정하면, 애그리게이터 컴퓨팅 디바이스는 계단식 군단 데이터 구조에서 다음 군단을 복호화할 수 있다. 계단식 군단 데이터 구조의 다음 군단은 예를 들어, 다음으로 큰 군단 색인에 대응하는 군단이거나 다음 군단을 식별하는 다른 메트릭(예: 다음 메모리 주소 등)일 수 있다. The system can decode the swarms from left to right (eg ascending or descending order of swarm index, etc.) until it reaches the reference swarm (eg the first swarm with less than half of the positions active, etc.). For example, once the aggregated data structures are processed by each worker computing device (e.g., worker computing device 405, aggregator computing device 410, etc.), the aggregator computing device then cascades each corps of the corps data structure. can be decrypted incrementally. Once the swarm is decrypted, the aggregator computing device may determine the number of positions to be filled in the swarm. The aggregator computing device determines the number of swarms that are populated by iterating over each position in the decoded swarm and determining whether the position value is zero (or less than a threshold or equal to some other predetermined value, or satisfies some other non-swarm criterion). The number of positions can be determined. The aggregator computing device may determine that a particular corps is a reference corps if less than half of the positions of that corps are filled. If the aggregator computing device determines that the swarm is not a reference swarm, the aggregator computing device can decode the next swarm in the cascading swarm data structure. The next swarm in the cascading swarm data structure can be, for example, the swarm corresponding to the next larger swarm index or some other metric that identifies the next swarm (eg, next memory address, etc.).
참조 군단부터, 적은 수의 충돌이 있을 수 있다. 따라서 시스템은 모든 군단을 함께 셔플링한 후 복호화할 수 있다. 빈도는 결과 빈도 히스토그램을 결정하기 위한 샘플로 사용된다. 충돌 후 히스토그램을 관찰한 가장 가능성이 높은 원래 히스토그램을 찾아 일부 조정을 수행할 수 있다. 이 접근법은 둘 이상의 사용자가 기여한 레지스터(예: 포지션 등)를 필터링하고 사용자 빈도의 깨끗한 샘플을 얻기 위한 동형 암호화를 포함할 수 있다. From the reference corps, there may be fewer collisions. Thus, the system can decrypt after shuffling all the swarms together. The frequencies are used as samples to determine the resulting frequency histogram. You can make some adjustments by finding the most likely original histogram observed post-collision histogram. This approach may include homomorphic encryption to filter registers contributed by more than one user (e.g. positions, etc.) and obtain a clean sample of user frequencies.
동일한 키 집합 구조는 암호화된 카운터와 키(E(count), E(key)) 쌍이다. 계단식 군단 데이터 구조에 대한 추가는 다음과 같이 정의할 수 있다:The same key set structure is an encrypted counter and key (E(count), E(key)) pair. An addition to the cascading swarm data structure can be defined as:
(E(count1), E(key1)) + (E(count2), E(key2)) = (E(count1 + count2 + R * (key1 - key2)), E(key1 + R * (key1 - key2)).(E(count1), E(key1)) + (E(count2), E(key2)) = (E(count1 + count2 + R * (key1 - key2)), E(key1 + R * (key1 - key2) )).
여기서 R은 난수이다. 이 추가 연산은 동형으로 계산될 수 있다.where R is a random number. This addition operation can be computed isomorphically.
이 구조는 다음과 같이 작동할 수 있다.This structure can work as follows.
If key1 = key2 = key then If key1 = key2 = key then
(E(count1), E(key)) + (E(count2), E(key)) = (E(count1 + count2), E(key)).(E(count1), E(key)) + (E(count2), E(key)) = (E(count1 + count2), E(key)).
계단식 군단을 사용하여 멀티세트의 빈도를 추정하는 적어도 하나의 다른 기법은 빈도 히스토그램 추정에 기초한다. 빈도 히스토그램 추정 기반 기법은 추가 추정 및 프로세싱을 위해 빈도 히스토그램을 생성하여 특정 목표 기준의 빈도를 추정할 수 있다. 각 레지스터(예: 군단 포지션 등)에 대해 시스템은 동일한 키 애그리게이터를 추가할 수 있다. 퍼블리셔 컴퓨팅 디바이스(예를 들어, 식별자 서버, 데이터 프로세싱 시스템(105A-N) 등)는 레지스터를 키로 개시하는 가상 ID의 해시를 사용할 수 있다. 퍼블리셔 컴퓨팅 디바이스에 디바이스 식별자가 없는 경우 특수한 빈 토큰을 추가한다. 레지스터 부울이 먼저 결합되고, 결합되지 않은 노출 애그리게이터가 함께 셔플링될 수 있다. 0이 아닌 레지스터의 경우, 빈 토큰이 복호화되고 폐기된다. 나머지 노출 애그리게이터가 결합될 수 있다. 그 후, 카운터가 복호화된다.At least one other technique for estimating the frequencies of multisets using cascades is based on frequency histogram estimation. Frequency histogram estimation-based techniques can estimate the frequency of a particular target criterion by generating a frequency histogram for further estimation and processing. For each register (e.g. corps position, etc.) the system can add the same key aggregator. A publisher computing device (eg, an identifier server, data processing systems 105A-N, etc.) may use the hash of the virtual ID starting register as a key. Adds a special empty token if the publisher computing device does not have a device identifier. Register booleans may be combined first, then uncoupled exposure aggregators may be shuffled together. For non-zero registers, empty tokens are decrypted and discarded. The remaining exposure aggregators may be combined. After that, the counter is decrypted.
시스템은 각 계단식 군단 데이터 구조의 생성에 기여한 디바이스 식별자 및 속성의 프라이버시를 가리거나 보호하기 위해 각 계단식 군단 데이터 구조에 차등 프라이버시 보호를 적용할 수 있다. 예를 들어, 각 퍼블리셔 컴퓨팅 디바이스(예를 들어, 식별자 서버, 데이터 프로세싱 시스템(105A-N) 등)는 비트를 무작위로 플립핑하여 계단식 군단 스케치에 차등 개인 노이즈를 적용하는 것을 보호할 수 있으며, 위 섹션 A에서 설명한 블룸 필터를 사용하여 수행하는 방식과 유사하게 수행한다. 일부 구현예에서, 스케치의 각 포지션이 빈도 추정을 위한 카운터 레지스터이면, 차등 프라이버시는 군단에서 랜덤 포지션을 무작위로 추가, 업데이트 또는 증가함으로써 구현될 수 있다. 예를 들어, 이러한 노이즈는 1, 2 등과 같은 미리 결정된 양만큼 증가하거나 특정 임계 값(예를 들어, 0과 100 사이의 난수 또는 임의의 다른 범위 등) 내에서 임의의 양만큼 증가함으로써 추가될 수 있다. The system may apply differential privacy protection to each cascade data structure to obscure or protect the privacy of device identifiers and attributes that contributed to the creation of each cascade data structure. For example, each publisher computing device (e.g., identifier server, data processing systems 105A-N, etc.) may randomly flip bits to protect against applying differential personal noise to cascade sketches; This is done similarly to how it is done using the Bloom filter described in Section A above. In some implementations, where each position in the sketch is a counter register for frequency estimation, differential privacy can be implemented by randomly adding, updating, or incrementing random positions in a swarm. For example, such noise can be added by increasing by a predetermined amount, such as 1, 2, etc., or by increasing by any amount within a certain threshold (eg, a random number between 0 and 100, or any other range, etc.) there is.
시스템은 확률 p로 각 군단 x 포지션(예를 들어, 또는 위에서 설명한 카운터 레지스터에 추가 등)를 플립핑하여 노이즈를 적용할 수 있다. k 스케치의 경우, 일부 포지션에서 비트 b의 조합이 있는 경우, 이 조합은 확률 p^(k-a)*(1-p)^a와 함께 비트(b')의 조합으로 변환되며, 여기서 a는 b_i=b'_i인 포지션 i의 수이다. 이 근거를 카운터 레지스터 기반 빈도 군단에 적용할 때, 0과 같거나 같지 않은 포지션에 대해 동일한 분석이 적용된다(예: 이 분석에서 0과 같은 모든 포지션은 이진 0으로 취급될 수 있으며, 0과 같지 않은 모든 포지션은 이 분석에서 이진 1로 취급될 수 있다.) 따라서 시스템은 조합 전환의 확률 행렬을 계산하고 반전에 의해 노이즈 보정 행렬을 얻을 수 있다. The system can apply noise by flipping each swarm x position (e.g., or adding to a counter register as described above) with probability p. For k sketch, if there is a combination of bits b at some position, this combination is transformed into a combination of bits b' with probability p^(k-a)*(1-p)^a, where a is b_i = b'_i is the number of positions i. When applying this rationale to the counter-register-based frequency corps, the same analysis applies for positions equal to or not equal to zero (e.g. in this analysis any position equal to zero can be treated as binary zero, and equal to zero equals zero). All positions that do not match can be treated as binary 1s in this analysis.) Therefore, the system can calculate the probability matrix of combination transitions and obtain a noise correction matrix by inversion.
시스템은 참조 군단에 기초하여 카디널리티 또는 빈도를 추정할 수 있다. 따라서 시스템은 결합된 계단식 군단 스케치를 (예를 들어, 작업자 컴퓨팅 디바이스 및 애그리게이터 컴퓨팅 디바이스 등에 의해 프로세싱된 후) 블룸 필터의 모음 또는 카운팅 블룸 필터로 취급하거나, 노이즈가 가장 적은 것을 선택할 수 있다. 시스템은 참조 군단을 선택하는데 휴리스틱을 사용할 수 있다: 비트의 절반 미만으로 포화된 제1 군단(노이즈 제거가 적용된 후) 또는 카운터 레지스터의 경우 포지션의 절반 미만이 채워진 제1 군단으로 선택될 수 있다. 각 군단은 집단의 확률이 감소하는 순서로 분석될 수 있다. 예를 들어 각 군단은 기초하여 채워질 수 있다. The system can estimate cardinality or frequency based on the reference corps. Thus, the system may treat the combined cascade swarm sketch as a collection of bloom filters or counting bloom filters (eg, after being processed by worker computing devices and aggregator computing devices, etc.), or select the one with the least noise. The system may use a heuristic to select a reference corps: either the first corps that is less than half full of bits (after noise cancellation is applied) or, in the case of counter registers, the first corps that are less than half full of positions. Each corps can be analyzed in order of decreasing probability of the population. For example, each corps can be populated based on
이제 도 5를 참조하면, 도시된 것은 식별자 값 및 속성 데이터에 기초하여 계단식 군단 데이터 구조를 생성하기 위한 방법(2000)의 흐름도이다. 방법(2000)은 예를 들어, 적어도 하나의 데이터 프로세싱 시스템(예를 들어, 적어도 하나의 데이터 프로세싱 시스템(105) 등) 또는 여기에 설명된 임의의 다른 컴퓨팅 디바이스에 의해 수행될 수 있다. 데이터 프로세싱 시스템은 데이터 레코드를 유지할 수 있다(동작 2002). 데이터 프로세싱 시스템은 빈 계단식 군단 데이터 구조를 생성할 수 있다(동작 2004). 데이터 프로세싱 시스템은 k번째 데이터 레코드를 선택할 수 있다(동작 2006). 데이터 프로세싱 시스템은 선택된 데이터 레코드를 해시할 수 있다(동작 2008). 데이터 프로세싱 시스템은 군단을 선택할 수 있다(동작 2010). 데이터 프로세싱 시스템은 포지션 식별자를 추출할 수 있다(동작 2012). 데이터 프로세싱 시스템은 선택한 레지스터 군단에서 포지션을 업데이트할 수 있다(동작 2014). 데이터 프로세싱 시스템은 카운터 레지스터 k가 데이터 레코드의 수 n과 동일한지 여부를 결정할 수 있다(동작 2016). 데이터 프로세싱 시스템은 카운터 레지스터 k를 증가시킬 수 있다(동작 2018). 데이터 프로세싱 시스템은 집합된 암호화 키를 획득할 수 있다(동작 2020). 데이터 프로세싱 시스템은 벡터 카운터 레지스터를 암호화할 수 있다(동작 2022). 데이터 프로세싱 시스템은 암호화된 벡터를 전송할 수 있다(동작 2024).Referring now to FIG. 5 , shown is a flow diagram of a method 2000 for generating a cascaded swarm data structure based on identifier values and attribute data. Method 2000 may be performed by, for example, at least one data processing system (eg, at least one data processing system 105 , etc.) or any other computing device described herein. The data processing system may maintain data records (act 2002). The data processing system may create an empty cascade corps data structure (act 2004). The data processing system may select the kth data record (act 2006). The data processing system may hash the selected data record (act 2008). The data processing system may select a swarm (act 2010). The data processing system may extract the position identifier (act 2012). The data processing system may update the positions in the selected register corps (act 2014). The data processing system may determine whether the counter register k is equal to the number of data records n (act 2016). The data processing system may increment the counter register k (act 2018). The data processing system may obtain the aggregated encryption key (act 2020). The data processing system may encrypt the vector counter register (act 2022). The data processing system may transmit the encrypted vector (act 2024).
데이터 프로세싱 시스템은 데이터 레코드를 유지할 수 있다(동작 2002). 데이터 레코드(예를 들어, 데이터 레코드(122A-N))는 예를 들어 하나 이상의 디바이스 식별자(예를 들어, 클라이언트 식별자(122A-N)) 및 하나 이상의 속성(예를 들어, 속성(127A-N))을 포함할 수 있다. 데이터 레코드는 데이터 프로세싱 시스템에 통신적으로 결합된 데이터베이스(예를 들어, 데이터베이스(115))에 저장된 하나 이상의 데이터 구조일 수 있다. 데이터 레코드를 유지하는 것은 컴퓨터 메모리에 하나 이상의 데이터 레코드를 저장하는 것을 포함할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 하나 이상의 메시지(예를 들어, 요청, 표시, 데이터 패킷 등)를 수신하는 것에 응답하여 데이터 레코드를 적어도 하나의 클라이언트 디바이스(예를 들어, 적어도 하나의 클라이언트 디바이스(120))에 유지할 수 있다. 데이터 프로세싱 시스템은 메시지의 속성과 함께 메시지로부터 적어도 하나의 식별자를 추출하고 식별자 및 속성을 포함하는 데이터 레코드를 생성할 수 있다. 데이터 프로세싱 시스템은 데이터베이스, 하나 이상의 데이터 구조 또는 비휘발성 컴퓨터 판독가능 매체와 같은 컴퓨터 메모리에 데이터 레코드를 유지(예를 들어, 저장, 로드 또는 기록)할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 하나 이상의 클라이언트 디바이스(예를 들어, 클라이언트 디바이스(120A-N) 등)로부터 하나 이상의 데이터 레코드를 수신할 수 있다. The data processing system may maintain data records (act 2002). Data records (eg, data records 122A-N) may include, for example, one or more device identifiers (eg, client identifiers 122A-N) and one or more attributes (eg, attributes 127A-N). )) may be included. A data record may be one or more data structures stored in a database (eg, database 115) communicatively coupled to the data processing system. Maintaining data records may include storing one or more data records in a computer memory. In some implementations, the data processing system, in response to receiving one or more messages (eg, requests, indications, data packets, etc.), sends data records to at least one client device (eg, at least one client device ( 120)). The data processing system may extract at least one identifier from the message along with attributes of the message and create a data record containing the identifier and attributes. A data processing system may maintain (eg, store, load, or write) records of data in computer memory, such as a database, one or more data structures, or non-volatile computer-readable media. In some implementations, the data processing system can receive one or more data records from one or more client devices (eg, client devices 120A-N, etc.).
데이터 프로세싱 시스템은 계단식 군단 데이터 구조를 생성할 수 있다(동작 2004). 계단식 군단 데이터 구조를 생성하기 위해, 데이터 프로세싱 시스템은 적어도 하나의 비트 어레이, 적어도 하나의 카운터 레지스터 어레이 또는 적어도 하나의 카운터 레지스터를 수용하기 위해 하나 이상의 메모리 영역을 할당할 수 있다. 할당된 적어도 하나의 비트 어레이, 적어도 하나의 카운터 레지스터 어레이 또는 적어도 하나의 카운터 레지스터는 계단식 군단 데이터 구조의 적어도 하나의 좌표(예를 들어, 특정 군단에서의 포지션 등)에 대응할 수 있다. 하나 이상의 카운터 레지스터에 대한 메모리를 생성하고 할당함으로써, 데이터 프로세싱 시스템은 카운터 레지스터를 포함하는 벡터를 생성할 수 있다. 데이터 프로세싱 시스템은 비트 어레이 또는 카운터 레지스터 어레이일 수 있는 적어도 하나의 군단을 생성할 수 있다. 데이터 프로세싱 시스템은 생성된 각 군단에 군단 ID(예를 들어, 위에서 사용된 군단 식별자 l 등)를 할당할 수 있고, 각 군단의 각 포지션(예컨대, 각 비트, 카운터 레지스터 등)에 포지션 식별자를 할당할 수 있다. 일부 구현예에서, 포지션 식별자는 군단 간에 동일할 수 있지만 동일한 군단 간에는 다를 수 있다. 예를 들어, 특정 군단의 모든 포지션은 다른 포지션 식별자를 가질 수 있지만, 두 개의 다른 군단에 있는 유사한 포지션은 동일한 식별자를 가질 수 있다. 데이터 프로세싱 시스템은 계단식 군단 데이터 구조의 각 포지션(예를 들어, 비트 값 또는 카운터 레지스터 등)를 초기화 값, 예를 들어 0 또는 1로 초기화할 수 있다. 데이터 프로세싱 시스템은 카운터 레지스터 또는 비트 값의 행렬에 대응할 수 있는 계단식 군단 데이터 구조를 생성할 수 있으며, 행렬의 각 포지션은 때때로 "버킷" 또는 "버킷들"이라고 한다. 예를 들어, 데이터 프로세싱 시스템은 버킷 당 l개의 군단과 n개의 포지션 또는 l군단에 걸쳐 lxn개의 버킷이 있는 계단식 군단 데이터 구조를 생성하라는 표시를 수신할 수 있다. 데이터 프로세싱 시스템은 군단, 버킷, 비트 포지션, 카운터 레지스터 또는 여기에 설명된 임의의 다른 가능한 파라미터에 의해 계단식 군단 데이터 구조의 크기를 지정하는 외부 컴퓨팅 디바이스에 의해 제공되는 내부 구성 설정에 액세스할 수 있다.The data processing system may create a cascaded swarm data structure (act 2004). To create the cascaded corps data structure, the data processing system may allocate one or more memory regions to accommodate at least one bit array, at least one counter register array, or at least one counter register. The assigned at least one bit array, at least one counter register array, or at least one counter register may correspond to at least one coordinate (eg, a position in a specific corps) of a cascade data structure. By creating and allocating memory for one or more counter registers, the data processing system can create vectors containing the counter registers. The data processing system may create at least one corps, which may be a bit array or a counter register array. The data processing system may assign a corps ID (eg, corps identifier l as used above) to each corps created, and assign a position identifier to each position of each corps (eg, each bit, counter register, etc.) can do. In some implementations, the position identifier may be the same between corps, but may be different between the same corps. For example, all positions in a particular corps may have different position identifiers, but similar positions in two different corps may have the same identifier. The data processing system may initialize each position (eg, bit value or counter register, etc.) of the cascade data structure to an initialization value, eg, 0 or 1. Data processing systems may create cascaded corps data structures that may correspond to counter registers or matrices of bit values, each position of the matrix is sometimes referred to as a "bucket" or "buckets." For example, the data processing system may receive an indication to create a cascaded corps data structure with l corps per bucket and n positions or lxn buckets across l corps. The data processing system may access internal configuration settings provided by the external computing device that specify the size of the cascaded corps data structure by swarm, bucket, bit position, counter register, or any other possible parameter described herein.
데이터 프로세싱 시스템은 k번째 데이터 레코드를 선택할 수 있다(동작 2006). 생성된 계단식 군단 데이터 구조에 동작 2002에서 유지되는 각 데이터 레코드를 프로세싱하고 추가하기 위해, 데이터 프로세싱 시스템은 데이터 프로세싱 시스템에서 유지하는 데이터 레코드 각각에 대해 반복할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 카운터 레지스터 k에 기초하여 데이터 레코드 각각을 반복적으로 루프할 수 있다. 예를 들면, 데이터 레코드 각각은 인덱스 값(예를 들어, 인덱스 0, 인덱스 1, 인덱스 2 등)에 의해 데이터 구조에서 인덱스될 수 있다. 데이터 레코드를 프로세싱하기 위해, 데이터 프로세싱 시스템은 카운터 레지스터 k와 동일한(거의 동일한) 인덱스 값을 포함하거나 그와 연관된 데이터 레코드를 선택할 수 있다. 그것이 루프의 첫 번째 반복이라면, 카운터 레지스터 k는 k번째 데이터 레코드를 선택하기 전에 초기화 값(예를 들어, k = 0, k = 1 등)으로 초기화될 수 있다. 데이터 레코드를 선택하는 것은 데이터 레코드와 연관된 데이터를 데이터 프로세싱 시스템의 컴퓨터 메모리의 다른 영역, 예를 들어 메모리의 작업 영역에 복사하는 것을 포함할 수 있다. 데이터 레코드를 선택하는 것은 데이터 레코드가 데이터베이스에 있는 경우 데이터베이스에서 데이터 레코드를 검색하고, 샘플과 연관된 데이터를 데이터 프로세싱 시스템의 다른 컴퓨터 메모리 영역(예: 메모리의 작업 영역)에 복사하는 것을 포함할 수 있다.The data processing system may select the kth data record (act 2006). To process and add each data record maintained in operation 2002 to the created cascade data structure, the data processing system may iterate for each data record maintained by the data processing system. In some implementations, the data processing system can iteratively loop through each data record based on the counter register k. For example, each data record may be indexed in the data structure by an index value (eg, index 0, index 1, index 2, etc.). To process a data record, the data processing system may select a data record that contains or is associated with the same (almost the same) index value as counter register k. If it is the first iteration of the loop, the counter register k may be initialized to an initialization value (e.g., k = 0, k = 1, etc.) prior to selecting the kth data record. Selecting the data record may include copying data associated with the data record to another area of computer memory of the data processing system, for example a working area of memory. Selecting the data record may include retrieving the data record from the database, if the data record exists in the database, and copying the data associated with the sample to another computer memory area (eg, a working area of memory) of the data processing system. .
데이터 프로세싱 시스템은 선택된 데이터 레코드를 해시할 수 있다(동작 2008). 데이터 프로세싱 시스템은 계단식 군단 데이터 구조를 채우는데 사용할 해시 함수를 식별하고 실행할 수 있다. 예를 들어, 해시 목록에서 식별된 각 해시는 입력 값에 기초하여 정규 분포 또는 임의성 기대치를 제공할 수 있다. 즉, 예를 들어 해시 함수에 대한 유사한 입력이 반드시 해시 함수와 유사한 출력을 갖는 것은 아니다. 해시 함수는 계단식 군단 데이터 구조를 위한 최적의 해시 함수로 선택될 수 있다. 예를 들어, 데이터 프로세싱 시스템은 독립적이고 균일하게 분산된 해시 함수를 선택할 수 있다. 이러한 해시 함수는 예를 들어 murmur 해시, Fowler-Noll-Vo 시리즈 해시, 또는 Jenkins 해시, SHA-1 해시, SHA-2 해시 또는 균일하게 분포된 또는 실질적으로 균일하게 분포된 출력 분포 등을 생성할 수 있는 당업계에 공지된 임의의 다른 유형의 해시 함수를 포함할 수 있다. 데이터 프로세싱 시스템은 해시 함수를 선택하거나 식별할 수 있으며, 선택된 데이터 레코드에 해시 함수를 적용하여 해시된 데이터 레코드를 생성할 수 있다.The data processing system may hash the selected data record (act 2008). The data processing system can identify and execute a hash function to use to populate the cascade data structure. For example, each hash identified in the list of hashes may provide a normal distribution or expected randomness based on the input value. That is, for example, similar inputs to a hash function do not necessarily have similar outputs to a hash function. The hash function can be chosen as the optimal hash function for the cascade swarm data structure. For example, the data processing system may choose an independent uniformly distributed hash function. These hash functions can produce, for example, murmur hashes, Fowler-Noll-Vo series hashes, or Jenkins hashes, SHA-1 hashes, SHA-2 hashes, or evenly distributed or substantially uniformly distributed output distributions. It may include any other type of hash function known in the art. The data processing system may select or identify a hash function and apply the hash function to the selected data record to generate a hashed data record.
데이터 프로세싱 시스템은 생성된 계단식 군단 데이터 구조의 군단을 선택할 수 있다(동작 2010). 계단식 군단 데이터 구조는 여러 군단을 포함하도록 생성될 수 있으며, 각 군단은 대응하는 색인 값으로 인덱싱된다. 인덱스 값이 증가하면, 대응 군단의 포지션을 업데이트하는 값의 확률이 감소할 수 있다. 예를 들어, l 군단이 있는 계단식 군단 데이터 구조를 고려한다. l군단 각각은 인덱스 값(예: 1, 2, 3,…, l)으로 번호를 매길 수 있다. 일부 구현예에서, 각 군단의 인덱스 값은 서로 다른 숫자로 시작하고 끝날 수 있다(예를 들어, 제1 군단은 0의 인덱스 값을 갖고 마지막 군단은 l-1의 인덱스 값을 갖는 등). 각 해시된 데이터 레코드는 계단식 군단 데이터 구조에서 군단의 포지션을 업데이트할 수 있다. 해시된 데이터 레코드에 기초하여 업데이트될 군단을 결정하기 위해, 데이터 프로세싱 시스템은 해시된 데이터 레코드의 특정 포지션에 있는 0의 수를 결정할 수 있다. 예를 들어, 값 '0110 1010 0100'과 동일한 해시된 데이터 레코드의 경우, 데이터 프로세싱 시스템은 해시된 데이터 레코드에 두 개의 연속적인 최하위 0이 있음을 결정할 수 있다. 이 결정에 기초하여, 데이터 프로세싱 시스템은 업데이트할 두 번째 것(예를 들어, 인덱스 값이 2인 계단식 군단 등)을 선택할 수 있다. 이는 인덱스 값이 3인 군단에 배치되는 3개의 연속적인 0과 인덱스 값이 4인 군단에 배치되는 4개의 연속적인 0에 뒤따른다. 따라서 해시 함수의 출력이 균일하게 분산되기 때문에, 하나의 최하위 0이 있는 해시된 데이터 레코드의 확률은 50%이고, 2개의 연속된 최하위 0이 있는 해시된 데이터 레코드의 확률은 25%, 3개의 연속된 최하위 0이 있는 해시된 데이터 레코드의 확률은 12.5% 등이며, 각 군단은 임의의 주어진 해시된 데이터 레코드로 채워질 가능성이 점점 더 적다. 일부 구현예에서, 다른 일련의 비트는 동일한 비트 포지션 및 연속 값 체계가 계단식 군단 데이터 구조를 채우는데 사용되는 각 해시 데이터 레코드에 사용되는 한 유사한 방식(예를 들어, 연속적인 최상위 비트, 또는 각 해시된 데이터 레코드 전체에 걸쳐 일련의 연속 또는 비연속 비트 등)으로 군단을 선택하는데 사용된다.The data processing system may select the swarm of the cascaded swarm data structure created (act 2010). A cascading swarm data structure can be created to contain multiple swarms, each indexed with a corresponding index value. As the index value increases, the probability of the value updating the position of the corresponding corps may decrease. For example, consider a cascading corps data structure with l corps. Each l group can be numbered with an index value (eg 1, 2, 3,..., l). In some implementations, each corps' index value may start and end with a different number (eg, the first corps has an index value of 0, the last corps has an index value l-1, etc.). Each hashed data record can update the swarm's position in the cascading swarm data structure. To determine the swarm to be updated based on the hashed data record, the data processing system can determine the number of zeros in a particular position of the hashed data record. For example, for a hashed data record equal to the value '0110 1010 0100', the data processing system can determine that the hashed data record has two consecutive least significant zeros. Based on this determination, the data processing system can select the second one to update (eg, the cascade with an index value of 2, etc.). This is followed by 3 consecutive 0s placed in the corps with an index value of 3 and 4 consecutive 0s placed in the corps with an index value of 4. Therefore, since the output of the hash function is uniformly distributed, the probability of a hashed data record with one trailing zero is 50%, the probability of a hashed data record with two consecutive trailing zeros is 25%, and the probability of a hashed data record with two consecutive trailing zeros is 25%. The probability of a hashed data record with the lowest 0 being zero is 12.5%, etc., and each swarm is less and less likely to be filled with any given hashed data record. In some implementations, different sets of bits are performed in a similar manner (e.g., contiguous most significant bits, or each hash) as long as the same bit position and contiguous value system is used for each hash data record used to populate the cascade data structure. A series of consecutive or non-contiguous bits, etc.) throughout the recorded data record.
데이터 프로세싱 시스템은 해시된 데이터 레코드에서 포지션 식별자를 추출할 수 있다(동작 2012). 해시된 데이터 레코드는 동작 2010에서 선택된 군단의 포지션에 대응할 수 있다. 선택된 군단에서 대응하는 포지션을 식별하기 위해, 데이터 프로세싱 시스템은 해시된 데이터 레코드에서 레지스터 식별자를 추출할 수 있다. 데이터 프로세싱 시스템은 예를 들어 선택된 군단의 포지션의 수로 각 해시된 데이터 식별자에 대해 모듈러스 연산을 수행하여 레지스터 식별자를 추출할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 군단을 선택하는데 사용되지 않는 해시된 데이터 레코드의 비트에 대해 모듈러스 연산을 수행할 수 있다. 예를 들어, 해시된 데이터 레코드가 '0110 1010 0100'과 같고, 군단이 최하위 비트에서 시작하는 연속 0의 수로 선택된 경우, 데이터 프로세싱 시스템은 이 예에서는 '0110 1010 01'인 해시된 데이터 레코드의 나머지 부분에 대해 모듈러스 연산을 수행할 수 있다. 연속 0 최하위 비트 수가 4개이면(예: 해시된 데이터 레코드가 '1001 0011 0000'과 같음), 데이터 프로세싱 시스템은 군단의 포지션을 선택하기 위해 군단을 선택하는데 사용되지 않은 해시된 데이터 레코드의 비트를 사용할 수 있다(예: '1001 0011'). 군단을 선택하는데 사용된 비트가 제거된 후 남아있는 비트 수가 포지션을 선택하는데 필요한 비트 수보다 적으면, 데이터 프로세싱 시스템은 군단의 포지션을 선택하는데 필요한 수까지 랜덤 비트(예: 의사 랜덤, 균일 분산)를 생성할 수 있다. 예를 들어 군단에 16개의 포지션이 있지만 나머지 부분이 추출된 후 2비트만 남아있는 경우, 데이터 프로세싱 시스템은 랜덤하게(예: 의사 랜덤 등) 2비트를 더 생성하고 그들을 나머지 2비트에 연결할 수 있다. 이 예에서는 4개의 균일하게 분산된 비트로 구성된 비트 열을 생성하며, 이는 군단의 16개 포지션으로부터 선택하는데 사용될 수 있다. The data processing system may extract the position identifier from the hashed data record (act 2012). The hashed data record may correspond to the position of the corps selected in operation 2010 . To identify the corresponding position in the selected corps, the data processing system can extract the register identifier from the hashed data record. The data processing system may extract the register identifier, for example, by performing a modulus operation on each hashed data identifier with the number of positions in the selected corps. In some implementations, the data processing system can perform a modulus operation on the bits of the hashed data record that are not used to select swarms. For example, if the hashed data record is equal to '0110 1010 0100', and the swarm is chosen as the number of consecutive zeros starting with the least significant bit, the data processing system will use the remainder of the hashed data record, which in this example is '0110 1010 01'. A modulus operation can be performed on the part. If the number of consecutive 0 least significant bits is 4 (e.g. the hashed data record equals '1001 0011 0000'), the data processing system selects the positions of the swarms by using the bits of the hashed data record that are not used to select the swarms. can be used (e.g. '1001 0011'). If the number of bits remaining after the bits used to select the swarm are removed is less than the number of bits needed to select the position, the data processing system randomizes bits (e.g., pseudo-random, uniform distribution) up to the number needed to select the position of the swarm. can create For example, if there are 16 positions in a swarm, but only 2 bits remain after the remainder has been extracted, the data processing system can generate 2 more bits at random (e.g. pseudo-random, etc.) and concatenate them to the remaining 2 bits. . This example creates a bit string consisting of 4 evenly distributed bits, which can be used to select from the 16 positions of the swarm.
데이터 프로세싱 시스템은 선택된 군단에서 선택된 포지션을 업데이트할 수 있다(동작 2014). 선택된 포지션을 업데이트하는 것은 예를 들어 선택된 군단의 포지션 식별자에 대응하는 카운터 레지스터에 하나를 추가하는 것을 포함할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 선택된 군단의 포지션 식별자에 대응하는 비트를 설정할 수 있다. 일부 구현예에서, 카운터 레지스터에 추가되는 양은 1이 아닌 값일 수 있다. 예를 들어, 데이터 프로세싱 시스템은 여기서 결정, 생성 또는 계산된 임의의 값에 대응할 수 있는 각 카운터 레지스터에 다른 값을 추가할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 본 명세서에서 논의되는 다양한 이유로 카운터 레지스터로부터 감산될 수 있다. 일부 구현예에서, 감산에 대한 대안으로서, 데이터 프로세싱 시스템은 데이터 프로세싱 시스템에 의해 현재 선택되지 않은 다른 카운터 레지스터 버킷 각각에 양(예를 들어, 1 또는 일부 다른 값 등)을 더할 수 있다. 예를 들어, 데이터 프로세싱 시스템은 특정 데이터 레코드와 연관된 특정 액세스 수만큼 값을 증가시킬 수 있다. 디바이스 식별자와 연관된 디바이스가 특정 콘텐츠 아이템에 특정 횟수만큼 액세스하는 경우, 데이터 프로세싱 시스템은 계단식 군단 데이터 구조(예를 들어, 다른 섹션을 포함하여 여기에 설명된 임의의 다른 확률 데이터 구조)에서 포지션을 해시된 데이터 레코드에 대응하는 디바이스가 특정 콘텐츠 아이템에 액세스 한 횟수만큼 증가시킬 수 있다. 일부 구현예에서, 이 특정 콘텐츠 아이템이 액세스된 횟수는 각각의 데이터 레코드에 저장될 수 있다.The data processing system may update the selected position in the selected corps (act 2014). Updating the selected position may include, for example, adding one to the counter register corresponding to the position identifier of the selected corps. In some implementations, the data processing system can set a bit corresponding to the position identifier of the selected corps. In some implementations, the amount added to the counter register can be a non-one value. For example, the data processing system may add another value to each counter register that may correspond to any value determined, generated, or calculated herein. In some implementations, the data processing system may subtract from the counter register for various reasons discussed herein. In some implementations, as an alternative to subtraction, the data processing system can add an amount (eg, 1 or some other value, etc.) to each of the other counter register buckets not currently selected by the data processing system. For example, the data processing system may increment the value by a particular number of accesses associated with a particular data record. When a device associated with a device identifier accesses a particular content item a particular number of times, the data processing system hashes its position in a cascade data structure (eg, any other probabilistic data structure described herein, including other sections). may be increased by the number of times the device corresponding to the data record accessed the specific content item. In some implementations, the number of times this particular item of content has been accessed may be stored in each data record.
데이터 프로세싱 시스템은 카운터 레지스터 k가 데이터 레코드의 수 n과 동일한지 여부를 결정할 수 있다(동작 2016). 데이터 프로세싱 시스템이 각 데이터 레코드를 사용하여 계단식 군단 데이터 구조를 업데이트했는지 여부를 결정하기 위해, 데이터 프로세싱 시스템은 각 데이터 레코드를 선택하는데 사용되는 카운터 레지스터(예: k)를 총 데이터 레코드 수 n과 비교할 수 있다. 카운터 레지스터 k가 총 데이터 레코드의 수 n과 동일하지 않으면(예를 들어, 그보다 작은 경우), 데이터 프로세싱 시스템은 동작 2018를 실행할 수 있다. 카운터 레지스터 k가 총 데이터 레코드의 수 n과 같으면(예를 들어, 동일하거나 그보다 큰 경우), 데이터 프로세싱 시스템은 동작 2020를 실행할 수 있다.The data processing system can determine whether the counter register k is equal to the number of data records n (act 2016). To determine whether the data processing system has updated the cascade data structure with each data record, the data processing system compares the counter register (eg k ) used to select each data record with the total number of data records n . can If the counter register k is not equal to (eg less than) the total number of data records n , the data processing system may execute operation 2018. If the counter register k is equal to (eg, equal to or greater than) the total number of data records n , the data processing system may execute operation 2020.
데이터 프로세싱 시스템은 카운터 레지스터 k를 증가시킬 수 있다(동작 2018). 일부 구현예에서, 데이터 프로세싱 시스템은 유지된 데이터 레코드 세트(예를 들어, 동작 2002에서 데이터 프로세싱 시스템에 의해 유지되는 데이터 레코드 등)에서 다음 프로세싱되지 않은 데이터 레코드를 나타내기 위해 레지스터 k에 하나를 추가할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 카운터 레지스터 k를 다음 프로세싱되지 않은 데이터 레코드의 메모리 어드레스 값(예를 들어, 컴퓨터 메모리에서의 위치)으로 설정할 수 있다. 일부 구현예에서, 다음 프로세싱되지 않은 데이터 레코드의 메모리 어드레스 값은 현재(예를 들어, 선택된) 데이터 레코드의 위치에서 데이터 구조에 포함될 수 있다. 카운터 레지스터 k의 값을 증가시킨 후, 데이터 프로세싱 시스템은 동작 2006를 실행할 수 있다.The data processing system may increment the counter register k (act 2018). In some implementations, the data processing system adds one to register k to indicate the next unprocessed data record in the held data record set (eg, the data record maintained by the data processing system in operation 2002, etc.) can do. In some implementations, the data processing system can set counter register k to the memory address value (eg, location in computer memory) of the next unprocessed data record. In some implementations, the memory address value of the next unprocessed data record may be included in the data structure at the location of the current (eg, selected) data record. After incrementing the value of counter register k, the data processing system may execute operation 2006.
데이터 프로세싱 시스템은 집합된 암호화 키를 획득할 수 있다(동작 2020). 예를 들어, 데이터 프로세싱 시스템은 하나 이상의 작업자 컴퓨팅 디바이스(예를 들어, 작업자 컴퓨팅 디바이스(405A-N), 애그리게이터 컴퓨팅 디바이스(410) 등)에 의해 생성되는 집합된 공개 키를 수신할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 다른 컴퓨팅 디바이스(예를 들어, 다른 데이터 프로세싱 시스템, 작업자 컴퓨팅 디바이스 등)로부터 하나 이상의 공개 키를 수신하고, 공개 키를 집합된 공개 암호화 키로 집합할 수 있다. 일부 구현예에서, 작업자 컴퓨팅 디바이스는 공개 키를 교환 및 집합하고, 집합된 공개 키를 생성하고, 이를 계단식 군단 데이터 구조를 생성한 각 데이터 프로세싱 시스템에 전송할 수 있다. 집합된 키는 일부 구현예에서, 본 명세서에 설명된 하나 이상의 포지션, 군단 또는 계단식 군단 데이터 구조를 부분적으로 또는 완전히 암호화하는데 사용될 수 있다. 일부 구현예에서, 집합된 키는 데이터 프로세싱 시스템에 의해 유지되는 계단식 군단 데이터 구조를 암호화하기 위해 데이터 프로세싱 시스템에 배포되는 단일 공개 키일 수 있다. 일부 구현예에서, 집합된 암호화 키는 하나 이상의 ElGamal 암호화 키, 또는 임의의 다른 유형의 동형 암호화 체계를 포함할 수 있다. 일부 구현예에서, 집합된 암호화 키는 임계 복호화 방식을 지원하는 모든 종류의 공개 암호화 키일 수 있다.The data processing system may obtain the aggregated encryption key (act 2020). For example, the data processing system may receive an aggregated public key generated by one or more worker computing devices (eg, worker computing devices 405A-N, aggregator computing devices 410, etc.). In some implementations, the data processing system can receive one or more public keys from other computing devices (eg, other data processing systems, worker computing devices, etc.) and aggregate the public keys into an aggregated public encryption key. In some implementations, worker computing devices may exchange and aggregate public keys, generate aggregated public keys, and transmit them to each data processing system that created the cascade data structure. The aggregated key may be used, in some implementations, to partially or fully encrypt one or more of the position, swarm, or cascade data structures described herein. In some implementations, the aggregated key may be a single public key distributed to the data processing system to encrypt the cascade data structure maintained by the data processing system. In some implementations, the aggregated encryption key may include one or more ElGamal encryption keys, or any other type of homomorphic encryption scheme. In some implementations, the aggregated encryption key can be any type of public encryption key that supports a criticality decryption scheme.
데이터 프로세싱 시스템은 계단식 군단 데이터 구조를 암호화할 수 있다(동작 2022). 계단식 군단 데이터 구조의 차등 프라이버시를 보장하기 위해, 데이터 프로세싱 시스템은 데이터 프로세싱 시스템에 의해 생성되고 유지되는 계단식 군단 데이터 구조를 암호화하기 위해 하나 이상의 암호화 기법을 사용할 수 있다. 예를 들어, 데이터 프로세싱 시스템은 암호화 체계(예를 들어, ElGamal 암호화, 임계값 복호화를 지원하는 암호화 체계, 동형 암호화 등)을 사용하여 동작 2020에서 획득된 집합된 공개 키를 사용할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 계단식 군단 데이터 구조를 암호화하기 위해 집합된 암호화 키를 사용하여 개별적으로 각 군단의 포지션에 대응하는 카운터 레지스터 또는 비트 값 각각을 암호화할 수 있다. 이러한 구현에서, 각각의 암호화된 카운터 레지스터 또는 비트 값은 계단식 군단 데이터 구조를 표현하는 암호화된 데이터 구조를 생성하기 위해 집합될 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 계단식 군단 데이터 구조를 군단 단위로 암호화할 수 있고 즉, 각 군단은 독립적으로 암호화되고 계단식 군단 데이터 구조를 표현하는 암호화된 데이터 구조로 집합될 수 있다.The data processing system may encrypt the cascading swarm data structure (act 2022). To ensure differential privacy of the cascade data structure, the data processing system may use one or more encryption techniques to encrypt the cascade data structure created and maintained by the data processing system. For example, the data processing system may use the aggregated public key obtained in operation 2020 using an encryption scheme (eg, ElGamal encryption, an encryption scheme supporting threshold decryption, homomorphic encryption, etc.). In some implementations, the data processing system may encrypt each counter register or bit value corresponding to the position of each swarm individually using the aggregated encryption key to encrypt the cascade swarm data structure. In such an implementation, each encrypted counter register or bit value may be aggregated to create an encrypted data structure representing a cascade data structure. In some implementations, the data processing system may encrypt the cascaded corps data structure in corps units, that is, each corps may be independently encrypted and aggregated into an encrypted data structure representing the cascaded corps data structure.
데이터 프로세싱 시스템은 암호화된 계단식 군단 데이터 구조를 전송할 수 있다(동작 2024). 암호화된 계단식 군단 데이터 구조를 전송하는 것은 암호화된 계단식 군단 데이터 구조를 작업자 컴퓨팅 디바이스(예를 들어, 임의의 작업자 컴퓨팅 디바이스(405A-N), 애그리게이터 컴퓨팅 디바이스(410) 등)에 제공하는 것을 포함할 수 있다. 데이터 프로세싱 시스템은 암호화된 계단식 군단 데이터 구조를 프로세싱하기 위해 하나 이상의 작업자 컴퓨팅 디바이스 중 첫 번째로 작업자 컴퓨팅 디바이스를 선택할 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 암호화된 계단식 군단 데이터 구조를 포지션 단위로 전송할 수 있으며, 여기서 각 군단의 각 포지션은 작업자 컴퓨팅 디바이스로 개별적으로 전송될 수 있다. 일부 구현예에서, 데이터 프로세싱 시스템은 암호화된 계단식 군단 데이터 구조를 대량 트랜잭션으로 전송할 수 있으며, 여기서 암호화된 벡터의 대부분 또는 전체가 단일 메시지로 전송된다. 일부 구현예에서, 데이터 프로세싱 시스템은 암호화된 계단식 군단 데이터 구조를 군단 단위로 전송할 수 있으며, 여기서 각 암호화된 군단은 자체 메시지로 작업자 컴퓨팅 디바이스에 전송된다.The data processing system may transmit the encrypted cascade corps data structure (act 2024). Transmitting the encrypted cascade swarm data structure includes providing the encrypted cascade swarm data structure to a worker computing device (eg, any worker computing device 405A-N, aggregator computing device 410, etc.) can do. The data processing system may select a worker computing device as a first of the one or more worker computing devices to process the encrypted cascade data structure. In some implementations, the data processing system may transmit the encrypted cascade corps data structure on a position-by-position basis, where each position of each corps may be individually transmitted to the worker computing device. In some implementations, the data processing system can transmit encrypted cascade data structures in bulk transactions, where most or all of the encrypted vectors are transmitted in a single message. In some implementations, the data processing system can transmit the encrypted cascade swarm data structure in swarm units, where each encrypted swarm is sent in its own message to the worker computing device.
C. 빈도 및 카디널리티 추정을 위한 대체 계단식 군단 기법C. Alternative cascading corps techniques for frequency and cardinality estimation
식별자 서버는 예를 들어 각각의 클라이언트 디바이스와 연관된 클라이언트 식별자를 유지함으로써 클라이언트 디바이스 세트와 연관될 수 있다. 각 클라이언트 식별자는 각 식별자 서버와 클라이언트 디바이스 간의 연결을 설명하는 속성 정보를 포함할 수 있다. 속성 정보는 클라이언트 디바이스와 식별자 서버 간의 관계에 대한 정보(예: 웹 브라우징 기록, 인터렉션 데이터, 연결 시간, 네트워크 분석 데이터 등)를 포함할 수 있으며, 각각의 클라이언트 디바이스로부터 수신된 보호된 또는 개인 정보를 포함할 수 있다. 서로 다른 식별자 서버는 동일한 각각의 클라이언트 디바이스에 대응하는 서로 다른 속성 데이터 및 서로 다른 클라이언트 식별자를 유지할 수 있다. 일반적으로 각 식별자 서버간에 중복된 속성 데이터가 있는지 결정하기 위해 식별자 서버는 보호된 또는 개인 정보를 포함할 수 있는 속성 데이터를 중앙 서버와 공유하여 클라이언트 속성 정보의 중복을 제거할 수 있다. An identifier server may be associated with a set of client devices, for example by maintaining a client identifier associated with each client device. Each client identifier may include attribute information describing a connection between each identifier server and the client device. Attribute information may include information about the relationship between the client device and the identifier server (eg, web browsing history, interaction data, connection time, network analysis data, etc.), and may include protected or personal information received from each client device. can include Different identifier servers may maintain different client identifiers and different attribute data corresponding to the same respective client device. In general, to determine if there is duplicate attribute data between each identifier server, the identifier server may share attribute data, which may contain protected or private information, with the central server to eliminate duplication of client attribute information.
그러나 모든 클라이언트 속성 데이터를 전송하면 확장성에 문제가 발생한다. 클라이언트 식별자 서버 수가 증가하면 일반적으로 네트워크를 통해 전송되는 클라이언트 디바이스 속성 데이터의 양도 증가한다. 속성 데이터는 각 클라이언트 디바이스에 대해 상세하고 상대적으로 클 수 있기 때문에 이러한 정보를 대규모로 전송하면 네트워크 대역폭과 계산 리소스가 소모될 수 있다. 또한 시스템이 총 사용자 식별자 수를 계산하는 것 뿐만 아니라 네트워크를 통해 보호된 또는 개인 속성 정보를 전송하지 않고 특정 속성의 빈도와 같은 특정 속성 데이터 기준을 충족하는 클라이언트 디바이스의 수도 계산하는 것이 유용하다. 또한, 이러한 이슈를 해결하는데 사용되는 암호화된 확률 데이터 구조의 구현예는 비현실적으로 큰(예: 기가 바이트 정도) 스케치 크기로 인해 어려움을 겪는다. However, sending all client attribute data causes scalability problems. As the number of client identifier servers increases, the amount of client device attribute data typically transmitted over the network also increases. Because attribute data can be detailed and relatively large for each client device, transmitting this information on a large scale can consume network bandwidth and computational resources. It is also useful for the system to count not only the total number of user identifiers, but also the number of client devices that meet certain attribute data criteria, such as the frequency of certain attributes, without transmitting protected or private attribute information over the network. Additionally, implementations of encrypted probabilistic data structures used to address this issue suffer from unrealistically large (e.g., on the order of gigabytes) sketch sizes.
전술한 문제를 해결하기 위해, 이 기술적 접근의 시스템 및 방법의 양태는 미국 특허 가출원 번호 제62/981,960호에서 설명된 바와 같이 생성된 디노이징된 계단식 군단 데이터 구조를 결합할 수 있다. 각 퍼블리셔 컴퓨팅 디바이스는 해당 퍼블리셔와 연관된 디바이스 식별자를 표현하는 확률 행렬 데이터 구조를 생성할 수 있다. 차등 프라이버시를 유지하기 위해, 각 퍼블리셔는 행렬의 각 행에서 비트를 무작위로 플립핑할 수 있다. 데이터 프로세싱 시스템은 모든 퍼블리셔 컴퓨팅 디바이스로부터 때때로 스케치로 지칭되는 노이즈 행렬들을 수신하고 모든 퍼블리셔 컴퓨팅 디바이스에 걸쳐 식별자의 멀티세트의 유니온 또는 카디널리티를 계산할 수 있다. To address the foregoing problems, system and method aspects of this technical approach may incorporate a denoised cascade corps data structure created as described in US Provisional Patent Application Serial No. 62/981,960. Each publisher computing device may generate a random matrix data structure representing a device identifier associated with that publisher. To maintain differential privacy, each publisher can randomly flip bits in each row of the matrix. The data processing system may receive noise matrices, sometimes referred to as sketches, from all publisher computing devices and compute the union or cardinality of the multiset of identifiers across all publisher computing devices.
각 퍼블리셔로부터의 스케치를 사용하여 식별자의 멀티세트의 유니온을 계산하는 적어도 하나의 구현예는 먼저 각 노이즈가 있는 스케치의 카디널리티(예를 들어, 스케치를 생성하는데 사용되는 추정된 식별자 수)를 계산하고, 노이즈가 있는 스케치를 카디널리티 내림차순으로 정렬하는 것을 포함한다. 데이터 프로세싱 시스템은 노이징된 스케치를 미리 결정된 크기의 그룹으로 그룹화하고 디노이징된 것을 추정할 수 있다. 데이터 프로세싱 시스템은 Monte-Carlo 샘플링을 사용하여 각 스케치 그룹에 대해 디노이징된 유니온 스케치를 추정할 수 있다. 추정된 디노이징된 스케치가 생성되면, 데이터 프로세싱 시스템은 스케치를 결합하고 모든 퍼블리셔 컴퓨팅 디바이스의 모든 디바이스 식별자를 나타내는 카디널리티 또는 유니온을 결정할 수 있다.At least one implementation that computes a union of multisets of identifiers using sketches from each publisher first calculates the cardinality of each noisy sketch (e.g., the estimated number of identifiers used to generate the sketch) and , which involves sorting the noisy sketches in descending cardinality order. The data processing system may group the noised sketches into groups of a predetermined size and infer that they have been denoised. The data processing system can use Monte-Carlo sampling to estimate a denoised union sketch for each group of sketches. Once the estimated denoised sketch is created, the data processing system may combine the sketches and determine a cardinality or union representing all device identifiers of all publisher computing devices.
본 명세서에 기술된 기법은 퍼블리셔 컴퓨팅 디바이스가 디바이스 식별자 또는 퍼블리셔 컴퓨팅 디바이스(예: 데이터 프로세싱 시스템(105A-N))에 의해 유지되는 데이터 레코드의 디바이스 식별자와 연관하여 저장된 속성에 관한 정보를 공개하지 않고, 퍼블리셔 컴퓨팅 디바이스 세트의 식별자(예: 디바이스 식별자, 속성 등)의 총 수를 찾게 한다.Techniques described herein do not allow a publisher computing device to disclose information about attributes stored in association with device identifiers or device identifiers of data records maintained by publisher computing devices (eg, data processing systems 105A-N). , to find the total number of identifiers (e.g., device identifiers, attributes, etc.) of a set of publisher computing devices.
수학적으로, 이것은 일반적인 문제의 예다: 세트 S1, ... , Sk의 유니온의 카디널리티 찾기. 여기서 각 세트 Si는 에이전트 Ai(예: 데이터 프로세싱 시스템 105I 등)에 의해 유지된다. 데이터세트의 개별 멤버에 대한 특정 정보(예: 디바이스 식별자, 속성 데이터, 개인 또는 집합 데이터 레코드 등)를 공개하지 않는 경우 데이터세트를 차등적 비공개(private)라고 한다. 사용자의 세트의 스케치를 생성하여, 이들이 차등적으로 비공개이고, 세트(예를 들어, 멀티세트) 유니온의 카디널리티가 효율적으로 결정될 수 있도록 하는 것이 바람직하다. 차등적 비공개 및 노이징된 계단식 군단(예를 들어, 섹션 B에서 위에서 설명한 계단식 군단 등)의 효율적인 유니온을 위한 알고리즘이 이 섹션에 설명되어 있다. 섹션 B는 식별자의 멀티세트의 카디널리티와 빈도를 결정하기 위한 계단식 군단 체계를 제공하기 위해 섹션 A에 요약된 시스템의 구현예를 자세히 설명한다. 이 섹션에서는 데이터 프로세싱 레벨에서 각 계단식 군단 데이터 구조(예: 스케치 등)에 차등적 비공개(DP, Differentially private) 노이즈를 추가하고(예: 각 데이터 프로세싱 시스템(105A-N)은 각각의 계단식 군단 스케치에 노이즈를 추가할 수 있음), 최종 카디널리티 또는 주파수 추정의 정확도에 대한 DP 노이즈의 영향을 줄이거나 제거할 수 있는 기법을 사용하여 멀티세트의 카디널리티 및 주파수를 효율적으로 결정하는 기법을 자세히 설명한다.Mathematically, this is an example of a general problem: finding the cardinality of a union of sets S 1 , ... , S k . Here, each set Si is maintained by an agent Ai (eg data processing system 105I, etc.). A dataset is said to be differentially private if it does not disclose specific information about individual members of the dataset (e.g., device identifiers, attribute data, personal or collective data records, etc.). It is desirable to create sketches of the user's sets so that they are differentially private, and that the cardinality of set (e.g., multiset) unions can be efficiently determined. Algorithms for efficient union of differentially closed and noised cascades (eg, cascades described above in Section B) are described in this section. Section B details an implementation of the system outlined in Section A to provide a cascading swarm scheme for determining the cardinality and frequency of multisets of identifiers. In this section, at the data processing level, we add differentially private (DP) noise to each cascade data structure (e.g. sketch, etc.) (e.g. each data processing system 105A-N) We detail a technique for efficiently determining the cardinality and frequency of a multiset using a technique that can reduce or eliminate the effect of DP noise on the accuracy of the final cardinality or frequency estimate.
k DP 노이징된 계단식 군단 스케치의 중복 제거는 선형 시간으로 달성될 수 있다. 알고리즘은 계산적으로 효율적이다. 임의의 수의 스케치를 중복 제거하는데 사용할 수 있는 휴리스틱이 설명되어 있다. 특정 가정이 유지되면 노이즈가 작다. 특히, 유니온 스케치의 카디널리티가 가장 큰 스케치에 의해 지배되는 경우 노이즈가 작다. 블룸 필터에 대한 중복 제거 알고리즘(예를 들어, 섹션 A에서 설명됨)의 복잡성은 이 섹션에서 설명된 기법을 사용하여 지수적 시간으로부터 선형 시간으로 개선될 수 있다.Deduplication of the k DP-noised cascade corps sketch can be achieved in linear time. The algorithm is computationally efficient. A heuristic is described that can be used to deduplicate an arbitrary number of sketches. Noise is small if certain assumptions hold. In particular, the noise is small when the union sketch is dominated by the sketch with the largest cardinality. The complexity of the duplicate removal algorithm (eg, described in Section A) for Bloom filters can be improved from exponential time to linear time using the techniques described in this section.
확률 p로 각 군단 x 포지션을 무작위로 플립핑하여 노이즈가 추가된다. 이 확률은 차등 프라이버시 엡실론과 관련이 있는 것으로 간주된다:Noise is added by randomly flipping each swarm x position with probability p. This probability is considered to be related to the differential privacy epsilon:
이 체계는 예를 들어 계단식 군단 데이터 구조를 블룸 필터(예를 들어, 섹션 B 등에 설명된 바와 같이 카운터 레지스터가 비트 값 대신 사용되는 경우 카운팅 블룸 필터)로 감소시킴으로써 효율적으로 될 수 있다. 계단식 군단 스케치는 각각 n 개의 포지션을 가진 l 군단으로 구성될 수 있다. 아이템(예를 들어, 디바이스 식별자 및 연관 속성 데이터 등을 포함하는 데이터 레코드)은 한 군단의 한 포지션으로 해시될 수 있다. 아이템이 k 번째 군단으로 해시될 확률은 2-k다. 군단이 주어지면, 특정 데이터 레코드에 의해 한 포지션이 채워지거나 업데이트될 확률은 선택된 군단의 각 포지션에 대해 동일하다.This scheme can be made efficient, for example, by reducing the cascading corps data structure to a bloom filter (e.g., a counting bloom filter if a counter register is used instead of a bit value as described in Section B, etc.). A cascading corps sketch can consist of l corps, each with n positions. An item (eg, a data record containing a device identifier and associated attribute data, etc.) may be hashed to a position in a swarm. The probability of an item hashing into the k th swarm is 2-k. Given a corps, the probability that a position will be filled or updated by a particular data record is the same for each position in the selected corps.
안전한 다자간 계산에서, 카디널리티 추정은 1로 설정된 총 포지션 수(예: 0으로 설정되지 않음)에서 수행된다. 차등적 비공개인 경우, 총 포지션의 수의 노이즈는 비어 있고 포화된 군단에 의해 지배될 것이다. 따라서 포화 과정에 있는 군단에서 추정을 이루어질 수 있다. 포화 과정에 있는 군단의 선택은 위 섹션 B에 설명되어 있지만, 값으로 채워진 포지션의 절반 미만을 갖는 계단식 군단 데이터 구조의 제1 군단을 결정하는 것을 포함한다. 자체적으로, 포화 과정에 있는 군단은 균일한 블룸 필터(또는 카운터 레지스터가 사용되는 경우 카운팅 블룸 필터 등)일 수 있다. 유니폼 블룸 필터 카디널리티 추정을 위한 알고리즘은 다음과 같은 순전히 예시 및 비 제한적 의사 코드에 설명된 바와 같이 계단식 군단에 적용될 수 있다:In secure multiparty computation, cardinality estimation is performed on the total number of positions set to 1 (i.e. not set to 0). In the case of differential closing, the noise in the total number of positions will be dominated by empty and saturated corps. Thus, an estimate can be made of a corps that is in the process of saturation. The selection of corps that are in the process of saturation is described in Section B above, but involves determining the first corps of the cascaded corps data structure that has less than half of the positions filled with values. By itself, the swarm in the process of saturation can be a uniform bloom filter (or a counting bloom filter if a counter resistor is used, etc.). The algorithm for uniform bloom filter cardinality estimation can be applied to the cascade as described in the purely illustrative and non-limiting pseudo code as follows:
Input: CascadingLegion(l, n) sketches s[0], ..., s[k-1] noised with probability Input: CascadingLegion(l, n) sketches s[0], ..., s[k-1] noised with probability
Output: cardinality of the union Output: cardinality of the union
for legion in range(l): for legion in range(l):
estimate C to be denoised number of bits set to 1 in the estimate C to be denoised number of bits set to 1 in the
union of sketeches union of sketches
if C < (n/2): if C < (n/2):
# we are at Reference Legion # we are at Reference Legion
Return estimation C * 2^legion Return estimation C * 2^legion
알고리즘은 블룸 필터의 포지션에서 관찰된 비트 조합 볼륨의 벡터에서 작동할 수 있다. 알고리즘은 다음과 같이 진행할 수 있다:The algorithm can operate on the vector of bits combination volume observed at the position of the bloom filter. The algorithm can proceed as follows:
1. 비트 조합 b1, b2의 모든 쌍에 대해 b1에서 b2로 이어지는 랜덤 플립 확률이 계산된다.1. A random flip probability from b1 to b2 is calculated for every pair of bit combinations b1, b2.
2. 확률은 1에서 계산될 수 있으며 전이 행렬 M으로 조합된다.2. The probabilities can be computed at 1 and combined into a transition matrix M.
3. 전이 행렬 M은 보정 행렬 C를 계산하기 위해 반전될 수 있다.3. The transition matrix M can be inverted to compute the correction matrix C.
4. 스케치 모음이 주어지면:4. Given a set of sketches:
a. 비트 조합의 볼륨 벡터가 계산된다. a. The volume vector of the bit combination is calculated.
b. 벡터에 보정 행렬을 적용하여 비트 조합 볼륨의 사전 노이즈 벡터를 추정한다. b. Estimate the prior noise vector of the bit combination volume by applying a correction matrix to the vector.
비트 조합 볼륨의 사전 노이즈 벡터는 데이터 레코드의 전체 멀티세트를 기술한다. 유니온을 계산하기 위해 시스템은(0, ... 0)을 제외한 모든 조합을 합산할 수 있다. 보정 행렬의 계산은 예를 들어 다음의 예시적 비제한적 의사 코드에 의해 설명된 바와 같이 적어도 하나의 구현예에서 구현될 수 있다.The prior noise vector of the bit combination volume describes the entire multiset of data records. To compute a union, the system can sum all combinations except (0, ... 0). Calculation of the correction matrix may be implemented in at least one implementation, for example as illustrated by the following example non-limiting pseudo code.
def NoiseCorrection(s, p=0.1): def NoiseCorrection(s, p=0.1):
""" Noise correction matrix.""" Noise correction matrix.
Args:Args:
s: Number of bloom filters s: Number of bloom filters
p: DP flip probability p: DP flip probability
Returns:Returns:
A matrix that is to be applied to combination count to A matrix that is to be applied to combination count to
recover estimated combination count before DP noise. recover estimated combination count before DP noise.
""""""
q = 1 - p q = 1 - p
size = 2 ** s size = 2 ** s
result = [] result = []
for i in range(size): for i in range(size):
row = [] row = []
for j in range(size): for j in range(size):
match = ~(numpy.uint8(i) ^ numpy.uint8(j)) match = ~(numpy.uint8(i) ^ numpy.uint8(j))
match_count = bin(match & (size-1)).count('1') match_count = bin(match &(size-1)).count('1')
row.append(q**match_count*p**(log2(size)-match_count)) row.append(q**match_count*p**(log2(size)-match_count))
result.append(row) result. append(row)
m = numpy.matrix(result) m = numpy. matrix(result)
return numpy.linalg.inv(m) return numpy.linalg.inv(m)
다른 구현예에서, 프로세싱은 조합 벡터보다는 number-of-ones 벡터에서 발생할 수 있다. number-of-ones에 대한 전이 확률을 결정하는 것은 이항 계수를 사용하여 수행될 수 있다. 벡터의 제1 행은 모두 0인 디노이징된 버킷 수를 추정하는데 사용된다. 적어도 하나의 구현예에서, 1의 수 공간에서 전이 확률을 계산하는 것은 다음 예시적 의사 코드에 설명된 대로 선형 시간으로 달성될 수 있다.In other implementations, processing may occur on number-of-ones vectors rather than combinatorial vectors. Determining the transition probabilities for number-of-ones can be done using binomial coefficients. The first row of the vector is used to estimate the denoised bucket number of all zeros. In at least one implementation, computing the transition probabilities in number-ones space can be accomplished in linear time as described in the following example pseudocode.
def TransitionProbability(l, s, t, p): def TransitionProbability(l, s, t, p):
result = 0 result = 0
q = 1 - p q = 1 - p
for i in range(l // 2 + 1): for i in range(l // 2 + 1):
flip_zeros = max(0, t - s) + i flip_zeros = max(0, t - s) + i
flip_ones = max(0, s - t) + i flip_ones = max(0, s - t) + i
flips = flip_ones + flip_zeros flips = flip_ones + flip_zeros
calms = 1 - flips calms = 1 - flips
if flip_ones > s or flip_zeros > l - s: if flip_ones > s or flip_zeros > l - s:
continuecontinue
choose_ones = special.comb(s, flip_ones) choose_ones = special.comb(s, flip_ones)
choose_zeros = special.comb(l - s, flip_zeros) choose_zeros = special.comb(l - s, flip_zeros)
choices = choose_ones * choose_zeros choices = choose_ones * choose_zeros
assert choices > 0 assert choices > 0
result += choices * p ** flips * q ** calms result += choices * p ** flips * q ** calms
return result return result
본 섹션에 설명된 기법은 확률 행렬의 반전을 포함할 수 있다. 이러한 반전의 결과는 큰 차원에서 시끄러울 수 있다. 작은 스케치 집합(예: 5개)이 주어지면, 유니온의 디노이징된 스케치 샘플이 획득될 수 있다. 아래에 표시된 실시예는 2개의 스케치에 대한 유니온의 디노이징된 스케치를 얻지 만, 아래에 표시된 메서드는 임의의 수의 스케치로 일반화될 수 있으며, 단일 비트가 아닌 정수 값(예: 카운트 등)인 포지션을 포함하는 스케치로도 일반화될 수 있다. 이 메서드는 Monte Carlo 샘플링 휴리스틱이며, 아래의 의사 코드 예제에서 보여진다:The techniques described in this section may include inversion of a random matrix. The result of this reversal can be noisy on a large scale. Given a small set of sketches (eg 5), a union of denoised sketch samples can be obtained. The embodiment shown below obtains a denoised sketch of a union of two sketches, but the method shown below can be generalized to any number of sketches, and can be generalized to an integer value (e.g. count, etc.) rather than a single bit. It can also be generalized to sketches that include positions. This method is a Monte Carlo sampling heuristic and is shown in the pseudocode example below:
def GetCombinationsVector(s1, s2): def GetCombinationsVector(s1, s2):
"""Compute vector of combinations of bits in sketches.""" """Compute vector of combinations of bits in sketches."""
v = [0, 0, 0, 0] v = [0, 0, 0, 0]
for x, y in zip(s1, s2): for x, y in zip (s1, s2):
v[x+2*y] += 1 v[x+2*y] += 1
return v return v
def ProbabilityOfOr(bit_a, bit_b, priors_map): def ProbabilityOfOr(bit_a, bit_b, priors_map):
prob_map = {} prob_map = {}
for true_a in [0, 1]: for true_a in [0, 1]:
for true_b in [0, 1]: for true_b in [0, 1]:
flip_a_needed = 1 if bit_a != true_a else 0 flip_a_needed = 1 if bit_a != true_a else 0
flip_b_needed = 1 if bit_b != true_b else 0 flip_b_needed = 1 if bit_b != true_b else 0
prob_map[true_a,true_b] = priors_map[true_a,true_b]*( prob_map[true_a,true_b] = priors_map[true_a,true_b]*(
p ** flip_a_needed * q ** (1 - flip_a_needed) * p ** flip_a_needed * q ** (1 - flip_a_needed) *
p ** flip_b_needed * q ** (1 - flip_b_needed)) p ** flip_b_needed * q ** (1 - flip_b_needed))
prob_00 = prob_map[0, 0] / sum(prob_map.values())prob_00 = prob_map[0, 0] / sum (prob_map.values())
return 1 - prob00 return 1 - prob00
def DenoisedUnion(s1, s2): def DenoisedUnion(s1, s2):
v = GetCombinationsVector(s1, s2) v = GetCombinationsVector(s1, s2)
assert p == 0.1, "For now only case p=0.1 is simulated" assert p == 0.1, "For now only case p=0.1 is simulated"
v =numpy.matrix([[ 1.265625,-0.140625,-0.140625, 0.015625], v =numpy.matrix([[ 1.265625,-0.140625,-0.140625, 0.015625],
[-0.140625, 1.265625, 0.015625,-0.140625], [-0.140625, 1.265625, 0.015625,-0.140625],
[-0.140625, 0.015625, 1.265625,-0.140625], [-0.140625, 0.015625, 1.265625,-0.140625],
[ 0.015625,-0.140625,-0.140625, 1.265625]])* [ 0.015625,-0.140625,-0.140625, 1.265625]])*
numpy.array(v).reshape(4, 1)numpy.array(v).reshape(4, 1)
priors_map = {(0,0):v[0], (1,0):v[1], (0,1):v[2], (1,1):v[3]} priors_map = {(0,0):v[0], (1,0):v[1], (0,1):v[2], (1,1):v[3]}
probs = [ProbabilityOfOr(x, y, priors_map) for x, y in zip(s1,s2)]probs = [ProbabilityOfOr(x, y, priors_map) for x, y in zip (s1,s2)]
result = [int(random.uniform(0,1) < x) for x in probs]result = [ int (random.uniform(0,1) < x) for x in probs]
return result return result
위에서 설명한 기법을 사용하여, 시스템은 정확도 손실없이 큰(예: 10개 이상 등) 노이징된 스케치에 대한 유니온을 계산할 수 있다. 알고리즘은 튜닝 파라미터 k를 포함할 수 있으며, 일부 구현예에서 약 5로 설정될 수 있다. 그러나 튜닝 파라미터 k는 다른 값으로도 설정될 수 있다. Using the technique described above, the system can compute unions for large (eg 10 or more) noisy sketches without loss of accuracy. The algorithm may include a tuning parameter k , which may be set to about 5 in some implementations. However, the tuning parameter k can be set to other values as well.
1. 단일 스케치의 카디널리티를 추정할 수 있는 위에서 설명한 직접 추정 기법을 사용하여 각 스케치의 카디널리티를 추정(예: 특정 스케치의 전환 확률을 결정하고 포지션에서 해당 숫자를 제거하고 스케치의 카디널리티를 결정). 1. Estimate the cardinality of each sketch using the direct estimation technique described above, which allows estimating the cardinality of a single sketch (e.g., determine the transition probability of a particular sketch, remove that number from position, and determine the cardinality of the sketch).
2. 카디널리티를 기준으로 스케치를 내림차순으로 정렬(예: 스케치 목록의 첫 번째 스케치가 가장 큰 카디널리티, 목록의 두 번째 스케치가 두 번째로 큰 카디널리티 등).2. Sort sketches by cardinality in descending order (eg, the first sketch in the list of sketches has the highest cardinality, the second sketch in the list has the second largest cardinality, and so on).
3. 카디널리티 순서를 유지하면서 스케치를 k 크기의 그룹으로 그룹화(예: 목록의 첫 번째 k 스케치는 첫 번째 그룹에 있고, 목록의 다음 k 스케치는 두 번째 그룹에 있는 등). 이렇게하면 g 그룹의 스케치를 생성한다.3. Grouping sketches into k- sized groups, preserving cardinality order (eg, the first k sketches in the list are in the first group, the next k sketches in the list are in the second group, and so on). This creates a sketch of the g group.
4. 스케치의 각 g 그룹에 대해, Monte Carlo 방법을 사용하여 각 그룹에 대해 디노이징된 유니온을 샘플링한다. 이것은 g Monte Carlo 샘플링된 유니온 스케치를 반환할 수 있다.4. For each group of g in the sketch, use the Monte Carlo method to sample the denoised union for each group. This can return a g Monte Carlo sampled union sketch.
5. 1 단계에서와 같이 직접 g 스케치의 유니온을 취한다.5. Take the union of the direct g sketch as in step 1.
유니온된 모든 세트의 수퍼 세트가 제공되면, Monte-Carlo 샘플링의 정확도가 더욱 향상될 수 있다. 이러한 구현예에서 매핑된 데이터가 없는 모든 레지스터는 0으로 채워진다.The accuracy of Monte-Carlo sampling can be further improved if a superset of all unioned sets is provided. In this implementation, all registers without mapped data are filled with zeros.
이제 도 21을 참조하면, 도시된 것은 차등적 비공개 노이징된 계단식 군단 스케치의 카디널리티를 추정하는 방법(2100)의 예시적 흐름도이다. 이 방법은 섹션 A에서 본 명세서에 기술된 컴퓨팅 디바이스 중 임의의 것 또는 애그리게이터 컴퓨팅 디바이스(예: 애그리게이터 컴퓨팅 디바이스(410) 등)과 같은 본 명세서에 기술된 임의의 다른 컴퓨팅 디바이스(예를 들어, 하나 이상의 데이터 프로세싱 시스템(105A-N), 하나 이상의 클라이언트 디바이스(120A-N), 하나 이상의 작업자 컴퓨팅 디바이스(405A-N), 애그리게이터 컴퓨팅 디바이스(410) 등)에 의해 실행 또는 수행될 수 있다. 애그리게이터 컴퓨팅 디바이스는 하나 이상의 차등 비공개 계단식 군단 스케치를 수신할 수 있다(동작 2102). 애그리게이터 컴퓨팅 디바이스는 k 번째 스케치를 선택할 수 있다(동작 2104). 애그리게이터 컴퓨팅 디바이스는 선택된 스케치의 카디널리티를 추정할 수 있다(동작 2106). 애그리게이터 컴퓨팅 디바이스는 카운터 레지스터 k가 스케치의 수 n과 동일한지 여부를 결정할 수 있다(동작 2108). 애그리게이터 컴퓨팅 디바이스는 카운터 레지스터 k를 증가시킬 수 있다(동작 2110). 애그리게이터 컴퓨팅 디바이스는 카디널리티에 의해 스케치를 정렬할 수 있다(동작 2112). 애그리게이터 컴퓨팅 디바이스는 정렬된 스케치를 그룹화할 수 있다(동작 2114). 애그리게이터 컴퓨팅 디바이스는 g 번째 그룹을 선택할 수 있다(동작 2116). 애그리게이터 컴퓨팅 디바이스는 Monte Carlo 샘플링을 사용하여 선택한 그룹의 유니온을 추정할 수 있다(동작 2118). 애그리게이터 컴퓨팅 디바이스는 카운터 레지스터 g가 그룹의 수 m과 동일한지 여부를 결정할 수 있다(결정 2120). 애그리게이터 컴퓨팅 디바이스는 카운터 레지스터 g를 증가시킬 수 있다. 애그리게이터 컴퓨팅 디바이스는 g 그룹 유니온 값의 유니온으로부터 카디널리티를 추정할 수 있다(동작 2124). Referring now to FIG. 21 , shown is an exemplary flow diagram of a method 2100 of estimating the cardinality of a differentially closed-noised cascade corps sketch. The method may be performed using any of the computing devices described herein in Section A or any other computing device described herein, such as an aggregator computing device (eg, aggregator computing device 410, etc.) , one or more data processing systems 105A-N, one or more client devices 120A-N, one or more worker computing devices 405A-N, aggregator computing devices 410, etc.) . The aggregator computing device may receive one or more differentially private cascaded swarm sketches (act 2102). The aggregator computing device may select the kth sketch (act 2104). The aggregator computing device may estimate the cardinality of the selected sketch (act 2106). The aggregator computing device may determine whether the counter register k is equal to the number n of sketches (act 2108). The aggregator computing device may increment the counter register k (act 2110). The aggregator computing device may sort the sketches by cardinality (act 2112). The aggregator computing device may group the sorted sketches (act 2114). The aggregator computing device may select the g -th group (act 2116). The aggregator computing device may estimate the union of the selected group using Monte Carlo sampling (act 2118). The aggregator computing device may determine whether the counter register g is equal to the number of groups m (decision 2120). The aggregator computing device may increment the counter register g. The aggregator computing device may estimate the cardinality from the union of g- group union values (act 2124).
애그리게이터 컴퓨팅 디바이스는 하나 이상의 차등 비공개 계단식 군단 스케치를 수신할 수 있다(동작 2102). 일부 구현예에서, 애그리게이터 컴퓨팅 디바이스는 주기적으로 또는 버스트 트랜잭션에서 차등적 비공개(예를 들어, 노이징된) 계단식 군단을 수신할 수 있다. 각각의 계단식 군단 스케치는 계단식 군단 스케치가 생성되고 수신된 식별자 서버(예를 들어, 데이터 프로세싱 시스템(105A-N) 등)를 반영하는 각각의 식별자와 연관될 수 있다. 식별자 서버로부터 수신된 차등적 비공개 계단식 군단 스케치 각각은 집합된 암호화 키를 사용하여 암호화될 수 있다. 일부 구현예에서, 계단식 군단 스케치는 암호화되지 않으며, 차등적 프라이버시는 각 식별자 서버에 의해 계단식 군단 스케치에 추가된 노이즈를 통해 유지된다.The aggregator computing device may receive one or more differentially private cascaded swarm sketches (act 2102). In some implementations, the aggregator computing device may receive differential private (eg, noised) cascades periodically or in burst transactions. Each cascading corps sketch may be associated with a respective identifier that reflects the identifier server (eg, data processing systems 105A-N, etc.) from which the cascading sketch was created and received. Each differential private cascade corps sketch received from the identifier server may be encrypted using the aggregated encryption key. In some implementations, the cascading sketch is not encrypted, and differential privacy is maintained through noise added to the cascading sketch by each identifier server.
애그리게이터 컴퓨팅 디바이스는 k 번째 스케치를 선택할 수 있다(동작 2104). 동작 2102에서 수신된 각 계단식 군단 스케치의 노이징된 카디널리티를 프로세싱하고 결정하기 위해, 애그리게이터 컴퓨팅 디바이스는 애그리게이터 컴퓨팅 디바이스에서 수신한 각 스케치를 반복할 수 있다. 애그리게이터 컴퓨팅 디바이스는 카운터 레지스터 k에 기초하여 각각의 계단식 군단 스케치를 반복적으로 반복할 수 있다. 계단식 군단 스케치 각각은 인덱스 값(예를 들어, 인덱스 0, 인덱스 1, 인덱스 2 등)에 의해 데이터 구조에서 인덱스될 수 있다. 계단식 군단 스케치를 프로세싱하기 위해, 데이터 프로세싱 시스템은 카운터 레지스터 k와 동일한(거의 동일한) 인덱스 값을 포함하거나 그와 연관된 계단식 군단 스케치를 선택할 수 있다. 그것이 루프의 첫 번째 반복이라면, 카운터 레지스터 k는 k번째 계단식 군단 스케치를 선택하기 전에 legion(예를 들어, k = 0, k = 1 등)으로 초기화될 수 있다. 계단식 군단 스케치를 선택하는 것은 계단식 군단 스케치와 연관된 데이터를 애그리게이터 컴퓨팅 디바이스의 컴퓨터 메모리의 다른 영역, 예를 들어 메모리의 작업 영역에 복사하는 것을 포함할 수 있다.The aggregator computing device may select the kth sketch (act 2104). In operation 2102 the aggregator computing device may iterate through each sketch received at the aggregator computing device to process and determine the noised cardinality of each cascade sketch received. The aggregator computing device may iteratively iterate over each cascade sketch based on the counter register k . Each of the cascading corps sketches may be indexed in the data structure by an index value (eg, index 0, index 1, index 2, etc.). To process the cascading sketch, the data processing system may select a cascading sketch that contains or is associated with the same (nearly the same) index value as the counter register k . If it is the first iteration of the loop, the counter register k may be initialized to legion (e.g. k = 0, k = 1, etc.) before selecting the kth cascade sketch. Selecting the cascade sketch may include copying data associated with the cascade sketch to another area of the computer memory of the aggregator computing device, eg, a working area of memory.
애그리게이터 컴퓨팅 디바이스는 선택된 스케치의 카디널리티를 추정할 수 있다(동작 2106). 애그리게이터 컴퓨팅 디바이스에 의해 수신된 계단식 군단 스케치의 목록을 순위 화하기 위해, 애그리게이터 컴퓨팅 디바이스는 선택된 계단식 군단 스케치의 카디널리티(예를 들어, 노이징된 카디널리티)를 순위 추정할 수 있다. 이를 위해, 애그리게이터 컴퓨팅 디바이스는 채움 확률이 가장 높은 군단(예: i = 1, 여기서 i는 선택된 군단)에서 시작하여, 채움 확률이 가장 낮은 군단(예: i = 1, 여기서 i는 선택된 군단)에서 종료하는 스케치의 l 군단 각각을 반복할 수 있다. 각각의 선택된 군단에 대해, 애그리게이터 컴퓨팅 디바이스는 군단 내에 채워진 포지션의 수(예를 들어, 1과 같은 채움 값과 동일한 비트 수)를 군단 내에 채워지지 않은 포지션의 수와 비교할 수 있다. 애그리게이터 컴퓨팅 디바이스가 선택된 군단에 대해 채워진 포지션의 수가 채워지지 않은 포지션의 수보다 크거나 같다고 결정하면, 애그리게이터 컴퓨팅 디바이스는 계단식 군단 데이터 구조에서 다음 군단으로 이동할 수 있다. 애그리게이터 컴퓨팅 디바이스가 채워진 포지션의 수가 채워지지 않은 포지션의 수보다 적다고 결정하면, 애그리게이터 컴퓨팅 디바이스는 현재 군단 인덱스와 연관하여 선택된 군단을 참조 군단으로 저장할 수 있다(예를 들어, 애그리게이터 컴퓨팅 디바이스가 계단식 군단 데이터 구조에서 세 번째 군단으로 반복되고 첫 군단의 인덱스는 0이고 참조 군단 인덱스는 2와 같을 수 있다). 애그리게이터 컴퓨팅 디바이스는 참조 군단의 채워진 포지션 수에 2 ^(golden_legion_index)를 곱하여 선택한 노이징된 군단 데이터 구조의 카디널리티를 추정할 수 있다. 예를 들어, 참조 군단에 채워진 포지션이 10개이고 참조 군단 인덱스가 4인 경우, 애그리게이터 컴퓨팅 디바이스는 노이징된 계단식 군단 데이터 구조의 노이징된 카디널리티를 10*2^4 또는 160으로 추정할 수 있다.The aggregator computing device may estimate the cardinality of the selected sketch (act 2106). To rank the list of cascading sketches received by the aggregator computing device, the aggregator computing device may rank the cardinality (eg, the noised cardinality) of the selected cascading sketches. To this end, the aggregator computing device starts with the swarm with the highest probability of filling (e.g. i = 1, where i is the selected swarm), and proceeds to the swarm with the lowest probability of filling (e.g. i = 1, where i is the selected swarm). You can iterate through each of the l corps of sketches ending at . For each selected corps, the aggregator computing device may compare the number of filled positions in the corps (eg, a number of bits equal to a fill value equal to one) to the number of unfilled positions in the corps. If the aggregator computing device determines that the number of filled positions for the selected corps is greater than or equal to the number of unfilled positions, the aggregator computing device may move to the next corps in the cascading corps data structure. If the aggregator computing device determines that the number of filled positions is less than the number of unfilled positions, the aggregator computing device may store the selected corps in association with the current corps index as a reference swarm (eg, the aggregator computing device is repeated as the third corps in the cascading swarm data structure, the index of the first swarm is 0 and the reference swarm index may be equal to 2). The aggregator computing device may estimate the cardinality of the selected noised legion data structure by multiplying the number of filled positions in the reference legion by 2^(golden_legion_index). For example, if the reference corps has 10 filled positions and the reference corps index is 4, the aggregator computing device may estimate the noised cardinality of the noised cascade corps data structure as 10*2^4 or 160 .
애그리게이터 컴퓨팅 디바이스는 카운터 레지스터 k가 스케치의 수 n과 동일한지 여부를 결정할 수 있다(동작 2108). 애그리게이터 컴퓨팅 디바이스가 각 노이징된 계단식 군단 스케치를 사용하여 노이징된 카디널리티를 추정했는지 여부를 결정하기 위해, 애그리게이터 컴퓨팅 디바이스는 각 노이징된 계단식 군단 스케치를 선택하는데 사용되는 카운터 레지스터(예: k)를 노이징된 계단식 군단 스케치의 총 수 n과 비교할 수 있다. 카운터 레지스터 k가 노이징된 계단식 군단 스케치 n의 총 수와 동일하지 않으면(예를 들어, 더 작으면), 애그리게이터 컴퓨팅 디바이스는 동작 2110을 실행할 수 있다. 카운터 레지스터 k가 노이징된 계단식 군단 스케치의 총 수 n과 같으면(예를 들어, 동일하거나 그보다 큰 경우), 데이터 프로세싱 시스템은 동작 2112를 실행할 수 있다.The aggregator computing device may determine whether the counter register k is equal to the number n of sketches (act 2108). To determine whether the aggregator computing device has estimated the noised cardinality using each noisy cascade sketch, the aggregator computing device uses a counter register used to select each noisy cascade sketch, e.g. k ) can be compared with the total number n of the cascaded corps sketches that have been noised. If the counter register k is not equal to (eg, less than) the total number of noisy cascade sketches n , the aggregator computing device may execute operation 2110 . If the counter register k is equal to (eg, equal to or greater than) the total number n of noisy cascade corps sketches, the data processing system may execute operation 2112 .
애그리게이터 컴퓨팅 디바이스는 카운터 레지스터 k를 증가시킬 수 있다(동작 2110). 일부 구현예에서, 애그리게이터 컴퓨팅 디바이스는 수신된 계단식 군단 스케치의 세트(예를 들어, 동작 2102에서 애그리게이터 컴퓨팅 디바이스에 의해 수신된 계단식 군단 스케치 등)에서 다음 프로세싱되지 않은 노이징된 계단식 군단 스케치를 나타내기 위해 레지스터 k에 하나를 추가할 수 있다. 일부 구현예에서, 애그리게이터 컴퓨팅 디바이스는 카운터 레지스터 k를 다음 프로세싱되지 않은 계단식 군단 스케치의 메모리 어드레스 값(예를 들어, 컴퓨터 메모리에서의 위치)으로 설정할 수 있다. 일부 구현예에서, 다음 프로세싱되지 않은 계단식 군단 스케치의 메모리 어드레스 값은 현재(예를 들어, 선택된) 계단식 군단 스케치의 위치에서 데이터 구조에 포함될 수 있다. 카운터 레지스터 k의 값을 증가시킨 후, 애그리게이터 컴퓨터 디바이스는 동작 2104를 실행할 수 있다.The aggregator computing device may increment the counter register k (act 2110). In some implementations, the aggregator computing device selects the next unprocessed, noised cascading corps sketch from the set of received cascading sketches (eg, the cascading sketch received by the aggregator computing device in operation 2102). You can add one to register k to indicate In some implementations, the aggregator computing device may set the counter register k to the memory address value (eg, location in computer memory) of the next unprocessed cascade sketch. In some implementations, the memory address value of the next unprocessed cascading sketch may be included in the data structure at the location of the current (eg, selected) cascading sketch. After incrementing the value of counter register k , the aggregator computer device may execute operation 2104.
애그리게이터 컴퓨팅 디바이스는 카디널리티에 의해 스케치를 정렬할 수 있다(동작 2112). 각 차등적 비공개 계단식 군단 스케치의 노이징된 카디널리티를 추정한 후, 애그리게이터 컴퓨팅 디바이스는 추정된 노이징된 카디널리티 값에 기초하여 차등적 비공개 계단식 군단 스케치의 정렬된 목록을 생성할 수 있다. 노이징된 카디널리티 값은 각각의 계단식 군단 스케치에 기여한 세트의 카디널리티를 정확하게 표현하지 못할 수 있지만 이 방법(2100)에 설명된 대로 스케치를 정렬할 목적으로는 충분히 정확하다. 계단식 군단 스케치를 정렬하는 것은 효율적인 정렬 알고리즘(예: 힙 정렬) 또는 다른 유형의 정렬 알고리즘을 사용하여 스케치의 추정된 노이징된 카디널리티 각각을 비교하는 것을 포함할 수 있다. 정렬 알고리즘을 사용하여, 애그리게이터 컴퓨팅 디바이스는 계단식 군단 스케치의 정렬된 목록을 내림차순으로 생성할 수 있다. 예를 들어, 목록의 제1 항목은 동작 2106에서 계산된 가장 큰 노이징된 카디널리티와 연관된 계단식 군단 스케치일 수 있고, 목록의 제2 항목은 두 번째로 큰 노이징된 카디널리티와 연관된 계단식 군단 스케치일 수 있다.The aggregator computing device may sort the sketches by cardinality (act 2112). After estimating the noised cardinality of each differentially private cascaded corps sketch, the aggregator computing device may generate an ordered list of differentially private cascaded corps sketches based on the estimated noised cardinality value. The noised cardinality value may not accurately represent the cardinality of the set contributing to each cascading corps sketch, but is sufficiently accurate for the purposes of aligning the sketches as described in method 2100. Sorting the cascading corps sketches may involve comparing each of the estimated noisy cardinalities of the sketches using an efficient sorting algorithm (eg, heap sort) or another type of sorting algorithm. Using a sorting algorithm, the aggregator computing device may generate an ordered list of cascading corps sketches in descending order. For example, the first item in the list may be the cascading corps sketch associated with the largest noisy cardinality calculated in operation 2106, and the second item in the list may be the cascading corps sketch associated with the second largest noisy cardinality. can
애그리게이터 컴퓨팅 디바이스는 정렬된 스케치를 그룹화할 수 있다(동작 2114). 계단식 군단 스케치를 정렬한 후, 애그리게이터 컴퓨팅 디바이스는 각 스케치를 크기 j의 m 그룹으로 할당할 수 있고, 여기서 j는 파라미터가 약 5이지만 다른 값과 같을 수 있다. 파라미터 j는 애그리게이터 컴퓨팅 디바이스의 메모리에 있는 하나 이상의 데이터 구조로부터 검색될 수 있다. 예를 들어, 애그리게이터 컴퓨팅 디바이스는 목록에서 제1 j개의 스케치를 선택하여 제1 그룹에 할당할 수 있다. 애그리게이터 컴퓨팅 디바이스는 목록에서 그룹화되지 않은 다음 j개 스케치를 선택하고, 다음 그룹에 할당할 수 있으며, 애그리게이터 컴퓨팅 디바이스가 크기가 j 인 m개의 스케치 그룹을 생성할 때까지 계속할 수 있다.The aggregator computing device may group the sorted sketches (act 2114). After sorting the cascading corps sketches, the aggregator computing device can assign each sketch into m groups of size j , where j has a parameter of about 5, but can be any other value. Parameter j may be retrieved from one or more data structures in memory of the aggregator computing device. For example, the aggregator computing device may select a first j number of sketches from the list and assign them to the first group. The aggregator computing device may select the next j ungrouped sketches from the list, assign them to the next group, and so on until the aggregator computing device creates m groups of sketches of size j .
애그리게이터 컴퓨팅 디바이스는 g 번째 그룹을 선택할 수 있다(동작 2116). 동작 2114에서 생성된 각 그룹의 Monte Carlo 샘플링된 카디널리티를 프로세싱하고 결정하기 위해, 애그리게이터 컴퓨팅 디바이스는 애그리게이터 컴퓨팅 디바이스에서 생성된 각 그룹을 반복할 수 있다. 애그리게이터 컴퓨팅 디바이스는 카운터 레지스터 g에 기초하여 각 그룹을 반복적으로 루프할 수 있다. 그룹 각각은 인덱스 값(예를 들어, 인덱스 0, 인덱스 1, 인덱스 2 등)에 의해 데이터 구조에서 인덱스될 수 있다. 그룹을 프로세싱하기 위해, 데이터 프로세싱 시스템은 카운터 레지스터 g와 동일한(거의 동일한) 그룹을 포함하거나 그와 연관된 노이즈 값을 선택할 수 있다 그것이 루프의 첫 번째 반복이라면, 카운터 레지스터 g는 g번째 그룹을 선택하기 전에 초기화 값(예를 들어, g = 0, g = 1 등)으로 초기화될 수 있다. 그룹을 선택하는 것은 그룹과 연관된 데이터를 애그리게이터 컴퓨팅 디바이스의 컴퓨터 메모리의 다른 영역, 예를 들어 메모리의 작업 영역에 복사하는 것을 포함할 수 있다. The aggregator computing device may select the g-th group (act 2116). To process and determine the Monte Carlo sampled cardinality of each group generated in operation 2114, the aggregator computing device may iterate through each group generated at the aggregator computing device. The aggregator computing device can iteratively loop through each group based on the counter register g . Each group may be indexed in the data structure by an index value (eg, index 0, index 1, index 2, etc.). To process a group, the data processing system can select a noise value that contains or is associated with a group that is identical (nearly identical) to counter register g . If that is the first iteration of the loop, counter register g selects the gth group. It may be initialized to an initialization value (eg, g = 0, g = 1, etc.). Selecting the group may include copying data associated with the group to another area of the computer memory of the aggregator computing device, for example a working area of memory.
애그리게이터 컴퓨팅 디바이스는 Monte Carlo 샘플링을 사용하여 선택한 그룹의 유니온을 추정할 수 있다(동작 2118). Monte Carlo 샘플링을 사용하여 카디널리티를 추정하는 것은 그룹에 있는 벡터의 조합 벡터를 결정하고, 특정 포지션에서 비트가 플립될 확률을 계산하고, 각각의 입력 스케치의 디노이징된 유니온을 추정하는 디노이징된 추정 스케치를 생성하는 것을 포함할 수 있다. 다음 의사 코드의 두 스케치에 대한 프로세스가 아래에 표시되어 있지만 약간의 수정으로 두 개 이상의 스케치로 확장될 수 있다: The aggregator computing device may estimate the union of the selected group using Monte Carlo sampling (act 2118). Estimating cardinality using Monte Carlo sampling is a denoised estimate that determines the combinatorial vector of vectors in a group, computes the probability that a bit will flip at a particular position, and estimates the denoised union of each input sketch. This may include creating sketches. The process for two sketches of the following pseudocode is shown below, but can be extended to more than two sketches with minor modifications:
def GetCombinationsVector(s1, s2): def GetCombinationsVector(s1, s2):
"""Compute vector of combinations of bits in sketches.""" """Compute vector of combinations of bits in sketches."""
v = [0, 0, 0, 0] v = [0, 0, 0, 0]
for x, y in zip(s1, s2): for x, y in zip (s1, s2):
v[x+2*y] += 1 v[x+2*y] += 1
return v return v
def ProbabilityOfOr(bit_a, bit_b, priors_map): def ProbabilityOfOr(bit_a, bit_b, priors_map):
prob_map = {} prob_map = {}
p = 0.1 p = 0.1
q = 1 - p q = 1 - p
for true_a in [0, 1]: for true_a in [0, 1]:
for true_b in [0, 1]: for true_b in [0, 1]:
flip_a_needed = 1 if bit_a != true_a else 0 flip_a_needed = 1 if bit_a != true_a else 0
flip_b_needed = 1 if bit_b != true_b else 0 flip_b_needed = 1 if bit_b != true_b else 0
prob_map[true_a,true_b] = priors_map[true_a,true_b]*( prob_map[true_a,true_b] = priors_map[true_a,true_b]*(
p ** flip_a_needed * q ** (1 - flip_a_needed) * p ** flip_a_needed * q ** (1 - flip_a_needed) *
p ** flip_b_needed * q ** (1 - flip_b_needed)) p ** flip_b_needed * q ** (1 - flip_b_needed))
prob_00 = prob_map[0, 0] / sum(prob_map.values())prob_00 = prob_map[0, 0] / sum (prob_map.values())
return 1 - prob00 return 1 - prob00
def DenoisedUnion(s1, s2): def DenoisedUnion(s1, s2):
p = 0.1 p = 0.1
q = 1 - p q = 1 - p
v = GetCombinationsVector(s1, s2) v = GetCombinationsVector(s1, s2)
assert p == 0.1, "For now only case p=0.1 is simulated" assert p == 0.1, "For now only case p=0.1 is simulated"
v =numpy.matrix([[ 1.265625,-0.140625,-0.140625, 0.015625], v =numpy.matrix([[ 1.265625,-0.140625,-0.140625, 0.015625],
[-0.140625, 1.265625, 0.015625,-0.140625], [-0.140625, 1.265625, 0.015625,-0.140625],
[-0.140625, 0.015625, 1.265625,-0.140625], [-0.140625, 0.015625, 1.265625,-0.140625],
[ 0.015625,-0.140625,-0.140625, 1.265625]])* [ 0.015625,-0.140625,-0.140625, 1.265625]])*
numpy.array(v).reshape(4, 1)numpy.array(v).reshape(4, 1)
priors_map = {(0,0):v[0], (1,0):v[1], (0,1):v[2], (1,1):v[3]} priors_map = {(0,0):v[0], (1,0):v[1], (0,1):v[2], (1,1):v[3]}
probs = [ProbabilityOfOr(x, y, priors_map) for x, y in zip(s1,s2)]probs = [ProbabilityOfOr(x, y, priors_map) for x, y in zip (s1,s2)]
result = [int(random.uniform(0,1) < x) for x in probs]result = [ int (random.uniform(0,1) < x) for x in probs]
return result return result
위의 의사 코드는 0.1의 확률을 포함하는 것으로 표시되지만, 조합 벡터 v를 곱하는데 사용되는 역행렬에 대응 변경이 수행되는 한 p의 값은 임의의 값으로 변경될 수 있음을 이해해야 한다. 또한, 위의 의사 코드에서 두 개의 스케치만 결합될 수 있지만, 이 숫자는 둘 이상의 벡터를 수용하기 위해 조합 벡터의 파라미터, 역행렬의 크기 및 ProbabilityOfOr 함수를 변경하여 확장할 수 있음을 이해해야 한다. 다른 구현예에서, 2개의 그룹에 대한 디노이징된 유니온을 결정하는데 사용되는 방법이 사용될 수 있다(예를 들어, 그룹 크기를 결정하기 위한 파라미터 j가 2로 설정될 수 있는 등).Although the above pseudocode is shown to contain a probability of 0.1, it should be understood that the value of p can be changed to any value as long as a corresponding change is made to the inverse matrix used to multiply the combinatorial vector v . Also, while only two sketches can be combined in the above pseudocode, it should be understood that this number can be extended by changing the parameters of the combining vector, the size of the inverse matrix and the ProbabilityOfOr function to accommodate more than one vector. In another implementation, the method used to determine the denoised union for the two groups can be used (eg, the parameter j for determining the group size can be set to 2, etc.).
애그리게이터 컴퓨팅 디바이스는 카운터 레지스터 g가 그룹의 수 m과 동일한지 여부를 결정할 수 있다(결정 2120). 애그리게이터 컴퓨팅 디바이스가 각각의 계단식 군단 스케치 그룹을 사용하여 유니온 몬테 카를로 샘플링 값을 추정했는지 여부를 결정하기 위해, 애그리게이터 컴퓨팅 디바이스는 각 그룹을 선택하는 데 사용된 카운터 레지스터(예를 들어, g)를 총 그룹 수 m과 비교할 수 있다. 카운터 레지스터 g가 그룹의 총 수 m과 동일하지 않으면(예를 들어, 더 작으면), 애그리게이터 컴퓨팅 디바이스는 동작 2122을 실행할 수 있다. 카운터 레지스터 g가 그룹의 총 수 m과 같으면(예를 들어, 동일하거나 그보다 큰 경우), 데이터 프로세싱 시스템은 동작 2124를 실행할 수 있다.The aggregator computing device may determine whether the counter register g is equal to the number of groups m (decision 2120). To determine whether the aggregator computing device has estimated the union Monte Carlo sampling value using each group of cascaded swarm sketches, the aggregator computing device uses the counter register (e.g., g ) used to select each group. can be compared with the total number of groups m . If the counter register g is not equal to (eg, less than) the total number of groups m , the aggregator computing device may execute operation 2122 . If the counter register g is equal to the total number of groups m (eg, equal to or greater than), the data processing system can execute operation 2124.
애그리게이터 컴퓨팅 디바이스는 카운터 레지스터 g를 증가시킬 수 있다. 일부 구현예에서, 애그리게이터 컴퓨팅 디바이스는 계단식 군단 스케치 그룹의 세트(예를 들어, 동작 2114에서 애그리게이터 컴퓨팅 디바이스에 의해 생성된 계단식 군단 스케치의 그룹 등)에서 다음 프로세싱되지 않은 계단식 군단 스케치 그룹을 나타내기 위해 레지스터 g에 1을 추가할 수 있다. 일부 구현예에서, 애그리게이터 컴퓨팅 디바이스는 카운터 레지스터 g를 다음 프로세싱되지 않은 그룹의 메모리 어드레스 값(예를 들어, 컴퓨터 메모리에서의 위치)으로 설정할 수 있다. 일부 구현예에서, 다음 프로세싱되지 않은 그룹의 메모리 어드레스 값은 현재(예를 들어, 선택된) 그룹의 위치에서 데이터 구조에 포함될 수 있다. 카운터 레지스터 g의 값을 증가시킨 후, 애그리게이터 컴퓨터 디바이스는 동작 2116를 실행할 수 있다.The aggregator computing device may increment the counter register g . In some implementations, the aggregator computing device indicates the next unprocessed cascaded corps sketch group in the set of cascaded corps sketch groups (eg, the group of cascaded corps sketches generated by the aggregator computing device in operation 2114, etc.) You can add 1 to register g to In some implementations, the aggregator computing device may set the counter register g to the memory address value (eg, location in computer memory) of the next unprocessed group. In some implementations, the next unprocessed group's memory address value may be included in the data structure at the location of the current (eg, selected) group. After incrementing the value of the counter register g , the aggregator computer device may execute operation 2116.
애그리게이터 컴퓨팅 디바이스는 g 그룹 유니온 값의 유니온으로부터 카디널리티를 추정할 수 있다(동작 2124). 위에서 설명한 것처럼, m 그룹의 계단식 군단 스케치 각각을 몬테 카를로 샘플링하여 생성된 스케치는 각 그룹 멤버의 디노이징된 유니온을 나타낸다. 따라서 몬테카를로 샘플 스케치 각각의 유니온은 단계 2102에서 수신된 모든 계단식 군단 스케치의 디노이징된 통합을 나타내는 결합된 유니온 스케치를 결정하기 위해 기본 집합(예: 각 그룹에 걸쳐 비트 OR 연산 등)에 의해 결정될 수 있다. 애그리게이터 컴퓨팅 디바이스는 생성된 몬테카를로 샘플 스케치 각각을 집합(예를 들어, 반복적으로 비트 ORing, 추가 등)하여 결합된 계단식 군단 스케치를 생성할 수 있다. 애그리게이터 컴퓨팅 디바이스는 결합된 스케치를 사용하여 단계 2102에서 수신된 스케치의 유니온의 디노이징된 카디널리티를 결정할 수 있다. The aggregator computing device may estimate the cardinality from the union of g- group union values (act 2124). As described above, the sketch generated by Monte Carlo sampling of each of the m group's cascading corps sketches represents the denoised union of each group member. Thus, the union of each of the Monte Carlo sample sketches can be determined by a basis set (e.g., a bitwise OR operation across each group, etc.) to determine a combined union sketch representing the denoised union of all cascading corps sketches received at step 2102. there is. The aggregator computing device may generate a combined cascade corps sketch by aggregating (eg, iteratively bitwise ORing, adding, etc.) each of the generated Monte Carlo sample sketches. The aggregator computing device may use the combined sketch to determine the denoised cardinality of the union of sketches received in step 2102 .
이를 위해, 애그리게이터 컴퓨팅 디바이스는 채움 확률이 가장 높은 군단(예: i = 1, 여기서 i는 선택된 군단)에서 시작하여, 채움 확률이 가장 낮은 군단(예: i = 1, 여기서 i는 선택된 군단)에서 종료하는 결합된 스케치의 l 군단 각각을 반복할 수 있다. 각각의 선택된 군단에 대해, 애그리게이터 컴퓨팅 디바이스는 군단 내에 채워진 포지션의 수(예를 들어, 1과 같은 채움 값과 동일한 비트 수)를 군단 내에 채워지지 않은 포지션의 수와 비교할 수 있다. 애그리게이터 컴퓨팅 디바이스가 선택된 군단에 대해 채워진 포지션의 수가 채워지지 않은 포지션의 수보다 크거나 같다고 결정하면, 애그리게이터 컴퓨팅 디바이스는 결합된 스케치에서 다음 군단으로 이동할 수 있다. 애그리게이터 컴퓨팅 디바이스가 채워진 포지션의 수가 채워지지 않은 포지션의 수보다 적다고 결정하면, 애그리게이터 컴퓨팅 디바이스는 현재 군단 인덱스 i와 연관하여 선택된 군단을 참조 군단으로 저장할 수 있다(예를 들어, 애그리게이터 컴퓨팅 디바이스가 결합된 스케치에서 세 번째 군단으로 반복되고 첫 군단의 인덱스는 0이고 참조 군단 인덱스 i는 2와 같을 수 있다). 애그리게이터 컴퓨팅 디바이스는 참조 군단의 채워진 포지션 수에 2 ^(golden_legion_index)를 곱하여 결합된 스케치의 디노이징된 카디널리티를 추정할 수 있다. 예를 들어, 참조 군단에 채워진 포지션이 10개이고 참조 군단 인덱스가 4인 경우, 애그리게이터 컴퓨팅 디바이스는 노이징된 계단식 군단 데이터 구조의 노이징된 카디널리티를 10*2^4 또는 160으로 추정할 수 있다.To this end, the aggregator computing device starts with the swarm with the highest probability of filling (e.g. i = 1, where i is the selected swarm), and proceeds to the swarm with the lowest probability of filling (e.g. i = 1, where i is the selected swarm). You can iterate through each of the l corps of the combined sketches ending at . For each selected corps, the aggregator computing device may compare the number of filled positions in the corps (eg, a number of bits equal to a fill value equal to one) to the number of unfilled positions in the corps. If the aggregator computing device determines that the number of filled positions for the selected corps is greater than or equal to the number of unfilled positions, the aggregator computing device may move to the next corps in the combined sketch. If the aggregator computing device determines that the number of filled positions is less than the number of unfilled positions, the aggregator computing device may store the selected corps in association with the current swarm index i as a reference swarm (eg, aggregator computing If the device is repeated as the third corps in the combined sketch, the index of the first corps is 0 and the reference corps index i may be equal to 2). The aggregator computing device may estimate the denoised cardinality of the combined sketch by multiplying the number of filled positions in the reference legion by 2^(golden_legion_index). For example, if the reference corps has 10 filled positions and the reference corps index is 4, the aggregator computing device may estimate the noised cardinality of the noised cascade corps data structure as 10*2^4 or 160 .
애그리게이터 컴퓨팅 디바이스는 요청에 응답하여 방법 2100의 단계를 수행할 수 있다. 예를 들어, 외부 컴퓨팅 디바이스는 식별자 서버에 상주하는 식별자 및 속성 데이터 세트의 디노이징된 카디널리티에 대한 요청을 애그리게이터 컴퓨팅 디바이스에 제공할 수 있다. 그 다음, 애그리게이터 컴퓨팅 디바이스는 각각의 식별자 서버(예를 들어, 각각의 데이터 프로세싱 시스템(105A-N) 등)로부터 계단식 군단 스케치를 요청할 수 있다. 각각의 데이터 프로세싱 시스템(105)은 섹션 B에 설명된 바와 같이 계단식 군단 스케치를 생성할 수 있고, 여기에서 전술한 바와 같이 확률 p로 스케치의 비트를 플립함으로써 확률적 노이즈를 적용할 수 있다. 스케치를 생성한 후, 데이터 프로세싱 시스템(105)은 추가 프로세싱을 위해 그들의 스케치를 애그리게이터 컴퓨팅 디바이스로 전송할 수 있다. 애그리게이터 컴퓨팅 디바이스는 방법(2100)의 단계(2102)에서와 같이 데이터 프로세싱 시스템(105)으로부터 스케치를 수신할 수 있고, 그 다음 스케치에 기여한 식별자의 카디널리티를 결정하는 방법의 단계를 수행할 수 있다. 카디널리티를 결정한 후, 애그리게이터 컴퓨팅 디바이스는 멀티세트의 추정된 카디널리티를 요청을 담당하는 외부 컴퓨팅 디바이스에 전송할 수 있다.The aggregator computing device may perform the steps of method 2100 in response to the request. For example, an external computing device may provide a request for a denoised cardinality of an identifier and attribute data set residing in an identifier server to an aggregator computing device. The aggregator computing device may then request the cascading corps sketch from each identifier server (eg, each data processing system 105A-N, etc.). Each data processing system 105 may generate a cascading corps sketch as described in Section B, where it may apply stochastic noise by flipping bits of the sketch with probability p as described above. After creating the sketches, the data processing system 105 may send their sketches to the aggregator computing device for further processing. The aggregator computing device can receive the sketch from the data processing system 105 as in step 2102 of method 2100 and then perform the steps of the method to determine the cardinality of the identifiers that contributed to the sketch. . After determining the cardinality, the aggregator computing device may send the multiset of estimated cardinalities to the external computing device responsible for the request.
본 명세서에 설명된 기술은 다수의 기술적 이점을 제공한다. 각각의 데이터 프로세싱 시스템(105)이 네트워크를 통해 많은 양의 데이터를 전송하여 네트워크 리소스를 소모하는 대신, 각 데이터 프로세싱 시스템은 계산 기법을 사용하여 (1) 전체 식별자 및 속성 세트를 표현하고, (2) 차등적으로 비공개인 작은 데이터 구조를 생성할 수 있다. 또한, 계단식 군단 스케치를 생성하기 위해 본 명세서에 기술된 계산 기법은 식별자 서버에 의해 유지되는 식별자의 수에 따라 계산 복잡도가 선형적으로 확장된다. 스케치가 나타내는 데이터보다 훨씬 작을 수 있기 때문에, 데이터 자체 대신 스케치를 차등적 비공개로 배포하면 네트워킹 리소스에 대한 부하를 감소시킨다. 이것은 네트워킹 기술의 개선이다. 또한 스케치가 차등적 비공개이기 때문에, 스케치로 표현된 데이터를 다른 컴퓨팅 디바이스에 배포할 필요가 없으므로 네트워킹 시스템과 카디널리티 추정기 시스템의 보안이 향상된다.The technology described herein provides a number of technological advantages. Instead of each data processing system 105 sending large amounts of data over the network and consuming network resources, each data processing system uses computational techniques to (1) represent the entire set of identifiers and attributes, (2) ) can create small data structures that are differentially private. Additionally, the computational techniques described herein for generating cascading corps sketches scale linearly in computational complexity with the number of identifiers maintained by the identifier server. Because sketches can be much smaller than the data they represent, distributing the sketches as differential privacy instead of the data itself reduces the load on networking resources. This is an improvement in networking technology. Also, because the sketch is differentially private, the data represented by the sketch does not need to be distributed to other computing devices, which increases the security of the networking system and cardinality estimator system.
D. 빈도 및 카디널리티 추정을 위한 연속 액체 군단 기법D. Continuous liquid swarm technique for frequency and cardinality estimation
카디널리티 및 빈도 추정 기법이 소개된다. 이러한 방법은 HyperLogLog 및 블룸 필터의 양태를 결합하여 아이템 할당을 버킷에 기하학적으로 배포하여 블룸 필터보다 더 간결한 스케치를 작성할 수 있다. 본 명세서에 기술된 시스템 및 방법은 버킷 단위 합계를 사용하여 스케치를 결합할 수 있으며, 동형 암호화를 활용하여 신뢰할 수 없는 여러 당사자 간에 스케치를 결합하는 안전한 다자간 계산 프로토콜을 생성할 수 있는 동시에 프로토콜 당사자가 합의된 출력에 대한 차등적 비공개 추정치를 학습한다.Cardinality and frequency estimation techniques are introduced. This method combines aspects of HyperLogLog and bloom filters to geometrically distribute item assignments into buckets, allowing for a more concise sketch than bloom filters. The systems and methods described herein can combine sketches using bucket-by-bucket sums and utilize homomorphic encryption to create secure multi-party computational protocols that combine sketches between multiple untrusted parties while allowing protocol parties to Learn differential privacy estimates for the agreed output.
디바이스 식별자의 빈도는 특정 콘텐츠 아이템에 액세스한 디바이스 식별자(이후에는 디바이스 또는 식별자라고도 함)의 수일 수 있다. 이와 같이, 카디널리티는 콘텐츠 아이템에 액세스한 고유 디바이스 식별자의 수일 수 있고, 빈도는 미리 결정된 횟수 이상 콘텐츠 아이템에 액세스한 고유 디바이스 식별자의 수일 수 있으므로 관련된 값이다. 예를 들어, 1+ 빈도(예를 들어, 콘텐츠에 한 번 이상 액세스한 고유 디바이스 식별자의 수 등)는 서로 다른 퍼블리셔 컴퓨팅 디바이스에 걸쳐 식별자 세트의 멀티세트의 카디널리티일 수 있다. 콘텐츠의 빈도를 결정하는 적어도 두 가지 방법, 즉 빈도 히스토그램과 k+ 도달이 여기에 설명된다. 빈도 히스토그램은 각 빈도를 가지는 디바이스 비율을 표시할 수 있으며, k+ 도달은 빈도가 k보다 큰 디바이스의 세트의 카디널리티를 나타낼 수 있다. 데이터 세트에 대한 단일 패스만으로 값 범위에 대한 빈도를 추정하면, 추정을 수행하는데 필요한 계산 리소스의 양이 줄어들기 때문에 카디널리티 추정 컴퓨터 시스템이 개선된다. 빈도에 대해 계산된 최대 값은 미리 결정된 최대 빈도 값에 기초할 수 있고, 이는 콘텐츠 제공자가 이 메트릭을 사용하여 콘텐츠 노출을 제한할 수 있기 때문이다.The frequency of device identifiers may be the number of device identifiers (hereinafter also referred to as devices or identifiers) that have accessed a particular content item. As such, cardinality may be the number of unique device identifiers that have accessed a content item, and frequency may be the number of unique device identifiers that have accessed a content item more than a predetermined number of times, and thus are related values. For example, a 1+ frequency (eg, the number of unique device identifiers that have accessed content more than once, etc.) may be the cardinality of multisets of identifier sets across different publisher computing devices. At least two methods for determining the frequency of content are described here: frequency histograms and k+ arrivals. The frequency histogram may indicate the proportion of devices with each frequency, and k+ arrivals may indicate the cardinality of the set of devices with frequencies greater than k. Estimating frequencies for a range of values with only a single pass over a data set improves cardinality estimation computer systems because the amount of computational resources required to perform the estimation is reduced. The maximum value calculated for frequency may be based on a predetermined maximum frequency value, as content providers may use this metric to limit content exposure.
이 기술 솔루션의 시스템 및 방법은 콘텐츠 퍼블리셔의 도달 범위 및 빈도를 결정할 수 있으며, 여기서 콘텐츠 퍼블리셔 컴퓨팅 디바이스(예: 임의의 데이터 프로세싱 시스템(105A-N) 등)는 콘텐츠를 호스팅하고 제공하는 엔티티로 정의된다. 그러나, 콘텐츠 퍼블리셔는 서로를 신뢰하지 않을 수 있으므로, 카디널리티와 빈도를 결정하는데 사용되는 스케치를 직접 공유할 수 없다. 본 명세서에 기술된 카디널리티 및 빈도 측정을 위한 시스템 및 방법은 스케치를 구성하는 식별자 또는 디바이스의 프라이버시를 보존할 수 있으며, 콘텐츠 퍼블리셔 컴퓨팅 디바이스가 서로에 대한 정보를 학습하는 것을 방지하여 네트워킹 시스템의 전체 보안을 향상시킬 수 있다. The systems and methods of this technology solution may determine the reach and frequency of content publishers, where a content publisher computing device (eg, any data processing system 105A-N, etc.) is defined as an entity that hosts and provides content. do. However, content publishers may not trust each other, so they cannot directly share the sketches used to determine cardinality and frequency. The systems and methods for cardinality and frequency measurement described herein can preserve the privacy of identifiers or devices that make up sketches, and prevent content publisher computing devices from learning information about each other, thereby ensuring overall security of a networking system. can improve
보안 및 프라이버시 보호 방식으로 하나 이상의 퍼블리셔 컴퓨팅 디바이스에 걸쳐 식별자의 카디널리티 및 빈도를 결정하는 다양한 방법이 설명될 것이다: 카디널리티 및 빈도를 추정하기 위해 블룸 필터의 기하학적으로 분산된 어레이일 수 있는 계단식 군단(Cascading Legions)(예를 들어, 여기에서 섹션 B 및 C 등에서 위에서 설명됨); 계단식 군단 알고리즘의 연속 버전일 수 있는 액체 군단(Liquid Legions)(예: 이 섹션에서 설명됨); 다중 퍼블리셔 도달 범위를 추정하기 위해 차등 프라이버시를 적용하는 두 가지 메커니즘; 및 두 가지 유형의 스케치를 결합하고 차등적 비공개인 빈도 추정치를 생성하기 위한 다자간 계산 프로토콜.Various methods of determining the cardinality and frequency of an identifier across one or more publisher computing devices in a secure and privacy preserving manner will be described: Legions) (eg, described above in Sections B and C, etc. herein); Liquid Legions, which can be a continuous version of the cascading legion algorithm (eg as described in this section); Two mechanisms to apply differential privacy to estimate multi-publisher reach; and a multiparty computational protocol for combining the two types of sketches and generating differentially private frequency estimates.
카디널리티를 추정하는 또 다른 기법은 HyperLogLog이다. HyperLogLog(HLL)는 낮은 오류율, 낮은 분산 및 낮은 메모리 사용을 특징으로 하는 카디널리티 추정기일 수 있다. 또한, 두 HLL의 유니온은 계산하기가 간단할 수 있으므로, HLL이 분산 카운팅 애플리케이션에 이상적일 수 있다. 카디널리티와 빈도를 모두 추정할 수 있는 HLL의 확장을 FreqLogLog라고 한다. 이를 위해, FreqLogLogs(FLL)는 레지스터 당 두 개의 추가 값, 카운트 및 지문을 저장할 수 있다. HLL 레지스터 값이 업데이트되면, 아이템의 지문이 저장되고 카운터가 1로 재설정된다. 그 다음, 해당 레지스터에 할당된 다른 아이템이 이전 아이템과 동일한 수의 선행 0이 있을 때 지문이 비교된다. 동일한 경우, 카운트가 증가된다. 그렇지 않으면, 새 지문이 이전 지문보다 크면, 새 지문이 저장되고 카운트는 1로 재설정된다. 그렇지 않으면, 이전 지문이 더 커지고 아무것도 수정되지 않는다.Another technique for estimating cardinality is HyperLogLog. HyperLogLog (HLL) can be a cardinality estimator characterized by low error rate, low variance and low memory usage. Also, the union of the two HLLs can be simple to compute, making the HLL ideal for distributed counting applications. An extension of HLL that can estimate both cardinality and frequency is called FreqLogLog. To this end, FreqLogLogs (FLL) can store two additional values per register, count and fingerprint. When the HLL register value is updated, the fingerprint of the item is saved and the counter is reset to 1. Then, the fingerprints are compared when another item assigned to that register has the same number of leading zeros as the previous item. If equal, the count is incremented. Otherwise, if the new fingerprint is greater than the old fingerprint, the new fingerprint is saved and the count is reset to one. Otherwise, the previous fingerprint is larger and nothing is modified.
이러한 또 다른 기법은 블룸 필터에 기초한다. HLL과 마찬가지로, Bloom 필터는 카디널리티와 빈도를 계산하는데 사용될 수 있으며 비교적 더 높은 메모리 요구 사항을 가질 수 있다. 블룸 필터의 카디널리티는Another such technique is based on a bloom filter. Like HLL, Bloom filters can be used to compute cardinality and frequency and can have relatively higher memory requirements. The cardinality of the bloom filter is
를 평가하여 결정될 수 있다. 여기서 k는 블룸 필터를 생성하는데 사용된 해시의 수, m은 블룸 필터의 비트 수, x는 블룸 필터의 채워진 버킷 수, n은 블룸 필터의 카디널리티의 추정치 수다.can be determined by evaluating where k is the number of hashes used to generate the bloom filter, m is the number of bits in the bloom filter, x is the number of filled buckets in the bloom filter, and n is the number of estimates of the cardinality of the bloom filter.
k가 1로 이동하고 함수를 반전하면, 다음 공식:When k shifts to 1 and the function is inverted, the formula:
을 사용하여 설정된 크기에 따라 활성 비트 수를 추정할 수 있다.The number of active bits can be estimated according to the set size using .
다른 컴퓨팅 디바이스로 전송할 때 스케치의 차등 프라이버시를 유지하기 위해 ElGamal 암호화를 사용할 수 있다(예: 섹션 A 등에서 설명됨). ElGamal 암호화는 임계 복호화를 지원하도록 적응될 수 있는 간단한 공개 키 암호화 방식이다. Diffie-Hellman 키 교환 프로토콜의 오프라인 변형으로 볼 수 있다. 생성기 G를 가진 그룹에 대한 기본 체계는 다음과 같다:ElGamal encryption can be used to maintain the differential privacy of sketches when transferring to other computing devices (e.g. as described in Section A, etc.). ElGamal cryptography is a simple public key cryptographic scheme that can be adapted to support critical decryption. It can be viewed as an offline variant of the Diffie-Hellman key exchange protocol. The basic scheme for a group with generator G is:
KeyGen: 랜덤 정수 X modulo q(그룹의 순서)를 선택한다. 이는 복호화에 사용되는 개인 키이다; 공개 키는 G^X이다.KeyGen: Choose a random integer X modulo q (order of groups). This is the private key used for decryption; The public key is G^X.
Encrypt(pk, m): 랜덤 정수 R modulo q를 선택한다. 암호문은(G^R, m pk^R), 즉(G^R, m G^(XR))이다.Encrypt(pk, m): Choose a random integer R modulo q. The ciphertext is (G^R, m pk^R), i.e. (G^R, m G^(XR)).
Decrypt(sk, m): 비밀 키를 사용하여 G^(XR)을 계산한 다음 m = m pk^R/G^(XR).Decrypt(sk, m): Compute G^(XR) using the secret key, then m = m pk^R/G^(XR).
이 체계의 N-of-N 임계 버전은 모든 공개 키를 함께 곱하여 구성될 수 있다. 이 임계 변형의 예는 다음과 같다. 두 당사자가 G^X 및 G^Y 키를 생성할 수 있다. 이러한 공개 키를 곱하면 G^(X + Y)로 계산되어 암호화를 위한 공개 키로 사용될 수 있다; 대응 비밀 키는 X + Y다. 복호화를 위해, 원래 비밀 키를 (순서에 관계없이) 하나씩 적용할 수 있으므로, 단일 당사자가 공동 개인 키를 알 필요가 없다.An N-of-N critical version of this scheme can be constructed by multiplying all public keys together. An example of this critical strain is: Both parties can generate G^X and G^Y keys. Multiplying this public key is calculated as G^(X + Y), which can be used as the public key for encryption; The corresponding secret key is X + Y. For decryption, the original secret keys can be applied one by one (in any order), so that no single party needs to know the joint private key.
ElGamal 암호화는 곱셈 동형을 지원할 수 있다. 두 개의 암호문 (G^R1, M1 G^X R1), (G^R2, M2 G^X R2)이 주어지면, 값 (G^(R1 + R2), M1 M2 G^X(R1 + R2))은 두 메시지의 곱을 복호화하기 위해 계산될 수 있다. 이것은 메시지의 이산 로그에 대한 부가적인 동형일 수 있다; 즉, 값 (G^(R1 + R2), G^(M1 + M2) G^X(R1 + R2))이 계산될 수 있으며, 이는 작은 메시지 공간(이산 로그를 효율적으로 계산할 만큼 충분히 작음)에 사용될 수 있다.ElGamal encryption can support multiplicative isomorphism. Given two ciphertexts (G^R1, M1 G^X R1), (G^R2, M2 G^X R2), the values (G^(R1 + R2), M1 M2 G^X(R1 + R2) ) can be calculated to decode the product of two messages. This can be an additive isomorphism to the discrete log of messages; That is, the values (G^(R1 + R2), G^(M1 + M2) G^X(R1 + R2)) can be computed in a small message space (small enough to compute the discrete logarithm efficiently). can be used
지수로 합계를 수행하는 것으로 충분할 수 있다. 예를 들어, 2^v1 및 2^v2로 표현되는 v1, v2 값을 가진 두 정수는 곱셈적으로 결합하여 2^(v1 + v2)의 결합된 암호문을 산출할 수 있다. 또한, 아래에서 설명된 스케치는 최대 원하는 주파수보다 적은 수의 엘리먼트를 사용할 수 있기 때문에, 이러한 잘 알려진 값만 디코딩하기 위해 룩업 테이블을 사용할 수 있다. 여기에 작은 보안 이점도 있다: 애그리게이터는 해당 값이 무엇인지 알지 않고도 임계치를 초과하는 값의 카운트를 학습할 수 있다. 이를 위해, 작업자는 암호화(예: Pohlig-Hellman 암호 등)를 사용할 수 있으며, 이는 각 작업자가 부분적으로 복호화된 모든 버킷에 적용되는 비밀 지수를 선택하는 것을 포함할 수 있다. 이것은 동형을 통해 수행될 수 있으며, 생성기 G를 임의의 그룹 엘리먼트로 변경하는 것과 동일할 수 있다.It may be sufficient to perform the summation exponentially. For example, two integers with values v1 and v2, expressed as 2^v1 and 2^v2, can be multiplicatively combined to yield the combined ciphertext of 2^(v1 + v2). Also, since the sketch described below may use fewer elements than the maximum desired frequency, a lookup table can be used to decode only these well-known values. There's also a small security benefit here: the aggregator can learn counts of values that exceed a threshold without knowing what those values are. To do this, workers can use cryptography (such as the Pohlig-Hellman cipher), which can involve each worker choosing a secret exponent that applies to all partially decrypted buckets. This can be done via isomorphism and can be equivalent to changing generator G to any group element.
멀티세트의 카디널리티 및 빈도를 추정하는 또 다른 기법은 계단식 군단 스케치를 사용하여 구현될 수 있다. 블룸 필터 정확도를 위한 비트 수는 측정되어야 하는 세트의 카디널리티에 따라 선형적으로 증가할 수 있다. CascadingLegions(CL)의 registers(즉, 아이템의 존재를 기록하는 비트)를 2차원 어레이(또는 행렬)로 배열하면 비트 수의 선형 증가를 완화할 수 있다. 어레이의 열을 legions라고 하고 행을 positions이라고 한다. 따라서 각 아이템은 register인 군단의 (legion, position) 튜플에 매핑된다. 군단에 대한 확률 분포는 기하학적이고 포지션에 걸쳐 균일하므로 각 군단은 단일 해시 블룸 필터일 수 있다. 이 체계는 고정된 상대 오차로 카디널리티를 추정할 수 있으며, 필요한 스케치 크기는 측정되어야 하는 세트의 카디널리티와 함께 대수적으로 증가할 수 있다. 또한, 블룸 필터와 마찬가지로, CL 스케치 레지스터는 비트단위-OR 연산을 통해 결합될 수 있거나 또는 스케치가 빈도 문제에 필요한 카운터를 포함하는 경우, 스케치는 레지스터단위로 합산하여 결합될 수 있다.Another technique for estimating the cardinality and frequency of multisets can be implemented using cascaded corps sketches. The number of bits for bloom filter accuracy can increase linearly with the cardinality of the set to be measured. The linear increase in the number of bits can be mitigated by arranging the registers of CascadingLegions (CL) (i.e., the bits that record the existence of an item) into a two-dimensional array (or matrix). The columns of the array are called legions and the rows are called positions . So, each item is mapped to the (legion, position) tuple of the register , the legion. Since the probability distribution over swarms is geometric and uniform across positions, each swarm can be a single hash bloom filter. This scheme can estimate the cardinality with a fixed relative error, and the required sketch size can grow logarithmically with the cardinality of the set to be measured. Also, as with bloom filters, the CL sketch registers can be combined via a bitwise-OR operation, or if the sketch contains the necessary counters for the frequency problem, the sketches can be combined by summing register by register.
아래에 설명된 알고리즘 1(섹션 B 등에서 제공되는 개시 내용에 기초함)은 CL 스케치의 초기화를 설명한다. 여기에는 레지스터 어레이(들)의 할당과 동일한 키 애그리게이터 어레이(b)의 할당이 포함될 수 있다. 아이템이 처음에 레지스터(r)에 삽입되면, 동일한 키 애그리게이터가 해당 아이템의 지문을 저장할 수 있으며 s[r]은 1로 설정된다. 그 후, 다음에 아이템이 해당 레지스터에 할당되면, 그것의 지문을 기존 지문과 비교할 수 있다. 지문이 같으면 s[r]을 증가시킬 수 있다. 새 지문이 기존 지문보다 크면 기존 지문을 교체하고 s[r]을 1로 재설정할 수 있다. 그렇지 않으면, 새 지문이 더 작아지고 수정되지 않는다. 동일한 키 애그리게이터를 업데이트하는 프로세스는 아이템을 스케치에 삽입하는 방법을 설명하는 알고리즘 3의 일부로 설명된다.Algorithm 1 described below (based on the disclosure provided in Section B, etc.) describes the initialization of a CL sketch. This may include the allocation of the key aggregator array (b) equal to the allocation of the register array(s). When an item is initially inserted into a register ( r ), the same key aggregator can store that item's fingerprint and s[r] is set to 1. Then, the next time an item is assigned to that register, its fingerprint can be compared to an existing fingerprint. If the fingerprints are the same, s[r] can be incremented. If the new fingerprint is greater than the old fingerprint, we can replace the old fingerprint and reset s[r] to 1. Otherwise, the new fingerprint will be smaller and not modified. The process of updating the same key aggregator is described as part of Algorithm 3, which describes how to insert an item into a sketch.
알고리즘 1, 스케치 초기화:Algorithm 1, sketch initialization:
settings: none settings : none
input: number of legions l, and number of positions m input : number of legions l , and number of positions m
output: CascadingLegions sketch and same key aggregator (s, b) output : CascadingLegions sketch and same key aggregator ( s, b )
let s = integer array of size l * n let s = integer array of size l * n
let b = array of SameKeyAggregator structures let b = array of SameKeyAggregator structures
initialize s with zeros initialize s with zeros
*삽입 알고리즘을 진행하기 전에, 레지스터 할당 알고리즘이 도입된다. 아이템을 레지스터에 할당하려면, 먼저 해시될 수 있다. 다음으로, 해시 값에서 선행 0의 수(예: 최상위, 최하위 등)를 결정하여 군단이 할당될 수 있다. 다음으로, 0이 아닌 첫 번째 비트가 제거되고 나머지 비트 모듈러스 포지션의 수는 군단에서의 포지션을 결정한다. 아래에 설명된 알고리즘 2 참조. 군단을 결정하는 방법으로 해시 값의 활성 비트 합계를 사용하여 이항 분포를 사용하여 아이템을 군단에 할당할 수 있다.* Before proceeding with the insert algorithm, the register allocation algorithm is introduced. To assign an item to a register, it can be hashed first. Next, swarms can be assigned by determining the number of leading zeroes in the hash value (e.g., top, bottom, etc.). Next, the first non-zero bit is removed and the number of remaining bit modulus positions determines the position in the swarm. See Algorithm 2 described below. As a way to determine swarms, we can use the sum of the active bits of the hash value to assign items to swarms using a binomial distribution.
알고리즘 2, 레지스터 할당:Algorithm 2, register allocation:
settings: number of legions l, number of positions m. settings: number of legions l , number of positions m .
input: fingerprint (f) of item to allocate. input: fingerprint (f) of item to allocate.
output: CascadingLegions register (i, j) output: CascadingLegions register ( i, j )
let i = 0 let i = 0
while f % 2 == 0 and i < l - 1: while f % 2 == 0 and i < l - 1:
let i += 1 let i += 1
let f /= 2 let f /= 2
let f /= 2 let f /= 2
let j = f % m let j = f % m
return (j, i) return (j, i)
아이템을 레지스터(i, j)에 할당하여 삽입을 진행할 수 있다. 다음 단계는 위에서 설명된 바와 같이 동일한 키 애그리게이터를 확인하고, 그에 따라 레지스터 값을 조정하는 것이다. 알고리즘은 카운터의 사용을 가정할 수 있지만, 빈도가 바람직하지 않은(예를 들어, 카디널리티가 요구되는 등) 구현예에서 각 군단은 비트 어레이로 표현될 수 있다.Insertion can proceed by allocating the item to the registers (i, j). The next step is to check the same key aggregator as described above and adjust the register values accordingly. The algorithm may assume the use of counters, but in implementations where the frequency is undesirable (e.g., cardinality required, etc.) each corps may be represented as a bit array.
알고리즘 3, 아이템 삽입:Algorithm 3, insert item:
input: item input : item
output: modified sketch (s,b) output : modified sketch (s,b)
f = fingerprint(item)f = fingerprint(item)
let (i, j) = allocateRegister(f) let (i, j) = allocateRegister(f)
let r = i * m + j let r = i * m + j
if b[r] == null or b[r] == f:if b[r] == null or b[r] == f:
s[r] += 1 s[r] += 1
b[r] = f b[r] = f
elif b[r] < f:elif b[r] < f:
s[r] = 1 s[r] = 1
br[r] = f br[r] = f
아이템 세트의 카디널리티를 추정하기 위해, 특정 카디널리티에 의해 활성화되는 예상 레지스터 수를 도출할 수 있다. 각 군단은 균일 블룸 필터일 수 있으므로, tj 아이템이 군단 j에 속하면To estimate the cardinality of a set of items, an expected number of registers activated by a particular cardinality can be derived. Each swarm can be a uniform bloom filter, so if t j item belongs to swarm j
레지스터의 일부가 활성화될 수 있다. 그리고 군단 ℓ이 아이템의 2^-(j + 1) 부분에 맞을 것으로 예상되므로, 활성화된 총 레지스터 수는 다음과 같을 수 있다:Some of the registers may be active. And since corps ℓ is expected to fit in 2^-(j + 1) parts of items, the total number of activated registers could be:
F(t)는 단조롭기 때문에, 이진 검색을 사용하여 관찰된 활성화된 레지스터 수를 고려하여 카디널리티 t를 효율적으로 찾을 수 있다. 아래에 설명된 알고리즘 4 참조Since F(t) is monotonic, we can efficiently find the cardinality t by taking into account the observed number of active registers using a binary search. See Algorithm 4 described below
알고리즘 4, 계단식 군단 스케치에서 카디널리티 추정:Algorithm 4, cardinality estimation from cascading corps sketches:
settings: number of legions l, number of positions m settings : number of legions l , number of positions m
input: CascadingLegions sketch s input : CascadingLegions sketch s
output: estimated cardinality of the set stored in s output : estimated cardinality of the set stored in s
define function F(t): define function F(t):
return sum((1 - exp(-t * 2^(-t * 2 ^( -(j + 1)) / m )) * m for j in range(l) ) return sum((1 - exp(-t * 2^(-t * 2 ^( -(j + 1)) / m )) * m for j in range(l) )
define function InverseF(c): define function InverseF(c):
return results of binary search of t such that F(t) = c return results of binary search of t such that F(t) = c
let c = count of non-zeros in s let c = count of non-zeros in s
let t = InverseF(c) let t = InverseF(c)
return t return t
빈도 추정을 위해, 레지스터로부터 카운트 분포를 추출할 수 있고, 샘플로부터 빈도 분포를 외삽할 수 있다.For frequency estimation, the count distribution can be extracted from registers and the frequency distribution can be extrapolated from samples.
이러한 스케치는 랜덤 노이즈의 도입을 통해 차등적 비공개로 확장될 수 있다. 계단식 군단 스케치에 있는 비트를 무작위로 플립핑하여 랜덤 노이즈를 도입할 수 있다. 스케치는 확률 p로 스케치의 각 비트를 플립하여 파라미터ε를 사용하여 차등적 비공개로 할 수 있다.This sketch can be extended to differential privacy through the introduction of random noise. Random noise can be introduced by randomly flipping the bits in the cascading corps sketch. The sketch can be differentially private using the parameter ε by flipping each bit of the sketch with probability p .
예를 들어, ln(3)의 DP 엡실론에 대해 비트는 확률 0.25로 플립될 수 있다. 알고리즘 4에서, 필터 S의 목록이 주어졌을 때, 모든 비트가 p 확률로 플립되었으며 유니온의 0 레지스터 수는 집합에서 노이즈를 제거하여 추정될 수 있다. 이 전략은 전체 스케치에 적용될 수 있지만, 완전히 포화되거나 완전히 0인 군단이 많이 있을 것으로 예상되기 때문에 그러한 추정의 오류가 클 것이다. 대신 디노이징이 각 군단에 개별적으로 적용될 수 있으며, 포화 과정에 있는 군단(예: 값의 절반 미만이 채워진 첫 번째 군단 등)을 사용하여 추정될 수 있다. For example, for a DP epsilon of ln(3), a bit may be flipped with probability 0.25. In Algorithm 4, given a list of filters S, all bits have been flipped with probability p and the number of 0 registers in the union can be estimated by removing noise from the set. This strategy can be applied to the entire sketch, but the error in such an estimate will be large, since there are expected to be many fully saturated or completely zero swarms. Instead, denoising can be applied to each corps separately, and estimated using corps that are in the process of saturation (e.g. the first corps that are less than half full of values).
알고리즘 5, 노이징된 계단식 군단 스케치의 참조 군단을 사용하여 유니온의 카디널리티 추정.Algorithm 5, Cardinality Estimation of Unions Using Reference Corps of Noised Cascading Corps Sketch.
settings: number of legions l, number of positions m, flip probability p settings : number of legions l, number of positions m, flip probability p
input: a list of CascadingLegions sketches S which had bits flipped with probability p input : a list of CascadingLegions sketches S which had bits flipped with probability p
output: estimated cardinality of the union of sets stored in S output : estimated cardinality of the union of sets stored in S
let InverseF = InverseF function from Algorithm 3. let InverseF = InverseF function from Algorithm 3 .
*define function OneCountsVolumesVector(S, j):* define function OneCountsVolumesVector(S, j):
let v = [0] * len(S) let v = [0] * len(S)
for i in range(m): for i in range(m):
let c = number of sketches in S that have 1 in i-th position of j-th legion let c = number of sketches in S that have 1 in i-th position of j-th legion
let v[c] += 1 let v[c] += 1
return v return v
define function TransitionProbability(a, b): define function TransitionProbability(a, b):
# For brevity, this function is omitted from the description of high level algorithm. # For brevity, this function is omitted from the description of high level algorithm.
# An example Python implementation of this function is included in the Appendix. # An example Python implementation of this function is included in the Appendix.
return probability of a vector with a ones to have b ones after bits flipping with probability p return probability of a vector with a ones to have b ones after bits flipping with probability p
define function CorrectionMatrix(): define function CorrectionMatrix():
let N be a matrix of transition probabilities, i.e. N(a, b) = TransitionProbability(a, b). let N be a matrix of transition probabilities, ie N(a, b) = TransitionProbability(a, b).
return linear algebra inverse of N return linear algebra inverse of N
for g in range(l): for g in range(l):
let v = OneCountsVolumesVector(S) let v = OneCountsVolumesVector(S)
* let estimated_zero_count = first coordinate of CorrectionMatrix() * v* let estimated_zero_count = first coordinate of CorrectionMatrix() * v
if j < l - 1 and estimated_zero_count < 0.4 * m: if j < l - 1 and estimated_zero_count < 0.4 * m:
# The legion j is oversaturated, move on. # The legion j is oversaturated, move on.
continuecontinue
# Legion g is saturated just enough, it's the Reference Legion. # Legion g is saturated just enough, it's the Reference Legion.
return InverseF(m - estimated_zero_count) return InverseF(m - estimated_zero_count)
이러한 또 다른 기법인 액체 군단은 연속 분포를 사용하는 계단식 군단 기법의 확장이다. 군단이 ½ 단계로 감소하는 할당 확률을 갖는다는 결정은 임의적이다. 예상되는 군단 수에 대한 공식 F는 l개의 항으로 합계를 사용할 수 있다. 대신, 다양한 감쇠 계수가 있는 기하학적 분포를 사용하여 아이템을 레지스터에 할당할 수 있다. 제한된 기하학적 분포를 고려한다.Another such technique, liquid swarming, is an extension of the cascade swarming technique using continuous distribution. The determination that a corps has an allocation probability that decreases by ½ steps is arbitrary. Formula F for the expected number of corps can use the sum in l terms. Instead, a geometric distribution with different damping factors can be used to assign items to registers. Consider a limited geometric distribution.
이 샘플링을 효율적으로 수행하고 분석을 단순화하기 위해 지수 분포가 사용될 수 있다:An exponential distribution can be used to efficiently perform this sampling and simplify the analysis:
해상도 m과 함께 세그먼트 [0, 1]로 잘린다.It is cut into segments [0, 1] with resolution m .
아이템을 레지스터에 할당하려면, i 번째 세그먼트가 i 번째 레지스터에 대응한다고 가정하여 세그먼트 [0, 1]을 동일한 길이의 m개 세그먼트로 분할할 수 있다. 지수 분포에서 실수 값이 샘플링될 수 있으며, 실수가 떨어진 간격에 대응하는 레지스터에 아이템이 할당될 수 있다.To assign an item to a register, segment [0, 1] can be divided into m segments of equal length, assuming that the i -th segment corresponds to the i -th register. Real values may be sampled from an exponential distribution, and items may be assigned to registers corresponding to intervals at which real numbers fall.
실수 값 분포로부터 숫자를 샘플링하려면, 세그먼트 [0, 1]의 숫자를 균일하게 샘플링하고, 역 누적 분포 함수(CDF)가 적용될 수 있다. 위의 잘린 지수 분포의 역 CDF는 다음과 같을 수 있다:To sample numbers from a real-valued distribution, uniformly sampling numbers in segment [0, 1], the inverse cumulative distribution function (CDF) can be applied. The inverse CDF of the above truncated exponential distribution can be:
따라서 우리는 LiquidLegions 스케치의 군단을 샘플링하기 위해 알고리즘 1L에 도달한다.Thus we arrive at Algorithm 1L to sample Legions of LiquidLegions sketches.
알고리즘 1L: Liquid Legions 레지스터 할당:Algorithm 1L: Liquid Legions register allocation:
settings: decay parameter a, number of positions m. settings: decay parameter a , number of positions m .
input: item to allocate. input: item to allocate.
output: CascadingLegions register (i, j) output: CascadingLegions register (i, j)
let f = fingerprint64bit(item) let f = fingerprint64bit(item)
let u = f / 2 ^ 64 let u = f / 2 ^ 64
let x = 1 - log(exp(a) + u * (1 - exp(a))) / a let x = 1 - log(exp(a) + u * (1 - exp(a))) / a
return integer floor of x * (m + 1) return integer floor of x * (m + 1)
Liquid Legions의 스케치 생성 알고리즘은 적절한 레지스터 할당 함수가 있는 Cascading Legions와 동일할 수 있다. 카디널리티 추정을 위해, 함수는 활성화된 예상 레지스터 수 r에 카디널리티를 매핑할 수 있다.Liquid Legions' sketch generation algorithm can be the same as Cascading Legions with proper register allocation functions. For cardinality estimation, the function can map the cardinality to the expected number of active registers, r.
t = c / m을 r / m에 매핑하는 함수는 적분을 통해 임의 분포 P에 대해 획득될 수 있다.A function mapping t = c/m to r/m can be obtained for any distribution P through integration.
이 공식은 i 번째 레지스터가 적어도 하나의 아이템에 할당되고, m이 무한대가 될 때 한계에 도달할 확률을 작성하여 획득될 수 있다.This formula can be obtained by writing the probability of reaching the limit when the i-th register is assigned to at least one item and m becomes infinity.
아래에서, 카디널리티 추정 알고리즘이 설명된다. 카디널리티 함수의 대체를 제외하고는 Cascading Legions 대응과 동일할 수 있다.Below, the cardinality estimation algorithm is described. It can be identical to the Cascading Legions counterpart except for the replacement of the cardinality function.
알고리즘 3L 부록. LiquidLegions 스케치의 역 카디널리티 추정 함수:Algorithm 3L appendix. Inverse cardinality estimation function from the LiquidLegions sketch:
define function F(t): define function F(t):
return 1 - (-expi(- a * t / (exp(a) - 1)) return 1 - (-expi(- a * t / (exp(a) - 1))
+expi(-a * exp(a) * t / (exp(a) - 1))) / a +expi(-a * exp(a) * t / (exp(a) - 1))) / a
Liquid Legion 스케치의 차등적 비공개 버전은 Reference Legion이 연속적으로 미끄러질 수 있고, 추정치의 최소 분산을 위해 길이가 최적화될 수 있다는 점을 제외하면 Cascading Legion과 동일할 수 있다. 역 카디널리티 추정기를 미분하고 활성화된 레지스터 수의 증분 증가 확률을 곱한 미분 값이 최대인 지점을 찾아 최적의 참조 군단을 찾을 수 있다. 데이터 프로세싱 시스템은 섹션 C에서 위에 설명된 알고리즘과 함께 또는 대체로 알고리즘의 일부 또는 전부를 활용할 수 있다. 예를 들어, 스케치의 카디널리티를 결정하는 알고리즘을 이 섹션의 알고리즘으로 교체 또는 Liquid Legions 스케치를 채우는 알고리즘을 계단식 군단 구현예에 의해 사용되는 알고리즘 등으로 교체함으로써. 데이터 프로세싱 시스템(105A-N), 작업자 컴퓨팅 디바이스(405), 또는 애그리게이터 컴퓨팅 디바이스(410) 중 임의의 것이 이 섹션에서 설명된 기능 중 일부 또는 전부를 수행할 수 있다는 것을 이해해야 한다.The differentially private version of the Liquid Legion sketch may be identical to the Cascading Legion, except that the Reference Legion may be continuously slid and its length may be optimized for minimal variance in the estimate. Differentiating the inverse cardinality estimator and finding the point where the derivative multiplied by the incremental increase probability of the number of active registers is maximum, we can find the optimal reference corps. The data processing system may utilize some or all of the algorithms in conjunction with or in place of the algorithms described above in Section C. For example, by replacing the algorithm that determines the cardinality of the sketch with the algorithm in this section, or replacing the algorithm that fills the Liquid Legions sketch with the algorithm used by the cascading legion implementation, etc. It should be understood that any of the data processing systems 105A-N, worker computing devices 405, or aggregator computing devices 410 may perform some or all of the functions described in this section.
Liquid Legions 스케치 분석에 사용되는 기법은 레지스터를 통한 아이템의 임의 분포에 적용될 수 있다. 또한, 활동 공간에서 Dirac Mixture를 사용하여 임의 분포를 근사화할 수 있다. 따라서 지수화된 확률 함수는 적분될 필요가 없으며, Dirac Mixture에 의한 근사치가 사용될 수 있다.The techniques used for analyzing the Liquid Legions sketch can be applied to any distribution of items through registers. In addition, we can approximate arbitrary distributions using the Dirac Mixture in the activity space. Therefore, the exponentialized probability function does not need to be integrated, and an approximation by Dirac Mixture can be used.
암호화된 동일한 키 애그리게이터를 사용하여, 본 문서의 시스템은 동형 암호화를 활용하여 디바이스 식별자보다 더 많이 기여한 레지스터를 필터링하고, 디바이스 빈도의 깨끗한 샘플을 결정할 수 있다. 키 집합 구조는 암호화된 카운터와 키의 쌍이 될 수 있다(E(count), E(key)).Using the same encrypted key aggregator, the system of this document can utilize homomorphic encryption to filter registers that contribute more than device identifiers and determine a clean sample of device frequencies. The key set structure can be a pair of encrypted counter and key (E(count), E(key)).
구조에 대한 추가는 다음과 같이 정의될 수 있다:An addition to the structure can be defined as:
(E(count1), E(key1)) + (E(count2), E(key2)) = (E(count1), E(key1)) + (E(count2), E(key2)) =
(E(count1+count2+R*(key1-key2)), E(key1+R*(key1-key2)),(E(count1+count2+R*(key1-key2)), E(key1+R*(key1-key2)),
여기서 R은 난수다.where R is a random number.
이 더하기 연산은 동형으로 계산될 수 있다. 그러면 구조는 다음과 같이 작동할 수 있다:This addition operation can be computed isomorphically. Then the structure could work like this:
If key1 = key2 = key then If key1 = key2 = key then
(E(count1), E(key)) + (E(count2), E(key)) = (E(count1 + count2), E(key)). (E(count1), E(key)) + (E(count2), E(key)) = (E(count1 + count2), E(key)).
그렇지 않으면 카운터가 무작위로 파괴될 수 있다.Otherwise, counters may be randomly destroyed.
이러한 스케치를 생성하는 퍼블리셔 컴퓨팅 디바이스(예를 들어, 데이터 프로세싱 시스템 105A-N 등) 간의 차등 프라이버시를 유지하기 위해, 시스템은 안전한 다자간 계산 프로토콜을 구현하여 퍼블리셔 간에 스케치를 집합하고 멀티세트의 카디널리티 및 빈도를 추정할 수 있다. 위와 같이 파라미터화가 동일한 스케치는 포지션단위로 합산하여 결합될 수 있다. 경량 MPC 프로토콜은 ElGamal 암호화의 동형 속성을 프로토콜의 핵심 작업으로 사용하여 공동 스케치를 계산하는데 사용될 수 있다. 높은 수준의 접근법은 먼저 N-of-N 임계 키를 설정한 다음 각 스케치 제공자가 공개 키를 사용하여 입력을 암호화하도록 하는 것이다. 그 다음 각 비밀 키 보유자는 공동 스케치를 부분적으로 복호화하고 동형 속성을 사용하여 결정론적 암호를 적용한 다음 결과를 다음 보유자에게 전달할 수 있다. 모든 복호화 키 공유가 사용되면, 결과는 원하는 통계가 계산될 수 있는 결정 론적으로 암호화된 스케치가 된다. 프로토콜은 차등 비공개 출력이 계산될 수 있는 방법을 포함하여 아래에서 설명된다.In order to maintain differential privacy between the publisher computing devices (e.g., data processing systems 105A-N, etc.) that create these sketches, the system implements a secure multiparty computation protocol to aggregate sketches between publishers, with multisets of cardinality and frequency. can be estimated. As above, the sketches with the same parameterization can be summed and combined in a position unit. The lightweight MPC protocol can be used to compute joint sketches using the isomorphic property of ElGamal cryptography as the protocol's core operation. A high-level approach is to first establish an N-of-N threshold key, then have each sketch provider encrypt the input using the public key. Each holder of the secret key can then partially decrypt the joint sketch, apply a deterministic cipher using the isomorphic property, and pass the result to the next holder. When all decryption key sharing is used, the result is a deterministically encrypted sketch from which desired statistics can be computed. The protocol is described below, including how differential private outputs can be computed.
일부 구현예에서, 스케치 제공자의 수가 많을 수 있다. 일부 구현예에서, 소수의 독립적으로 운영되는 작업자가 프로토콜을 실행하고 대부분의 스케치 제공자는 암호화된 입력을 작업자 중 적어도 하나에 보낼 수 있다. 작업자 사이에서, 통신 그래프는 링 토폴로지를 따를 수 있다. 나머지 예의 경우, 이 개시는 작업자 1이 작업자 2와, 작업자 2가 작업자 3과, 작업자 3이 작업자 1과 통신하도록 3명의 작업자가 있다는 가정하에 동작한다. 그러나 프로토콜에 참여할 수 있는 작업자는 얼마든지 있을 수 있음을 이해해야 한다.In some implementations, the number of sketch providers may be large. In some implementations, a small number of independently operated workers execute the protocol and most sketch providers may send encrypted input to at least one of the workers. Between workers, the communication graph may follow a ring topology. For the rest of the example, this disclosure operates under the assumption that there are three workers, such that worker 1 communicates with worker 2, worker 2 communicates with worker 3, and worker 3 communicates with worker 1. However, it should be understood that any number of workers may participate in the protocol.
시작하기 위해, 각 작업자는 위에서 설명한 대로 또는 섹션 A에 설명된 대로 ElGamal 키 쌍(pki, ski)을 생성할 수 있다. 각 작업자는 자신의 키를 다른 작업자 각각에게 브로드캐스트할 수 있다. 각 작업자는 결합된 공개 키를 형성할 수 있으며, 스케치 공급자는 작업자 중 하나에서 키를 가져올 수 있다. 이 결합된 공개 키는 스케치 제공자가 스케치를 암호화하는데 사용할 수 있다.To start, each worker can generate an ElGamal key pair (pki, ski) as described above or as described in Section A. Each worker can broadcast its key to each of the other workers. Each worker can form a combined public key, and a sketch provider can get a key from one of the workers. This combined public key can be used by the sketch provider to encrypt the sketch.
각각의 스케치 제공자(예를 들어, 데이터 프로세싱 시스템(105A-N))는 다음을 수행할 수 있다(예를 들어, 섹션 AC와 관련하여 본 명세서에서 설명됨):Each sketch provider (eg, data processing systems 105A-N) may (eg, described herein with respect to section AC):
1. 작업자(예를 들어, 작업자 컴퓨팅 디바이스(405A-N) 등)로부터 결합된(예를 들어, 집합된) 공개 키를 검색.1. Retrieve the combined (eg, aggregated) public key from the worker (eg, worker computing device 405A-N, etc.).
2. 버킷 지문을 포함하는 스케치를 생성(예: 여기에 설명된대로 등).2. Create a sketch containing the bucket fingerprint (e.g. as described here).
3. 0이 아닌 각 포지션이 3개의 튜플(위치, 값, 지문)로 표시되는 희소 표현으로 스케치를 패키징.3. Packaging the sketch into a sparse representation where each non-zero position is represented by a 3-tuple (position, value, fingerprint).
4. 결합된 공개 키를 사용하여 각 3튜플에 ElGamal 암호화를 적용.4. Apply ElGamal encryption to each 3-tuple using the combined public key.
5. 암호화된 희소 스케치를 제1 작업자(예를 들어, 작업자 컴퓨팅 디바이스(405A) 등)에게 보냄.5. Sending the encrypted sparse sketch to the first worker (eg, worker computing device 405A, etc.).
스케치 제공자가 자신의 스케치를 임의의 작업자에게 보낸 다음 프로토콜로 시작되는 단일 작업자에게 보내기 전에 각 작업자가 수신한 스케치를 셔플링하도록 일반화할 수 있다. 이 예시적 설명에서, 모든 스케치 제공자가 한 명의 작업자에게 스케치를 보내는 것으로 가정한다. 그러나 스케치 제공자의 수에 관계없이 여러 작업자에게 스케치를 보낼 수 있다는 점을 이해해야 한다. 제1 작업자가 각 퍼블리셔의 암호화된 희소 스케치를 수신하면 프로토콜을 시작할 수 있다.It can be generalized that sketch providers send their sketches to arbitrary workers and then each worker shuffles the sketches it receives before sending them to a single worker starting with the protocol. In this example description, it is assumed that all sketch providers send sketches to a single operator. However, it is important to understand that you can send a sketch to multiple workers regardless of the number of sketch contributors. When the first worker receives each publisher's encrypted sparse sketch, it can start the protocol.
1. 모든 퍼블리셔의 모든 3-튜플(이후 "3-튜플"이라고 함)에 대해 제1 작업자(예: 작업자(405A))는 3-튜플을 셔플링(예: 순열)하고 다음 작업자에게 전송할 수 있다.1. For every 3-tuple (hereafter referred to as "3-tuple") from every publisher, the first worker (e.g. worker 405A) may shuffle (e.g. permutate) the 3-tuple and send it to the next worker. there is.
2. 다음 작업자는 다음 단계를 수행한다:2. The next operator performs the following steps:
a. ElGamal 키 공유(예: 비밀 키 등)를 사용하여, 각 포지션 ID(예: 각 3-튜플)를 부분적으로 복호화한다. a. Partially decrypt each position ID (eg each 3-tuple) using the ElGamal key share (eg secret key, etc.).
b. 이는 ElGamal 동형을 사용하여 결정론적 암호화 계층을 각 포지션 ID(예: 각 3-튜플)에 적용한다. b. It applies a deterministic encryption layer to each position ID (ie each 3-tuple) using ElGamal isomorphism.
c. 3-튜플을 셔플링한다. c. Shuffle the 3-tuple.
d. 3-튜플을 다음 작업자에게 전달한다. d. Pass the 3-tuple to the next worker.
3. 이 프로세스는 제1 작업자가 3-튜플(예: 링 구성 등)을 다시 수신할 때까지 계속될 수 있다.3. This process may continue until the first worker receives the 3-tuple (eg ring configuration, etc.) again.
4. 그 다음, 제1 작업자는 키 공유를 사용하여 3-튜플을 복호화하고, 이제 결정론적으로 암호화된 포지션 ID에서 튜플을 결합할 수 있고, 그러면 각 포지션에 대해 다음 구조가 생성된다 (Enon_det(position), [(E(value1), E(지문 1)),(E(값 2), E(지문 2)),…]).4. The first worker can then decrypt the 3-tuple using key sharing and combine the tuples at the now deterministically encrypted position ID, which will then generate the following structure for each position (Enon_det( position), [(E(value1), E(fingerprint1)),(E(value2), E(fingerprint2)),…]).
5. 그 다음 제1 작업자는 위에서 설명한 동일한 키 애그리게이터 방법을 사용하여 암호화된 (값, 지문) 튜플을 결합한다. 이렇게 하면 결합된 스케치에서 0이 아닌 포지션 ID 각각에 대해 (Enon_det(position_id), E(value), E(fingerprint))의 3-튜플이 생성될 수 있다.5. The first worker then combines the encrypted (value, fingerprint) tuples using the same key aggregator method described above. This would result in a 3-tuple of (Enon_det(position_id), E(value), E(fingerprint)) for each non-zero position ID in the combined sketch.
6. 제1 작업자가 제2 통신을 개시한다.6. The first operator initiates the second communication.
a. 결합된 3-튜플에서 암호화된 키(예: E(key))를 삭제하는 것으로 시작하여, 0이 아닌 각 포지션 ID에 대해 (Enon_det(position_id),(E(count))의 결합된 2-튜플이 생성된다. a. Start by deleting the encrypted key (e.g. E(key)) from the combined 3-tuple, then for each non-zero position ID, the combined 2-tuple of (Enon_det(position_id),(E(count)) is created
b. 그 다음 결합된 2-튜플(이하 "2-튜플"이라고 함)을 다음 작업자에게 전달한다. b. It then passes the combined 2-tuple (hereafter referred to as "2-tuple") to the next worker.
7. 다음 작업자는 다음 단계를 수행한다:7. The next operator performs the following steps:
a. 각 카운트로부터 비결정론적 암호화를 제거한다. a. Remove non-deterministic encryption from each count.
b. 각 카운트에 결정론적 암호화를 적용한다. b. Apply deterministic encryption to each count.
c. 튜플이 이미 제1 라운드에서 셔플되었으므로 셔플링이 필요하지 않다. c. Since the tuples have already been shuffled in the first round, no shuffling is required.
8. 이 프로세스는 제1 작업자가 비결정론적으로 암호화된 2-튜플 세트를 수신할 때까지 계속된다. 8. This process continues until the first worker receives a non-deterministically encrypted set of 2-tuples.
9. 여기에서 카디널리티 추정치를 얻을 수 있다.9. You can get the cardinality estimate here.
10. 다음으로, 작업자는 협력하여 빈도 분포를 결정할 수 있다:10. Next, the operators can cooperatively determine the frequency distribution:
a. 먼저 작업자는 이전 라운드에서와 동일한 키를 사용하여 정수 값 [1, max_frequency)을 사용하여 결정론적으로 암호화할 수 있으며, 이는 알려진 값 [1, max_frequency)에 대한 일반 텍스트에 대한 암호문 룩업 테이블을 생성할 수 있다. a. First, the worker can deterministically encrypt using the integer value [1, max_frequency) using the same key as in the previous round, which will generate a ciphertext lookup table for the plaintext for known values [1, max_frequency). can
b. 그 다음, 룩업 테이블을 사용하여 결정론적으로 암호화된 스케치에서 빈도 히스토그램을 구성할 수 있다. 이 히스토그램은 스케치의 빈도 분포를 결정하는데 사용할 수 있다. b. The lookup table can then be used to construct a frequency histogram from the deterministically encrypted sketch. This histogram can be used to determine the frequency distribution of sketches.
c. 룩업 테이블의 값에 매핑되지 않는 스케치에 있는 모든 값은 max_frequency와 동일한 것으로 간주된다. c. Any value in the sketch that does not map to a value in the lookup table is considered equal to max_frequency.
이것은 도 4a-c 및 도 5-7과 관련하여 위에서 설명된 MPC 프로토콜의 확장이다. 즉, 여기에 설명된 임의의 컴퓨팅 디바이스, 예를 들어 데이터 프로세싱 시스템(105A-N), 작업자 컴퓨팅 디바이스(405A-N), 애그리게이터 컴퓨팅 디바이스는 이 섹션에서 설명된 기능 중 하나 이상을 수행할 수 있다. 또한 섹션 A-C의 방법, 시스템 또는 기술 중 일부 또는 전부가 이 섹션의 기능에 적용될 수 있음을 이해해야 한다.This is an extension of the MPC protocol described above with respect to FIGS. 4a-c and FIGS. 5-7. That is, any of the computing devices described herein, such as data processing systems 105A-N, worker computing devices 405A-N, and aggregator computing devices, can perform one or more of the functions described in this section. there is. It should also be understood that any or all of the methods, systems or techniques in Sections A-C may be applicable to the functions in this Section.
동일한 키 애그리게이터는 간단한 동등성 테스트를 사용하여 주어진 포지션의 키가 동일한지 여부를 결정할 수 있다. 각 히스토그램 빈에 대해 양측 기하학적 랜덤 변수를 생성하고 해당 빈에 추가하여 차등 프라이버시를 빈도 히스토그램에 직접 추가할 수 있다. 쿼리 민감도는 1이며, 이는 임의의 식별자는 빈도 히스토그램에 최대 한 번만 표시될 수 있기 때문에 반드시 그래야 한다. An equal-key aggregator can use a simple equivalence test to determine whether the keys of a given position are equal. Differential privacy can be added directly to the frequency histogram by creating a two-sided geometric random variable for each histogram bin and adding it to that bin. The query sensitivity is 1, which must be the case because any identifier can appear at most once in the frequency histogram.
노이즈를 추가하기 위해, 작업자는 각 버킷에 추가될 임의의 기준선 B에 동의하는 것으로 시작할 수 있다. 위 프로토콜의 1 단계와 2 단계는 각 작업자가 max_frequency 랜덤 변수(X1, Xi, Xmax_freq)를 그리도록 확장될 수 있다. 이들은 특정 작업자에 대한 값 [1, max_frequency] 계산에 추가할 노이즈 값의 수를 나타낼 수 있다. 이를 달성하기 위해, 각 작업자는 값 i를 갖는 B-X i 튜플을 스케치에 추가할 수 있다. 그 다음, 9 단계에서 제1 작업자는 각 히스토그램 버킷에서 B * W 값을 뺄 수 있고, 여기서 W는 작업자 수다. 그 다음, 이는 필요한 노이즈 분포를 제공한다. 또한, 노이즈 기준선을 뺀 후에 카디널리티가 추정될 수 있다. 각 작업자가 계산에 노이즈를 추가하는 방법에 대한 자세한 내용은 아래에 설명된 알고리즘 5를 참조. 유사한 기법이 도 7과 함께 섹션 A에서 위에서 설명된다. 예를 들어, 다음 알고리즘은 작업자 컴퓨팅 디바이스(405A-N)에 의해 빈도를 계산하는 동안 분산된 노이즈 값을 생성하고 추가하는데 사용될 수 있다.To add noise, the operator can start by agreeing on an arbitrary baseline B to be added to each bucket. Steps 1 and 2 of the above protocol can be extended so that each worker draws a max_frequency random variable (X 1 , X i , X max_freq ). These can represent the number of noise values to add to the value [1, max_frequency] calculation for a particular worker. To achieve this, each worker can add a BX i tuple with value i to the sketch. Then, in step 9, the first operator can subtract B * W values from each histogram bucket, where W is the number of operators. Then, it provides the required noise distribution. Also, cardinality can be estimated after subtracting the noise baseline. See Algorithm 5 described below for details on how each operator adds noise to the calculation. A similar technique is described above in Section A in conjunction with FIG. 7 . For example, the following algorithm may be used to generate and add distributed noise values during frequency calculation by worker computing devices 405A-N.
알고리즘 5, 작업자 생성 분산 노이즈:Algorithm 5, worker-generated variance noise:
noise_tuples = []noise_tuples = []
for v in [0, max_frequency]:for v in [0, max_frequency]:
x = drawPolyaRv() x = drawPolyaRv()
for i in range(B-x): for i in range(B-x):
noise_tuples.append((random(), v, random())) noise_tuples. append((random(), v, random()))
개별 스케치 기여자의 카디널리티 유출을 방지하기 위해, 각 스케치 제공자는 sentinel_value가 잘 알려진 레지스터 값인 값 (sentinel_position, 0, 0)으로 여러 개의 3-튜플을 암호화할 수 있다. 그 다음, 4 단계가 끝날 때 작업자에 의해 감시 포지션을 결정론적으로 암호화할 수 있으며, 해당 포지션의 모든 튜플을 폐기할 수 있다.To prevent cardinality leaks from individual sketch contributors, each sketch contributor MAY encrypt multiple 3-tuples with values (sentinel_position, 0, 0) where sentinel_value is a well-known register value. Then, at the end of step 4, the watch position can be deterministically encrypted by the worker, and all tuples in that position can be discarded.
일부 구현예에서, 모든 버킷이 스케치 제공자에 의해 암호화될 수 있는 고밀도 버전의 프로토콜을 사용할 수 있다. 그러나 희소 방법은 스케치가 ⅓차있는 일반적인 경우에 더 자원 효율적일 수 있다. In some implementations, all buckets may use a dense version of the protocol that can be encrypted by the sketch provider. However, the sparse method may be more resource efficient in the general case of ⅓ full sketches.
*위에서 설명한 것과 동일한 주요 애그리게이터 기법은 분산 데이터를 수집하기 위해 더 일반화될 수 있다. 예를 들어, 식별자의 분포는 하나 이상의 속성(예를 들어, 디바이스 정보, 디바이스 메타 데이터, 디바이스에 대한 정보 등)에 기초하여 선택될 수 있다. 속성 별로 스케치를 생성하는 대신, 속성을 동일한 키 애그리게이터에 저장할 수 있으므로, 계산 리소스를 절약할 수 있으며 카디널리티 및 빈도 결정 컴퓨터 시스템을 개선할 수 있다. 트레이드오프는 속성 버킷에 대한 대략적 카운트가 아닌 대략적인 분포가 알려진다는 것이다. 따라서, 특정 속성이 멀티세트의 작은 부분이면, 카테고리 또는 속성에 대한 도달 범위의 상대적 오류를 보장할 수 없다. 배포 데모를 저장하기 위해 애그리게이터를 다음과 같이 조정할 수 있다. 카테고리(예: 속성)가 객체에 일관되게 할당될 수 있다고 가정할 수 있다.*The same primary aggregator techniques described above can be further generalized to collect distributed data. For example, the distribution of identifiers may be selected based on one or more properties (eg, device information, device metadata, information about the device, etc.). Instead of creating sketches per attribute, attributes can be stored in the same key aggregator, saving computational resources and improving cardinality and frequency determination computer systems. The tradeoff is that the approximate distribution is known, not the approximate count for the attribute bucket. Thus, if a particular attribute is a small part of the multiset, the relative error of coverage for a category or attribute cannot be guaranteed. To store deployment demos, we can tweak our aggregator as follows: We can assume that categories (e.g. attributes) can be consistently assigned to objects.
(E(category1), E(key1)) + (E(category2), E(key2)) =(E(category1), E(key1)) + (E(category2), E(key2)) =
(E(category1 + R * (key1 - key2)), E(key1 + R * (key1 - key2)). (E(category1 + R * (key1 - key2)), E(key1 + R * (key1 - key2)).
시스템은 작업을 엘리먼트 단위로 적용하는 동일한 키 애그리게이터에 임의의 수의 스케치 및 카테고리 클래스를 저장할 수 있다. 예를 들면:The system can store any number of sketches and category classes in the same key aggregator that applies operations element by element. For example:
(E(count1_a), E(count1_b), E(category1_c), E(E(key1)) +(E(count1_a), E(count1_b), E(category1_c), E(E(key1)) +
(E(count2_a), E(count2_b), E(category2_c), E(E(key2)) =(E(count2_a), E(count2_b), E(category2_c), E(E(key2)) =
(E(count1_a + count2_a + R * (key1 - key2)), (E(count1_a + count2_a + R * (key1 - key2)),
E(count1_b + count2_b + R * (key1 - key2)), E(count1_b + count2_b + R * (key1 - key2)),
E(category1_c + R * (key1 - key2)), E(category1_c + R * (key1 - key2)),
E(key1 + R * (key1 - key2)). E(key1 + R * (key1 - key2)).
설명을 위해 이 알고리즘을 Same Key Aggregator라고 할 수 있으며, 임의 카운트와 카테고리 분포를 집합한다고 가정할 수 있다. 구조 병합 동작은 '+' 기호를 통해 표시되며, 이는 위에서 설명한 대로 카운트 추가 및 카테고리 병합을 의미한다. 알고리즘의 일반 텍스트 버전 For purposes of explanation, this algorithm can be referred to as the Same Key Aggregator, and it can be assumed that it aggregates an arbitrary count and category distribution. The structure merging operation is indicated by a '+' sign, which means adding counts and merging categories as described above. Plain text version of the algorithm
일부 구현예에서, Same Key Aggregator 애그리게이터는 암호화된 키 대신 사용할 수 있는 부동 소수점 값 해시를 포함할 수 있다. 단일 카운터의 경우 다음과 같다:In some implementations, the Same Key Aggregator aggregator can include a hash of a floating point value that can be used in place of an encrypted key. For a single counter:
(hash_1, count_1) + (hash_2, count_2) =(hash_1, count_1) + (hash_2, count_2) =
((hash_1, count_1 + count_2) ((hash_1, count_1 + count_2)
if (hash_1 == hash_2) else min((hash_1, count_1), (hash_2, count_2))) if (hash_1 == hash_2) else min((hash_1, count_1), (hash_2, count_2)))
여기에 설명된 시스템 및 방법은 섹션 A-C에서 제공된 구현예를 수정 또는 확장 할뿐만 아니라 이전 섹션에서 설명되지 않은 다른 구현예를 구현하기 위해 이 섹션에서 설명된 기법을 구현할 수 있음을 이해해야 한다.It should be understood that the systems and methods described herein may implement techniques described in this section to implement other implementations not described in previous sections, as well as to modify or extend the implementations provided in Sections A-C.
E. 빈도 및 카디널리티 추정을 위한 지수 일반화 블룸 필터E. Exponential Generalized Bloom Filters for Frequency and Cardinality Estimation
이 기법 솔루션의 이 섹션에서는 본 명세서에 기술된 전체 빈도 및 카디널리티를 계산하는데 사용되는 지수 및 일반화된 블룸 필터 데이터 구조를 설명한다. 이 기술 솔루션의 다른 섹션(예를 들어, 섹션 A-D)에서 설명된 바와 같이, 각 퍼블리셔 컴퓨팅 디바이스(예를 들어, 데이터 프로세싱 시스템(105A-N))는 하나 이상의 디바이스 식별자 또는 속성을 나타낼 수 있는 자신의 프라이버시 안전 스케치를 생성할 수 있다. 디바이스 식별자 또는 속성은 디바이스 식별자에 의해 수행되는 하나 이상의 액션, 예를 들어 특정 콘텐츠 아이템 또는 웹 주소에 액세스하는 것과 연관될 수 있다. 퍼블리셔 컴퓨팅 디바이스 각각은 수신된 스케치에 걸쳐 중복 제거된 고유 디바이스 식별자의 수를 추정하는 중복 제거 서비스(예를 들어, 임의의 작업자 컴퓨팅 디바이스(405), 애그리게이터 컴퓨팅 디바이스(410) 등)로 스케치를 전송할 수 있다. 스케치는 차등적 프라이버시 안전일 수 있다. 결과적으로, 스케치를 신뢰할 수 없는 엔터티로 전송할 때에도 스케치의 차등 프라이버시를 유지할 수 있어 네트워킹 시스템의 보안이 향상된다.This section of this technique solution describes the exponential and generalized bloom filter data structures used to compute the overall frequency and cardinality described herein. As described in other sections of this technical solution (eg, Sections A-D), each publisher computing device (eg, data processing systems 105A-N) is itself capable of representing one or more device identifiers or attributes. of privacy-safe sketches. A device identifier or property may be associated with one or more actions performed by the device identifier, such as accessing a particular content item or web address. Each of the publisher computing devices sends the sketch to a deduplication service (eg, any worker computing device 405, aggregator computing device 410, etc.) that estimates the number of unique device identifiers that have been deduplicated across the received sketches. can transmit A sketch can be a differential privacy safe. As a result, it is possible to maintain differential privacy of sketches even when sending sketches to untrusted entities, improving the security of the networking system.
이 기술 솔루션에 설명된 기법은 지수 일반화 블룸 필터(exp-GBF)를 스케치로 사용할 수 있다. 본 명세서에 기술된 기법은 애그리게이터 컴퓨팅 디바이스가 exp-GBF 스케치에 의해 표현된 멀티세트의 카디널리티를 추정하는데 사용할 수 있는 차등 프라이버시 안전 스케치로서 exp-GBF의 생성을 허용할 수 있다. 본 명세서에 기술된 기법은 여러 퍼블리셔에 걸쳐 exp-GBF를 결합하거나 결합하는 시스템 및 방법을 제공한다.The technique described in this technical solution can use an exponential generalized bloom filter (exp-GBF) as a sketch. The techniques described herein may allow the creation of exp-GBF as a differential privacy safe sketch that an aggregator computing device can use to estimate the cardinality of the multiset represented by the exp-GBF sketch. The techniques described herein provide systems and methods for combining or combining exp-GBF across multiple publishers.
본 명세서에 기술된 기법은 기하학적 일반화 블룸 필터(exp-GBF)를 사용할 수 있다. GBF는 클래식 블룸 필터를 일반화하여, 비트 벡터의 비트가 해시된 식별자 공간의 다른 부분을 커버할 수 있도록 한다. 특히, i 번째 비트는 해시된 식별자 공간의 pi를 커버한다. pi는 분수일 수 있다. 퍼블리셔 컴퓨팅 디바이스(예: 데이터 프로세싱 시스템(105A-N))는 exp-GBF가 pi에 대한 지수 함수를 사용할 수 있으며, pi = kappa * exp(-kappa * i / m), m은 비트 벡터의 길이다. kappa는 exp-GBF 스케치의 형상을 결정할 수 있는 파라미터다.The technique described herein may use a geometric generalized bloom filter (exp-GBF). GBF generalizes the classic bloom filter, allowing the bits of a bit vector to cover different parts of the hashed identifier space. In particular, the i -th bit covers p i of the hashed identifier space. p i may be a fraction. A publisher computing device (e.g. data processing system 105A-N) may use an exponential function for pi where exp-GBF is pi = kappa * exp(-kappa * i / m) where m is a bit vector is the length of kappa is a parameter that can determine the shape of the exp-GBF sketch.
본 명세서에 기술된 컴퓨팅 디바이스(예를 들어, 애그리게이터 컴퓨팅 디바이스(410) 또는 작업자 컴퓨팅 디바이스(405), 데이터 프로세싱 시스템(105A-N), 임의의 다른 컴퓨팅 디바이스 등)는 다음 공식을 사용하여 주어진 exp-GBF의 중복 제거된 카디널리티를 계산할 수 있다:The computing devices described herein (eg, aggregator computing devices 410 or worker computing devices 405, data processing systems 105A-N, any other computing devices, etc.) are given using the formula: We can compute the deduplicated cardinality of exp-GBF:
여기서 C는 exp-GBF에 기여한 식별자 세트의 카디널리티, x는 exp-GBF 스케치에 설정된 비트 수, m은 스케치의 총 비트 포지션 수다.where C is the cardinality of the set of identifiers contributing to exp-GBF, x is the number of bits set in the exp-GBF sketch, and m is the total number of bit positions in the sketch.
차등 프라이버시를 유지하기 위해, 퍼블리셔 컴퓨팅 디바이스(예를 들어, 데이터 프로세싱 시스템(105A-N))는 확률 p로 exp-GBF 스케치에서 각 비트를 플립핑할 수 있다. 예를 들어, 퍼블리셔 컴퓨팅 디바이스는 확률 p로 '1'비트를 '0'으로 플립하고 확률 q로 '0'비트를 '1'비트로 플립할 수 있다. 이 차등 비공개 exp-GBF 스케치를 dp-exp-GBF라고할 수 있다. exp GBF 스케치에서 각 비트를 플립핑하여 차등적 비공개로 한 후, 퍼블리셔 컴퓨팅 디바이스는 dp-exp-GBF 스케치를 애그리게이터 컴퓨팅 디바이스에 전송하여, 다른 퍼블리셔 컴퓨팅 디바이스에서 중복 제거된 카디널리티를 계산할 수 있다. To maintain differential privacy, a publisher computing device (eg, data processing system 105A-N) may flip each bit in the exp-GBF sketch with probability p. For example, the publisher computing device may flip '1' bits to '0' with probability p and flip '0' bits to '1' bits with probability q. This differential private exp-GBF sketch can be referred to as dp-exp-GBF. After differential privacy by flipping each bit in the exp GBF sketch, the publisher computing device sends the dp-exp-GBF sketch to the aggregator computing device, where other publisher computing devices can compute the deduplicated cardinality.
주어진 dp-exp-GBF 스케치에 대한 고유 카운트를 계산하기 위해, 애그리게이터 컴퓨팅 디바이스는 다음 공식을 사용하여 dp-exp-GBF 스케치의 수정된 1 비트 값을 계산할 수 있다.To calculate the unique count for a given dp-exp-GBF sketch, the aggregator computing device may calculate the modified 1-bit value of the dp-exp-GBF sketch using the following formula:
여기서 CB는 카디널리티 추정에 사용되는 수정된 1 비트 수이고, q는 0 비트가 1 비트로 플립될 확률, p는 1 비트가 0 비트로 플립될 확률, x는 '1'로 설정된 스케치의 비트 수이고, z는 '0'으로 설정된 스케치의 비트 수다. 그 다음, 애그리게이터 컴퓨팅 디바이스는 다음 공식을 사용하여 수정된 1 비트 수로 dp-exp-GBF의 중복 제거된 도달 범위를 계산할 수 있다:where CB is the number of modified 1-bits used for cardinality estimation, q is the probability that 0 bits will flip to 1 bits, p is the probability that 1 bits will flip to 0 bits, x is the number of bits in the sketch set to '1', z is the number of bits in the sketch set to '0'. The aggregator computing device may then calculate the deduplicated reach of dp-exp-GBF as a modified number of 1 bits using the following formula:
여기서 DC는 dp-exp-GBF의 카디널리티, CB는 위의 공식을 사용하여 계산된 수정된 1 비트 수, m은 dp-exp-GBF의 비트 위치 수다.where DC is the cardinality of dp-exp-GBF, CB is the number of modified 1-bits calculated using the formula above, and m is the number of bit positions in dp-exp-GBF.
이 섹션에서 설명하는 스케치는 일반적으로 'ADBF(Any Distribution Bloom Filter)'라고도 한다. 이 섹션에서 설명하는 스케치는 균일 또는 지수 이외의 다른 분포 함수를 수용할 수 있는 비트 분포 허용을 포함할 수 있다. 예를 들어, 여기에 설명된 기법은 선형 감쇠 블룸 필터(BF), 쌍곡선 BF, 또는 균일한 지수 BF의 혼합물을 구현할 수 있다. 노이즈 보정은 하나 이상의 애그리게이터 또는 작업자 컴퓨팅 디바이스(예를 들어, 애그리게이터 컴퓨팅 디바이스(410), 작업자 컴퓨팅 디바이스(405A-N) 등)에 의해 효율적으로 적용될 수 있다. The sketch described in this section is also commonly referred to as an 'Any Distribution Bloom Filter' (ADBF). The sketches described in this section may include bit distribution allowances that can accommodate distribution functions other than uniform or exponential. For example, the techniques described herein may implement mixtures of linear attenuated bloom filters (BFs), hyperbolic BFs, or uniform exponential BFs. Noise correction may be efficiently applied by one or more aggregators or worker computing devices (eg, aggregator computing device 410 , worker computing devices 405A-N, etc.).
또한, 애그리게이터 컴퓨팅 디바이스(예: 작업자 컴퓨팅 디바이스(405), 애그리게이터 컴퓨팅 디바이스(410) 등)에 의해 구현된 추정 기법은 참조 군단의 비트만 사용되는 참조 군단 기반 구현예에서와 달리, 스케치의 모든 비트가 카디널리티 추정에 기여할 수 있도록 구현될 수 있다. 참조 군단을 선택하는 대신, 애그리게이터 컴퓨팅 디바이스는 스케치에서 각 비트의 가중치를 조정할 수 있고, 가중치 값은 스케치에서 최종 카디널리티 추정에 대한 비트의 기여도를 나타낸다. 스케치의 파라미터에 기초하여, 애그리게이터 컴퓨팅 디바이스는 스케치의 각 비트에 대한 최적의 가중치를 도출하여, 카디널리티 추정의 전체 정확도를 향상시킬 수 있다.In addition, estimation techniques implemented by aggregator computing devices (eg, worker computing device 405, aggregator computing device 410, etc.), unlike in reference corps-based implementations where only the bits of the reference corps are used, It can be implemented so that all bits can contribute to cardinality estimation. Instead of selecting a reference swarm, the aggregator computing device may adjust the weight of each bit in the sketch, and the weight value represents the bit's contribution to the final cardinality estimate in the sketch. Based on the parameters of the sketch, the aggregator computing device can derive an optimal weight for each bit of the sketch, improving the overall accuracy of cardinality estimation.
ADBF 구현예를 설명하기 위해 이 기술 솔루션은 몇 가지 대체 접근법을 설명하는 것으로 시작한다. 첫째, 확률적 카운팅 및 확률적 평균(PSCA)을 구현하는 스케치가 설명된다.To describe an ADBF implementation, this technical solution begins by describing some alternative approaches. First, a sketch implementing probabilistic counting and probabilistic averaging (PSCA) is described.
PSCA 기반 기법은 비트 맵 데이터 구조를 활용할 수 있다. 다음은 PCSA 3x2 비트 맵을 도시한다. 각 셀 값은 1 또는 0과 같은 비트일 수 있다. 여기서 일반 지정자 '행'과 '열'은 특정 셀의 위치를 설명하는데 사용된다. 행은 레지스터라고도 한다. PSCA 스케치에서 식별자는 비트 시퀀스에 기초하여 셀에 할당될 수 있다. 예를 들어, 각 행은 총 유니버스 식별자의 1 / nrows(이 예에서는 ⅓) 부분을 캡처할 수 있다. 열에는 전체 유니버스 식별자 중 기하 급수적으로 감소한 부분이 있을 수 있다. 예를 들어, 열 1은 ½을 가질 수 있고, 열 2는 ¼을 가질 수 있다. 따라서, 셀은 유니버스의 1 / nrows *(½) ^ column_id 부분을 캡처한다. 3x2 PSCA 스케치의 예시 표현이 아래에 포함된다.PSCA-based techniques may utilize bitmap data structures. The following shows the PCSA 3x2 bitmap. Each cell value can be a bit like 1 or 0. Here, the general specifiers 'row' and 'column' are used to describe the location of a particular cell. A row is also called a register. In the PSCA sketch, identifiers can be assigned to cells based on bit sequences. For example, each row can capture 1 / nrows (⅓ in this example) part of the total universe identifier. A column can contain an exponentially decreasing fraction of the total universe identifier. For example, column 1 could have ½ and column 2 could have ¼. Thus, the cell captures 1 / nrows *(½) ^ column_id part of the universe. An example representation of a 3x2 PSCA sketch is included below.
3x2 PSCA 스케치 표현3x2 PSCA sketch representation
PCSA 비트 맵은 아래 그림과 같이 비트 벡터로 플랫화될 수 있다. 벡터는 열 순서로 셀을 정렬한다. 제1 열로부터 3개 셀의 제1 세그먼트이다. 그들은 각각 1/6의 유니버스 ID를 캡처한다. 제2 열로부터 3개 셀의 제2 세그먼트이다. 그들은 각각 유니버스의 1/12를 캡처한다. 비트 맵과 비트 벡터는 동일하며, 서로 1-1 매핑될 수 있음이 분명하다.A PCSA bitmap can be flattened into bit vectors as shown below. Vectors sort cells in column order. It is the first segment of three cells from the first column. They each capture 1/6 of the universe ID. The second segment of three cells from the second row. They each capture 1/12 of the universe. It is clear that bitmaps and bitvectors are equivalent and can be mapped 1-1 to each other.
3x2 PSCA 스케치의 플랫화된 표현Flattened representation of a 3x2 PSCA sketch
ADBF 스케치는 이러한 스케치의 일반화된 형태일 수 있다. ADBF 스케치는 아래 그림과 같이 유니버스의 모든 확률을 취할 수 있다.ADBF sketches can be generalized forms of these sketches. ADBF sketch can take all probabilities of the universe as shown below.
ADBF 스케치의 플랫화된 표현A flattened representation of an ADBF sketch
스케치의 각 포지션에 대한 확률 분포는 임의의 값으로 일반화될 수 있기 때문에 여기에 설명된 다른 구조가 그 결과로 나타날 수 있다. 예를 들어, 모든 확률 값이 1/m로 동일하게 가중치를 부여하면 클래식 블룸 필터 구현예가 되며, 여기서 m은 스케치의 포지션 수다. 마찬가지로 '폭포'와 같은 확률이 각 세그먼트에 할당되면, PSCA와 같은 스케치가 나타난다. 또한 지수 p 값이 사용되면 다음과 같다:Because the probability distribution for each position in the sketch can be generalized to any value, other structures described here may result. For example, if all probability values are equally weighted as 1/m, then a classic Bloom filter implementation is obtained, where m is the number of positions in the sketch. Likewise, when a 'waterfall'-like probability is assigned to each segment, a PSCA-like sketch emerges. Also, if an exponential p-value is used, then:
여기서 i는 스케치에서 포지션의 인덱스, c는 정규화 계수, m은 스케치의 포지션 수이며, 액체 군단 유형 스케치가 나타난다. where i is the index of the position in the sketch, c is the normalization coefficient, m is the number of positions in the sketch, and a liquid swarm type sketch appears.
아래에 설명된 지수 블룸 필터 케이스는 우아한 통계 모델 및 해석을 통해 폐쇄형 최대 가능성 솔루션을 제공한다. 다음으로, 식별자로부터 ADBF 구성, 노이즈 추가, 하나의 ADBF의 고유 카운트 계산 및 여러 결합된 ADBF의 고유 카운트 계산을 포함하여 ADBF 및 일부 이론적 공식에 대해 설명한다. 블룸 필터, PCSA/CL 및 ADBF를 비교하기 위한 시뮬레이션 결과가 제공된다.The exponential bloom filter case described below provides a closed maximum likelihood solution through an elegant statistical model and interpretation. Next, ADBF and some theoretical formulas are described, including ADBF construction from an identifier, noise addition, eigencount calculation of one ADBF, and eigencount calculation of several combined ADBFs. Simulation results are provided to compare the Bloom filter, PCSA/CL and ADBF.
일반화된 블룸 필터(ADBF)는 다음과 같이 퍼블리셔 컴퓨팅 디바이스(예를 들어, 데이터 프로세싱 시스템(105A-N))에 의해 구성될 수 있다. kappa 파라미터는 값 1로 설정될 수 있지만, 1보다 작을 수 있는 조정 가능한 파라미터다. 데이터 프로세싱 시스템은 ADBF 데이터 구조를 구성하는데 활용하기 위해 하나 이상의 데이터 레코드(예: 식별자 및 속성 또는 특정 기준을 충족하는 식별자 등)에 액세스할 수 있다. 예를 들어, 데이터 프로세싱 시스템은 구성된 ADBF 스케치에 삽입하는데 사용할 하나 이상의 데이터 레코드에 액세스하기 위해 데이터베이스(예를 들어, 데이터베이스(115) 등)에 액세스할 수 있다. ADBF 스케치는 데이터 프로세싱 시스템의 메모리에 유지될 수 있으며, 다른 스케치 구현예에 대한 진행 섹션에서 본 명세서에 기술된 초기화 값으로 초기화될 수 있다. 예를 들어, ADBF 스케치를 구성하는 절차는 계단식 군단 스케치 또는 액체 군단 스케치와 실질적으로 유사할 수 있으며, 데이터 프로세싱 시스템의 메모리에 저장되거나 작업자 컴퓨팅 디바이스(405), 애그리게이터 컴퓨팅 디바이스(410) 또는 클라이언트 디바이스(120)로부터 수신된 파라미터에 기초될 수 있다. A generalized bloom filter (ADBF) may be constructed by a publisher computing device (eg, data processing system 105A-N) as follows. The kappa parameter is a tunable parameter that can be set to the value 1, but can be less than 1. A data processing system may have access to one or more data records (eg, identifiers and attributes or identifiers meeting certain criteria) for use in constructing an ADBF data structure. For example, the data processing system may access a database (eg, database 115, etc.) to access one or more data records for use in inserting into the constructed ADBF sketch. ADBF sketches can be maintained in the memory of the data processing system and initialized with the initialization values described herein in the progress section for other sketch implementations. For example, the procedure for constructing an ADBF sketch may be substantially similar to a cascade swarm sketch or a liquid swarm sketch, and may be stored in the memory of the data processing system or on the worker computing device 405, aggregator computing device 410, or client It may be based on parameters received from device 120 .
구성 후, 데이터 레코드는 다음 기법을 사용하여 ADBF의 포지션에 매핑될 수 있다. ADBF 스케치는 여러 버킷 k와 i가 1에서 k까지의 범위에 있는 모든 p i 의 합이 kappa와 같은 임의의 확률 벡터(p 1 , p 2 ,…, p k )를 포함하도록 구성될 수 있다. kappa의 값은 1일 수 있지만 반드시 1일 필요는 없다. 확률 벡터는 확률 벡터의 각 좌표가 ADBF 스케치에서 단일 버킷 또는 레지스터에 할당될 수 있도록 한다. 데이터 레코드의 각 식별자(예를 들어, 데이터베이스(115)에 유지되는 데이터 레코드 등)는 확률 p i 로 ADBF 스케치의 버킷 i에 삽입될 수 있다. 실제로, h는 식별자 공간(예를 들어, 데이터 레코드 공간 등)을 균일하게(0, 2^64)로 매핑하는 데이터 프로세싱 시스템(105)에 의해 식별된 해시라고 하자. 그 다음 표현식 이 만족되면, 데이터 레코드 x를 버킷 i에 삽입할 수 있다. 데이터 레코드 세트의 경우(데이터 레코드는 "식별자"라는 용어와 상호 교환적으로 사용될 수 있음) 세트에 있는 적어도 하나의 데이터 레코드가 버킷 i에 삽입되면 대응 NBF에 엘리먼트 i = 1이고, 그렇지 않으면 0이다. 섹션 D에서 여기에 설명된 액체 군단 기법은 p i 가 지수 분포에 기초하여 결정되는 ADBF의 경우일 수 있다.After construction, data records can be mapped to positions in ADBF using the following technique. An ADBF sketch can be constructed so that several buckets k and i contain random vector vectors ( p 1 , p 2 ,…, p k ) such that the sum of all p i in the range 1 to k is kappa. The value of kappa can be 1, but does not have to be 1. A probability vector allows each coordinate of the probability vector to be assigned to a single bucket or register in the ADBF sketch. Each identifier of a data record (eg, a data record maintained in database 115, etc.) may be inserted into bucket i of an ADBF sketch with probability p i . In practice, let h be a hash identified by the data processing system 105 that maps the identifier space (e.g., data record space, etc.) uniformly (0, 2^64). then the expression is satisfied, data record x can be inserted into bucket i . For a data record set (data record can be used interchangeably with the term "identifier") element i = 1 in the corresponding NBF if at least one data record in the set is inserted into bucket i, otherwise 0 . The liquid swarm technique described herein in Section D may be the case for ADBF where pi is determined based on an exponential distribution.
이 섹션에서 설명하는 BLIP 기법은 차등적 프라이버시 보호일 수 있다. 특히, ADBF + BLIP는 원시 NBF의 각 버킷을 플립핑하여 획득될 수 있다. 이진 0은 이진 1로 플립될 수 있고 이진 1은 동일한 확률 p로 이진 0으로 플립될 수 있다. 일부 구현예에서, 이진 0 값은 확률 p로 이진 1로 플립될 수 있고 이진 1 값은 확률 q로 이진 0으로 플립될 수 있다. The BLIP technique described in this section can be a differential privacy protection. In particular, ADBF + BLIP can be obtained by flipping each bucket of raw NBF. Binary 0 can be flipped to binary 1 and binary 1 can be flipped to binary 0 with the same probability p . In some implementations, binary 0 values can be flipped to binary 1 with probability p and binary 1 values can be flipped to binary 0 with probability q .
ABDF 스케치 유니온의 카디널리티는 이 섹션 아래에 설명된 식(1) 또는 (3)의 근을 찾아서 추정될 수 있다. 이 추정기는 예를 들어 하나 이상의 애그리게이터 컴퓨팅 디바이스(410) 또는 하나 이상의 작업자 컴퓨팅 디바이스(405)에 의해 수행될 수 있다. 이 섹션에서 설명하는 추정기 기법은 균일 및 지수와 같은 특수 분포에 대한 근사 솔루션(근사치 포함)을 가질 수 있으며, 이전 섹션에서 설명한 균일 및 지수 블룸 필터의 기존 추정기를 커버한다. 비트의 임의 확률 분포에 대해, 이 추정기는 폐쇄형 솔루션을 갖지 않을 수 있지만 여기에 설명된 컴퓨팅 디바이스에 의해 수치적으로 해결될 수 있다. 추정기는 추정기를 실행하는 컴퓨팅 디바이스(예를 들어, 작업자 컴퓨팅 디바이스(405), 애그리게이터 컴퓨팅 디바이스(410) 등)의 메모리로부터 일련의 튜닝 파라미터를 포함하거나 검색할 수 있다. 카디널리티 추정기의 분산을 최소화하기 위한 최적의 파라미터는 아래에서 도출되고 설명된다.The cardinality of an ABDF sketch union can be estimated by finding the root of equation (1) or (3) described below in this section. This estimator may be performed, for example, by one or more aggregator computing devices 410 or one or more worker computing devices 405 . The estimator techniques described in this section can have approximate solutions (including approximations) for special distributions such as uniform and exponential, and cover the existing estimators of uniform and exponential bloom filters described in the previous section. For any probability distribution of bits, this estimator may not have a closed-end solution but can be solved numerically by the computing device described herein. The estimator may contain or retrieve a set of tuning parameters from memory of the computing device executing the estimator (eg, worker computing device 405, aggregator computing device 410, etc.). Optimal parameters for minimizing the variance of the cardinality estimator are derived and described below.
본 명세서에 설명된 하나 이상의 컴퓨팅 디바이스에 의해 실행 또는 수행되는 추정기는 노이즈 없는 ADBF 스케치(예를 들어, 통합된 노이즈 없는 ADBF 스케치 등)를 중복 제거할 수 있다. 노이즈 없는 ADBF 스케치를 병합할 때 유니온 세트의 ADBF가 b = [b 1 , b 2 ,…, b k ]로 표시된다. 1 ≤ i ≤ k의 경우, 유니온의 적어도 하나의 데이터 레코드가 해당 버킷에 매핑되면 b i = 1이고, 그렇지 않으면 0이다. 모멘트의 방법은 b 1 , b 2 ,…, b k 로부터 유니온을 추정하는데 사용될 수 있다. p i 는 데이터 레코드가 버킷 i에 매핑될 확률을 나타내는데 사용된다. u의 유니온 카디널리티를 고려하면, u 데이터 레코드가 버킷 i에 포함되지 않을 확률은 (1-p i )u와 같다. 즉, P(b i = 0) = (1 - p i )u이고, 따라서 E(b i = 1|u) = 1 - (1 - pi)u다. 따라서 예상치를 가진 총 수는 이다. 따라서, 관찰된 bi를 연결하고, 다음 식을 다시 풀면 u의 추정치를 얻을 수 있다.An estimator executed or performed by one or more computing devices described herein may deduplicate a denoised ADBF sketch (eg, a unified denoised ADBF sketch, etc.). When merging noiseless ADBF sketches, the ADBF of the union set b = [ b 1 , b 2 ,… , b k ]. For 1 ≤ i ≤ k , b i = 1 if at least one data record in the union is mapped to the corresponding bucket, and 0 otherwise. Methods of moments are b 1 , b 2 , . . . , b can be used to estimate the union from k . p i is used to indicate the probability that a data record will be mapped to bucket i . Given the union cardinality of u , the probability that u data record is not included in bucket i is equal to (1- p i ) u . That is, P( b i = 0) = (1 - pi ) u , so E( b i = 1|u) = 1 - ( 1 - pi ) u . Therefore, the total number with an estimate is am. Therefore, an estimate of u can be obtained by connecting the observed b i and solving the following equation again.
식 1: Equation 1:
통계 용어를 사용하면, "통계 에 따라, 비트 확률 분포 p i (1 ≤ i ≤ m)에서 u의 모멘트 추정기"라고 할 수 있다. 일반 분포 p i (1 ≤ i ≤ m)의 경우, 추정기는 폐쇄형 솔루션이 없을 수 있다. 그러나 균일 및 지수 분포와 같은 특정 분포의 경우, 추정기는 이전 섹션에서 위에서 설명한 추정기와 정확하게 일치하는 근사 솔루션을 가질 수 있다. Using statistical terminology, "statistics According to , we can say "the moment estimator of u in the bit probability distribution p i (1 ≤ i ≤ m)". For the normal distribution p i (1 ≤ i ≤ m), the estimator may not have a closed solution. However, for certain distributions, such as the uniform and exponential distributions, the estimator may have an approximate solution that exactly matches the estimator described above in the previous section.
당업계에 알려진 바와 같이, 표현 은 x가 무한대에 가까워지면 e -1 로 간다. 따라서, 각 p i 가 충분히 작을 때(예: 매우 작지만 0은 아님 등),(1-p i )1/pi는 대략 e -1 이고, (1-p i )u는 대략 exp(-p i u)이다. 이 근사를 통해 식(1)을 식(2)로 줄일 수 있다.As is known in the art, the expression goes to e -1 when x approaches infinity. Thus, when each p i is sufficiently small (e.g. very small but not zero, etc.), (1- p i ) 1/pi is approximately e -1 , and (1- p i ) u is approximately exp(- p i u ) is. Through this approximation, equation (1) can be reduced to equation (2).
여기서 y =은 블룸 필터의 1의 수이다.where y = is the number of 1s in the bloom filter.
균일 블룸 필터의 경우, 각 p i = 1/k이고 식(2)의 해는 다음과 같다.For a uniform bloom filter, each p i = 1/ k and the solution of equation (2) is
이 식은 균일 블룸 필터에 대한 유니온의 추정기일 수 있다.This equation can be a union's estimator for a uniform bloom filter.
지수 일반화 블룸 필터의 경우, 각 p i = -cln(i/k)이며, 여기서 c는 정규화 상수다. k가 충분히 크면For an exponential generalized bloom filter, each p i = -c ln (i/k), where c is the regularization constant. if k is large enough
적분은 partus에 의한 적분을 통해 해결될 수 있다. 따라서, exp(-p i u) = exp[(1/k) ln(i/k)u] = (i/k)u/k, 그리고 따라서,Integrals can be solved through integration by partus. Thus, exp(- p i u ) = exp[(1/ k ) ln( i / k ) u ] = ( i / k ) u/k , and thus
이 경우, 식 (2)는 k / (u/k + 1) = k - y, 즉, u/k + 1 = k/(k-y)로 감소되며, u = ky / (k - y) = y / (1 - y/k)이다. 이것은 식(3)에 주어진 해일 수 있다.In this case, equation (2) reduces to k / ( u / k + 1) = k - y , that is, u / k + 1 = k / ( ky ), and u = ky / ( k - y ) = y / (1 - y/k ). This can be the solution given in equation (3).
쌍곡선 일반화 블룸 필터의 경우, 각 , 여기서 a는 미리 지정된 비율이고 c는 정규화 상수다. k가 충분히 크면:For a hyperbolic generalized bloom filter, each , where a is a predetermined ratio and c is a normalization constant. If k is large enough:
[0001] 이면, , 그리고 그 후, = = [0001] if it is, , and after that, = =
= ]= ]
= ,= ,
여기서 는 지수 적분 함수다. 따라서 식(2)는 로 감소되고, Ei 함수의 구현을 사용하여 b의 근을 풀 수 있다. u의 값은 u = abk / [1 - exp(-a)]로 추정될 수 있다.here is an exponential integral function. Therefore, equation (2) is , and the roots of b can be solved using an implementation of the E i function. The value of u can be estimated as u = abk / [1 - exp(-a)].
위의 유도를 요약하면, 식(1)은 비트 분포 p i (1 ≤ i ≤ m)에서 유니온 추정에 대한 개요를 제공한다. 추정치는 통계 의 기대치에 기초하여 모멘트 방법을 기반으로 얻거나 도출될 수 있다. 추정기는 균일하고 지수적인 ADF에 대한 적어도 근사 형태 솔루션을 가지고 있으며, 이렇게 얻어지거나 도출된 근사 형태는 본 명세서에 기술된 섹션 A-D에서 설명한 추정기일 수 있다.Summarizing the above derivation, equation (1) gives an outline for union estimation in the bit distribution p i (1 ≤ i ≤ m). estimates are statistics can be obtained or derived based on the moment method based on the expectation of The estimator has at least an approximate form solution to the uniform exponential ADF, and the approximate form thus obtained or derived may be the estimator described in section AD described herein.
또 다른 비트 분포의 ADBF, p i = c(i/k), c는 정규화 상수다. 이 분포에서 비트 확률은 비트 인덱스 i의 선형 함수로 감소될 수 있다. 이 ADBF에 대한 폐쇄형 추정기도 있다. 첫째, k가 충분히 클 때 정규화 상수 . 그 후, 여기서 a = 2u/k. 따라서 식(2)는 인 경우 유지할 수 있다. 이것은 u의 초월적 함수일 수 있으며, 폐쇄형 솔루션이 없을 수도 있다. 그러나 이것은 u의 단조 함수로 주어질 수 있기 때문에 수치적으로 풀어질 수 있다. 일반적으로 식(2)는 u의 단조 함수로 주어질 수 있으므로, 이분법 방법을 사용하여 풀어질 수 있다.ADBF of another bit distribution, pi = c (i/k) , where c is the normalization constant. From this distribution, the bit probability can be reduced as a linear function of the bit index i . There is also a closed-form estimator for this ADBF. First, the regularization constant when k is large enough . After that, where a = 2 u/k . Therefore, equation (2) is can be maintained if It may be a transcendental function of u , and there may be no closed-form solution. However, since it can be given as a monotonic function of u , it can be solved numerically. In general, since equation (2) can be given as a monotonic function of u , it can be solved using the binary method.
특히, 작업자 컴퓨팅 디바이스(405) 또는 애그리게이터 컴퓨팅 디바이스(410)에 의해 실행되는 무-노이즈 ADBF에 대한 추정기는 bi의 각각에 가중치를 추가함으로써 더 확장될 수 있다. 유니온 세트의 원시 블룸 필터가 로 표현되는 경우 유니온 추정을 고려한다. 위에서 설명한 추정기는 총 비트의 예상 값 사이의 관계를 활용한다. 이러한 구현예에서, 모든 비트는 확률이 가장 높은 비트에서 가장 확률이 낮은 비트까지 동일하게 가중치를 부여할 수 있다. 이것은 균일하지 않은 블룸 필터에는 효율적이지 않을 수 있다. 비-균일 블룸 필터를 구현하는 기법에서, 처음 몇 비트에 대한 확률()은 모든 비트의 평균()보다 훨씬 높을 수 있고, 마지막 몇 비트에 대한 확률은 평균보다 훨씬 낮을 수 있다. 따라서 블룸 필터 스케치가 절반이 찼을 때, 처음 몇 비트는 1과 같고 마지막 몇 비트는 0과 같을 가능성이 있다. 그러한 구현예에서, 스케치의 양쪽 끝에 있는 비트는 거의 정보를 전달할 수 없는 반면, 스케치 중간의 패턴은 카디널리티 추정(예: 참조 군단의 선택 등)에 초점이 맞춰질 수 있어야 한다. 따라서, 가중화된 합산 모멘트에 기초한 추정치는 직접 합계 대신, 다른 카디널리티 추정 시스템에 비해 개선된 카디널리티 추정 체계의 정확성과 유연성을 향상시킬 수 있다.In particular, the estimator for noise-free ADBF executed by worker computing device 405 or aggregator computing device 410 can be further extended by adding a weight to each of b i . Union set's primitive bloom filter Consider union estimation if expressed as The estimator described above is the expected value of total bits. use the relationship between In this implementation, all bits may be weighted equally from the most probable bit to the least probable bit. This may not be effective for non-uniform bloom filters. In a technique for implementing a non-uniform bloom filter, the probability for the first few bits ( ) is the average of all bits ( ), and the probability for the last few bits can be much lower than average. So when the bloom filter sketch is half full, it is possible that the first few bits are equal to 1 and the last few bits are equal to 0. In such an implementation, the bits at either end of the sketch may carry little information, while the patterns in the middle of the sketch should be focusable for cardinality estimation (eg, selection of reference corps, etc.). Thus, the weighted sum moment Estimates based on are directly summed Instead, it can improve the accuracy and flexibility of the improved cardinality estimation scheme compared to other cardinality estimation systems.
와 같이, 에 기초한 방법의 모멘트는 아래 식(3)의 근으로서 의 추정치를 제공할 수 있다: together with, The moment of the method based on is the root of equation (3) below. can give an estimate of:
일부 구현예에서, 가중치 는 상수일 수 있다. 가중치가 상수 값이라고 하면, 및 다. 따라서 위의 식(3)은 과 같이 다시 작성될 수 있다. 은 랜덤 변수일 수 있다. 사실, 특정 가정 하에서, 은 분산을 가진 변수일 수 있다. 이 경우, 델타 방법은 의 분포가 근(예: 등)의 분포를 결정할 수 있다.In some embodiments, the weight may be a constant. If the weight is a constant value, and all. Therefore, equation (3) above is can be rewritten as may be a random variable. In fact, under certain assumptions, silver It can be a variable with variance. In this case, the delta method is the distribution of root (e.g. etc.) can be determined.
은 및 을 가진 랜덤 변수일 수 있다. 충분히 큰 를 고려하면, . 여기서 은 진정한 유니온을 나타낼 수 있다. 단순화를 위해 Delta 방법으로 . silver and It can be a random variable with big enough Considering . here can represent a true union. Delta method for simplicity .
이 분포에서, 과의 값은 위에 설명되어 있으며, .In this distribution, class The value of is described above, .
위를 고려하면,Considering the above,
여기서 행렬 는matrix here Is
● for any ● for any
● for any ● for any
그리고 벡터 각 엘리먼트 를 가질 수 있다.and vector each element can have
최적의 가중치 벡터는 다음과 같다:The optimal weight vector is:
이 가중치 하에서 . under this weight .
또한, 는 의 함수로 최소화될 수 있다. also, Is can be minimized as a function of
그들의 스케치의 차별화된 프라이버시를 유지하기 위해, 각각의 퍼블리셔 컴퓨팅 디바이스(예를 들어, 데이터 프로세싱 시스템(105A-N) 등)는 미리 결정된 확률로 특정 비트를 플립할 수 있다. 여기서 노이즈를 추가하기 위해 비트를 플립하는 프로세스를 '블리핑'이라고 할 수 있으며, 확률적 비트 플립을 통해 노이즈가 도입된 스케치를 '블리핑된'이라고 한다. 애그리게이터 컴퓨팅 디바이스(예를 들어, 작업자 컴퓨팅 디바이스(405), 애그리게이터 컴퓨팅 디바이스(410) 등)에 의해 구현된 추정기는 추가로 확장되어 데이터 프로세싱 시스템(105)에 의해 생성된 노이징된(예: 블리핑된) ADBF 스케치의 유니온의 카디널리티를 정확하게 계산할 수 있다. To maintain the differentiated privacy of their sketches, each publisher computing device (eg, data processing systems 105A-N, etc.) may flip certain bits with a predetermined probability. Here, the process of flipping bits to add noise can be referred to as 'bleeping', and a sketch in which noise is introduced through stochastic bit flipping is referred to as 'bleeped'. An estimator implemented by an aggregator computing device (e.g., worker computing device 405, aggregator computing device 410, etc.) may be further extended to calculate the noised (e.g., : bleeped) can accurately calculate the cardinality of unions in ADBF sketches.
데이터 프로세싱 시스템(105)에 의해 생성된 ADBF는 블리핑될 수 있다. 따라서 위에서 설명한 원시 ADBF에 기반한 추정기는 직접 적용되지 않을 수 있다. 이러한 구현예에서, 애그리게이터 컴퓨팅 디바이스는 유니온 세트의 원시 ADBF를 추정할 수 있다(예: 마지막 두 하위 섹션의 벡터 등). 노이징된 블룸 필터가 로 표현되고, 블립 확률(예: ADBF 스케치에서 주어진 '0'비트가 '1'로 플립될 확률 및 ADBF 스케치에서 주어진 '1'비트가 '0'으로 플립될 확률, 등)이 라고 가정하면, 벡터는 애그리게이터 컴퓨팅 디바이스(예를 들어, 작업자 컴퓨팅 디바이스(405), 애그리게이터 컴퓨팅 디바이스(410) 등)에 의해 다음과 같이 추정될 수 있다:The ADBF generated by data processing system 105 may be bled. Therefore, the estimator based on the raw ADBF described above may not be directly applicable. In such an implementation, the aggregator computing device may estimate the raw ADBF of the union set (e.g., the last two subsections of vectors, etc.). Noised bloom filter , and the blip probabilities (e.g., the probability of a given '0' bit in the ADBF sketch flipping to '1' and the probability of a given '1' bit flipping to '0' in the ADBF sketch, etc.) Assuming that The vector may be estimated by an aggregator computing device (eg, worker computing device 405, aggregator computing device 410, etc.) as:
추정된 벡터는 노이징된(예: 블립핑된) 스케치의 유니온 크기 를 추정하기 위해 본 명세서에 상기 기술된 식(1) 또는 식(3)과 함께 사용될 수 있다.estimated vectors are the size of the union of the noised (e.g. blipped) sketch can be used in conjunction with equation (1) or equation (3) described above in this specification to estimate .
노이즈는 추정기에 분산을 더 추가할 수 있다. 노이즈를 사용하면 추정기의 분산을 로 나타낼 수 있고, 여기서 벡터는 로 나타낼 수 있고, 행렬 은 로 나타낼 수 있고, 는 상기 벡터이다.Noise can add more variance to the estimator. Using noise reduces the variance of the estimator. can be represented by, where vector Is can be expressed as, matrix silver can be expressed as, is the vector.
분산을 구한 다음 분산을 최소화하는 최적의 가중치를 얻으려면, 각 을 구하는 것으로 충분하다. 그러나, 이러한 공분산은 더 이상 유니온 도달 범위만으로 결정될 수 없다. 서로 다른 ADBF 간의 상관 관계에 의존하며, 이러한 상관 관계는 전체 벤 다이어그램에 따라 달라진다. To find the variance and then get the optimal weights that minimize the variance, It is sufficient to obtain However, these covariances can no longer be determined from union reach alone. It depends on the correlations between different ADBFs, and these correlations depend on the overall Venn diagram.
퍼블리셔 컴퓨팅 디바이스(예를 들어, 데이터 프로세싱 시스템(105) 등) 각각에 걸친 식별자(예를 들어, 데이터 레코드)의 멀티세트의 유니온에 걸친 노이즈의 분산 분석은 각 데이터 프로세싱 시스템(105) 간의 데이터 레코드의 각 세트의 오버랩에 기초하여 달라질 수 있다. 서로 다른 데이터 프로세싱 시스템의 데이터 레코드 간의 분산 분석을 지원하기 위해, 다음 표기를 고려한다.A variance analysis of the noise across unions of multisets of identifiers (eg, data records) across each of the publisher computing devices (eg, data processing systems 105, etc.) may vary based on the overlap of each set of . To support analysis of variance between data records from different data processing systems, consider the following notation:
● 은 번째 데이터 프로세싱 시스템(105)(예: 데이터 프로세싱 시스템(105V) 등)에서 얻은 ADBF 스케치 데이터 레코드의 카디널리티다.● silver The cardinality of the ADBF sketch data record obtained from the data processing system 105 (eg, the data processing system 105V, etc.).
● 은 번째 데이터 프로세싱 시스템으로부터 획득된 노이즈 없는 ADBF의 번째 비트이다.● silver of the noise-free ADBF obtained from the th data processing system. is the second bit.
● 는 번째 데이터 프로세싱 시스템으로부터 획득된 노이징된 ADBF의 번째 비트이다(는 고정 확률 로 를 플립함으로써 획득된다).● Is of the noised ADBF obtained from the data processing system is the second bit ( is a fixed probability as is obtained by flipping ).
다음 식과 도출은 분산이 멀티세트 카디널리티 추정에 미치는 영향을 이해하는데 도움이 될 수 있다. 유니온의 추정 ADBF,은 그 번째 엘리먼트로 The following equations and derivations can be helpful in understanding the effect of variance on multiset cardinality estimation. Union's Estimated ADBF, is that as the second element
과 같이 정의된다. is defined as
따라서, 독립적인 카디널리티 시나리오에서, Thus, in an independent cardinality scenario,
Where,Where,
Thus, Thus,
Consider: Consider:
Where, Where,
Thus:Thus:
Now consider: Now consider:
where for any data processing system : where for any data processing system :
Because Because
consider: consider:
* *
Consider also:Consider also:
Hence: Therefore:
Put together: Put together:
Put together: Put together:
Put together: Put together:
which can equal which can equal
이것은 추정기의 편견없음과 일치한다. Put together: This is consistent with the estimator's unbiasedness. Put together:
요약하면 다음과 같습니다.To summarize:
● ●
● ●
● ●
이 공식의 분석을 따르면:According to the analysis of this formula:
유니버스가 크다고 생각하면: Considering the universe is large:
여기서 은 카디널리티의 진정한 유니온이다. 추가 고려:here is a true union of cardinalities. Additional considerations:
유니버스가 크다고 고려하면: Considering the universe is large:
노이즈 없는 경우의 공분산과 동일할 수 있다.It may be the same as the covariance in the case of no noise.
다음은 데이터 프로세싱 시스템(105A-N), 작업자 컴퓨팅 디바이스(405A-N), 애그리게이터 컴퓨팅 디바이스(410), 클라이언트 디바이스(120A-N) 또는 본 명세서에 기술된 임의의 다른 컴퓨팅 디바이스에서 구현될 수 있는 알고리즘 구현 및 의사 코드를 포함한다. 또한, 데이터 프로세싱 시스템(105A-N), 시스템(100), 시스템(400A-C)의 임의의 컴포넌트 및 그의 임의의 컴포넌트는 이 섹션에서 상세히 설명된 임의의 기능을 수행할 수 있다. The following may be implemented in data processing systems 105A-N, worker computing devices 405A-N, aggregator computing devices 410, client devices 120A-N, or any other computing device described herein. Contains algorithm implementations and pseudocode. Further, any component of data processing systems 105A-N, systems 100, and systems 400A-C, and any components thereof, may perform any of the functions detailed in this section.
ADBF 스케치가 m 비트를 갖도록 생성되었다고 가정한다. 균일(예를 들어, 정상 블룸 필터) 및 지수 블룸 필터(예를 들어, 액체 군단 등)에 대한 0, 1,…, m-1에서 i에 대한 확률 값 pi는 데이터 프로세싱 시스템(105)에 의해 생성된 또는 네트워크(110)를 통해 외부 컴퓨팅 디바이스(예를 들어, 여기에 설명된 임의의 컴퓨팅 디바이스 등)에 의해 제공된 미리 결정된 값이고, 데이터 프로세싱 시스템(105)의 메모리 또는 이 섹션에서 설명된 기능을 수행하는 임의의 다른 컴퓨팅 디바이스에 저장된다. 지수 블룸 필터 구현예의 경우, kappa = 1 값을 간단하게 사용할 수 있지만, 일부 구현예에서 다른 값도 사용될 수 있다. Assume that the ADBF sketch is created with m bits. 0, 1,... for uniform (eg, stationary bloom filters) and exponential bloom filters (eg, liquid bodies, etc.) , m−1, the probability value pi for i is either generated by data processing system 105 or provided by an external computing device (e.g., any computing device described herein, etc.) via network 110. It is a predetermined value and is stored in the memory of data processing system 105 or any other computing device that performs the functions described in this section. For exponential bloom filter implementations, a value of kappa = 1 can be used simply, but other values may be used in some implementations.
각각의 pi 값을 생성하는 하나 이상의 구현예가 아래 의사 코드로 제공된다: One or more implementations of generating each pi value are provided in pseudocode below:
if method == 'exponential': if method == 'exponential':
p = -np.log((np.arange(bit_size) + 1) / bit_size) p = -np.log((np.arange(bit_size) + 1) / bit_size)
if method == 'uniform': if method == 'uniform':
p = np.ones(bit_size) p = np.ones(bit_size)
p = p/sum(p) p = p/sum(p)
데이터 레코드 세트의 경우, 다음 예시적 의사 코드에 설명된 대로 정규화된 값을 계산하여 ADBF 비트 포지션에 추가될 수 있다.For a data record set, a normalized value can be calculated and added to the ADBF bit position as described in the following example pseudocode.
# Map ids into normalized values.# Map ids into normalized values.
values = hash64(ids) / 2^64 values = hash64(ids) / 2^64
# Value bounds for bits. # Value bounds for bits.
bit_bounds = np.cumsum(p) bit_bounds = np.cumsum(p)
# Identify the bit index for values. # Identify the bit index for values.
bit_indices = np.searchsorted(bit_bounds, values) bit_indices = np.searchsorted(bit_bounds, values)
# Set the respective bit for each id. # Set the respective bit for each id.
ADBF = np.zeros(bit_size) ADBF = np.zeros(bit_size)
for i in bit_indices: for i in bit_indices:
ADBF[i] = 1 ADBF[i] = 1
주어진 ADBF 스케치의 경우, 스케치에 추가되었던 고유 데이터 레코드의 수는 스케치의 1 비트 수에 기초하여 추정될 수 있다. 이것은 다음 예시 의사 코드로 기술된다:For a given ADBF sketch, the number of unique data records that have been added to the sketch can be estimated based on the number of 1 bits in the sketch. This is illustrated by the following example pseudocode:
def _UniqueCountFromOnes(ones, bit_size, method): def _UniqueCountFromOnes(ones, bit_size, method):
if method == 'exponential': if method == 'exponential':
return ones / (1 - ones/bit_size) return ones / (1 - ones/bit_size)
elif method == 'uniform': elif method == 'uniform':
return np.log(1 - ones / bit_size) / np.log(1- 1 / bit_size) return np.log(1 - ones / bit_size) / np.log(1- 1 / bit_size)
확률 p로 비트를 플립핑하여 각 스케치에 노이즈를 추가할 수 있다. 비트가 플립되는 확률 p는 앞에서 설명한 확률 할당 pi와 상이하다. ADBF 스케치에 대해 무작위로 플립된 비트는 차등 프라이버시를 안전하게 만들 수 있다. 비트 플립 프로세스는 다음과 같은 의사 코드 예시로 기술될 수 있다:We can add noise to each sketch by flipping bits with probability p. The probability that a bit is flipped, p, is different from the probability assignment pi described above. Randomly flipped bits for the ADBF sketch can safely create differential privacy. The bit flip process can be described with the following pseudocode example:
# blip: the probability to flip: 1 -> 0; and 0-> 1# blip: the probability to flip: 1 -> 0; and 0-> 1
def Flip(ADBF, flip): def Flip(ADBF, flip):
for i in np.arange(len(ADBF)): for i in np.arange(len(ADBF)):
if np.random.uniform() < flip: if np.random.uniform() < flip:
if ADBF[i] == 1: if ADBF[i] == 1:
ADBF[i] = 0 ADBF[i] = 0
else: else :
ADBF[i] = 1 ADBF[i] = 1
일부 구현예에서, 상기 구현예는 별도의 확률이 '0'비트를 '1'비트로 플립하고 '1'비트를 '0'비트로 플립할 수 있도록 확장될 수 있다. 이러한 구현예는 아래의 의사 코드 예시에서 보여진다:In some implementations, the above implementations can be extended so that separate probabilities can flip '0' bits to '1' bits and flip '1' bits to '0' bits. This implementation is shown in the pseudocode example below:
def Flip(ADBF, flip0to1_prob, flip1to0_prob): def Flip(ADBF, flip0to1_prob, flip1to0_prob):
"""Can be more efficient than for-loop. """Can be more efficient than for-loop.
""" """
num_bits = len(ADBF) num_bits = len(ADBF)
flip0to1 = np.random.choice([True, False], size=num_bits,flip0to1 = np.random.choice([ True , False ], size=num_bits,
p=[flip0to1_prob, 1 - flip0to1_prob]) p=[flip0to1_prob, 1 - flip0to1_prob])
flip1to0 = np.random.choice([True, False], size=num_bits,flip1to0 = np.random.choice([ True , False ], size=num_bits,
p=[flip1to0_prob, 1 - flip1to0_prob]) p=[flip1to0_prob, 1 - flip1to0_prob])
return ADBF * (1 - flip1to0) + (1 - ADBF) * flip0to1 return ADBF * (1 - flip1to0) + (1 - ADBF) * flip0to1
확률 p로 플립된 비트를 통해 소개된 노이즈를 가진 주어진 ADBF 스케치의 경우, 스케치에 추가되었던 고유 데이터 레코드의 수는 스케치의 1 비트의 수정된 수에 기초하여 추정될 수 있다. 이는 다음과 같은 의사 코드 예시로 보여진다: For a given ADBF sketch with noise introduced via flipped bits with probability p, the number of unique data records that were added to the sketch can be estimated based on the modified number of 1 bits in the sketch. This is shown in the following pseudo-code example:
def _UniqueCount(ADBF, blip=None, method='exponential'): def _UniqueCount(ADBF, blip=None, method='exponential'):
one_bits = sum(ADBF) one_bits = sum(ADBF)
zero_bits = len(ADBF) - one_bits zero_bits = len(ADBF) - one_bits
bit_size = len(ADBF) bit_size = len(ADBF)
if blip: if blip:
q = 1-blip q = 1-blip
corrected_one_bits = (q*one_bits - blip*zero_bits) / (q - blip) corrected_one_bits = (q*one_bits - blip*zero_bits) / (q - blip)
return _UniqueCountFromOnes(corrected_one_bits, bit_size, method) return _UniqueCountFromOnes(corrected_one_bits, bit_size, method)
다음 기법은 임의의 수(예를 들어, m) 데이터 프로세싱 시스템(105)에 걸쳐 데이터 레코드 세트를 중복 제거하기 위해 슬라이스 내의 모든 0의 수를 계산할 수 있다. 슬라이스는 m 퍼블리셔의 비트 포지션에 대한 m 비트 벡터일 수 있다. 슬라이스가 m 개의 데이터 프로세싱 시스템의 모든 0 비트를 가진 경우, 이 슬라이스에 기여한 데이터 레코드는 없다. 목표는 노이징된 관측치가 주어졌을 때 모두 0 비트 슬라이스(all-zero-bits-slices)의 수를 추정하는 것이다. 이를 수행하는 방법의 예는 다음 의사 코드와 같다:The following technique may compute all the number of zeros in a slice to deduplicate a set of data records across an arbitrary number (eg m) data processing system 105. A slice can be an m bit vector for m publisher's bit positions. If a slice has all 0 bits of m data processing systems, then no data record has contributed to this slice. The goal is to estimate the number of all-zero-bits-slices given a noisy observation. An example of how to do this would look like the following pseudocode:
def _ComputeOnesFromPubs(ADBFs, blip, verbose=False): def _ComputeOnesFromPubs(ADBFs, blip, verbose= False ):
"""Correct number of ones.""" """Correct number of ones."""
m = len(ADBFs) m = len(ADBFs)
# Compute counts of bit positions for slices of 1 one, 2 ones, 3 ones, etc. # Compute counts of bit positions for slices of 1 one, 2 ones, 3 ones, etc.
sum_ADBF = functools.reduce(lambda a, b: a + b, ADBFs.values())sum_ADBF = functools.reduce( lambda a, b: a + b, ADBFs.values())
unique_values, freq_count = np.unique(sum_ADBF, return_counts=True)unique_values, freq_count = np.unique(sum_ADBF, return_counts= True )
freqs = np.zeros(m+1) freqs = np.zeros(m+1)
freqs[[int(v) for v in unique_values]] = freq_countfreqs[[ int (v) for v in unique_values]] = freq_count
q = 1 - blip q = 1 - blip
s = 0 s = 0
for k in np.arange(m+1): for k in np. arange(m+1):
s += np.power(q, m-k) * np.power(-blip, k) * freqs[k] s += np.power(q, m-k) * np.power(-blip, k) * freqs[k]
n0 = s/np.power(q-blip, m) n0 = s/np.power(q-blip, m)
return len(ADBFs[0]) - n0 return len(ADBFs[0]) - n0
그 후, 여러 데이터 프로세싱 시스템에서 ADBF 스케치를 생성하는데 사용되는 데이터 레코드의 유니온을 계산할 수 있다. 아래에 포함된 예시적 의사 코드는 많은 데이터 프로세싱 시스템의 '블리핑된' ADBF 스케치에서 데이터 레코드의 유니온을 나타내는 스케치 생성을 결정하는 적어도 하나의 방법을 구현한다.After that, multiple data processing systems can compute unions of data records used to create ADBF sketches. Example pseudocode included below implements at least one method for determining sketch generation representing unions of data records in 'bleeped' ADBF sketches of many data processing systems.
def EstimateUnionADBFFromPubs(ADBFs, blip0to1_probs_arr, blip1to0_probs_arr): def EstimateUnionADBFFromPubs(ADBFs, blip0to1_probs_arr, blip1to0_probs_arr):
"""Each ADBF can be a numpy array. """Each ADBF can be a numpy array.
""" """
num_pubs = len(ADBFs) num_pubs = len(ADBFs)
num_bits = len(ADBFs[0]) num_bits = len(ADBFs[0])
d_vector = np.ones(num_bits) d_vector = np.ones(num_bits)
* for j in range(num_pubs):* for j in range(num_pubs):
d_vector *= (- blip1to0_probs_arr[j] * ADBFs[j] + d_vector *= (- blip1to0_probs_arr[j] * ADBFs[j] +
(1 - blip1to0_probs_arr[j]) * (1 - ADBFs[j])) (1 - blip1to0_probs_arr[j]) * (1 - ADBFs[j]))
return d_vector / np.prod(1 - blip1to0_probs_arr - blip0to1_probs_arr) return d_vector / np.prod(1 - blip1to0_probs_arr - blip0to1_probs_arr)
다음은 본 명세서 및 이전 섹션에서 설명된 다양한 확률 데이터 구조의 중복 제거된 빈도를 계산하기 위한 본 명세서에 기술된 작업자 컴퓨팅 디바이스 또는 애그리게이터 컴퓨팅 디바이스(예를 들어, 작업자 컴퓨팅 디바이스(405), 애그리게이터 컴퓨팅 디바이스(410 등))에 의해 사용 가능한 다양한 구현예 및 프로세스에 대한 설명을 포함한다. 전술한 바와 같이, 애그리게이터 컴퓨팅 디바이스(410) 또는 작업자 컴퓨팅 디바이스(405)와 같은 애그리게이터 컴퓨팅 디바이스는 다양한 식별자 서버(예를 들어, 데이터 프로세싱 시스템(105A-N) 등)로부터 하나 이상의 데이터 구조를 수신할 수 있다. 이러한 각 데이터 구조는 하나 이상의 속성을 포함하는 식별자를 표현할 수 있다. 예를 들어, 이러한 속성은 인터렉션에 할당되거나 연관된 디바이스 별 온라인 활동 또는 인터렉션을 설명할 수 있다. 데이터 레코드(예를 들어, 데이터 레코드(122) 등)은 각각의 데이터 프로세싱 시스템(105)에 의해 유지될 수 있다. 애그리게이터 컴퓨팅 디바이스(410) 또는 작업자 컴퓨팅 디바이스(405)는 식별자 서버(예를 들어, 데이터 프로세싱 시스템(105))로부터 수신된 데이터 구조의 구성에 의해 표현된 정보에 기초하여 식별자의 속성의 빈도를 계산할 수 있다. 여기에 설명된 바와 같이, 계산될 수 있는 하나의 메트릭은 많은 식별자 서버에 걸쳐 유지되는 식별자의 빈도 속성이다. 예를 들어, 특정 유형의 콘텐츠와 특정 유형의 온라인 활동(예를 들어, 인터렉션)을 수행한 특정 그룹의 식별자에 대해 빈도가 계산될 수 있다. 위에서 설명한 방법과 같이 스케치를 집합하는 다양한 방법 또는 순서가 아래에 포함된다.The following are worker computing devices or aggregator computing devices described herein (e.g., worker computing device 405, aggregator It includes descriptions of various implementations and processes usable by computing devices (such as 410). As discussed above, an aggregator computing device, such as aggregator computing device 410 or worker computing device 405, may retrieve one or more data structures from various identifier servers (eg, data processing systems 105A-N, etc.). can receive Each of these data structures can represent an identifier containing one or more attributes. For example, these properties may describe online activities or interactions by devices assigned to or associated with the interaction. A data record (eg, data record 122 , etc.) may be maintained by each data processing system 105 . The aggregator computing device 410 or worker computing device 405 determines the frequency of an attribute of an identifier based on information represented by the configuration of the data structure received from the identifier server (eg, data processing system 105). can be calculated As described herein, one metric that can be calculated is the frequency attribute of an identifier maintained across many identifier servers. For example, a frequency may be calculated for an identifier of a particular group that has performed a particular type of online activity (eg, interaction) with a particular type of content. Various methods or sequences of assembling sketches, such as those described above, are included below.
적어도 하나의 방법은 데이터 프로세싱 시스템(105)에 의해 애그리게이터 컴퓨팅 디바이스(410)(또는 경우에 따라 작업자 컴퓨팅 디바이스(405))로 전송되는 각 데이터 구조에 기여하는 식별자의 도달 범위가 실질적으로 독립적이라고 가정한다. 이러한 방법은 데이터 프로세싱 시스템(105)으로부터 수신된 데이터 구조의 순차적 중복 제거를 구현할 수 있으며, 아래의 컨볼루션 프로세스를 통해 설명될 수 있으며, 여기서 fi는 i 번째 데이터 프로세싱 시스템의 빈도 분포이다. 이러한 구현예에서, 빈도는 f1_2 =(f1 * f2)(k)와 같이 반복적으로 결정될 수 있고, 여기서 k는 원하는 빈도 속성 값(예: 특정 콘텐츠 아이템과 k번 이상 인터렉션한 고유 식별자의 수 k)이다. 빈도 분포 데이터 구조를 집합시키는 컴퓨팅 디바이스는 예를 들어, f1_2_3 =(f1_2 * f3)(k) 등의 프로세스를 각 식별자 서버(예: 데이터 프로세싱 시스템(105))로부터 빈도 분포가 결정될 때까지 수행할 수 있다.At least one method provides that the reach of the identifier contributing to each data structure transmitted by the data processing system 105 to the aggregator computing device 410 (or worker computing device 405 as the case may be) is substantially independent. Assume. This method may implement sequential deduplication of data structures received from data processing system 105, and may be described through a convolution process below, where fi is the frequency distribution of the ith data processing system. In such an implementation, the frequency can be determined iteratively as f1_2 = (f1 * f2)(k), where k is the desired frequency attribute value (e.g., k the number of unique identifiers that have interacted with a particular content item k or more times). am. The computing device that aggregates the frequency distribution data structure may perform processes such as f1_2_3 = (f1_2 * f3) (k) until the frequency distribution is determined from each identifier server (eg, data processing system 105). can
이러한 구현예에서, 데이터 프로세싱 시스템(105) 각각에 의해 전송된 스케치는 본 명세서에서 전술한 바와 같이 애그리게이터 컴퓨팅 디바이스(410) 또는 작업자 컴퓨팅 디바이스(405)에 의해 순차적으로 결합될 수 있다. 이 방법의 간결한 설명을 돕기 위해, 다음 작업이 스케치와 함께 사용되어 스케치가 나타내는 데이터 레코드 세트에 대한 다양한 세트 동작을 표시한다. 이러한 작업은 인터섹션(), 유니온() 또는 설정 차이(\)를 포함할 수 있다.In such an implementation, the sketches transmitted by each of the data processing systems 105 may be sequentially combined by the aggregator computing device 410 or worker computing device 405 as described herein above. To aid in the concise description of this method, the following operations are used with sketches to show the various set actions for the data record sets represented by the sketches. These operations are performed by intersection ( ), Union( ) or set differences (\).
두 개의 식별자 서버(예를 들어, 두 개의 데이터 프로세싱 시스템(105))를 고려한다. 제1 데이터 프로세싱 시스템(105)은 스케치 를 전송하고, 제2 데이터 프로세싱 시스템(105)은 을 전송한다. 각 퍼블리셔의 모든 스케치가 분리된 세트에서 나온 것이므로 1개 이상의 도달 범위의 스케치를 쉽게 얻을 수 있다. 예를 들면, 및 .Consider two identifier servers (e.g., two data processing systems 105). The first data processing system 105 is a sketch and the second data processing system 105 send Since all sketches from each publisher are from separate sets, it's easy to get sketches of more than one reach. For example, and .
다음으로, 애그리게이터 컴퓨팅 디바이스(410) 또는 작업자 컴퓨팅 디바이스(405)는 제1 데이터 프로세싱 시스템(105) 및 제2 데이터 프로세싱 시스템(105)으로부터 수신된 두 스케치의 유니온의 도달 빈도를 추정할 수 있다.Next, the aggregator computing device 410 or worker computing device 405 may estimate the frequency of arrival of the union of the two sketches received from the first data processing system 105 and the second data processing system 105 . .
예를 들어, 의 경우, frequency j의 유니온 도달 범위는 다음 교차 추정치에서 비롯된다(그리고 서로 분리되어 있다). 및 , 및.for example, For , the union reach of frequency j is derived from (and separated from each other) the following intersection estimates: and , and .
및 에 대해, 또는 는 더 분해해야 될 수 있다. 예를 들면: and About, or may require further decomposition. For example:
. .
. .
따라서 빈도 = j 의 카디널리티는So the cardinality of frequency = j is
빈도> = k의 경우, 빈도의 유니온 도달 범위는 다음 교차점에서 발생한다:For frequencies >= k, the union reach of the frequencies occurs at the intersection of:
, ,
, , , ,
…,… ,
, …, , , = . , … , , , = .
, …, , , = . , … , , , = .
의 경우, 추가로 다음과 같이 분해된다: For , it is further decomposed as follows:
모든 조각별 카디널리티 추정치가 주어지면, k+ 도달 범위는 합산, 결합 또는 계산될 수 있다. 둘 이상의 퍼블리셔로 확장하는 것은 스케치를 병합한 다음 여기에서 전술한 바와 같이 제3 식별자 서버(예를 들어, 데이터 프로세싱 시스템(105))로 중복 제거를 수행하는 것을 포함할 수 있다. 병합 작업은 다음과 같다: Given all the piecewise cardinality estimates, the k+ coverage can be summed, combined or computed. Extending to more than one publisher may include merging the sketches and then performing deduplication with a third identifier server (eg, data processing system 105) as described herein above. The merge operation is as follows:
, for j=1:k-1. , for j=1:k-1.
둘 이상의 스케치를 병합하는 다른 방법 중 하나 이상은 Chow-Liu 모델에 기초할 수 있다. 이 방법은 예를 들어 애그리게이터 컴퓨팅 디바이스(410) 또는 작업자 컴퓨팅 디바이스(405)를 포함하여 여기에 설명된 임의의 컴퓨팅 디바이스에 의해 구현될 수 있다. 본 명세서에서 사용된 바와 같이, 함수 R은 도달 범위를 나타내고 f1,…, fs는 각 데이터 프로세싱 시스템(105)에서 각 식별자의 빈도를 나타낸다. 이와 같이:One or more of the other methods of merging two or more sketches may be based on the Chow-Liu model. This method may be implemented by any computing device described herein, including, for example, aggregator computing device 410 or worker computing device 405 . As used herein, function R represents reach and f1,... , fs represents the frequency of each identifier in each data processing system 105. like this:
예를 들면: For example:
. .
R(f1 = j1, f2 = j2,…, fs = js) 형식의 각 항은 Chow-Liu 모델을 사용하여 추정될 수 있다:Each term of the form R(f1 = j1, f2 = j2,..., fs = js) can be estimated using the Chow-Liu model:
, ,
which implies thatwhich implies that
이것은 식별자 서버 s 의 선형 트리 아래에 있는 Chow-Liu 모델일 수 있다. 한계 도달 거리와 양방향 교차점은 위의 방정식에 포함된다. 따라서 각 식별자 서버는 모든 식별자 및 속성(본 명세서에서 "id"라고도 함)을 로 알고 있고, 그들은 이들 ID의 것을 나타내는 암호화되거나 프로세싱된 데이터 구조를 전송할 수 있으며, 그 다음 여기에서 위와 아래에 설명된 추정기를 사용하여 방정식(1)의 모든 항을 얻을 수 있다. 임의의 의 경우, 를 가진 ID는 데이터 레코드(122)로부터 식별될 수 있다. 그러나, 각각의 데이터 프로세싱 시스템(105)은 빈도 = 0인 모든 ID를 알지 못할 수 있다. 데이터 프로세싱 시스템(105)은 데이터 레코드의 공통 목록을 공유하지 않을 수 있다. 데이터 프로세싱 시스템(105A)에 의해 유지되는 데이터 레코드(122)가 아닌 이러한 레코드는 데이터 프로세싱 시스템(105A)에서 빈도 = 0으로 할당되어야 하지만, 데이터 프로세싱 시스템(105A)은 이러한 ID를 나타내는 데이터를 유지하거나 가질 수 없다.This is the identifier server s can be a Chow-Liu model under the linear tree of Critical reach and intersection point in both directions are included in the above equation. Therefore, each identifier server All identifiers and attributes (also referred to herein as "id") , they can transmit encrypted or processed data structures representing those of these IDs, from which all terms of equation (1) can then be obtained using the estimators described herein above and below. random In the case of, An ID with a can be identified from data record 122. However, each data processing system 105 may not know all IDs with frequency = 0. The data processing systems 105 may not share a common list of data records. These records, other than data records 122 maintained by data processing system 105A, must be assigned with frequency = 0 in data processing system 105A, but data processing system 105A does not maintain data representing these IDs or can't have
이 문제는 에 유의하여 해결할 수 있다. 이 표현하는 데이터 구조가 획득될 수 있으므로 는 이면 추정될 수 있다.this problem It can be solved by paying attention to . Since the data structure representing this can be obtained Is can be estimated if
중에 0이 여러 개있는 경우, 0과 0이 아닌 j는 분리될 수 있다. 동안 라고 가정한다. 선형 트리의 Chow-Liu 모델은 If there are multiple 0s in , 0 and non-zero j can be separated. during Assume that Chow-Liu model of a linear tree silver
그리고 그 다음,and then,
이와 같이, 를 포함하는 용어는 까지 를 표현하는 데이터 구조를 사용하여 계산될 수 있고, 이들은 첫 번째를 제외한 모든 용어이다. 제1 용어,는, 두 세트의 중복 제거 과이다. 이 두 세트를 중복 제거하기 위해, 데이터 프로세싱 시스템(105)에 의해 전송된 데이터 구조 는 데이터 프로세싱 시스템(105)으로부터 직접 도출된다. 세트을 나타내는 데이터 구조는 반면에, 까지 를 나타내는 데이터 구조를 병합하여 추정될 수 있다. 이와 같이, 이 추정될 수 있다. 이 방법의 비제한적인 구현예 및 예시는 다음 예시적 의사 코드에서 설명된다.like this, terms that include until can be computed using a data structure representing , and these are all terms except the first. first term, , remove duplicates in both sets class am. Data structure sent by data processing system 105 to de-dupe these two sets is the data processing system 105 is derived directly from data structure representing a set On the other hand, until It can be estimated by merging data structures representing like this, this can be estimated. Non-limiting implementations and examples of this method are described in the following example pseudo code.
freq_combinations = FindCombinations(frequency_target, num_servers)freq_combinations = FindCombinations(frequency_target, num_servers)
# Using our notations, this is to find all combinations of j1, j2, ..., js# Using our notations, this is to find all combinations of j1, j2, ..., js
target_freq_reach = 0target_freq_reach = 0
for freq_combination in freq_combinations:for freq_combinations in freq_combinations:
zero_servers, nonzeros_servers = FindZeros(freq_combination)zero_servers, nonzeros_servers = FindZeros(freq_combination)
# zero_servers and non_zeros_servers are indices lists of the servers with j=0 and j>0 respectively# zero_servers and non_zeros_servers are indices lists of the servers with j=0 and j>0 respectively
data_structure_to_dedup_with = np.zeros(num_buckets)data_structure_to_dedup_with = np.zeros(num_buckets)
for server_index in zero_servers:for server_index in zero_servers:
data_structure_to_dedup_with = Merge(data_structure_to_dedup_with, GetOnePlusData_structure(server_index))data_structure_to_dedup_with = Merge(data_structure_to_dedup_with, GetOnePlusData_structure(server_index))
# Then dedup with the first pub with non-zero frequency# Then dedup with the first pub with non-zero frequency
first_nonzero_server_index = nonzeros_servers[0]first_nonzero_server_index = nonzeros_servers[0]
data_structure_firstnon_zero_server = GetData_structureAtCertainFreq(data_structure_firstnon_zero_server = GetData_structureAtCertainFreq(
first_nonzero_server_index, freq_combination)first_nonzero_server_index, freq_combination)
intersection = sum(Data_structure_first_nonzero_server) - EstimateOverlap(data_structure_to_dedup_with, data_structure_first_non_zero_server)intersection = sum(Data_structure_first_nonzero_server) - EstimateOverlap(data_structure_to_dedup_with, data_structure_first_non_zero_server)
# Then multiply R(fr+2=jr+2, fr+1=jr+1) / R(fr+1=jr+1) up to R(fs=js, fs-1=js-1) / R( fs-1=js-1) in equation (2)# Then multiply R(fr+2=jr+2, fr+1=jr+1) / R(fr+1=jr+1) up to R(fs=js, fs-1=js-1) / R (fs-1=js-1) in equation (2)
for server_index in remaining_nonzero_servers:for server_index in remaining_nonzero_servers:
overlap_rate = EstimateOverlap(previous_data_structure, current_data_structure)overlap_rate = EstimateOverlap(previous_data_structure, current_data_structure)
intersection *= overlap_rateintersection *= overlap_rate
target_freq_reach += intersectiontarget_freq_reach += intersection
return target_freq_reachreturn target_freq_reach
# Final estimate of R(f1+f2++fs=k)# Final estimate of R(f1+f2++fs=k)
예를 들어, 차등 프라이버시는 본 명세서에서 위에서 설명된 차등 프라이버시 기반 방법 중 하나를 사용하여 도입될 수 있다. 예를 들어, 각각의 데이터 프로세싱 시스템(105)은 본 명세서에서 전술한 바와 같이 각각의 데이터 프로세싱 시스템(105)에 의해 전송된 k + 1 스케치에 차등적 비공개 노이즈를 추가할 수 있다.For example, Differential Privacy may be introduced using one of the Differential Privacy-based methods described herein above. For example, each data processing system 105 may add differential private noise to the k + 1 sketch transmitted by each data processing system 105 as described herein above.
본 발명의 구현예들과 본 명세서에 기술된 동작들은 본 발명에 개시된 구조들 및 그들의 구조적 균등물들 또는 그들 중 하나 이상의 조합들을 포함하는 디지털 전자회로 또는 컴퓨터 소프트웨어, 펌웨어 또는 하드웨어에서 구현될 수 있다. 본 명세서에 기술된 본 발명의 구현예들은 하나 이상의 컴퓨터 프로그램들 즉, 데이터 프로세싱 장치에 의해 실행 또는 데이터 프로세싱 장치의 동작을 제어하기 위한 컴퓨터 저장 매체에 인코딩된 컴퓨터 프로그램 명령어들의 하나 이상의 컴포넌트들로서 구현될 수 있다. 프로그램 명령어들은 데이터 프로세싱 장치에 의해 실행하기 위한 적절한 수신기 장치에 전송하기 위한 정보를 인코딩하기 위해 생성된 인공적으로 생성된 전파된 신호 즉, 기계-생성 전기, 광학 또는 전자기적 신호에 인코딩될 수 있다. 컴퓨터 저장 매체는 컴퓨터 판독가능 저장 디바이스, 컴퓨터 판독가능 저장 기판, 랜덤 또는 직렬 액세스 메모리 어레이 또는 디바이스 또는 그들의 임의의 조합이거나 그에 포함될 수 있다. 또한, 컴퓨터 저장 매체는 전파된 신호가 아니지만, 컴퓨터 저장 매체는 인공적으로 생성된 전파된 신호에 인코딩된 컴퓨터 프로그램 명령어들의 소스 또는 목적지를 포함할 수 있다. 또한, 컴퓨터 저장 매체는 하나 이상의 별개의 물리적 컴포넌트 또는 매체(예를 들면, 다수의 CD, 디스크, 플래시 메모리, 솔리드 스테이트 메모리 또는 다른 저장 디바이스)이거나 또는 그에 포함될 수 있다.Implementations of the present invention and operations described herein may be implemented in digital electronic circuitry or computer software, firmware or hardware that includes the structures disclosed herein and their structural equivalents, or combinations of one or more of them. Implementations of the invention described herein may be implemented as one or more components of one or more computer programs, i.e., computer program instructions executed by a data processing apparatus or encoded on a computer storage medium for controlling the operation of a data processing apparatus. can Program instructions may be encoded in an artificially generated propagated signal, ie a machine-generated electrical, optical or electromagnetic signal, generated to encode information for transmission to an appropriate receiver device for execution by a data processing device. A computer storage medium may be or be included in a computer readable storage device, a computer readable storage substrate, a random or serial access memory array or device, or any combination thereof. Further, while a computer storage medium is not a propagated signal, a computer storage medium may include a source or destination of computer program instructions encoded in an artificially generated propagated signal. Also, a computer storage medium can be or included in one or more separate physical components or media (eg, multiple CDs, disks, flash memory, solid state memory, or other storage device).
본 명세서에 개시된 구성은 랩톱 컴퓨터 또는 다른 개인용 컴퓨터, 스마트폰, 다른 모바일폰, 핸드 헬드 컴퓨터, 태블릿 PC 또는 기타 컴퓨팅 디바이스에서 구현될 수 있다. The configurations disclosed herein may be implemented in a laptop computer or other personal computer, smart phone, other mobile phone, handheld computer, tablet PC or other computing device.
본 명세서에 기술된 동작들은 하나 이상의 컴퓨터 판독가능 저장 디바이스들에 저장된 또는 다른 소스들로부터 수신된 데이터에서 데이터 프로세싱 장치에 의해 수행되는 동작들로서 구현될 수 있다. Operations described herein may be implemented as operations performed by a data processing apparatus on data stored on one or more computer readable storage devices or received from other sources.
용어 "데이터 프로세싱 장치", "데이터 프로세싱 시스템", "사용자 디바이스", "클라이언트 디바이스", "작업자 디바이스", "작업자", "작업자 컴퓨팅 디바이스", "퍼블리셔" 또는 “컴퓨팅 디바이스"는 예시로서 프로그래머블 프로세서, 컴퓨터, 시스템 온 칩 또는 앞서 언급된 것들 중 다수의 것들 또는 조합들을 포함하는 데이터를 프로세싱하기 위한 모든 종류의 장치, 디바이스들 및 기계들을 포함한다. 상기 장치는 특수 목적 논리 회로, 예를 들어 FPGA(field programmable gate array) 또는 ASIC(application specific integrated circuit)을 포함할 수 있다. 또한, 장치는 하드웨어 이외에 문제의 컴퓨터 프로그램에 대한 실행 환경을 생성하는 코드, 예를 들어 프로세서 펌웨어, 프로토콜 스택, 데이터베이스 관리 시스템, 운영 체제, 크로스-플랫폼 런타임(cross-platform runtime) 실행 환경, 가상 머신 또는 그들의 임의의 조합을 구성하는 코드를 포함할 수 있다. 장치 및 실행 환경은 웹 서비스들, 분산 컴퓨팅 및 그리드 컴퓨팅 인프라와 같은 다양한 컴퓨팅 모델 인프라를 실현할 수 있다.The terms "data processing device", "data processing system", "user device", "client device", "worker device", "worker", "worker computing device", "publisher", or "computing device" are by way of example programmable All kinds of apparatus, devices and machines for processing data, including a processor, computer, system on a chip or any number or combination of any of the foregoing The apparatus includes a special purpose logic circuit, e.g. It may include a field programmable gate array (FPGA) or an application specific integrated circuit (ASIC) In addition to hardware, the device may include code that creates an execution environment for the computer program in question, such as processor firmware, protocol stacks, databases may include code constituting a management system, an operating system, a cross-platform runtime execution environment, a virtual machine, or any combination thereof Device and execution environment may include web services, distributed computing and grid computing Various computing model infrastructures such as infrastructure can be realized.
컴퓨터 프로그램(프로그램, 소프트웨어, 소프트웨어 애플리케이션, 스크립트 또는 코드로도 알려져 있음)은 컴파일된 또는 인터프리트된 언어들, 선언적, 기능적 또는 절차적 언어들을 포함하는 임의의 형태의 프로그래밍 언어로 작성될 수 있으며, 독립 실행형 프로그램으로서 또는 모듈, 컴포넌트, 서브루틴, 객체로서 또는 컴퓨팅 환경에서 사용하기에 적합한 기타 단위를 포함하는 임의의 형태로 배포될 수 있다. 컴퓨터 프로그램은 파일 시스템의 파일에 대응할 수 있지만, 반드시 그런 것은 아니다. 프로그램은 다른 프로그램들이나 데이터, 예를 들어, 마크업 언어 문서에 저장된 하나 이상의 스크립트들을 가지는 파일의 부분에, 문제되는 프로그램 전용 단일의 파일에 또는 다수의 조정된 파일들, 예를 들어, 하나 이상의 모듈들, 서브프로그램 또는 코드의 일부를 저장하는 파일들에 저장될 수 있다. 컴퓨터 프로그램은 하나의 컴퓨터 또는 하나의 사이트에 위치되어 있거나 다수의 사이트들에 걸쳐서 분산되어 있고 통신 네트워크에 의해 상호연결된 다수의 컴퓨터들에서 실행되도록 배포될 수 있다. A computer program (also known as a program, software, software application, script, or code) may be written in any form of programming language, including compiled or interpreted languages, declarative, functional, or procedural languages; may be distributed as a stand-alone program or in any form comprising modules, components, subroutines, objects, or other units suitable for use in a computing environment. A computer program may, but not necessarily, correspond to a file in a file system. A program may be part of a file with other programs or data, for example one or more scripts stored in a markup language document, in a single file dedicated to the program in question or in a number of coordinated files, for example one or more modules. files, subprograms, or files that store portions of code. A computer program may be distributed to be executed on one computer or on multiple computers located at one site or distributed across multiple sites and interconnected by a communication network.
본 명세서에 기술된 프로세스들 및 논리 흐름들은 입력 데이터를 동작하고 출력을 생성함으로써 액션들을 수행하기 위해 하나 이상의 컴퓨터 프로그램들을 실행하는 하나 이상의 프로그래머블 프로세서들에 의해 수행될 수 있다. 프로세스들 및 논리 흐름들은 또한 FPGA 또는 ASIC와 같은 특수 목적 논리 회로에 의해 수행될 수 있고, 장치는 또한 특수 목적 논리 회로로서 구현될 수 있다.The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform actions by operating on input data and generating output. The processes and logic flows can also be performed by a special purpose logic circuit such as an FPGA or ASIC, and the apparatus can also be implemented as a special purpose logic circuit.
컴퓨터 프로그램의 실행에 적절한 프로세서들은, 예시로서, 범용 및 전용 마이크로프로세서들과 임의의 종류의 디지털 컴퓨터의 임의의 하나 이상의 프로세서들을 포함한다. 일반적으로, 프로세서는 읽기-전용 메모리 또는 랜덤 액세스 메모리 또는 둘 모두로부터 명령어들 및 데이터를 수신할 것이다. 컴퓨터의 엘리먼트들은 명령어들에 따라 액션들을 수행하기 위한 프로세서 및 명령어들 및 데이터를 저장하기 위한 하나 이상의 메모리 디바이스들을 포함한다. 일반적으로, 컴퓨터는 데이터를 저장하기 위한 하나 이상의 대형 저장 디바이스 예를 들면, 자기적, 자기-광학 디스크, 플래시 메모리, 솔리드 스테이트 드라이브 또는 광학적 디스크 또한 포함하거나 또는 그로부터 데이터를 수신하거나 그에 데이터를 전송하기 위해 동작적으로 결합될 수 있다. 그러나, 컴퓨터는 상기 디바이스들을 반드시 가져야하는 것은 아니다. 추가로, 컴퓨터는 다른 디바이스, 예를 들어, 모바일 전화, 개인 휴대 정보 단말기(PDA), 모바일 오디오 또는 비디오 플레이어, 게임 콘솔, GPS 수신기 또는 휴대용 저장 디바이스 예를 들어, 범용 직렬 버스(USB) 플래시 드라이브에 내장될 수 있다. 컴퓨터 프로그램 명령어들 및 데이터를 저장하기에 적합한 디바이스들은 예를 들어, EPROM, EEPROM 및 플래시 메모리 디바이스들과 같은 반도체 메모리 디바이스들; 예를 들어, 내부 하드 디스크들 또는 이동식 디스크들과 같은 자기 디스크들; 및 CD-ROM 및 DVD-ROM 디스크들을 포함하는 모든 형태의 비휘발성 메모리, 매체 및 메모리 디바이스들을 포함한다. 프로세서 및 메모리는 특수 목적 논리 회로에 의해 보충되거나 그 안에 통합될 수 있다.Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from read-only memory or random access memory or both. Elements of a computer include a processor for performing actions in accordance with the instructions and one or more memory devices for storing instructions and data. Generally, a computer also includes one or more mass storage devices for storing data, such as magnetic, magneto-optical disks, flash memory, solid state drives, or optical disks, or for receiving data from or transferring data thereto. can be operatively coupled to However, a computer does not necessarily have these devices. Additionally, the computer may be another device such as a mobile phone, personal digital assistant (PDA), mobile audio or video player, game console, GPS receiver or portable storage device such as a universal serial bus (USB) flash drive. can be embedded in Devices suitable for storing computer program instructions and data include, for example, semiconductor memory devices such as EPROM, EEPROM and flash memory devices; magnetic disks such as, for example, internal hard disks or removable disks; and all forms of non-volatile memory, media and memory devices including CD-ROM and DVD-ROM disks. The processor and memory may be supplemented by or integrated into special purpose logic circuitry.
사용자와의 인터렉션을 제공하기 위해, 본 명세서에서 기술된 본 발명의 구현예들은 사용자에게 정보를 디스플레이하기 위해 예를 들어, CRT(cathode ray tube) 또는 LCD(liquid crystal display) 모니터와 같은 디스플레이 디바이스 및 사용자가 컴퓨터에 입력을 제공할 수 있는 키보드 및 포인팅 디바이스 예를 들어, 마우스 또는 트랙볼을 갖는 컴퓨터에서 구현될 수 있다. 다른 종류의 디바이스들도 사용자와의 인터렉션을 제공하는데 사용될 수 있다. 예를 들어, 사용자에게 제공되는 피드백은 시각 피드백, 청각 피드백 또는 촉각 피드백과 같은 임의의 형태의 감각적 피드백일 포함할 수 있고, 사용자로부터의 입력은 음향, 음성 또는 촉각 입력을 포함하는 임의의 형태로 수신될 수 있다. 추가로, 컴퓨터는 사용자에 의해 사용되는 디바이스에 문서를 송수신함으로써 예를 들어, 웹브라우저로부터 수신된 요청에 응답하여, 사용자의 사용자 디바이스상의 웹브라우저에 웹페이지를 전송함으로써 사용자와 인터렉션할 수 있다.To provide interaction with a user, embodiments of the invention described herein may include a display device, such as, for example, a cathode ray tube (CRT) or liquid crystal display (LCD) monitor, to display information to a user, and It can be implemented in a computer with a keyboard and pointing device, such as a mouse or trackball, through which a user can provide input to the computer. Other types of devices may also be used to provide interaction with the user. For example, the feedback provided to the user may include any form of sensory feedback such as visual feedback, auditory feedback, or tactile feedback, and the input from the user may be in any form including acoustic, audio, or tactile input. can be received Additionally, the computer may interact with the user by sending and receiving documents to and from the device being used by the user, for example by sending webpages to the webbrowser on the user's user device, in response to a request received from the webbrowser.
본 명세서에서 기술된 발명의 구현예는 예를 들어 데이터 서버와 같은 백엔드 컴포넌트, 애플리케이션 서버와 같은 미들웨어 컴포넌트 또는 그래픽 사용자 인터페이스를 가지는 사용자 컴퓨터 또는 사용자가 본 명세서에 기술된 본 발명의 구현예와 인터렉션할 수 있는 웹 브라우저와 같은 프론트엔드 컴포넌트 또는 하나 이상의 상기 백엔드, 미들웨어 또는 프론트엔드 컴포넌트들의 임의의 조합을 포함하는 컴퓨팅 시스템에서 구현될 수 있다. 시스템의 컴포넌트들은 디지털 데이터 통신의 임의의 형태 또는 매체, 예를 들어 통신 네트워크에 의해 상호연결될 수 있다. 통신 네트워크들의 예는 근거리 통신망("LAN") 및 광역 통신망("WAN"), 인터-네트워크(예를 들어, 인터넷) 및 피어투피어 네트워크(예를 들어, 애드혹 피어투피어 네트워크)를 포함한다.An implementation of the invention described herein may be a user computer having, for example, a backend component such as a data server, a middleware component such as an application server, or a graphical user interface, or a user interacting with an implementation of the invention described herein. A front-end component such as a web browser that can be implemented in a computing system that includes a front-end component, such as a web browser, or any combination of one or more of the foregoing back-end, middleware, or front-end components. Components of the system may be interconnected by any form or medium of digital data communication, for example a communication network. Examples of communication networks include local area networks ("LAN") and wide area networks ("WAN"), inter-networks (eg, Internet) and peer-to-peer networks (eg, ad hoc peer-to-peer networks). .
데이터 프로세싱 시스템(600)과 같은 컴퓨팅 시스템은 클라이언트 및 서버를 포함할 수 있다. 예를 들어, 데이터 프로세싱 시스템(105)은 적어도 하나의 데이터 센터 또는 서버 팜에 위치된 복수의 서버들 포함할 수 있다. 사용자와 서버는 일반적으로 서로 멀리 떨어져 있으며, 일반적으로 통신 네트워크를 통해 인터렉션한다. 사용자와 서버의 관계는 각각의 컴퓨터에서 실행되고 서로 사용자-서버 관계를 갖는 컴퓨터 프로그램에 의해 발생한다. 일부 구현예에서, 서버는(예를 들어, 사용자 디바이스와 인터렉션하는 사용자에게 데이터를 디스플레이하고 사용자 입력을 수신하기 위해) 사용자 디바이스에 데이터(예를 들어, HTML 페이지)를 전송한다. 사용자 디바이스에서 생성된 데이터(예를 들어, 사용자 인터렉션의 결과)는 서버에서 사용자 디바이스로부터 수신될 수 있다.A computing system such as data processing system 600 may include a client and a server. For example, data processing system 105 may include a plurality of servers located in at least one data center or server farm. Users and servers are generally remote from each other and typically interact through a communication network. The relationship between user and server arises by means of computer programs running on the respective computers and having a user-server relationship with each other. In some implementations, the server sends data (eg, HTML pages) to the user device (eg, to display data and receive user input to a user interacting with the user device). Data generated by the user device (eg, a result of user interaction) may be received from the user device at the server.
본 명세서는 많은 특정 구현 세부내용을 포함하지만, 이들은 본 구현예의 범위 또는 청구될 수 있는 범위에 대한 제한으로서 해석되어서는 안되며, 오히려 본 명세서에 기술된 시스템 및 방법의 특정한 구현예에 특정한 구성들에 대한 설명으로 해석되어야 한다. 별개의 구현예의 맥락에서 본 명세서에서 기술되는 일정 구성들은 또한 단일 구현예에서 조합하여 구현될 수 있다. 반대로, 단일 구현예의 맥락에서 기술된 다양한 구성들은 또한 다수의 구현예에서 개별적으로 또는 임의의 적합한 서브 조합으로 구현될 수 있다. 게다가, 구성들은 일정 조합으로 동작하고 심지어 초기적으로 그렇게 청구되는 것으로서 상기에서 기술될 수 있지만, 청구된 조합으로부터의 하나 이상의 구성들은 조합으로부터 제거될 수 있고, 청구된 조합은 서브 조합 또는 서브 조합의 변형으로 안내될 수 있다.Although this specification contains many specific implementation details, they should not be construed as limitations on the scope of the implementations or on the scope of what may be claimed, but rather are intended as configurations specific to particular implementations of the systems and methods described herein. should be interpreted as an explanation. Certain features that are described in this specification in the context of separate implementations can also be implemented in combination in a single implementation. Conversely, various features that are described in the context of a single implementation can also be implemented in multiple implementations individually or in any suitable subcombination. Moreover, while elements operate in certain combinations and may even be described above as initially so claimed, one or more elements from a claimed combination may be removed from the combination, and the claimed combination may be a sub-combination or sub-combination. Can be guided by transformation.
유사하게, 동작들이 특정한 순서로 도면에서 도시되었지만, 이는 상기 동작들이 도시된 특정한 순서로 또는 시계열적 순서로 수행되어야 함을 요구하는 것으로서 또는 모든 도시된 동작들이 수행되어야 하는 것으로 이해되어서는 안된다. 일부 경우에, 청구항들에서 기재된 액션들은 상이한 순서로 수행되고 여전히 원하는 결과들을 달성할 수 있다. 추가로, 첨부 도면들에 도시된 프로세스들은 원하는 결과들을 달성하기 위해 특정한 도시된 순서, 또는 시계열적 순서를 반드시 필요로 하지 않는다.Similarly, while actions are depicted in the drawings in a particular order, this should not be construed as requiring that the actions be performed in the specific order depicted or in a chronological order, or that all depicted actions must be performed. In some cases, the actions recited in the claims can be performed in a different order and still achieve desired results. Additionally, the processes depicted in the accompanying figures do not necessarily require a specific depicted order, or chronological order, to achieve desired results.
특정 환경에서, 멀티태스킹과 병렬 프로세싱은 이점이 있다. 게다가, 상기 기술된 구현예에서 다양한 시스템 컴포넌트들의 분리는 모든 구현예에서 그러한 분리가 필요한 것으로서 이해되어서는 안되며, 일반적으로 기술된 프로그램 컴포넌트들 및 시스템들은 단일의 소프트웨어 제품에 함께 통합되거나 다수의 소프트웨어 제품들에 패키징될 수 있다고 이해되어야 한다. 예를 들면, 데이터 프로세싱 시스템(105)은 단일 모듈, 하나 이상의 프로세싱 모듈을 갖는 논리 디바이스, 하나 이상의 서버 또는 클라우드 컴퓨팅 환경의 일부일 수 있다.In certain circumstances, multitasking and parallel processing are advantageous. Moreover, the separation of various system components in the implementations described above should not be understood as requiring such separation in all implementations; generally, the program components and systems described may be integrated together in a single software product or multiple software products. It should be understood that it can be packaged in fields. For example, data processing system 105 may be a single module, a logical device having one or more processing modules, one or more servers, or part of a cloud computing environment.
일부 예시적 구현 및 구현예들을 설명하였지만, 전술한 예는 예시적인 것이며 제한적인 것은 아니며 예시로서 제시되었다. 특히, 본 명세서에 제시된 많은 예들이 방법 동작들 또는 시스템 엘리먼트들의 특정 조합을 포함하지만, 그러한 동작들 및 엘리먼트들은 동일한 목적을 달성하기 위해 다른 방식으로 결합될 수 있다. 하나의 구현예와만 관련하여 논의된 동작, 엘리먼트 및 구성들은 다른 구현예들에서 유사한 역할로부터 배제되지 않는다.While some example implementations and implementations have been described, the foregoing examples have been presented as illustrative and non-limiting examples. In particular, although many of the examples presented herein include specific combinations of method acts or system elements, such acts and elements may be combined in other ways to achieve the same purpose. Acts, elements, and configurations discussed in connection with only one implementation are not excluded from a similar role in other implementations.
본 명세서에서 사용된 문구 및 용어는 설명의 목적을 위한 것이며 제한적인 것으로 간주되어서는 안된다. "포함(including)" "포함(comprising)" "포함(having)" "포함(containing)" "포함(involving)" "포함(characterized by)" "포함(characterized in that)” 및 본 명세서에서 이들의 변형들은 열거된 아이템들, 그 균등물 및 추가 아이템들뿐만 아니라 배타적으로 열거된 아이템들로 구성되는 대안적 구현예들을 포함하는 것을 의미한다. 일 구현예에서, 본 명세서에 기술된 시스템 및 방법은 설명된 엘리먼트들, 동작들 또는 컴포넌트들 중 하나, 하나 이상의 조합 또는 전부로 구성된다.The phrases and terminology used herein are for the purpose of description and should not be regarded as limiting. “including” “comprising” “having” “containing” “involving” “characterized by” “characterized in that” and herein Variations of are meant to include the recited items, their equivalents and additional items, as well as alternative implementations consisting exclusively of the recited items In one embodiment, the system and method described herein consists of one, a combination of one or more, or all of the described elements, operations or components.
단수형으로 본 명세서에서 언급된 시스템 및 방법의 구현 또는 엘리먼트에 관한 참조는 이들 엘리먼트들 복수형을 포함하는 구현예들을 포함할 수 있고, 복수형으로 본 명세서에서 언급된 임의의 구현예 또는 엘리먼트에 대한 임의의 참조는 단수형 엘리먼트를 포함하는 구현예들을 포함할 수 있다. 단수 또는 복수 형태의 참조는 현재 개시된 시스템 또는 방법, 그들의 컴포넌트들, 동작 또는 엘리먼트를 단수 또는 복수 구성으로 제한하려는 것이 아니다. 임의의 정보, 동작 또는 엘리먼트에 기초한 임의의 동작 또는 엘리먼트에 대한 참조는 해당 동작 또는 엘리먼트가 적어도 부분적으로 임의의 정보, 동작 또는 엘리먼트에 기초하는 구현예를 포함할 수 있다.References to implementations or elements of systems and methods referred to herein in the singular may include implementations including those elements in the plural, and any reference to any implementation or element referred to herein in the plural. References may include implementations that include the singular element. References in singular or plural form are not intended to limit the presently disclosed system or method, its components, acts or elements to singular or plural configurations. Reference to any operation or element based on any information, operation or element may include implementations in which the operation or element is based at least in part on the any information, operation or element.
본 명세서에 개시된 임의의 구현예는 임의의 다른 구현예와 결합될 수 있으며, "구현", "일부 구현", "대안적 구현", "다양한 구현", "하나의 구현” 등은 반드시 상호 배타적이지 않고, 구현예과 관련하여 기술된 특정한 구성, 구조 또는 특성이 적어도 하나의 구현예에 포함될 수 있음을 나타내는 것이다. 본 명세서에 사용된 용어들은 반드시 모두 동일한 구현예를 지칭하는 것은 아니다. 임의의 구현예는 본 명세서에 개시된 양태들 및 구현예들과 일관된 방식으로 임의의 다른 구현예와 포괄적으로 또는 배타적으로 결합될 수 있다.Any implementation disclosed herein may be combined with any other implementation, and terms such as “an implementation,” “some implementations,” “alternative implementations,” “various implementations,” “one implementation,” etc. are necessarily mutually exclusive. It is intended to indicate that a particular configuration, structure or characteristic described in connection with an embodiment may be included in at least one embodiment.Terms used herein do not necessarily all refer to the same embodiment. Any implementation An example may be combined, inclusively or exclusively, with any other implementation in a manner consistent with the aspects and implementations disclosed herein.
"또는"에 대한 참조는 "또는"을 사용하여 기술된 임의의 용어가 기술된 용어들 중 하나, 하나 이상 및 전부를 나타낼 수 있도록 포괄적인 것으로 해석될 수 있다.References to “or” may be construed as inclusive such that any term stated using “or” may refer to one, more than one, and all of the terms described.
도면, 상세한 설명 또는 청구범위의 기술적 구성에 참조 부호가 있는 경우, 상기 참조 부호는 도면, 상세한 설명 및 청구 범위의 명료성을 증가시키는 목적으로만으로 포함되었다. 따라서, 참조 부호들 또는 그것들의 부재는 임의의 청구항 엘리먼트들의 범위에 대해 어떠한 제한 효과도 가지지 않는다.Where reference signs appear in the drawings, description, or technical structure of the claims, the reference signs are included solely for the purpose of increasing the clarity of the drawings, description, and claims. Thus, reference signs or their absence do not have any limiting effect on the scope of any claim elements.
본 명세서에 기술된 시스템 및 방법은 그 특성을 벗어나지 않고 다른 특정 형태로 구체화될 수 있다. 본 명세서에서 제공된 예시들은 정보 리소스의 콘텐츠의 디스플레이를 제어하는 것에 관한 것이지만, 본 명세서에 기술된 시스템 및 방법은 다른 환경에 적용되는 것을 포함할 수 있다. 전술한 구현예들은 기술된 시스템 및 방법을 제한하는 것이라기 보다는 예시적인 것이다. 따라서, 본 명세서에 기술된 시스템 및 방법의 범위는 상술한 설명보다는 첨부된 청구범위에 의해 표시되며, 청구범위의 의미 및 범위 내에서의 변경들도 그 안에 포함된다.The systems and methods described herein may be embodied in other specific forms without departing from their characteristics. Although the examples provided herein relate to controlling the display of the content of an information resource, the systems and methods described herein may include applications in other environments. The foregoing implementations are illustrative rather than limiting of the described systems and methods. Accordingly, the scope of the systems and methods described herein is indicated by the appended claims rather than the foregoing description, and changes within the meaning and scope of the claims are embraced therein.
전술한 시스템 및 방법은 하나 이상의 제조물, 예를 들어 컴퓨터 판독가능 매체 상에 또는 기록된 하나 이상의 컴퓨터 프로그램에서 명령어로서 제공될 수 있음을 이해해야 한다. 제조물은 플로피 디스크, 하드 디스크, CD-ROM, 플래시 메모리 카드, PROM, RAM, ROM 또는 자기 테이프일 수 있다. 일반적으로 컴퓨터 프로그램은 LISP, Perl, Python, C, C ++, C #, PROLOG와 같은 프로그래밍 언어 또는 JAVA와 같은 모든 바이트 코드 언어로 구현될 수 있다. 소프트웨어 프로그램은 객체 코드로서 하나 이상의 제조물에 저장될 수 있다.It should be understood that the systems and methods described above may be provided as instructions in one or more computer programs recorded or on one or more articles of manufacture, eg, computer readable media. The article of manufacture may be a floppy disk, hard disk, CD-ROM, flash memory card, PROM, RAM, ROM or magnetic tape. In general, computer programs can be implemented in any programming language such as LISP, Perl, Python, C, C++, C#, PROLOG, or any bytecode language such as JAVA. A software program may be stored in one or more products as object code.
방법 및 시스템의 특정 실시예를 설명하였지만, 본 개시 내용의 개념을 포함하는 다른 실시예가 사용될 수 있다는 것이 이제 통상의 기술자에게 명백할 것이다. 따라서, 본 개시는 특정 실시예로 제한되어서는 안되며, 오히려 다음 청구 범위의 사상 및 범위에 의해서만 제한되어야 한다.Having described specific embodiments of the method and system, it will now be apparent to those skilled in the art that other embodiments incorporating the concepts of the present disclosure may be used. Accordingly, the present disclosure should not be limited to the specific embodiments, but rather only by the spirit and scope of the following claims.
Claims (20)
하나 이상의 프로세서 및 메모리를 포함하는 데이터 프로세싱 시스템에 의해, 데이터베이스에서, 디바이스 식별자 세트를 유지하는 단계, 디바이스 식별자 세트 각각은 디바이스 속성을 포함하며;
상기 데이터 프로세싱 시스템에 의해, 상기 디바이스 식별자 세트 및 해시 함수를 사용하여 데이터 구조를 생성하는 단계;
상기 데이터 프로세싱 시스템에 의해, 상기 데이터 구조를 암호화하여 암호화된 데이터 구조를 생성하는 단계, 상기 암호화된 데이터 구조는 제2 암호화된 데이터 구조와 결합될 수 있으며;
상기 데이터 프로세싱 시스템에 의해, 상기 암호화된 데이터 구조를 작업자 컴퓨팅 디바이스로 전송하는 단계를 포함하는, 방법.A method of generating an encrypted data structure representing a set of identifiers having attributes that satisfy target criteria for secure and computationally efficient transmission, comprising:
maintaining, by a data processing system comprising one or more processors and memory, a set of device identifiers in a database, each set of device identifiers including device attributes;
generating, by the data processing system, a data structure using the device identifier set and a hash function;
encrypting, by the data processing system, the data structure to create an encrypted data structure, the encrypted data structure being capable of being combined with a second encrypted data structure;
transmitting, by the data processing system, the encrypted data structure to a worker computing device.
상기 데이터 프로세싱 시스템에 의해, 제1 디바이스 속성을 포함하는 제1 디바이스 식별자를 수신하는 단계; 및
상기 데이터 프로세싱 시스템에 의해, 상기 제1 디바이스 속성을 포함하는 제1 디바이스 식별자를 상기 디바이스 식별자 세트의 멤버로서 저장하는 단계를 더 포함하는, 방법.The method of claim 1,
receiving, by the data processing system, a first device identifier comprising a first device attribute; and
storing, by the data processing system, a first device identifier comprising the first device attribute as a member of the device identifier set.
상기 데이터 프로세싱 시스템에 의해, 각각의 복수의 카운터 레지스터에 대응하는 복수의 좌표를 포함하는 벡터 데이터 구조를 생성하는 단계를 포함하며, 상기 벡터 데이터 구조는 상기 데이터 구조인, 방법.The method of claim 1 , wherein the hash function is a plurality of hash functions, and creating the data structure comprises:
generating, by the data processing system, a vector data structure comprising a plurality of coordinates corresponding to each of the plurality of counter registers, the vector data structure being the data structure.
상기 복수의 해시 함수를 사용하여 상기 벡터 데이터 구조의 상기 각각의 복수의 카운터 레지스터의 카운터 레지스터를 업데이트하는 단계를 더 포함하는, 방법.5. The method of claim 4, wherein creating the data structure comprises:
updating a counter register of each of the plurality of counter registers of the vector data structure using the plurality of hash functions.
복수의 해시된 데이터 레코드 값을 생성하기 위해 상기 복수의 해시 함수 각각을 사용하여 상기 디바이스 식별자 세트의 디바이스 식별자를 해싱하는 단계를 더 포함하는, 방법.6. The method of claim 5 wherein updating a counter register of each of the plurality of counter registers comprises:
hashing a device identifier of the set of device identifiers using each of the plurality of hash functions to generate a plurality of hashed data record values.
상기 복수의 해시된 데이터 레코드 값으로부터 복수의 레지스터 식별자를 추출하는 단계를 더 포함하고, 상기 복수의 레지스터 식별자 각각은 상기 복수의 카운터 레지스터의 각각의 카운터 레지스터에 대응하는, 방법.7. The method of claim 6, wherein updating a counter register of each of the plurality of counter registers comprises:
extracting a plurality of register identifiers from the plurality of hashed data record values, each of the plurality of register identifiers corresponding to a respective counter register of the plurality of counter registers.
상기 데이터 프로세싱 시스템에 의해, 최소값 임계치를 만족하는 카운터 레지스터 세트를 식별하기 위해 상기 복수의 레지스터 식별자에 대응하는 상기 복수의 카운터 레지스터 각각에 액세스하는 단계; 및
상기 데이터 프로세싱 시스템에 의해, 상기 최소값 임계치를 만족하는 카운터 레지스터 세트 각각을 증가시키는 단계를 포함하는, 방법.9. The method of claim 8, wherein updating a counter register of each of the plurality of counter registers comprises:
accessing, by the data processing system, each of the plurality of counter registers corresponding to the plurality of register identifiers to identify a set of counter registers that satisfy a minimum value threshold; and
incrementing, by the data processing system, each set of counter registers that satisfy the minimum value threshold.
상기 데이터 프로세싱 시스템에 의해, 상기 해시 함수 및 상기 디바이스 식별자 세트의 디바이스 식별자를 사용하여 선택된 벡터를 선택하는 단계, 상기 선택된 벡터는 상기 제1 벡터 또는 상기 제2 벡터 중 하나이며; 및
상기 데이터 프로세싱 시스템에 의해, 상기 해시 함수 및 상기 디바이스 식별자 세트의 디바이스 식별자를 사용하여 상기 행렬 데이터 구조의 선택된 벡터의 좌표를 업데이트하는 단계를 포함하는, 방법.The method according to claim 1, wherein the data structure is a matrix data structure comprising a first vector and a second vector, and generating the data structure comprises:
selecting, by the data processing system, a selected vector using the hash function and a device identifier of the device identifier set, the selected vector being either the first vector or the second vector; and
updating, by the data processing system, the coordinates of the selected vector of the matrix data structure using the hash function and a device identifier of the device identifier set.
상기 데이터 프로세싱 시스템에 의해, 해시된 디바이스 식별자를 생성하기 위해 상기 디바이스 식별자 세트의 디바이스 식별자를 해싱하는 단계;
상기 데이터 프로세싱 시스템에 의해, 미리 결정된 비트 값을 만족하는 상기 해시된 디바이스 식별자의 최하위 비트의 수를 결정하는 단계; 및
상기 데이터 프로세싱 시스템에 의해, 상기 미리 결정된 비트 값을 만족하는 상기 해시된 디바이스 식별자의 상기 최하위 비트 수에 기초하여, 상기 제1 벡터를 선택된 벡터로서 또는 상기 제2 벡터를 선택된 벡터로서 선택하는 단계를 포함하는, 방법.The method of claim 11 , wherein the step of selecting the selected vector is:
hashing, by the data processing system, device identifiers of the device identifier set to generate a hashed device identifier;
determining, by the data processing system, the number of least significant bits of the hashed device identifier that satisfy a predetermined bit value; and
selecting, by the data processing system, the first vector as a selected vector or the second vector as a selected vector based on the number of least significant bits of the hashed device identifier that satisfy the predetermined bit value. Including, how.
상기 데이터 프로세싱 시스템에 의해, 카운터 레지스터 인덱스 값을 계산하기 위해 상기 해시된 디바이스 식별자에 대한 모듈러스 연산을 수행하는 단계; 및
상기 데이터 프로세싱 시스템에 의해, 상기 카운터 레지스터 인덱스 값을 사용하여 좌표를 선택하는 단계; 및
상기 데이터 프로세싱 시스템에 의해, 상기 카운터 레지스터 인덱스 값을 사용하여 선택된 좌표를 증가시키는 단계를 포함하는, 방법.13. The method of claim 12, wherein updating the coordinates of the selected vector of the matrix data structure comprises:
performing, by the data processing system, a modulus operation on the hashed device identifier to compute a counter register index value; and
selecting, by the data processing system, a coordinate using the counter register index value; and
incrementing, by the data processing system, a selected coordinate using the counter register index value.
하나 이상의 프로세서 및 메모리를 포함하는 데이터 프로세싱 시스템을 포함하며, 상기 데이터 프로세싱 시스템은:
데이터베이스에서, 디바이스 식별자 세트를 유지하고, 디바이스 식별자 세트 각각은 디바이스 속성을 포함하며;
상기 디바이스 식별자 세트 및 해시 함수를 사용하여 데이터 구조를 생성하고; 상기 데이터 구조를 암호화하여 암호화된 데이터 구조를 생성하고, 상기 암호화된 데이터 구조는 제2 암호화된 데이터 구조와 결합될 수 있으며; 상기 암호화된 데이터 구조를 작업자 컴퓨팅 디바이스로 전송하도록 구성되는 시스템.A system for generating an encrypted data structure representing a set of identifiers having attributes that satisfy target criteria for secure and computationally efficient transmission, comprising:
A data processing system comprising one or more processors and memory, the data processing system comprising:
In the database, a set of device identifiers is maintained, each set of device identifiers including device attributes;
create a data structure using the device identifier set and a hash function; encrypting the data structure to create an encrypted data structure, wherein the encrypted data structure can be combined with a second encrypted data structure; A system configured to transmit the encrypted data structure to a worker computing device.
제1 디바이스 속성을 포함하는 제1 디바이스 식별자를 수신하고; 그리고
상기 제1 디바이스 속성을 포함하는 제1 디바이스 식별자를 상기 디바이스 식별자 세트의 멤버로서 저장하도록 더 구성되는, 시스템.15. The method of claim 14, wherein the data processing system:
receive a first device identifier including a first device attribute; and
and store the first device identifier comprising the first device attribute as a member of the device identifier set.
각각의 복수의 카운터 레지스터에 대응하는 복수의 좌표를 포함하는 벡터 데이터 구조를 생성하도록 더 구성되고, 상기 벡터 데이터 구조는 상기 데이터 구조인, 시스템.15. The method of claim 14, wherein the hash function is a plurality of hash functions, and the data processing system comprises:
and generate a vector data structure comprising a plurality of coordinates corresponding to each of the plurality of counter registers, the vector data structure being the data structure.
상기 디바이스 속성을 포함하는 상기 디바이스 식별자 세트 각각에 대해, 상기 복수의 해시 함수를 사용하여 상기 벡터 데이터 구조의 상기 각각의 복수의 카운터 레지스터의 카운터 레지스터를 업데이트하도록 더 구성되는, 시스템.18. The method of claim 17, wherein the hash function is a plurality of hash functions, and the data processing system comprises:
and for each of the device identifier set that includes the device attribute, update a counter register of each of the plurality of counter registers of the vector data structure using the plurality of hash functions.
복수의 해시된 데이터 레코드 값을 생성하기 위해 상기 복수의 해시 함수 각각을 사용하여 상기 디바이스 식별자 세트의 디바이스 식별자를 해싱하고;
상기 복수의 해시된 데이터 레코드 값으로부터 복수의 레지스터 식별자를 추출하고, 상기 복수의 레지스터 식별자 각각은 상기 복수의 카운터 레지스터의 각각의 카운터 레지스터에 대응하며;
최소값 임계치를 만족하는 카운터 레지스터 세트를 식별하기 위해 상기 복수의 레지스터 식별자에 대응하는 상기 복수의 카운터 레지스터 각각에 액세스하고; 그리고
상기 최소값 임계치를 만족하는 카운터 레지스터 세트 각각을 증가시키도록 더 구성되는, 시스템.15. The method of claim 14, wherein the data processing system:
hashing device identifiers of the set of device identifiers using each of the plurality of hash functions to generate a plurality of hashed data record values;
extracting a plurality of register identifiers from the plurality of hashed data record values, each of the plurality of register identifiers corresponding to a respective counter register of the plurality of counter registers;
access each of the plurality of counter registers corresponding to the plurality of register identifiers to identify a set of counter registers that satisfy a minimum value threshold; and
and increment each set of counter registers that satisfy the minimum value threshold.
Applications Claiming Priority (10)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US202062977141P | 2020-02-14 | 2020-02-14 | |
US62/977,141 | 2020-02-14 | ||
US202062981960P | 2020-02-26 | 2020-02-26 | |
US62/981,960 | 2020-02-26 | ||
US202062987645P | 2020-03-10 | 2020-03-10 | |
US62/987,645 | 2020-03-10 | ||
US202063002138P | 2020-03-30 | 2020-03-30 | |
US63/002,138 | 2020-03-30 | ||
KR1020217011133A KR102569373B1 (en) | 2020-02-14 | 2020-07-28 | Securing multi-party reach and frequency estimation |
PCT/US2020/043894 WO2021162743A1 (en) | 2020-02-14 | 2020-07-28 | Secure multi-party reach and frequency estimation |
Related Parent Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
KR1020217011133A Division KR102569373B1 (en) | 2020-02-14 | 2020-07-28 | Securing multi-party reach and frequency estimation |
Publications (1)
Publication Number | Publication Date |
---|---|
KR20230124111A true KR20230124111A (en) | 2023-08-24 |
Family
ID=71944289
Family Applications (4)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
KR1020217011267A KR102371529B1 (en) | 2020-02-14 | 2020-07-07 | Securing multi-party reach and frequency estimation |
KR1020217011266A KR102371528B1 (en) | 2020-02-14 | 2020-07-07 | Securing multi-party reach and frequency estimation |
KR1020237027886A KR20230124111A (en) | 2020-02-14 | 2020-07-28 | Secure multi-party reach and frequency estimation |
KR1020217011133A KR102569373B1 (en) | 2020-02-14 | 2020-07-28 | Securing multi-party reach and frequency estimation |
Family Applications Before (2)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
KR1020217011267A KR102371529B1 (en) | 2020-02-14 | 2020-07-07 | Securing multi-party reach and frequency estimation |
KR1020217011266A KR102371528B1 (en) | 2020-02-14 | 2020-07-07 | Securing multi-party reach and frequency estimation |
Family Applications After (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
KR1020217011133A KR102569373B1 (en) | 2020-02-14 | 2020-07-28 | Securing multi-party reach and frequency estimation |
Country Status (6)
Country | Link |
---|---|
US (4) | US11784800B2 (en) |
EP (3) | EP3891922B1 (en) |
JP (3) | JP7121194B2 (en) |
KR (4) | KR102371529B1 (en) |
CN (3) | CN113557512B (en) |
WO (3) | WO2021162738A1 (en) |
Families Citing this family (27)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US11902259B2 (en) * | 2020-02-05 | 2024-02-13 | Google Llc | Pure differentially private algorithms for summation in the shuffled model |
US11676160B2 (en) | 2020-02-11 | 2023-06-13 | The Nielsen Company (Us), Llc | Methods and apparatus to estimate cardinality of users represented in arbitrarily distributed bloom filters |
US11722500B2 (en) * | 2020-04-01 | 2023-08-08 | Paypal, Inc. | Secure identity verification marketplace using hashed data and forward hashing search functions |
US11741068B2 (en) | 2020-06-30 | 2023-08-29 | The Nielsen Company (Us), Llc | Methods and apparatus to estimate cardinality of users represented across multiple bloom filter arrays |
US11550949B2 (en) * | 2020-07-21 | 2023-01-10 | Constella Intelligence, Inc. | Secure exchange of password presence data |
US11755545B2 (en) | 2020-07-31 | 2023-09-12 | The Nielsen Company (Us), Llc | Methods and apparatus to estimate audience measurement metrics based on users represented in bloom filter arrays |
US11496287B2 (en) | 2020-08-18 | 2022-11-08 | Seagate Technology Llc | Privacy preserving fully homomorphic encryption with circuit verification |
US11575501B2 (en) * | 2020-09-24 | 2023-02-07 | Seagate Technology Llc | Preserving aggregation using homomorphic encryption and trusted execution environment, secure against malicious aggregator |
US20220156783A1 (en) * | 2020-11-13 | 2022-05-19 | The Nielsen Company (Us), Llc | Methods and apparatus to estimate unique audience sizes across multiple intersecting platforms |
US11734290B1 (en) * | 2020-11-24 | 2023-08-22 | Amazon Technologies, Inc. | Computationally efficient cardinality-estimation techniques |
US20220247548A1 (en) * | 2021-02-01 | 2022-08-04 | Sap Se | Efficient distributed privacy-preserving computations |
US20220398220A1 (en) * | 2021-06-14 | 2022-12-15 | EMC IP Holding Company LLC | Systems and methods for physical capacity estimation of logical space units |
US11854030B2 (en) * | 2021-06-29 | 2023-12-26 | The Nielsen Company (Us), Llc | Methods and apparatus to estimate cardinality across multiple datasets represented using bloom filter arrays |
IL285766A (en) * | 2021-08-22 | 2023-03-01 | Google Llc | Cryptographically secure control using secure multi-party computation |
US11909866B2 (en) * | 2021-08-27 | 2024-02-20 | Paypal, Inc. | Systems and methods for configuring a networked system to perform threshold multi-party computation |
US11934399B2 (en) * | 2021-08-30 | 2024-03-19 | The Nielsen Company (Us), Llc | Method and system for estimating the cardinality of information |
US11847119B2 (en) * | 2021-08-30 | 2023-12-19 | The Nielsen Company (Us), Llc | Method and system for estimating the cardinality of information |
US11876775B2 (en) * | 2021-08-30 | 2024-01-16 | Arbor Networks, Inc. | System and method for monitoring communication traffic associated with dynamic internet services via DNS monitoring |
CN113886889B (en) * | 2021-10-26 | 2024-04-09 | 重庆邮电大学 | Differential privacy protection method based on joint random overturn |
KR102401485B1 (en) * | 2021-12-30 | 2022-05-24 | 주식회사 디사일로 | Method and system for processing homomorphic encrypted data |
CN114884675B (en) * | 2022-04-29 | 2023-12-05 | 杭州博盾习言科技有限公司 | Multi-party privacy intersection method, device, equipment and medium based on bit transmission |
CN114584285B (en) * | 2022-05-05 | 2022-07-29 | 深圳市洞见智慧科技有限公司 | Secure multiparty processing method and related device |
US20230393765A1 (en) * | 2022-06-01 | 2023-12-07 | Micron Technology, Inc. | Power efficient codeword scrambling in a non-volatile memory device |
CN115242371B (en) * | 2022-06-15 | 2024-04-19 | 华中科技大学 | Differential privacy-protected set intersection and base number calculation method, device and system thereof |
CN115455483B (en) * | 2022-09-21 | 2023-12-26 | 广州大学 | Big data frequency number estimation method based on local differential privacy |
WO2024079899A1 (en) * | 2022-10-14 | 2024-04-18 | 日本電信電話株式会社 | Statistical value estimation device, statistical value estimation system, statistical value estimation method, and program |
CN117910047A (en) * | 2024-03-20 | 2024-04-19 | 广东电网有限责任公司 | Multi-key federal learning method, device, terminal equipment and medium |
Family Cites Families (46)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN1183841A (en) | 1995-02-13 | 1998-06-03 | 英特特拉斯特技术公司 | System and method for secure transaction management and electronic rights protection |
KR100337637B1 (en) * | 1998-12-03 | 2002-07-18 | 오길록 | Method for recovering a digital document encrypted |
JP3788246B2 (en) | 2001-02-13 | 2006-06-21 | 日本電気株式会社 | Anonymous decryption system and anonymous decryption method |
CA2369304A1 (en) * | 2002-01-30 | 2003-07-30 | Cloakware Corporation | A protocol to hide cryptographic private keys |
JP4835831B2 (en) | 2004-01-26 | 2011-12-14 | 日本電気株式会社 | Method and apparatus for computing a function from multiple inputs |
US7856100B2 (en) * | 2005-12-19 | 2010-12-21 | Microsoft Corporation | Privacy-preserving data aggregation using homomorphic encryption |
WO2011112535A2 (en) * | 2010-03-10 | 2011-09-15 | Promentis Pharmaceuticals, Inc. | Propionic acids, propionic acid esters, and related compounds |
EP2503480A1 (en) * | 2011-03-22 | 2012-09-26 | Smals Vzw | Method and devices for secure data access and exchange |
US8526603B2 (en) | 2011-07-08 | 2013-09-03 | Sap Ag | Public-key encrypted bloom filters with applications to private set intersection |
US8472983B1 (en) * | 2011-12-07 | 2013-06-25 | Cisco Technology, Inc. | Selective location-aware paging |
US9049011B1 (en) * | 2012-08-15 | 2015-06-02 | Washington State University | Secure key storage and distribution |
US9465826B2 (en) * | 2012-11-27 | 2016-10-11 | Hewlett Packard Enterprise Development Lp | Estimating unique entry counts using a counting bloom filter |
US9306738B2 (en) | 2012-12-21 | 2016-04-05 | Microsoft Technology Licensing, Llc | Managed secure computations on encrypted data |
JP5873822B2 (en) | 2013-02-15 | 2016-03-01 | 日本電信電話株式会社 | Secret common set calculation system and secret common set calculation method |
US9652511B2 (en) * | 2013-03-13 | 2017-05-16 | International Business Machines Corporation | Secure matching supporting fuzzy data |
US9514169B2 (en) * | 2013-09-23 | 2016-12-06 | Protegrity Corporation | Columnar table data protection |
US10445769B2 (en) | 2013-12-24 | 2019-10-15 | Google Llc | Systems and methods for audience measurement |
US20150220625A1 (en) | 2014-02-03 | 2015-08-06 | Interdigital Patent Holdings, Inc. | Methods and apparatus for conveying surveillance targets using bloom filters |
US20150293923A1 (en) | 2014-04-10 | 2015-10-15 | Max Planck Gesellschaft zur Förderung der Wissenschaften e.V. | Systems and methods for anonymized user list count |
JP6331715B2 (en) * | 2014-06-02 | 2018-05-30 | 富士通株式会社 | Information generating apparatus, network system, and information generating method |
AU2015336949B2 (en) * | 2014-10-24 | 2020-04-09 | Commonwealth Scientific And Industrial Research Organisation | Gradients over distributed datasets |
GB2531848B (en) * | 2014-10-31 | 2017-12-13 | Hewlett Packard Entpr Dev Lp | Management of cryptographic keys |
US9418723B2 (en) | 2014-12-23 | 2016-08-16 | Intel Corporation | Techniques to reduce memory cell refreshes for a memory device |
US20160378465A1 (en) * | 2015-06-23 | 2016-12-29 | Intel Corporation | Efficient sparse array handling in a processor |
US10740474B1 (en) * | 2015-12-28 | 2020-08-11 | Ionic Security Inc. | Systems and methods for generation of secure indexes for cryptographically-secure queries |
CN108885627B (en) * | 2016-01-11 | 2022-04-05 | 甲骨文美国公司 | Query-as-a-service system providing query result data to remote client |
US10069631B2 (en) * | 2016-03-17 | 2018-09-04 | Palo Alto Research Center Incorporated | Fault-tolerant aggregation of encrypted data in a star network |
CN106534313B (en) * | 2016-11-17 | 2019-09-13 | 浙江工商大学 | The frequency measuring method and system of facing cloud end data publication protection safety and privacy |
EP3561697A4 (en) | 2016-12-26 | 2019-11-27 | Osaka University | Data analysis method and data analysis system |
US20180285596A1 (en) * | 2017-03-30 | 2018-10-04 | Cisco Technology, Inc. | System and method for managing sensitive data |
US10430598B2 (en) * | 2017-06-08 | 2019-10-01 | The Government Of The United States, As Represented By The Secretary Of The Army | Secure generalized bloom filter |
US20180373882A1 (en) * | 2017-06-23 | 2018-12-27 | Thijs Veugen | Privacy preserving computation protocol for data analytics |
GB2565540A (en) | 2017-08-11 | 2019-02-20 | Infosum Ltd | System and methods for joining datasets |
US10901907B2 (en) * | 2017-10-19 | 2021-01-26 | Samsung Electronics Co., Ltd. | System and method for identifying hot data and stream in a solid-state drive |
CN110971414B (en) * | 2017-11-10 | 2021-05-04 | 财付通支付科技有限公司 | Method, device, terminal and server for generating signature |
US11558178B2 (en) * | 2018-01-31 | 2023-01-17 | Walmart Apollo, Llc | System and method for prescription security and authentication |
US20190244138A1 (en) | 2018-02-08 | 2019-08-08 | Apple Inc. | Privatized machine learning using generative adversarial networks |
CN110622165B (en) * | 2018-04-19 | 2023-05-30 | 谷歌有限责任公司 | Security measures for determining privacy set intersections |
GB201811968D0 (en) | 2018-07-23 | 2018-09-05 | Nchain Holdings Ltd | Computer-implemented System and Method |
CN110913344B (en) * | 2018-08-27 | 2023-09-01 | 香港科技大学 | Collaborative target tracking system and method |
US11347808B1 (en) * | 2018-12-03 | 2022-05-31 | Amazon Technologies, Inc. | Dynamically-adaptive bloom-filter |
US10862513B2 (en) * | 2019-01-16 | 2020-12-08 | Fungible, Inc. | Data processing unit having hardware-based parallel variable-length codeword decoding |
US10990598B2 (en) * | 2019-01-31 | 2021-04-27 | Microsoft Technology Licensing, Llc | Aggregating quantile metrics in multidimensional data sets |
CN111680041B (en) | 2020-05-31 | 2023-11-24 | 西南电子技术研究所（中国电子科技集团公司第十研究所） | Safety high-efficiency access method for heterogeneous data |
US11809577B2 (en) * | 2020-09-07 | 2023-11-07 | The Toronto-Dominion Bank | Application of trained artificial intelligence processes to encrypted data within a distributed computing environment |
CN113157778B (en) | 2021-06-09 | 2021-09-24 | 富算科技(上海)有限公司 | Proxiable query method, system, device and medium for distributed data warehouse |
-
2020
- 2020-07-07 US US17/278,626 patent/US11784800B2/en active Active
- 2020-07-07 KR KR1020217011267A patent/KR102371529B1/en active IP Right Grant
- 2020-07-07 CN CN202080005460.7A patent/CN113557512B/en active Active
- 2020-07-07 US US17/278,496 patent/US20210359836A1/en active Pending
- 2020-07-07 EP EP20750891.2A patent/EP3891922B1/en active Active
- 2020-07-07 WO PCT/US2020/041025 patent/WO2021162738A1/en unknown
- 2020-07-07 CN CN202080005452.2A patent/CN114175568B/en active Active
- 2020-07-07 JP JP2021517780A patent/JP7121194B2/en active Active
- 2020-07-07 JP JP2021517804A patent/JP7121195B2/en active Active
- 2020-07-07 KR KR1020217011266A patent/KR102371528B1/en active IP Right Grant
- 2020-07-07 EP EP20750888.8A patent/EP3891921B1/en active Active
- 2020-07-07 WO PCT/US2020/041020 patent/WO2021162737A1/en unknown
- 2020-07-28 CN CN202080005459.4A patent/CN113557511A/en active Pending
- 2020-07-28 US US17/276,643 patent/US11909864B2/en active Active
- 2020-07-28 KR KR1020237027886A patent/KR20230124111A/en not_active Application Discontinuation
- 2020-07-28 KR KR1020217011133A patent/KR102569373B1/en active IP Right Grant
- 2020-07-28 EP EP20754583.1A patent/EP3891923B1/en active Active
- 2020-07-28 JP JP2021517872A patent/JP7144607B2/en active Active
- 2020-07-28 WO PCT/US2020/043894 patent/WO2021162743A1/en unknown
-
2023
- 2023-06-13 US US18/334,035 patent/US20230421365A1/en active Pending
Also Published As
Publication number | Publication date |
---|---|
WO2021162743A1 (en) | 2021-08-19 |
KR20210104653A (en) | 2021-08-25 |
US20220376887A1 (en) | 2022-11-24 |
EP3891921B1 (en) | 2022-11-16 |
JP2022517054A (en) | 2022-03-04 |
KR102569373B1 (en) | 2023-08-22 |
KR20210104655A (en) | 2021-08-25 |
EP3891923A1 (en) | 2021-10-13 |
CN113557512A (en) | 2021-10-26 |
EP3891923B1 (en) | 2023-07-12 |
WO2021162737A1 (en) | 2021-08-19 |
US20210359836A1 (en) | 2021-11-18 |
WO2021162738A1 (en) | 2021-08-19 |
CN113557512B (en) | 2022-09-20 |
JP7144607B2 (en) | 2022-09-29 |
KR102371528B1 (en) | 2022-03-07 |
CN113557511A (en) | 2021-10-26 |
JP7121195B2 (en) | 2022-08-17 |
US20230421365A1 (en) | 2023-12-28 |
US11909864B2 (en) | 2024-02-20 |
JP7121194B2 (en) | 2022-08-17 |
US20210359846A1 (en) | 2021-11-18 |
EP3891921A1 (en) | 2021-10-13 |
JP2022517298A (en) | 2022-03-08 |
CN114175568A (en) | 2022-03-11 |
EP3891922A1 (en) | 2021-10-13 |
KR102371529B1 (en) | 2022-03-07 |
US11784800B2 (en) | 2023-10-10 |
KR20210104654A (en) | 2021-08-25 |
CN114175568B (en) | 2023-06-06 |
EP3891922B1 (en) | 2022-09-07 |
JP2022517299A (en) | 2022-03-08 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
KR102569373B1 (en) | Securing multi-party reach and frequency estimation | |
Papadimitriou et al. | Big data analytics over encrypted datasets with seabed | |
Chen et al. | Labeled PSI from fully homomorphic encryption with malicious security | |
Mazloom et al. | Secure computation with differentially private access patterns | |
US10229068B2 (en) | Tunable oblivious RAM | |
Liu et al. | Efficient searchable symmetric encryption for storing multiple source dynamic social data on cloud | |
Li et al. | An efficient blind filter: Location privacy protection and the access control in FinTech | |
CN116324778A (en) | Updatable private collection intersections | |
Syam Kumar et al. | RSA-based dynamic public audit service for integrity verification of data storage in cloud computing using Sobol sequence | |
Mazloom et al. | Differentially private access patterns in secure computation | |
Wang et al. | Secret sharing scheme with dynamic size of shares for distributed storage system | |
Zhang et al. | Longshot: Indexing growing databases using MPC and differential privacy | |
Blass et al. | Epic: Efficient privacy-preserving counting for mapreduce | |
Pagano | A Distributed Approach to Privacy on the Cloud | |
Tekin et al. | Implementation and evaluation of improved secure index scheme using standard and counting bloom filters | |
Zhao | Order-Preserving Database Encryption with Secret Sharing | |
Ahmadian | On the security of NoSQL cloud database services |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
A107 | Divisional application of patent | ||
E902 | Notification of reason for refusal |