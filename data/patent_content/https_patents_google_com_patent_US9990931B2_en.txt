US9990931B2 - Method for coding pulse vectors using statistical properties - Google Patents
Method for coding pulse vectors using statistical properties Download PDFInfo
- Publication number
- US9990931B2 US9990931B2 US14/460,440 US201414460440A US9990931B2 US 9990931 B2 US9990931 B2 US 9990931B2 US 201414460440 A US201414460440 A US 201414460440A US 9990931 B2 US9990931 B2 US 9990931B2
- Authority
- US
- United States
- Prior art keywords
- vector
- coding
- pulse
- zero
- vectors
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Fee Related, expires
Links
Images
Classifications
-
- G—PHYSICS
- G10—MUSICAL INSTRUMENTS; ACOUSTICS
- G10L—SPEECH ANALYSIS OR SYNTHESIS; SPEECH RECOGNITION; SPEECH OR VOICE PROCESSING; SPEECH OR AUDIO CODING OR DECODING
- G10L19/00—Speech or audio signals analysis-synthesis techniques for redundancy reduction, e.g. in vocoders; Coding or decoding of speech or audio signals, using source filter models or psychoacoustic analysis
- G10L19/02—Speech or audio signals analysis-synthesis techniques for redundancy reduction, e.g. in vocoders; Coding or decoding of speech or audio signals, using source filter models or psychoacoustic analysis using spectral analysis, e.g. transform vocoders or subband vocoders
- G10L19/032—Quantisation or dequantisation of spectral components
- G10L19/038—Vector quantisation, e.g. TwinVQ audio
-
- H—ELECTRICITY
- H03—ELECTRONIC CIRCUITRY
- H03M—CODING; DECODING; CODE CONVERSION IN GENERAL
- H03M7/00—Conversion of a code where information is represented by a given sequence or number of digits to a code where the same, similar or subset of information is represented by a different sequence or number of digits
- H03M7/30—Compression; Expansion; Suppression of unnecessary data, e.g. redundancy reduction
- H03M7/3082—Vector coding
-
- H—ELECTRICITY
- H03—ELECTRONIC CIRCUITRY
- H03M—CODING; DECODING; CODE CONVERSION IN GENERAL
- H03M7/00—Conversion of a code where information is represented by a given sequence or number of digits to a code where the same, similar or subset of information is represented by a different sequence or number of digits
- H03M7/30—Compression; Expansion; Suppression of unnecessary data, e.g. redundancy reduction
- H03M7/40—Conversion to or from variable length codes, e.g. Shannon-Fano code, Huffman code, Morse code
- H03M7/4006—Conversion to or from arithmetic code
- H03M7/4012—Binary arithmetic codes
- H03M7/4018—Context adapative binary arithmetic codes [CABAC]
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/48—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using compressed domain processing techniques other than decoding, e.g. modification of transform coefficients, variable length coding [VLC] data or run-length data
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/90—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using coding techniques not provided for in groups H04N19/10-H04N19/85, e.g. fractals
- H04N19/91—Entropy coding, e.g. variable length coding [VLC] or arithmetic coding
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/90—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using coding techniques not provided for in groups H04N19/10-H04N19/85, e.g. fractals
- H04N19/94—Vector quantisation
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/46—Embedding additional information in the video signal during the compression process
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/60—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using transform coding
Definitions
- This application is related to encoding and decoding of video signals. More particularly, this application is related to encoding and decoding pulse vectors, which represent portions of a video frame, using statistical analysis of the pulse vectors.
- FPC Factorial Pulse Coding
- FIG. 1 is a block diagram and functional flow diagram of a user equipment (UE) incorporating an embodiment of the method for coding pulse vectors using statistical and probability properties;
- UE user equipment
- FIG. 2 is a flow diagram showing a prior art method for coding a quantized pulse vector that does not include using probability models
- FIG. 3 is a flow diagram describing a flow process of an encoder embodiment that encodes quantized pulse vectors
- FIG. 4 is a flow diagram providing detail about a process of coding a pulse count of a quantized pulse vector
- FIG. 5 is a flow diagram providing additional detail about the process of coding the pulse count of a quantized pulse vector that includes state processing
- FIG. 6 provides a trellis flow diagram that explains a recursive process used in an embodiment to determine conditional probabilities
- FIG. 7 is a flow diagram providing detail about a process for coding quantized pulse vector pulse position information
- FIG. 8 is a flow diagram providing an overview of the sequence of steps used for VPCC coding magnitudes of the quantized pulse vector non-zero positions
- FIG. 9 is a flow diagram providing detailing a process for coding mean value vectors using variable factorial pulse codingVFPC to create an output codeword representing a coded pulse vector x k ;
- FIG. 10 is a flow diagram detailing a process for decoding a code word in accordance with an embodiment to recreate the quantized pulse vector x k .
- FPC Factorial Pulse Coding
- n is the vector length
- m is the total number of unit magnitude “pulses” within vector x, such that all vector elements are within the range ⁇ m ⁇ x i ⁇ m. It has been found that the total number of unique pulse combinations N in a video frame arising from Eq. 1 is:
- F(n, k) is the number of combinations of k non-zero elements on n vector positions:
- D(m, k) is the number of combinations that m unit magnitude pulses can fall on k non-zero vector elements, (where k ⁇ m):
- PVQ Pyramid Vector Quantization
- FPC has also been included in the following industry standards for audio: 3GPP2 EVRC-B and EVRC-WB, and ITU—T G.718. In these standards, low-complexity fixed-point software implementations are required as part of the distribution packages. Thus, the primary technical advantages of FPC over PVQ are:
- an FPC bit rate estimator (given in Eqs.1-5) was “plugged” into an existing video codec. Then, while keeping video quality constant, the incremental bit rate of FPC relative to the default coding method was measured (for the default coding method used by video codec). Only the bits used by the default video codec for which the equivalent FPC operations are performed were counted. By keeping the video quality constant (i.e., bit exact with the default codec operations), one can focus on the bit rate aspects, and not be concerned with trying to measure relative quality differences. Maintaining bit-exactness, however, does create other codec specific issues, which will be discussed below.
- FIG. 1 an example of a mobile communication device, electronic tablet device, video creation/playback device or other user equipment (UE) 1 having a user interface (not specifically shown) is depicted.
- the UE 1 has a video block 10 comprising hardware and/or software blocks adapted to encode or decode a digital video signal.
- digital video signals may be divided into a plurality of frames. Often the frames are of different frame types, which are utilized to compensate for motion and at the same time decrease the bit-rate needed to transmit the motion representation within areas of the frame to a decoder.
- I, B and P coded fields or frames of data in a digital video signal which are well known in the art. Embodiments of the invention work equally well for each of the various types of I, B and P data fields or data frames of video data.
- FIG. 1 within the video block 10 is a block diagram that represents a high level view of a video codec that may incorporate a Video FPC (FPC) in accordance with various embodiments.
- a frame of data 12 which is essentially a spatial domain snapshot of a video screen (a single video frame), is divided into multiple macro blocks 14 the form of a grid or matrix.
- Each macro block 14 can be, for example, 32 ⁇ 32 pixels in dimension.
- each macro block may be sectioned into 64 ⁇ 64, 32 ⁇ 32, 16 ⁇ 16 or 8 ⁇ 8 pixels.
- the macro blocks 14 may be further subdivided into sub blocks 16 , which may be for example, 8 ⁇ 8 or 4 ⁇ 4 pixels.
- Each of the sub blocks 16 are provided as an array of data to a transform block 18 .
- the transform block 18 performs a discrete cosine transform (DCT) 19 on each of the sub blocks 16 , which converts the X Y coordinate system of each sub block into a spatial-frequency domain.
- the DCT 19 block outputs transform coefficients.
- the transform coefficients are then quantized in the quantization block 20 .
- different transforms may be performed on each of the sub blocks 16 .
- a Walsh-Hadamard transform can be used instead of the DCT in block 19 .
- WHT Walsh-Hadamard transform
- the quantization block 20 is not required and can be bypassed as shown by the dotted lines 21 .
- the quantization step may have little or no effect on the transform coefficients produced in the transform block 19 regardless of whether a DCT is used or not.
- the 4 ⁇ 4 or 8 ⁇ 8 blocks of quantized coefficients that were output from the transform block 18 are converted from a two dimensional matrix to a serial string of quantized coefficients. In various embodiments this is performed by scanning the matrix in, for example, a zigzag pattern, as is also known in the art, to turn the 2D matrix into a serial string of quantized coefficients, which may also be referred to as a quantized pulse vector.
- the serial strings of quantized coefficients may then be provided to a loop filter block 24 , which may, among other things, buffer the serial string of quantized coefficients due to a varying bit-rate that is dependent on the complexity of the picture information (e.g., the type of frame data I, B or P frame data) and the amount and type of motion captured in the digital video frame.
- a loop filter block 24 may, among other things, buffer the serial string of quantized coefficients due to a varying bit-rate that is dependent on the complexity of the picture information (e.g., the type of frame data I, B or P frame data) and the amount and type of motion captured in the digital video frame.
- the output of the loop filter 24 provides a quantized pulse vector x that contains only integer valued magnitude components which embodiments of a Video FPC encoder 26 requires.
- the quantized pulse vector x may also be referred to herein as a pulse vector
- the pulse vector x in some embodiments, may also contain information indicating the length n of the pulse vector.
- the Video FPC encoder 26 receives the pulse vector x and the vector length n. It should be noted that the pulse vector may also include or have attached thereto meta data 25 associated with the frame or the overall video data.
- the encoder 26 may be configured to have a predetermined number of number unit magnitude pulses m (as in various audio applications) for each pulse vector x, or the number unit magnitude pulses m can be calculated from the pulse vector x signal itself. Conversely, on the decoder side, however, if m is not fixed, it must be conveyed as side information, either by explicit coding or indirectly by coding block energies from which the number of bits m can be derived. Once the number of bits is made available, the number of magnitude pulses m can be determined from there.
- the Video FPC encoder 26 combines statistical encoding with vector quantization to provide coded video that requires less data and bandwidth than prior video encoding and decoding methods.
- the coded video output of the Video FPC encoder 26 can then be stored in a memory or data storage device 2 , or transmitted wirelessly via a transceiver 4 via antenna 5 .
- One or more processors 6 within the UE 1 control the processing of the digital video data via instructions stored in the memory 2 .
- Embodiments use the transformed and quantized macro blocks and/or sub blocks (i.e., the pulse vectors) in a new way such that Video FPC can be used in a non-uniform way where the probabilities are not uniformly distributed over different frames of data, as explained in more detail below.
- FIG. 2 is a flow diagram of a prior art method of coding a single pulse vector x.
- This prior art method uses an encoding technique referred to as factored pulse coding (FPC).
- FPC is discussed to some degree in U.S. Pat. No. 8,149,144 for audio coding.
- a single quantized pulse vector x is received at step 30 .
- the number of non-zero positions n p is computed and coded. Since, the number of unit magnitude pulses is fixed or already known in this prior art method in block 40 , this information does not have to be calculated.
- the positions of each non-zero pulse within the pulse vector is coded as a position vector ⁇ .
- the magnitude of each non-zero pulse within the pulse vector is coded as a magnitude vector ⁇ .
- the sign of each non-zero pulse within the pulse vector is coded at step 38 .
- the results of each of the steps 32 through 38 are essentially coded numbers that correlate directly to the pulse vector from which they were calculated.
- the number of non-zero positions in the quantized pulse vector is can be a positive integer number between 0 and the maximum number of pixels in the micro block, which in this example there are 16 possible locations in a 4 ⁇ 4 sub block.
- the position vector ⁇ may indicate that, for example, positions 2, 5, 6, 7 and 8 of the quantized pulse vector (having positions 0 through 15) are non-zero values.
- VP9 is a video codec standard used by Google, but it is understood that various video codec methods and systems can be used with embodiments of the invention. It was found that embodiments decrease the bandwidth or bit rate of the video data that is necessary or required to recreate the video sub block, macro block and ultimately the video frames. Thus, embodiments enable a lower bandwidth or bit rate necessary to transmit and receive video signals without degradation of the decoded recreated video images displayed on a UE 1 or other display device.
- the type of information that is contained in a WHT or DCT transform block's 18 output quantized signal vector or pulse vector x was carefully considered.
- the serial string of quantized coefficients quantized that can be output of the transform block 18 is a series of pulses or pulse vectors that essentially encodes the video signal in the frequency domain.
- Each pulse sample in the series of pulses or pulse vector has an integer magnitude and a sign (+/ ⁇ ). There are also a number of non-zero pulses within each pulse vector.
- VP9 For VP9, the inventors found that there were statistical biases in the resulting pulse vectors. Additionally, statistical biases were discovered in the pulse vectors created by other video codecs. It is expected that there are also statistical biases in other video codec outputs such as Daala, VP8, Indeo, Windows Media Video (WMV), QuickTime H264 as well as in other video codecs. Thus, many of the same VFPC methods that are shown to be used herein with VP9 can also be used and will apply to other types of video codecs. It is noted that the “number of unit magnitude pulses” cannot be reused with VP9 as, for example, it could be done in other video codecs like a Daala codec.
- the parameter m being the total number of unit magnitude pulses within the vector x, should be explicitly coded in or with the vector.
- a flow chart 50 is presented to describe example encoding methods that utilize statistical models (i.e., probability models) for an ensemble of pulse vectors to more efficiently code the ensemble of pulse vectors.
- at least one pulse parameter describing the non-zero pulses of a given pulse vector is encoded using the statistical models and the number of non-zero pulse positions for the given pulse vector.
- Such encoding methods may be performed by an encoder such as encoder 26 in FIG. 1 .
- a pulse vector x k of the ensemble of pulse vectors is received by the encoder 26 from a transform block 18 or other block in which such pulse vectors may be generated or stored (if previously generated).
- the number of non-zero pulse positions n p in the pulse vector x k is computed.
- the number of unit magnitude pulses m k in the pulse vector x k is computed (although in some embodiments, as described below, a related quantity m′ k may be computed).
- the number of unit magnitude pulses m k may also be viewed as a sum of magnitudes of the non-zero pulse positions of the pulse vector x k .
- a position vector ⁇ k is computed which includes location information for each non-zero pulse position in the pulse vector x k .
- An example position vector ⁇ k includes a sequence of values indicating the position number of each non-zero pulse position of the pulse vector x k .
- a magnitude vector ⁇ k is computed which includes magnitude information for each non-zero pulse position in the pulse vector x k .
- An example magnitude vector ⁇ k includes a sequence of values indicating the absolute magnitude of each non-zero pulse position of the pulse vector x k , and omits any zero-valued positions.
- step 62 the sign information (i.e., algebraic sign) for each non-zero position of the pulse vector x k is computed and a corresponding sign vector s k is generated.
- Each of these parameters n p , m k , position vector ⁇ k , magnitude vector ⁇ k , and sign vector s k may be viewed as a respective pulse parameter describing non-zero pulse positions within the respective pulse vector x k of the ensemble of pulse vectors.
- steps 52 , 54 , 56 , 58 , 60 , 62 are repeated for every pulse vector x k of the ensemble of N pulse vectors.
- Such an ensemble of N pulse vectors may represent an entire video frame being evaluated (i.e., each pulse vector x k corresponding to a sub-block of the video frame).
- each of the respective pulse parameters generated in steps 54 through 62 are accumulated for each respective pulse vector vector x k of the ensemble of N pulse vectors.
- probability models are calculated for the accumulated pulse parameters for all N pulse vectors of the ensemble. Examples of such probability models are described in greater detail below.
- the respective pulse parameters for each pulse vector x k are coded into corresponding codewords of a respective vector codeword set.
- At least one of the pulse parameters for each respective pulse vector x k is coded based on the probability models for the ensemble and also based on the respective number of non-zero positions in the respective pulse vector x k .
- the respective pulse parameter n p is coded based on the probability models for the ensemble of pulse vectors.
- one, or more than one, or all of the respective parameters m k , position vector ⁇ k , magnitude vector ⁇ k , and sign vector s k are coded based on the probability models for the ensemble and also based on the respective number of non-zero positions in the respective pulse vector x k . Example methods of coding each of these different pulse parameters are described in greater detail below.
- the respective vector codeword set i.e., the statistically coded pulse parameters for the number of non-zero positions, the number of unit magnitude pulses, the positions vector, the magnitude vector, and the sign bits
- a coded bitstream may be subsequently decoded by a decoder to reconstruct the ensemble of pulse vectors (e.g., as part of decoding a video signal represented by the coded bitstream).
- a bitstream may be stored in memory storage 2 , and may be transmitted using transceiver 4 and antenna 5 .
- Other storage blocks and transmission blocks are also contemplated.
- the probability models for each ensemble of pulse vectors is also coded at step 68 into one or more corresponding codewords of a statistical model codeword set (i.e., the coded probability models) for the ensemble.
- this statistical model codeword set is transmitted or stored, for subsequent use by a decoder to reconstruct each pulse vector of the ensemble of pulse vectors.
- a respective vector codeword set i.e., the statistically coded pulse parameters for the number of non-zero positions, the number of unit magnitude pulses, the positions vector, the magnitude vector, and the sign bits
- the statistical model codeword set i.e., the coded probability models
- each video frame usually includes a large number of sub-blocks, and since the coded probability models are transmitted relatively infrequently compared to the coded pulse parameters, the particular method used to code the probability models does not have a significant influence on the total number of bits required to code a given video frame, and such coding need not require significant compression.
- a method for coding an ensemble of pulse vectors includes receiving the ensemble of pulse vectors, and determining, for each respective pulse vector of the ensemble of pulse vectors, a respective plurality of pulse parameters describing non-zero pulse positions within the respective pulse vector. One of the respective plurality of pulse parameters corresponds to a number of non-zero pulse positions within the respective pulse vector.
- the example method further includes generating a set of statistical parameters for the ensemble of pulse vectors, and coding the set of statistical parameters to produce a statistical model codeword set corresponding to the ensemble of vectors.
- the example method further includes coding the pulse parameter corresponding to the number of non-zero pulse positions within the respective pulse vector to produce a first codeword of a respective vector codeword set; and coding at least one of a remaining plurality of pulse parameters describing non-zero pulse positions within the respective pulse vector, based upon the number of non-zero pulse positions within the respective pulse vector and the set of statistical parameters for the ensemble, to produce at least one corresponding codeword of the respective vector codeword set.
- a system for coding an ensemble of pulse vectors includes a first buffer, for example in an encoder block, operable to receive the ensemble of pulse vectors, and a processor, as depicted in FIG. 1 .
- the processor is operable to determine, for each respective pulse vector of the ensemble of pulse vectors, a respective plurality of pulse parameters describing non-zero pulse positions within the respective pulse vector.
- One of the respective plurality of pulse parameters corresponds to a number of non-zero pulse positions within the respective pulse vector.
- the processor is further operable to generate a set of statistical parameters for the ensemble of pulse vectors, and to code the set of statistical parameters to produce a statistical model codeword set corresponding to the ensemble of vectors.
- the processor is further operable, for each respective pulse vector of the ensemble of pulse vectors, to code the pulse parameter corresponding to the number of non-zero pulse positions within the respective pulse vector to produce a first codeword of a respective vector codeword set, and to code at least one of a remaining plurality of pulse parameters describing non-zero pulse positions within the respective pulse vector, based upon the number of non-zero pulse positions within the respective pulse vector and the set of statistical parameters for the ensemble, to produce at least one corresponding codeword of the respective vector codeword set.
- Decoding such a coded bitstream is computationally less difficult, since it is not necessary to generate the probability models. Rather, the decoder receives the coded probability models for each ensemble from a coded bitstream, then decodes the coded probability models to generate the probability models for the ensemble (e.g., video frame). The decoder also receives each set of coded pulse parameters from the coded bitstream, then uses the probability models to decode the corresponding pulse parameters for each respective pulse vector of the ensemble, and determine each of the non-zero pulse positions within each respective pulse vector of the ensemble using the corresponding pulse parameters.
- a method for decoding a coded bitstream to reconstruct an ensemble of pulse vectors includes receiving from the coded bitstream a statistical model codeword set, and decoding the statistical model codeword set to determine a set of statistical parameters corresponding to the ensemble of pulse vectors. The example method further includes receiving from the coded bitstream respective vector codeword sets corresponding to respective pulse vectors of the ensemble.
- the example method further includes decoding a first codeword of the respective vector codeword set to determine a first pulse parameter corresponding to a number of non-zero pulse positions within a corresponding respective pulse vector; decoding at least a one of a remaining plurality of codewords of the respective vector codeword set, using the set of statistical parameters for the ensemble and the number of non-zero positions within the corresponding respective pulse vector, to determine at least one of a remaining plurality of pulse parameters describing the non-zero pulse positions within the corresponding respective pulse vector; and determining each of the non-zero pulse positions within the corresponding respective pulse vector of the ensemble using the respective plurality of pulse parameters.
- a system for decoding a coded bitstream to reconstruct an ensemble of pulse vectors includes a first buffer and a processor.
- the first buffer is operable to receive from the coded bitstream a statistical model codeword set, and respective vector codeword sets corresponding to respective pulse vectors of the ensemble.
- the processor is operable to decode the statistical model codeword set to determine a set of statistical parameters corresponding to the ensemble of pulse vectors.
- the processor is further operable, for each respective vector codeword set, to decode a first codeword of the respective vector codeword set to determine a first pulse parameter corresponding to a number of non-zero pulse positions within a corresponding respective pulse vector; to decode at least a one of a remaining plurality of codewords of the respective vector codeword set, using the set of statistical parameters for the ensemble and the number of non-zero positions within the corresponding respective pulse vector, to determine at least one of a remaining plurality of pulse parameters describing the non-zero pulse positions within the corresponding respective pulse vector; and to determine each of the non-zero pulse positions within the corresponding respective pulse vector of the ensemble using the respective plurality of pulse parameters.
- the first step in this part of the encoding process of an embodiment is the coding of the number of non-zero elements n p (k) for each vector x k .
- the following is performed at step 54 , where:
- n is the length of the pulse vector x k , which for a 4 ⁇ 4 block size, is 16.
- P of a particular non-zero element n p (k) occurring are calculated, which can be expressed as:
- N is the number of vectors (blocks) in the ensemble of vectors being evaluated (for example, corresponding to the number of blocks in a frame)
- n p (k) is the number of non-zero positions in the k-th vector (block)
- j is the bit index of the pulse vector x k .
- this information is used to explicitly code n p (k) using range coding.
- This method for coding the number of unit magnitude pulses contained in the each vector x k uses a conditional bitwise arithmetic coding. Similar to other steps in this embodiment, first a number of unit magnitude pulses m k in vector x k (where all values of x k are signed integers) of length n is calculated as:
- bitwise probabilities of each bit of m k being set to one are calculated.
- bitwise (a.k.a. binary) arithmetic coding (BAC) scheme the following expression yields the bitwise probabilities:
- N b is the maximum number of bits to be coded
- j is the bit index
- m k is the number of unit magnitude pulses for the k-th vector (block)
- N is the total number of vectors (blocks) to be coded, for example, in a frame or macro block.
- the “&” symbol represents the bitwise AND operator.
- P m (j) represents the probability that the j-th bit position of the value m k is set to one. This probability can be used to losslessly code the array of m k values for use in signal compression.
- n p (k) when fewer positions are occupied (i.e., n p (k) is small relative to n), there is a corresponding increased probability that m′ k will be relatively small, and conversely, when more positions are occupied, there is an increased probability that m′ k will be relatively large.
- BAC binary arithmetic coding
- n ⁇ N b size matrix that gives the probability of a particular bit of m k (i) being set for a given predetermined number of occupied positions n p (k).
- block 64 is operable to accumulate all of the pulse vector parameters in a given frame for the value of k ranging from a value of 0 to N.
- the value of k is initiated at a null value at a block 410 and then proceeds to a block 412 to receive the k-th pulse vector x k and then to block 414 to calculate the non-zero positions and onto a block 416 to compute the number of unit magnitude pulses for that particular vector.
- the value of k is tested against the value of N to determine if the frame has been completed. If not, the process loops to block 412 . If so, then the process flows from the block 64 to the next process to generate the probability models, this being block 66 from FIG. 3 .
- the bit wise probabilities of m′ k is calculated over the entire frame with the value of k ranging from a value of 0 to N.
- a computed value m′ k representing the number of unit magnitude pulses for the given pulse vector x k .
- the process is initialized at the “0” for the j-th bit at block 418 , and then proceeds to test each bit in m′ 1 .
- the decision block 420 determines if the currently tested bit is set.
- the program then flows to a block 426 to calculate c 2 (n p (k)) for the number of instances in which x k contains n p (k) non-zero positions and then to a block 428 in order to perform this test for all pulse vectors x k in the frame.
- this process provides the bit wise probabilities of m′ k and the process flows to a block 432 to build the table in accordance with equation 1.6 above and then proceeds to a block 432 wherein the table is transmitted or stored and into a block 434 to code the bits of m′ k using the probability table for all k, j.
- the coded bits of m′ k are then transmitted or stored with other statistically coded bits, as indicated by block 436 .
- FIG. 5 provides one example of a flow chart of how a state machine can be employed in an embodiment.
- the pulse vectors are accumulated and bitwise probabilities of m′ k are performed as discussed above and shown in FIG. 4 .
- this FIG. 5 there are provided two states, a state 0 representing bits not being set and a state 1 indicating the occurrence of a first bit being set.
- the bits are tested from the MSB to the LSB, taking advantage of the fact that large values of m′ k will have a large number of bits not set in the upper portion of the digital word.
- the state is initially set at state 0 in block 520 and to the first j-th bit of m′ k (the MSB Nb-1) in this state.
- the process flows to the first decision block 522 in order to determine if the state is still state 0 .
- the state will be state 0 until the first j-th bit tested is set.
- the program will flow along the path from block 522 to block 524 to determine if this tested bit is set. This is the point where the state changes from state 0 to state 1 .
- the process will remain in state 0 and the process will merely calculate c 2 (n p (k)) as noted in block 526 . However, if the tested bit is set, this indicates that the state operation must change to state 1 .
- the process then flows to decision block 530 and continues until all bits have been tested for j.
- the program then flows to a decision block 540 to loop back around to the input of block 524 until all additional pulse vectors in the frame are handled and then proceeds to perform the same functions as set forth above with respect to blocks 430 - 436 .
- Table 1 shows the relative performance gains of the described methods compared to traditional scalar and binary arithmetic coding (using know probability models).
- the step of coding of position information involves using binary arithmetic coding to convey whether or not an element of the quantized vector x k contains non-zero information.
- the overall probability of a given element within the quantized vector is comprised of the conditional probability of the i-th position element being non-zero, given that the number of the j remaining non-zero elements lie the range i to n ⁇ 1.
- a flow diagram that provides detail of an example process for coding quantized pulse vector pulse position information is provided.
- the parameters for each k vector x k are accumulated as already discussed in FIG. 4 .
- the probability of the i-th position or element of input vector x k being occupied by a non-zero value is determined based on the equation:
- this is the probability of element x k (i) being non-zero, given j non-zero valued elements over the remaining n ⁇ i positions of vector x k .
- the probability of the i-th element of input vector x k being occupied by a non-zero value is determined by the encoder block via probability calculations, while in other embodiments, these probabilities are received from functional blocks associated with the encoder block.
- P ⁇ ( T ) [ P ⁇ ( T ⁇ ( 0 , 0 ) ) 0 0 ... 0 P ⁇ ( T ⁇ ( 1 , 0 ) ) P ⁇ ( T ⁇ ( 1 , 1 ) ) 0 ... 0 P ⁇ ( T ⁇ ( 2 , 0 ) ) P ⁇ ( T ⁇ ( 2 , 1 ) ) P ⁇ ( T ⁇ ( 2 , 2 ) ... 0 ⁇ ⁇ ⁇ ⁇ ⁇ P ⁇ ( T ⁇ ( n , 0 ) ) P ⁇ ( T ⁇ ( n , 1 ) ) P ⁇ ( T ⁇ ( n , 2 ) ... P ⁇ ( T ⁇ ( n , n ) ] , ( 1.8 ) where the matrix elements P(T(i, j)) represent the probabilities from using a trellis matrix of having j non-zero elements on
- the probabilities P(x k (i)) may be sorted in descending order and a trellis matrix with matrix elements P(T(i,j)).
- T ′ ⁇ ( n - i , j ) P ⁇ ( T ⁇ ( n - i - 1 , j - 1 ) ) P ⁇ ( T ⁇ ( n - i , j ) ) , ⁇ 0 ⁇ i ⁇ n , ⁇ 1 ⁇ j ⁇ n - i ( 1.14 ) and thereby reducing the per vector probability computations to: P ( x k ( i ) ⁇ 0
- T ( n ⁇ i,j ) 1 ⁇ T ′( n ⁇ i,j ) ⁇ P ( k k ( i )) (1.15b)
- FIG. 7 shows a dotted box showing sorting of probabilities P(x k (i)) 80 .
- the number of bits needed to code the non-zero positions will not change whether the probabilities are sorted or not.
- the magnitude vector of length n p (k) is defined as: x′ ⁇
- an ensemble of integer pulse sequence vectors i.e., pulse vectors x k for an entire frame or block is provided having a length n.
- the mean value vector ⁇ is sorted such that the components of the vectors x k are re-arranged or re-indexed in, for example memory of the UE, in a decreasing order of mean value vector ⁇ .
- step 96 for each vector in the ensemble, the number of non-zero values (n p ) is determined and all the zero values are removed from the x k vector. The resulting vector x′ is then saved. Additionally, the mean value vector ⁇ is modified by removing the corresponding mean values from the sorted mean vector ⁇ and save the result as ⁇ ′. Then at step 98 , use VPFC to code vector with the zeros removed x′ based on the modified mean value vector ⁇ ′.
- the magnitude vector of length n p (k) is defined as: x′ ⁇
- the k-th codeword resulting from coding the magnitude vector x′ is given by:
- N is the number of vectors (or scanned video blocks) per frame
- n is the vector length. It can be statistically inferred that if all x k (i) are independent and identically distributed (i.i.d.), then their respective expected absolute values are equivalent, and that their sampled mean absolute values ⁇ i are approximately equal.
- the codeword can be generated by a combinatorial coding method that is also dependent on the expected values or mean values ⁇ i .
- the magnitude vector is arranged such that the ⁇ i are in decreasing order i.e, ⁇ 0 ⁇ 1 ⁇ . . . ⁇ i ⁇ . . . ⁇ n-1 . If they are not already arranged in decreasing order, then one can first sort ⁇ i , and then re-arrange or re-index the x k (i) components such that their mean values are in the decreasing order.
- x k the initial few components of x k will have higher values, i.e., x k (0), x k (1), etc., as well as a higher probability of being greater than the last few components.
- the magnitudes are coded using an adaptive combinatorial coding approach, which generates a variable length codeword.
- This approach is novel and has been named by the inventors as Variable Factorial Pulse Coding ( VFPC ).
- s and t define the start and end components of the sub-vectors to be analyzed.
- the functions are used to generate the adaptive pulse count a j as:
- a j min ⁇ ( m , ⁇ j ′ ⁇ _ ⁇ ( 0 , j ) / ( j + 1 ) ⁇ x _ ⁇ ( 0 , j ) - ⁇ ) , ( 1.23 )
- ⁇ is a fixed pre-determined positive constant.
- a j is calculated using equation 1.23.
- the modified value a′ j is now obtained as:
- a j ′ min ⁇ ( m , ⁇ j ′ ⁇ _ ⁇ ( 0 , j ) / ( j + 1 ) ⁇ ( x _ ⁇ ( 0 , j ) - ⁇ ) + ⁇ ) . ( 1.25 )
- a minimum value s is found at step 109 such that F ( a j ⁇ ,j ) ⁇ 2 ⁇ s ⁇ F ( a′ j ⁇ ,j ) (1.26)
- step 110 wherein the process loops back to step 104 .
- step 110 the inequality condition in Eq.1.26 of step 109 guarantees that the coding process is still uniquely decodable, and that selecting a minimum value of s will minimize the increase in the number of coded bits.
- the final combinatorial codeword C is obtained from step 116 as a summation of respective combinatorial contribution C j :
- the corresponding decoder process is complementary to the encoder process.
- FIG. 10 provides a flowchart showing VFPC decoding steps in accordance with an embodiment of the invention.
- FIG. 10 is easily understood by one of ordinary skill in the art after understanding the workings of FIG. 9 .
- the mean values are fixed and are known a-priori, the method of FIG. 9 can be directly used.
- the mean value also needs to be computed and transmitted.
- the mean values of the coefficients x k (i) of macro-blocks (vector x k ) may change from frame to frame or may be different depending on the type of macro-block (Luma or Chroma).
- the mean values are calculated and can be transmitted in each frame of the coded video.
- the computation of mean value also makes use of the fact that the input to VFPC encoder (see FIG. 9 ) is a vector whose components are non-zero and hence it may be better to restrict the mean calculation over only those components of the quantized vector x that are non-zero.
- x k (i) as the i-th component of the vector x k
- c i as the count of i-th component being non-zero over all the vectors x 0 to x N-1 , i.e.,
- Either Eq.1.31 or Eq.1.19 can be used to calculate the absolute mean values ⁇ i .
- the mean values thus computed may be quantized (scalar quantization) and transmitted or stored once per frame (see FIG. 3 , step 70 ).
- VFPC variable length FPC
- WHT Walsh-Hadamard Transform
- VFPC video encoding embodiment as a stand alone coding method for coding of the magnitudes
- the VFPC embodiment was used for coding the magnitudes of non-zero components of pulse vector x in a simulation. In the Table 3 the results of the VFPC magnitude coding method is compared with the regular FPC magnitude coding method.
- Embodiments of the invention provide lossless coding (entropy coding) of blocks of prediction residual data in video coding after being transformed, quantized and mapped into one-dimensional vectors.
- Embodiments provide a UE that, via hardware and/or program instructions, uses a coding method that segregates video block data originating from a frame into the following units of information and then encodes the units of information efficiently using statistical models that are updated every frame.
- the units of information comprise a) determining the number of non-zero positions of a quantized pulse vector per block, where a block is a macro or micro block of the frame; b) summing the magnitudes (the absolute values) for the non-zero positions m of the quantized pulse vector; c) determining which positions within the quantized pulse vector have a non-zero magnitude; d) determining the absolute value magnitude of each non-zero position in the quantized pulse vector; and e) determining the sign of each magnitude at the non-zero positions in the quantized pulse vector.
- the parameters for all the pulse vectors N in the frame are then accumulated.
- probability models are generated for the frame and for each block unit of information within the frame.
- the probability models are used to encode the units of information (a through e) for each block of video data to produce encoded video data.
- the probability models are transmitted or stored, as needed, with each block unit of encoded video data so that the encoded video data can be decoded at a decoder.
- the probability models encode the units of information using bitwise arithmetic coding (BAC) which calculates the probabilities for each non-zero bit in the pulse vectors to be coded to be 1 when the pulse vector is represented in binary in order to find model probabilities for the most efficient code length.
- BAC bitwise arithmetic coding
- Method encodes one set of occupied positions in pulse magnitude information from the pulse vector based on the number of non-zero positions and then sets statistical parameters using adaptive arithmetic coding. Additionally, bitwise arithmetic is used to encode each non-zero position.
- the statistical probabilities of each frame are adapted based on how many positions of the pulse vectors are occupied with non-zero values. Statistical probabilities are updated for each frame.
- factorial pulse coding is utilized to generate codes for the magnitude of each non-zero position in a block based on factorial calculations.
- Fixed codeword lanes and codewords are produced for set of (n, m) values. Since video coding residual blocks are not i.i.d, like audio coding data, each frame block you have very different statistical parameters associated with average values and probabilities with respect to the number of, location of, magnitude of, position of and sign of each non-zero position of the pulse vectors.
- coding position information is well known
- various novel encoder embodiments of the invention use arithmetic coding for simultaneous position and magnitude coding. Coding the last non-zero position is accomplished using a determination or “end of block” code.
- This new method uses a specialized version of arithmetic coding for coding positions where probabilities are adapted in each frame of data based on how many previously coded positions were occupied or unoccupied. The adapted probabilities are precomputed on a frame by frame basis via a trellis, which may be referred to as a “probability matrix” rather than using an explicit termination code, embodiments provide a process that completes when the number of non-zero positions are exhausted. Such embodiments provide lossless encoded video data they can be transmitted at a lower data rate or stored using less memory space than previous digital video encoding techniques.
- this method and system for coding pulse vectors using statistical properties provides improved methods for coding an ensemble of pulse vectors utilizing statistical models (i.e., probability models) for the ensemble of pulse vectors, to more efficiently code each pulse vector of the ensemble.
- at least one pulse parameter describing the non-zero pulses of a given pulse vector is coded using statistical models and a number of non-zero pulse positions for the given pulse vector.
- a number of non-zero pulse positions are coded using range coding.
- the total number of unit magnitude pulses may be coded using conditional (state driven) bitwise arithmetic coding.
- Non-zero pulse position locations may be coded using adaptive arithmetic coding. Additionally, non-zero pulse position magnitudes may be coded using probability-based combinatorial coding, and the corresponding sign information may be coded using bitwise arithmetic coding. Such embodiment methods and systems are well suited for coding non-independent-identically-distributed signals, such as coding video information. It should be understood that the drawings and detailed description herein are to be regarded in an illustrative rather than a restrictive manner, and are not intended to be limiting to the particular forms and examples disclosed.
Abstract
Description
where x={x0, x1, . . . , xn-1} is a quantized signal vector containing integer values, n is the vector length, and m is the total number of unit magnitude “pulses” within vector x, such that all vector elements are within the range −m≤xi≤m. It has been found that the total number of unique pulse combinations N in a video frame arising from Eq. 1 is:
D(m, k) is the number of combinations that m unit magnitude pulses can fall on k non-zero vector elements, (where k≤m):
and 2k is the number of unique sign combinations for the k non-zero vector positions. Given the total number of combinations N, and that each of the N combinations is equiprobable, then the total number of bits M required to code the vector sequence x is:
M=log2(N).
For this expression, n is the length of the pulse vector xk, which for a 4×4 block size, is 16. In order to effectively range code np(k), the probabilities P of a particular non-zero element np(k) occurring are calculated, which can be expressed as:
where N is the number of vectors (blocks) in the ensemble of vectors being evaluated (for example, corresponding to the number of blocks in a frame), np(k) is the number of non-zero positions in the k-th vector (block), and j is the bit index of the pulse vector xk. From these expressions, the number of bits per block Mp for encoding np(k) can be estimated as:
where Nb is the maximum number of bits to be coded, j is the bit index, mk is the number of unit magnitude pulses for the k-th vector (block), and N is the total number of vectors (blocks) to be coded, for example, in a frame or macro block. Also, the “&” symbol represents the bitwise AND operator. For the above expression, Pm(j) represents the probability that the j-th bit position of the value mk is set to one. This probability can be used to losslessly code the array of mk values for use in signal compression.
where c1(np(k),j) is the number of times the j-th bit of the number of pulses m′k parameter is set (for a given np(k)), np(k) is the number of non-zero positions in xk, and c2(np(k)) is the number of instances in which xk contains np(k) non-zero positions. The expression defines an n×Nb size matrix that gives the probability of a particular bit of mk(i) being set for a given predetermined number of occupied positions np(k). The above process is shown in in flow chart form in
TABLE 1 |
Comparison of coding methods for lossless compression of the ‘m’ |
parameter in 4 × 4 WHT blocks (360 frames, original content resolution |
352 × 288) |
Luminance | Chrominance | ||
Vector | Average number of non-zero | 12.408 | 10.073 |
statistics | positions np | ||
Average number of unit | 87.4 | 29.2 | |
magnitude pulses m | |||
Maximum number of unit | 1528 | 655 | |
magnitude pulses mmax | |||
Coding rate | Simple scalar quantization | 11 | 10 |
(average bits | Traditional binary arithmetic | 7.611 | 6.011 |
per block) | coding (BAC) | ||
BAC + (m − np) coding | 7.246 | 5.132 | |
+Conditional BAC | 6.449 | 4.452 | |
+State driven CBAC | 6.350 | 4.393 | |
Conditional BAC | 6.800 | 5.042 | |
+State driven CBAC | 6.515 | 4.742 | |
+(m − np) coding | 6.350 | 4.393 | |
where N is the total number of vectors in the probability ensemble (e.g., the frame or portion of a frame,) and n is the vector length. Next, if the probability of j non-zero values falling on the remaining n−i positions of vector xk is set to be P(T(n−i,j)), then the overall probability can be denoted as P(xk(i)|T (n−i,j)). Again, this is the probability of element xk(i) being non-zero, given j non-zero valued elements over the remaining n−i positions of vector xk. In some embodiments the probability of the i-th element of input vector xk being occupied by a non-zero value is determined by the encoder block via probability calculations, while in other embodiments, these probabilities are received from functional blocks associated with the encoder block.
where the matrix elements P(T(i, j)) represent the probabilities from using a trellis matrix of having j non-zero elements on the remaining i positions of vector xk. Further, the matrix elements can be defined as:
P(T(0,0))=1, (1.9a)
P(T(1,0))=1−P(x k(n−1)), (1.9b)
P(T(1,1))=P(x k(n−1)), (1.9c)
P(T(2,0))=(1−P(x k(n−1)))·(1−P(x k(n−2))), (1.9d)
P(T(2,1))=P(x k(n−1))·(1−P(x k(n−2)))+(1−P(x k(n−1)))·P(x k(n−2)), (1.9e)
P(T(2,2))=P(x k(n−1))·P(x k(n−2)), (1.90f)
and so on. As may be apparent, a recursive relationship can be formed as follows:
P(T(2,0))=(1−P(x k(n−2))·P(T(1,0)), (1.10a)
P(T(2,1))=P(x k(n−2))·P(T(1,0))+(1−P(x k(n−2)))·P(T(1,1)), (1.10b)
P(T(2,2))=P(x k(n−2))·P(T(1,1)), (1.10c)
which can be generalized as:
where it is implied that P(xk(i)≠0)=P(xk(i)). From this expression, the trellis diagram of
and thereby reducing the per vector probability computations to:
P(x k(i)≠0|T(n−i,j))=T′(n−i,j)·P(x k(i)) (1.15a)
and
P(x k(i)=0|T(n−i,j)=1−T′(n−i,j)·P(k k(i)) (1.15b)
TABLE 2 |
Comparison of methods for position coding in 4 × 4 WHT blocks |
(360 frames, lossless compression, original content resolution 352 × 288) |
Luminance | Chrominance | ||
Vector | Average number of non-zero | 12.408 | 10.073 |
statistics | positions np | ||
Coding rate | FPC position coding | 7.231 | 10.064 |
(average bits | Adaptive conditional | 6.667 | 9.388 |
per block) | arithmetic coding | ||
x′≡{|x k|>0}, (1.16)
such that x′≡{x′0, x′1, . . . , x′n
x′≡{|x k|>0}, (1.16)
such that x′≡{x′0, x′1, . . . , x′n
where F(m, j) is the combinatorial expression given in Eq. 3. The corresponding length (in bits) of the magnitude codeword (from Eq.4) is then given by:
L=log2(F(m k−1,n p(k)−1) (1.18)
where mk and np(k) are the number of unit magnitude pulses and number of non-zero vector elements, respectively, for vector index k, as defined and discussed above.
where, as also discussed above, N is the number of vectors (or scanned video blocks) per frame, and n is the vector length. It can be statistically inferred that if all xk(i) are independent and identically distributed (i.i.d.), then their respective expected absolute values are equivalent, and that their sampled mean absolute values μi are approximately equal. However, if the mean absolute values μi are significantly different across all values of 0≤i<n, then all possible combinations of the magnitude vector x′ (and therefore, the codeword (C)) are not equally likely. In this case, the bits for coding C are not fully utilized, and are therefore not 100% efficient. To circumvent this problem, the length of the combinatorial codeword C should be smaller for vectors that are more likely, and should be larger for vectors that are less likely. The following describes a method for accomplishing this objective.
where aj≤m (defined as the adaptive pulse count) and bj (defined as the adaptive shift count) are obtained adaptively based on the partially coded vector and the sampled absolute mean values. If aj=m and bj=0, then this expression is equivalent to Eq.1.17. As we typically start coding with j=np−1, and work down to j=1, (and then rearranging the terms on the right) we get:
So we will now describe a process for adapting aj and bj using some function of the sampled absolute mean values μi, such that the average length of codeword C is reduced.
where s and t define the start and end components of the sub-vectors to be analyzed. In the following expression, the functions are used to generate the adaptive pulse count aj as:
where Δ is a fixed pre-determined positive constant. In the above equation, μ′j corresponds to the mean absolute value for the j-th element of vector x′. That is, the vector μ′, which was also determined and input from the accumulated parameters for N pulse vectors in step 100 with vector x′, contains the values of vector μ, that correspond to the non-zero elements of vector xk. In experimentation, Δ=3 was chosen. One of ordinary skill in the art may choose other values for Δ in various embodiments of VPFC. It should be noted that when all values of μ′ are equal then aj in Eq.1.23 is equal to m−Δ. However, for optimum performance of some embodiments, aj should be m. In this example scenario of an embodiment (when all mean values are equal), it is preferable to choose Δ=0.
It can be observed that if we have sorted absolute means, i.e., μ′0≥μ′1≥ . . . ≥μ′n
F(a j −β,j)≥2−s ·F(a′ j −β,j) (1.26)
C j=2−b
L=b 1 log2(F(a n
Since b1 is not fixed and is dependent on the coded sequence and the mean value vector, the method generates a variable length codeword. The corresponding decoder process is complementary to the encoder process.
where Iq is an indicator function which is 1 if q is true otherwise it is 0, where q is the value of xk(i)≠0. The mean value of the i-th component can now be computed as:
TABLE 3 |
Showing comparison average number of bits needed by VFPC vs. |
Regular FPC for coding magnitudes with components mean values |
μi = g0 · γ(i−1) |
g0 | γ | FPC | VFPC Bits | ||
25 | 0.70 | 46.24 | 41.25 | ||
25 | 0.79 | 56.45 | 52.27 | ||
7.9 | 0.99 | 71.34 | 72.08 | ||
Claims (15)
Priority Applications (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US14/460,440 US9990931B2 (en) | 2014-08-15 | 2014-08-15 | Method for coding pulse vectors using statistical properties |
PCT/US2015/043938 WO2016025281A1 (en) | 2014-08-15 | 2015-08-06 | Method for coding pulse vectors using statistical properties |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US14/460,440 US9990931B2 (en) | 2014-08-15 | 2014-08-15 | Method for coding pulse vectors using statistical properties |
Publications (2)
Publication Number | Publication Date |
---|---|
US20160049156A1 US20160049156A1 (en) | 2016-02-18 |
US9990931B2 true US9990931B2 (en) | 2018-06-05 |
Family
ID=53879825
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US14/460,440 Expired - Fee Related US9990931B2 (en) | 2014-08-15 | 2014-08-15 | Method for coding pulse vectors using statistical properties |
Country Status (2)
Country | Link |
---|---|
US (1) | US9990931B2 (en) |
WO (1) | WO2016025281A1 (en) |
Families Citing this family (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US10389558B2 (en) * | 2016-10-03 | 2019-08-20 | Mediatek Inc. | Method and apparatus for synchronization |
CN109068144B (en) * | 2018-07-18 | 2021-03-12 | 北京奇艺世纪科技有限公司 | Probability estimation method and device and electronic equipment |
CN113728561B (en) | 2019-01-11 | 2023-10-13 | 联想（新加坡）私人有限公司 | Type II codebook compression using multi-level quantization |
CN114710209B (en) * | 2022-03-29 | 2024-02-13 | 浙江农林大学 | Codeable information system and method based on vector multiple period soliton pulsation |
Citations (9)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6236960B1 (en) * | 1999-08-06 | 2001-05-22 | Motorola, Inc. | Factorial packing method and apparatus for information coding |
US6662154B2 (en) | 2001-12-12 | 2003-12-09 | Motorola, Inc. | Method and system for information signal coding using combinatorial and huffman codes |
US6900748B2 (en) | 2003-07-17 | 2005-05-31 | Fraunhofer-Gesellschaft Zur Foerderung Der Angewandten Forschung E.V. | Method and apparatus for binarization and arithmetic coding of a data value |
US7230550B1 (en) | 2006-05-16 | 2007-06-12 | Motorola, Inc. | Low-complexity bit-robust method and system for combining codewords to form a single codeword |
US7461106B2 (en) | 2006-09-12 | 2008-12-02 | Motorola, Inc. | Apparatus and method for low complexity combinatorial coding of signals |
US7889103B2 (en) | 2008-03-13 | 2011-02-15 | Motorola Mobility, Inc. | Method and apparatus for low complexity combinatorial coding of signals |
US20110096830A1 (en) * | 2009-10-28 | 2011-04-28 | Motorola | Encoder that Optimizes Bit Allocation for Information Sub-Parts |
US20110156932A1 (en) * | 2009-12-31 | 2011-06-30 | Motorola | Hybrid arithmetic-combinatorial encoder |
US7978101B2 (en) | 2009-10-28 | 2011-07-12 | Motorola Mobility, Inc. | Encoder and decoder using arithmetic stage to compress code space that is not fully utilized |
-
2014
- 2014-08-15 US US14/460,440 patent/US9990931B2/en not_active Expired - Fee Related
-
2015
- 2015-08-06 WO PCT/US2015/043938 patent/WO2016025281A1/en active Application Filing
Patent Citations (11)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6236960B1 (en) * | 1999-08-06 | 2001-05-22 | Motorola, Inc. | Factorial packing method and apparatus for information coding |
US6662154B2 (en) | 2001-12-12 | 2003-12-09 | Motorola, Inc. | Method and system for information signal coding using combinatorial and huffman codes |
US6900748B2 (en) | 2003-07-17 | 2005-05-31 | Fraunhofer-Gesellschaft Zur Foerderung Der Angewandten Forschung E.V. | Method and apparatus for binarization and arithmetic coding of a data value |
US7230550B1 (en) | 2006-05-16 | 2007-06-12 | Motorola, Inc. | Low-complexity bit-robust method and system for combining codewords to form a single codeword |
US7461106B2 (en) | 2006-09-12 | 2008-12-02 | Motorola, Inc. | Apparatus and method for low complexity combinatorial coding of signals |
US7889103B2 (en) | 2008-03-13 | 2011-02-15 | Motorola Mobility, Inc. | Method and apparatus for low complexity combinatorial coding of signals |
US20110096830A1 (en) * | 2009-10-28 | 2011-04-28 | Motorola | Encoder that Optimizes Bit Allocation for Information Sub-Parts |
US7978101B2 (en) | 2009-10-28 | 2011-07-12 | Motorola Mobility, Inc. | Encoder and decoder using arithmetic stage to compress code space that is not fully utilized |
US8207875B2 (en) | 2009-10-28 | 2012-06-26 | Motorola Mobility, Inc. | Encoder that optimizes bit allocation for information sub-parts |
US20110156932A1 (en) * | 2009-12-31 | 2011-06-30 | Motorola | Hybrid arithmetic-combinatorial encoder |
US8149144B2 (en) | 2009-12-31 | 2012-04-03 | Motorola Mobility, Inc. | Hybrid arithmetic-combinatorial encoder |
Non-Patent Citations (9)
Title |
---|
Andy C. Hung et al., "Error-Resilient Pyramid Vector Quantization for Image Compression," IEEE Transactions on Image Processing, vol. 7, No. 10, Oct. 1998. |
Ashley, J.P. et al. "Wideband Coding of Speech Using a Scalable Pulse Codebook", Speech Coding, 2000, Proceedings. 2000 IEEE Workshop on Sep. 17-20, 2000, Piscataway, NJ, pp. 148-150. * |
Fishcher, T.R., "A pyramid vector quantizer", Information Theory, IEEE Transactions on (vol. 32, Issue: 4, Jul. 1986, pp. 568-583. |
Hung, A.C. et al.: Multidimensional rotations for robust quantization of image data, Image Processing, IEEE Transaction on (vol. 7, Issue 1, Jan. 1998, all pages. |
International Preliminary Report on Patentability from PCT/US2015/043938, mailed, Mar. 2, 2017, 11 Pages. |
International Search Report and Written Opinion from PCT/US2015/043938, mailed Nov. 17, 2015, 13 pages. |
UDAR MITTAL ; TENKASI V RAMABADRAN ; JAMES P ASHLEY: "Coding pulse sequences using a combination of factorial pulse coding and arithmetic coding", SIGNAL PROCESSING AND COMMUNICATIONS (SPCOM), 2010 INTERNATIONAL CONFERENCE ON, IEEE, PISCATAWAY, NJ, USA, 18 July 2010 (2010-07-18), Piscataway, NJ, USA, pages 1 - 5, XP031744814, ISBN: 978-1-4244-7137-9 |
Udar Mittal et al. "Coding Pulse Sequences Using a Combination of Factorial Pulse Coding and Arithmetic Coding," Signal Processing and Communications, 2010 International Conference on, IEEE, Piscataway, NJ, Jul. 18, 2010, XP031744814, ISBN: 978-1-4244-7137-9 Abs.,pp. 1-5. |
Udar Mittal et al. "Coding Pulse Sequences Using a Combination of Factorial Pulse Coding and Arithmetic Coding," Signal Processing and Communications, 2010 International Conference on, IEEE, Piscataway, NJ, Jul. 18, 2010, pp. 1-5. * |
Also Published As
Publication number | Publication date |
---|---|
WO2016025281A1 (en) | 2016-02-18 |
US20160049156A1 (en) | 2016-02-18 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US10515649B2 (en) | Method for coding pulse vectors using statistical properties | |
US10045034B2 (en) | System and method for using pattern vectors for video and image coding and decoding | |
CN115514978B (en) | Method and apparatus for mixing probabilities of entropy coding in video compression | |
US7126506B2 (en) | Lossless adaptive encoding and decoding of integer data | |
US7015837B1 (en) | Lossless adaptive encoding and decoding of integer data | |
US10009611B2 (en) | Visual quality measure for real-time video processing | |
US20130089137A1 (en) | Rate distortion optimization in image and video encoding | |
US9990931B2 (en) | Method for coding pulse vectors using statistical properties | |
US20230106778A1 (en) | Quantization for Neural Networks | |
EP1653746A2 (en) | Lossless adaptive encoding and decoding of integer data | |
US9584833B2 (en) | Method for coding pulse vectors using statistical properties | |
US9620136B2 (en) | Method for coding pulse vectors using statistical properties | |
US20140133552A1 (en) | Method and apparatus for encoding an image | |
US11645079B2 (en) | Gain control for multiple description coding | |
US20160323603A1 (en) | Method and apparatus for performing an arithmetic coding for data symbols |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: MOTOROLA MOBILITY LLC, ILLINOISFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:MITTAL, UDAR;ASHLEY, JAMES P.;REEL/FRAME:033542/0315Effective date: 20140814 |
|
AS | Assignment |
Owner name: GOOGLE TECHNOLOGY HOLDINGS LLC, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:MOTOROLA MOBILITY LLC;REEL/FRAME:035593/0001Effective date: 20141028 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
CC | Certificate of correction | ||
FEPP | Fee payment procedure |
Free format text: MAINTENANCE FEE REMINDER MAILED (ORIGINAL EVENT CODE: REM.); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
LAPS | Lapse for failure to pay maintenance fees |
Free format text: PATENT EXPIRED FOR FAILURE TO PAY MAINTENANCE FEES (ORIGINAL EVENT CODE: EXP.); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
STCH | Information on status: patent discontinuation |
Free format text: PATENT EXPIRED DUE TO NONPAYMENT OF MAINTENANCE FEES UNDER 37 CFR 1.362 |
|
FP | Lapsed due to failure to pay maintenance fee |
Effective date: 20220605 |