EP3158466A1 - Real-time saved-query updates for a large graph - Google Patents
Real-time saved-query updates for a large graphInfo
- Publication number
- EP3158466A1 EP3158466A1 EP15729035.4A EP15729035A EP3158466A1 EP 3158466 A1 EP3158466 A1 EP 3158466A1 EP 15729035 A EP15729035 A EP 15729035A EP 3158466 A1 EP3158466 A1 EP 3158466A1
- Authority
- EP
- European Patent Office
- Prior art keywords
- constraint
- query
- target
- node
- state
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Granted
Links
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/24—Querying
- G06F16/245—Query processing
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/24—Querying
- G06F16/245—Query processing
- G06F16/2455—Query execution
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/95—Retrieval from the web
- G06F16/951—Indexing; Web crawling techniques
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/23—Updating
- G06F16/2393—Updating materialised views
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/24—Querying
- G06F16/245—Query processing
- G06F16/2453—Query optimisation
- G06F16/24534—Query rewriting; Transformation
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/901—Indexing; Data structures therefor; Storage structures
- G06F16/9024—Graphs; Linked lists
Definitions
- Graph-based knowledge bases represent factual information about the world.
- entities such as people, places, phrases, words, classes, facts, things, concepts, etc.
- the basic unit of such a data graph can be a triple that includes two nodes, or entities, and an edge label.
- the first node is sometimes referred the source or subject node
- the second node is sometimes referred to as the target or object node.
- a triple may include additional information, such as metadata about the entities and/or the relationship, in addition to identifying the subject, predicate, and object.
- a collection or query defines constraints a node must satisfy to be a member of the set of nodes responsive to the query.
- the constraints usually specify what relationship(s) a node must have or not have to be a member of the query results, e.g., a member of the collection.
- queries i.e., collections
- membership is often stored because calculating membership can be expensive in a large graph. But as nodes and relationships are added or deleted from the graph, the saved members can become stale, especially in large graphs that are frequently updated.
- Some implementations enable a system to update saved query results in real-time as edges are updated, e.g., as triples are added to or deleted from the graph-based data store.
- Real-time can include a short delay (e.g., less than one minutes), to allow the system to group updates by the source node of the triple.
- Queries may be defined by constraints, which identify properties or relationships a node must have (or not have) in the graph to qualify as a result for the saved query.
- a saved query may be defined by a constraint expression, which is a series of constraints joined by logical operations, in other words a Boolean expression of constraints.
- the system may include an index of constraints that is indexed by edge. The system may use the index to determine which constraints match the edge from an updated triple, thus identifying target constraints for that triple. The system uses the target constraints to efficiently determine which stored query results are affected by the update, and whether the update results in a change to the results. By grouping updates by subject, the system may re-use work, e.g., forward and backward walks in the graph, in identifying and evaluating query results affected by the updates.
- One aspect of the disclosure can be embodied in a system that includes at least one processor and one or more memories.
- the one or more memories may store a data graph that includes nodes connected by edges and a plurality of saved queries, each query defined by one or more constraints to be satisfied for membership in query results for the query, each constraint specifying an at least one of the edges.
- the one or more memories may also store instructions that, when executed by the at least one processor, cause the computer system perform operations.
- the operations may include identifying a target constraint responsive to an operation that updates the data graph with a source node, an update edge, and a target node, the target constraint specifying a path that includes the update edge and the target constraint belonging to a first saved query of the plurality of saved queries.
- the operations may also include evaluating the target constraint for a member node to determine a state for the target constraint by traversing the graph via the path of the target constraint, determining whether a collapsed definition for the first saved query, based on the state, indicates the member node is responsive or not responsive to the first saved query, and updating a saved query result of the first saved query with the member node in accordance with the collapsed definition when the collapsed definition indicates the member node is responsive or not responsive.
- the target constraint may be a first target constraint and the operations may also include identifying a second target constraint belonging to the first saved query, the second target constraint specifying a path including the update edge, the second target constraint having a path length longer than a path length of the first target constraint, and setting a state for the second target constraint to a state indicating the second target constraint is unresolved.
- the state may be a first state and the operations may also include determining that a collapsed definition for the first saved query, based on the first state, fails to indicate whether the member node is responsive or not responsive to the first saved query, evaluating the second target constraint for the member node to determine a second state for the second target constraint by traversing the graph via the path of the second target constraint, determining whether the collapsed definition for the first query, based on the first state and the second state, indicates the member node is responsive or not responsive to the first saved query, and updating the saved query result of the first saved query with the member node according to the collapsed definition when the collapsed definition indicates the member node is responsive or not responsive.
- the one or more memories may also store an index of the constraints by edge, the index being used to identify the target constraint.
- the operations may also include storing results of the traversal of the data graph and using the stored results to evaluate a second target constraint that specifies a path that includes the path of the target constraint.
- the update may be a first update and the operations may include storing results of the traversal of the data graph and deleting the stored results when a subsequent update to the data graph includes a source node that differs from the source node of the first update.
- the target constraint may be a first target constraint and the state may be a first state and the operations may include storing a result of the traversal of the graph in the memory, identifying a second target constraint for the first query, the second target constraint having a path that includes the path of the first target constraint, and using the stored result of the traversal in evaluating the second target constraint to determine a second state for the second target constraint.
- the operations may further include determining whether the collapsed definition for the first saved query, based on the first state and the second state, indicates the member node is responsive or not responsive to the first saved query and updating the saved query result of the first saved query with the member node according to the collapsed definition when the collapsed definition indicates the member node is responsive or not responsive.
- the target constraint may be a first target constraint and the operations may also include identifying a plurality of target constraints, the first target constraint being one of the plurality of target constraints, the plurality of target constraints being for at least two queries, and the first saved query being one of the at least two queries.
- the operations may also include intelligently evaluate the plurality of target constraints to delay traversals for target constraints with longer path lengths.
- a computer-implemented method includes identifying, using at least one processor, a target constraint, the target constraint specifying a path in a data graph that includes an edge specified in an update to the data graph, the identifying being triggered by the update, and determining, using the at least one processor, a state for the target constraint by traversing the graph via the path.
- the method also includes determining, based on the state, that a collapsed definition for a first query that includes the constraint indicates a member node is responsive to the first query, and updating a saved query result for the first query using the member node identified during the traversal in accordance with the collapsed definition.
- the target constraint is identified using an index of a plurality of constraints, the index being organized by edge.
- updating the saved query result in accordance with the collapsed definition includes adding the member node to the saved query result.
- updating the saved query result in accordance with the collapsed definition includes maintaining the saved query result.
- the target constraint may be a first target constraint and the method further includes identifying a second target constraint belonging to the first query, the second target constraint specifying a path including the update edge, the second target constraint having a path length longer than a path length of the first target constraint and setting a state for the second target constraint to a state indicating that the second target constraint is unresolved.
- the state may be a first state and the method further includes determining that collapsed definition for the first query, based on the first state, fails to indicate whether the member node is responsive or not responsive to the first query, evaluating the second target constraint for the member node to determine a second state for the second target constraint by traversing the graph via the path of the second target constraint, determining that the collapsed definition for the first query, based on the first state and the second state, indicates the member node is responsive to the first query, and updating the saved query result of the first query with the member node according to the collapsed definition.
- the target constraint may be a first target constraint and the state may be a first state and the method also includes storing a result of the traversal of the graph, identifying a second target constraint for the first query, the second target constraint having a path that includes the path of the first target constraint, and using the stored result of the traversal in evaluating the second target constraint to determine a second state for the second target constraint.
- determining that the collapsed definition for the first query indicates the member node is responsive to the first query is based on the first state and the second state.
- the method may also include grouping a plurality of updates to the data graph by source node, the plurality of updates occurring within five minutes of each other and the update to the data graph being one of the plurality of updates, wherein identifying the target constraint occurs in real-time after the grouping.
- a method in another aspect, includes identifying, using at least one processor, a target constraint, the target constraint specifying a path in the data graph that includes the update edge responsive to an operation that updates a data graph with a source node, an update edge, and a target node.
- the method also includes determining, using the at least one processor, a state for the target constraint by traversing the graph via the path, determining that a collapsed definition, based on the state, for a first query that includes the constraint indicates a member node is not responsive to the first query, and updating a saved query result for the first query using the member node identified during the traversal in accordance with the collapsed definition.
- the update is removal of the update edge between the source node and the target node and updating the saved query result in accordance with the collapsed definition includes removing the member node from the saved query result.
- the update is an addition of the update edge between the source node and the target node and updating the saved query result in accordance with the collapsed definition includes maintaining the saved query result.
- a computer program product embodied on a non-transitory computer-readable storage device includes instructions that, when executed by at least one processor formed in a substrate, cause a computing device to perform any of the disclosed methods, operations, or processes.
- Another general aspect includes a system and/or a method for updating saved query results in real time, substantially as shown in and/or described in connection with at least one of the figures, and as set forth more completely in the claims.
- the system may update saved query results in real-time, meaning that the process to update saved query results begins within a few minutes of the update, and are triggered by the update, rather than waiting for a periodic, offline batch process to update the memberships. Implementations are able to quickly and efficiently evaluate target constraints, making the real-time updates to saved query results possible. In other words, the system minimizes the quantity of additional lookups required to maintain correct results of the saved queries by using information in the graph update to identify a minimum number of additional constraints in affected queries to evaluate and grouping graph updates together to reuse the result of previous work. Other features will be apparent from the description and drawings, and from the claims.
- FIG. 1 illustrates an example system in accordance with some implementations .
- FIG. 2 illustrates a representation of an example data graph, with entities as nodes and relationships as edges between nodes.
- FIG. 3 illustrates an example of saved queries and a query edge index, consistent with disclosed implementations.
- FIG. 4 illustrates a flow diagram of an example process for efficiently updating query membership in real-time, consistent with disclosed implementations.
- FIG. 5 illustrates a flow diagram of an example process for intelligently evaluating constraints after an edge is added to the graph, consistent with disclosed implementations.
- FIG. 6 illustrates a flow diagram of an example process for intelligently evaluating constraints after an edge is deleted from the graph, consistent with disclosed implementations.
- FIG. 7 illustrates an example of updating query membership in realtime after deleting an edge in the data graph of FIG. 2.
- FIG. 8 illustrates an example of updating query membership in realtime after adding an edge in the data graph of FIG. 2.
- FIG. 9 shows an example of a computer device that can be used to implement the described techniques.
- FIG. 10 shows an example of a distributed computer device that can be used to implement the described techniques.
- FIG. 1 is a block diagram of a system 100 in accordance with an example implementation.
- the system 100 updates saved query results in real-time in response to edge updates in a data graph.
- the system of FIG. 1 is one example implementation and other configurations and applications may be used. While the system 100 can be used to keep stored query results fresh in any data graph, the system 100 is especially useful for large graphs as the processing time to determine query results in such graphs is often cost-prohibitive and time-prohibitive.
- the system 100 may be a computing device or devices that take the form of a number of different devices.
- the system 100 may be a standard server, a group of such servers, a client-server system, or a rack server system.
- system 100 may be implemented in a personal computer.
- the system 100 may be an example of computer device 900, as depicted in FIG. 9, or computer device 1000, as depicted in FIG. 10.
- the system 100 may include a graph engine 110 and a saved query engine 150.
- graph engine 110 and saved query engine 150 may each be a separate computing device, or they may share components, such as processors and memories.
- the graph engine 110 and the saved query engine 150 may be implemented in a personal computer, a server, one or more logical partitions of a computer, etc.
- one or more of the graph engine 110 and the saved query engine 150 may be distributed systems implemented in a series of computing devices, such as a group of servers, such as computer device 1000, as depicted in FIG. 10.
- the system 100 may include a graph-based data store 190.
- a graph- based data store is a data graph that stores information in the form of nodes and edges, with nodes being connected by edges.
- a node in a data graph may represent an entity, such as a person, place, item, word, phrase, idea, topic, abstract concept, concrete element, other suitable thing, or any combination of these, or a property of an entity. Nodes may thus be referred to as entities and vice-versa. Entities in the graph may be related to each other by edges, which may represent relationships between entities.
- the data graph may have an entity that corresponds to Abraham Lincoln and the data graph may have an occupation relationship between the Abraham Lincoln entity and a President entity and another such relationship between the Abraham Lincoln entity and a Lawyer entity.
- An indexing engine may maintain the graph-based data store 190 to allow a search engine to search the data graph, for example finding entities related to other entities by one or more relationships or paths in the graph.
- the indexing engine and/or the search engine may be included in the graph engine 110.
- the graph-based data store 190 may include an index or some other method for searching for and retrieving data from the data store.
- the graph-based data store 190 may include information from which a graph, such as the graph 200 illustrated in FIG. 2, can be created.
- a graph such as the graph 200 illustrated in FIG. 2
- reference to a data graph may be considered reference to the index for the data graph and vice versa.
- the nodes of the data graph may be referred to as entities and the edges may be referred to as relationships between two entities.
- entity may refer to a physical embodiment of a person, place, or thing or a representation of the physical entity, e.g., text, or other information that refers to an entity.
- an entity may be the physical location of France or an abstract concept that refers to France.
- the graph engine 110 may include a user interface that allows users, for example users of client 170, to search, update, and otherwise maintain the information in the graph-based data store 190.
- the graph engine 110 may also include batch or off-line processes that update the graph-based data store 190.
- the graph engine 110 may be a separate computing device with its own hardware processor 113 and memory 114, or it may share one or more hardware processors and memories with other components of system 100.
- the system 100 may also include saved queries 140.
- a query is defined by a constraint expression, which may be one constraint or a Boolean expression of constraints.
- a constraint expression defines a query and, thus, may be referred to as a query or collection definition.
- the constraint expression represents conditions an entity in the graph-based data store 190 must satisfy to be considered responsive to the query and included in query results, i.e., as a member of the query results. In this sense, the query may be thought of as a collection and the entities responsive to the query members of the collection.
- saved queries 140 may be referred to as saved collection memberships.
- a constraint is associated with a path in the graph.
- the path often has a length of one, but may have a longer length.
- a node meeting this constraint would be a node connected to a first target node by an alumni relationship, the first target node connected to a second target node by a parent relationship, and the second target node being connected to a President node by an occupation relationship.
- Constraints may be combined into a constraint expression using other logical operators, such as and (&&), or (
- the system 100 may optionally include query edge index 145.
- the query edge index 145 may index constraints in the saved queries 140 by edge.
- the query edge index 145 may improve processing time in determining which saved queries are potentially affected by an update to the graph-based data store 190, but the system 100 may also just read constraints from the saved queries 140 to determine which saved queries are potentially affected.
- FIG. 3 illustrates an example of information that may be stored in saved queries 140 and a query edge index 145, consistent with disclosed
- the saved queries 340 may include a query identifier 305, which may include a name for the query.
- Each query may be defined by one or more constraints 310, which may be combined into a constraint expression 315 using logical operators.
- Query Q 1 illustrates a constraint that does not specify a target node.
- Query Q5 illustrates a saved query with only one constraint in the constraint expression.
- FIG. 3 also illustrates example query edge index 345.
- the query edge index 345 is optional, and implementations may not include query edge index 345.
- the query edge index 345 stores the constraints for each saved query by edge. Thus, for example, there is an occupation entry in the query edge index 345.
- the system may use query edge index 345 to quickly identify all saved queries and target constraints from the saved queries potentially affected by the update.
- the system may inspect the saved queries 340 to obtain the same information.
- the system 100 also includes saved query results 160.
- the saved query results 160 identify entities in the graph-based data store 190 that are responsive to the queries identified in saved queries 140. While it is not necessary for each saved query to have corresponding members in the saved query results 160, due to the length of processing time to determine query results for all nodes in a large data graph, many, if not all, queries in saved queries 140 have associated results saved in the saved query results 160. The system can thus determine membership in a query result using the entire graph-based data store 190 once and update the membership as updates to the graph-based data store 190 occur.
- the saved query results 160 may have various formats.
- each saved query may be represented as a node in the graph-based data store 190 and entities responsive to a saved query may share an edge with the node for the saved query.
- the saved query results 160 may be a subset of the graph-based data store 190. Such an implementation is illustrated in the graph 200 of FIG. 2 as the First Families node and the edges connecting the node to other nodes in the graph 200.
- the saved query results 160 may be a file or database relating a query identifier with identifiers of nodes that are responsive to the query (e.g. a saved query result).
- the graph-based data store 190, saved query results 160, saved queries 140, and query edge index 145 are stored on tangible computer-readable storage devices, for instance disk, flash, cache memory, or a combination of these, configured to store data in a semi-permanent or non-transient form.
- the graph-based data store 190, saved query results 160, saved queries 140, and query edge index 145 may be stored in a combination of various memories, and/or may be stored in a distributed manner across multiple physical or logical computing devices.
- the system 100 may include a saved query engine 150.
- the saved query engine 150 may include one or more hardware processors 153 configured to execute one or more machine executable instructions or pieces of software, firmware, or a combination thereof to receive saved queries 140 and update the saved query results 160 as the graph-based data store 190 is updated.
- the saved query engine 150 may have its own processor and memory or it may share one or more processors and memories with other components of system 100.
- the saved query engine 150 may collect updates to the graph-based data store 190, use the updates to identify saved queries impacted by the updates, and modify the saved results (e.g., the membership) of impacted queries, if needed.
- the saved query engine 150 may store and reuse results of graph lookups.
- the saved query engine 150 may store the results of previous graph lookups in temporary lookup results 147.
- the previous lookups may be stored by source node, e.g., the node from which the lookup started.
- a graph lookup is a forward or backward walk in the graph, starting from the source node, following all possible paths that meet the lookup criteria. Because walks in the graph can be time consuming, saving walks related to an updated edge for reuse can significantly improve the performance of the saved query engine 150 in determining updates to the saved query results 160.
- the temporary lookup results 147 may be deleted when the source node for an update changes. Thus, in an implementation where the system groups updates by source node, the previous lookups can be used across updates.
- the saved query engine 150 may include a saved query user interface (UI) that receives query definitions, for example from a client 170.
- the saved query engine 150 may use the graph-based data store 190 to determine saved query results for the newly entered saved query in an offline manner.
- UI saved query user interface
- the system 100 may also include other components not illustrated for brevity.
- the system 100 may include an indexing engine to create and maintain graph-based data store 190.
- the indexing engine may obtain content from, for example, one or more servers, and use the content to maintain graph-based data store 190.
- the servers may be web servers, servers on a private network, or other sources that are accessible by the indexing engine.
- the indexing engine may be one or more separate computing devices and, in some implementations, the graph engine 110 may include an indexing engine for the graph- based data store 190.
- the system 100 may also include a search engine that uses the graph-based data store 190 to determine search results for queries using conventional or other information retrieval techniques. In some implementations, the search engine may also use saved query results 160 to determine search results.
- the system 100 may be in communication with the client(s) 170 over network 180.
- Network 180 may be for example, the Internet or the network 180 can be a wired or wireless local area network (LAN), wide area network (WAN), etc., implemented using, for example, gateway devices, bridges, switches, and/or so forth.
- LAN local area network
- WAN wide area network
- the graph engine 110 and/or the saved query engine 150 may communicate with and transmit data to/from clients 170.
- FIG. 4 illustrates a flow diagram of an example process 400 for efficiently updating saved query results in real-time, consistent with disclosed implementations.
- the process 400 may be performed by a system, such as system 100 of FIG. 1.
- the system may use process 400 to update saved query results in real-time, as updates occur to the graph-based data store, rather than waiting for a periodic batch or offline update process. This enables the system to avoid staleness in the stored query memberships.
- process 400 may be performed by a saved query engine.
- Process 400 may begin with the system receiving a graph update that identifies a source node, an edge, and a target node (405).
- the system may receive several graph updates and group the updates by source node, so that all updates involving the same source node are grouped together. For example, rather than running immediately after an update to the graph occurs, the system may have a short delay, for example up to one minute, in which to collect updates. This way the system can take advantage of several updates that involve the same source node.
- the system may select one or more of the updates in the grouped updates for processing. For example, for updates that involve the same source node the system may perform process 400 in parallel.
- the system may then identify constraints potentially affected by the update, also referred to as target constraints (410).
- a target constraint is a constraint specifying a path that includes the edge identified in the updated triple.
- the system may determine a state for each of the target constraints (415).
- the state of a constraint is TRUE, FALSE, and UNKNOWN.
- a state of TRUE indicates that there is at least one way of satisfying the constraint in the graph-based data store. For example, if a node in the graph-based data store satisfies the constraint using the added edge or satisfies the constraint even after the edge is deleted the constraint is satisfied.
- the constraint is a negation
- the absence of a subgraph despite an added edge may satisfy the constraint.
- the backward lookup may mean that the constraint has a state of TRUE for more than one node. This will be explained in more detail with regard to FIGS. 7 and 8.
- a state of FALSE for an edge means that the updated edge does not satisfy the constraint.
- a state of UNKNOWN indicates that additional lookups are needed.
- the system may defer a graph-lookup for a constraint that has multiple hops for efficiency, e.g., if the constraint is one of a string of constraints connected by OR operators and other constraints have shorter paths or saved lookup results.
- multi-hop graph lookups are expensive, deferring longer graph lookups in longer-path constraints when the constraints are disjunctively combined with shorter-path constraints may save processing time.
- query Q2 includes three constraints combined disjunctively (e.g., with the OR operator). The first two constraints involve a path length of two, while the last involves a path length of three. If the source node of the added edge causes the first constraint to be TRUE, a lookup of the longer path is not needed.
- the system may set the state of the constraint with the longer path to UNKNOWN and only perform the lookup if the graph lookup fails to match one of the first two constraints.
- the system may use an intelligent selection process, such as process 500 of FIG. 5 or process 600 of FIG. 6.
- the system may look up the query definition for a saved query for at least one of the target constraints and collapse the constraint expression for the query (420).
- collapsing the query definition of C2 using the example above would look like (TRUE
- the collapsed query definition of C2 resolves to TRUE because one constraint in a disjunction of constraints is TRUE.
- the system may determine whether the collapsed constraint expression resolves to TRUE or FALSE (425). As demonstrated above, this may occur when one constraint in series of disjunctive constraints is TRUE. In this case, the system does not need to evaluate other constraints because one constraint having a TRUE state is enough to make the constraint expression TRUE. Likewise, if one constraint in a series of conjunctive constraints is FALSE, the system need not evaluate the other constraints. If the constraint expression does not resolve to either TRUE or FALSE (425, No), the system may select one or more of the unresolved constraints in the constraint expression and determine a state for the unresolved constraints (440).
- the system may use an intelligent selection process, such as process 500 of FIG. 5 or process 600 of FIG. 6.
- the system may then collapse the constraint expression (420) using the state(s) determined for one or more of the constraints.
- Steps 420 to 440 thus represent an iterative evaluation of constraints, graph lookups, and collapsing the constraint expression to determine which nodes may be members of the query results affected by the graph update.
- Such an iterative process allows the system to perform minimal lookups in the graph, the reducing the processing time spent determining which saved query results are affected by a graph update.
- the system may update the stored membership for the query (430).
- the system may add the appropriate source node(s) to the saved query results if the source node(s) do not already exist in the saved results for the query.
- the system may remove the appropriate source node(s) from the saved query results, if they exist in the saved query results. Otherwise, the system may maintain the query results or, in other words, leave the query results as they are because the results are unaffected by the updated triple.
- process 400 ends, the system having updated affected saved query results in response to updates to the graph.
- FIG. 5 illustrates a flow diagram of an example process 500 for intelligently selecting and evaluating constraints after an edge is added to the graph, consistent with disclosed implementations.
- the process 500 may be performed by a saved query engine of a system as part of step 415 or 440 of FIG. 4.
- the system may use process 500 to intelligently select constraints for evaluation and to reuse graph traversals performed for other constraints to more efficiently determine changes to saved query results after an update to the graph-based data store.
- the system may run process 500 for a constraint in a constraint expression for a query that has at least one target constraint.
- Process 500 may begin by determining whether the update edge is the only edge in the constraint (505).
- a member node is a node that is a potential member of the set of nodes in the query results that includes the constraint being evaluated.
- the member target node is a node that is reached from the member node via the path specified in the constraint.
- the source node of the updated triple is the member node and the target node of the updated triple is the member target node, because any other nodes reached from the source node of the updated triple via the edge of the updated triple are not affected by the update.
- the membership doesn't change and it is not necessary for the system to re-verify this membership.
- the edge in the update is the first edge in a constraint with a path length longer than one
- the source node of the update is still the only potential member node because any graph lookups will only include forward walks in the graph from the source node in the update. In this situation, the target node of the updated triple is not the member target node.
- Member target nodes in this situation are identified by traversing the graph from the object node via the path specified in the constraint to one or more target member nodes. If the system is unable to reach at least one member target node following the path specified in the constraint, the member target node for the member node is NULL, meaning that the graph does not include a path from the member node to any other node that matches the path in the constraint.
- Member nodes are not always the source node of the added triple. For example, when the edge in the added triple is not the first edge in a path of the constraint, the graph lookup will involve a backward walk from the source node of the updated triple, and the member nodes will be one or more nodes reached on the backward walk. Member target nodes in such a situation will be nodes reached from the member nodes via the added triple, as will be explained in more detail below.
- the system may set the state of the constraint for each member node based on the traversal (550). Whether or not the member node satisfies the constraint depends on the member target node (or nodes) identified for the member node. For example, if the member node is associated with at least one member target node that satisfies the constraint, the state of the constraint is TRUE for that member node, otherwise it is FALSE.
- the member target nodes are nodes reached from the member node via the graph update (e.g., the source, edge, and target node of the graph update). This may result in the system traversing to zero, one, or more member target nodes per member node. As long as one member target node matches the constraint conditions, the state of the constraint for the member node is TRUE.
- the system may determine whether the constraint includes single edge lookups (515).
- the system may consider this a single edge lookup because the member node is Jack Doe and only a forward lookup from Jane Doe via the occupation edge is needed to identify member target node(s). If no occupation edge exists for Jane Doe the system may set the member target node to NULL. Additionally, if the edge of a graph update is the middle edge of a constraint with a path length of three, the system may consider this a single edge, e.g., a single backward edge and a single forward edge.
- the added triple fulfills the middle edge in the constraint and the system may traverse one edge from Jane Doe via the occupation edge to determine potential target member nodes and traverse the graph from the Jack Doe node via the alumni edge to determine member nodes.
- the constraint is a single edge lookup (515, Yes)
- the system may traverse the graph to identify member nodes and target member nodes (520), as just described.
- the system may save the results of a lookup in a temporary lookup table (545). This will enable the system to re-use the results of the lookup in future evaluations of other constraints.
- the system may set the state to FALSE. If the target member node(s) do include the President node, the system may set the state to TRUE. The system may pair the member node with the appropriate state, so that it can track which member nodes satisfy the constraint. Process 500 then ends for the constraint.
- the system may determine whether the constraint includes a path with stored lookup results (525). For example, the system may temporarily store results from previous graph lookups, for example in a data store such as temporary lookup results 147 of FIG. 1. This enables the system to reuse work performed for a previous constraint. This is especially efficient when the system groups updates by source node, so that saved lookups can be used across multiple updates to the graph.
- the saved lookups may include the source node, the path followed, and any target nodes arrived at via the path.
- the system may use the saved lookup results to determine member nodes and member target nodes for the constraint (530).
- member nodes are the nodes that are nodes that can potentially satisfy the constraint and, thus, are potentially responsive to the query (e.g., potential members of the set of nodes in the saved query results).
- Each saved lookup result may include a source node and any target nodes reached via the saved path from the source node.
- the source nodes in the saved lookups may be member nodes or may be used to determine member nodes, depending on the constraint. For example, if the graph update is ⁇ Bill Clinton, occupation, President>, and the constraint being evaluated is
- the forward and backward walks may themselves include more than a single lookup.
- the constraint may include a backward walk that is saved and a forward walk that is not, or vice versa.
- using the saved lookup results from a previous graph walk may include additional graph lookups to determine either member nodes or member target nodes, depending on which walk is saved.
- the system may set the state of the constraint for each member node identified, based on the traversal (550), as described above.
- the system may determine if the constraint has a lowest unresolved path length for the query definition (535).
- query Q4 of FIG. 3 includes two constraints with a path length of five and one constraint with a path length of three.
- the system may use the structure of the constraint expression to determine if the constraint has a lowest unresolved path length for a particular portion of the constraint expression.
- the expression is a disjunctive series of constraints the system may determine whether the constraint has a lowest path length of the constraints in the series of constraints. If process 500 is invoked when evaluating target constraints only (e.g., step 415 of FIG.
- the system may determine if the constraint is the shortest path length of the target constraints for a saved query, rather than the full query definition. If the system determines that the constraint has lowest path length (535, Yes), the system may traverse the graph to identify member nodes and their respective member target node(s), if any. As described above, this may include both a forward walk in the graph and a backward walk. The system may save the results of the lookup(s) made during the traversal (545) so that the results can be reused. The system may set the state of the constraint for each member node (550), as previously described.
- the system may set the state of the constraint to UNKNOWN (555). This means that the system will wait to evaluate the constraint at a later time, if such an evaluation is needed. In this manner the system may put off more complex traversals if such traversals are not necessary to resolve the responsiveness of a particular member node to a saved query.
- Process 500 as illustrated in FIG. 5 is one example of intelligently evaluating constraints.
- the system may fully evaluate each constraint as it is encountered, saving the results of any graph traversals as needed.
- the system may use saved lookups, if available (e.g., step 525 and 530), and otherwise traverse the graph (e.g., step 540) and save the results of the traversal (545), never setting a state to UNKNOWN.
- other variants may be used in optimizing constraint evaluation, e.g., always performing lookups with a length of two instead of just single lookups as part of step 515, etc.
- FIG. 6 illustrates a flow diagram of an example process 600 for intelligently selecting and evaluating constraints after an edge is deleted from the graph, consistent with disclosed implementations.
- the process 600 may be performed by a saved query engine of a system as part of step 415 or 440 of FIG. 4.
- the system may use process 600 to intelligently select constraints for evaluation and to reuse graph traversals performed for other constraints to more efficiently determine changes to saved query results after an update to the graph-based data store.
- the system may run process 600 for a constraint in a constraint expression of a saved query that has at least one target constraint.
- Process 600 may begin by determining whether the deleted edge is the only edge in the constraint (605). In other words, if the edge in the graph update matches the only edge in the constraint (605, Yes), the system can set the member node to the source node of the deleted edge and look for member target nodes (610). Unlike an added triple, the target node of the deleted triple is not a valid member target node because the edge no longer exists in the graph. Thus, the system may traverse the graph from the member node (e.g., the source node from the deleted triple) to determine if it is connected to another node by an edge that matches the constraint edge.
- the member node e.g., the source node from the deleted triple
- the system may determine whether there is another parent edge from Jack Doe to a node besides John Doe. If there is, the other node is the member target node.
- the system may set the state of the constraint for the member node based on the traversal (650). As with an addition to the graph, whether or not the member node satisfies the constraint depends on the member target node (or nodes) identified, or the failure to identify a member target node, for the member node.
- the system may determine whether the constraint includes single edge lookups (615).
- a single edge for a deleted triple includes a constraint where the edge of the deleted triple is part of a constraint with a path length of two.
- a constraint where the edge of the deleted triple is the middle edge of a constraint is not a single edge lookup. This is because the deleted triple no longer fulfills the middle edge requirement. Instead, the system needs to perform a backwards lookup to identify all the potential member nodes (if any) and do a forward lookup, following the path prescribed by the three edges, to determine any possible member target nodes.
- the system may traverse the graph to identify member nodes and target member nodes (620), as just described.
- the system may save the results of a lookup in a temporary lookup table (645). This will enable the system to re-use the results of the lookup in future evaluations of other constraints.
- the system may set the state of the constraint for each member node based on the traversal and the member target nodes identified (650). The system may pair the member node with the appropriate state, so that it can track which member nodes meet the constraint. Process 600 then ends for the constraint.
- the system may determine whether the constraint includes a path with stored lookup results (625). For example, the system may temporarily store results from previous graph lookups, for example in a data store such as temporary lookup results 147 of FIG. 1. This enables the system to reuse work performed for a previous constraint and is especially efficient when the system groups updates by source node, so that saved lookups can be used across multiple updates to the graph.
- the saved lookups may include the source node, the path followed, and any target nodes arrived at via the path. The system may delete any saved lookups when the source node of the graph updates changes.
- the system may use the target nodes of the saved lookup to determine member nodes and member target nodes for the constraint (630), as discussed above with regard to FIG. 5, except that the deleted edge cannot be used to traverse the graph.
- the system may set the state of the constraint for each member node identified and the member target node(s), based on the traversal (650), as described above.
- the system may determine if the constraint has a lowest unresolved path length for the query definition (635), as described above with regard to FIG. 5. If the system determines that the constraint has lowest path length (635, Yes), the system may traverse the graph to identify member nodes and member target node(s), as appropriate as described above with regard to FIG. 5, except that the traversal includes doing any backward walk first to identify member nodes and doing a forward walk from each member node using the path specified in the constraint to identify potential member target nodes.
- the constraint when more than one member node exists for a constraint, it is possible for the constraint to have a state of TRUE for one member node and a state of FALSE for another member node.
- the system may save the results of the backward and forward lookup(s) made during the traversal (645) so that the results can be reused.
- the system may set the state of the constraint for each member node (650), as previously described.
- the system may set the state of the constraint to UNKNOWN (655). This means that the system will wait to evaluate the constraint at a later time, if such an evaluation is needed. In this manner the system may put off more complex traversals if such traversals are not necessary to resolve the responsiveness of a particular member node to a saved query.
- process 600 as illustrated in FIG. 6 is one example and implementations may combine steps, reorder steps, perform only some steps, etc., and implementations are not limited to the order or the steps illustrated.
- FIGS. 7 and 8 illustrate an example of updating query membership in real-time using the data graph of FIG. 2 and the example saved queries 340 of FIG. 3.
- the triple ⁇ Duke, alumni, Jack Doe> of FIG. 2 is deleted from the graph 200.
- the updated triple is ⁇ Duke, alumni, JackDoe>.
- the system may update saved query results affected by the deletion in response to the update, and in some implementations the system may group updates that occur in a short period of time, for example less than 5 minutes, and then update saved query results based on the group of updates. Grouping may be done by source node of the updated triple. In either implementation, the update triggers the process of updating the saved query results. Thus, the saved query results occur in real-time.
- target constraints are constraints that include the edge identified by the deleted triple.
- the system may use an index, such as query edge index 345 of FIG. 3 to identify target constraints. For example, using the index 345 the system may find an entry for the alumni edge in the index and identify the entries for the alumni edge as target constraints.
- the system may read the saved queries 340 and look for constraints that include the alumni edge. Based on the graph 200 of FIG. 2 and the saved queries 340 and, optionally, the query edge index 345, the system may identify the target constraints 705. The system may then evaluate the target constraints. In some implementations, the system may intelligently evaluate the constraints.
- the two constraints for query Q3 each have a path length of three - thus, they are each a shortest path length for the target constraints of query Q3 and the system may traverse the graph to determine member nodes and a state of the constraint for each member node. Because the edge of the deleted triple is alumni and alumni is the first edge of each target constraint in query Q3, the member node is Duke, the source node of the deleted triple. Thus, traversing the graph for these constraints involves a forward walk in the graph from the Duke node.
- the Duke node includes only one alumni edge now that the ⁇ Duke, alumni, JackDoe> edge is deleted.
- the system follows the alumni to the John Doe node.
- the John Doe node has a parent relationship with the Jack Doe node, but the Jack Doe node does not have an occupation edge.
- the system assigns the member target node to NULL.
- the member target node of NULL fails to satisfy the constraint, so the system sets the state of the constraint to FALSE for the Duke member node. It is understood that the graph of FIG.
- the graph is an undirected graph.
- the graph may be directed, for example the parent edge may lead only from the child node to the parent node (e.g., only from Jack Doe to John Doe).
- the system would not see a parent relationship leading out from the Jack Doe node, which would still result in a member target node of NULL and a state of FALSE for this constraint.
- the system may then evaluate the second constraint for query Q3.
- the Duke node has an alumni relationship with the John Doe node, which has a spouse relationship with the Jane Doe node.
- the Jane Doe node has an occupation relationship with the President node, making the member target node President for the member node oiDuke. Because the member target node oi President matches the condition in the constraint, the system sets the state of the constraint
- the system may also evaluate the target constraints for the query Q4.
- the target constraints include two constraints with a path length of five and one with a path length of two.
- the system may set the member node to Duke, the source node of the deleted triple.
- the system may walk the graph and determine that the Duke node has an alumni relationship with another node - the John Doe node. In some implementations the system may use a saved graph lookup to determine that this relationship exists.
- the John Doe node has an alumni relationship with the Michigan node.
- the member target node is Michigan. Because the member target node is not NULL, the constraint is satisfied and the system sets the state of the constraint for the Duke node to TRUE.
- the system may evaluate the target constraint for query Q5. This constraint only has one edge, so the system may traverse the graph from the Duke node to the John Doe node via the alumni edge. This is the end of the path, so the John Doe node is the member target node. Because the member target node is not "Jack Doe", as specified by the constraint, the system sets the state for this constraint to FALSE for the Duke member node.
- the system may collapse the various query definitions by substituting the state of the constraints for the constraint in the query definition. This results in the collapsed definitions 710 of FIG. 7.
- the system can evaluate the collapsed definitions to determine if the constraint expression evaluates to TRUE or FALSE, or if additional lookups are needed.
- the constraint expression for query Q3 resolves to TRUE for Duke and the constraint expression for query Q5 resolves to FALSE for Duke.
- the system may update the saved query results for resolved queries at 715. Because query Q5 resolved to FALSE, and this is deletion of a triple, the Duke node should be removed from the Q5 query. Because query Q3 resolved to TRUE, and this is a deletion of a triple, no changes are needed (e.g., the deletion did not affect the membership) and the system may maintain the membership for the saved results of query Q3.
- FIG. 7 illustrates the evaluation, collapse, and update steps operating over groups of constraints in different saved queries, it is understood that in some implementations the system may evaluate, collapse, and update membership one query at a time.
- the system could evaluate the constraints for query Q3, collapse the query definition for Q3, and then update the membership of Q3 before evaluating the constraints of Q4, collapsing the query definition of Q4, etc.
- implementations are not limited to the sequence demonstrated in FIG. 7.
- the system may evaluate the constraints with an UNKNOWN state or constraints that were not target constraints in the query.
- the constraints there are two constraints to evaluate, each with the same path length. The system may, thus, begin a walk in the graph from the Duke node following the path identified in the
- the member target node is NULL, which does not satisfy the constraint, and the system sets the state of the constraint to FALSE for the Duke member node.
- the system may also set the state of this constraint to FALSE for the Duke node.
- the system may then collapse the query definition and determine that it evaluates to FALSE. Because it evaluates to FALSE and the update is a deleted triple, the system may delete the Duke node from the Q4 saved query results. The system has now updated the saved query results affected by the deletion of the triple, and may move on to process a next triple in a group, or may wait for another update to the data graph.
- the triple ⁇ JackDoe, parent, Jane Doe> has been added to the graph 200 of FIG. 2.
- the updated triple is ⁇ Jack Doe, parent, Jane Doe>.
- the system may update saved query results affected by the addition in response to the update, and in some implementations the system may group updates that occur in a short period of time, for example less than 5 minutes, and then update saved query results based on the group of updates. Grouping may be done by source node of the updated triple.
- the example of FIG. 8 uses the graph 200 illustrated in FIG. 2 without the deletion discussed with regard to FIG. 7.
- the example of FIG. 8 is independent of the example of FIG. 7. It is understood, however, that if the deletion did occur before the events depicted in FIG. 8 the Duke node would not be a valid member node, as its alumni relationship with Jack Doe would no longer exist.
- target constraints are constraints that include the edge identified by the added triple.
- the system may use an index, such as query edge index 345 of FIG. 3 to identify target constraints. For example, using the query edge index 345 the system may find an entry for the parent edge in the index and identify the entries for the parent edge as target constraints.
- the system may read the saved queries 340 and look for constraints that include the parent edge. Based on the graph 200 of FIG. 2 and the saved queries 340 and, optionally, the query edge index 345, the system may identify the target constraints 805. The system may then evaluate the target constraints. In some implementations, the system may intelligently evaluate the constraints.
- the system may select choose constraints with smaller lookup paths, or constraints that can re-use saved work for evaluation.
- one target constraint for query Q2 has a path length of two, and the other has a path length of three.
- the system may set the Jack Doe node as the member node and follow the newly-added parent edge to the Jane Doe node.
- the system may save the member node (e.g., Jack Doe) and the member target node (e.g., President) for the
- the system may also evaluate the target constraint for query Q3.
- the target constraint for query Q3 includes a single-edge backward walk in the graph, e.g., from Jack Doe via an alumni edge and a forward walk via parent.occupation.
- the system may be able to re-use the parent.occupation walk from the target constraint for query Q2 to identify the member target node as President.
- the system may only perform the backward walk to determine the member nodes for this constraint.
- the system may follow the alumni edge from the Jack Doe node to both the Duke node and the Columbia node.
- the system may identify two member nodes: Duke and Columbia.
- the system may set a status of TRUE for the member node Duke and for the member node Columbia. In some implementations, the system may save the backward walk from Jack Doe to Duke and Columbia via the alumni edge in temporary lookup results.
- the system may also evaluate the target constraints for query Q4.
- the path lengths of the two target constraints are equal, and the shortest for the query, so the system may evaluate each constraint.
- the system performs a backward walk using the alumni edge.
- the system may use temporary lookup results to identify the Duke and Columbia member nodes for the backward walk, for example because the system performed this walk in evaluating the target constraint for query Q3.
- the ox node is the member target node for the member nodes oiDuke and Columbia.
- the system may save the member nodes oiDuke and Columbia with the member target node of ox for the
- the system may set the state of FALSE for the member node Columbia and the member node Duke. [00082] The system may then evaluate the second constraint for the Q4 query. In some implementations, the system may use results of the previous lookup, e.g., from temporary lookup results, to identify the member nodes of Columbia and Duke and the member target node of ox. Thus, the system need not actually perform any further walks in the graph to evaluate the alumni,par ent.birthy ear.
- the system may collapse the query definitions using the states determined for the target constraints. As illustrated by the collapsed definitions 810 of FIG. 8, queries Q2 and Q3 collapse to TRUE without further lookups. Accordingly, the system may update the membership of query Q2 to add the member node Jack Doe and the membership of query Q3 to add the member nodes Columbia and Duke, assuming the member nodes are not already in the saved results of the respective queries.
- the system may begin at the Columbia node, follow the alumni edge to the Jack Doe node and follow the alumni edge from Jack Doe to Duke. Thus, the system may determine that for the member node Columbia the member target node is Duke.
- the system may set a state of TRUE for the Columbia member node.
- the system may also walk the graph from the Duke node via the alumni edge to the Jack Doe node and from the Jack Doe node to the Columbia node via another alumni edge.
- the member target node is Columbia.
- the system may set a state of the constraint to TRUE for the Duke member node.
- the system could have also followed a path from the Duke node to the John Doe node via an alumni edge, and from John Doe to the Michigan node via another alumni edge.
- the state of the constraint is TRUE, the system need not walk every possible path.
- the system may collapse the query definition of query Q4 using the status of the constraints - as illustrated by collapsed definitions 815.
- the query definition collapses to TRUE for both the Columbia member node and the Duke member node, so the system may add the Columbia and Duke member nodes to the saved query results.
- the system has now updated the saved query results affected by the addition of the triple, and may move on to process a next triple in a group, or may wait for another update to the data graph.
- FIG. 9 shows an example of a generic computer device 900, which may be system 100, and/or client 170 of FIG. 1, which may be used with the techniques described here.
- Computing device 900 is intended to represent various example forms of computing devices, such as laptops, desktops, workstations, personal digital assistants, cellular telephones, smart phones, tablets, servers, and other computing devices, including wearable devices.
- the components shown here, their connections and relationships, and their functions, are meant to be examples only, and are not meant to limit implementations of the inventions described and/or claimed in this document.
- Computing device 900 includes a processor 902, memory 904, a storage device 906, and expansion ports 910 connected via an interface 908.
- computing device 900 may include transceiver 946, communication interface 944, and a GPS (Global Positioning System) receiver module 948, among other components, connected via interface 908.
- Device 900 may communicate wirelessly through communication interface 944, which may include digital signal processing circuitry where necessary.
- Each of the components 902, 904, 906, 908, 910, 940, 944, 946, and 948 may be mounted on a common motherboard or in other manners as appropriate.
- the processor 902 can process instructions for execution within the computing device 900, including instructions stored in the memory 904 or on the storage device 906 to display graphical information for a GUI on an external input/output device, such as display 916.
- Display 916 may be a monitor or a flat touchscreen display.
- multiple processors and/or multiple buses may be used, as appropriate, along with multiple memories and types of memory.
- multiple computing devices 900 may be connected, with each device providing portions of the necessary operations (e.g., as a server bank, a group of blade servers, or a multi-processor system).
- the memory 904 stores information within the computing device 900.
- the memory 904 is a volatile memory unit or units.
- the memory 904 is a non-volatile memory unit or units.
- the memory 904 may also be another form of computer-readable medium, such as a magnetic or optical disk.
- the memory 904 may include expansion memory provided through an expansion interface.
- the storage device 906 is capable of providing mass storage for the computing device 900.
- the storage device 906 may be or contain a computer-readable medium, such as a floppy disk device, a hard disk device, an optical disk device, or a tape device, a flash memory or other similar solid state memory device, or an array of devices, including devices in a storage area network or other configurations.
- a computer program product can be tangibly embodied in such a computer-readable medium.
- the computer program product may also contain instructions that, when executed, perform one or more methods, such as those described above.
- the computer- or machine-readable medium is a storage device such as the memory 904, the storage device 906, or memory on processor 902.
- the interface 908 may be a high speed controller that manages bandwidth-intensive operations for the computing device 900 or a low speed controller that manages lower bandwidth-intensive operations, or a combination of such controllers.
- An external interface 940 may be provided so as to enable near area communication of device 900 with other devices.
- controller 908 may be coupled to storage device 906 and expansion port 914.
- the expansion port which may include various communication ports (e.g., USB, Bluetooth, Ethernet, wireless Ethernet) may be coupled to one or more input/output devices, such as a keyboard, a pointing device, a scanner, or a networking device such as a switch or router, e.g., through a network adapter.
- the computing device 900 may be implemented in a number of different forms, as shown in the figure. For example, it may be implemented as a standard server 930, or multiple times in a group of such servers. It may also be implemented as part of a rack server system. In addition, it may be implemented in a personal computing device such as desktop computer 934, laptop computer 932, or tablet or smart phone 936. An entire system may be made up of multiple computing devices 900 communicating with each other. Other configurations are possible.
- FIG. 10 shows an example of a generic computer device 1000, which may be system 100 of FIG. 1, which may be used with the techniques described here.
- Computing device 1000 is intended to represent various example forms of large-scale data processing devices, such as servers, blade servers, datacenters, mainframes, and other large-scale computing devices.
- Computing device 1000 may be a distributed system having multiple processors, possibly including network attached storage nodes, that are interconnected by one or more communication networks.
- the components shown here, their connections and relationships, and their functions, are meant to be examples only, and are not meant to limit implementations of the inventions described and/or claimed in this document.
- Distributed computing system 1000 may include any number of computing devices 1080.
- Computing devices 1080 may include a server or rack servers, mainframes, etc. communicating over a local or wide-area network, dedicated optical links, modems, bridges, routers, switches, wired or wireless networks, etc.
- each computing device may include multiple racks.
- computing device 1080a includes multiple racks 1058a - 1058n.
- Each rack may include one or more processors, such as processors 1052a-1052n and 1062a-1062n.
- the processors may include data processors, network attached storage devices, and other computer controlled devices.
- one processor may operate as a master processor and control the scheduling and data distribution tasks.
- Processors may be interconnected through one or more rack switches 1058, and one or more racks may be connected through switch 1078. Switch 1078 may handle communications between multiple connected computing devices 1000.
- Each rack may include memory, such as memory 1054 and memory 1064, and storage, such as 1056 and 1066.
- Storage 1056 and 1066 may provide mass storage and may include volatile or non-volatile storage, such as network-attached disks, floppy disks, hard disks, optical disks, tapes, flash memory or other similar solid state memory devices, or an array of devices, including devices in a storage area network or other configurations.
- Storage 1056 or 1066 may be shared between multiple processors, multiple racks, or multiple computing devices and may include a computer-readable medium storing instructions executable by one or more of the processors.
- Memory 1054 and 1064 may include, e.g., volatile memory unit or units, a non-volatile memory unit or units, and/or other forms of computer-readable media, such as a magnetic or optical disks, flash memory, cache, Random Access Memory (RAM), Read Only Memory (ROM), and combinations thereof. Memory, such as memory 1054 may also be shared between processors 1052a-1052n. Data structures, such as an index, may be stored, for example, across storage 1056 and memory 1054. Computing device 1000 may include other components not shown, such as controllers, buses, input/output devices, communications modules, etc.
- An entire system such as system 100, may be made up of multiple computing devices 1000 communicating with each other.
- device 1080a may communicate with devices 1080b, 1080c, and 1080d, and these may collectively be known as system 100.
- system 100 of FIG. 1 may include one or more computing devices 1000 as saved query engine 150.
- some of the computing devices may be located geographically close to each other, and others may be located geographically distant.
- the layout of system 1000 is an example only and the system may take on other layouts or configurations.
- Various implementations can include implementation in one or more computer programs that are executable and/or interpretable on a programmable system including at least one programmable processor, which may be special or general purpose, coupled to receive data and instructions from, and to transmit data and instructions to, a storage system, at least one input device, and at least one output device.
- a programmable processor which may be special or general purpose, coupled to receive data and instructions from, and to transmit data and instructions to, a storage system, at least one input device, and at least one output device.
- the systems and techniques described here can be implemented in a computing system that includes a back end component (e.g., as a data server), or that includes a middleware component (e.g., an application server), or that includes a front end component (e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the systems and techniques described here), or any combination of such back end, middleware, or front end components.
- the components of the system can be interconnected by any form or medium of digital data communication (e.g., a communication network). Examples of communication networks include a local area network ("LAN”), a wide area network (“WAN”), and the Internet.
- LAN local area network
- WAN wide area network
- the Internet the global information network
- the computing system can include clients and servers.
- a client and server are generally remote from each other and typically interact through a communication network.
- the relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
Abstract
Description
Claims
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US14/306,969 US9626407B2 (en) | 2014-06-17 | 2014-06-17 | Real-time saved-query updates for a large graph |
PCT/US2015/033967 WO2015195335A1 (en) | 2014-06-17 | 2015-06-03 | Real-time saved-query updates for a large graph |
Publications (2)
Publication Number | Publication Date |
---|---|
EP3158466A1 true EP3158466A1 (en) | 2017-04-26 |
EP3158466B1 EP3158466B1 (en) | 2020-04-08 |
Family
ID=53396616
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
EP15729035.4A Active EP3158466B1 (en) | 2014-06-17 | 2015-06-03 | Real-time saved-query updates for a large graph |
Country Status (6)
Country | Link |
---|---|
US (2) | US9626407B2 (en) |
EP (1) | EP3158466B1 (en) |
JP (1) | JP6277286B2 (en) |
CN (1) | CN106462625B (en) |
RU (1) | RU2645286C1 (en) |
WO (1) | WO2015195335A1 (en) |
Families Citing this family (21)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US9626407B2 (en) | 2014-06-17 | 2017-04-18 | Google Inc. | Real-time saved-query updates for a large graph |
US10049132B2 (en) * | 2014-06-26 | 2018-08-14 | Excalibur Ip, Llc | Personalizing query rewrites for ad matching |
US10353912B2 (en) | 2014-10-10 | 2019-07-16 | Salesforce.Com, Inc. | Navigation of a data extraction graph of data and metadata from a data repository |
US9965209B2 (en) * | 2014-10-15 | 2018-05-08 | Nec Corporation | Large-scale, dynamic graph storage and processing system |
US11120069B2 (en) | 2016-07-21 | 2021-09-14 | International Business Machines Corporation | Graph-based online image queries |
US10467229B2 (en) | 2016-09-30 | 2019-11-05 | Microsoft Technology Licensing, Llc. | Query-time analytics on graph queries spanning subgraphs |
US10545945B2 (en) * | 2016-10-28 | 2020-01-28 | Microsoft Technology Licensing, Llc | Change monitoring spanning graph queries |
US10445361B2 (en) | 2016-12-15 | 2019-10-15 | Microsoft Technology Licensing, Llc | Caching of subgraphs and integration of cached subgraphs into graph query results |
US10402403B2 (en) | 2016-12-15 | 2019-09-03 | Microsoft Technology Licensing, Llc | Utilization of probabilistic characteristics for reduction of graph database traversals |
US10311050B2 (en) * | 2017-01-23 | 2019-06-04 | International Business Machines Corporation | Crowdsourced discovery of paths in a knowledge graph |
US10242223B2 (en) | 2017-02-27 | 2019-03-26 | Microsoft Technology Licensing, Llc | Access controlled graph query spanning |
US20180260442A1 (en) * | 2017-03-10 | 2018-09-13 | Microsoft Technology Licensing, Llc | Self-tutoring graph of event data |
US20180260190A1 (en) * | 2017-03-10 | 2018-09-13 | Microsoft Technology Licensing, Llc | Split and merge graphs |
US20180285818A1 (en) * | 2017-04-04 | 2018-10-04 | Inersi Inc. | Collaboration platform |
US11243949B2 (en) | 2017-04-21 | 2022-02-08 | Microsoft Technology Licensing, Llc | Query execution across multiple graphs |
US10885118B2 (en) * | 2017-05-12 | 2021-01-05 | Futurewei Technologies, Inc. | Incremental graph computations for querying large graphs |
US11500867B2 (en) * | 2018-11-07 | 2022-11-15 | International Business Machines Corporation | Identification of multiple foci for topic summaries in a question answering system |
JP7360047B2 (en) | 2020-02-26 | 2023-10-12 | 富士通株式会社 | Search processing program, search processing method, and search processing device |
USD1025348S1 (en) | 2020-04-16 | 2024-04-30 | Intersurgical Ag | Airway device |
CN113760971B (en) * | 2021-11-09 | 2022-02-22 | 通联数据股份公司 | Method, computing device and storage medium for retrieving data of a graph database |
US11886433B2 (en) * | 2022-01-10 | 2024-01-30 | Red Hat, Inc. | Dynamic data batching for graph-based structures |
Family Cites Families (24)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6581205B1 (en) | 1998-12-17 | 2003-06-17 | International Business Machines Corporation | Intelligent compilation of materialized view maintenance for query processing systems |
US6826562B1 (en) * | 1999-11-29 | 2004-11-30 | International Business Machines Corporation | Method of simplifying and optimizing scalar subqueries and derived tables that return exactly or at most one tuple |
CA2427202A1 (en) * | 2003-04-30 | 2004-10-30 | Ibm Canada Limited - Ibm Canada Limitee | Method and system for aggregation subquery join elimination |
US7281002B2 (en) | 2004-03-01 | 2007-10-09 | International Business Machine Corporation | Organizing related search results |
US20050235001A1 (en) | 2004-03-31 | 2005-10-20 | Nitzan Peleg | Method and apparatus for refreshing materialized views |
US7877377B2 (en) * | 2004-06-03 | 2011-01-25 | International Business Machines Corporation | Dropping tautological predicates from SQL queries for reusability |
US20060047696A1 (en) * | 2004-08-24 | 2006-03-02 | Microsoft Corporation | Partially materialized views |
US7877350B2 (en) | 2005-06-27 | 2011-01-25 | Ab Initio Technology Llc | Managing metadata for graph-based computations |
US7873627B2 (en) * | 2006-01-18 | 2011-01-18 | Microsoft Corporation | Relational database scalar subquery optimization |
RU2419862C2 (en) * | 2006-06-01 | 2011-05-27 | Медиарайф Местль Унд Райф Коммуникационс- Унд Информационстехнологиен Оег | Method of managing relational database system |
EP2021951B1 (en) | 2006-06-01 | 2010-09-01 | mediareif Möstl & Reif Kommunikations- und Informationstechnologien OEG | Method for controlling a relational database system |
US7895189B2 (en) * | 2007-06-28 | 2011-02-22 | International Business Machines Corporation | Index exploitation |
US8214895B2 (en) | 2007-09-26 | 2012-07-03 | Microsoft Corporation | Whitelist and blacklist identification data |
US20100318538A1 (en) | 2009-06-12 | 2010-12-16 | Google Inc. | Predictive searching and associated cache management |
US9613164B2 (en) | 2009-09-11 | 2017-04-04 | University Of Maryland, College Park | System and method for data management in large data networks |
US8688683B2 (en) * | 2009-11-30 | 2014-04-01 | Business Objects Software Ltd. | Query plan reformulation |
US9081578B1 (en) | 2011-10-04 | 2015-07-14 | Amazon Technologies, Inc. | System and method for graph conditioning with non-overlapping orderable values for efficient graph evaluation |
US8682932B2 (en) | 2012-02-16 | 2014-03-25 | Oracle International Corporation | Mechanisms for searching enterprise data graphs |
US8484208B1 (en) | 2012-02-16 | 2013-07-09 | Oracle International Corporation | Displaying results of keyword search over enterprise data |
US10031968B2 (en) * | 2012-10-11 | 2018-07-24 | Veveo, Inc. | Method for adaptive conversation state management with filtering operators applied dynamically as part of a conversational interface |
US9031933B2 (en) | 2013-04-03 | 2015-05-12 | International Business Machines Corporation | Method and apparatus for optimizing the evaluation of semantic web queries |
US20140337373A1 (en) | 2013-05-07 | 2014-11-13 | Magnet Systems, Inc. | System for managing graph queries on relationships among entities using graph index |
US10133776B2 (en) * | 2013-06-20 | 2018-11-20 | Oracle International Corporation | Transforming a query by eliminating a subquery |
US9626407B2 (en) | 2014-06-17 | 2017-04-18 | Google Inc. | Real-time saved-query updates for a large graph |
-
2014
- 2014-06-17 US US14/306,969 patent/US9626407B2/en active Active
-
2015
- 2015-06-03 JP JP2016560405A patent/JP6277286B2/en active Active
- 2015-06-03 RU RU2016149782A patent/RU2645286C1/en active
- 2015-06-03 EP EP15729035.4A patent/EP3158466B1/en active Active
- 2015-06-03 CN CN201580030355.8A patent/CN106462625B/en active Active
- 2015-06-03 WO PCT/US2015/033967 patent/WO2015195335A1/en active Application Filing
-
2017
- 2017-04-17 US US15/488,852 patent/US9996581B2/en active Active
Also Published As
Publication number | Publication date |
---|---|
US9626407B2 (en) | 2017-04-18 |
EP3158466B1 (en) | 2020-04-08 |
US20170220636A1 (en) | 2017-08-03 |
RU2645286C1 (en) | 2018-02-19 |
US9996581B2 (en) | 2018-06-12 |
WO2015195335A1 (en) | 2015-12-23 |
JP6277286B2 (en) | 2018-02-07 |
JP2017522627A (en) | 2017-08-10 |
CN106462625A (en) | 2017-02-22 |
CN106462625B (en) | 2019-11-22 |
US20150363461A1 (en) | 2015-12-17 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US9996581B2 (en) | Real-time saved-query updates for a large graph | |
US9317557B2 (en) | Answering relational database queries using graph exploration | |
US10007699B2 (en) | Optimized exclusion filters for multistage filter processing in queries | |
US20150293958A1 (en) | Scalable data structures | |
US20180081946A1 (en) | Duplicate reduction or elimination with hash join operations | |
US10565201B2 (en) | Query processing management in a database management system | |
WO2017078929A1 (en) | Virtual edge of a graph database | |
WO2017096892A1 (en) | Index construction method, search method, and corresponding device, apparatus, and computer storage medium | |
US10769132B1 (en) | Efficient storage and retrieval of time series data | |
EP3161684B1 (en) | Rule-based joining of foreign to primary key | |
US9229960B2 (en) | Database management delete efficiency | |
WO2008016822A2 (en) | Primenet data management system | |
CN103561133A (en) | IP address ownership information indexing and fast querying method | |
TWI652586B (en) | Group search method and device based on social network | |
CN104268295A (en) | Data query method and device | |
CN104166661B (en) | Data-storage system and date storage method | |
US8818971B1 (en) | Processing bulk deletions in distributed databases | |
CN110807028B (en) | Method, apparatus and computer program product for managing a storage system | |
US20160125095A1 (en) | Lightweight temporal graph management engine | |
KR20180077830A (en) | Processing method for a relational query in distributed stream processing engine based on shared-nothing architecture, recording medium and device for performing the method | |
CN110990423A (en) | SQL statement execution method, device, equipment and storage medium | |
WO2013097065A1 (en) | Index data processing method and device | |
CN109491988A (en) | A kind of data real time correlation method for supporting full dose to update | |
US20160321575A1 (en) | Scoring entries in a repository of business process models to facilitate searching | |
CN104281686A (en) | Method and system for quickly processing tree-shaped nodes in batches |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: THE INTERNATIONAL PUBLICATION HAS BEEN MADE |
|
PUAI | Public reference made under article 153(3) epc to a published international application that has entered the european phase |
Free format text: ORIGINAL CODE: 0009012 |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: REQUEST FOR EXAMINATION WAS MADE |
|
17P | Request for examination filed |
Effective date: 20161209 |
|
AK | Designated contracting states |
Kind code of ref document: A1Designated state(s): AL AT BE BG CH CY CZ DE DK EE ES FI FR GB GR HR HU IE IS IT LI LT LU LV MC MK MT NL NO PL PT RO RS SE SI SK SM TR |
|
AX | Request for extension of the european patent |
Extension state: BA ME |
|
DAV | Request for validation of the european patent (deleted) | ||
DAX | Request for extension of the european patent (deleted) | ||
RAP1 | Party data changed (applicant data changed or rights of an application transferred) |
Owner name: GOOGLE LLC |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: EXAMINATION IS IN PROGRESS |
|
17Q | First examination report despatched |
Effective date: 20181012 |
|
REG | Reference to a national code |
Ref country code: DERef legal event code: R079Ref document number: 602015050250Country of ref document: DEFree format text: PREVIOUS MAIN CLASS: G06F0017300000Ipc: G06F0016230000 |
|
RIC1 | Information provided on ipc code assigned before grant |
Ipc: G06F 16/23 20190101AFI20190918BHEP |
|
GRAP | Despatch of communication of intention to grant a patent |
Free format text: ORIGINAL CODE: EPIDOSNIGR1 |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: GRANT OF PATENT IS INTENDED |
|
INTG | Intention to grant announced |
Effective date: 20191025 |
|
GRAS | Grant fee paid |
Free format text: ORIGINAL CODE: EPIDOSNIGR3 |
|
GRAJ | Information related to disapproval of communication of intention to grant by the applicant or resumption of examination proceedings by the epo deleted |
Free format text: ORIGINAL CODE: EPIDOSDIGR1 |
|
GRAL | Information related to payment of fee for publishing/printing deleted |
Free format text: ORIGINAL CODE: EPIDOSDIGR3 |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: EXAMINATION IS IN PROGRESS |
|
GRAR | Information related to intention to grant a patent recorded |
Free format text: ORIGINAL CODE: EPIDOSNIGR71 |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: GRANT OF PATENT IS INTENDED |
|
GRAA | (expected) grant |
Free format text: ORIGINAL CODE: 0009210 |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: THE PATENT HAS BEEN GRANTED |
|
INTC | Intention to grant announced (deleted) | ||
INTG | Intention to grant announced |
Effective date: 20200227 |
|
AK | Designated contracting states |
Kind code of ref document: B1Designated state(s): AL AT BE BG CH CY CZ DE DK EE ES FI FR GB GR HR HU IE IS IT LI LT LU LV MC MK MT NL NO PL PT RO RS SE SI SK SM TR |
|
REG | Reference to a national code |
Ref country code: CHRef legal event code: EPRef country code: ATRef legal event code: REFRef document number: 1255323Country of ref document: ATKind code of ref document: TEffective date: 20200415 |
|
REG | Reference to a national code |
Ref country code: DERef legal event code: R096Ref document number: 602015050250Country of ref document: DE |
|
REG | Reference to a national code |
Ref country code: IERef legal event code: FG4D |
|
REG | Reference to a national code |
Ref country code: NLRef legal event code: MPEffective date: 20200408 |
|
REG | Reference to a national code |
Ref country code: LTRef legal event code: MG4D |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: NLFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200408Ref country code: LTFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200408Ref country code: PTFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200817Ref country code: FIFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200408Ref country code: ISFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200808Ref country code: SEFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200408Ref country code: NOFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200708Ref country code: GRFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200709 |
|
REG | Reference to a national code |
Ref country code: ATRef legal event code: MK05Ref document number: 1255323Country of ref document: ATKind code of ref document: TEffective date: 20200408 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: BGFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200708Ref country code: HRFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200408Ref country code: RSFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200408Ref country code: LVFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200408 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: ALFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200408 |
|
REG | Reference to a national code |
Ref country code: DERef legal event code: R119Ref document number: 602015050250Country of ref document: DE |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: SMFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200408Ref country code: EEFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200408Ref country code: DKFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200408Ref country code: ROFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200408Ref country code: ITFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200408Ref country code: CZFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200408Ref country code: ATFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200408Ref country code: ESFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200408Ref country code: MCFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200408 |
|
REG | Reference to a national code |
Ref country code: CHRef legal event code: PL |
|
PLBE | No opposition filed within time limit |
Free format text: ORIGINAL CODE: 0009261 |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: NO OPPOSITION FILED WITHIN TIME LIMIT |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: PLFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200408Ref country code: SKFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200408 |
|
26N | No opposition filed |
Effective date: 20210112 |
|
GBPC | Gb: european patent ceased through non-payment of renewal fee |
Effective date: 20200708 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: LUFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20200603 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: LIFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20200630Ref country code: CHFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20200630Ref country code: GBFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20200708 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: DEFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20210101Ref country code: SIFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200408 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: TRFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200408Ref country code: MTFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200408Ref country code: CYFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200408 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: MKFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20200408 |
|
P01 | Opt-out of the competence of the unified patent court (upc) registered |
Effective date: 20230508 |
|
PGFP | Annual fee paid to national office [announced via postgrant information from national office to epo] |
Ref country code: IEPayment date: 20230627Year of fee payment: 9Ref country code: FRPayment date: 20230626Year of fee payment: 9 |
|
PGFP | Annual fee paid to national office [announced via postgrant information from national office to epo] |
Ref country code: BEPayment date: 20230627Year of fee payment: 9 |