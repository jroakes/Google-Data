US20180204117A1 - Dynamic-length stateful tensor array - Google Patents
Dynamic-length stateful tensor array Download PDFInfo
- Publication number
- US20180204117A1 US20180204117A1 US15/410,643 US201715410643A US2018204117A1 US 20180204117 A1 US20180204117 A1 US 20180204117A1 US 201715410643 A US201715410643 A US 201715410643A US 2018204117 A1 US2018204117 A1 US 2018204117A1
- Authority
- US
- United States
- Prior art keywords
- tensor
- operations
- tensor array
- computational graph
- machine learning
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Granted
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/901—Indexing; Data structures therefor; Storage structures
- G06F16/9024—Graphs; Linked lists
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F17/00—Digital computing or data processing equipment or methods, specially adapted for specific functions
- G06F17/10—Complex mathematical operations
- G06F17/16—Matrix or vector computation, e.g. matrix-matrix or matrix-vector multiplication, matrix factorization
-
- G06F17/30958—
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N20/00—Machine learning
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/044—Recurrent networks, e.g. Hopfield networks
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
- G06N3/084—Backpropagation, e.g. using gradient descent
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/10—Interfaces, programming languages or software development kits, e.g. for simulating neural networks
- G06N3/105—Shells for specifying net layout
Definitions
- This specification relates to constructing and processing computational graphs that represent machine learning models.
- a machine learning model receives input and generates output based on its received input and on values of model parameters.
- a computational graph representation of a machine learning model defines sequences of operations by the types of operations, the data that is input into and output from each operation, and computational dependencies.
- This specification describes technologies relating to machine learning systems in general, and specifically to systems and methods for efficiently processing dynamic-length tensors of a machine learning model represented by a computational graph.
- a computational graph includes nodes, connector edges, and parameter edges. These edges are directed edges. Each node represents a respective computational operation performed. Each connector edge that connects a first node to a second node represents that an output of the operation represented by the first node is an input to the operation represented by the second node.
- Each parameter edge represents a flow into a node of one or more parameters of a machine learning model as input to the operation represented by the node. When all inputs required for the operation are available to the node, its operation can be executed.
- An outgoing edge from a node represents a flow of an output of the operation represented by the node to be used as an input to an operation represented by another node.
- a directed edge connecting a first node in the graph to a second node in the graph indicates that an output generated by the operation represented by the first node is used as an input to the operation represented by the second node.
- the computational graphs of this specification include nodes that operate on and/or produce what will be referred to as “tensors.”
- a tensor is a multidimensional array of numeric values or other values, e.g., strings, having a specific order that corresponds to the dimensionality of the array.
- a scalar value is a 0th-order tensor
- a vector of values is a 1st-order or 1D tensor
- a matrix is a 2nd-order or 2D tensor and so on.
- one innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of efficiently processing dynamic-length tensors of a machine learning model represented by a computational graph.
- inventions of this aspect include corresponding computer systems, apparatus, and computer programs recorded on one or more computer storage devices, each configured to perform the actions of the methods.
- a system of one or more computers to be configured to perform particular operations or actions means that the system has installed on it software, firmware, hardware, or a combination of them that in operation cause the system to perform the operations or actions.
- one or more computer programs to be configured to perform particular operations or actions means that the one or more programs include instructions that, when executed by data processing apparatus, cause the apparatus to perform the operations or actions.
- An example method includes: receiving a program specifying a dynamic, iterative computation that can be performed on input data for processing by a machine learning model; generating a directed computational graph representing the machine learning model that specifies the dynamic, iterative computation as one or more operations using a tensor array object, wherein the tensor array object is an object containing a dynamically-sized array of tensors that ensures sequential execution of its operations; receiving an input for processing by the machine learning model; and executing the directed computational graph representation of the machine learning model with the received input to obtain output.
- One innovative aspect of the subject matter described in this specification can be embodied in a system comprising one or more computers and one or more storage devices storing instructions that are operable, when executed by the one or more computers to cause the one or more computers to perform operations that implement the example method.
- One innovative aspect of the subject matter described in this specification can be embodied in one or more non-transitory computer-readable mediums comprising instructions stored thereon that are executable by a processing device and upon such execution cause the processing device to perform operations that implement the example method.
- the tensor array object can include read, write, concat, split, grad, close, pack, unpack, gather, and scatter operations.
- the tensor array object can allow data to be written to an index of the tensor array object once.
- the computational graph including one or more operations using a tensor array object can ensure sequential execution of its operations by defining a tensor flow which is read by all operations of the tensor array object.
- the write operation can write a flow out tensor that is used to chain write operations so that any write operation ensures that all previous write operations have occurred prior to executing the write operation.
- a read operation following at least one write operation may use the tensor flow to ensure that all previous write operations have occurred prior to executing the read operation.
- the computational graph may be augmented to generate a training algorithm that includes computing a gradient of an objective function with respect to each of the parameters of the neural network by inserting a plurality of gradient nodes and training edges into the computational graph to generate a backward path through the computational graph that represents operations for computing the gradients of the objective function with respect to the parameters of the neural network, wherein each gradient node represents a gradient function that computes a gradient of the objective function with respect to parameters flowing along a respective parameter directed edge in the computational graph and training the neural network using the machine learning training algorithm by executing the training computational graph.
- Augmenting the computational graph may include identifying one or more tensor array operation nodes in the computational graph; and inserting, for each identified tensor array operation node, a corresponding backward path tensor array operation node along the backward path through the computational graph, wherein each backward path tensor array operation node along the backward path through the computational graph, wherein each backward path tensor array operation node forms part of a backward path tensor array object along the backward path corresponding to the tensor array object of the forward path.
- the one or more tensor array operation nodes may include a write operation, and the backward path tensor array operation corresponding to the write operation may be a tensor array read operation.
- One or more tensor array operation nodes may include a read operation and the backward path tensor array operation corresponding to the read operation may be a tensor array write operation. Multiple tensor array write operations of the backward path that write to the same index of the backward path tensor array object may be accumulated prior to execution.
- the machine learning model may be a recurrent neural network. The dynamic, iterative computation that can be performed on input data for processing by a machine learning model is specified within a higher-order operator.
- the subject matter described in this specification can be implemented in particular embodiments so as to realize one or more of the following advantages.
- the dynamic-length tensor arrays and the techniques for using them described in this specification allow for efficient processing of dynamic, iterative computations in a computational graph representation of a machine learning model.
- a computational graph can use a tensor array in computations within dynamic flow control loops to allow dynamic allocation of tensor data while maintaining the advantages of tensor immutability.
- a tensor array supports efficient dynamic, iterative processing by allowing dynamic resizing.
- the tensor array can be used to represent not just sequence data, but also tree-like structures and other more complex structures, e.g., graphs and nested data. Iterative computations can then be used to process these structures.
- the tensor array also allows lazy execution of operations by ensuring operations occur in sequence using control dependencies.
- the tensor array also ensures that back propagation calculation occurs correctly by using the control dependencies and intelligent resource management when executing create the back propagation graph.
- FIG. 1 illustrates an example computational graph system.
- FIG. 2 is a flow diagram of an example process for processing dynamic length tensors in a computational graph that represents a machine learning model.
- FIG. 3 illustrates an example of a portion of a forward propagation computational graph that uses tensor array object operations.
- FIG. 4 illustrates an example of a portion of a backward computational graph that represents the backward propagation of the forward propagation computational graph illustrated in FIG. 3 .
- This specification generally describes a computational graph system that performs operations represented by a computational graph in a distributed manner. Particularly, this specification describes techniques based on an innovative tensor array object and programming paradigm for efficiently specifying and performing dynamic, iterative computations defined by a computational graph of a machine learning model in both forward and backward propagation.
- a neural network is a machine learning model that employs one or more layers of nonlinear units to predict an output for a received input.
- Some neural networks are deep neural networks that include one or more hidden layers in addition to an output layer. The output of each hidden layer is used as input to another layer in the network, i.e., another hidden layer, the output layer, or both.
- Some layers of the neural network generate an output from a received input and a respective set of parameters, while other layers of the neural network may not have parameters.
- the operations represented by a computational graph may be operations for the neural network to compute an inference, i.e., to process an input through the layers of the neural network to generate a neural network output for the input. Additionally or alternatively, the operations represented by a computational graph may be operations to train the neural network by performing a neural network training procedure to adjust the values of the parameters of the neural network, e.g., to determine trained values of parameters from initial values of the parameters using backpropagation. In some cases, e.g., during training of the neural network, the operations represented by the computational graph can be performed in parallel by multiple replicas of the neural network.
- a neural network layer that receives an input from a previous layer can use a parameter matrix and perform a matrix multiplication between the parameter matrix and the input.
- this matrix multiplication is represented as multiple nodes in the computational graph.
- a matrix multiplication can be divided into multiple multiplication and addition operations, and each operation can be represented by a different node in the computational graph.
- the operation represented by each node can generate a respective output, which flows from a node to a subsequent node on the directed edge.
- the result flows, as represented by a directed edge, to an operation represented by another node.
- the result in this example corresponds to an output of the neural network layer that performs the matrix multiplication.
- the matrix multiplication is represented as one node in the graph.
- the operation represented by the node can receive, as inputs, an input tensor on a first directed edge and a weight tensor, e.g., a parameter matrix, on a second directed edge.
- the node can process, e.g., perform a matrix multiplication of, the input and weight tensors to output, on a third directed edge, an output tensor, which is equivalent to an output of the neural network layer.
- mathematical operations e.g., subtraction, division, and gradient computations
- array operations e.g., concatenate, splice, split, or rank
- neural network building block operations e.g., softmax, sigmoid, rectified linear unit (ReLU), or convolution.
- One or more nodes in a computational graph may represent dynamic, iterative control flow operations, e.g., nodes that represent conditional, recursive, and/or iterative control flow statements including: if statements, while loops, do-while loops, for loops, for-each loops, or nested control flow statements that include a combination of these statements.
- FIG. 1 illustrates an example computational graph system 100 .
- the system 100 can be implemented as computer programs on one or more computers in one or more locations, in which the systems, components, and techniques described below can be implemented.
- the system 100 can also be implemented using special purpose hardware for accelerating computations that occur frequently.
- the system implements an interface that can be used by a user to request operations be performed on a computational graph.
- the user can do so using software running on a user device 102 , e.g., a web browser or a special purpose application.
- the user provides data identifying a computational graph to the system 100 and specifies types of operations, e.g., dynamic, iterative operations, to be performed on the computational graph.
- types of operations e.g., dynamic, iterative operations
- the request can identify a computational graph representing an inference, i.e., a forward propagation computational graph, for a particular neural network and can identify input on which the inference should be performed.
- a computational graph representing an inference i.e., a forward propagation computational graph
- the request can identify a computational graph, e.g., a backward propagation computation graph, representing a training procedure for a particular neural network and can identify input training data on which the training should be performed.
- a computational graph e.g., a backward propagation computation graph
- the system 100 partitions the operations represented by the computational graph across multiple devices 116 , 118 , 120 , 122 .
- the devices 116 , 118 , 120 , 122 perform the operations and, if applicable, return, over a network 114 , a respective output or indication to the system 100 , which can return the requested output or indication to the user device 102 .
- Any devices performing machine learning operations can include a memory, e.g., a random access memory (RAM), for storing instructions and data, and a processor for executing stored instructions.
- a memory e.g., a random access memory (RAM)
- processor for executing stored instructions.
- each device is a hardware resource that performs operations independent of other devices.
- the devices can be, for example, graphical processing units (GPUs), central processing units (CPUs), processor cores, field programmable gate arrays (FPGAs), or application specific integrated circuits (ASICs) or other machine-learning-specific processors.
- GPUs graphical processing units
- CPUs central processing units
- FPGAs field programmable gate arrays
- ASICs application specific integrated circuits
- one machine can host one or more devices, e.g., multiple CPUs, GPUs, FPGAs, ASICs, or machine-learning-specific processors that are accessible to the computational graph system 100 over a network 114 .
- the devices are advantageously located in one place to reduce data propagation delays.
- FIG. 2 is a flow diagram of an example process 200 for performing dynamic length computations, e.g., for-loops or while loops, represented in a computational graph that represents a machine learning model.
- the process 200 will be described as being performed by a system of one or more computers, located in one or more locations, and programmed appropriately in accordance with this specification.
- an example computational graph system 100 of FIG. 1 appropriately programmed, can perform the process 200 .
- the system receives a program specifying a dynamic, iterative computation that can be performed on input data for processing by a machine learning model 202 .
- the system generates, from the program, an executable directed computational graph representing the machine learning model that specifies the dynamic, iterative computation as one or more operations of a tensor array object 204 .
- an executable directed computational graph representing the machine learning model that specifies the dynamic, iterative computation as one or more operations of a tensor array object 204 .
- the system generates nodes representing tensor array operations and edges that denote the data dependencies, including control dependencies, between nodes for execution by the system.
- An example forward computation graph is described in detail with reference to FIG. 3 .
- the system then receives an input for processing by the machine learning model 206 and performs the computation represented by the generated directed computational graph with the received input to obtain output 208 .
- Table 1 illustrates an example of a map function that uses tensor array operations, i.e., operations of a tensor array object.
- a tensor array object which will be referred to simply as a tensor array, is a thread-safe reference counted wrapper and bookkeeping mechanism around a vector of tensor objects. This tensor array object can be dynamically-sized and ensure that its operations are sequentially executed by hidden flow control dependencies.
- the tensor array object is part of the TensorFlow open source software library for numerical computation using a computational graph and naturally supports back-propagation.
- a map operation applies a function to a sequence of elements in a tensor from the first element to the last element.
- the example code of Table 1 defines a map function starting on line 1 that takes as input a specific function and a tensor.
- the map function unpacks the tensor into an input tensor array on line 6 using a tensor array unpack operation.
- the map function then defines a while loop on line 13 that calls a compute function to perform the compute function on each element of the input tensor within the while loop.
- the compute function is defined on lines 8-11.
- the compute function reads an element from an inputted index of the input tensor array and performs a function on the value at line 9 to obtain an output value.
- the output value is written to a result tensor array object for every element in the input tensor array.
- the result tensor array is packed using the tensor array pack operation to provide a tensor as output.
- the computational graph system uses tensor array objects for a variety of operations within dynamic loop constructs to support processing of dynamic-length tensors and to perform efficient reads and writes during dynamic iterative calculations.
- a tensor array object supports several operations including: size, read, write, unpack, pack, concat, split, grad, and close.
- the “size” operation takes in no input and returns the size of the tensor array.
- Size is the number of tensors that the tensor array object can hold within the data structure.
- a tensor array object can have its size set at initialization of the tensor array.
- the TensorFlow framework tf initializes a tensor array. This initialization sets the type of tensor data held in the tensor array to float32, meaning that the tensor array holds tensors of floats.
- the tensor array is initialized to a size of 2, meaning that memory has been allocated for two tensors within the tensor array.
- the tensor array object can dynamically grow past its initial size.
- tensor array objects by default are not dynamically resizable.
- the “close” operation takes in no input and closes the tensor array.
- the “read” operation takes in an input index, i, and returns the tensor at index i.
- the “pack” operation takes the m tensors in the tensor array, assuming they are all have the same shape and stacks them along a new first dimension into a larger tensor.
- the “concat” operation takes the m tensors in the tensor array and concatenates them into one tensor, as long as the tensors all match for all dimensions except the first dimension.
- the operation returns all the tensors in the tensor array concatenated into one tensor.
- the “gather” operation receives a set of indices.
- the indices are identified in a 1D tensor taking values between 0 and the last index of the tensor array.
- the operation returns the tensors identified by the indices of the tensor array packed into one tensor. This operation in effect is a pack performed on selected tensors rather than all the tensors of a tensor array.
- the “write” operation receives an index, i and a tensor T and writes the tensor T at index i in a new tensor array, which is returned as the results of the Write operation. After it is written, this i-th tensor of the tensor array is immutable.
- the “unpack” operation receives an input tensor T of size [N, d0, d1, . . . ].
- the operation splits the tensor along the first dimension, storing the subtensors at indices 0 . . . N ⁇ 1.
- the “scatter” operation scatters the values of an input tensor in specific indices of a tensor array.
- the operation receives a tensor T and indices of the tensor array in the form of a 1D tensor with values between 0 and the last index of the tensor array.
- the operation then unpacks the tensor T into the specified indices.
- the “split” operation splits the values of a tensor into the tensor array.
- the operation receives a tensor T of type dtype to split and a 1D vector that contains the locations to use when splitting the tensor T along its first dimension.
- the “grad” operation creates, or performs a lookup to find, a gradient tensor array object, which is a tensor array object that contains the gradient operations for the given forward propagation tensor array object.
- a tensor array object creates a scalar flow tensor that enforces proper chaining of operations and ensures execution of the operations in order.
- Each write operation e.g., write, unpack, and split, requires an input of a scalar flow tensor from the existing tensor array and writes a new flow tensor out that is used by the new tensor array created by the write operation.
- the use of a tensor forces the execution of the operation that created it.
- a write operation uses a flow input tensor to ensure that all previous writes have occurred.
- All read operations from a tensor array require a scalar flow tensor as input.
- This scalar flow tensor is part of the encapsulated data of the tensor array object and its use ensures any read following a series of write operations occurs after the execution of the write operations.
- This use of the flow tensor ensures that any data meant to be written to the tensor array has been written when the read occurs. Since operations require the flow tensor as input, they will not start execution until the flow tensor is available.
- FIG. 3 illustrates an example of a portion 300 of a forward propagation computational graph that uses tensor array object operations.
- the example computational graph system 100 of FIG. 1 can represent a program 306 as a visual graph, subgraph 300 .
- This subgraph 300 represents the program 306 as an executable directed computational graph.
- the computational graph system 100 generates a graph that initializes a tensor array object, ta, and performs two tensor array write operations followed by two tensor array read operations as illustrated in the pseudo code snippet of program 306 .
- the computational graph system 100 creates an operation node 301 A that represents the initialization of the tensor array, ta.
- the node When the tensor array initialize operation node 301 A is executed, the node creates a tensor array object, ta, with a size 305 , which is specified as an input by the computational graph.
- the tensor array initialize operation node 301 A creates an initial flow tensor to keep track of the flow of operations.
- the tensor array object, ta is initialized with a size of two and a tensor data type of float32.
- the computational graph system 100 then generates an operation node for a first write operation to write c3 into the 0th tensor of the tensor array as specified in the program 306 .
- the tensor array write operation node 301 B has an edge from the tensor array initialize operation node 301 A that is the size of the tensor array, ta.
- the tensor array write operation node 301 B also takes in an index 302 B to be written in the tensor array, a value 303 B to write to the index.
- the tensor array write operation node 301 B creates a new tensor array object with the index 302 B written and outputs a flow, flow 1, that ensures the write operation occurs before the write of node 301 C occurs.
- the newly-created tensor array from the write of the tensor array write operation node 301 B is assigned to ta and then used in subsequent operations.
- the computational graph system 100 uses a second tensor array write operation node 301 C to represent the second write operation of the program 306 .
- the tensor array write operation node 301 C has an edge from the node to tensor array write operation node 301 B showing that tensor array write operation node 301 C has as an input the flow, flow 1, from the tensor array write operation 301 B.
- the tensor array write operation node 301 C also takes as an input an index 302 C that indicates which tensor is to be written in the tensor array and a value 303 C which is the tensor to write.
- the tensor array write operation node 301 C performs a write operation to write the value of ⁇ 3 to the 1st tensor of a tensor array, creating a new tensor array that is subsequently assigned to ta in the example.
- a new flow, Flow 2 is created by the write operation of the tensor array write operation node 301 C and used as input for subsequent operations.
- the computational graph system 100 also generates edges and nodes to represent the two tensor array read operations of program 306 and their data dependencies.
- Each tensor array read operation node 301 D, 301 E has an edge from the tensor array write operation node 301 C to the read node 301 D, 301 E. These edges represent the data dependency of the read operations.
- Each of the read operations requires a flow input in order to execute.
- the tensor array write operation node 301 C outputs flow 2 which is sent as input to tensor array read operation nodes 301 D, 301 E so that the read operation nodes can perform their read operations.
- the tensor array read operation nodes 301 D, 301 E input the index 302 D, 302 E to be read, which in the program 306 is the 0th and 1st indices, respectively in operation.
- the computational graph system 100 uses a gradient tensor array object, grad_r_es, to construct the backpropagation path of the computational graph in order to train the machine learning model.
- the system may use a machine learning training algorithm that includes computing a gradient of an objective function, e.g., a cost function or a lost function, with respect to each of the parameters of the machine learning model, e.g., as in stochastic gradient descent.
- the system generates a backward propagation graph by inserting gradient nodes and training edges into the computational graph to represent operations for computing the gradients of the objective functions with respect to the parameters of the machine learning model.
- Each gradient node represents a respective gradient function that computes a gradient of the objective function with respect to parameters flowing along a respective parameter edge in the computational graph.
- the example system uses the gradient tensor array object grad_r_cs as illustrated in FIG. 4 to generate a graph that represents gradient computations of a forward tensor array object, e.g., to as illustrated in FIG. 3 .
- the grad operation defined above, either creates a gradient tensor array object or performs a lookup to find a previously-defined gradient tensor array.
- Each grad operation takes in a flow input tensor that forces the creation of the gradient tensor array object to occur only after the size of the forward propagating tensor array object is fixed, meaning that all operations of the forward computational graph have been identified.
- the example system may assume that the gradient tensor execution happens after all forward tensor array operations have executed.
- the tensor array gradient operation relies on the flow of the forward tensor array. Therefore, the execution of the tensor array gradient operation is dependent on all the forward operations having already executed.
- Each operation in the forward propagation tensor array of the computational graph has a corresponding operation in the backward propagation path.
- a read operation in the forward propagation graph corresponds to a write operation in the backward propagation graph
- a pack operation corresponds to an unpack operation
- a split operation corresponds to a concat operation
- a scatter operation corresponds to a gather operation.
- tensor arrays have the property that a tensor at any given index may be written only once. This property ensures the source of the write to be able to send the source to the correct gradient tensor during backpropagation. If more than one write occurs, the system does not know what values to pass to the writing operations during backpropagation.
- FIG. 4 illustrates an example of a portion of a backward computational graph that represents the backward propagation of the forward propagation computational graph illustrated in FIG. 3 .
- Subgraph 400 is the backward propagation of subgraph 300 from FIG. 3 , a portion of which is illustrated in FIG. 4 .
- the example computational graph system 100 of FIG. 1 appropriately programmed, can create the backpropagation subgraph 400 from the forward propagation subgraph 300 .
- the computational graph system 100 generates a graph that initializes a gradient tensor array object, grad_r_cs, and performs gradient operations of the forward propagation graph 300 .
- the computational graph system 100 determines the gradients of the forward graph 300 operations in backward sequential order to form the backward propagation graph 400 .
- the backward propagation graph will have two read gradient operation nodes 470 A, 470 B followed by two write gradient operations nodes 480 A, 480 B.
- the computational graph generates a tensor read gradient 470 A that contains a tensor array grad operation node 460 A that either creates a gradient tensor array object or performs a lookup to find a previously-defined gradient tensor array for the forward propagation graph.
- the tensor read gradient 470 A also contains a tensor array write operation node 401 E which is the gradient of the tensor array read operation node 301 E.
- the tensor array grad operation node 460 A has one edge from the tensor array write operation node 301 C to input the gradient of the output flow of the write operation of the tensor array write operation node 301 C and one edge from the tensor array initialize operation node 301 A to input the size of the forward propagation graph.
- the two tensor input illustrated includes a flow tensor for the backpropagation tensor array and the reference object of the backpropagation tensor array.
- the tensor array write operation node 401 E has input of an index 402 E, and a fill node 410 A that is filled with the tensor defined by shape 420 A and constant 430 A to write to the specified index of the gradient tensor array object.
- the shape 420 A creates a tensor of values to send through the back propagation.
- the tensor array write operation node 401 E also takes in as input the gradient of the flow from the tensor array grad operation node 460 A. In operation, the tensor array write operation node 401 E performs a write operation that outputs a new tensor array object and a flow output, Flow 3.
- the computational graph generates a second tensor read gradient 470 B that contains a tensor array grad operation node 460 B that either creates a gradient tensor array object or performs a lookup to find a previously-defined gradient tensor array for the forward propagation graph.
- the tensor read gradient 470 B also contains a tensor array write operation node 401 D which is the gradient of the tensor array read operation node 301 D.
- the tensor array grad operation node 460 B has one edge from the tensor array write operation node 301 C to input the gradient of the output flow of the write operation of the tensor array write operation node 301 C and one edge from the tensor array initialize operation node 301 A to input the size of the forward propagation graph.
- the tensor array write operation node 401 D has input of an index 402 D and a fill node 410 B that is filled with the tensor defined by shape 420 B and constant 430 B to write into the specified index of the gradient tensor array object.
- the tensor array write operation node 401 D also takes in as input the gradient of the flow from the tensor array grad operation node 460 B. In operation, the tensor array write operation node 401 D performs a write operation that outputs a new tensor array object and a flow output, Flow 4.
- the computational graph system 100 then sets the output of the multiple write operations to run through an accumulator operation node, Add N 450 , to ensure that multiple write operations to the same index are accumulated.
- the flow tensor ensures that the computations 480 A and 480 B actually occur. Since gradient computations occur across floating point edges, the gradient graph may be constructed only following the flow edges. In this example, the flow ensures that, after the gradients of the two reads execute, the gradients of the two writes are created and execute. Gradient computations occur across floating.
- the computational graph system 100 also generates tensor write gradients 480 A, 480 B to represent the gradients of the two tensor array write operations of the forward propagation graph 300 .
- Each tensor write gradient 480 A, 480 B contains a tensor array gradient operation node 460 C, 460 D and a tensor array read operation node 401 C, 401 B.
- the tensor array gradient operation node 460 C has an edge from the accumulator operation node 450 that passes the in the gradient flow.
- the tensor array gradient operation node 460 C also has an edge from the tensor array initialize operation node 301 A to input the size of the forward propagation graph.
- the tensor read operation node 401 C has an edge from the tensor array gradient operation node 460 C that inputs the gradient flow to the operation node.
- the tensor read operation node also inputs an index 402 C on which the operation node performs a read.
- the tensor array gradient operation node 460 D has an edge from the accumulator operation node 450 that passes in the gradient flow.
- the tensor array gradient operation node 460 D also has an edge from the tensor array initialize operation node 301 A to input the size of the forward propagation graph.
- the tensor read operation node 401 B has an edge from the tensor array gradient operation node 460 D that inputs the gradient flow to the operation node.
- the tensor read operation node also inputs an index 402 B on which the operation node performs a read.
- the example computational graph system uses tensor array objects and operations for a variety of higher order operators, e.g., map, fold left, fold right, and scan.
- the map function is described above with respect to Table 1.
- Fold functions, foldl and foldr analyze a recursive data structure and through the use of a combining operation and recombines the results to build a return value. These functions use tensor array operations within the combining and recombining loops.
- the computational graph system can additionally or alternatively use tensor array operations in scan operations. The simplest version of scan repeatedly applies a callable function to a sequence of elements from first to last.
- Tensor array objects are useful in line with dynamic loop constructs to support efficient reads and writes during dynamic iterative calculations. These object are especially useful in recurrent neural networks, e.g., neural networks that perform speech-to-text recognition, handwriting recognition, processing and compressing video, or processing text to create parse trees and perform classification on the text.
- Recurrent neural networks can have input of varying lengths. For example, each sentence that is input into a speech-to-text machine learning model may have a different number of words. In some instances, computations may need to be performed on every word of the sentence. Since sentences can be varying lengths, a computational graph may need to represent computations over every word of a sentence as a computation in a dynamic iterative while loop. These dynamic iterative computations may be represented succinctly and efficiently using tensor array object operations.
- Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, in tangibly-embodied computer software or firmware, in computer hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them.
- Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions encoded on a tangible non-transitory storage medium for execution by, or to control the operation of, data processing apparatus.
- the computer storage medium can be a machine-readable storage device, a machine-readable storage substrate, a random or serial access memory device, or a combination of one or more of them.
- the program instructions can be encoded on an artificially-generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus.
- data processing apparatus refers to data processing hardware and encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers.
- the apparatus can also be, or further include, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
- the apparatus can optionally include, in addition to hardware, code that creates an execution environment for computer programs, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them.
- a computer program which may also be referred to or described as a program, software, a software application, an app, a module, a software module, a script, or code, can be written in any form of programming language, including compiled or interpreted languages, or declarative or procedural languages; and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment.
- a program may, but need not, correspond to a file in a file system.
- a program can be stored in a portion of a file that holds other programs or data, e.g., one or more scripts stored in a markup language document, in a single file dedicated to the program in question, or in multiple coordinated files, e.g., files that store one or more modules, sub-programs, or portions of code.
- a computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a data communication network.
- the processes and logic flows described in this specification can be performed by one or more programmable computers executing one or more computer programs to perform functions by operating on input data and generating output.
- the processes and logic flows can also be performed by special purpose logic circuitry, e.g., an FPGA or an ASIC, or by a combination of special purpose logic circuitry and one or more programmed computers.
- Computers suitable for the execution of a computer program can be based on general or special purpose microprocessors or both, or any other kind of central processing unit.
- a central processing unit will receive instructions and data from a read-only memory or a random access memory or both.
- the essential elements of a computer are a central processing unit for performing or executing instructions and one or more memory devices for storing instructions and data.
- the central processing unit and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
- a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks.
- a computer need not have such devices.
- a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device, e.g., a universal serial bus (USB) flash drive, to name just a few.
- PDA personal digital assistant
- GPS Global Positioning System
- USB universal serial bus
- Computer-readable media suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks.
- semiconductor memory devices e.g., EPROM, EEPROM, and flash memory devices
- magnetic disks e.g., internal hard disks or removable disks
- magneto-optical disks e.g., CD-ROM and DVD-ROM disks.
- embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer.
- a display device e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor
- keyboard and a pointing device e.g., a mouse or a trackball
- Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.
- a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a web browser on a user's device in response to requests received from the web browser.
- a computer can interact with a user by sending text messages or other forms of message to a personal device, e.g., a smartphone, running a messaging application, and receiving responsive messages from the user in return.
- Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface, a web browser, or an app through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back-end, middleware, or front-end components.
- the components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (LAN) and a wide area network (WAN), e.g., the Internet.
- LAN local area network
- WAN wide area network
- the computing system can include clients and servers.
- a client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
- a server transmits data, e.g., an HTML page, to a user device, e.g., for purposes of displaying data to and receiving user input from a user interacting with the device, which acts as a client.
- Data generated at the user device e.g., a result of the user interaction, can be received at the server from the device.
- Embodiment 1 is a method comprising: receiving a program specifying a dynamic, iterative computation that can be performed on input data for processing by a machine learning model; generating a directed computational graph representing the machine learning model that specifies the dynamic, iterative computation as one or more operations using a tensor array object, wherein the tensor array object is an object containing a dynamically-sized array of tensors that ensures sequential execution of its operations; receiving an input for processing by the machine learning model; and executing the directed computational graph representation of the machine learning model with the received input to obtain output.
- Embodiment 2 is the method of embodiment 1, wherein the tensor array object includes read, write, concat, split, grad, close, pack, unpack, gather, and scatter operations.
- Embodiment 3 is the method of embodiment 1 or 2, wherein the tensor array object allows data to be written to an index of the tensor array object once.
- Embodiment 4 is the method of any one of embodiments 1-3, wherein the computational graph including one or more operations using a tensor array object ensures sequential execution of its operations by defining a tensor flow which is read by all operations of the tensor array object.
- Embodiment 5 is the method of any one of embodiments 1-4, wherein a write operation writes a flow out tensor that is used to chain write operations so that any write operation ensures that all previous write operations have occurred prior to executing the write operation.
- Embodiment 6 is the method of embodiment 4, wherein a read operation following at least one write operation uses the tensor flow to ensure that all previous write operations have occurred prior to executing the read operation.
- Embodiment 7 is the method of any one of embodiments 1-6, further comprising: augmenting the computational graph to generate a training computational graph for training the neural network using a machine learning training algorithm that includes computing a gradient of an objective function with respect to each of the parameters of the neural network, comprising: inserting a plurality of gradient nodes and training edges into the computational graph to generate a backward path through the computational graph that represents operations for computing the gradients of the objective function with respect to the parameters of the neural network, wherein each gradient node represents a gradient function that computes a gradient of the objective function with respect to parameters flowing along a respective parameter directed edge in the computational graph; and training the neural network using the machine learning training algorithm by executing the training computational graph.
- Embodiment 8 is the method of embodiment 7, wherein augmenting the computational graph further comprises: identifying one or more tensor array operation nodes in the computational graph; and inserting, for each identified tensor array node, a corresponding backward path tensor array operation node along the backward path through the computational graph, wherein each backward path tensor array operation node forms part of a backward path tensor array object along the backward path corresponding to the tensor array object of the forward path.
- Embodiment 9 is the method of embodiment 8, wherein the one or more tensor array operation nodes include a write operation, and wherein the backward path tensor array operation corresponding to the write operation is a tensor array read operation.
- Embodiment 10 is the method of embodiment 8 or 9, wherein the one or more tensor array operation nodes include a read operation, and wherein the backward path tensor array operation corresponding to the read operation is a tensor array write operation.
- Embodiment 11 is the method of embodiment 9, wherein multiple tensor array write operations of the backward path that write to the same index of the backward path tensor array object are accumulated prior to execution.
- Embodiment 12 is the method of any of embodiments 1-11, wherein the machine learning model is a recurrent neural network.
- Embodiment 13 is the method of any of embodiments 1-12, wherein the dynamic, iterative, computation that can be performed on input data for processing by a machine learning model is specified within a higher-order operator.
- Embodiment 14 is a system of one or more computers and one or more storage devices storing instructions that are operable, when executed by the one or more computers to cause the one or more computers to perform the operations of any one of the embodiments 1 through 13.
- Embodiment 15 is one or more non-transitory computer-readable storage mediums comprising instructions stored thereon that are executable by a processing device and upon such execution cause the processing device to perform the operations of any one of the embodiments 1 through 13.
Abstract
Description
- This specification relates to constructing and processing computational graphs that represent machine learning models.
- A machine learning model receives input and generates output based on its received input and on values of model parameters. A computational graph representation of a machine learning model defines sequences of operations by the types of operations, the data that is input into and output from each operation, and computational dependencies.
- This specification describes technologies relating to machine learning systems in general, and specifically to systems and methods for efficiently processing dynamic-length tensors of a machine learning model represented by a computational graph.
- A computational graph includes nodes, connector edges, and parameter edges. These edges are directed edges. Each node represents a respective computational operation performed. Each connector edge that connects a first node to a second node represents that an output of the operation represented by the first node is an input to the operation represented by the second node.
- Each parameter edge represents a flow into a node of one or more parameters of a machine learning model as input to the operation represented by the node. When all inputs required for the operation are available to the node, its operation can be executed.
- An outgoing edge from a node represents a flow of an output of the operation represented by the node to be used as an input to an operation represented by another node. Thus, a directed edge connecting a first node in the graph to a second node in the graph indicates that an output generated by the operation represented by the first node is used as an input to the operation represented by the second node.
- The computational graphs of this specification include nodes that operate on and/or produce what will be referred to as “tensors.” A tensor is a multidimensional array of numeric values or other values, e.g., strings, having a specific order that corresponds to the dimensionality of the array. In this specification, the term “tensor” will be used to refer simply to a structure of values that has n dimensions, for n=0, 1, 2, or any larger integer. For example, a scalar value is a 0th-order tensor, a vector of values is a 1st-order or 1D tensor, and a matrix is a 2nd-order or 2D tensor and so on.
- In the graph processing system described in this specification, once the operation of a node has used a tensor as an input or produced a tensor as an output, the data of the tensor cannot be changed by another operation. This immutability of tensors allows the system to reason about the computations represented by a graph and to perform various optimizations.
- Processing and modifying a computational graph in a distributed manner is described in detail in U.S. Patent Application No. 62/247,709, entitled “PROCESSING COMPUTATIONAL GRAPHS,” filed on Oct. 28, 2015, and U.S. Patent Application No. 62/247,713, entitled “MODIFYING COMPUTATIONAL GRAPHS,” filed on Oct. 28, 2015. The contents of each are hereby incorporated by reference herein in their entirety.
- In general, one innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of efficiently processing dynamic-length tensors of a machine learning model represented by a computational graph.
- Other embodiments of this aspect include corresponding computer systems, apparatus, and computer programs recorded on one or more computer storage devices, each configured to perform the actions of the methods. For a system of one or more computers to be configured to perform particular operations or actions means that the system has installed on it software, firmware, hardware, or a combination of them that in operation cause the system to perform the operations or actions. For one or more computer programs to be configured to perform particular operations or actions means that the one or more programs include instructions that, when executed by data processing apparatus, cause the apparatus to perform the operations or actions.
- The foregoing and other embodiments can each optionally include one or more of the following features, alone or in combination. In particular, one embodiment includes all the following features in combination. An example method includes: receiving a program specifying a dynamic, iterative computation that can be performed on input data for processing by a machine learning model; generating a directed computational graph representing the machine learning model that specifies the dynamic, iterative computation as one or more operations using a tensor array object, wherein the tensor array object is an object containing a dynamically-sized array of tensors that ensures sequential execution of its operations; receiving an input for processing by the machine learning model; and executing the directed computational graph representation of the machine learning model with the received input to obtain output.
- One innovative aspect of the subject matter described in this specification can be embodied in a system comprising one or more computers and one or more storage devices storing instructions that are operable, when executed by the one or more computers to cause the one or more computers to perform operations that implement the example method. One innovative aspect of the subject matter described in this specification can be embodied in one or more non-transitory computer-readable mediums comprising instructions stored thereon that are executable by a processing device and upon such execution cause the processing device to perform operations that implement the example method.
- These and other embodiments can optionally include one or more of the following features. The tensor array object can include read, write, concat, split, grad, close, pack, unpack, gather, and scatter operations. The tensor array object can allow data to be written to an index of the tensor array object once. The computational graph including one or more operations using a tensor array object can ensure sequential execution of its operations by defining a tensor flow which is read by all operations of the tensor array object. The write operation can write a flow out tensor that is used to chain write operations so that any write operation ensures that all previous write operations have occurred prior to executing the write operation. A read operation following at least one write operation may use the tensor flow to ensure that all previous write operations have occurred prior to executing the read operation. The computational graph may be augmented to generate a training algorithm that includes computing a gradient of an objective function with respect to each of the parameters of the neural network by inserting a plurality of gradient nodes and training edges into the computational graph to generate a backward path through the computational graph that represents operations for computing the gradients of the objective function with respect to the parameters of the neural network, wherein each gradient node represents a gradient function that computes a gradient of the objective function with respect to parameters flowing along a respective parameter directed edge in the computational graph and training the neural network using the machine learning training algorithm by executing the training computational graph. Augmenting the computational graph may include identifying one or more tensor array operation nodes in the computational graph; and inserting, for each identified tensor array operation node, a corresponding backward path tensor array operation node along the backward path through the computational graph, wherein each backward path tensor array operation node along the backward path through the computational graph, wherein each backward path tensor array operation node forms part of a backward path tensor array object along the backward path corresponding to the tensor array object of the forward path. The one or more tensor array operation nodes may include a write operation, and the backward path tensor array operation corresponding to the write operation may be a tensor array read operation. One or more tensor array operation nodes may include a read operation and the backward path tensor array operation corresponding to the read operation may be a tensor array write operation. Multiple tensor array write operations of the backward path that write to the same index of the backward path tensor array object may be accumulated prior to execution. The machine learning model may be a recurrent neural network. The dynamic, iterative computation that can be performed on input data for processing by a machine learning model is specified within a higher-order operator.
- The subject matter described in this specification can be implemented in particular embodiments so as to realize one or more of the following advantages. The dynamic-length tensor arrays and the techniques for using them described in this specification allow for efficient processing of dynamic, iterative computations in a computational graph representation of a machine learning model.
- A computational graph can use a tensor array in computations within dynamic flow control loops to allow dynamic allocation of tensor data while maintaining the advantages of tensor immutability. A tensor array supports efficient dynamic, iterative processing by allowing dynamic resizing. As a result, the tensor array can be used to represent not just sequence data, but also tree-like structures and other more complex structures, e.g., graphs and nested data. Iterative computations can then be used to process these structures.
- The tensor array also allows lazy execution of operations by ensuring operations occur in sequence using control dependencies. The tensor array also ensures that back propagation calculation occurs correctly by using the control dependencies and intelligent resource management when executing create the back propagation graph.
- The details of one or more embodiments of the subject matter of this specification are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the subject matter will become apparent from the description, the drawings, and the claims.
-
FIG. 1 illustrates an example computational graph system. -
FIG. 2 is a flow diagram of an example process for processing dynamic length tensors in a computational graph that represents a machine learning model. -
FIG. 3 illustrates an example of a portion of a forward propagation computational graph that uses tensor array object operations. -
FIG. 4 illustrates an example of a portion of a backward computational graph that represents the backward propagation of the forward propagation computational graph illustrated inFIG. 3 . - Like reference numbers and designations in the various drawings indicate like elements.
- This specification generally describes a computational graph system that performs operations represented by a computational graph in a distributed manner. Particularly, this specification describes techniques based on an innovative tensor array object and programming paradigm for efficiently specifying and performing dynamic, iterative computations defined by a computational graph of a machine learning model in both forward and backward propagation.
- In this specification, as a convenient shorthand, computations will be described as being performed by nodes of a graph on data flowing through edges of the graph. The reality behind this shorthand is that a graph processing system performs the operations represented by the nodes and provides data from one operation to another according to the flows defined by the directed edges of the graph. The operation represented by a node is performed when the data represented by the one or more edges directed into the node is available. The operation may be performed as soon as the data is available or at a later time determined by the system to satisfy, for example, resource availability or other constraints.
- Some computational graphs represent operations that realize a neural network. A neural network is a machine learning model that employs one or more layers of nonlinear units to predict an output for a received input. Some neural networks are deep neural networks that include one or more hidden layers in addition to an output layer. The output of each hidden layer is used as input to another layer in the network, i.e., another hidden layer, the output layer, or both. Some layers of the neural network generate an output from a received input and a respective set of parameters, while other layers of the neural network may not have parameters.
- The operations represented by a computational graph may be operations for the neural network to compute an inference, i.e., to process an input through the layers of the neural network to generate a neural network output for the input. Additionally or alternatively, the operations represented by a computational graph may be operations to train the neural network by performing a neural network training procedure to adjust the values of the parameters of the neural network, e.g., to determine trained values of parameters from initial values of the parameters using backpropagation. In some cases, e.g., during training of the neural network, the operations represented by the computational graph can be performed in parallel by multiple replicas of the neural network.
- By way of illustration, a neural network layer that receives an input from a previous layer can use a parameter matrix and perform a matrix multiplication between the parameter matrix and the input. In some cases, this matrix multiplication is represented as multiple nodes in the computational graph. For example, a matrix multiplication can be divided into multiple multiplication and addition operations, and each operation can be represented by a different node in the computational graph. The operation represented by each node can generate a respective output, which flows from a node to a subsequent node on the directed edge. After the operation represented by a final node generates a result of the matrix multiplication, the result flows, as represented by a directed edge, to an operation represented by another node. The result in this example corresponds to an output of the neural network layer that performs the matrix multiplication.
- In some other cases, the matrix multiplication is represented as one node in the graph. The operation represented by the node can receive, as inputs, an input tensor on a first directed edge and a weight tensor, e.g., a parameter matrix, on a second directed edge. The node can process, e.g., perform a matrix multiplication of, the input and weight tensors to output, on a third directed edge, an output tensor, which is equivalent to an output of the neural network layer.
- Other neural network operations that may be represented by nodes in the computational graph include other mathematical operations, e.g., subtraction, division, and gradient computations; array operations, e.g., concatenate, splice, split, or rank; and neural network building block operations, e.g., softmax, sigmoid, rectified linear unit (ReLU), or convolution.
- One or more nodes in a computational graph may represent dynamic, iterative control flow operations, e.g., nodes that represent conditional, recursive, and/or iterative control flow statements including: if statements, while loops, do-while loops, for loops, for-each loops, or nested control flow statements that include a combination of these statements.
-
FIG. 1 illustrates an examplecomputational graph system 100. Thesystem 100 can be implemented as computer programs on one or more computers in one or more locations, in which the systems, components, and techniques described below can be implemented. Thesystem 100 can also be implemented using special purpose hardware for accelerating computations that occur frequently. - The system implements an interface that can be used by a user to request operations be performed on a computational graph. The user can do so using software running on a user device 102, e.g., a web browser or a special purpose application.
- As part of the request, the user provides data identifying a computational graph to the
system 100 and specifies types of operations, e.g., dynamic, iterative operations, to be performed on the computational graph. - For example, the request can identify a computational graph representing an inference, i.e., a forward propagation computational graph, for a particular neural network and can identify input on which the inference should be performed.
- As another example, the request can identify a computational graph, e.g., a backward propagation computation graph, representing a training procedure for a particular neural network and can identify input training data on which the training should be performed.
- The
system 100 partitions the operations represented by the computational graph acrossmultiple devices devices network 114, a respective output or indication to thesystem 100, which can return the requested output or indication to the user device 102. - Any devices performing machine learning operations, e.g.,
devices computational graph system 100 over anetwork 114. The devices are advantageously located in one place to reduce data propagation delays. -
FIG. 2 is a flow diagram of anexample process 200 for performing dynamic length computations, e.g., for-loops or while loops, represented in a computational graph that represents a machine learning model. For convenience, theprocess 200 will be described as being performed by a system of one or more computers, located in one or more locations, and programmed appropriately in accordance with this specification. For example, an examplecomputational graph system 100 ofFIG. 1 , appropriately programmed, can perform theprocess 200. The system receives a program specifying a dynamic, iterative computation that can be performed on input data for processing by amachine learning model 202. The system generates, from the program, an executable directed computational graph representing the machine learning model that specifies the dynamic, iterative computation as one or more operations of atensor array object 204. To generate the graph, the system generates nodes representing tensor array operations and edges that denote the data dependencies, including control dependencies, between nodes for execution by the system. An example forward computation graph is described in detail with reference toFIG. 3 . - The system then receives an input for processing by the
machine learning model 206 and performs the computation represented by the generated directed computational graph with the received input to obtainoutput 208. -
TABLE 1 1 def map_fn(fn, elem): 2 if not callable(fn): 3 raise TypeError(“fn must be callable.”) 4 n = tf.shape(elem)[0] 5 elem_ta = tf.TensorArray(dtype=elem.dtype, size=n) 6 elem_ta = elem_ta.unpack(elem) 7 result_ta = tf.TensorArray(dtype=elem.dtype, size=n) 8 def compute(i, ta): 9 out = fn(elem_ta.read(i)) 10 ta = ta.write(i, out) 11 return (i + 1, ta) 12 i_0 = tf.constant(0) 13 _, final_result_ta = tf.while_loop( 14 lambda i, _: i < n, compute, (i_0, result_ta)) 15 results = final_result_ta.pack( ) 16 return results - Table 1 illustrates an example of a map function that uses tensor array operations, i.e., operations of a tensor array object. A tensor array object, which will be referred to simply as a tensor array, is a thread-safe reference counted wrapper and bookkeeping mechanism around a vector of tensor objects. This tensor array object can be dynamically-sized and ensure that its operations are sequentially executed by hidden flow control dependencies. The tensor array object is part of the TensorFlow open source software library for numerical computation using a computational graph and naturally supports back-propagation.
- In the map function of Table 1, a map operation applies a function to a sequence of elements in a tensor from the first element to the last element. As illustrated, the example code of Table 1 defines a map function starting on
line 1 that takes as input a specific function and a tensor. The map function unpacks the tensor into an input tensor array on line 6 using a tensor array unpack operation. The map function then defines a while loop on line 13 that calls a compute function to perform the compute function on each element of the input tensor within the while loop. The compute function is defined on lines 8-11. The compute function reads an element from an inputted index of the input tensor array and performs a function on the value at line 9 to obtain an output value. The output value is written to a result tensor array object for every element in the input tensor array. Once the while loop has finished, the result tensor array is packed using the tensor array pack operation to provide a tensor as output. - The computational graph system uses tensor array objects for a variety of operations within dynamic loop constructs to support processing of dynamic-length tensors and to perform efficient reads and writes during dynamic iterative calculations.
- A tensor array object supports several operations including: size, read, write, unpack, pack, concat, split, grad, and close.
- The “size” operation takes in no input and returns the size of the tensor array. Size is the number of tensors that the tensor array object can hold within the data structure. A tensor array object can have its size set at initialization of the tensor array. For example, a tensor array may be initialized by the following code: to =tf.TensorArray (dtype=tf.float32, size=2). As shown, the TensorFlow framework tf initializes a tensor array. This initialization sets the type of tensor data held in the tensor array to float32, meaning that the tensor array holds tensors of floats. Additionally, the tensor array is initialized to a size of 2, meaning that memory has been allocated for two tensors within the tensor array. The tensor array object can dynamically grow past its initial size. However, tensor array objects by default are not dynamically resizable.
- The “close” operation takes in no input and closes the tensor array.
- The “read” operation takes in an input index, i, and returns the tensor at index i.
- The “pack” operation takes the m tensors in the tensor array, assuming they are all have the same shape and stacks them along a new first dimension into a larger tensor.
- The “concat” operation takes the m tensors in the tensor array and concatenates them into one tensor, as long as the tensors all match for all dimensions except the first dimension. The operation returns all the tensors in the tensor array concatenated into one tensor.
- The “gather” operation receives a set of indices. The indices are identified in a 1D tensor taking values between 0 and the last index of the tensor array. The operation returns the tensors identified by the indices of the tensor array packed into one tensor. This operation in effect is a pack performed on selected tensors rather than all the tensors of a tensor array.
- The “write” operation receives an index, i and a tensor T and writes the tensor T at index i in a new tensor array, which is returned as the results of the Write operation. After it is written, this i-th tensor of the tensor array is immutable.
- The “unpack” operation receives an input tensor T of size [N, d0, d1, . . . ]. The operation splits the tensor along the first dimension, storing the subtensors at
indices 0 . . . N−1. - The “scatter” operation scatters the values of an input tensor in specific indices of a tensor array. The operation receives a tensor T and indices of the tensor array in the form of a 1D tensor with values between 0 and the last index of the tensor array. The operation then unpacks the tensor T into the specified indices.
- The “split” operation splits the values of a tensor into the tensor array. The operation receives a tensor T of type dtype to split and a 1D vector that contains the locations to use when splitting the tensor T along its first dimension.
- The “grad” operation creates, or performs a lookup to find, a gradient tensor array object, which is a tensor array object that contains the gradient operations for the given forward propagation tensor array object.
- At initialization, a tensor array object creates a scalar flow tensor that enforces proper chaining of operations and ensures execution of the operations in order. Each write operation, e.g., write, unpack, and split, requires an input of a scalar flow tensor from the existing tensor array and writes a new flow tensor out that is used by the new tensor array created by the write operation. In the system, the use of a tensor forces the execution of the operation that created it. Thus, when writes are chained together, a write operation uses a flow input tensor to ensure that all previous writes have occurred.
- All read operations from a tensor array, e.g., read, pack, and concat, require a scalar flow tensor as input. This scalar flow tensor is part of the encapsulated data of the tensor array object and its use ensures any read following a series of write operations occurs after the execution of the write operations. This use of the flow tensor ensures that any data meant to be written to the tensor array has been written when the read occurs. Since operations require the flow tensor as input, they will not start execution until the flow tensor is available.
-
FIG. 3 illustrates an example of aportion 300 of a forward propagation computational graph that uses tensor array object operations. The examplecomputational graph system 100 ofFIG. 1 , appropriately programmed, can represent aprogram 306 as a visual graph,subgraph 300. Thissubgraph 300 represents theprogram 306 as an executable directed computational graph. Thecomputational graph system 100 generates a graph that initializes a tensor array object, ta, and performs two tensor array write operations followed by two tensor array read operations as illustrated in the pseudo code snippet ofprogram 306. Thecomputational graph system 100 creates anoperation node 301A that represents the initialization of the tensor array, ta. When the tensor array initializeoperation node 301A is executed, the node creates a tensor array object, ta, with asize 305, which is specified as an input by the computational graph. In some implementations, the tensor array initializeoperation node 301A creates an initial flow tensor to keep track of the flow of operations. In theprogram 306, the tensor array object, ta, is initialized with a size of two and a tensor data type of float32. Thecomputational graph system 100 then generates an operation node for a first write operation to write c3 into the 0th tensor of the tensor array as specified in theprogram 306. The tensor array writeoperation node 301B has an edge from the tensor array initializeoperation node 301A that is the size of the tensor array, ta. The tensor array writeoperation node 301B also takes in an index 302B to be written in the tensor array, avalue 303B to write to the index. The tensor array writeoperation node 301B creates a new tensor array object with the index 302B written and outputs a flow,flow 1, that ensures the write operation occurs before the write ofnode 301C occurs. In this example, the newly-created tensor array from the write of the tensor array writeoperation node 301B is assigned to ta and then used in subsequent operations. - The
computational graph system 100 uses a second tensor array writeoperation node 301C to represent the second write operation of theprogram 306. The tensor array writeoperation node 301C has an edge from the node to tensor array writeoperation node 301B showing that tensor array writeoperation node 301C has as an input the flow,flow 1, from the tensor array writeoperation 301B. The tensor array writeoperation node 301C also takes as an input an index 302C that indicates which tensor is to be written in the tensor array and a value 303C which is the tensor to write. - During execution, the tensor array write
operation node 301C performs a write operation to write the value of −3 to the 1st tensor of a tensor array, creating a new tensor array that is subsequently assigned to ta in the example. A new flow,Flow 2, is created by the write operation of the tensor array writeoperation node 301C and used as input for subsequent operations. - The
computational graph system 100 also generates edges and nodes to represent the two tensor array read operations ofprogram 306 and their data dependencies. Each tensor array readoperation node operation node 301C to theread node operation node 301C outputs flow 2 which is sent as input to tensor array readoperation nodes operation nodes index program 306 is the 0th and 1st indices, respectively in operation. - The
computational graph system 100 uses a gradient tensor array object, grad_r_es, to construct the backpropagation path of the computational graph in order to train the machine learning model. The system may use a machine learning training algorithm that includes computing a gradient of an objective function, e.g., a cost function or a lost function, with respect to each of the parameters of the machine learning model, e.g., as in stochastic gradient descent. In particular, the system generates a backward propagation graph by inserting gradient nodes and training edges into the computational graph to represent operations for computing the gradients of the objective functions with respect to the parameters of the machine learning model. Each gradient node represents a respective gradient function that computes a gradient of the objective function with respect to parameters flowing along a respective parameter edge in the computational graph. - The example system uses the gradient tensor array object grad_r_cs as illustrated in
FIG. 4 to generate a graph that represents gradient computations of a forward tensor array object, e.g., to as illustrated inFIG. 3 . The grad operation, defined above, either creates a gradient tensor array object or performs a lookup to find a previously-defined gradient tensor array. Each grad operation takes in a flow input tensor that forces the creation of the gradient tensor array object to occur only after the size of the forward propagating tensor array object is fixed, meaning that all operations of the forward computational graph have been identified. The example system may assume that the gradient tensor execution happens after all forward tensor array operations have executed. The tensor array gradient operation relies on the flow of the forward tensor array. Therefore, the execution of the tensor array gradient operation is dependent on all the forward operations having already executed. - Each operation in the forward propagation tensor array of the computational graph has a corresponding operation in the backward propagation path. For example, a read operation in the forward propagation graph corresponds to a write operation in the backward propagation graph, a pack operation corresponds to an unpack operation, a split operation corresponds to a concat operation, and a scatter operation corresponds to a gather operation.
- During forward propagation, tensor arrays have the property that a tensor at any given index may be written only once. This property ensures the source of the write to be able to send the source to the correct gradient tensor during backpropagation. If more than one write occurs, the system does not know what values to pass to the writing operations during backpropagation.
- Forward propagation tensor arrays support multiple reads from the same index. Upon backpropagation, the multiple reads become multiple writes and the gradient tensor array is configured to treat multiple writes to the same index as a sum operation using an accumulator.
FIG. 4 illustrates an example of a portion of a backward computational graph that represents the backward propagation of the forward propagation computational graph illustrated inFIG. 3 .Subgraph 400 is the backward propagation ofsubgraph 300 fromFIG. 3 , a portion of which is illustrated inFIG. 4 . The examplecomputational graph system 100 ofFIG. 1 , appropriately programmed, can create thebackpropagation subgraph 400 from theforward propagation subgraph 300. Thecomputational graph system 100 generates a graph that initializes a gradient tensor array object, grad_r_cs, and performs gradient operations of theforward propagation graph 300. Thecomputational graph system 100 determines the gradients of theforward graph 300 operations in backward sequential order to form thebackward propagation graph 400. Given theforward propagation graph 300, the backward propagation graph will have two readgradient operation nodes gradient operations nodes - The computational graph generates a tensor read
gradient 470A that contains a tensor arraygrad operation node 460A that either creates a gradient tensor array object or performs a lookup to find a previously-defined gradient tensor array for the forward propagation graph. The tensor readgradient 470A also contains a tensor array writeoperation node 401E which is the gradient of the tensor array readoperation node 301E. The tensor arraygrad operation node 460A has one edge from the tensor array writeoperation node 301C to input the gradient of the output flow of the write operation of the tensor array writeoperation node 301C and one edge from the tensor array initializeoperation node 301A to input the size of the forward propagation graph. The two tensor input illustrated includes a flow tensor for the backpropagation tensor array and the reference object of the backpropagation tensor array. - The tensor array write
operation node 401E has input of anindex 402E, and afill node 410A that is filled with the tensor defined byshape 420A and constant 430A to write to the specified index of the gradient tensor array object. Theshape 420A creates a tensor of values to send through the back propagation. The tensor array writeoperation node 401E also takes in as input the gradient of the flow from the tensor arraygrad operation node 460A. In operation, the tensor array writeoperation node 401E performs a write operation that outputs a new tensor array object and a flow output,Flow 3. - The computational graph generates a second tensor read
gradient 470B that contains a tensor arraygrad operation node 460B that either creates a gradient tensor array object or performs a lookup to find a previously-defined gradient tensor array for the forward propagation graph. The tensor readgradient 470B also contains a tensor array write operation node 401D which is the gradient of the tensor array readoperation node 301D. The tensor arraygrad operation node 460B has one edge from the tensor array writeoperation node 301C to input the gradient of the output flow of the write operation of the tensor array writeoperation node 301C and one edge from the tensor array initializeoperation node 301A to input the size of the forward propagation graph. The tensor array write operation node 401D has input of anindex 402D and afill node 410B that is filled with the tensor defined byshape 420B and constant 430B to write into the specified index of the gradient tensor array object. The tensor array write operation node 401D also takes in as input the gradient of the flow from the tensor arraygrad operation node 460B. In operation, the tensor array write operation node 401D performs a write operation that outputs a new tensor array object and a flow output,Flow 4. - The
computational graph system 100 then sets the output of the multiple write operations to run through an accumulator operation node,Add N 450, to ensure that multiple write operations to the same index are accumulated. The flow tensor ensures that thecomputations - The
computational graph system 100 also generatestensor write gradients forward propagation graph 300. Each tensor writegradient gradient operation node operation node 401C, 401B. - The tensor array
gradient operation node 460C has an edge from theaccumulator operation node 450 that passes the in the gradient flow. The tensor arraygradient operation node 460C also has an edge from the tensor array initializeoperation node 301A to input the size of the forward propagation graph. The tensor readoperation node 401C has an edge from the tensor arraygradient operation node 460C that inputs the gradient flow to the operation node. The tensor read operation node also inputs anindex 402C on which the operation node performs a read. - The tensor array
gradient operation node 460D has an edge from theaccumulator operation node 450 that passes in the gradient flow. The tensor arraygradient operation node 460D also has an edge from the tensor array initializeoperation node 301A to input the size of the forward propagation graph. The tensor read operation node 401B has an edge from the tensor arraygradient operation node 460D that inputs the gradient flow to the operation node. The tensor read operation node also inputs anindex 402B on which the operation node performs a read. - The example computational graph system uses tensor array objects and operations for a variety of higher order operators, e.g., map, fold left, fold right, and scan. The map function is described above with respect to Table 1.
- Fold functions, foldl and foldr, analyze a recursive data structure and through the use of a combining operation and recombines the results to build a return value. These functions use tensor array operations within the combining and recombining loops. The computational graph system can additionally or alternatively use tensor array operations in scan operations. The simplest version of scan repeatedly applies a callable function to a sequence of elements from first to last.
- Tensor array objects are useful in line with dynamic loop constructs to support efficient reads and writes during dynamic iterative calculations. These object are especially useful in recurrent neural networks, e.g., neural networks that perform speech-to-text recognition, handwriting recognition, processing and compressing video, or processing text to create parse trees and perform classification on the text. Recurrent neural networks can have input of varying lengths. For example, each sentence that is input into a speech-to-text machine learning model may have a different number of words. In some instances, computations may need to be performed on every word of the sentence. Since sentences can be varying lengths, a computational graph may need to represent computations over every word of a sentence as a computation in a dynamic iterative while loop. These dynamic iterative computations may be represented succinctly and efficiently using tensor array object operations.
- Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, in tangibly-embodied computer software or firmware, in computer hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions encoded on a tangible non-transitory storage medium for execution by, or to control the operation of, data processing apparatus. The computer storage medium can be a machine-readable storage device, a machine-readable storage substrate, a random or serial access memory device, or a combination of one or more of them. Alternatively or in addition, the program instructions can be encoded on an artificially-generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus.
- The term “data processing apparatus” refers to data processing hardware and encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers. The apparatus can also be, or further include, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit). The apparatus can optionally include, in addition to hardware, code that creates an execution environment for computer programs, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them.
- A computer program, which may also be referred to or described as a program, software, a software application, an app, a module, a software module, a script, or code, can be written in any form of programming language, including compiled or interpreted languages, or declarative or procedural languages; and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data, e.g., one or more scripts stored in a markup language document, in a single file dedicated to the program in question, or in multiple coordinated files, e.g., files that store one or more modules, sub-programs, or portions of code. A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a data communication network.
- The processes and logic flows described in this specification can be performed by one or more programmable computers executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by special purpose logic circuitry, e.g., an FPGA or an ASIC, or by a combination of special purpose logic circuitry and one or more programmed computers.
- Computers suitable for the execution of a computer program can be based on general or special purpose microprocessors or both, or any other kind of central processing unit. Generally, a central processing unit will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a central processing unit for performing or executing instructions and one or more memory devices for storing instructions and data. The central processing unit and the memory can be supplemented by, or incorporated in, special purpose logic circuitry. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device, e.g., a universal serial bus (USB) flash drive, to name just a few.
- Computer-readable media suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks.
- To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input. In addition, a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a web browser on a user's device in response to requests received from the web browser. Also, a computer can interact with a user by sending text messages or other forms of message to a personal device, e.g., a smartphone, running a messaging application, and receiving responsive messages from the user in return.
- Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface, a web browser, or an app through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back-end, middleware, or front-end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (LAN) and a wide area network (WAN), e.g., the Internet.
- The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other. In some embodiments, a server transmits data, e.g., an HTML page, to a user device, e.g., for purposes of displaying data to and receiving user input from a user interacting with the device, which acts as a client. Data generated at the user device, e.g., a result of the user interaction, can be received at the server from the device.
- In addition to the embodiments of the attached claims and the embodiments described above, the following numbered embodiments are also innovative:
-
Embodiment 1 is a method comprising: receiving a program specifying a dynamic, iterative computation that can be performed on input data for processing by a machine learning model; generating a directed computational graph representing the machine learning model that specifies the dynamic, iterative computation as one or more operations using a tensor array object, wherein the tensor array object is an object containing a dynamically-sized array of tensors that ensures sequential execution of its operations; receiving an input for processing by the machine learning model; and executing the directed computational graph representation of the machine learning model with the received input to obtain output. -
Embodiment 2 is the method ofembodiment 1, wherein the tensor array object includes read, write, concat, split, grad, close, pack, unpack, gather, and scatter operations. -
Embodiment 3 is the method ofembodiment -
Embodiment 4 is the method of any one of embodiments 1-3, wherein the computational graph including one or more operations using a tensor array object ensures sequential execution of its operations by defining a tensor flow which is read by all operations of the tensor array object. - Embodiment 5 is the method of any one of embodiments 1-4, wherein a write operation writes a flow out tensor that is used to chain write operations so that any write operation ensures that all previous write operations have occurred prior to executing the write operation.
- Embodiment 6 is the method of
embodiment 4, wherein a read operation following at least one write operation uses the tensor flow to ensure that all previous write operations have occurred prior to executing the read operation. - Embodiment 7 is the method of any one of embodiments 1-6, further comprising: augmenting the computational graph to generate a training computational graph for training the neural network using a machine learning training algorithm that includes computing a gradient of an objective function with respect to each of the parameters of the neural network, comprising: inserting a plurality of gradient nodes and training edges into the computational graph to generate a backward path through the computational graph that represents operations for computing the gradients of the objective function with respect to the parameters of the neural network, wherein each gradient node represents a gradient function that computes a gradient of the objective function with respect to parameters flowing along a respective parameter directed edge in the computational graph; and training the neural network using the machine learning training algorithm by executing the training computational graph.
-
Embodiment 8 is the method of embodiment 7, wherein augmenting the computational graph further comprises: identifying one or more tensor array operation nodes in the computational graph; and inserting, for each identified tensor array node, a corresponding backward path tensor array operation node along the backward path through the computational graph, wherein each backward path tensor array operation node forms part of a backward path tensor array object along the backward path corresponding to the tensor array object of the forward path. - Embodiment 9 is the method of
embodiment 8, wherein the one or more tensor array operation nodes include a write operation, and wherein the backward path tensor array operation corresponding to the write operation is a tensor array read operation. - Embodiment 10 is the method of
embodiment 8 or 9, wherein the one or more tensor array operation nodes include a read operation, and wherein the backward path tensor array operation corresponding to the read operation is a tensor array write operation. - Embodiment 11 is the method of embodiment 9, wherein multiple tensor array write operations of the backward path that write to the same index of the backward path tensor array object are accumulated prior to execution.
- Embodiment 12 is the method of any of embodiments 1-11, wherein the machine learning model is a recurrent neural network.
- Embodiment 13 is the method of any of embodiments 1-12, wherein the dynamic, iterative, computation that can be performed on input data for processing by a machine learning model is specified within a higher-order operator.
- Embodiment 14 is a system of one or more computers and one or more storage devices storing instructions that are operable, when executed by the one or more computers to cause the one or more computers to perform the operations of any one of the
embodiments 1 through 13. - Embodiment 15 is one or more non-transitory computer-readable storage mediums comprising instructions stored thereon that are executable by a processing device and upon such execution cause the processing device to perform the operations of any one of the
embodiments 1 through 13. - While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any invention or on the scope of what may be claimed, but rather as descriptions of features that may be specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially be claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a sub combination.
- Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system modules and components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
- Particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. For example, the actions recited in the claims can be performed in a different order and still achieve desirable results. As one example, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In some cases, multitasking and parallel processing may be advantageous.
Claims (20)
Priority Applications (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US15/410,643 US10956500B2 (en) | 2017-01-19 | 2017-01-19 | Dynamic-length stateful tensor array |
PCT/US2018/014349 WO2018136697A1 (en) | 2017-01-19 | 2018-01-19 | Dynamic-length stateful tensor array |
US17/207,188 US20210311994A1 (en) | 2017-01-19 | 2021-03-19 | Dynamic-length stateful tensor array |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US15/410,643 US10956500B2 (en) | 2017-01-19 | 2017-01-19 | Dynamic-length stateful tensor array |
Related Child Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US17/207,188 Continuation US20210311994A1 (en) | 2017-01-19 | 2021-03-19 | Dynamic-length stateful tensor array |
Publications (2)
Publication Number | Publication Date |
---|---|
US20180204117A1 true US20180204117A1 (en) | 2018-07-19 |
US10956500B2 US10956500B2 (en) | 2021-03-23 |
Family
ID=62841449
Family Applications (2)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US15/410,643 Active 2039-08-01 US10956500B2 (en) | 2017-01-19 | 2017-01-19 | Dynamic-length stateful tensor array |
US17/207,188 Pending US20210311994A1 (en) | 2017-01-19 | 2021-03-19 | Dynamic-length stateful tensor array |
Family Applications After (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US17/207,188 Pending US20210311994A1 (en) | 2017-01-19 | 2021-03-19 | Dynamic-length stateful tensor array |
Country Status (2)
Country | Link |
---|---|
US (2) | US10956500B2 (en) |
WO (1) | WO2018136697A1 (en) |
Cited By (35)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20190325400A1 (en) * | 2018-04-20 | 2019-10-24 | Fujitsu Limited | Computer-readable recording medium, machine learning method, and machine learning device |
CN110598855A (en) * | 2019-09-23 | 2019-12-20 | Oppo广东移动通信有限公司 | Deep learning model generation method, device, equipment and storage medium |
CN110780921A (en) * | 2019-08-30 | 2020-02-11 | 腾讯科技（深圳）有限公司 | Data processing method and device, storage medium and electronic device |
CN111159483A (en) * | 2019-12-26 | 2020-05-15 | 华中科技大学 | Social network diagram abstract generation method based on incremental calculation |
CN111291240A (en) * | 2018-12-06 | 2020-06-16 | 华为技术有限公司 | Method for processing data and data processing device |
CN111580827A (en) * | 2020-04-30 | 2020-08-25 | 腾讯科技（深圳）有限公司 | Compiling optimization method and device of machine learning model |
CN111708641A (en) * | 2020-07-14 | 2020-09-25 | 腾讯科技（深圳）有限公司 | Memory management method, device and equipment and computer readable storage medium |
US20210142207A1 (en) * | 2017-07-14 | 2021-05-13 | Siemens Aktiengesellschaft | A method and apparatus for providing an adaptive self-learning control program for deployment on a target field device |
US11010666B1 (en) * | 2017-10-24 | 2021-05-18 | Tunnel Technologies Inc. | Systems and methods for generation and use of tensor networks |
US11080200B2 (en) | 2019-05-31 | 2021-08-03 | Apple Inc. | Allocation of machine learning tasks into a shared cache |
CN113485837A (en) * | 2021-07-21 | 2021-10-08 | 瀚博半导体(上海)有限公司 | Tensor processing method and processing system based on parallel branch and tensor segmentation |
US20210373867A1 (en) * | 2020-06-02 | 2021-12-02 | SambaNova Systems, Inc. | Anti-Congestion Flow Control for Reconfigurable Processors |
WO2022060929A1 (en) * | 2020-09-16 | 2022-03-24 | SambaNova Systems, Inc. | Compile time logic for detecting streaming compatible and broadcast compatible data access patterns |
US11343352B1 (en) * | 2017-06-21 | 2022-05-24 | Amazon Technologies, Inc. | Customer-facing service for service coordination |
US20220247648A1 (en) * | 2021-02-03 | 2022-08-04 | Tektronix, Inc. | Eye classes separator with overlay, and composite, and dynamic eye-trigger for humans and machine learning |
US20220281112A1 (en) * | 2020-02-24 | 2022-09-08 | Southeast University | Virtual reality-based caregiving machine control system |
US11494621B2 (en) | 2018-06-27 | 2022-11-08 | Amazon Technologies, Inc. | Attached accelerator selection and placement |
US11531902B2 (en) | 2018-11-13 | 2022-12-20 | International Business Machines Corporation | Generating and managing deep tensor neural networks |
US11537852B2 (en) | 2020-02-13 | 2022-12-27 | International Business Machines Corporation | Evolving graph convolutional networks for dynamic graphs |
US20230050303A1 (en) * | 2021-08-12 | 2023-02-16 | Tektronix, Inc. | Combined tdecq measurement and transmitter tuning using machine learning |
US11599821B2 (en) * | 2018-06-27 | 2023-03-07 | Amazon Technologies, Inc. | Attached accelerator based inference service |
US11645057B2 (en) | 2020-09-24 | 2023-05-09 | SambaNova Systems, Inc. | Systems and methods for memory layout determination and conflict resolution |
WO2023082567A1 (en) * | 2022-04-13 | 2023-05-19 | 之江实验室 | Dynamic graph execution method and apparatus for neural network computation |
US11687789B2 (en) | 2019-05-31 | 2023-06-27 | Apple Inc. | Decomposition of machine learning operations |
US11694075B2 (en) * | 2019-09-05 | 2023-07-04 | Alibaba Group Holding Limited | Partitioning control dependency edge in computation graph |
US11836635B2 (en) | 2019-05-31 | 2023-12-05 | Apple Inc. | Mutable parameters for machine learning models during runtime |
JP7430744B2 (en) | 2018-10-10 | 2024-02-13 | グーグル エルエルシー | Improving machine learning models to improve locality |
US11907090B2 (en) | 2021-08-12 | 2024-02-20 | Tektronix, Inc. | Machine learning for taps to accelerate TDECQ and other measurements |
US11923895B2 (en) | 2021-03-24 | 2024-03-05 | Tektronix, Inc. | Optical transmitter tuning using machine learning and reference parameters |
US11923896B2 (en) | 2021-03-24 | 2024-03-05 | Tektronix, Inc. | Optical transceiver tuning using machine learning |
US11941413B2 (en) | 2020-06-29 | 2024-03-26 | Amazon Technologies, Inc. | Managed control plane service |
US20240104341A1 (en) * | 2022-09-27 | 2024-03-28 | Zhejiang Lab | Memory optimization method and apparatus for neural network compilation |
US11948005B2 (en) | 2020-06-29 | 2024-04-02 | Amazon Technologies, Inc. | Managed integration of constituent services of multi-service applications |
US11960935B2 (en) | 2018-06-27 | 2024-04-16 | Amazon Technologies, Inc. | Fault-tolerant accelerator based inference service |
US11983509B2 (en) | 2022-09-12 | 2024-05-14 | SambaNova Systems, Inc. | Floating-point accumulator |
Families Citing this family (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN110633153A (en) * | 2019-09-24 | 2019-12-31 | 上海寒武纪信息科技有限公司 | Method for realizing neural network model splitting by using multi-core processor and related product |
WO2021056389A1 (en) * | 2019-09-27 | 2021-04-01 | Intel Corporation | Methods and apparatus to process machine learning model in web-browser environment |
US11275671B2 (en) | 2020-07-27 | 2022-03-15 | Huawei Technologies Co., Ltd. | Systems, methods and media for dynamically shaped tensors using liquid types |
CN114237918B (en) | 2022-02-28 | 2022-05-27 | 之江实验室 | Graph execution method and device for neural network model calculation |
Family Cites Families (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US10204174B2 (en) * | 2015-12-15 | 2019-02-12 | Oracle International Corporation | Efficient method for subgraph pattern matching |
CN105868917A (en) | 2016-04-13 | 2016-08-17 | 内蒙古工业大学 | Complex product availability characteristic identification method designed for maintainability |
US20180018573A1 (en) * | 2016-07-12 | 2018-01-18 | Xerox Corporation | Vector operators for distributional entailment |
US10372507B2 (en) * | 2016-12-31 | 2019-08-06 | Intel Corporation | Compute engine architecture to support data-parallel loops with reduction operations |
CN108304177A (en) * | 2017-01-13 | 2018-07-20 | 辉达公司 | Calculate the execution of figure |
-
2017
- 2017-01-19 US US15/410,643 patent/US10956500B2/en active Active
-
2018
- 2018-01-19 WO PCT/US2018/014349 patent/WO2018136697A1/en active Application Filing
-
2021
- 2021-03-19 US US17/207,188 patent/US20210311994A1/en active Pending
Cited By (41)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US11343352B1 (en) * | 2017-06-21 | 2022-05-24 | Amazon Technologies, Inc. | Customer-facing service for service coordination |
US20210142207A1 (en) * | 2017-07-14 | 2021-05-13 | Siemens Aktiengesellschaft | A method and apparatus for providing an adaptive self-learning control program for deployment on a target field device |
US11010666B1 (en) * | 2017-10-24 | 2021-05-18 | Tunnel Technologies Inc. | Systems and methods for generation and use of tensor networks |
US20190325400A1 (en) * | 2018-04-20 | 2019-10-24 | Fujitsu Limited | Computer-readable recording medium, machine learning method, and machine learning device |
US11599821B2 (en) * | 2018-06-27 | 2023-03-07 | Amazon Technologies, Inc. | Attached accelerator based inference service |
US11960935B2 (en) | 2018-06-27 | 2024-04-16 | Amazon Technologies, Inc. | Fault-tolerant accelerator based inference service |
US11494621B2 (en) | 2018-06-27 | 2022-11-08 | Amazon Technologies, Inc. | Attached accelerator selection and placement |
JP7430744B2 (en) | 2018-10-10 | 2024-02-13 | グーグル エルエルシー | Improving machine learning models to improve locality |
US11915139B2 (en) | 2018-10-10 | 2024-02-27 | Google Llc | Modifying machine learning models to improve locality |
US11948093B2 (en) | 2018-11-13 | 2024-04-02 | International Business Machines Corporation | Generating and managing deep tensor neural networks |
US11531902B2 (en) | 2018-11-13 | 2022-12-20 | International Business Machines Corporation | Generating and managing deep tensor neural networks |
CN111291240A (en) * | 2018-12-06 | 2020-06-16 | 华为技术有限公司 | Method for processing data and data processing device |
US20210294852A1 (en) * | 2018-12-06 | 2021-09-23 | Huawei Technologies Co., Ltd. | Method and apparatus for tensor processing |
US11687789B2 (en) | 2019-05-31 | 2023-06-27 | Apple Inc. | Decomposition of machine learning operations |
US11080200B2 (en) | 2019-05-31 | 2021-08-03 | Apple Inc. | Allocation of machine learning tasks into a shared cache |
US11836635B2 (en) | 2019-05-31 | 2023-12-05 | Apple Inc. | Mutable parameters for machine learning models during runtime |
CN110780921A (en) * | 2019-08-30 | 2020-02-11 | 腾讯科技（深圳）有限公司 | Data processing method and device, storage medium and electronic device |
US11694075B2 (en) * | 2019-09-05 | 2023-07-04 | Alibaba Group Holding Limited | Partitioning control dependency edge in computation graph |
CN110598855A (en) * | 2019-09-23 | 2019-12-20 | Oppo广东移动通信有限公司 | Deep learning model generation method, device, equipment and storage medium |
CN111159483A (en) * | 2019-12-26 | 2020-05-15 | 华中科技大学 | Social network diagram abstract generation method based on incremental calculation |
US11537852B2 (en) | 2020-02-13 | 2022-12-27 | International Business Machines Corporation | Evolving graph convolutional networks for dynamic graphs |
US20220281112A1 (en) * | 2020-02-24 | 2022-09-08 | Southeast University | Virtual reality-based caregiving machine control system |
CN111580827A (en) * | 2020-04-30 | 2020-08-25 | 腾讯科技（深圳）有限公司 | Compiling optimization method and device of machine learning model |
US11709664B2 (en) * | 2020-06-02 | 2023-07-25 | SambaNova Systems, Inc. | Anti-congestion flow control for reconfigurable processors |
US20210373867A1 (en) * | 2020-06-02 | 2021-12-02 | SambaNova Systems, Inc. | Anti-Congestion Flow Control for Reconfigurable Processors |
US11948005B2 (en) | 2020-06-29 | 2024-04-02 | Amazon Technologies, Inc. | Managed integration of constituent services of multi-service applications |
US11941413B2 (en) | 2020-06-29 | 2024-03-26 | Amazon Technologies, Inc. | Managed control plane service |
CN111708641A (en) * | 2020-07-14 | 2020-09-25 | 腾讯科技（深圳）有限公司 | Memory management method, device and equipment and computer readable storage medium |
WO2022060929A1 (en) * | 2020-09-16 | 2022-03-24 | SambaNova Systems, Inc. | Compile time logic for detecting streaming compatible and broadcast compatible data access patterns |
US11645057B2 (en) | 2020-09-24 | 2023-05-09 | SambaNova Systems, Inc. | Systems and methods for memory layout determination and conflict resolution |
US20220247648A1 (en) * | 2021-02-03 | 2022-08-04 | Tektronix, Inc. | Eye classes separator with overlay, and composite, and dynamic eye-trigger for humans and machine learning |
US11923895B2 (en) | 2021-03-24 | 2024-03-05 | Tektronix, Inc. | Optical transmitter tuning using machine learning and reference parameters |
US11923896B2 (en) | 2021-03-24 | 2024-03-05 | Tektronix, Inc. | Optical transceiver tuning using machine learning |
CN113485837A (en) * | 2021-07-21 | 2021-10-08 | 瀚博半导体(上海)有限公司 | Tensor processing method and processing system based on parallel branch and tensor segmentation |
US20230050303A1 (en) * | 2021-08-12 | 2023-02-16 | Tektronix, Inc. | Combined tdecq measurement and transmitter tuning using machine learning |
US11940889B2 (en) * | 2021-08-12 | 2024-03-26 | Tektronix, Inc. | Combined TDECQ measurement and transmitter tuning using machine learning |
US11907090B2 (en) | 2021-08-12 | 2024-02-20 | Tektronix, Inc. | Machine learning for taps to accelerate TDECQ and other measurements |
US11861505B2 (en) | 2022-04-13 | 2024-01-02 | Zhejiang Lab | Method and apparatus of executing dynamic graph for neural network computation |
WO2023082567A1 (en) * | 2022-04-13 | 2023-05-19 | 之江实验室 | Dynamic graph execution method and apparatus for neural network computation |
US11983509B2 (en) | 2022-09-12 | 2024-05-14 | SambaNova Systems, Inc. | Floating-point accumulator |
US20240104341A1 (en) * | 2022-09-27 | 2024-03-28 | Zhejiang Lab | Memory optimization method and apparatus for neural network compilation |
Also Published As
Publication number | Publication date |
---|---|
US20210311994A1 (en) | 2021-10-07 |
WO2018136697A1 (en) | 2018-07-26 |
US10956500B2 (en) | 2021-03-23 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US20210311994A1 (en) | Dynamic-length stateful tensor array | |
US10970628B2 (en) | Training neural networks represented as computational graphs | |
US11829874B2 (en) | Neural architecture search | |
CN110192210B (en) | Construction and processing of computational graphs for dynamically structured machine learning models | |
US20210209444A1 (en) | Depth concatenation using a matrix computation unit | |
US11803711B2 (en) | Depthwise separable convolutions for neural machine translation | |
Bernico | Deep Learning Quick Reference: Useful hacks for training and optimizing deep neural networks with TensorFlow and Keras | |
US9691019B1 (en) | Depth concatenation using a matrix computation unit | |
US20220171942A1 (en) | Natural Language Processing with an N-Gram Machine | |
US9798527B1 (en) | Loop and library fusion | |
US10922611B2 (en) | Neural network optimizer search | |
US10325340B2 (en) | Executing computational graphs on graphics processing units | |
US11693627B2 (en) | Contiguous sparsity pattern neural networks | |
US11580440B2 (en) | Dynamic form with machine learning | |
US11755879B2 (en) | Low-pass recurrent neural network systems with memory | |
CN108369664A (en) | Adjust the size of neural network | |
US20200265327A1 (en) | Selecting answer spans from electronic documents using neural networks | |
US20230119229A1 (en) | Augmenting neural networks | |
Gosmann et al. | Automatic optimization of the computation graph in the Nengo neural network simulator | |
US20220129436A1 (en) | Symbolic validation of neuromorphic hardware |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:BREVDO, EUGENE;REEL/FRAME:041157/0349Effective date: 20170202 |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: DOCKETED NEW CASE - READY FOR EXAMINATION |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044567/0001Effective date: 20170929 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CERTIFICATE OF CONVERSION - CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:045008/0470Effective date: 20170930 |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: NON FINAL ACTION MAILED |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: RESPONSE TO NON-FINAL OFFICE ACTION ENTERED AND FORWARDED TO EXAMINER |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
CC | Certificate of correction |