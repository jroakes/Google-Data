US20230153700A1 - Efficient Training of Embedding Models Using Negative Cache - Google Patents
Efficient Training of Embedding Models Using Negative Cache Download PDFInfo
- Publication number
- US20230153700A1 US20230153700A1 US17/983,130 US202217983130A US2023153700A1 US 20230153700 A1 US20230153700 A1 US 20230153700A1 US 202217983130 A US202217983130 A US 202217983130A US 2023153700 A1 US2023153700 A1 US 2023153700A1
- Authority
- US
- United States
- Prior art keywords
- embedding
- computing system
- query
- items
- embeddings
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/045—Combinations of networks
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N20/00—Machine learning
- G06N20/20—Ensemble learning
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F12/00—Accessing, addressing or allocating within memory systems or architectures
- G06F12/02—Addressing or allocation; Relocation
- G06F12/08—Addressing or allocation; Relocation in hierarchically structured memory systems, e.g. virtual memory systems
- G06F12/0802—Addressing of a memory level in which the access to the desired data or data block requires associative addressing means, e.g. caches
- G06F12/0875—Addressing of a memory level in which the access to the desired data or data block requires associative addressing means, e.g. caches with dedicated cache, e.g. instruction or stack
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F12/00—Accessing, addressing or allocating within memory systems or architectures
- G06F12/02—Addressing or allocation; Relocation
- G06F12/08—Addressing or allocation; Relocation in hierarchically structured memory systems, e.g. virtual memory systems
- G06F12/0802—Addressing of a memory level in which the access to the desired data or data block requires associative addressing means, e.g. caches
- G06F12/0891—Addressing of a memory level in which the access to the desired data or data block requires associative addressing means, e.g. caches using clearing, invalidating or resetting means
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
- G06N3/084—Backpropagation, e.g. using gradient descent
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
- G06N3/09—Supervised learning
Definitions
- the present disclosure relates generally to machine learning. More particularly, the present disclosure relates to efficient training of embedding models (e.g., embedding-based retrieval models) using a negative cache.
- embedding models e.g., embedding-based retrieval models
- a popular paradigm for such learning tasks involves training two separate neural networks (often called two-towers or dual-encoders), each representing a query and a document. Given positive and negative (query, document) pairs, the learning task trains the two networks by minimizing a loss function, usually softmax cross-entropy, to encourage positive pairs to have higher similarity scores and negative pairs to have lower scores.
- two-towers or dual-encoders Given positive and negative (query, document) pairs, the learning task trains the two networks by minimizing a loss function, usually softmax cross-entropy, to encourage positive pairs to have higher similarity scores and negative pairs to have lower scores.
- Negatives from the full dataset can be extracted based on approximate retrieval techniques such as ScaNN, Faiss, or SPTAG.
- approximate retrieval techniques such as ScaNN, Faiss, or SPTAG.
- it requires coordinating with a separate process for re-indexing and re-building the retrieval index at each learning iteration, which is not only computationally expensive and hard to maintain but also suffers from the problem of stale index.
- One example aspect is directed to a computer-implemented method for training embedding models with improved efficiency, the method comprising: for a plurality of training iterations: processing, by a computing system, a query with an embedding model to generate a query embedding for the query; accessing, by the computing system, an embedding table that stores a plurality of item embeddings for at least a portion of a plurality of candidate items, wherein the item embedding for at least one of the plurality of candidate items was generated by a previous version of the embedding model in one or more previous iterations; generating, by the computing system, a plurality of similarity scores for the query embedding with respect to at least a portion of the plurality of item embeddings included in the embedding table; sampling, by the computing system, from the plurality of candidate items based at least in part on the plurality of similarity scores to select one or more sampled items; processing, by the computing system, the one or more sampled items with the embedding model
- sampling, by the computing system, from the plurality of candidate items based at least in part on the plurality of similarity scores comprises performing, by the computing system, a Gumbel-Max sampling technique to sample from the plurality of candidate items based at least in part on the plurality of similarity scores.
- the embedding table is stored in a memory portion of a hardware accelerator.
- the method further includes: prior to processing the query with the embedding model: obtaining, by the computing system, a training example from a training dataset, wherein the training example comprises the query and one or more positive items labeled as positive results for the query, the one or more positive items being a subset of the plurality of candidate items; and prior to generating the plurality of similarity scores: processing, by the computing system, the one or more positive items with the embedding model to respectively generate one or more positive embeddings for the one or more positive items; and updating, by the computing system, the embedding table to include the one or more positive embeddings for the one or more positive items of the plurality of candidate items.
- updating, by the computing system, the one or more values of the one or more parameters of the embedding model comprises updating, by the computing system, the one or more values of the one or more parameters of the embedding model based at least in part on the similarity scores generated for the query embedding with respect to at least a portion of the positive items and at least the portion of the sampled items.
- updating, by the computing system, the one or more values of the one or more parameters of the embedding model comprises: determining, by the computing system, an approximate gradient of a cross-entropy loss based on the similarity scores generated for the query embedding with respect to at least a portion of the sampled item embeddings; and updating, by the computing system, the one or more values of the one or more parameters of the embedding model based at least in part on the approximate gradient of the cross-entropy loss.
- the embedding table comprises a full document cache that stores item embeddings for all of the plurality of candidate items.
- the method further includes, for each iteration: removing, by the computing system, from the embedding table the item embeddings associated with a fraction of the candidate items; and replacing, by the computing system, the item embeddings that were removed from the embedding table with new item embeddings generated for the fraction of the candidate items.
- the embedding table comprises a streaming cache that stores item embeddings for fewer than all of the plurality of candidate items.
- the method further includes for each iteration: removing, by the computing system, from the embedding table the item embeddings associated with a fraction of the candidate items; sampling, by the computing system, newly sampled items from the plurality of candidate items; and replacing, by the computing system, the item embeddings that were removed from the embedding table with new item embeddings generated for newly sampled items.
- the embedding model comprises a two-tower dual encoding model that comprises a query encoder and an item encoder.
- the plurality of candidate items comprise: images; textual documents; web documents; products; videos; or entities.
- the query comprises: a textual query; a voice query; or an image query.
- FIG. 1 depicts a flow chart diagram of an example method to perform more efficient training of an embedding model according to example embodiments of the present disclosure.
- FIG. 2 A depicts a block diagram of an example computing system according to example embodiments of the present disclosure.
- FIG. 2 B depicts a block diagram of an example computing device according to example embodiments of the present disclosure.
- FIG. 2 C depicts a block diagram of an example computing device according to example embodiments of the present disclosure.
- the present disclosure is directed to systems and methods which more efficiently train embedding models through the use of a cache of item embeddings for candidate items over a number of training iterations.
- the cached item embeddings can be “stale” embeddings that were generated by a previous version of the model at a previous training iteration.
- the (potentially stale) item embeddings included in the cache can be used when generating similarity scores that are the basis for sampling a number of items to use as negatives in the current training iteration.
- a Gumbel-Max sampling approach can be used to sample negative items that will enable an approximation of a true gradient.
- New embeddings can be generated for the sampled negative items and can be used to train the model at the current iteration.
- the systems and methods of the present disclosure can avoid needing to re-compute embeddings for an entire vocabulary of items at each iteration, thereby conserving significant amounts of computational resources, such as processor usage, memory usage, network bandwidth, etc.
- example implementations of the present disclosure can leverage a streaming cache that, at any given iteration, contains embeddings for fewer than all of the possible items.
- Use of a streaming cache in such fashion can enable the embedding cache to be retained within the memory of a hardware accelerator (e.g., graphics processing unit, tensor processing unit, etc.), thereby greatly improving the speed and computational efficiency at which training of the model can be performed.
- a hardware accelerator e.g., graphics processing unit, tensor processing unit, etc.
- embedding models e.g., factorized models, such as two tower neural network models
- scoring query, document pairs in information retrieval tasks.
- These models are typically trained by optimizing the model parameters to score relevant “positive” pairs higher than the irrelevant “negative” ones. While a large set of negatives typically improves the model performance, limited computation and memory budgets place constraints on the number of negatives used during training.
- the present disclosure provides a novel negative sampling technique for accelerating training (e.g., training that leverages a softmax cross-entropy loss).
- the proposed techniques enables training with a large pool of negatives with reduced memory and computation.
- the present disclosure also provides a streaming variant of the proposed algorithms geared towards very large datasets. For example, some implementations that update only a very small fraction of the cache at each iteration can still ensure fast convergence.
- the proposed approaches are efficient and compare favorably with more complex, state-of-the-art approaches.
- one aspect of the present disclosure is directed to an approach to train retrieval models with cross-entropy loss using a large negative cache.
- some implementations can utilize Gumbel-Max sampling on the cached embeddings to efficiently sample the negatives.
- Analysis of the convergence of example implementations of the proposed algorithm in terms of the refresh rate of the cache shows that, even for a small refresh rate, the example implementations can obtain a first-order convergence rate comparable to that of getting exact gradients using the entire dataset.
- Another aspect of the present disclosure is directed to a streaming version of the proposed approach.
- Example implementations of the streaming algorithm allow the approach to scale to very large datasets and avoid needing to maintain an up-to-date index for nearest neighbor search (or maximum inner product search).
- Experimental validations of example implementations using the MS MARCO and TREC 2019 passage retrieval tasks show that the example implementations can be efficiently implemented and achieve statistical performance comparable to state-of-the-art benchmarks with a computationally simpler approach that requires only a fraction of the memory.
- a dual encoder can include two components:
- Query encoder ⁇ Q : dQ d which maps a query to a d-dimensional embedding space.
- Document encoder ⁇ D dD d , which maps a document to the embedding space.
- the model can be trained such that the relevant query, document pairs have high scores. Dual encoders are popular in large scale settings since they are highly efficient during training and inference as the high scoring items for a given query can be found using efficient nearest neighbors algorithms, often achieving more than 100 ⁇ speed up over brute force search.
- ⁇ is the inverse temperature that scales the scores.
- This computation involves computing the scores for all documents, which can be prohibitively expensive when the number of documents m is large.
- the embeddings have unit bounded norms, i.e., ⁇ Q ( ⁇ ; ⁇ ) ⁇ 2 ⁇ 1 and ⁇ D ( ⁇ ; ⁇ ) ⁇ 2 ⁇ 1 for all ⁇ p . Note that this can be assumed without a loss in generality since one can adjust the inverse temperature ⁇ accordingly to compensate for the scale.
- Random sampling is often implemented using in-batch negative sampling.
- this approach is not scalable because a huge amount of accelerator memory is required to achieve a bigger pool of in-batch negatives.
- BERT based transformers are typically used in NLP tasks but a single pair of (query, document) BERT-base consumes 600 MB of accelerator memory during training. This further limits the effectiveness of random negative sampling.
- the present disclosure proposes example approaches that can approximate the gradient of cross-entropy loss without needing to embed every document, thereby reducing the per-iteration computation and memory requirements for gradient computation.
- Some example approaches leverage cached embeddings. To understand the example approaches, this section first starts with gradient estimation with Gumbel-Max sampling. The following known fact shows that if we can sample from the softmax distribution then we can get an unbiased estimate of the stochastic gradient.
- Gumbel-Max sampling This approach can be referred to as Gumbel-Max sampling and GumbelMaxSample( ⁇ s) can be used to represent this sampling procedure.
- the per-iteration memory requirement is reduced from O(m ⁇ ) to O(md) where i and d are the model and embedding sizes respectively.
- Algorithm 1 An example of this algorithm is provided below as Algorithm 1. Although the algorithm is presented with a batch size of 1—it can be easily extended to larger batches. An embedding table of all documents can be maintained. At each iteration, update only a small fraction ⁇ of the stale embeddings are updated to ensure that p i and ⁇ tilde over (p) ⁇ i are similar. Using this approach, approximately sampling from this distribution using Gumbel-Max sampling can be performed in an efficient manner.
- the query and document encoder functions are both L-Lipschitz in the parameters ⁇ .
- the score functions have bounded gradients i.e., we have ⁇ s ij ⁇ 2 ⁇ M for all i ⁇ [n] and j ⁇ [m].
- Some example implementations can store the cache using accelerator memory. This prevents the need to have a separate task that constantly reindexes the embeddings as they change throughout training. This is feasible for moderate size datasets. For instance, 1 million training points with an embedding dimension of 512 and feature vector dimension of 1024 will use about 6 GB memory, which can fit on a single accelerator. To calculate the perturbed nearest neighbor for Gumbel-Max sampling, a system can simply brute force calculate the largest dot product. Accelerators such as GPUs and TPUs can do this very efficiently—in example experiments it is demonstrated that the steps/second increases only a small amount as the cache size is increased. This is because the cost of computing the embeddings is much larger than the cost of doing the search due to the complexity of large transformer models.
- Algorithm 1 modifies Algorithm 1 to be a streaming algorithm.
- the Gumbel-Max sampling step can become difficult. If the embedding vectors are stored in accelerator memory, then only a finite number of vectors can be stored on a fixed computational budget. If the vectors are stored in CPU memory with a CPU-based retrieval system, then the nearest neighbor index needs to be constantly recreated, which is computationally expensive for large datasets. Additionally, we see in Theorem 2 that as the fraction of elements refreshed each iteration ⁇ decreases, then the learning rate needs to decrease as well to maintain a given bias in gradient estimation. Alternatively, more embeddings will need to be refreshed each iteration as the size of the dataset grows.
- some example implementations can perform a streaming variant of the algorithms proposed herein.
- One difference with respect to the full dataset setting is that instead of storing all the document embeddings in memory, some streaming implementations store only a sample multiset of size am. After every iteration some example implementations can remove the oldest pam elements in and replace them with pam new elements sampled uniform i.i.d. from the dataset. The fraction ⁇ can be tuned to fit a given computational budget.
- An example gradient estimator approximates gradients from a cache cross-entropy loss.
- the cache cross-entropy loss can be defined to be the following:
- L CacheCEi - log ⁇ exp ⁇ ( ⁇ ⁇ s y i ) exp ⁇ ( ⁇ ⁇ s iy i ) + 1 ⁇ ⁇ ⁇ j ⁇ S , j ⁇ y i exp ⁇ ( ⁇ ⁇ s ij )
- Some example implementations scale the weight of the negative elements by
- Lemma 4 Assume Assumptions A2 and A3 hold, i.e., that the norm of the encoder embeddings is bounded by 1 and the norm of the gradients of the scores is bounded by M.
- Algorithm 2 is an example algorithm for training with the streaming cache. Algorithm 2 uses GumbelMaxSample( ⁇ s, ) to denote the Gumbel-Max sampling described in Fact 1 with scores restricted to documents in set .
- Theorem 5 Assume that Assumptions 1 and 2 hold and we use a learning rate
- Running Algorithm 2 with a cache of size am with a refresh rate ⁇ creates updates ⁇ 1 , ⁇ 2 , . . . , ⁇ T such that
- FIG. 1 depicts a flow chart diagram of an example method according to example embodiments of the present disclosure.
- FIG. 1 depicts steps performed in a particular order for purposes of illustration and discussion, the methods of the present disclosure are not limited to the particularly illustrated order or arrangement.
- the various steps of the method 12 can be omitted, rearranged, combined, and/or adapted in various ways without deviating from the scope of the present disclosure.
- a computing system can initialize an embedding table that includes item embeddings for at least a portion of a plurality of candidate items.
- the candidate items can correspond to textual documents, web documents, natural language tokens, images, products, videos, movies, books, users, entities, locations, businesses, and/or any other items.
- the embedding table is stored in a memory portion (e.g., video random access memory, on-chip memory, high bandwidth memory, etc.) of a hardware accelerator.
- Example hardware accelerators include graphics processing units, tensor processing units, or other application-specific integrated circuits.
- the embedding table can be a full document cache that stores item embeddings for all of the plurality of candidate items.
- the cache can contain embeddings (potentially stale) for all of the possible items.
- the embedding table can be a streaming cache that stores item embeddings for fewer than all of the plurality of candidate items.
- the streaming cache can store, at any given time, a cache fraction of the total number of candidate items.
- the cache fraction can be a hyperparameter that can, for example, be user-specified. Maintaining the embedding table as a streaming cache can facilitate storage of the embedding table in a memory-constrained location such as, for example, in various on-device environments and/or in the memory portion of a hardware accelerator.
- the computing system can obtain a training example from a training dataset.
- the training example can include a query and one or more positive items labeled as positive results for the query.
- the one or more positive items are a subset of the plurality of candidate items.
- the query can be a textual query, a voice query, or an image query.
- the query can itself be one of the plurality of candidate items.
- the one or more positive items can be inferred from and/or labeled on the basis of feedback data such as impressions data, click through data (e.g., click through rate), eye gaze data, explicit user feedback, co-click data, co-usage data, and/or forms of feedback data or other data from which a relatedness between the query and the positive item(s) can be inferred or established.
- feedback data such as impressions data, click through data (e.g., click through rate), eye gaze data, explicit user feedback, co-click data, co-usage data, and/or forms of feedback data or other data from which a relatedness between the query and the positive item(s) can be inferred or established.
- the computing system can process the query with an embedding model to generate a query embedding for the query.
- the computing system can process the one or more positive items with the embedding model to respectively generate one or more positive embeddings.
- the embedding model can include one or more component models that are configured to receive an input and produce an embedding for the input in a latent embedding space.
- Example embedding models can include various neural networks such as feed-forward neural networks, recurrent neural networks, transformer-style neural networks, convolutional neural networks, etc.
- One example embedding model can be or include a two-tower dual encoding model that includes a query encoder and an item encoder.
- the query encoder can be configured to generate embeddings for queries while the item encoder can be configured to generate embeddings for items (e.g., positive and/or negative items).
- the computing system can update the embedding table to include the one or more positive embeddings for the one or more positive items.
- the computing system can generate a plurality of similarity scores for the query embedding with respect to at least a portion of the plurality of item embeddings included in the embedding table.
- a similarity score for a pair of embeddings can be equal to or based on a distance between the pair of embedding.
- the distance can be an L1 distance, an L2 distance, or other form of distance.
- a similarity score for a pair of embeddings can be generated by determining the inner product between the pair of embeddings.
- the computing system can sample from the plurality of candidate items based at least in part on the plurality of similarity scores to select one or more sampled items.
- the computing system can perform a Gumbel-Max sampling technique to sample from the plurality of candidate items based at least in part on the plurality of similarity scores.
- vanilla sampling techniques can be used, but may have less impressive results.
- sampling techniques from the REALM and/or ANCE techniques can be performed.
- the computing system can process the one or more sampled items with the embedding model to generate one or more sampled item embeddings.
- the computing system can update the embedding table to include the one or more sampled item embeddings for the one or more sampled items.
- the computing system can generate one or more similarity scores for the query embedding with respect to the one or more sampled item embeddings generated at 28 .
- the computing system can determine a gradient of a loss function based on the similarity scores generated for the query embedding with respect to at least a portion of the positive items and at least a portion of the sampled items.
- determining the gradient at 32 can include determining an approximate gradient of a cross-entropy loss based on the similarity scores generated for the query embedding with respect to at least a portion of the positive items and at least a portion of the sampled items.
- the computing system can update one or more values of one or more parameters of the embedding model based on the gradient of the loss function.
- the gradient can be backpropagated through the embedding model.
- the computing system can replace at least a refresh fraction of the embeddings in the embedding table using the updated embedding model.
- the refresh fraction can be a hyperparameter that, for example, is user-specified.
- replacing the refresh fraction can include recomputing the embedding for the same items included in the refresh fraction.
- replacing the refresh fraction can include sampling newly sampled items from the plurality of candidate items and replacing the item embeddings that were removed from the embedding table with new item embeddings generated for newly sampled items.
- the computing system can optionally return to 16. For example, iterations of 16-36 (or portions thereof) can be iteratively performed until a stopping condition is met.
- Example stopping conditions include a loop counter meeting a threshold number, convergence, a iteration-over-iteration change in a performance metric of the model satisfying a threshold, etc.
- the embedding model can be provided as an output (e.g., for deployment).
- the method 12 of FIG. 1 is performed continuously in an online fashion during deployment of the embedding model.
- 16-36 are discussed with reference in one training example for ease of understanding, 16-36 can be performed on a batch of training examples in parallel/at the same time.
- FIG. 2 A depicts a block diagram of an example computing system 100 that according to example embodiments of the present disclosure.
- the system 100 includes a user computing device 102 , a server computing system 130 , and a training computing system 150 that are communicatively coupled over a network 180 .
- the user computing device 102 can be any type of computing device, such as, for example, a personal computing device (e.g., laptop or desktop), a mobile computing device (e.g., smartphone or tablet), a gaming console or controller, a wearable computing device, an embedded computing device, or any other type of computing device.
- a personal computing device e.g., laptop or desktop
- a mobile computing device e.g., smartphone or tablet
- a gaming console or controller e.g., a gaming console or controller
- a wearable computing device e.g., an embedded computing device, or any other type of computing device.
- the user computing device 102 includes one or more processors 112 and a memory 114 .
- the one or more processors 112 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, an FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected.
- the memory 114 can include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof.
- the memory 114 can store data 116 and instructions 118 which are executed by the processor 112 to cause the user computing device 102 to perform operations.
- the user computing device 102 can store or include one or more machine-learned models 120 .
- the machine-learned models 120 can be or can otherwise include various machine-learned models such as neural networks (e.g., deep neural networks) or other types of machine-learned models, including non-linear models and/or linear models.
- Neural networks can include feed-forward neural networks, recurrent neural networks (e.g., long short-term memory recurrent neural networks), convolutional neural networks or other forms of neural networks.
- Some example machine-learned models can leverage an attention mechanism such as self-attention.
- some example machine-learned models can include multi-headed self-attention models (e.g., transformer models).
- the one or more machine-learned models 120 can be received from the server computing system 130 over network 180 , stored in the user computing device memory 114 , and then used or otherwise implemented by the one or more processors 112 .
- the user computing device 102 can implement multiple parallel instances of a single machine-learned model 120 (e.g., to perform parallel embedding generation and/or retrieval across multiple instances of items).
- one or more machine-learned models 140 can be included in or otherwise stored and implemented by the server computing system 130 that communicates with the user computing device 102 according to a client-server relationship.
- the machine-learned models 140 can be implemented by the server computing system 140 as a portion of a web service (e.g., an embedding-based retrieval service).
- a web service e.g., an embedding-based retrieval service.
- one or more models 120 can be stored and implemented at the user computing device 102 and/or one or more models 140 can be stored and implemented at the server computing system 130 .
- the user computing device 102 can also include one or more user input components 122 that receives user input.
- the user input component 122 can be a touch-sensitive component (e.g., a touch-sensitive display screen or a touch pad) that is sensitive to the touch of a user input object (e.g., a finger or a stylus).
- the touch-sensitive component can serve to implement a virtual keyboard.
- Other example user input components include a microphone, a traditional keyboard, or other means by which a user can provide user input.
- the server computing system 130 includes one or more processors 132 and a memory 134 .
- the one or more processors 132 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, an FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected.
- the memory 134 can include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof.
- the memory 134 can store data 136 and instructions 138 which are executed by the processor 132 to cause the server computing system 130 to perform operations.
- the server computing system 130 includes or is otherwise implemented by one or more server computing devices. In instances in which the server computing system 130 includes plural server computing devices, such server computing devices can operate according to sequential computing architectures, parallel computing architectures, or some combination thereof.
- the server computing system 130 can store or otherwise include one or more machine-learned models 140 .
- the models 140 can be or can otherwise include various machine-learned models.
- Example machine-learned models include neural networks or other multi-layer non-linear models.
- Example neural networks include feed forward neural networks, deep neural networks, recurrent neural networks, and convolutional neural networks.
- Some example machine-learned models can leverage an attention mechanism such as self-attention.
- some example machine-learned models can include multi-headed self-attention models (e.g., transformer models).
- the user computing device 102 and/or the server computing system 130 can train the models 120 and/or 140 via interaction with the training computing system 150 that is communicatively coupled over the network 180 .
- the training computing system 150 can be separate from the server computing system 130 or can be a portion of the server computing system 130 .
- the training computing system 150 includes one or more processors 152 and a memory 154 .
- the one or more processors 152 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, an FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected.
- the memory 154 can include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof.
- the memory 154 can store data 156 and instructions 158 which are executed by the processor 152 to cause the training computing system 150 to perform operations.
- the training computing system 150 includes or is otherwise implemented by one or more server computing devices.
- the training computing system 150 can include a model trainer 160 that trains the machine-learned models 120 and/or 140 stored at the user computing device 102 and/or the server computing system 130 using various training or learning techniques, such as, for example, backwards propagation of errors.
- a loss function can be backpropagated through the model(s) to update one or more parameters of the model(s) (e.g., based on a gradient of the loss function).
- Various loss functions can be used such as mean squared error, likelihood loss, cross entropy loss, hinge loss, and/or various other loss functions.
- Gradient descent techniques can be used to iteratively update the parameters over a number of training iterations.
- performing backwards propagation of errors can include performing truncated backpropagation through time.
- the model trainer 160 can perform a number of generalization techniques (e.g., weight decays, dropouts, etc.) to improve the generalization capability of the models being trained.
- the model trainer 160 can train the machine-learned models 120 and/or 140 based on a set of training data 162 .
- the training data 162 can include, for example, a plurality of training examples.
- Each training example can include a query and one or more items that are labeled as positive items for the query.
- the positive items can be inferred and labeled as positives based on feedback data such as click through data, eye gaze data, impression data, explicit user feedback, and/or other forms of feedback data.
- the training examples can be provided by the user computing device 102 .
- the model 120 provided to the user computing device 102 can be trained by the training computing system 150 on user-specific data received from the user computing device 102 . In some instances, this process can be referred to as personalizing the model.
- the model trainer 160 includes computer logic utilized to provide desired functionality.
- the model trainer 160 can be implemented in hardware, firmware, and/or software controlling a general purpose processor.
- the model trainer 160 includes program files stored on a storage device, loaded into a memory and executed by one or more processors.
- the model trainer 160 includes one or more sets of computer-executable instructions that are stored in a tangible computer-readable storage medium such as RAM, hard disk, or optical or magnetic media.
- the network 180 can be any type of communications network, such as a local area network (e.g., intranet), wide area network (e.g., Internet), or some combination thereof and can include any number of wired or wireless links.
- communication over the network 180 can be carried via any type of wired and/or wireless connection, using a wide variety of communication protocols (e.g., TCP/IP, HTTP, SMTP, FTP), encodings or formats (e.g., HTML, XML), and/or protection schemes (e.g., VPN, secure HTTP, SSL).
- the machine-learned models described in this specification may be used in a variety of tasks, applications, and/or use cases.
- the input to the machine-learned model(s) of the present disclosure can be image data.
- the machine-learned model(s) can process the image data to generate an output.
- the machine-learned model(s) can process the image data to generate an encoded image data output (e.g., an encoded and/or compressed representation of the image data, etc.).
- the input to the machine-learned model(s) of the present disclosure can be text or natural language data.
- the machine-learned model(s) can process the text or natural language data to generate an output.
- the machine-learned model(s) can process the natural language data to generate a language encoding output.
- the machine-learned model(s) can process the text or natural language data to generate a latent text embedding output.
- the input to the machine-learned model(s) of the present disclosure can be speech data.
- the machine-learned model(s) can process the speech data to generate an output.
- the machine-learned model(s) can process the speech data to generate an encoded speech output (e.g., an encoded and/or compressed representation of the speech data, etc.).
- the input to the machine-learned model(s) of the present disclosure can be latent encoding data (e.g., a latent space representation of an input, etc.).
- the machine-learned model(s) can process the latent encoding data to generate an output.
- the machine-learned model(s) can process the latent encoding data to generate a recognition output.
- the machine-learned model(s) can process the latent encoding data to generate a reconstruction output.
- the machine-learned model(s) can process the latent encoding data to generate a search output.
- the machine-learned model(s) can process the latent encoding data to generate a reclustering output.
- the machine-learned model(s) can process the latent encoding data to generate a prediction output.
- the input to the machine-learned model(s) of the present disclosure can be statistical data.
- Statistical data can be, represent, or otherwise include data computed and/or calculated from some other data source.
- the machine-learned model(s) can process the statistical data to generate an output.
- the machine-learned model(s) can process the statistical data to generate a compressed representation of the statistical data.
- the input to the machine-learned model(s) of the present disclosure can be sensor data.
- the machine-learned model(s) can process the sensor data to generate an output.
- the machine-learned model(s) can process the sensor data to generate a compressed representation of the sensor data.
- the machine-learned model(s) can be configured to perform a task that includes encoding input data for reliable and/or efficient transmission or storage (and/or corresponding decoding).
- the task may be an audio compression task.
- the input may include audio data and the output may comprise compressed audio data.
- the input includes visual data (e.g. one or more images or videos), the output comprises compressed visual data, and the task is a visual data compression task.
- the task may comprise generating an embedding for input data (e.g. input audio or visual data). Additional examples of input data can include products, videos, movies, books, users, entities, locations, businesses, and/or any other item that can be embedded into a latent embedding space.
- the input includes visual data and the task is a computer vision task. In some cases, the input includes pixel data for one or more images and the task is an image processing task.
- FIG. 2 A illustrates one example computing system that can be used to implement the present disclosure.
- the user computing device 102 can include the model trainer 160 and the training dataset 162 .
- the models 120 can be both trained and used locally at the user computing device 102 .
- the user computing device 102 can implement the model trainer 160 to personalize the models 120 based on user-specific data.
- FIG. 2 B depicts a block diagram of an example computing device 10 that performs according to example embodiments of the present disclosure.
- the computing device 10 can be a user computing device or a server computing device.
- the computing device 10 includes a number of applications (e.g., applications 1 through N). Each application contains its own machine learning library and machine-learned model(s). For example, each application can include a machine-learned model.
- Example applications include a text messaging application, an email application, a dictation application, a virtual keyboard application, a browser application, etc.
- each application can communicate with a number of other components of the computing device, such as, for example, one or more sensors, a context manager, a device state component, and/or additional components.
- each application can communicate with each device component using an API (e.g., a public API).
- the API used by each application is specific to that application.
- FIG. 2 C depicts a block diagram of an example computing device 50 that performs according to example embodiments of the present disclosure.
- the computing device 50 can be a user computing device or a server computing device.
- the computing device 50 includes a number of applications (e.g., applications 1 through N). Each application is in communication with a central intelligence layer.
- Example applications include a text messaging application, an email application, a dictation application, a virtual keyboard application, a browser application, etc.
- each application can communicate with the central intelligence layer (and model(s) stored therein) using an API (e.g., a common API across all applications).
- the central intelligence layer includes a number of machine-learned models. For example, as illustrated in FIG. 2 C , a respective machine-learned model can be provided for each application and managed by the central intelligence layer. In other implementations, two or more applications can share a single machine-learned model. For example, in some implementations, the central intelligence layer can provide a single model for all of the applications. In some implementations, the central intelligence layer is included within or otherwise implemented by an operating system of the computing device 50 .
- the central intelligence layer can communicate with a central device data layer.
- the central device data layer can be a centralized repository of data for the computing device 50 . As illustrated in FIG. 2 C , the central device data layer can communicate with a number of other components of the computing device, such as, for example, one or more sensors, a context manager, a device state component, and/or additional components. In some implementations, the central device data layer can communicate with each device component using an API (e.g., a private API).
- an API e.g., a private API
- the technology discussed herein makes reference to servers, databases, software applications, and other computer-based systems, as well as actions taken and information sent to and from such systems.
- the inherent flexibility of computer-based systems allows for a great variety of possible configurations, combinations, and divisions of tasks and functionality between and among components.
- processes discussed herein can be implemented using a single device or component or multiple devices or components working in combination.
- Databases and applications can be implemented on a single system or distributed across multiple systems. Distributed components can operate sequentially or in parallel.
Abstract
Provided are systems and methods which more efficiency train embedding models through the use of a cache of item embeddings for candidate items over a number of training iterations. The cached item embeddings can be “stale” embeddings that were generated by a previous version of the model at a previous training iteration. Specifically, at each iteration, the (potentially stale) item embeddings included in the cache can be used when generating similarity scores that are the basis for sampling a number of items to use as negatives in the current training iteration. For example, a Gumbel-Max sampling approach can be used to sample negative items that will enable an approximation of a true gradient. New embeddings can be generated for the sampled negative items and can be used to train the model at the current iteration.
Description
- This application claims priority to and the benefit of U.S. Provisional Patent Application No. 63/277,385, filed Nov. 9, 2021. U.S. Provisional Patent Application No. 63/277,385 is hereby incorporated by reference in its entirety.
- The present disclosure relates generally to machine learning. More particularly, the present disclosure relates to efficient training of embedding models (e.g., embedding-based retrieval models) using a negative cache.
- Learning to represent objects as numerical vectors (e.g., dense vectors), often called “embeddings”, has proved to be crucial in large scale information retrieval tasks from multiple domains including, among other domains, vision and natural language processing.
- A popular paradigm for such learning tasks involves training two separate neural networks (often called two-towers or dual-encoders), each representing a query and a document. Given positive and negative (query, document) pairs, the learning task trains the two networks by minimizing a loss function, usually softmax cross-entropy, to encourage positive pairs to have higher similarity scores and negative pairs to have lower scores.
- While it is easy to sample positive pairs of examples through user feedback such as impressions, clicks, or other forms of inferred approval, it is more challenging to sample good negative pairs from a pool of potentially millions or even billions of documents. A large number of negative pairs is often required to ensure high quality of the final model, which makes the training process consume significant computational resources.
- A number of strategies have been proposed in the literature to address the problem of sampling good negative pairs from a large corpus. The most common approach is to use in-batch negatives, which treats random, non-positive pairs in a minibatch as negatives. This approach is computationally efficient and works in a streaming setting, but the pool of negative examples is limited to the minibatch. Towards the later stages of the training, the in-batch negatives become less informative (i.e., have low gradients) since they are sampled randomly without paying attention to which negatives are hard for a given query.
- Another popular approach is to maintain an asynchronous retrieval index of the full dataset for negative sampling. Negatives from the full dataset can be extracted based on approximate retrieval techniques such as ScaNN, Faiss, or SPTAG. However, it requires coordinating with a separate process for re-indexing and re-building the retrieval index at each learning iteration, which is not only computationally expensive and hard to maintain but also suffers from the problem of stale index.
- Aspects and advantages of embodiments of the present disclosure will be set forth in part in the following description, or can be learned from the description, or can be learned through practice of the embodiments.
- One example aspect is directed to a computer-implemented method for training embedding models with improved efficiency, the method comprising: for a plurality of training iterations: processing, by a computing system, a query with an embedding model to generate a query embedding for the query; accessing, by the computing system, an embedding table that stores a plurality of item embeddings for at least a portion of a plurality of candidate items, wherein the item embedding for at least one of the plurality of candidate items was generated by a previous version of the embedding model in one or more previous iterations; generating, by the computing system, a plurality of similarity scores for the query embedding with respect to at least a portion of the plurality of item embeddings included in the embedding table; sampling, by the computing system, from the plurality of candidate items based at least in part on the plurality of similarity scores to select one or more sampled items; processing, by the computing system, the one or more sampled items with the embedding model to respectively generate one or more sampled item embeddings; generating, by the computing system, one or more similarity scores for the query embedding with respect to the one or more sampled item embeddings; and updating, by the computing system, one or more values of one or more parameters of the embedding model based at least in part on the similarity scores generated for the query embedding with respect to at least a portion of the sampled item embeddings; and after the plurality of training iterations, providing, by the computing system, the embedding model as an output.
- In some implementations, sampling, by the computing system, from the plurality of candidate items based at least in part on the plurality of similarity scores comprises performing, by the computing system, a Gumbel-Max sampling technique to sample from the plurality of candidate items based at least in part on the plurality of similarity scores.
- In some implementations, the embedding table is stored in a memory portion of a hardware accelerator.
- In some implementations, the method further includes: prior to processing the query with the embedding model: obtaining, by the computing system, a training example from a training dataset, wherein the training example comprises the query and one or more positive items labeled as positive results for the query, the one or more positive items being a subset of the plurality of candidate items; and prior to generating the plurality of similarity scores: processing, by the computing system, the one or more positive items with the embedding model to respectively generate one or more positive embeddings for the one or more positive items; and updating, by the computing system, the embedding table to include the one or more positive embeddings for the one or more positive items of the plurality of candidate items.
- In some implementations, updating, by the computing system, the one or more values of the one or more parameters of the embedding model comprises updating, by the computing system, the one or more values of the one or more parameters of the embedding model based at least in part on the similarity scores generated for the query embedding with respect to at least a portion of the positive items and at least the portion of the sampled items.
- In some implementations, updating, by the computing system, the one or more values of the one or more parameters of the embedding model comprises: determining, by the computing system, an approximate gradient of a cross-entropy loss based on the similarity scores generated for the query embedding with respect to at least a portion of the sampled item embeddings; and updating, by the computing system, the one or more values of the one or more parameters of the embedding model based at least in part on the approximate gradient of the cross-entropy loss.
- In some implementations, the embedding table comprises a full document cache that stores item embeddings for all of the plurality of candidate items.
- In some implementations, the method further includes, for each iteration: removing, by the computing system, from the embedding table the item embeddings associated with a fraction of the candidate items; and replacing, by the computing system, the item embeddings that were removed from the embedding table with new item embeddings generated for the fraction of the candidate items.
- In some implementations, the embedding table comprises a streaming cache that stores item embeddings for fewer than all of the plurality of candidate items.
- In some implementations, the method further includes for each iteration: removing, by the computing system, from the embedding table the item embeddings associated with a fraction of the candidate items; sampling, by the computing system, newly sampled items from the plurality of candidate items; and replacing, by the computing system, the item embeddings that were removed from the embedding table with new item embeddings generated for newly sampled items.
- In some implementations, the embedding model comprises a two-tower dual encoding model that comprises a query encoder and an item encoder.
- In some implementations, the plurality of candidate items comprise: images; textual documents; web documents; products; videos; or entities.
- In some implementations, the query comprises: a textual query; a voice query; or an image query.
- Other aspects of the present disclosure are directed to various systems, apparatuses, non-transitory computer-readable media, user interfaces, and electronic devices.
- These and other features, aspects, and advantages of various embodiments of the present disclosure will become better understood with reference to the following description and appended claims. The accompanying drawings, which are incorporated in and constitute a part of this specification, illustrate example embodiments of the present disclosure and, together with the description, serve to explain the related principles.
- Detailed discussion of embodiments directed to one of ordinary skill in the art is set forth in the specification, which makes reference to the appended figures, in which:
-
FIG. 1 depicts a flow chart diagram of an example method to perform more efficient training of an embedding model according to example embodiments of the present disclosure. -
FIG. 2A depicts a block diagram of an example computing system according to example embodiments of the present disclosure. -
FIG. 2B depicts a block diagram of an example computing device according to example embodiments of the present disclosure. -
FIG. 2C depicts a block diagram of an example computing device according to example embodiments of the present disclosure. - Reference numerals that are repeated across plural figures are intended to identify the same features in various implementations.
- Generally, the present disclosure is directed to systems and methods which more efficiently train embedding models through the use of a cache of item embeddings for candidate items over a number of training iterations. The cached item embeddings can be “stale” embeddings that were generated by a previous version of the model at a previous training iteration. Specifically, at each iteration, the (potentially stale) item embeddings included in the cache can be used when generating similarity scores that are the basis for sampling a number of items to use as negatives in the current training iteration. For example, a Gumbel-Max sampling approach can be used to sample negative items that will enable an approximation of a true gradient. New embeddings can be generated for the sampled negative items and can be used to train the model at the current iteration.
- By re-using stale item embeddings from previous iteration(s) to guide the sampling of the negative items at the current iteration, the systems and methods of the present disclosure can avoid needing to re-compute embeddings for an entire vocabulary of items at each iteration, thereby conserving significant amounts of computational resources, such as processor usage, memory usage, network bandwidth, etc. Furthermore, example implementations of the present disclosure can leverage a streaming cache that, at any given iteration, contains embeddings for fewer than all of the possible items. Use of a streaming cache in such fashion can enable the embedding cache to be retained within the memory of a hardware accelerator (e.g., graphics processing unit, tensor processing unit, etc.), thereby greatly improving the speed and computational efficiency at which training of the model can be performed.
- More particularly, embedding models (e.g., factorized models, such as two tower neural network models) are widely used for scoring (query, document) pairs in information retrieval tasks. These models are typically trained by optimizing the model parameters to score relevant “positive” pairs higher than the irrelevant “negative” ones. While a large set of negatives typically improves the model performance, limited computation and memory budgets place constraints on the number of negatives used during training.
- In view of these challenges, the present disclosure provides a novel negative sampling technique for accelerating training (e.g., training that leverages a softmax cross-entropy loss). By using cached (possibly stale) item embeddings, the proposed techniques enables training with a large pool of negatives with reduced memory and computation. The present disclosure also provides a streaming variant of the proposed algorithms geared towards very large datasets. For example, some implementations that update only a very small fraction of the cache at each iteration can still ensure fast convergence. The proposed approaches are efficient and compare favorably with more complex, state-of-the-art approaches.
- Thus, one aspect of the present disclosure is directed to an approach to train retrieval models with cross-entropy loss using a large negative cache. For example, some implementations can utilize Gumbel-Max sampling on the cached embeddings to efficiently sample the negatives. Analysis of the convergence of example implementations of the proposed algorithm in terms of the refresh rate of the cache shows that, even for a small refresh rate, the example implementations can obtain a first-order convergence rate comparable to that of getting exact gradients using the entire dataset. Another aspect of the present disclosure is directed to a streaming version of the proposed approach. Example implementations of the streaming algorithm allow the approach to scale to very large datasets and avoid needing to maintain an up-to-date index for nearest neighbor search (or maximum inner product search). Experimental validations of example implementations using the MS MARCO and TREC 2019 passage retrieval tasks show that the example implementations can be efficiently implemented and achieve statistical performance comparable to state-of-the-art benchmarks with a computationally simpler approach that requires only a fraction of the memory.
- With reference now to the Figures, example embodiments of the present disclosure will be discussed in further detail.
- Example Dual Encoders
- Given a query q, one goal is to match the query with the most relevant documents. The set of documents is represented by D={z1, z2, . . . , zm}∈
- The training data consists of n positive (query, doc) pairs T={(q1, y1), (q2, y2), . . . (qn, yn)}, where qi is a feature vector in
-
-
- The score for a particular query, document pair can in some examples be computed as an inner product of the corresponding query and document embeddings i.e., s(q,z)=φQ(q)·φD (z). Intuitively, this represents the “similarity” between the query and documents in the embedding space. The model can be trained such that the relevant query, document pairs have high scores. Dual encoders are popular in large scale settings since they are highly efficient during training and inference as the high scoring items for a given query can be found using efficient nearest neighbors algorithms, often achieving more than 100× speed up over brute force search.
- Example Training of Dual Encoders with Cross-Entropy Loss
- One popular loss for training dual encoders is the cross-entropy loss. Even though these loss functions have been found to be highly effective, the main challenge in large scale settings is computational. To observe the computational bottleneck, consider the cross-entropy loss:
-
- where β is the inverse temperature that scales the scores.
- Here, sij=sij(θ)=ϕQ(qi;θ)·ϕD(zyi;θ) and θ∈
- On large-scale datasets, it may not be possible to have the entire dataset in memory, especially with large embedding models where the activations of the intermediate layers are persisted for back-propagation. An alternative approach is to first select a sample of documents S and use them to approximate the partition function. We thus have the following loss function:
-
- It has been observed that using a larger set of negative samples leads to better performance. A simple approach is to uniformly sample this set from
- Random sampling is often implemented using in-batch negative sampling. However, this approach is not scalable because a huge amount of accelerator memory is required to achieve a bigger pool of in-batch negatives. For example, BERT based transformers are typically used in NLP tasks but a single pair of (query, document) BERT-base consumes 600 MB of accelerator memory during training. This further limits the effectiveness of random negative sampling.
- One primary objective is to find the parameters θ* that minimize the softmax cross-entropy loss
- The present disclosure proposes example approaches that can approximate the gradient of cross-entropy loss without needing to embed every document, thereby reducing the per-iteration computation and memory requirements for gradient computation. Some example approaches leverage cached embeddings. To understand the example approaches, this section first starts with gradient estimation with Gumbel-Max sampling. The following known fact shows that if we can sample from the softmax distribution then we can get an unbiased estimate of the stochastic gradient.
-
Fact 1 The gradient of the cross-entropy has the following form: -
- where
-
- This approach can be referred to as Gumbel-Max sampling and GumbelMaxSample(βs) can be used to represent this sampling procedure. A natural estimator of the gradient is ∇
i =−βsiyi +β∇sij where J is the index in [m] obtained through Gumbel-Max sampling. Due to the feasibility of fast maximum inner product search (MIPS), Gumbel-Max sampling is an efficient way to sample from the softmax distribution; this, thereby, provides an efficient way to obtain an unbiased estimate of the gradient. In particular, the per-iteration memory requirement is reduced from O(mτ) to O(md) where i and d are the model and embedding sizes respectively. This is due to the fact that the intermediate activations need to be stored only for documents yi and J, the negative obtained through Gumbel-Max sampling. When d<<τ (which is typically the case while using large transformer models), this leads to a significant reduction in memory requirements. While the memory requirements are reduced drastically, we still need to do a forward pass on all documents to compute the scores sij. UsingFact 1, an example system would need to embed every document every iteration, which is still computationally intensive. - This motivates an algorithm where previously calculated embeddings are cached to efficiently approximate the softmax distribution pi. First note the structure of the sij=ϕQ(qi;θ)·ϕD(zj;θ). The key computational challenge in Gumbel-Max sampling is computation of the embeddings ϕD(zj;θ) for all j∈[m]. This is required to find the index J in
Fact 1, which essentially renders it computationally intractable for large m. Our approach is to compute embeddings ϕD(zj;θ) for only a few documents j∈[m] at each iteration and reuse the previously computed embeddings for the rest of the documents. In particular, let zj=ϕD(zj;θ) be the current embedding of a document and {tilde over (z)}j=ϕD(zj;θ) be its previous embedding. If θ and {tilde over (θ)} are reasonably close, then zj and {tilde over (z)}j would be similar. In such a scenario, the scores sij and {tilde over (s)}ij, and, thereby the corresponding distributions pi=(pi1, pi2, . . . , pim) and {tilde over (p)}i=({tilde over (p)}i1, {tilde over (p)}i2, . . . , {tilde over (p)}im) are also similar. As a consequence, the true gradient ∇i =−β ∇siyi +Σj=1 mpijβ∇sij and the approximation to the gradient −β∇siyi +Σj=1 m{tilde over (p)}ijβ∇sij should be similar. Note that for the approximation we take the gradient of sij and not {tilde over (s)}ij; we only replace the weight terms pij with {tilde over (p)}ij. - An example of this algorithm is provided below as
Algorithm 1. Although the algorithm is presented with a batch size of 1—it can be easily extended to larger batches. An embedding table of all documents can be maintained. At each iteration, update only a small fraction ρ of the stale embeddings are updated to ensure that pi and {tilde over (p)}i are similar. Using this approach, approximately sampling from this distribution using Gumbel-Max sampling can be performed in an efficient manner. -
Algorithm 1Cached Gumbel-Max Gradient Descent Input: Learning rate η, Document refresh fraction ρ ∈ (0,1] Initialize parameters θ0. Initialize embeddings table Ε: Εj ← ϕD(zj; θ0) for all j ∈ [m] for t ∈ 0,1, ... , T − 1 do Sample qi, yi from the training set eq i ← ϕQ(qi; θt)Calculate scores {tilde over (s)}ij ← eq i · Εj for all j ∈ [m]J ← GumbelMaxSample(β{tilde over (s)}i) ez J ← ϕD(zJ; θt)siJ ← eq i · ezJ gt ← −β∇siy i + β∇siJθt+1 ← θt − ηgt Select oldest ρm embeddings of Ε and update them to Εj ← ϕD(zj; θt+1) end for - Example Theoretical Results
- This section establishes error guarantees on the error of example implementations of the Cached Gumbel-Max gradient approximation. Before delving into the technical details, we state the following example assumptions on the query and document encoder.
-
Assumption 1 The following conditions hold for the query ϕQ and document encoder ϕD: - A1 The query and document encoder functions are both L-Lipschitz in the parameters θ. In particular, we have ∥ϕ(qi;θ)−ϕ(qi;θ′)∥2≤L∥θ−θ′∥2 for all i∈[n] and ∥ϕ(zi;θ)−ϕ(zi;θ′)∥2≤L∥θ−θ′∥2 for all i∈[m].
- A2 The query and document embeddings are bounded i.e., we have eq, ez=ϕQ(q;θ),ϕD(z;θ) satisfy ∥eq∥2, ∥ez∥2≤1.
- A3 The score functions have bounded gradients i.e., we have ∥∇sij∥2≤M for all i∈[n] and j∈[m].
- All of these assumptions are fairly mild and are common in optimization literature. As noted earlier, the second assumption does not lead to much loss of generality as a larger bound on the norm can be absorbed into the inverse temperature parameter β. In the following result, it is first shown that the error can be bounded by the
Algorithm 1 with learning rate η and refresh rate ρ, we can bound the gradient error at each iteration. -
Theorem 2 Let θt and index i be the parameters and training point selected at tth iteration of Algorithm 3, respectively. Let. J represent the Gumbel-Max index selected at that iteration. Then, underAssumption 1, we have the following gradient approximation with the cached embeddings -
- where
-
- When parameter updates are generated by
Algorithm 1 with step size η and update rate ρ, we have -
- We see that the error can be controlled by either increasing the refresh rate or decreasing the gradient norm. This provides a bound on the bias in the gradient approximation. Using the above result, the following first-order convergence guarantees can be shown. For proving convergence, the following additional assumption is used.
-
- Under the above assumption, we have the following convergence result in general non-convex settings.
- Theorem 3 Suppose we run
Algorithm 1 for T iterations with stepsize -
- Then under
Assumption -
-
- It can be observed that the bias introduced due to stale embeddings is a lower order term in the bound of Theorem 3. In particular, one can use
-
- without affecting the convergence rate of the standard SGD algorithm. For a large T (which is typical in machine learning settings), this can have a significant impact on the computational complexity since a very small fraction of the documents need to be updated at each iteration.
- Example Computational Discussion
- Some example implementations can store the cache using accelerator memory. This prevents the need to have a separate task that constantly reindexes the embeddings as they change throughout training. This is feasible for moderate size datasets. For instance, 1 million training points with an embedding dimension of 512 and feature vector dimension of 1024 will use about 6 GB memory, which can fit on a single accelerator. To calculate the perturbed nearest neighbor for Gumbel-Max sampling, a system can simply brute force calculate the largest dot product. Accelerators such as GPUs and TPUs can do this very efficiently—in example experiments it is demonstrated that the steps/second increases only a small amount as the cache size is increased. This is because the cost of computing the embeddings is much larger than the cost of doing the search due to the complexity of large transformer models.
- If faster sampling is needed, it can be accelerated by using fast nearest neighbor search. One example approach applies Gumbel perturbations to the k highest scoring elements plus a small number of random elements to perform Gumbel-Max sampling in sublinear time.
- However, having the cache on an accelerator has limitations due to the accelerator memory limits. The next section modifies
Algorithm 1 to be a streaming algorithm. - Example Conditional Sampling Negatives
- Note that Gumbel-Max sampling has a chance to sample the positive element. If this happens, then the gradient approximation is zero. Since example implementations train the model to make the score of the positive element large, this can happen often. Provided is an approach to force the sampled element to be a negative element while maintaining a similar expected gradient.
- Assume that the positive element is z1 and the negative elements are z2, z3, . . . , zm. We have that
-
- Note that
-
- is the conditional distribution where we condition on not sampling the first element. Thus we can sample from the conditional distribution as long as we properly scale the gradient by 1−pi1. We note that the value of pi1 depends on the negative embeddings. Since we have all the negatives on our accelerator, we can also calculate the partition function without much additional compute, as it has the same complexity as of our nearest neighbor search.
- Example Applications to Streaming Cache
- For very large datasets, the Gumbel-Max sampling step can become difficult. If the embedding vectors are stored in accelerator memory, then only a finite number of vectors can be stored on a fixed computational budget. If the vectors are stored in CPU memory with a CPU-based retrieval system, then the nearest neighbor index needs to be constantly recreated, which is computationally expensive for large datasets. Additionally, we see in
Theorem 2 that as the fraction of elements refreshed each iteration ρ decreases, then the learning rate needs to decrease as well to maintain a given bias in gradient estimation. Alternatively, more embeddings will need to be refreshed each iteration as the size of the dataset grows. - To address this issue, some example implementations can perform a streaming variant of the algorithms proposed herein. One difference with respect to the full dataset setting is that instead of storing all the document embeddings in memory, some streaming implementations store only a sample multiset
- An example gradient estimator approximates gradients from a cache cross-entropy loss. As an example, the cache cross-entropy loss can be defined to be the following:
-
- Some example implementations scale the weight of the negative elements by
-
- otherwise the partition function would underestimate the true partition function. This is equivalent to shifting the scores of the negative elements by
-
-
- Lemma 4 Assume Assumptions A2 and A3 hold, i.e., that the norm of the encoder embeddings is bounded by 1 and the norm of the gradients of the scores is bounded by M.
- We have that
-
- where the expectation is taken over the randomness of the elements in the cache.
-
-
Algorithm 2Streaming Cached Gumbel-Max Gradient Descent Input: Learning rate η, Cache fraction α ∈ (0,1], Document refresh fraction ρ ∈ (0,1] Initialize parameters θ0. Random sample Initialize embeddings table Ε: Εj ← ϕD(zj; θ0) for all j ∈ for t ∈ 0,1, ... , T − 1 do Sample qi, yi from the training set eq i ← ϕQ(qi; θt)J ← GumbelMaxSample(β{tilde over (s)}i, ez J ← ϕD(zJ; θt)siJ ← eq i · ezJ py i ← probability of yi under softmax({tilde over (s)}i)gt ← β(1 − py i )(−∇siyi + ∇siJ)θt+1 ← θt − ηgt Select oldest ραm embeddings set O of Ε and remove them from Ε Sample Update Εj ← ϕD(zj; θt+1) for j ∈ Update set end for - There are two sources of bias in example implementations of the gradient estimate: first due to the staleness of the cache and the second due to using a sampled set of negatives rather than the entire dataset. We handle the latter in Lemma 4. For the former, note that our error guarantees in
Theorem 2 still apply to the streaming cache, as we can bound the error between true gradient using this set of negatives with our gradient approximation. This allows us to bound the bias due to the staleness of the cache. - Since we were able to control the bias of our gradient estimator even with the streaming cache, we can establish a first order convergence theorem for training with
Algorithm 2. - Theorem 5 Assume that
Assumptions -
- Running
Algorithm 2 with a cache of size am with a refresh rate ρ creates updates θ1, θ2, . . . , θT such that -
- where we omit terms that depend on S, L, M, and β.
- If the cache size satisfies αm≥T1/4, then we do not asymptotically affect the rate of convergence.
- It can be seen that using a streaming cache smaller than the entire dataset adds only a small amount of bias in convergence and reduces the computational burden of storing embeddings and calculating nearest neighbors significantly.
-
FIG. 1 depicts a flow chart diagram of an example method according to example embodiments of the present disclosure. AlthoughFIG. 1 depicts steps performed in a particular order for purposes of illustration and discussion, the methods of the present disclosure are not limited to the particularly illustrated order or arrangement. The various steps of themethod 12 can be omitted, rearranged, combined, and/or adapted in various ways without deviating from the scope of the present disclosure. - At 14, a computing system can initialize an embedding table that includes item embeddings for at least a portion of a plurality of candidate items. For example, the candidate items can correspond to textual documents, web documents, natural language tokens, images, products, videos, movies, books, users, entities, locations, businesses, and/or any other items.
- In some implementations, the embedding table is stored in a memory portion (e.g., video random access memory, on-chip memory, high bandwidth memory, etc.) of a hardware accelerator. Example hardware accelerators include graphics processing units, tensor processing units, or other application-specific integrated circuits.
- As one example, the embedding table can be a full document cache that stores item embeddings for all of the plurality of candidate items. Thus, the cache can contain embeddings (potentially stale) for all of the possible items.
- As another example, the embedding table can be a streaming cache that stores item embeddings for fewer than all of the plurality of candidate items. For example, the streaming cache can store, at any given time, a cache fraction of the total number of candidate items. The cache fraction can be a hyperparameter that can, for example, be user-specified. Maintaining the embedding table as a streaming cache can facilitate storage of the embedding table in a memory-constrained location such as, for example, in various on-device environments and/or in the memory portion of a hardware accelerator.
- At 16, the computing system can obtain a training example from a training dataset. The training example can include a query and one or more positive items labeled as positive results for the query. The one or more positive items are a subset of the plurality of candidate items. In some implementations, the query can be a textual query, a voice query, or an image query. In some implementations, the query can itself be one of the plurality of candidate items. In some examples, the one or more positive items can be inferred from and/or labeled on the basis of feedback data such as impressions data, click through data (e.g., click through rate), eye gaze data, explicit user feedback, co-click data, co-usage data, and/or forms of feedback data or other data from which a relatedness between the query and the positive item(s) can be inferred or established.
- At 18, the computing system can process the query with an embedding model to generate a query embedding for the query. At 20, the computing system can process the one or more positive items with the embedding model to respectively generate one or more positive embeddings.
- For example, the embedding model can include one or more component models that are configured to receive an input and produce an embedding for the input in a latent embedding space. Example embedding models can include various neural networks such as feed-forward neural networks, recurrent neural networks, transformer-style neural networks, convolutional neural networks, etc.
- One example embedding model can be or include a two-tower dual encoding model that includes a query encoder and an item encoder. The query encoder can be configured to generate embeddings for queries while the item encoder can be configured to generate embeddings for items (e.g., positive and/or negative items).
- At 22, the computing system can update the embedding table to include the one or more positive embeddings for the one or more positive items.
- At 24, the computing system can generate a plurality of similarity scores for the query embedding with respect to at least a portion of the plurality of item embeddings included in the embedding table. As examples, a similarity score for a pair of embeddings can be equal to or based on a distance between the pair of embedding. The distance can be an L1 distance, an L2 distance, or other form of distance. In one specific example, a similarity score for a pair of embeddings can be generated by determining the inner product between the pair of embeddings.
- At 26, the computing system can sample from the plurality of candidate items based at least in part on the plurality of similarity scores to select one or more sampled items. As one example, the computing system can perform a Gumbel-Max sampling technique to sample from the plurality of candidate items based at least in part on the plurality of similarity scores. In other examples, vanilla sampling techniques can be used, but may have less impressive results. In other examples, sampling techniques from the REALM and/or ANCE techniques can be performed.
- At 28, the computing system can process the one or more sampled items with the embedding model to generate one or more sampled item embeddings. In some implementations, the computing system can update the embedding table to include the one or more sampled item embeddings for the one or more sampled items.
- At 30, the computing system can generate one or more similarity scores for the query embedding with respect to the one or more sampled item embeddings generated at 28.
- At 32, the computing system can determine a gradient of a loss function based on the similarity scores generated for the query embedding with respect to at least a portion of the positive items and at least a portion of the sampled items. As one example, determining the gradient at 32 can include determining an approximate gradient of a cross-entropy loss based on the similarity scores generated for the query embedding with respect to at least a portion of the positive items and at least a portion of the sampled items.
- At 34, the computing system can update one or more values of one or more parameters of the embedding model based on the gradient of the loss function. For example, the gradient can be backpropagated through the embedding model.
- At 36, the computing system can replace at least a refresh fraction of the embeddings in the embedding table using the updated embedding model. For example, the refresh fraction can be a hyperparameter that, for example, is user-specified. In some implementations, e.g., when the table is a full document cache, replacing the refresh fraction can include recomputing the embedding for the same items included in the refresh fraction. In other implementations, e.g., when the table is a streaming cache, replacing the refresh fraction can include sampling newly sampled items from the plurality of candidate items and replacing the item embeddings that were removed from the embedding table with new item embeddings generated for newly sampled items.
- After 36, the computing system can optionally return to 16. For example, iterations of 16-36 (or portions thereof) can be iteratively performed until a stopping condition is met. Example stopping conditions include a loop counter meeting a threshold number, convergence, a iteration-over-iteration change in a performance metric of the model satisfying a threshold, etc. After the iterations have been completed, the embedding model can be provided as an output (e.g., for deployment). In some implementations, the
method 12 ofFIG. 1 is performed continuously in an online fashion during deployment of the embedding model. In some implementations, although 16-36 are discussed with reference in one training example for ease of understanding, 16-36 can be performed on a batch of training examples in parallel/at the same time. -
FIG. 2A depicts a block diagram of anexample computing system 100 that according to example embodiments of the present disclosure. Thesystem 100 includes auser computing device 102, aserver computing system 130, and atraining computing system 150 that are communicatively coupled over anetwork 180. - The
user computing device 102 can be any type of computing device, such as, for example, a personal computing device (e.g., laptop or desktop), a mobile computing device (e.g., smartphone or tablet), a gaming console or controller, a wearable computing device, an embedded computing device, or any other type of computing device. - The
user computing device 102 includes one ormore processors 112 and amemory 114. The one ormore processors 112 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, an FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected. Thememory 114 can include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof. Thememory 114 can storedata 116 andinstructions 118 which are executed by theprocessor 112 to cause theuser computing device 102 to perform operations. - In some implementations, the
user computing device 102 can store or include one or more machine-learnedmodels 120. For example, the machine-learnedmodels 120 can be or can otherwise include various machine-learned models such as neural networks (e.g., deep neural networks) or other types of machine-learned models, including non-linear models and/or linear models. Neural networks can include feed-forward neural networks, recurrent neural networks (e.g., long short-term memory recurrent neural networks), convolutional neural networks or other forms of neural networks. Some example machine-learned models can leverage an attention mechanism such as self-attention. For example, some example machine-learned models can include multi-headed self-attention models (e.g., transformer models). - In some implementations, the one or more machine-learned
models 120 can be received from theserver computing system 130 overnetwork 180, stored in the usercomputing device memory 114, and then used or otherwise implemented by the one ormore processors 112. In some implementations, theuser computing device 102 can implement multiple parallel instances of a single machine-learned model 120 (e.g., to perform parallel embedding generation and/or retrieval across multiple instances of items). - Additionally or alternatively, one or more machine-learned
models 140 can be included in or otherwise stored and implemented by theserver computing system 130 that communicates with theuser computing device 102 according to a client-server relationship. For example, the machine-learnedmodels 140 can be implemented by theserver computing system 140 as a portion of a web service (e.g., an embedding-based retrieval service). Thus, one ormore models 120 can be stored and implemented at theuser computing device 102 and/or one ormore models 140 can be stored and implemented at theserver computing system 130. - The
user computing device 102 can also include one or moreuser input components 122 that receives user input. For example, theuser input component 122 can be a touch-sensitive component (e.g., a touch-sensitive display screen or a touch pad) that is sensitive to the touch of a user input object (e.g., a finger or a stylus). The touch-sensitive component can serve to implement a virtual keyboard. Other example user input components include a microphone, a traditional keyboard, or other means by which a user can provide user input. - The
server computing system 130 includes one ormore processors 132 and amemory 134. The one ormore processors 132 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, an FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected. Thememory 134 can include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof. Thememory 134 can storedata 136 andinstructions 138 which are executed by theprocessor 132 to cause theserver computing system 130 to perform operations. - In some implementations, the
server computing system 130 includes or is otherwise implemented by one or more server computing devices. In instances in which theserver computing system 130 includes plural server computing devices, such server computing devices can operate according to sequential computing architectures, parallel computing architectures, or some combination thereof. - As described above, the
server computing system 130 can store or otherwise include one or more machine-learnedmodels 140. For example, themodels 140 can be or can otherwise include various machine-learned models. Example machine-learned models include neural networks or other multi-layer non-linear models. Example neural networks include feed forward neural networks, deep neural networks, recurrent neural networks, and convolutional neural networks. Some example machine-learned models can leverage an attention mechanism such as self-attention. For example, some example machine-learned models can include multi-headed self-attention models (e.g., transformer models). - The
user computing device 102 and/or theserver computing system 130 can train themodels 120 and/or 140 via interaction with thetraining computing system 150 that is communicatively coupled over thenetwork 180. Thetraining computing system 150 can be separate from theserver computing system 130 or can be a portion of theserver computing system 130. - The
training computing system 150 includes one ormore processors 152 and amemory 154. The one ormore processors 152 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, an FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected. Thememory 154 can include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof. Thememory 154 can storedata 156 andinstructions 158 which are executed by theprocessor 152 to cause thetraining computing system 150 to perform operations. In some implementations, thetraining computing system 150 includes or is otherwise implemented by one or more server computing devices. - The
training computing system 150 can include amodel trainer 160 that trains the machine-learnedmodels 120 and/or 140 stored at theuser computing device 102 and/or theserver computing system 130 using various training or learning techniques, such as, for example, backwards propagation of errors. For example, a loss function can be backpropagated through the model(s) to update one or more parameters of the model(s) (e.g., based on a gradient of the loss function). Various loss functions can be used such as mean squared error, likelihood loss, cross entropy loss, hinge loss, and/or various other loss functions. Gradient descent techniques can be used to iteratively update the parameters over a number of training iterations. - In some implementations, performing backwards propagation of errors can include performing truncated backpropagation through time. The
model trainer 160 can perform a number of generalization techniques (e.g., weight decays, dropouts, etc.) to improve the generalization capability of the models being trained. - In particular, the
model trainer 160 can train the machine-learnedmodels 120 and/or 140 based on a set oftraining data 162. Thetraining data 162 can include, for example, a plurality of training examples. Each training example can include a query and one or more items that are labeled as positive items for the query. The positive items can be inferred and labeled as positives based on feedback data such as click through data, eye gaze data, impression data, explicit user feedback, and/or other forms of feedback data. - In some implementations, if the user has provided consent, the training examples can be provided by the
user computing device 102. Thus, in such implementations, themodel 120 provided to theuser computing device 102 can be trained by thetraining computing system 150 on user-specific data received from theuser computing device 102. In some instances, this process can be referred to as personalizing the model. - The
model trainer 160 includes computer logic utilized to provide desired functionality. Themodel trainer 160 can be implemented in hardware, firmware, and/or software controlling a general purpose processor. For example, in some implementations, themodel trainer 160 includes program files stored on a storage device, loaded into a memory and executed by one or more processors. In other implementations, themodel trainer 160 includes one or more sets of computer-executable instructions that are stored in a tangible computer-readable storage medium such as RAM, hard disk, or optical or magnetic media. - The
network 180 can be any type of communications network, such as a local area network (e.g., intranet), wide area network (e.g., Internet), or some combination thereof and can include any number of wired or wireless links. In general, communication over thenetwork 180 can be carried via any type of wired and/or wireless connection, using a wide variety of communication protocols (e.g., TCP/IP, HTTP, SMTP, FTP), encodings or formats (e.g., HTML, XML), and/or protection schemes (e.g., VPN, secure HTTP, SSL). - The machine-learned models described in this specification may be used in a variety of tasks, applications, and/or use cases.
- In some implementations, the input to the machine-learned model(s) of the present disclosure can be image data. The machine-learned model(s) can process the image data to generate an output. As an example, the machine-learned model(s) can process the image data to generate an encoded image data output (e.g., an encoded and/or compressed representation of the image data, etc.).
- In some implementations, the input to the machine-learned model(s) of the present disclosure can be text or natural language data. The machine-learned model(s) can process the text or natural language data to generate an output. As an example, the machine-learned model(s) can process the natural language data to generate a language encoding output. As another example, the machine-learned model(s) can process the text or natural language data to generate a latent text embedding output.
- In some implementations, the input to the machine-learned model(s) of the present disclosure can be speech data. The machine-learned model(s) can process the speech data to generate an output. As an example, the machine-learned model(s) can process the speech data to generate an encoded speech output (e.g., an encoded and/or compressed representation of the speech data, etc.).
- In some implementations, the input to the machine-learned model(s) of the present disclosure can be latent encoding data (e.g., a latent space representation of an input, etc.). The machine-learned model(s) can process the latent encoding data to generate an output. As an example, the machine-learned model(s) can process the latent encoding data to generate a recognition output. As another example, the machine-learned model(s) can process the latent encoding data to generate a reconstruction output. As another example, the machine-learned model(s) can process the latent encoding data to generate a search output. As another example, the machine-learned model(s) can process the latent encoding data to generate a reclustering output. As another example, the machine-learned model(s) can process the latent encoding data to generate a prediction output.
- In some implementations, the input to the machine-learned model(s) of the present disclosure can be statistical data. Statistical data can be, represent, or otherwise include data computed and/or calculated from some other data source. The machine-learned model(s) can process the statistical data to generate an output. As an example, the machine-learned model(s) can process the statistical data to generate a compressed representation of the statistical data.
- In some implementations, the input to the machine-learned model(s) of the present disclosure can be sensor data. The machine-learned model(s) can process the sensor data to generate an output. As an example, the machine-learned model(s) can process the sensor data to generate a compressed representation of the sensor data.
- In some cases, the machine-learned model(s) can be configured to perform a task that includes encoding input data for reliable and/or efficient transmission or storage (and/or corresponding decoding). For example, the task may be an audio compression task. The input may include audio data and the output may comprise compressed audio data. In another example, the input includes visual data (e.g. one or more images or videos), the output comprises compressed visual data, and the task is a visual data compression task. In another example, the task may comprise generating an embedding for input data (e.g. input audio or visual data). Additional examples of input data can include products, videos, movies, books, users, entities, locations, businesses, and/or any other item that can be embedded into a latent embedding space.
- In some cases, the input includes visual data and the task is a computer vision task. In some cases, the input includes pixel data for one or more images and the task is an image processing task.
-
FIG. 2A illustrates one example computing system that can be used to implement the present disclosure. Other computing systems can be used as well. For example, in some implementations, theuser computing device 102 can include themodel trainer 160 and thetraining dataset 162. In such implementations, themodels 120 can be both trained and used locally at theuser computing device 102. In some of such implementations, theuser computing device 102 can implement themodel trainer 160 to personalize themodels 120 based on user-specific data. -
FIG. 2B depicts a block diagram of anexample computing device 10 that performs according to example embodiments of the present disclosure. Thecomputing device 10 can be a user computing device or a server computing device. - The
computing device 10 includes a number of applications (e.g.,applications 1 through N). Each application contains its own machine learning library and machine-learned model(s). For example, each application can include a machine-learned model. Example applications include a text messaging application, an email application, a dictation application, a virtual keyboard application, a browser application, etc. - As illustrated in
FIG. 2B , each application can communicate with a number of other components of the computing device, such as, for example, one or more sensors, a context manager, a device state component, and/or additional components. In some implementations, each application can communicate with each device component using an API (e.g., a public API). In some implementations, the API used by each application is specific to that application. -
FIG. 2C depicts a block diagram of anexample computing device 50 that performs according to example embodiments of the present disclosure. Thecomputing device 50 can be a user computing device or a server computing device. - The
computing device 50 includes a number of applications (e.g.,applications 1 through N). Each application is in communication with a central intelligence layer. Example applications include a text messaging application, an email application, a dictation application, a virtual keyboard application, a browser application, etc. In some implementations, each application can communicate with the central intelligence layer (and model(s) stored therein) using an API (e.g., a common API across all applications). - The central intelligence layer includes a number of machine-learned models. For example, as illustrated in
FIG. 2C , a respective machine-learned model can be provided for each application and managed by the central intelligence layer. In other implementations, two or more applications can share a single machine-learned model. For example, in some implementations, the central intelligence layer can provide a single model for all of the applications. In some implementations, the central intelligence layer is included within or otherwise implemented by an operating system of thecomputing device 50. - The central intelligence layer can communicate with a central device data layer. The central device data layer can be a centralized repository of data for the
computing device 50. As illustrated inFIG. 2C , the central device data layer can communicate with a number of other components of the computing device, such as, for example, one or more sensors, a context manager, a device state component, and/or additional components. In some implementations, the central device data layer can communicate with each device component using an API (e.g., a private API). - The technology discussed herein makes reference to servers, databases, software applications, and other computer-based systems, as well as actions taken and information sent to and from such systems. The inherent flexibility of computer-based systems allows for a great variety of possible configurations, combinations, and divisions of tasks and functionality between and among components. For instance, processes discussed herein can be implemented using a single device or component or multiple devices or components working in combination. Databases and applications can be implemented on a single system or distributed across multiple systems. Distributed components can operate sequentially or in parallel.
- While the present subject matter has been described in detail with respect to various specific example embodiments thereof, each example is provided by way of explanation, not limitation of the disclosure. Those skilled in the art, upon attaining an understanding of the foregoing, can readily produce alterations to, variations of, and equivalents to such embodiments. Accordingly, the subject disclosure does not preclude inclusion of such modifications, variations and/or additions to the present subject matter as would be readily apparent to one of ordinary skill in the art. For instance, features illustrated or described as part of one embodiment can be used with another embodiment to yield a still further embodiment. Thus, it is intended that the present disclosure cover such alterations, variations, and equivalents.
Claims (20)
1. A computer-implemented method for training embedding models with improved efficiency, the method comprising:
for a plurality of training iterations:
processing, by a computing system, a query with an embedding model to generate a query embedding for the query;
accessing, by the computing system, an embedding table that stores a plurality of item embeddings for at least a portion of a plurality of candidate items, wherein the item embedding for at least one of the plurality of candidate items was generated by a previous version of the embedding model in one or more previous iterations;
generating, by the computing system, a plurality of similarity scores for the query embedding with respect to at least a portion of the plurality of item embeddings included in the embedding table;
sampling, by the computing system, from the plurality of candidate items based at least in part on the plurality of similarity scores to select one or more sampled items;
processing, by the computing system, the one or more sampled items with the embedding model to respectively generate one or more sampled item embeddings;
generating, by the computing system, one or more similarity scores for the query embedding with respect to the one or more sampled item embeddings; and
updating, by the computing system, one or more values of one or more parameters of the embedding model based at least in part on the similarity scores generated for the query embedding with respect to at least a portion of the sampled item embeddings;
after the plurality of training iterations, providing, by the computing system, the embedding model as an output.
2. The computer-implemented method of claim 1 , wherein sampling, by the computing system, from the plurality of candidate items based at least in part on the plurality of similarity scores comprises performing, by the computing system, a Gumbel-Max sampling technique to sample from the plurality of candidate items based at least in part on the plurality of similarity scores.
3. The computer-implemented method of claim 1 , wherein the embedding table is stored in a memory portion of a hardware accelerator.
4. The computer-implemented method of claim 1 , further comprising:
prior to processing the query with the embedding model: obtaining, by the computing system, a training example from a training dataset, wherein the training example comprises the query and one or more positive items labeled as positive results for the query, the one or more positive items being a subset of the plurality of candidate items; and
prior to generating the plurality of similarity scores:
processing, by the computing system, the one or more positive items with the embedding model to respectively generate one or more positive embeddings for the one or more positive items; and
updating, by the computing system, the embedding table to include the one or more positive embeddings for the one or more positive items of the plurality of candidate items.
5. The computer-implemented method of claim 4 , wherein updating, by the computing system, the one or more values of the one or more parameters of the embedding model comprises updating, by the computing system, the one or more values of the one or more parameters of the embedding model based at least in part on the similarity scores generated for the query embedding with respect to at least a portion of the positive items and at least the portion of the sampled items.
6. The computer-implemented method of claim 1 , wherein updating, by the computing system, the one or more values of the one or more parameters of the embedding model comprises:
determining, by the computing system, an approximate gradient of a cross-entropy loss based on the similarity scores generated for the query embedding with respect to at least a portion of the sampled item embeddings; and
updating, by the computing system, the one or more values of the one or more parameters of the embedding model based at least in part on the approximate gradient of the cross-entropy loss.
7. The computer-implemented method of claim 1 , wherein the embedding table comprises a full document cache that stores item embeddings for all of the plurality of candidate items.
8. The computer-implemented method of claim 1 , further comprising, for each iteration:
removing, by the computing system, from the embedding table the item embeddings associated with a fraction of the candidate items; and
replacing, by the computing system, the item embeddings that were removed from the embedding table with new item embeddings generated for the fraction of the candidate items.
9. The computer-implemented method of claim 1 , wherein the embedding table comprises a streaming cache that stores item embeddings for fewer than all of the plurality of candidate items.
10. The computer-implemented method of claim 9 , further comprising, for each iteration:
removing, by the computing system, from the embedding table the item embeddings associated with a fraction of the candidate items;
sampling, by the computing system, newly sampled items from the plurality of candidate items; and
replacing, by the computing system, the item embeddings that were removed from the embedding table with new item embeddings generated for newly sampled items.
11. The computer-implemented method of claim 1 , wherein the embedding model comprises a two-tower dual encoding model that comprises a query encoder and an item encoder.
12. The computer-implemented method of claim 1 , wherein the plurality of candidate items comprise:
images;
textual documents;
web documents;
products;
videos; or
entities.
13. The computer-implemented method of claim 1 , wherein the query comprises:
a textual query;
a voice query; or
an image query.
14. A computing system for training embedding models with improved efficiency, the computing system comprising one or more processors and one or more non-transitory computer-readable media that store instructions that, when executed by the one or more processors, cause the computing system to perform operations, the operations comprising:
for a plurality of training iterations:
processing, by the computing system, a query with an embedding model to generate a query embedding for the query;
accessing, by the computing system, an embedding table that stores a plurality of item embeddings for at least a portion of a plurality of candidate items, wherein the item embedding for at least one of the plurality of candidate items was generated by a previous version of the embedding model in one or more previous iterations;
generating, by the computing system, a plurality of similarity scores for the query embedding with respect to at least a portion of the plurality of item embeddings included in the embedding table;
sampling, by the computing system, from the plurality of candidate items based at least in part on the plurality of similarity scores to select one or more sampled items;
processing, by the computing system, the one or more sampled items with the embedding model to respectively generate one or more sampled item embeddings;
generating, by the computing system, one or more similarity scores for the query embedding with respect to the one or more sampled item embeddings; and
updating, by the computing system, one or more values of one or more parameters of the embedding model based at least in part on the similarity scores generated for the query embedding with respect to at least a portion of the sampled item embeddings;
after the plurality of training iterations, providing, by the computing system, the embedding model as an output.
15. The computing system of claim 14 , wherein sampling, by the computing system, from the plurality of candidate items based at least in part on the plurality of similarity scores comprises performing, by the computing system, a Gumbel-Max sampling technique to sample from the plurality of candidate items based at least in part on the plurality of similarity scores.
16. The computing system of claim 14 , wherein the embedding table is stored in a memory portion of a hardware accelerator.
17. The computing system of claim 14 , wherein the operations further comprise:
prior to processing the query with the embedding model: obtaining, by the computing system, a training example from a training dataset, wherein the training example comprises the query and one or more positive items labeled as positive results for the query, the one or more positive items being a subset of the plurality of candidate items; and
prior to generating the plurality of similarity scores:
processing, by the computing system, the one or more positive items with the embedding model to respectively generate one or more positive embeddings for the one or more positive items; and
updating, by the computing system, the embedding table to include the one or more positive embeddings for the one or more positive items of the plurality of candidate items.
18. One or more non-transitory computer-readable media that store an embedding model that has been trained by performance of operations, the operations comprising:
for a plurality of training iterations:
processing, by a computing system, a query with an embedding model to generate a query embedding for the query;
accessing, by the computing system, an embedding table that stores a plurality of item embeddings for at least a portion of a plurality of candidate items, wherein the item embedding for at least one of the plurality of candidate items was generated by a previous version of the embedding model in one or more previous iterations;
generating, by the computing system, a plurality of similarity scores for the query embedding with respect to at least a portion of the plurality of item embeddings included in the embedding table;
sampling, by the computing system, from the plurality of candidate items based at least in part on the plurality of similarity scores to select one or more sampled items;
processing, by the computing system, the one or more sampled items with the embedding model to respectively generate one or more sampled item embeddings;
generating, by the computing system, one or more similarity scores for the query embedding with respect to the one or more sampled item embeddings; and
updating, by the computing system, one or more values of one or more parameters of the embedding model based at least in part on the similarity scores generated for the query embedding with respect to at least a portion of the sampled item embeddings.
19. The one or more non-transitory computer-readable media of claim 18 , wherein the embedding table comprises a full document cache that stores item embeddings for all of the plurality of candidate items.
20. The one or more non-transitory computer-readable media of claim 18 , wherein the embedding table comprises a streaming cache that stores item embeddings for fewer than all of the plurality of candidate items.
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US17/983,130 US20230153700A1 (en) | 2021-11-09 | 2022-11-08 | Efficient Training of Embedding Models Using Negative Cache |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US202163277385P | 2021-11-09 | 2021-11-09 | |
US17/983,130 US20230153700A1 (en) | 2021-11-09 | 2022-11-08 | Efficient Training of Embedding Models Using Negative Cache |
Publications (1)
Publication Number | Publication Date |
---|---|
US20230153700A1 true US20230153700A1 (en) | 2023-05-18 |
Family
ID=86323684
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US17/983,130 Pending US20230153700A1 (en) | 2021-11-09 | 2022-11-08 | Efficient Training of Embedding Models Using Negative Cache |
Country Status (1)
Country | Link |
---|---|
US (1) | US20230153700A1 (en) |
Cited By (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US11960550B1 (en) * | 2022-10-26 | 2024-04-16 | Microsoft Technology Licensing, Llc | Embedding-based retrieval techniques for feeds |
-
2022
- 2022-11-08 US US17/983,130 patent/US20230153700A1/en active Pending
Cited By (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US11960550B1 (en) * | 2022-10-26 | 2024-04-16 | Microsoft Technology Licensing, Llc | Embedding-based retrieval techniques for feeds |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US20210073639A1 (en) | Federated Learning with Adaptive Optimization | |
Liu et al. | Federated learning meets natural language processing: A survey | |
US10832139B2 (en) | Neural network acceleration and embedding compression systems and methods with activation sparsification | |
US20230267330A1 (en) | Parameter-Efficient Multi-Task and Transfer Learning | |
US11941527B2 (en) | Population based training of neural networks | |
EP3711000B1 (en) | Regularized neural network architecture search | |
US11928601B2 (en) | Neural network compression | |
US20220171942A1 (en) | Natural Language Processing with an N-Gram Machine | |
US11797822B2 (en) | Neural network having input and hidden layers of equal units | |
WO2019099193A1 (en) | Learning neural network structure | |
US11775770B2 (en) | Adversarial bootstrapping for multi-turn dialogue model training | |
US20210383223A1 (en) | Joint Architecture And Hyper-Parameter Search For Machine Learning Models | |
US20240013059A1 (en) | Extreme Language Model Compression with Optimal Sub-Words and Shared Projections | |
US20230297783A1 (en) | Systems and Methods for Machine-Learned Prediction of Semantic Similarity Between Documents | |
US20200327450A1 (en) | Addressing a loss-metric mismatch with adaptive loss alignment | |
US20240046103A1 (en) | Augmenting attention-based neural networks to selectively attend to past inputs | |
Lindgren et al. | Efficient training of retrieval models using negative cache | |
US20240061889A1 (en) | Systems and Methods for Weighted Quantization | |
US20230153700A1 (en) | Efficient Training of Embedding Models Using Negative Cache | |
US20230401382A1 (en) | Dynamic Language Models for Continuously Evolving Content | |
Li et al. | Ensemble of fast learning stochastic gradient boosting | |
US20210326757A1 (en) | Federated Learning with Only Positive Labels | |
US20220398500A1 (en) | Partially local federated learning | |
CN116097281A (en) | Theoretical superparameter delivery via infinite width neural networks | |
WO2021034517A1 (en) | Neologism classification techniques |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
STPP | Information on status: patent application and granting procedure in general |
Free format text: DOCKETED NEW CASE - READY FOR EXAMINATION |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:LINDGREN, ERIK MICHAEL;JAKKAM REDDI, SASHANK;GUO, RUIQI;AND OTHERS;SIGNING DATES FROM 20220311 TO 20220314;REEL/FRAME:062281/0384 |