US6760756B1 - Distributed virtual web cache implemented entirely in software - Google Patents
Distributed virtual web cache implemented entirely in software Download PDFInfo
- Publication number
- US6760756B1 US6760756B1 US09/598,546 US59854600A US6760756B1 US 6760756 B1 US6760756 B1 US 6760756B1 US 59854600 A US59854600 A US 59854600A US 6760756 B1 US6760756 B1 US 6760756B1
- Authority
- US
- United States
- Prior art keywords
- node
- referencing
- data component
- nodes
- repository
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Lifetime, expires
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/95—Retrieval from the web
- G06F16/957—Browsing optimisation, e.g. caching or content distillation
- G06F16/9574—Browsing optimisation, e.g. caching or content distillation of access to content, e.g. by caching
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99931—Database or file accessing
Definitions
- the present invention pertains to a network of nodes, such as a local area network of computer systems, in which it is desired to speed up the access by some nodes to data components initially retrieved by other nodes.
- a “cache” is a memory provided in a computer system having a higher speed than a main memory of the computer system.
- the term “cache” is often used to refer to a higher speed memory circuit, e.g., an SRAM, which supplements a slower memory circuit, i.e., a DRAM.
- the term is also commonly used to refer to any form of higher speed memory which supplements a lower speed memory.
- a (portion of a) hard disk physically local to a computer system, which supplements a remote server, that delivers data to the computer system over a low speed communication link is also referred to as a cache.
- the invention is illustrated for the latter form of cache.
- a cache The principle of operation of a cache is as follows. Accesses to program instructions and data by a computer system exhibit the property of temporal locality of reference, i.e., the computer system tends to access the same data or instructions repeatedly. Caches exploit the temporal locality of reference property by storing copies of certain frequently accessed program instructions and/or data. Note that cache memories typically are more costly than main memories and therefore have a much smaller storage space. This is especially true in a scenario where the main memory is a network of servers (e.g., web servers on the Internet), whose cost can be divided by the number of computer systems that access them (numbered in the millions) as compared to the hard disk drive and memory circuits of an individual computer system which serves as the cache for that computer system.
- main memory e.g., web servers on the Internet
- Caching techniques are used extensively in computer systems and networks to achieve many ends. Many general and specific caching solutions are available to meet both general and specific needs.
- a computer system typically executes a web browser application.
- the web browser is a program which, in the very least, is able to issue commands in message packets via a wide area network, e.g., the Internet, to identify web servers containing content of interest and to retrieve from such web servers the content of interest.
- Web servers are identified using “universal resource locator” addresses or “URLs” which can be translated to IP addresses of the web servers and other commands for retrieving the content.
- “Content” is typically in the form of “web pages” or information which can be presented visually and audibly by the web browser on the computer system at which it is executed.
- a parameter is also provided for each data component for indicating the expiration date of the copy of the data component. The web browser can use this parameter to determine whether or not a copy of a data component in the cache has expired and therefore should not be used for presenting the web page. In the case that the web browser determines that the copy of the data component in the cache has expired, the copy of the data component in the cache is discarded and a new copy of the data component is downloaded from the Internet.
- each LAN has one or more proxy servers for purposes of achieving all external data communications for the computer systems on the LAN.
- the web browser applications on each computer system are configured to send all of their messages destined to the Internet to one or more proxy servers.
- the proxy servers forward the messages to the Internet and distribute messages received from the Internet to the appropriate computer system on the LAN.
- proxy servers and proxy server applications which have web caching capabilities including Microsoft Proxy ServerTM, distributed by MicrosoftTM, a company located in Redmond, Wash., and NeoserverTM, distributed by CompaqTM, a company located in Houston, Tex. These proxy servers maintain their own cache of retrieved data components. If a particular computer system on the LAN attempts to retrieve a data component for which the proxy server already stores a (non-expired) copy, the proxy server delivers to the particular computer system the cached copy. As a result, the data component can be retrieved at the computer system at a higher speed than if the data component was downloaded from the web server via the Internet.
- CARP cached array routing protocol
- each LAN or computer system is typically connected to the Internet via equipment of an Internet service provider (“ISP”) and/or network access provider (“NAP”).
- ISPs and NAPs possess facilities with servers for enabling messages, including messages bearing data components, to be communicated between the computer systems and LANs on the one hand, and the web servers on the other hand.
- the servers of the ISPs and NAPs may also be connected to, or equipped with, “cache engines,” i.e., caches, for storing frequently retrieved data components.
- Such centralized cache servers and server software include CacheflowTM, distributed by CacheflowTM Inc., located in Sunnyvale, Calif., Traffic ServerTM, distributed by InktomiTM, located in Foster City, Calif., DynaCacheTM, distributed by InfolibriaTM, located in Waltham, Mass., NetcacheTM, distributed by Network Appliance, located in Sunnyvale, Calif., and Cisco 500 Series Cache EngineTM, distributed by CiscoTM, located in San Jose Calif.
- ISP and NAP “cache engines” may employ the so-called “web cache control protocol” (“WCCP”) which redirects computer system issued data component retrieval requests from the web servers to the cache engine located at the ISP or NAP facilities.
- WCP web cache control protocol
- an ISP or NAP can deliver data components more rapidly from their cache engines (to the computer systems and LANs for whom they provide service) than they can deliver data components from web servers located at arbitrary networks. Simply stated, on average, the data components will incur more delay in the latter case as they likely must be delivered via several private networks.
- ICP Internet caching protocol
- a proxy server if a proxy server lacks a non-expired copy of a particular data component requested by a computer system, the proxy server issues a query to another proxy server to determine if that other proxy server has a copy of the respective data component.
- the proxy servers will have a high speed communication path between them and thus this technique can still provide for a more rapid delivery of data components than obtaining such data components from the web server.
- Cache appliances are even available for web server premises for speeding access to their web pages.
- An example of one such product is Novell ICSTM, which is produced by Novell, Inc.TM, located in San Jose Calif., but distributed by many original equipment manufacturers including CompaqTM, DellTM, a company located in Austin, Tex., and International Business MachinesTM, a company located in Armonk, N.Y.
- This caching product causes the web server to retrieve the data components more efficiently so that they are delivered to the requesting computer systems more quickly.
- Another web cache service, called FreeflowTM is provided by a company called Akamai Technologies Inc.TM, located in Cambridge, Mass. According to this service, the data components that form the web pages are migrated to a network of servers maintained by the FreeflowTM service.
- the web pages on the web server are then redesigned so that the URLs for their data components point to the FreeflowTM network of servers.
- the data components are actually retrieved from a server maintained by the FreeflowTM service.
- the FreeflowTM service chooses a particular cache server to deliver the data component which is “near” the computer system which requested the data component, i.e., which can most efficiently deliver the data component.
- U.S. Pat. No. 6,026,474 proposes another solution for “web caching.”
- a portion of the storage space (disk, memory circuit, etc.) of each of multiple computer systems, or nodes is allocated for use as a globally addressable shared memory space.
- Each node is provided with a shared memory subsystem control program which enables the node to access the shared memory space.
- the storage of the shared memory space is divided into atomic units, i.e., pages of, for example, 4 kilobytes.
- a unique node is assigned for persistently storing each page, wherein the unique node stores each page allocated to it in the portion of the physical memory of the node allocated to the globally addressable shared memory space.
- a “responsible node” is also assigned for tracking the identity of the persistent storage node of each page.
- a directory structure is maintained in each node which can be used to identify, for a page with any given global address, the identity of the responsible node that tracks the identity of the node that persistently stores the page with that global address.
- Another directory structure is also provided at a location in the network well-known to the nodes which maps each file to the global addresses of the pages that compose the file. Thus, to access a file, a node first accesses the well-known location to identify the global addresses of the pages that compose that file. Next, the node accesses its local directory to identify the responsible node for tracking the persistent storage node for each page.
- the node then issues a query message to the responsible node to determine the identity of the persistent storage node for each page. Once the node has determined the identity of the persistent storage node of a given page, the node can transmit to the node that serves as the persistent storage for the page a message requesting the page.
- this shared memory space can be used to enable nodes to share the caches of web browser applications installed on the nodes.
- this caching technique is performed on the “client side,” i.e., at the nodes executing web browsers, or LAN to which they are connected.
- Client side caching techniques provide many advantages over ISP/NAP side or web server side solutions including:
- client side caching solutions are not strictly mutually exclusive alternatives for the ISP/NAP side or web server side caching solutions. Rather, these various solutions can be viewed as a hierarchical caching system. Indeed, caching solutions at each of the web server, ISP/NAP and client can be used in conjunction to provide an optimized solution with an average data component retrieval time which is faster than the data component retrieval time of any individual solution used alone.
- the technique described in the '474 patent has certain shortcomings.
- the system of the '474 patent “migrates” the persistent storage of a file from node to node on each access to a file.
- the duty of serving as the persistent storage for the file is delegated to the requesting node. This is not always the desired outcome.
- a responsible node is designated for tracking the node serving as the persistent storage of a file, it is generally inefficient to change the persistent storage node each time a file is accessed.
- a method and system are provided for optimizing the local caching of one or more data components available from a server node.
- Each of plural nodes connected to a local area network is provided with a locally physically present cache.
- Each of the caches of at least some of the plurality of nodes are linked together into a single virtual cache.
- a particular one of the nodes is designated as a repository node for persistently storing a particular data component and for providing a copy of the particular data component to other referencing nodes of the plurality of nodes which lack, but which desire to access, the particular data component.
- Designation of the particular node as the repository node is unchanged solely by providing a copy of the particular data component to one of the referencing nodes which desires to access the particular data component.
- the repository function of a node for a particular data component is relatively static. For instance, assume that a first referencing node obtains from the repository node a copy of the particular data component and performs a group of one or more access operations on the copy of the data component If another referencing node lacks a copy of, but desires to access, the particular data component, a copy of the particular data component is provided from the repository node to the other referencing node. Amongst other things, this reduces the efforts of tracking the identity of the repository node for each data component. Considering that a typical node executing a browser may, over time, access thousands of data components, the reduction on processing resources can be quite substantial.
- one of the nodes is designated as a monitor node for the particular data component.
- the monitor node responds to requests by each referencing node to identify the repository node of the particular data component by providing the identity of the particular node which serves as the repository node for the particular data component.
- a referencing node which desires to access a data component it lacks, follows a hierarchical process.
- the referencing node obtains from the appropriate monitor node (designated for indicating to referencing nodes the identity of the repository node designated for storing the desired data component) the identity of the appropriate repository node of the desired data component.
- the referencing node then obtains from the repository node a copy of the desired data component.
- referencing nodes may incrementally store information, derived from one or more messages detected in the local area network, identifying various monitor nodes designated for identifying repository nodes (which in turn are designated for storing corresponding data components).
- the referencing node may issue a message destined to a group of one or more nodes (e.g., a multicast or broadcast message) requesting the identity of the appropriate monitor node which can identify the repository node storing the desired data component, or group of data components including the desired data component.
- FIG. 1 shows a network in which the invention is used.
- FIG. 2 shows a node according to an embodiment of the present invention.
- FIG. 3 shows a flowchart illustrating a process according to an embodiment of the present invention.
- FIG. 4 shows a flowchart illustrating a cache locator process according to an embodiment of the present invention.
- FIG. 5 shows a flowchart illustrating a monitor node locator process according to an embodiment of the present invention.
- FIG. 6 shows a flowchart illustrating a data locator process according to an embodiment of the present invention.
- FIG. 7 shows a portion of the network of FIG 1 , wherein nodes of the network portion are partitioned into subsets of nodes according to an embodiment of the present invention.
- FIG. 8 shows a flowchart illustrating an abort data write process according to an embodiment of the present invention.
- FIG. 9 shows a flowchart illustrating a delete data process according to an embodiment of the present invention.
- FIG. 10 shows a flowchart illustrating a monitor location query process according to an embodiment of the present invention.
- FIG. 11 shows a flowchart illustrating a data locator query process according to an embodiment of the present invention.
- FIG. 12 shows a flowchart illustrating a monitor invalidate message process according to an embodiment of the present invention.
- the present invention is illustrated for a web access Internet application, whereby multiple personal computer system nodes connected to a LAN are capable of executing web browser applications. Furthermore, in the illustration, while executing the web browser application, each node attempts to present a web page which is accessible from a web server at a location remote from the LAN, e.g., via a wide area network or the Internet. Each such web page is presumed to be composed of data components, i.e., text, audio data, still pictures, movies, graphical data, applications, etc. However, those skilled in the art will appreciate the applicability of the invention to other applications in which the common accessibility of multiple nodes to data components is desirably optimized.
- FIG. 1 shows a network 1 in which the invention is illustrated.
- the network 1 includes an enterprise network 3 , a wide area network 5 and a web server network 7 .
- Both the enterprise network 3 and the web server network 7 may be Ethernet LANs.
- the wide area network 5 illustratively is the Internet.
- the web server network 7 includes a router r 2 and a node n 2 , which may be a computer system, such as a server.
- the enterprise network 3 includes a router r 4 , hubs or switches h 2 , h 4 and h 6 and nodes n 4 , n 6 , n 8 , n 10 , n 12 , n 14 , n 16 , n 18 , n 20 , n 22 , n 24 , n 26 , n 28 , n 30 , n 32 , n 34 , n 36 , n 38 , n 40 , n 42 and n 44 , which may be personal computer systems and/or servers.
- the routers r 2 and r 4 serve to route packets to and from the Internet 5 .
- the Internet 5 is an interconnection of a plurality of private networks maintained by network access providers (NAPs) and Internet service providers (ISP), wherein the interconnection of the networks may be carried by various high capacity (i.e., T 1 , T 3 , T 4 , OC-3, OC-48, etc.) privately leased lines of the telephone network.
- Communication is achieved in the Internet using a hierarchy of protocols, including the Internet protocol (IP), the transmission control protocol (TCP), and the hypertext transfer protocol (http).
- IP Internet protocol
- TCP transmission control protocol
- http hypertext transfer protocol
- the Internet 5 can carry (in packets) messages for requesting information, and such requested information, from a source node to an appropriate destination node.
- nodes can “visit web sites” and present “web pages” by issuing queries to specific web servers for web page information.
- the web servers respond by transferring the requested web page data to the requesting nodes.
- the transfer of information across the Internet 5 e.g., from the node n 2 to the node n 20
- the network interface card 18 can distinguish packets with MAC layer addresses destined to the node in question from those that are not.
- the input device 16 receives input from a human operator, e.g., commands for visiting various web sites.
- the output device 14 is for presenting audible and visual information to a human operator, e.g., to present audio and video of web pages.
- the caches 100 of the nodes are “linked” together to form a single virtual cache that can be accessed by all of the nodes.
- each of the nodes can access the data components stored in each other node forming part of the same virtual cache.
- This “linking” of caches or “sharing” of data components amongst nodes is effected by an elaborate querying communication procedure according to the invention.
- the processors 10 of the nodes illustratively execute software programs, and maintain data structures, according to the invention which cause them to communicate as described in greater detail below to achieve the linking of caches to form a virtual cache.
- a processor 10 of a node may execute a web browser application which enables a human operator to visit various web pages, i.e., to retrieve web pages and present them.
- a node operating in this capacity will be referred to herein as a browsing node.
- the processor 10 of a node may execute software to perform one of three functions, namely, (a) referencing, or obtaining a copy of a data component for the browsing node, (b) serving as a repository or persistent storage for a data component and (c) monitoring the identity of the node serving as the repository for a data component.
- a node When serving in each of these capacities, a node is referred to herein as a referencing node, a repository node and a monitor node, respectively.
- a node can assume only one, fewer than all, or all of the above roles, i.e., a node can be any combination of a browsing node, referencing node, repository node and monitor node.
- the role of a node will vary from moment to moment according to the particular processing performed by that node at that moment in time, and the type of message received by that node.
- execution is performed by the processors 10 of the nodes and instead, for sake of brevity, the nodes will be said to perform various functions.
- each node uses its respective processor 10 , memories 22 - 26 , network interface card 18 and suitable communication software in a well-known manner in order to transmit and receive packets.
- the nodes illustratively use a TCP/IP protocol for communicating messages and data component bearing packets according to the invention. However, this is merely illustrative.
- a referencing node serves to reference, or obtain a copy of, a particular data component to be accessed.
- a referencing node achieves this using a hierarchical access process involving the steps of:
- the referencing node preferable incrementally builds and maintains a monitor table for identifying the monitor nodes for specific data components.
- Table 1 provides an example of such a monitor table.
- the monitor table Table 1 is composed of a series of entries, each entry including at least a pair of elements.
- the first element of type “URL Group”, is an identifier of a group of data components.
- the referencing node can use this element as an index, i.e., the referencing node can compare the URL Group element of a table entry to the URL of a data component to identify a corresponding matching table entry.
- the second element of type “monitor location” identifies a particular monitor node last known to the referencing node as designated for identifying the repository node for the corresponding data component having a URL that matches the URL element of the same entry.
- the referencing node storing Table 1 as its monitor table stores information indicating that the node “Snort” is the monitor node for the data component identified by the URL Group “www.mango.com/help/genhelp.html,” i.e., indicating that the monitor node Snort is designated for identifying the repository node for the data component with the URL Group “www.mango.com/help/genhelp.html”.
- the URL Group element need not refer specifically to every individual data component but can instead refer to entire groups of data components.
- One manner of partitioning data components into groups is based on the URL. As can be seen, each URL Group entry contains less information than the URL entries of the data locator table and therefore refers to all data components with the same common URL information.
- the first entry “www.somehost.com/link” refers to all data components having the common URL information “www.somehost.com/link” such as the data component with URL “www.somehost.com/linkX/ad.gif” and the data component with the URL “www.somehost.com/linkY/ad.gif”.
- the grouping chosen tends to group together data components commonly found on the same web page as these will tend to be found at the same repository node. The use and construction of the monitor table is described in greater detail below.
- a monitor table may be a “local” or a “remote” monitor table.
- a local monitor table includes all URL Groups for which the referencing node is the monitor node.
- a remote monitor table includes a list of all known nodes that act as a monitor node, and for each monitor node, the table includes a list of all known URL Groups it monitors.
- each monitor node incrementally builds and maintains information in a data locator table that the monitor uses to identify the repository node of particular data components.
- Table 2 provides an example of a data locator table:
- Each entry of the data locator table also has at least two elements.
- the element of type “URL” is similar to the URL Group of the monitor table in that the element is used as an identifier of data components to index one table entry of the data locator table.
- URL's for indicating particular data components is preferred in a web environment as this is the same manner for identifying a data component within a web page. Of course, this can be replaced with any suitable identifier.
- the use of the term “Snort” in Table 1 is for sake of illustration.
- the MAC and/or IP address of the node “Snort” is used in the monitor table entries.
- a browsing node desires to present a web page.
- the browsing node encounters a command within the web page to retrieve a data component identified by a given URL.
- the browsing node issues to a particular referencing node a request to retrieve the data component.
- the particular referencing node selected by the browsing node may be preset.
- the referencing node can be a designated Internet proxy server.
- Such a designated proxy server can be set in most web browser applications, such as Microsoft'sTM Internet ExplorerTM.
- the browsing node and referencing node can be the same node.
- step S 2 the referencing node executes a cache locator process according to which the referencing node determines the identity of the repository node designated for storing the data component of interest. This is described in greater detail below.
- step S 3 the referencing node determines if a repository node had been identified in step S 2 . If not, step S 11 is executed.
- a failure in identifying the location of a repository node can occur because the requisite monitor node that can identify it is unavailable (e. g., broken, busy, uninstalled, or not powered on, etc.). However, this also happens when the invention is reset or initialized or a data component is accessed for the first time.
- step S 4 the referencing node determines if the referencing node, itself, has been identified as the repository node. If so, the referencing node determines whether or not a cache error has occurred in step S 8 . A cache error occurs if the data in the cache has expired and therefore should not be used but rather should be discarded. If a cache error is detected, the referencing node executes the delete data process in step S 10 and then proceeds to step S 11 .
- step S 7 is executed by which the repository node returns the data to the referencing node.
- the repository node is the referencing node and therefore no significant action actually is performed.
- step S 4 the referencing node determines that the repository node is not the same as the referencing node which desires to access a copy of the data component (the referencing node lacks the data component). If so, then in step S 5 , the referencing node attempts to acquire the data component from the identified repository node. This is achieved by the referencing node issuing a message in a packet destined to the referencing node on the LAN which requests a copy of the data component. In step S 6 , the referencing node determines if an error has occurred.
- step S 6 an error is detected in step S 6 if the repository node issues a reply message in a packet destined to the referencing node indicating that the repository node does not currently store the requested data component in question. This can occur for several reasons including expiration of the copy of the data component at the repository node.
- the repository node provides a copy of the requested data component in step S 7 .
- step S 7 is executed after step S 6 , in which case the repository node and referencing node are different nodes.
- the repository node transmits to the referencing node a copy of the requested data component in one or more packets destined to the referencing node.
- step S 11 is executed by the referencing node.
- step S 11 execution may arrive at step S 11 for one of three reasons, namely: (a) the referencing node could not identify the repository node for the data component in step S 3 ; (b) the referencing node identified itself as the repository node but detected a cache error in step S 8 , thereby requiring the data component to be deleted in step S 10 ; or (c) the referencing node identified a node other than referencing node as the repository node but detected an error in this identification in step S 6 .
- each of these are indications that a valid, i.e., non-expired, copy of the data component is not present in the virtual cache (i.e., no valid, non-expired copy of the data component is stored in any of the nodes whose caches are linked together to form the virtual cache).
- the referencing node must attempt to retrieve the data component from the Internet.
- the referencing node issues a message in a packet via the Internet destined to the web server (as identified using the URL of the data component) requesting a copy of the data component.
- the referencing node determines whether or not an error has occurred in attempting to retrieve the data component via the Internet.
- the referencing node executes an abort data write process described in greater detail below.
- the abort data write process involves the referencing node communicating with a monitor node for the data component in order to inform the monitor node that the referencing node has failed to retrieve the data component.
- the monitor node if different from the referencing node, returns a message “not acknowledge” to the referencing node, thereby completing a “handshake” on the failure report.
- step S 12 Assume that in step S 12 , no error was detected by the referencing node in attempting to obtain a copy of the data component from the Internet. In such a case, the referencing node executes a write data process in step S 15 and the send monitor invalidate message process in step S 16 , if necessary.
- the writing of data components into the local cache of the referencing node may be performed, e.g., by file system software such as MangoSoft's MedleyTM. For instance, each data component can be stored in a data file that holds all common root data components (e.g., all www.somehost.com data components) for efficiency.
- step S 7 is executed whereby the “repository node” provides the data to the referencing node.
- the referencing node was forced to obtain a copy of the data component from the Internet on account of a failure to locate the repository node, or the repository node not being able to provide a copy of the data component. Therefore, in this case, the referencing node (and the monitor node, if any is designated for this data component) designate the referencing node, itself, the repository node for the data component.
- step S 7 requires no significant action.
- step S 20 the referencing node determines whether or not the cache of the referencing node, itself, stores the desired data component.
- the referencing node will look in its local cache (e.g., cache 100 of FIG. 2) to determine whether the desired data component is stored therein.
- this step can be executed by the referencing node performing the ordinary cache lookup process provided by the web browser application executing thereon.
- step S 21 if the referencing node determines that the data component is located in its local cache, then the referencing node sets an internal variable “location” to indicate that the referencing node, itself, is the repository node for the data component. The referencing node returns this value as the location of the data component in steps S 22 . Otherwise, if the referencing node determines that the data component is not stored within the referencing node itself, a monitor node locator process is executed in step S 23 followed by a data locator process in step S 24 . These processes are described in greater detail below. As a result of executing these processes, the internal variable “location” is set to indicate a presumed repository node designated for storing the data component. This value is returned in step S 22 .
- FIG. 5 illustrates the monitor node locator process in greater detail.
- the referencing node determines if it possesses information indicating the identity of the monitor node designated for identifying the repository node for the desired data component. To that end, the referencing node accesses its monitor table in order to determine if the referencing node has an entry indexed with the same URL Group element as the URL of the desired data component. If so, in step S 31 , the referencing node sets an internal variable “monitor” to equal the monitor location element in the indexed table entry with the matching URL Group identified in step S 30 . Then, the referencing node executes step S 32 in which the monitor variable value is returned.
- step S 30 the broadcast monitor location query process is executed in step S 33 .
- the referencing node issues a query message on the LAN requesting the identity of the monitor node for the URL Group for the desired data component.
- the referencing node initiates an internal timer to count for a predetermined time period.
- step S 34 the referencing node determines if its internal timer for gathering responses to its broadcast query has expired. If not, then in step S 35 , the referencing node determines whether or not it has received a response to its query message. If not, the referencing node returns to step S 34 .
- the referencing node uses some predefined criteria to determine if the received response is “better” than a previously received response.
- the predefined criteria could be a count of the total number of data components for each group for which the respective responding monitor node is designated.
- the previously received response is replaced with the recently received response. Otherwise, the recently received response is discarded.
- the criteria can distinguish the “best” monitor node as the fastest responding monitor node, i.e., the first monitor node to respond within the predefined time period.
- the referencing node can exit from the loop of steps S 34 -S 36 as soon as a response is received.
- step S 34 the timer expires in step S 34 and the referencing node executes step S 37 .
- step S 37 the referencing node determines whether or not any “monitor” nodes responded at all. If so, then in step S 38 , the referencing node sets its internal variable “monitor” to indicate the monitor node which transmitted the retained response (i.e., the “best” monitor node selected by the step S 36 ) and returns this value in step S 32 .
- the referencing node adds an entry to its monitor table with the URL Group of the desired data component as the URL Group element and the best monitor node as the monitor location element.
- the referencing node issues a broadcast or multicast message on the LAN requesting the identity of such a monitor node. Based on the responses received, the referencing node adds an entry to its monitor table so that the referencing node has such information for future use.
- each referencing node only adds an entry to its monitor table in response to requests sent by that referencing node alone. That is, each response message is addressed to the referencing node (which issued the request message to identify the monitor node for a desired data component) and only this referencing node modifies its monitor table in response to this message.
- other referencing nodes eavesdrop on the response messages and modify their monitor tables to include such an entry even though such other referencing nodes are not currently attempting to access the desired data component.
- the responding monitor nodes can issue their responses in packets containing broadcast or multicast addresses so that the responses can be received by all referencing nodes.
- the referencing node determines that no monitor node is designated (or available) for identifying the repository node for the desired data component. As noted above, this can occur because the monitor node is unavailable or because no monitor node has yet been designated for this data component (because, this data component has not been accessed since the most recent reset or initialization of the inventive process.) In such a case, the referencing node designates itself as the monitor node for the desired data component in step S 39 . In so doing, the referencing/monitor node generates a new entry in its monitor table and inserts in this entry information indicating that the referencing/monitor node, itself, is the monitor node for the desired data component.
- Such an entry includes the URL Group of the desired data component as the URL Group element and an indication of the referencing/monitor node as the monitor node.
- the referencing/monitor node sets the internal variable “monitor” to indicate that the referencing/monitor node, itself, is the monitor node for the desired data component in step S 40 , and returns this value of monitor in steps S 32 .
- FIG. 6 illustrates the steps of the data locator process.
- the referencing node determines whether or not the monitor node (identified in the monitor node locator process) is the referencing node, itself. If so, then in step S 51 , the referencing node (functioning as a potential monitor node) determines if it has information that identifies the repository node for the desired data component. To that end, the referencing/monitor node determines if its data locator table has an entry indexed by a URL element which matches the URL of the desired data component. If so, then in step S 52 , the referencing/monitor node sets an internal variable “location” equal to an indication of the storage location element of the matching data locator table entry. Then, in step S 53 , the referencing/monitor node returns this location value.
- step S 51 the referencing node lacks the identity of the repository node (i.e., the data locator table lacks an entry with a matching URL element), then this is an indication that the monitor node indication is incorrect. This can occur for several reasons including the referencing node clearing its data locator table (resetting, clearing, or initializing the referencing node). In such a case, the referencing node designates itself both the monitor node and the repository node for the desired data component. In so doing, the referencing/monitor/repository node generates a new data locator table entry for the desired data component in step S 54 . That is, the referencing/monitor/repository node inserts the URL of the desired data component into the URL element of the new table entry.
- the referencing/monitor/repository node inserts as the storage location an identifier for itself. Furthermore, the referencing/monitor/repository node increments its count of the total number of data components for the group corresponding to the new table entry. Then, in step S 55 , the referencing/monitor/repository node sets the internal variable “location” to indicate a value NOT FOUND and in step S 53 , returns this value.
- step S 50 the referencing node determines that it is not the monitor node. If so, then in step S 56 , the send data locator query to monitor process is executed. As described in greater detail below, in this step S 56 , the referencing node issues a query message in a packet destined to the monitor (identified in the monitor node locator process) requesting the identity of the repository node for the desired data component. In addition, the referencing node initiates a timer to count for a predetermined period. Next, in step S 57 , the referencing node determines whether or not the timer has expired. If not, in step S 58 , the referencing node determines whether or not a response was received from the monitor node. If not, step S 57 is executed again. If a response was received, the referencing node sets the “location” variable to indicate the repository node indicated in the returned response. This location value is then returned in step S 53 .
- the referencing node determines that the timer has expired in step S 57 . This would indicate that no monitor node response was received in reply to the referencing node's query message requesting the identity of the repository node. In such a case, the referencing node determines that no node currently serves as the monitor or repository node for the desired data component. As such, in step S 60 , the referencing node designates itself the monitor node for the data component. In so doing, the referencing/monitor node inserts in its monitor table an entry indicating that the referencing/monitor node, itself, is the monitor node for the desired data component.
- Such an entry includes the URL Group of the desired data component as the URL Group element and an indication of the referencing/monitor node as the monitor node.
- the referencing/monitor designates itself as the repository node for the data component.
- the referencing/monitor/repository node generates a new data locator table entry for the desired data component in step S 54 .
- the referencing/monitor/repository node inserts the URL of the desired data component into the URL element of the new table entry.
- the referencing/monitor/repository node inserts as the storage location element an identifier for itself.
- the referencing/monitor/repository node increments its count of the total number of data components for the group corresponding to the new table entry. Then, in step S 55 , the referencing/monitor/repository node sets the internal variable “location” to indicate a value NOT FOUND and in step S 53 , returns this value.
- FIG. 8 illustrates the abort data write process.
- the referencing node cleans up the cache data, i.e., discards any of the received erroneous data of the data component.
- the referencing node determines whether or not it is currently also designated as the monitor node for the data component. If so, the referencing node deletes the entry of the data locator table which indicates that the referencing node, itself, is also the repository node, and decrements the counter of the number of data components accessible at the referencing node in step S 73 . The counter is decremented since the referencing/monitor/repository node failed in its attempt to store the desired data component, which counter was incremented in step S 54 of FIG. 6 . Such failure is caused, e.g., by the unavailability of the node to retrieve the data component from the Internet.
- step S 72 the monitor invalidate message process is executed in step S 72 .
- the referencing node ceases execution of the process in step S 75 .
- step S 13 the abort data write process is executed in step S 13 (FIG. 3) after: (a) the referencing node fails to locate the repository node, and therefore assumes that no node currently serves as the repository node for the data component; (b) the referencing node designates itself the repository node for storing the desired data component and attempts to acquire the data component from the Internet; but (c) detects an error in the attempt.
- steps S 72 and S 73 is to remove any designation of the referencing node as the repository node.
- FIG. 9 illustrates the delete data flow process.
- the referencing node deletes from its internal cache the URL of the desired data component.
- the referencing node determines if it has also currently designated itself as the monitor node. If not, then some other monitor node is currently identifying the referencing node as the repository node. Since the referencing node is discarding its copy of the data component (as a result of the cache error detected in step S 8 of FIG. 3 ), the monitor invalidate message process is executed. Otherwise, the referencing node must also be serving as a monitor node which identifies itself as the repository node for the (discarded) copy of the desired data component.
- the referencing/monitor node deletes from its data locator table the entry which identifies the referencing/monitor node, itself, as the repository node for the data component.
- the referencing/monitor node also decreases by one its count of data components that were deleted (or over-written) and for which it is designated as a monitor.
- the referencing node ceases execution of the process in step S 81 .
- FIG. 10 illustrates in greater detail the monitor location query process. This process is executed in step S 33 of FIG. 5 .
- the referencing node transmits on the LAN a packet containing a query message requesting the identity of the monitor node designated for identifying the repository node for the desired data component.
- the desired data component illustratively is specified in the message by its URL.
- the packet uses a broadcast address which is received by all nodes. However, a multicast address can also be used, in which case the packet is accepted (at the network layer) by all nodes of the specified multicast group.
- the monitor location query process is then executed by each monitor node which accepts the query message packet from the referencing node.
- step S 82 the monitor node extracts from the query message packet the URL of the desired data component.
- step S 83 the monitor node determines if the monitor node, itself, is the specific monitor node designated for identifying the repository node of the desired data component. To that end, the monitor node searches its monitor table for an entry having a URL Group element that matches the URL extracted from the query message packet. If the monitor node is designated for the desired data component, in step S 84 the monitor node generates and transmits a response packet to the referencing node indicating its identity and the count of the total number of data components for which the monitor node can identify a repository node for this URL Group. Otherwise, the monitor node simply ceases execution of the process.
- FIG. 11 illustrates the data locator query process. This process is executed in step S 56 of FIG. 6 .
- the referencing node having identified a monitor node (ostensibly) designated for providing the identity of the repository node for the desired data component, issues a query message in a packet to the identified monitor node.
- the query message requests the identity of the repository node for the desired data component.
- the desired data component is identified in the query by its URL.
- the monitor node extracts from the query message packet the URL of the desired data component.
- the monitor node determines if it knows the identity of the repository node for the data component.
- monitor node searching its data locator table for an entry indexed by a URL element that matches the URL extracted from the query message packet. If the monitor node is designated for identifying the repository node of the desired data component, then in step S 87 , the monitor node sets an internal variable “repository” to indicate the repository node indicated in the storage locator element of the matching data locator table entry.
- the monitor node must have incorrect information regarding the repository node.
- the monitor node therefore takes steps to correct its information so that it will correctly identify the repository.
- the referencing node will designate itself the repository node.
- the monitor node likewise performs a designation operation, by which the monitor node designates the referencing node as the repository node.
- the monitor node sets the “repository” variable to NOT FOUND.
- the monitor node adds a new entry to its data locator table.
- the monitor node sets the URL element of the new entry to the URL of the desired data component extracted from the query message packet.
- the monitor node sets the storage location element to indicate the referencing node (as indicated by the source address information extracted from the received query message packet).
- the monitor node Either after executing step S 87 or step S 89 , the monitor node generates and transmits a response packet addressed to the referencing node containing the value of the repository variable. The monitor node then ceases execution of this process.
- FIG. 12 illustrates the monitor invalidate message process. This process is selectively executed in two situations where the monitor node is not the referencing node and incorrectly identified a repository node which could not provide a copy of the desired data component.
- the monitor node lacked the identity of any repository node to provide to the referencing node (step S 86 , FIG. 11 ).
- the monitor node created an entry in its data locator table under the assumption that the referencing node would designate itself the repository node (see step S 89 , FIG. 11 ).
- the referencing node detected an error while attempting to retrieve a copy of the desired data component from the Internet (step S 12 , FIG. 3 ).
- the referencing node must send a message packet to the monitor node instructing the monitor node to delete the entry in the data locator table of the monitor node identifying the referencing node as the repository node for the data component.
- the monitor node provided the identity of a repository node (step S 87 FIG. 11) but in attempting to contact the repository node (step S 5 , FIG. 3 ), the referencing node detected an error (step S 6 , FIG. 3 ).
- the referencing node designated itself the repository node and acquired the desired data component from the Internet (step S 11 , FIG. 3) without error (step S 12 , FIG. 3 ).
- the referencing node transmits a message packet to the monitor node instructing the monitor node to update its data locator table to identify the referencing node as the repository node for the data component (step S 16 , FIG. 3 ).
- step S 91 the monitor node extracts from the received message packet the URL of the data component.
- step S 92 the monitor node determines if the extracted URL matches a URL element of any entry in its data locator table. If not, the monitor ceases execution of this process. Otherwise, in step S 93 , the monitor node determines if the message includes a delete instruction. If so, then in step S 95 , the monitor deletes the matching table entry of the data locator table. The monitor node also decrements by one its count of the total number of URLs for the group which it serves as a monitor node.
- step S 94 the monitor over-writes the storage location element of the retrieved table entry with an indication for the referencing node which is the source of the message packet.
- FIG. 7 illustrates the enterprise network 3 of FIG. 1, in another illustrative embodiment of the invention, wherein the nodes of enterprise network (e.g., a LAN) 3 are partitioned into separate, non-overlapping pools or subsets of nodes.
- LAN 3 includes three subsets A, B, and C.
- Subset A includes nodes n 4 , n 6 , n 8 , n 18 , n 20 , n 22 , n 24 , n 26 , n 28 , n 30 , and n 32 .
- Subset B includes n 16 , n 34 , n 36 , n 38 , n 40 , n 42 , and n 44 .
- Subset C includes n 10 , n 12 , and n 14 .
- a virtual cache is formed for each subset of nodes A, B, and C, i.e., by linking together the caches of each node of each subset only to other nodes of the same subset.
- This partitioning and separate linking of caches can be achieved in a number of ways. However, one way to do this is to provide to each subset a unique TCP port (not shown). Each node only accepts and processes (at the layers above TCP) the packets with the TCP port number associated with its respective subset. Otherwise, the invention operates similar to that described above, on a subset by subset basis.
- This pooling technique provides an added advantage of partitioning the caching load over the nodes of LAN 3 .
- a browser node n 8 desires to access a web page for which this data component must be retrieved. Also assume that the browser node n 8 is the referencing node. Referencing node n 8 executes the cache locator process (step S 2 FIG. 3 ). Referencing node n 8 determines that the URL for the data component is not stored in the cache of node n 8 (step S 20 FIG. 4 ). Referencing node n 8 executes the monitor node locator process (step S 23 FIG. 4 ).
- Referencing node n 8 determines that it lacks in its monitor table an entry for the data component (step S 30 FIG. 5 ). Referencing node n 8 executes the broadcast monitor location query (step S 33 FIG. 5 ). Each node (e.g., nodes n 6 , n 10 -n 44 ) which functions as a monitor node receives the message and extracts the URL Group of the desired data component (step S 82 FIG. 10 ), but determines that it is not the monitor node for that data component (step S 83 FIG. 10 ). Referencing node n 8 waits for a response (step S 35 FIG. 5) until the timer expires (step S 34 FIG. 5 ), but none is received (step S 37 ).
- step S 35 FIG. 5 the timer expires
- referencing node n 8 inserts an entry in its monitor table to indicate that node 8 is the monitor for the desired data component (step S 39 ) and returns an indication of itself, i.e., node n 8 , as the monitor (steps S 40 , S 32 FIG. 5 ).
- referencing/monitor node n 8 identifying itself as the monitor step S 50 FIG. 6 determines that there is no entry in its data locator table for the desired data component (step S 51 FIG. 6 ).
- referencing/monitor node n 8 creates an entry in its data locator table for the data component indicating that node n 8 , itself, is the repository for the data component and increments its data count (step S 54 FIG. 6 ).
- Referencing/monitor/repository node n 8 then returns a “NOT FOUND” location (steps S 55 , S 53 FIG. 6, S 22 FIG. 4 ).
- referencing/monitor/repository node n 8 returns a “NOT FOUND” location (step S 3 FIG. 3 )
- node n 8 attempts to acquire the data component from the Internet and store it in its cache 100 (steps S 11 , S 12 , S 15 FIG. 3 ). No monitor invalidate message need be sent.
- referencing node n 10 wishes to access the same data component just stored in node n 8 .
- Referencing node n 10 also searches for the monitor of the data component, inevitably arriving at step S 33 at which referencing node n 10 issues a broadcast message requesting the identity of the monitor for the data component.
- step S 83 monitor node n 8 determines that it does, in fact, have an entry for the data component desired by referencing node n 10 .
- monitor node n 8 transmits a response message indicating that it is a monitor for the data component (step S 84 FIG. 10 ). This response is received by referencing node n 10 (step S 35 FIG.
- referencing node n 10 determines that a response was in fact received (step S 37 FIG. 5) and returns the identifier for the monitor node, namely, monitor node n 8 (steps S 38 , S 32 FIG 5 ).
- Referencing node n 10 also updates its monitor table to include an entry for the data component indicating that monitor node n 8 is the monitor for the data component.
- referencing node n 10 determines that the monitor node n 8 is not itself (step S 50 FIG. 6) and sends a message to the monitor node n 8 to identify the repository node (S 56 ).
- This message is received at monitor node n 8 , which extracts the URL of the desired data component (S 85 FIG. 11 ), identifies the entry of its data locator table for the desired data component (S 86 FIG. 11) and returns the repository node indicated therein (S 87 , S 90 FIG. 11 ), in this case repository node n 8 .
- the referencing node n 10 receives the response message from the monitor node n 8 (S 58 ).
- the referencing node n 10 returns the identification of the repository node for the data component provided in the message, namely, an indication of repository node n 8 (steps S 59 , S 53 FIG. 6, S 22 FIG. 4 ).
- the referencing node n 10 issues a request to acquire the data component from the repository node n 8 (step S 5 FIG. 3 ). Assuming that no error occurs (step S 6 FIG. 3 ), the data component is returned to the referencing node n 10 (step S 7 FIG. 3 ). However, if an error occurs, e.g., the repository node n 8 determines that the data component has expired, then the repository node n 8 refetches the data component from, e.g., server n 2 of web server network 7 , across the wide-area network 5 of FIG.
- the repository node n 8 upon determining that the copy of the data component has expired, returns an error to the referencing node n 8 .
- a referencing node n 12 desires to access the same data component. A sequence of steps is performed very similar to that above. Most importantly, the referencing node n 12 is provided with the data component from repository node n 8 and not node n 10 . In short, even though repository node n 8 provided the data component to referencing node n 10 , node n 8 retained its designation as the repository node.
- a referencing node n 14 desires to access the same data component. However, the copy of the data component stored in repository node n 8 has been overwritten by another data component. The sequence of steps is very similar as before. However, when step S 5 is executed, the repository node n 8 issues a message to the node n 14 indicating that node n 8 no longer stores a copy of the data component. Thus, when step S 6 is executed, referencing node n 14 detects an error. This causes referencing node n 14 to acquire the data from the Internet (steps S 11 , S 12 , S 15 FIG. 3) and store it in its cache 100 . Assume that no error occurs in obtaining the data component.
- Referencing node n 14 must issue a monitor invalidate message (step S 16 ) to the monitor node n 8 so that the monitor node n 8 no longer identifies node n 8 as the repository node. Rather monitor node n 8 should now identify repository node n 14 as the repository node for this data component. Thus, referencing/repository node n 14 issues a replace message to monitor node n 8 .
- Monitor node n 8 extracts the URL of the data component from the message (step S 91 FIG. 12 ), obtains the matching table entry from its data locator table (step S 92 FIG. 12 ), and determines that a delete message was not received (step S 93 FIG. 12 ). As such, monitor node n 8 replaces the storage location element of the entry to indicate the repository node n 14 (step S 94 FIG. 12 ).
- referencing node n 10 determines that its monitor table has an entry identifying the monitor node for this data component (step S 30 FIG. 5 ), namely, the monitor node n 8 .
- referencing node n 10 returns node n 8 as the monitor for the data component (steps S 31 , S 32 FIG. 5 ).
- the retrieval of the data component is otherwise similar as before (noting of course than monitor node n 8 now identifies repository node n 14 as the repository node for the data component so that the data component is now retrieved from repository node n 14 ).
- node n 10 desires to access the same data component, but node n 8 is currently unavailable (e.g., broken, busy, uninstalled, or not powered on, etc.).
- no response is received (step S 58 FIG. 6) before the timer expires (step S 57 FIG).
- the referencing node n 10 designates itself the monitor node and the repository node for the data component by: (1) modifying the entry in its monitor table indicating that referencing/monitor/repository node n 10 is the monitor node for this data component (step S 60 FIG.
- step S 60 FIG. 6 The referencing node n 10 returns as the location NOT FOUND (steps S 55 , S 53 ) thereby causing the referencing node n 10 to acquire the data component from the Internet (steps S 3 , S 11 , S 12 , S 15 FIG. 3 ). Note that no node invalidation (step S 16 FIG. 3) is performed as the referencing node n 10 does not know that a monitor node even exists.
- node n 8 is once again available.
- there are two monitor nodes for the data component namely, node n 8 and node n 10 .
- node n 16 desires to access the data component.
- Referencing node n 16 lacks information in its monitor table for identifying the monitor of the data component.
- node n 16 issues a broadcast message requesting the identity of the monitor node (Step S 33 FIG. 5 ). This time, more than one response is received at the referencing node n 16 (step S 35 FIG.
- the referencing node n 16 selects the best of monitor nodes n 8 and n 10 which respond to its request (step S 36 FIG. 5) using some predefined criteria. The rest of the access is similar to that described above.
Abstract
Description
TABLE 1 | |||
URL Group | Monitor Location | ||
www.uspto.gov/web/menu/pats.html | Pepper | ||
www.somehost.com/linkX | Salt | ||
www.mango.com/help/genhelp.html | Snort | ||
www.somehost.com | Garlic | ||
TABLE 2 | |||
URL | Storage Location | ||
www.somehost.com/linkX/ad.gif | Salt | ||
www.somehost.com/logo.gif | Garlic | ||
www.mangosoft.com/ | Snort | ||
www.uspto.gov | Snort | ||
Claims (58)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US09/598,546 US6760756B1 (en) | 1999-06-23 | 2000-06-21 | Distributed virtual web cache implemented entirely in software |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US14064599P | 1999-06-23 | 1999-06-23 | |
US09/598,546 US6760756B1 (en) | 1999-06-23 | 2000-06-21 | Distributed virtual web cache implemented entirely in software |
Publications (1)
Publication Number | Publication Date |
---|---|
US6760756B1 true US6760756B1 (en) | 2004-07-06 |
Family
ID=32599541
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US09/598,546 Expired - Lifetime US6760756B1 (en) | 1999-06-23 | 2000-06-21 | Distributed virtual web cache implemented entirely in software |
Country Status (1)
Country | Link |
---|---|
US (1) | US6760756B1 (en) |
Cited By (33)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20020091792A1 (en) * | 2001-01-09 | 2002-07-11 | International Business Machines Corporation | Method and apparatus for client sharing of cached content |
US20020092026A1 (en) * | 2001-01-09 | 2002-07-11 | International Business Machines Corporation | Method and apparatus for broadcast delivery of content to a client-side cache based on user preferences |
US20030004998A1 (en) * | 2001-06-29 | 2003-01-02 | Chutney Technologies, Inc. | Proxy-based acceleration of dynamically generated content |
US20030061372A1 (en) * | 2001-09-21 | 2003-03-27 | International Business Machines Corporation | Method and apparatus for caching subscribed and non-subscribed content in a network data processing system |
US20030115186A1 (en) * | 2001-12-14 | 2003-06-19 | Wilkinson Francis M. | System for controlling access to and generation of localized application values |
US20030195929A1 (en) * | 2002-04-15 | 2003-10-16 | Franke Michael Martin | Methods and system using secondary storage to store media data accessible for local area users |
US20030195924A1 (en) * | 2002-04-15 | 2003-10-16 | Franke Michael Martin | Methods and system using a local proxy server to process media data for local area users |
US20040139303A1 (en) * | 2000-02-18 | 2004-07-15 | Permabit, Inc., A Delaware Corporation | Data repository and method for promoting network storage data |
US20040167943A1 (en) * | 2003-02-26 | 2004-08-26 | Permabit, Inc., A Massachusetts Corporation | History preservation in a computer storage system |
US6820079B1 (en) * | 1997-07-25 | 2004-11-16 | Claritech Corporation | Method and apparatus for retrieving text using document signatures |
US20050044301A1 (en) * | 2003-08-20 | 2005-02-24 | Vasilevsky Alexander David | Method and apparatus for providing virtual computing services |
US20050080982A1 (en) * | 2003-08-20 | 2005-04-14 | Vasilevsky Alexander D. | Virtual host bus adapter and method |
US20050120160A1 (en) * | 2003-08-20 | 2005-06-02 | Jerry Plouffe | System and method for managing virtual servers |
US20050234961A1 (en) * | 2004-04-16 | 2005-10-20 | Pinnacle Systems, Inc. | Systems and Methods for providing a proxy for a shared file system |
US20060031450A1 (en) * | 2004-07-07 | 2006-02-09 | Yotta Yotta, Inc. | Systems and methods for providing distributed cache coherence |
US20070101061A1 (en) * | 2005-10-27 | 2007-05-03 | Guruprasad Baskaran | Customized content loading mechanism for portions of a web page in real time environments |
US20070139189A1 (en) * | 2005-12-05 | 2007-06-21 | Helmig Kevin S | Multi-platform monitoring system and method |
US20070189200A1 (en) * | 2006-02-14 | 2007-08-16 | Motorola, Inc. | Methods of distributing an installation program on a wireless link and supporting memory circuit and apparatus |
US20070276887A1 (en) * | 2006-04-28 | 2007-11-29 | Research In Motion Limited | Method of reflecting on another device a change to a browser cache on a handheld electronic device, and associated device |
WO2008065341A2 (en) | 2006-12-01 | 2008-06-05 | David Irvine | Distributed network system |
US20100058054A1 (en) * | 2006-12-01 | 2010-03-04 | David Irvine | Mssan |
US7716312B2 (en) | 2002-11-13 | 2010-05-11 | Avid Technology, Inc. | Method and system for transferring large data files over parallel connections |
US20100146074A1 (en) * | 2008-12-04 | 2010-06-10 | Cisco Technology, Inc. | Network optimization using distributed virtual resources |
US20120221711A1 (en) * | 2011-02-28 | 2012-08-30 | International Business Machines Corporation | Regular expression searches utilizing general purpose processors on a network interconnect |
US20120271904A1 (en) * | 2011-04-25 | 2012-10-25 | Ikanos Communications, Inc. | Method and Apparatus for Caching in a Networked Environment |
US8423651B1 (en) | 2010-06-07 | 2013-04-16 | Google Inc. | Cross-domain communications with a shared worker application |
US8626865B1 (en) * | 2010-06-07 | 2014-01-07 | Google Inc. | Shared worker application |
US20140040412A1 (en) * | 2012-07-31 | 2014-02-06 | Apple Inc. | Delivering content to electronic devices using local caching servers |
US8762635B1 (en) * | 2005-03-31 | 2014-06-24 | Google Inc. | Method and apparatus for selecting and storing data on a hard disk drive |
US20140280683A1 (en) * | 2012-07-31 | 2014-09-18 | Apple Inc. | Using groups of user accounts to deliver content to electronic devices using local caching servers |
US20150350342A1 (en) * | 2014-05-30 | 2015-12-03 | Apple Inc. | Using listen ranges to deliver content to electronic devices from local caching servers |
US9374603B1 (en) | 2008-04-15 | 2016-06-21 | Sprint Communications Company L.P. | Systems and methods for providing content delivery over a backhaul link in a communication system |
US10095803B2 (en) | 2012-07-31 | 2018-10-09 | Apple Inc. | Delivering content to electronic devices using local caching servers |
Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5909540A (en) * | 1996-11-22 | 1999-06-01 | Mangosoft Corporation | System and method for providing highly available data storage using globally addressable memory |
US5918229A (en) * | 1996-11-22 | 1999-06-29 | Mangosoft Corporation | Structured data storage using globally addressable memory |
US6026474A (en) * | 1996-11-22 | 2000-02-15 | Mangosoft Corporation | Shared client-side web caching using globally addressable memory |
US6112279A (en) * | 1998-03-31 | 2000-08-29 | Lucent Technologies, Inc. | Virtual web caching system |
-
2000
- 2000-06-21 US US09/598,546 patent/US6760756B1/en not_active Expired - Lifetime
Patent Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5909540A (en) * | 1996-11-22 | 1999-06-01 | Mangosoft Corporation | System and method for providing highly available data storage using globally addressable memory |
US5918229A (en) * | 1996-11-22 | 1999-06-29 | Mangosoft Corporation | Structured data storage using globally addressable memory |
US6026474A (en) * | 1996-11-22 | 2000-02-15 | Mangosoft Corporation | Shared client-side web caching using globally addressable memory |
US6112279A (en) * | 1998-03-31 | 2000-08-29 | Lucent Technologies, Inc. | Virtual web caching system |
Cited By (54)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6820079B1 (en) * | 1997-07-25 | 2004-11-16 | Claritech Corporation | Method and apparatus for retrieving text using document signatures |
US7287030B2 (en) * | 2000-02-18 | 2007-10-23 | Burnside Acquisition, Llc | Data repository and method for promoting network storage of data |
US20040139303A1 (en) * | 2000-02-18 | 2004-07-15 | Permabit, Inc., A Delaware Corporation | Data repository and method for promoting network storage data |
US20020092026A1 (en) * | 2001-01-09 | 2002-07-11 | International Business Machines Corporation | Method and apparatus for broadcast delivery of content to a client-side cache based on user preferences |
US20020091792A1 (en) * | 2001-01-09 | 2002-07-11 | International Business Machines Corporation | Method and apparatus for client sharing of cached content |
US20030004998A1 (en) * | 2001-06-29 | 2003-01-02 | Chutney Technologies, Inc. | Proxy-based acceleration of dynamically generated content |
US20030061372A1 (en) * | 2001-09-21 | 2003-03-27 | International Business Machines Corporation | Method and apparatus for caching subscribed and non-subscribed content in a network data processing system |
US7028089B2 (en) * | 2001-09-21 | 2006-04-11 | International Business Machines Corporation | Method and apparatus for caching subscribed and non-subscribed content in a network data processing system |
US7007026B2 (en) * | 2001-12-14 | 2006-02-28 | Sun Microsystems, Inc. | System for controlling access to and generation of localized application values |
US20030115186A1 (en) * | 2001-12-14 | 2003-06-19 | Wilkinson Francis M. | System for controlling access to and generation of localized application values |
US20030195929A1 (en) * | 2002-04-15 | 2003-10-16 | Franke Michael Martin | Methods and system using secondary storage to store media data accessible for local area users |
US20030195924A1 (en) * | 2002-04-15 | 2003-10-16 | Franke Michael Martin | Methods and system using a local proxy server to process media data for local area users |
US7668901B2 (en) * | 2002-04-15 | 2010-02-23 | Avid Technology, Inc. | Methods and system using a local proxy server to process media data for local area users |
US7716312B2 (en) | 2002-11-13 | 2010-05-11 | Avid Technology, Inc. | Method and system for transferring large data files over parallel connections |
US20040167943A1 (en) * | 2003-02-26 | 2004-08-26 | Permabit, Inc., A Massachusetts Corporation | History preservation in a computer storage system |
US7467144B2 (en) | 2003-02-26 | 2008-12-16 | Burnside Acquisition, Llc | History preservation in a computer storage system |
US20050080982A1 (en) * | 2003-08-20 | 2005-04-14 | Vasilevsky Alexander D. | Virtual host bus adapter and method |
US20050120160A1 (en) * | 2003-08-20 | 2005-06-02 | Jerry Plouffe | System and method for managing virtual servers |
US20050044301A1 (en) * | 2003-08-20 | 2005-02-24 | Vasilevsky Alexander David | Method and apparatus for providing virtual computing services |
US8776050B2 (en) | 2003-08-20 | 2014-07-08 | Oracle International Corporation | Distributed virtual machine monitor for managing multiple virtual resources across multiple physical nodes |
US20050234961A1 (en) * | 2004-04-16 | 2005-10-20 | Pinnacle Systems, Inc. | Systems and Methods for providing a proxy for a shared file system |
US20060031450A1 (en) * | 2004-07-07 | 2006-02-09 | Yotta Yotta, Inc. | Systems and methods for providing distributed cache coherence |
US7975018B2 (en) * | 2004-07-07 | 2011-07-05 | Emc Corporation | Systems and methods for providing distributed cache coherence |
US8762635B1 (en) * | 2005-03-31 | 2014-06-24 | Google Inc. | Method and apparatus for selecting and storing data on a hard disk drive |
US20070101061A1 (en) * | 2005-10-27 | 2007-05-03 | Guruprasad Baskaran | Customized content loading mechanism for portions of a web page in real time environments |
US20070139189A1 (en) * | 2005-12-05 | 2007-06-21 | Helmig Kevin S | Multi-platform monitoring system and method |
US20070189200A1 (en) * | 2006-02-14 | 2007-08-16 | Motorola, Inc. | Methods of distributing an installation program on a wireless link and supporting memory circuit and apparatus |
US7672269B2 (en) * | 2006-02-14 | 2010-03-02 | Motorola, Inc. | Methods of distributing an installation program on a wireless link and supporting memory circuit and apparatus |
US20070276887A1 (en) * | 2006-04-28 | 2007-11-29 | Research In Motion Limited | Method of reflecting on another device a change to a browser cache on a handheld electronic device, and associated device |
US20110179138A1 (en) * | 2006-04-28 | 2011-07-21 | Research In Motion Limited | Method of reflecting on another device a change to a browser cache on a handheld electronic device, and assocaited device |
US7937361B2 (en) * | 2006-04-28 | 2011-05-03 | Research In Motion Limited | Method of reflecting on another device a change to a browser cache on a handheld electronic device, and associated device |
US20100058054A1 (en) * | 2006-12-01 | 2010-03-04 | David Irvine | Mssan |
US20100064354A1 (en) * | 2006-12-01 | 2010-03-11 | David Irvine | Maidsafe.net |
EP2472430A1 (en) | 2006-12-01 | 2012-07-04 | David Irvine | Self encryption |
WO2008065341A2 (en) | 2006-12-01 | 2008-06-05 | David Irvine | Distributed network system |
US9374603B1 (en) | 2008-04-15 | 2016-06-21 | Sprint Communications Company L.P. | Systems and methods for providing content delivery over a backhaul link in a communication system |
US8868675B2 (en) * | 2008-12-04 | 2014-10-21 | Cisco Technology, Inc. | Network optimization using distributed virtual resources |
US20100146074A1 (en) * | 2008-12-04 | 2010-06-10 | Cisco Technology, Inc. | Network optimization using distributed virtual resources |
US8438289B1 (en) | 2010-06-07 | 2013-05-07 | Google Inc. | Cross-domain communications with a shared worker application |
US9047393B1 (en) | 2010-06-07 | 2015-06-02 | Google Inc. | Cross-domain communications with a shared worker application |
US8626865B1 (en) * | 2010-06-07 | 2014-01-07 | Google Inc. | Shared worker application |
US8423651B1 (en) | 2010-06-07 | 2013-04-16 | Google Inc. | Cross-domain communications with a shared worker application |
US8719404B2 (en) * | 2011-02-28 | 2014-05-06 | International Business Machines Corporation | Regular expression searches utilizing general purpose processors on a network interconnect |
US20120221711A1 (en) * | 2011-02-28 | 2012-08-30 | International Business Machines Corporation | Regular expression searches utilizing general purpose processors on a network interconnect |
US8972517B2 (en) * | 2011-04-25 | 2015-03-03 | Ikanos Communications, Inc. | Method and apparatus for maintaining and migrating a distributed cache in a networked environment |
US20120271904A1 (en) * | 2011-04-25 | 2012-10-25 | Ikanos Communications, Inc. | Method and Apparatus for Caching in a Networked Environment |
US20150172409A1 (en) * | 2011-04-25 | 2015-06-18 | Ikanos Communications, Inc. | Method and apparatus for caching in a networked environment |
US20140040412A1 (en) * | 2012-07-31 | 2014-02-06 | Apple Inc. | Delivering content to electronic devices using local caching servers |
US20140280683A1 (en) * | 2012-07-31 | 2014-09-18 | Apple Inc. | Using groups of user accounts to deliver content to electronic devices using local caching servers |
US9736262B2 (en) * | 2012-07-31 | 2017-08-15 | Apple Inc. | Using groups of user accounts to deliver content to electronic devices using local caching servers |
US10095803B2 (en) | 2012-07-31 | 2018-10-09 | Apple Inc. | Delivering content to electronic devices using local caching servers |
US10154109B2 (en) * | 2012-07-31 | 2018-12-11 | Apple Inc. | Delivering content to electronic devices using local caching servers |
US20150350342A1 (en) * | 2014-05-30 | 2015-12-03 | Apple Inc. | Using listen ranges to deliver content to electronic devices from local caching servers |
US10033818B2 (en) * | 2014-05-30 | 2018-07-24 | Apple Inc. | Using listen ranges to deliver content to electronic devices from local caching servers |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US6760756B1 (en) | Distributed virtual web cache implemented entirely in software | |
US9602618B2 (en) | Method and system for dynamic distributed data caching | |
Barish et al. | World wide web caching: Trends and techniques | |
US7565450B2 (en) | System and method for using a mapping between client addresses and addresses of caches to support content delivery | |
CA2233731C (en) | Network with shared caching | |
US7689661B2 (en) | Method and system for community data caching | |
US7577754B2 (en) | System and method for controlling access to content carried in a caching architecture | |
KR100473671B1 (en) | Load balancing cooperating cache servers | |
US7725596B2 (en) | System and method for resolving network layer anycast addresses to network layer unicast addresses | |
US6799214B1 (en) | System and method for efficient content delivery using redirection pages received from the content provider original site and the mirror sites | |
CA2410860C (en) | Reverse content harvester | |
US7213062B1 (en) | Self-publishing network directory | |
WO2002056182A2 (en) | Method and system for community data caching | |
WO2000079362A2 (en) | Distributed virtual web cache implemented entirely in software | |
EP1277327B1 (en) | System and method for using network layer uniform resource locator routing to locate the closest server carrying specific content | |
Malet | Distributed Web Crawling Using Network Coordinates |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: MANGOSOFT CORPORATION, MASSACHUSETTSFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:DAVIS, SCOTT H.;DIETTERICH, DANIEL J.;ASSELIN, PAUL D.;AND OTHERS;REEL/FRAME:010990/0260Effective date: 20000621 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
AS | Assignment |
Owner name: MANGOSOFT INTELLECTUAL PROPERTY, INC., NEW YORKFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:MANGOSOFT CORPORATION;REEL/FRAME:018247/0438Effective date: 20060911 |
|
FPAY | Fee payment |
Year of fee payment: 4 |
|
REMI | Maintenance fee reminder mailed | ||
AS | Assignment |
Owner name: MANGOSOFT INTELLECTUAL PROPERTY, INC., NEW YORKFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:MANGOSOFT CORPORATION;REEL/FRAME:028089/0846Effective date: 20120423 |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
SULP | Surcharge for late payment |
Year of fee payment: 7 |
|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:MANGOSOFT INTELLECTUAL PROPERTY INC.;REEL/FRAME:028687/0383Effective date: 20120501 |
|
FPAY | Fee payment |
Year of fee payment: 12 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044695/0115Effective date: 20170929 |