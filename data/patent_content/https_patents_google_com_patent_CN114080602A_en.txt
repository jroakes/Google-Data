CN114080602A - Camera input as an automatic filter mechanism for video search - Google Patents
Camera input as an automatic filter mechanism for video search Download PDFInfo
- Publication number
- CN114080602A CN114080602A CN202080044843.5A CN202080044843A CN114080602A CN 114080602 A CN114080602 A CN 114080602A CN 202080044843 A CN202080044843 A CN 202080044843A CN 114080602 A CN114080602 A CN 114080602A
- Authority
- CN
- China
- Prior art keywords
- query
- text
- visual input
- search results
- computing device
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/50—Information retrieval; Database structures therefor; File system structures therefor of still image data
- G06F16/53—Querying
- G06F16/532—Query formulation, e.g. graphical querying
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/50—Information retrieval; Database structures therefor; File system structures therefor of still image data
- G06F16/53—Querying
- G06F16/535—Filtering based on additional data, e.g. user or group profiles
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/50—Information retrieval; Database structures therefor; File system structures therefor of still image data
- G06F16/55—Clustering; Classification
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/50—Information retrieval; Database structures therefor; File system structures therefor of still image data
- G06F16/58—Retrieval characterised by using metadata, e.g. metadata not derived from the content or metadata generated manually
- G06F16/583—Retrieval characterised by using metadata, e.g. metadata not derived from the content or metadata generated manually using metadata automatically derived from the content
- G06F16/5846—Retrieval characterised by using metadata, e.g. metadata not derived from the content or metadata generated manually using metadata automatically derived from the content using extracted text
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/50—Information retrieval; Database structures therefor; File system structures therefor of still image data
- G06F16/58—Retrieval characterised by using metadata, e.g. metadata not derived from the content or metadata generated manually
- G06F16/5866—Retrieval characterised by using metadata, e.g. metadata not derived from the content or metadata generated manually using information manually generated, e.g. tags, keywords, comments, manually generated location and time information
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/70—Information retrieval; Database structures therefor; File system structures therefor of video data
- G06F16/73—Querying
- G06F16/732—Query formulation
- G06F16/7328—Query by example, e.g. a complete video frame or video sequence
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/70—Information retrieval; Database structures therefor; File system structures therefor of video data
- G06F16/73—Querying
- G06F16/732—Query formulation
- G06F16/7335—Graphical querying, e.g. query-by-region, query-by-sketch, query-by-trajectory, GUIs for designating a person/face/object as a query predicate
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/70—Information retrieval; Database structures therefor; File system structures therefor of video data
- G06F16/78—Retrieval characterised by using metadata, e.g. metadata not derived from the content or metadata generated manually
- G06F16/7867—Retrieval characterised by using metadata, e.g. metadata not derived from the content or metadata generated manually using information manually generated, e.g. tags, keywords, comments, title and artist information, manually generated time, location and usage information, user ratings
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N20/00—Machine learning
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/045—Combinations of networks
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/06—Physical realisation, i.e. hardware implementation of neural networks, neurons or parts of neurons
- G06N3/061—Physical realisation, i.e. hardware implementation of neural networks, neurons or parts of neurons using biological neurons, e.g. biological neurons connected to an integrated circuit
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
Abstract
A method includes receiving a text query at a first time, receiving a visual input associated with the text query at a second time after the first time, generating text based on the visual input, generating a composite query based on a combination of the text query and the text based on the visual input, and generating search results based on the composite query, the search results including a plurality of links to content.
Description
This application claims benefit of U.S. application No.62/895,278 filed on 3/9/2019, the disclosure of which is incorporated herein by reference in its entirety.
Technical Field
Example embodiments relate to searching for content and storing searchable content using a user interface.
Background
Searching content (e.g., articles, information, instructions, videos, etc.) typically involves typing text (e.g., a search string) into a text box and initiating (e.g., by clicking on a key or clicking a button) a search of a data structure (e.g., a database, a knowledge graph, a file structure, etc.) using a user interface (e.g., a browser, an application, a website, etc.). The search may be text-based and the search response or result may be a set of links to content determined to be relevant to the text or search string. The results may be displayed on a user interface.
Disclosure of Invention
In a general aspect, an apparatus, system, non-transitory computer-readable medium (having computer-executable program code stored thereon that is executable on a computer system), and/or a method, may perform a process by a method comprising: the method includes receiving a text query at a first time, receiving a visual input associated with the text query a second time after the first time, generating text based on the visual input, generating a composite query based on a combination of the text query and the text based on the visual input, and generating search results based on the composite query, the search results including a plurality of links to content.
In another general aspect, an apparatus, a system, a non-transitory computer-readable medium (having computer-executable program code stored thereon that is executable on a computer system), and/or a method may perform a process by a method comprising: the method includes receiving a text query, receiving visual input associated with the query, generating search results based on the text query, generating text metadata based on the visual input, filtering the search results using the text metadata, and generating filtered search results based on the filtering, the filtered search results providing a plurality of links to content.
In yet another general aspect, an apparatus, a system, a non-transitory computer-readable medium (having computer-executable program code stored thereon that is executable on a computer system), and/or a method may perform a process by a method comprising: the method includes receiving content, receiving visual input associated with the content, performing object identification on the visual input, generating semantic information based on the object identification, and storing the content and the semantic information associated with the content.
Implementations may include one or more of the following features. For example, the composite query may be a first composite query. The creation of the first composite query may include performing object identification on the visual input and performing semantic query addition on the query using at least objects identified based on the object identification to generate the first composite query, wherein the search results are based on the first composite query. The performing of object identification may use a trained machine learning model. The performing of object identification may use a trained machine learning model, the trained machine learning model may generate a classifier for the object in the visual input, and the performing of semantic query addition may include generating text based on the visual input based on the classifier for the object.
The method may further include determining whether a first confidence level in the identification of the object satisfies a first condition, and performing semantic query addition on the query using at least the identified object satisfying the first condition to generate a second composite query, the search results may be based on the second composite query. The method may further include determining whether a second confidence level in the identification of the object satisfies a second condition, and performing semantic query addition on the query using at least the identified object satisfying the second condition to generate a third composite query, wherein the search results are based on the third composite query. The second confidence level may be higher than the first confidence level. The first condition and the second condition may be configurable by a user.
Drawings
Example embodiments will become more fully understood from the detailed description given herein below and the accompanying drawings, wherein like elements are represented by like reference numerals, which are given by way of illustration only and thus do not limit example embodiments and wherein:
fig. 1A illustrates a block diagram of a user interface device according to at least one example embodiment.
Fig. 1B illustrates a block diagram of a user interface device according to at least one example embodiment.
Fig. 2A illustrates a block diagram of an apparatus according to at least one example embodiment.
Fig. 2B illustrates a block diagram of a memory according to at least one example embodiment.
FIG. 3 illustrates an example use case of an automatic filter mechanism for video searching in accordance with at least one example embodiment.
FIG. 4 illustrates a block diagram of a method for building a search query with visual input, according to at least one example embodiment.
Fig. 5 illustrates a block diagram of a signal flow for visual matching using indexed video content, according to at least one example embodiment.
FIG. 6 illustrates a flow diagram of a method for building a search query with visual input, according to at least one example embodiment.
Fig. 7 illustrates a flow diagram of a method of visual matching using indexed video content, according to at least one example embodiment.
Fig. 8 illustrates a flow diagram of a method of visual matching of video content according to at least one example embodiment.
FIG. 9A illustrates layers in a convolutional neural network without sparsity constraints.
FIG. 9B illustrates layers in a convolutional neural network with sparsity constraints.
FIG. 10 illustrates a block diagram of a model according to an example embodiment.
FIG. 11 illustrates an example of a computer device and a mobile computer device according to at least one example embodiment.
It should be noted that these figures are intended to illustrate the general characteristics of the method structures and/or materials utilized in certain example embodiments, and are intended to supplement the written description provided below. The drawings, however, are not to scale and may not precisely reflect the precise structural or performance characteristics of any given embodiment, and should not be interpreted as defining or limiting the scope of values or properties encompassed by example embodiments. For example, the relative thicknesses and positioning of molecules, layers, regions and/or structural elements may be reduced or exaggerated for clarity. The use of similar or identical reference numbers in the various figures is intended to indicate the presence of similar or identical elements or features.
Detailed Description
A user may be interested in finding, for example, a video with particular content. However, text-based searches may not produce the most relevant search results (e.g., links to content) and/or may produce an excessive number of search results, which may or may not be relevant. For example, the search is limited by text, and the user may not know the keywords to search.
Example embodiments describe mechanisms that include using an input image to generate (or help produce) text that can be used as search text. For example, the images may be used to generate text used in a search and/or text to be concatenated to previously entered text. In addition, the input image may be used when uploading content. The input image may be used to generate text that may be stored as keywords associated with the content and used to produce (or assist in producing) results in future searches for content.
Example embodiments are more efficient and/or useful because images may be used to generate search text that may be more complete with respect to content of interest to a user. As a result, the amount of time a user may need to sort (sort through) may be significantly reduced because the user does not have to filter hundreds or thousands of search results (e.g., links to content) to find relevant content (e.g., product reviews, videos, price comparisons, instructions for use, etc.).
Fig. 1A illustrates a block diagram of a user interface device according to at least one example embodiment. As shown in fig. 1A, device 105 may include a User Interface (UI) 110. UI110 may include text box 115, button 120, and text box 125. In an example embodiment, text box 115 may be configured to allow text entry and use of search or search text within the text. Text box 125 may be configured to display search results. In the example of FIG. 1A, initially text box 115-1 includes text item 1 as search text. After the search is complete, text box 125-1 includes search results, which include result 1, result 2, result 3,. and result n. Further, the UI110 may be configured to generate contextual information query text (e.g., location, previous search history, and preferences) without the user explicitly typing the query text. The context information query text may be concatenated to the search text (e.g., text query, query string, etc.).
A user of UI110 may operate (e.g., click, push, press, etc.) button 120. In response to operation of the button 120, the UI 130 may become visible (e.g., open, pop-up, etc.) on the device 105 (shown as a dashed rectangle on the device 105). The UI 130 includes buttons 135, an image display part 140, and buttons 145. The button 135 may be configured to trigger selection of an image (e.g., captured via a camera interface, selected for storage, etc.). In response to selecting an image, the image may be displayed in the image display portion 140 (e.g., as a thumbnail image). Displaying the image in the image display portion 140 may give the user of the UI an opportunity to confirm that the image is as needed and/or desired. Button 145 may be configured to trigger generation of a search term and close UI 130 (e.g., no longer displayed) based on the selected image (e.g., as displayed in image display portion 140).
In response to completing the action with the UI 130, the text box 115-2 includes text item 1 and items 2 and 3 as search text. Items 2 and 3 may be search terms or semantic information generated based on the selected image. The additional search terms or semantic information may be more accurate because the search terms relate to items that should be of interest (e.g., coffee pot, flower, car, book, car, etc.). In response to triggering a new search, text box 125-2 includes search results, including result a, result b, result c.
In an example use case, a user may type a stationary coffee pot in text box 115 as a text query (e.g., text used in a search) and trigger a search for content. The results list may be returned and displayed in text box 125. The results list may include content related to repairing the coffee pot for a number of makes and models of coffee pots. The user may scroll through (scan through) a list of results for a particular brand and model, or the user may click on button 120 to cause UI 130 to be displayed. The user can photograph the damaged coffee maker displayed in the image display part 140 and click the button 145. Clicking on button 145 may trigger analysis of the image and generate semantic-based information (e.g., text) based on the image. The semantic information may be the make and model of the coffee machine, e.g., repair coffee pot, make, model, that is concatenated to the text query. A new result list is then generated using the concatenated text queries (e.g., semantic queries). The new results list may be based on the new search or the filter of the original search. Thus, the new results list may have content (e.g., video) at the top of the results list (e.g., ranked high) describing or showing how to repair the make, model coffee machine. Alternatively, the results list may not include content that does not include the make and model of the coffee machine. The new results list is displayed in text box 125. The new result list may be more accurate because the use of semantic information results in minimal scanning of the result list for the desired content by the user.
According to an example embodiment, the new result list should be more accurate than the original search due to the additional (e.g., concatenated) search terms. The new result list may limit or reduce the amount of time that the user may need to sort through to find the desired content as compared to the original result list. The new results list may be ranked based on the additional search terms. The ranking may result in content that includes additional search terms with higher rankings. Thus, the new results list may include the content of additional search terms that are included at the top (e.g., first, second, beginning, etc.) of the new results list.
Fig. 1B illustrates a block diagram of a user interface device according to at least one example embodiment. As shown in fig. 1B, device 150 includes a User Interface (UI) 155. UI 155 includes buttons 160, 165, 170, 175, and text box 180. In an example embodiment, a user of UI 155 may operate (e.g., click, push, press, etc.) button 160. In response to operation of button 160, a file selection window may be opened and the user may select content (e.g., video, instructions, articles, etc.). The user may then type the name of the content in text box 180. The name may be part of a keyword that will result in a link to content being included in the search result list. For example, the keywords may be repairs and coffee pots (which may describe the content of the video).
A user of UI 155 may operate (e.g., click, push, press, etc.) button 170. In response to operation of button 170, UI 130 may become visible (e.g., open, pop-up, etc.) on device 150 (shown on device 150 as a dashed rectangle). The UI 130 includes buttons 135, an image display part 140, and buttons 145. The button 135 may be configured to trigger selection of an image (e.g., captured via a camera interface, selected for storage, etc.). In response to selecting an image, the image may be displayed in the image display portion 140 (e.g., as a thumbnail image). Displaying the image in the image display portion 140 may give the user of the UI an opportunity to confirm that the image is as needed and/or desired. Button 145 may be configured to trigger generation of a search term and close UI 130 (e.g., no longer displayed) based on the selected image (e.g., as displayed in image display portion 140).
In response to completing the action with the UI 130, the text box 185 includes text item 1, item 2, item 3,.. and item n as items describing the image. Thus, the items describing the image may be additional keywords or semantic information that will result in links to content included in the search result list. For example, in addition to keyword repairs and coffee machines, keyword brands, models, serial numbers, etc. may be additional keywords based on images. In an example implementation, new terms (e.g., semantic query text) may be used as feedback to tools (e.g., Machine Learning (ML) models) to improve the tools (e.g., train ML models.
The UI 130 may include associated functionality that may identify objects and portions of objects in an image and generate items or semantic information associated with the objects. Further, UI 130 may include and/or be associated with a memory that may include data structures that store code implementing the functionality, data structures for storing images, items, etc., as well as searchable data structures (e.g., databases, knowledge graphs, file structures, etc.). The UI 130 may be implemented as code stored in a memory and executed by a processor.
In an example use case, a user may upload (e.g., using button 160) content (e.g., a video) on how to repair a coffee pot. The user may click on button 120 to display UI 130. The user can take a picture of a coffee pot (e.g., a coffee pot that may be damaged) displayed in the image display part 140 and click the button 145. Clicking on button 145 may trigger image analysis and generate semantic information (e.g., text) based on the image. The semantic information may be the make and model of the coffee machine. The uploaded content may be stored in association with semantic information (e.g., as metadata or textual metadata). Thus, content on how to repair the coffee maker may be stored in association with the make and model of the coffee maker. Future searches for uploaded content, how to repair the coffee pot, including text queries that include semantic information, make and model numbers, generated using techniques similar to the semantic information associated with the uploaded content, should result in a link to the uploaded content in the results list. This may result in a more accurate result list when uploading and storing content using image-based semantic information and searching for content using image-based semantic information.
Fig. 2A illustrates a block diagram of a portion of an apparatus including a search mechanism, according to at least one example embodiment. As shown in fig. 2A, the apparatus 200 includes at least one processor 205, at least one memory 210, and a controller 220. The at least one memory includes a search memory 225. The at least one processor 205, the at least one memory 210, and the controller 220 are communicatively coupled via a bus 215.
In the example of fig. 2A, apparatus 200 may be at least one computing device and should be understood to represent virtually any computing device configured to perform the techniques described herein. Accordingly, the apparatus 200 may be understood to include various components that may be utilized to implement the techniques described herein, or different or future versions thereof. For example, the apparatus 200 is illustrated as including at least one processor 205, and at least one memory 210 (e.g., computer-readable storage medium).
Thus, the at least one processor 205 may be utilized to execute instructions stored on the at least one memory 210. Thus, the at least one processor 205 may implement the various features and functions described herein, or additional or alternative features and functions (e.g., search mechanisms or tools). The at least one processor 205 and the at least one memory 210 may be utilized for various other purposes. For example, the at least one memory 210 may be understood to represent examples of various types of memory and associated hardware and software that may be used to implement any of the modules described herein. According to an example embodiment, the apparatus 200 may be included in a larger system (e.g., a server, a personal computer, a laptop computer, a mobile device, etc.).
At least one memory 210 may be configured to store data and/or information associated with search memory 225 and/or apparatus 200. The at least one memory 210 may be a shared resource. For example, the apparatus 200 may be an element of a larger system (e.g., a server, a personal computer, a mobile device, etc.). Thus, the at least one memory 210 may be configured to store data and/or information associated with other elements (e.g., web browsing or wireless communication) within a larger system (e.g., an audio encoder with quantization parameter modification).
The controller 220 may be configured to generate and communicate various control signals to various blocks in the apparatus 200. The controller 220 may be configured to generate control signals to implement a search using object recognition using image-based techniques or other techniques described herein.
At least one processor 205 may be configured to execute computer instructions associated with search memory 225 and/or controller 220. At least one processor 205 may be a shared resource. For example, the apparatus 200 may be an element of a larger system (e.g., a server, a personal computer, a mobile device, etc.). Thus, the at least one processor 205 may be configured to execute computer instructions associated with other elements within a larger system (e.g., serving web pages, web browsing, or wireless communications).
Fig. 2B illustrates a block diagram of a memory according to at least one example embodiment. As shown in FIG. 2B, search memory 225 may include an object identification 230 block, a term generator 235 block, a search data structure 240 block, an image data store 245 block, and a term data store 250 block.
The object recognition 230 block may be configured to identify any objects included in an image uploaded using the UI 130. The object may include a primary object (e.g., a coffee machine) and any portion of the primary object (e.g., identifying text, components, etc.) in the image. Identifying the object may include using a trained Machine Learning (ML) model. The trained ML model may be configured to generate classifier and/or semantic information or text associated with the object. The ML model may include a function call to a server that includes code to execute the model. The ML model may include function calls within the code of the UI (e.g., UI 130), which may include the code that is to execute the model (e.g., as an element of object recognition 230 block). Examples of ML models for object recognition are described in more detail below.
The search data structure 240 block may be configured to store a search data structure, metadata, and/or a link to a search data structure. The search data structure 240 may be, for example, a database, a knowledge graph, a file structure, and the like. Search data structure 240 may be configured to receive a search string and return a results list based on the search string.
The image data store 245 block may be configured to store images and/or metadata associated with images as input via the UI 130. Item data store 250 blocks may be configured to store items and/or metadata, as generated by item generator 235. The items may be stored in association with the object classification.
Fig. 3 illustrates an example use case of an automatic filter mechanism 300 for video searching in accordance with at least one example embodiment. At block 310, a computing device (e.g., laptop, desktop, mobile device, etc.) may receive an initial query (e.g., a search query/string). The initial query may include text entered using a user interface (e.g., UI 110). The initial query may include additional text based on the image (e.g., using the UI 130). The initial query may include a search data structure for searching video content based on text. The initial query may return search results or a list of results, including a link to at least one piece of content (e.g., a video). In some implementations, the initial query may be an "original query" (e.g., block 410 of fig. 4 and block 510 of fig. 5) and/or the home page feed may be a "visual input" (e.g., block 420 of fig. 4 and block 520 of fig. 5) as described below with reference to fig. 4-7.
At block 320, the computing device may output a video (e.g., a video discovery) based on the search performed at 310. A user of a user interface (e.g., UI110) may select content (e.g., a video) using links to search results. Content (e.g., video) may be displayed on a computing device (e.g., device 105). In some implementations, the search results may be based on a search performed using a search query with visual input as described below with reference to fig. 4 and 6, or visual matching using indexed content as described in detail below with reference to fig. 5 and 7. The links to the videos selectable at block 320 may be related videos that are filtered based not only on the query text but also on visual input (e.g., images) provided by the user (e.g., via UI 130), as described above.
At block 330, the user may view/view the content (e.g., video), and at block 340, perform in-depth research (e.g., further interaction) on the content. For example, in some implementations, a user may watch a video and may perform in-depth research on the video. The in-depth study may also be reading product instructions (e.g., assembly or maintenance instructions), environmental examples (e.g., planting or caring for flowers), and the like.
At block 350, the user may perform one or more actions based on the content (e.g., in-depth research of the video). In some embodiments, the actions performed by the user may include online shopping, repairing damaged appliances, planting flowers, and so forth.
Fig. 4 illustrates a block diagram 400 of a method for building a search query with visual input, according to at least one example embodiment. In an example embodiment, a user may be searching for content. For example, a user may be searching for a video on how to repair a damaged lamp.
At block 410, a user may type a query in a search engine. For example, a user may type text in a user interface (e.g., UI110) configured to implement (or facilitate) a search for content using a search engine. In some implementations, the query (e.g., referred to as the original query in fig. 4) can be "how" to search for strings (e.g., "how to repair"). The search engine may be associated with a video repository or application. Thus, the query may be searching for videos (e.g., "how to repair" the videos).
At block 420, the user may be prompted to upload an image or picture. The images uploaded by the user may be referred to as "visual input" from the user. In some implementations, for example, the visual input can be triggered in response to a user entering a search string, in response to some user interaction in a user interface, in response to a user clicking a button, and so forth. In some implementations, the user may be prompted to upload an image prior to entering the query. In other words, block 420 may be performed before block 410.
At block 430, a composite query may be created based on a combination of the query and the text based on the visual input. In some implementations, for example, a composite query can be created based on semantic query additions. In some implementations, the text based on the visual input can be generated in response to object recognition of an object in the visual input. For example, a trained ML model may be used to identify objects in a visual input. The identified objects may be classified and the items (e.g., text) may correspond to the classifications. The trained ML model may be configured to generate classifier and/or semantic information or text associated with the object. The confidence or confidence level of the trained ML model may be configured based on the likelihood that the object recognition and/or classification is accurate.
In an example embodiment, at block 430, the composite query may generate a composite query "how to repair lights" based on the generic object identification. For example, in general object identification, a classification of a particular product or object may not be available.
In additional example implementations, at block 440, the composite query may be identified based on the particular object to generate a composite query "how to repair [ branded ] lights". A particular object identification may be used if the confidence level in the object identification at 432 meets some condition (a first condition) that may be, for example, above or below a first threshold. In particular object recognition, for example, a particular product or category of objects may be identified.
In another additional example implementation, at block 450, the composite query may generate a composite query "how to repair the damaged [ branded ] lights" based on the object and the context identification. The object and context identification may be used if the confidence level in the object and context identification satisfies a certain condition (a second condition) at 442, which may be, for example, above or below a second threshold. For example, in an "object + context" identification, a specific/general identification and understanding of the user's intent may not be available.
Thus, more relevant search results may be generated based on a composite query that starts from a general object identification and moves to a full contextual identification (e.g., visually entered). The more complete or accurate the contextual identification of the visual input, the less time a user needs to sort through search results (e.g., links to content) for relevant content (e.g., product reviews, videos, price comparisons, instructions for use, etc.).
Fig. 5 illustrates a block diagram 500 of a signal flow for visual matching using indexed video content, according to at least one example embodiment. As shown in FIG. 5, at block 510, a user may type a query in a user interface (e.g., UI110) associated with a search engine (e.g., similar to block 410 of FIG. 4). In some implementations, the query (e.g., referred to as the original query in fig. 5) may be a search for content (e.g., a video), e.g., a user may be searching for "methods of operation" videos using a string similar to "how to fix" as shown in fig. 4 and may generate search results (e.g., a link to the video).
At block 520, the user may be prompted to upload an image or picture (e.g., similar to block 420 of fig. 4). The image uploaded by the user (e.g., the image of the damaged light) may be referred to as "visual input" from the user. In some implementations, for example, the visual input can be triggered in response to a user entering a search string, in response to some user interaction in a user interface, in response to a user clicking a button, and so forth.
At block 522, the visual input (e.g., the image uploaded at block 520) may be analyzed for semantic and visual entity information using, for example, a multi-pass approach. For example, semantic and visual entity information (e.g., manufacturer name, model number, etc. of a broken light) may be extracted from images/pictures uploaded by the user. In some implementations, the text based on the visual input can be generated in response to object recognition of an object in the visual input. For example, a trained ML model may be used to identify objects in a visual input. The identified objects may be classified and the items (e.g., text) may correspond to the classifications. The trained ML model may be configured to generate classifier and/or semantic information or text associated with the object. The confidence or confidence level of the trained ML model may be configured based on the likelihood that the object recognition and/or classification is accurate.
At block 524, metadata for the visual input may be generated. In some implementations, for example, the visually entered metadata can be used to filter search results generated by the search query. For example, the metadata may include at least one item such as "damaged" "[ manufacture name ]" "lamp" "serial number ]" operation method "" repair "" [ color of lamp ] ".
In some implementations, for example, a video visual metadata library (block 538) can be generated as illustrated with reference to block 530 and 538 and described in detail below. It should be noted that video visual metadata bases (e.g., video corpus with videos tagged with metadata, etc.) may be created and stored separately. In other words, the present disclosure describes a mechanism that can perform visual matching with indexed video content using metadata of the visual input.
At block 530, the video may be uploaded to a video content server. For example, a video (or some other content) may be uploaded by a user using a user interface (e.g., UI 155). At block 532, frames of each video may be analyzed for semantic and visual entity or object information using, for example, a multi-pass approach, similar to the operations performed on visual input (e.g., uploaded images) at block 522. In an example implementation, the analysis for semantic and visual entity or object information may include using a trained Machine Learning (ML) model. The trained ML model may be used to identify objects in the frame. The identified objects may be classified and the items (e.g., text) may correspond to the classifications. The trained ML model may be configured to generate classifier and/or semantic information or text associated with the object. The ML model may include a function call to a server that includes code to execute the model. The ML model may include function calls within the code of the UI (e.g., UI 130), which may include code for executing the model (e.g., as elements of object recognition 230 blocks). Examples of ML models for object recognition are described in more detail below.
In addition or alternatively, at block 534, in some implementations, for example, manual semantic content tagging can be performed. In some implementations, images associated with the video can be uploaded. The image may be analyzed for semantic and visual entity or object information. In an example implementation, the analysis for semantic and visual entity or object information may include using a trained Machine Learning (ML) model. The trained ML model may be used to identify objects in the frame. The identified objects may be classified and the items (e.g., text) may correspond to the classifications. The trained ML model may be configured to generate classifier and/or semantic information or text associated with the object. The ML model may include a function call to a server that includes code to execute the model. The ML model may include function calls within the code of the UI (e.g., UI 130), which may include code for executing the model (e.g., as elements of object recognition 230 blocks). Examples of ML models for object recognition are described in more detail below.
In some implementations, for example, content (e.g., video) creators can tag their own videos for metadata that is available for association with other users' visual inputs. This may be helpful because its accuracy may be higher than automatic visual input.
At block 536, video visual metadata for the video may be generated. In some implementations, for example, time-stamped semantic and visual entities can be generated. In some implementations, for example, the timestamp can be used for more specific suggestions of related video content. In the context of a broken lamp, the recommendation may include a specification to repair the lamp 0:32 to 0:48 in the video (rather than the entire video, which may include complete comments on other lamps).
At block 538, a video visual metadata repository may be generated based on the frame-by-frame analysis performed on the video at 532 and the video visual metadata generated at 536. It should be noted that the processes described with respect to blocks 530, 532, 534, 536, and/or 538 may be performed on thousands/millions of videos to generate a video visual metadata repository.
At block 540, the search results for the query at block 510 may be filtered by performing a match on the visual metadata. In some implementations, for example, visually input metadata (e.g., generated at 524) can be used to filter the search results based on the combination of blocks 510 and 538. For example, the metadata of the visual input may be used to filter videos generated by the search query.
At 550, the final search results may be presented to the user. In some implementations, search results based on the query at block 510 may output as output a 1000s video link, related videos and unrelated videos. However, by filtering the search results by comparing the visually entered metadata with metadata in a metadata repository (generated and stored offline), the search results may be narrowed to produce more relevant search results.
The described mechanism provides a user with a useful service of finding videos based on search strings and input images uploaded by the user. Accordingly, more relevant search results may be generated based on the metadata comparison as described above.
Fig. 6 and 7 illustrate block diagrams of methods according to at least one example embodiment. The steps described with respect to fig. 6 and 7 may be performed as a result of execution of software code stored in memory (e.g., at least one memory 210 and/or search memory 225) associated with an apparatus (e.g., as shown in fig. 2A and 2B) and executed by at least one processor (e.g., at least one processor 205) associated with the apparatus. However, alternative embodiments are contemplated, such as a system embodied as a dedicated processor. Although the steps described below are described as being performed by a processor, the steps are not necessarily performed by the same processor. In other words, the at least one processor may perform the steps described below with respect to fig. 6 and 7.
FIG. 6 illustrates a block diagram of a method for building a search query with visual input, according to at least one example embodiment. In step S610, a computing device (e.g., device 105) may receive a query. In some implementations, for example, the query can be a search string, e.g., "how to repair," as described above with reference to fig. 4. The search string may be entered as a user input in a user interface (e.g., UI 110).
In step S620, the computing device may receive a visual input associated with the query. In some implementations, the visual input can be triggered in response to the user entering a search string. In an example embodiment, once the user types "how to fix" in the search bar, the user may be prompted to upload, for example, an image/picture of "broken lights" (or any other image associated with the query, e.g., a broken coffee machine). In some implementations, the visual input can be triggered in response to a user interacting with the user interface (e.g., pressing a button). A user may use a camera of a computing device to take an image (e.g., of a light) and upload it. The image being uploaded may be referred to as visual input.
In step S630, the computing device may create a composite query based at least on a combination of the query and the visual input. In some implementations, for example, the composite query can be a first composite query ("how to fix lights") that can be created by performing object identification (e.g., using a trained ML model) on the image (e.g., detecting one object in the image uploaded by the user) and adding semantic queries ("how to fix") in the query using the identified object ("lights"). The object identification described above may be referred to as a general object identification.
In some implementations, for example, the computing device may further determine whether a confidence level (e.g., a first confidence level) in the object identification satisfies a condition, e.g., a first condition, which may be, e.g., above or below a first threshold. The confidence level may be associated with how confident the algorithm is in the object identification. In some implementations, for example, the confidence level may depend on the quality of the visual input received from the user and/or the availability of secondary information (e.g., the manufacturer, model, etc. of the lamp). If the confidence level is deemed to satisfy the condition, the computing device may generate a composite query, e.g., a second composite query, using at least the identified objects (particular object identifications) based at least on semantic additions on the query, e.g., "how to repair the [ branded ] light. "
In some implementations, for example, the computing device may determine whether a confidence level (e.g., a second confidence level) in the object identification satisfies a condition, e.g., a second condition, which may be, e.g., above or below a second threshold. As described above, the confidence level may be associated with how confident the algorithm is in the object identification. In some implementations, for example, the confidence level can be based on the quality of the visual input received from the user and/or the availability of secondary information (e.g., the manufacturer, model, etc. of the light). If the confidence level is deemed to satisfy the second condition, the computing device may generate a composite query, e.g., a third composite query, based on the semantic query addition using at least the object and context identifications to generate, e.g., the third composite query- "how to repair the damaged [ branded ] light. "
In some implementations, for example, the first condition and/or the second condition can be configured by a user. For example, in some embodiments, the first condition may be set to a 93% threshold and the second condition may be set to a 95% threshold. In other words, if a particular/accurate understanding of the object meets a 95% threshold, the composite query may rely on object and context identification to improve search results, and so forth. In some implementations, the condition may be configured by the user and/or based on the term the user is searching for.
At step S640, the computing device may generate search results based on the composite query (e.g., the first, second, or third composite query). In some implementations, for example, the search results can include multiple links to content (e.g., video) that is relevant as output.
Thus, based on the above, the results of a search query may be optimized by expanding (e.g., appending, expanding, etc.) the search query with visual input. In other words, search results based on the original query may be filtered based on visual input from the user.
Fig. 7 illustrates a block diagram of a visual matching method using indexed video content, according to at least one example embodiment. For example, in some implementations, the method may be performed by the computing device of fig. 2A. In step S710, a computing device (e.g., device 105) may receive a query. In some implementations, the query can be a search string, e.g., "how to fix," as described above with reference to fig. 5. The search string may be entered by the user as input in a user interface (e.g., UI 110). The operation at step S710 may be similar to the operation at block 310.
In step S720, a visual input associated with the query is received (the operation may be similar to that at block 320). For example, the computing device may receive a visual input associated with the query. In some implementations, the visual input can be triggered in response to the user entering a search string. In one example embodiment, once the user types "how to fix" in the search bar, the user may be prompted to upload, for example, an image/picture of "light" or "broken light" (or any other image associated with the query, e.g., a broken coffee machine). In some implementations, the visual input can be triggered in response to a user interacting with the user interface (e.g., pressing a button). The user may take an image of the damaged light using the camera of the computing device and upload it. The image being uploaded may be referred to as a visual input.
In step S730, the computing device may generate search results based on the query. In some implementations, the computing device may generate search results based on a search performed using the query (e.g., as received at block 510).
In step S740, the computing device may filter the search results using the visually entered metadata. In some implementations, an object in the visual input can be identified (e.g., using tools of the UI 130). The object may include a primary object (e.g., a coffee machine) and any portion of the primary object (e.g., identifying text, components, etc.) in the image. Identifying the object may include using a trained Machine Learning (ML) model. The trained ML model may be configured to generate classifier and/or semantic information or text associated with the object. Metadata may be associated with the identified object. The search results may be filtered to include content (e.g., video) whose metadata matches the metadata of the visual input (e.g., objects in the image identified at block 510).
In some implementations, for example, the computing device may filter the search results based on the query at block 510 by matching the visually input metadata with metadata information in a metadata repository. In other words, the results are filtered to output content (e.g., video) that includes metadata that matches the metadata of the visual input (e.g., the image at block 510).
At step S750, the computing device generates and presents a final search result. In an example embodiment, the final search results may be presented in a user interface (e.g., UI 110).
Thus, based on the foregoing, the results of a search query may be optimized by expanding (e.g., appending, expanding, etc.) the search query with visual input and comparing metadata of the image to metadata of millions of content (e.g., stored video). In other words, search results based on the original query may be filtered based on visual input from the user to provide more relevant search results.
Fig. 8 illustrates a flow diagram of a method of visual matching of video content according to at least one example embodiment. As shown in fig. 8, in step S810, a computing device (e.g., device 150) receives content (e.g., video). For example, a user may generate and upload content (e.g., video) to a searchable data structure associated with, for example, a mobile device application, a website, a web application, and so forth. In some implementations, a user can upload content (e.g., video) using a user interface (e.g., UI 155).
In step S820, the computing device receives a visual input associated with the content. For example, a user may trigger a user interface to cause input of an image. The image may be captured (e.g., by a camera of the computing device), selected from a file system, and so forth. In an example embodiment, the image may be input using a pop-up user interface (e.g., UI 130).
In step S830, the computing device generates textual and/or semantic information based on the visual input. In some implementations, an object in the visual input can be identified (e.g., using tools of the UI 130). The object may include a primary object (e.g., a coffee machine) and any portion of the primary object (e.g., identifying text, components, etc.) in the image. Identifying the object may include using a trained Machine Learning (ML) model. The trained ML model may be configured to generate classifier and/or semantic information or text associated with the object. Metadata may be associated with the identified object.
In step S840, the computing device stores the text and/or semantic information as metadata associated with the content. In some implementations, the metadata can be stored in response to a user interaction (e.g., clicking a button) in the user interface.
FIG. 9A illustrates layers in a convolutional neural network without sparsity constraints. FIG. 9B illustrates layers in a convolutional neural network with sparsity constraints. With reference to fig. 9A and 9B, various configurations of neural networks for use in at least one example embodiment will be described. An example hierarchical neural network is shown in fig. 9A. The hierarchical neural network includes three layers 910, 920, 930. Each layer 910, 920, 930 may be formed from a plurality of neurons 905. In this embodiment, the sparsity constraint has not been applied. Thus, all of the neurons 905 in each layer 910, 920, 930 are networked with all of the neurons 905 in any adjacent layer 910, 920, 930.
The example neural network shown in fig. 9A is computationally uncomplicated due to the small number of neurons 905 and layers. However, the arrangement of the neural network shown in fig. 9A may not be scalable to larger size networks due to the density of connections (e.g., connections between neurons/layers). In other words, the computational complexity may be too large because the size of the network scales in a non-linear manner. Thus, if a neural network needs to be scaled up in a large number of dimensions to work, networking all neurons 905 in each layer 910, 920, 930 with all neurons 905 in one or more adjacent layers 910, 920, 930 may be computationally overly complex.
The initial sparsity condition may be used to reduce the computational complexity of the neural network. For example, if a neural network is used as the optimization process, the neural network approach may process high-dimensional data by limiting the number of connections between neurons and/or layers. An example of a neural network with sparse constraints is shown in fig. 9B. The neural network as shown in fig. 9B is arranged such that each neuron 905 is connected to only a small number of neurons 905 in adjacent layers 940, 950, 960. This may form an incompletely connected neural network, and may be scaled to work with higher dimensional data. For example, a neural network with sparsity constraints may be used as an optimization process for the model and/or to generate a model for rating/demoting replies based on user posted replies. The smaller number of connections allows the number of connections between neurons to scale in a substantially linear fashion compared to a fully networked neural network.
In some embodiments, neural networks may be used that are fully or incompletely connected but in a different specific configuration than that described with respect to fig. 9B. Furthermore, in some embodiments, convolutional neural networks that are not fully connected and have a lower complexity than fully connected neural networks may be used. Convolutional neural networks may also utilize pooling or max pooling to reduce the dimensionality (and thus complexity) of the data flowing through the neural network. Other methods may be used to reduce the computational complexity of the convolutional neural network.
FIG. 10 illustrates a block diagram of a model according to an example embodiment. Model 1000 may include a Convolutional Neural Network (CNN) of a plurality of convolutional layers 1015, 1020, 1025, 1035, 1040, 1045, 1050, 1055, 1060 and an additive layer 1030. The plurality of convolutional layers 1015, 1020, 1025, 1035, 1040, 1045, 1050, 1055, 1060 may each be one of at least two types of convolutional layers. As shown in fig. 10, convolutional layer 1015 and convolutional layer 1025 may be of a first convolutional type. Convolutional layers 1020, 1035, 1040, 1045, 1050, 1055, and 1060 can be of a second convolution type. Images (e.g., uploaded using UI 130) and/or video frames (e.g., uploaded using UI 155) may be input to the CNN. Normalization layer 1005 may convert the input image into an image 1010 that may be used as an input to the CNN. Model 1000 further includes a detection layer 1075 and a suppression layer 1080. The model 1000 may be based on a computer vision model.
The normalization layer 1005 may be configured to normalize the input image. The normalization may include converting the image to MxM pixels. In an example implementation, the normalization layer 1005 may normalize the input image to 300x300 pixels. Further, normalization layer 1005 may generate a depth associated with image 1010. In an example embodiment, the image 1010 may have multiple channels, depths, or feature maps. For example, an RGB image may have three channels, a red (R) channel, a green (G) channel, and a blue (B) channel. In other words, there are three (3) channels for each of the MxM (e.g., 300x300) pixels. The feature map may have the same structure as the image. However, instead of pixels, the feature map has values based on at least one feature (e.g., color, frequency domain, edge detector, etc.).
The convolutional layer or convolution may be configured to extract features from the image. The features may be based on color, frequency domain, edge detector, etc. The convolution may have a filter (sometimes called a kernel) and a stride. For example, the filter may be a 1x1 filter with a stride of 1 (or a 1x1xn, 1x1 filter for transforming to n output channels is sometimes referred to as a point-by-point convolution), which results in an output of cells (e.g., add, subtract, multiply, etc.) generated based on a combination of characteristics of the cells of each channel at the location of the MxM trellis. In other words, feature maps having more than one depth or channel are combined into a feature map having a single depth or channel. The filter may be a 3x3 filter with a stride of 1, which results in output of fewer cells per lane of the MxM trellis or signature.
The output may have the same depth or number of channels (e.g., a 3x3xn filter, where n is the depth or number of channels, sometimes referred to as a depth-by-depth filter) or a reduced depth or number of channels (e.g., a 3x3xk filter, where k < the depth or number of channels). Each channel, depth, or feature map may have an associated filter. Each associated filter may be configured to emphasize a different aspect of the channel. In other words, different features may be extracted from each channel based on the filter (this is sometimes referred to as a depth-by-depth separable filter). Other filters are within the scope of the present disclosure.
Another type of convolution may be a combination of two or more convolutions. For example, the convolution may be a depth-wise and point-wise separable convolution. This may include, for example, a two-step convolution. The first step may be a depth convolution (e.g., a 3x3 convolution). The second step may be a point-by-point convolution (e.g., a 1x1 convolution). The depth-wise convolution and point-wise convolution may be separable convolutions in that different filters (e.g., filters that extract different features) may be used for each channel or each depth of the feature map. In one example implementation, the point-by-point convolution may transform the feature map to include c channels based on a filter. For example, an 8x8x3 feature map (or image) may be transformed into an 8x8x256 feature map (or image) based on a filter. In some implementations, more than one filter may be used to transform the feature map (or image) into an mxmxmxxc feature map (or image).
The convolution may be linear. Linear convolution describes the output as Linear Time Invariant (LTI) in terms of input. The convolution may also include a rectifying linear unit (ReLU). ReLU is an activation function that rectifies the convolved LTI output and limits the rectified output to a maximum value. The ReLU may be used to accelerate convergence (e.g., more efficient computation).
In an example embodiment, the first type of convolution may be a 1x1 convolution and the second type of convolution may be a depth-wise and point-wise separable convolution. Each of the plurality of convolutional layers 1020, 1035, 1040, 1045, 1050, 1055, 1060 may have a plurality of cells and at least one bounding box per cell. The convolutional layers 1015, 1020, 1025 and the additive layer 1030 may be used to transform the image 1010 into a feature map of the same size as the feature map of the Conv _3 layer of the VGG-16 standard. In other words, the convolutional layers 1015, 1020, 1025 and the additive layer 1030 may transform the image 1010 into a 38x38x512 feature map.
Convolutional layers 1035, 1040, 1045, 1050, 1055, 1060 may be configured to incrementally transform the feature map into a 1x1x256 feature map. Such incremental conversion may result in the generation of bounding boxes (regions of a feature map or grid) of different sizes that can detect objects of various sizes. Each cell may have at least one associated bounding box. In an example embodiment, the larger the trellis (e.g., number of cells), the smaller the number of bounding boxes per cell. For example, the largest trellis may use three (3) bounding boxes per cell, while the smaller trellis may use six (6) bounding boxes per cell.
The detection layer 1075 receives data associated with each bounding box. In an example embodiment, one of the bounding boxes may include a primary object (e.g., a coffee machine) and a plurality of additional bounding boxes may include identifying text, components, etc. associated with the primary object. The data may be associated with features in the bounding box. The data may indicate an object in the bounding box (which may not be an object or part of an object). An object may be identified by its characteristics. Data is sometimes referred to cumulatively as a class or classifier. A class or classifier may be associated with an object. The data (e.g., bounding box) may also include a confidence score (e.g., a number between zero (0) and one (1)).
After CNN processes the image, the detection layer 1075 may receive and include multiple classifiers indicative of the same object. In other words, an object (or a portion of an object) may be within multiple overlapping bounding boxes. However, the confidence score for each classifier may be different. For example, a classifier that identifies a portion of an object may have a lower confidence score than a classifier that identifies a complete (or substantially complete) object. The detection layer 1075 may also be configured to discard bounding boxes that have no associated classifier. In other words, the detection layer 1075 may discard bounding boxes with no objects therein.
The suppression layer 1080 may be configured to rank the bounding boxes based on the confidence scores and may select the bounding box with the highest score as the classifier that identifies the object. The suppression layer may repeat the ordering and selection process for each bounding box having the same or substantially similar classifiers. As a result, the suppression layer may include data (e.g., a classifier) that identifies each object in the input image.
As described above, the convolutional layers 1015, 1020, 1025 and the additive layer 1030 may generate a 38x38x512 feature map. Each cell (e.g., each of the 1444 cells) may have at least three (3) bounding boxes. Thus, at least 4332 bounding boxes may be communicated from the add layer 1030 to the detect layer 1075. Convolutional layers 1035 and 1040 may be a second type of convolution and are configured to perform a 3x3x1024 convolution and a 1x1x1024 convolution. The result may be a profile that is 19x19x 1024. Each cell (e.g., each of 361 cells) may have at least six (6) bounding boxes. Thus, at least 2166 bounding boxes may be communicated from convolutional layer 1040 to detection layer 1075.
However, additional bounding boxes may be added to the feature map for each convolutional layer. For example, a fixed number of bounding boxes (sometimes referred to as anchor points) may be added to each profile based on the number of cells (e.g., MxM). These bounding boxes may cover more than one cell. The larger the number of cells, the more bounding boxes are added. As the number of bounding boxes increases, the likelihood of capturing objects within the bounding box may increase. Thus, by increasing the number of bounding boxes per cell and/or by increasing the number of fixed frames per feature map, the likelihood of identifying objects in an image can be increased. Further, the bounding box may have a location on the feature map. As a result, more than one identical object (e.g., text, component, etc.) may be identified as being in the image.
Once a model (e.g., model 1000) architecture has been designed (and/or is in operation), the model should be trained (sometimes referred to as a development model). A model may be trained using a plurality of images (e.g., products, parts of products, environmental objects (e.g., plants), instruction booklets, etc.). Training the model may include generating a classifier and semantic information associated with the classifier.
FIG. 11 shows an example of a computer device 1100 and a mobile computer device 1150 that can be used with the techniques described herein. Computing device 1100 is intended to represent various forms of digital computers, such as laptops, desktops, workstations, personal digital assistants, servers, blade servers, mainframes, and other appropriate computers. Computing device 1150 is intended to represent various forms of mobile devices, such as personal digital assistants, cellular telephones, smart phones, and other similar computing devices. The components shown herein, their connections and relationships, and their functions, are meant to be exemplary only, and are not meant to limit implementations of the inventions described and/or claimed in this document.
The memory 1104 stores information within the computing device 1100. In one implementation, the memory 1104 is a volatile memory unit or units. In another implementation, the memory 1104 is a non-volatile memory unit or units. The memory 1104 may also be another form of computer-readable medium, such as a magnetic or optical disk.
The storage device 1106 can provide mass storage for the computing device 1100. In one implementation, the storage device 1106 may be or contain a computer-readable medium, such as a floppy disk device, a hard disk device, an optical disk device, or a tape device, a flash memory or other similar solid state memory device, or an array of devices, including devices in a storage area network or other configurations. The computer program product may be tangibly embodied in an information carrier. The computer program product may also contain instructions that, when executed, perform one or more methods such as those described above. The information carrier is a computer-or machine-readable medium, such as the memory 1104, the storage device 1106, or memory on processor 1102.
The high speed controller 1108 manages bandwidth-intensive operations for the computing device 1100, while the low speed controller 1112 manages lower bandwidth-intensive operations. Such allocation of functions is exemplary only. In one implementation, the high-speed controller 1108 is coupled (e.g., through a graphics processor or accelerator) to memory 1104, a display 1116, and to high-speed expansion ports 1110, which may accept various expansion cards (not shown). In this implementation, low-speed controller 1112 is coupled to storage device 1106 and low-speed expansion port 1114. The low-speed expansion port, which may include various communication ports (e.g., USB, bluetooth, ethernet, wireless ethernet), may be coupled to one or more input/output devices, such as a keyboard, a pointing device, a scanner, or a network device such as a switch or router, e.g., through a network adapter.
The computing device 1100 may be implemented in a number of different forms, as shown in the figure. For example, it may be implemented as a standard server 1120, or multiple times in a group of such servers. It may also be implemented as part of a rack server system 1124. It may also be implemented in a personal computer such as a laptop computer 1122. Alternatively, components from computing device 1100 may be combined with other components in a mobile device (not shown), such as device 1105. Each such device may contain one or more computing devices 1100, 1150, and an entire system may be made up of multiple computing devices 1100, 1150 communicating with each other.
The processor 1152 may execute instructions within the computing device 1150, including instructions stored in the memory 1164. The processor may be implemented as a chipset of chips that include separate or multiple analog and digital processors. The processor may provide, for example, for coordination of the other components of the device 1150, such as control of user interfaces, applications run by device 1150, and wireless communication by device 1150.
The memory may include, for example, flash memory and/or NVRAM memory, as described below. In one implementation, a computer program product is tangibly embodied in an information carrier. The computer program product contains instructions that, when executed, perform one or more methods such as those described above. The information carrier is a computer-or machine-readable medium, such as the memory 1164, expansion memory 1174, or memory on processor 1152, that may be received, for example, over transceiver 1168 or external interface 1162.
In a general aspect, an apparatus, system, non-transitory computer-readable medium (having computer-executable program code stored thereon that is executable on a computer system), and/or a method, may perform a process by a method comprising: the method includes receiving a text query at a first time, receiving a visual input associated with the text query at a second time after the first time, generating text based on the visual input, generating a composite query based on a combination of the text query and the text based on the visual input, and generating a search result based on the composite query, the search result including a plurality of links to content.
In another general aspect, an apparatus, a system, a non-transitory computer-readable medium (having computer-executable program code stored thereon that is executable on a computer system), and/or a method may perform a process by a method comprising: the method includes receiving a text query, receiving visual input associated with the query, generating search results based on the text query, generating text metadata based on the visual input, filtering the search results using the text metadata, and generating filtered search results based on the filtering, the filtered search results providing a plurality of links to content.
In yet another general aspect, an apparatus, a system, a non-transitory computer-readable medium (having computer-executable program code stored thereon that is executable on a computer system), and/or a method may perform a process by a method comprising: the method includes receiving content, receiving visual input associated with the content, performing object identification on the visual input, generating semantic information based on the object identification, and storing the content and the semantic information associated with the content.
Implementations may include one or more of the following features. For example, the composite query may be a first composite query. The creation of the first composite query may include performing object identification on the visual input and performing semantic query addition on the query using at least objects identified based on the object identification to generate the first composite query, wherein the search results are based on the first composite query. The performing of object identification may use a trained machine learning model. The performing of object identification may use a trained machine learning model, the trained machine learning model may generate a classifier for the object in the visual input, and the performing of semantic query addition may include generating text based on the visual input based on the classifier for the object.
The method may further include determining whether a first confidence level in the identification of the object satisfies a first condition, and performing semantic query addition on the query using at least the identified object satisfying the first condition to generate a second composite query, the search results may be based on the second composite query. The method may further include determining whether a second confidence level in the identification of the object satisfies a second condition, and performing semantic query addition on the query using at least the identified object satisfying the second condition to generate a third composite query, wherein the search results are based on the third composite query. The second confidence level may be higher than the first confidence level. The first condition and the second condition may be configurable by a user.
While example embodiments may include various modifications and alternative forms, embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that there is no intent to limit example embodiments to the particular forms disclosed, but on the contrary, example embodiments are to cover all modifications, equivalents, and alternatives falling within the scope of the claims. Like reference numerals refer to like elements throughout the description of the figures.
Various implementations of the systems and techniques described here can be realized in digital electronic circuitry, integrated circuitry, specially designed ASICs (application specific integrated circuits), computer hardware, firmware, software, and/or combinations thereof. These various implementations can include implementation in one or more computer programs that are executable and/or interpretable on a programmable system including at least one programmable processor, which may be special or general purpose, coupled to receive data and instructions from, and to transmit data and instructions to, a storage system, at least one input device, and at least one output device. Various implementations of the systems and techniques described here can be realized as and/or generally referred to herein as circuits, modules, blocks, or systems that can combine software and hardware aspects. For example, a module may comprise functions/acts/computer program instructions that are executed on a processor (e.g., a processor formed on a silicon substrate, a GaAs substrate, etc.) or some other programmable data processing apparatus.
Some of the above example embodiments are described as processes or methods depicted as flowcharts. Although a flowchart may describe the operations as a sequential process, many of the operations can be performed in parallel or concurrently. In addition, the order of the operations may be rearranged. These processes may terminate when their operations are complete, but may also have additional steps not included in the figure. The process may correspond to a method, a function, a procedure, a subroutine, a subprogram, etc.
Some of the above-discussed methods illustrated by flow charts may be implemented by hardware, software, firmware middleware, microcode, hardware description languages, or any combination thereof. When implemented in software, firmware, middleware or microcode, the program code or code segments to perform the necessary tasks may be stored in a machine or computer readable medium such as a storage medium. The processor may perform the necessary tasks.
Specific structural and functional details disclosed herein are merely representative for purposes of describing example embodiments. Example embodiments, however, are embodied in many alternate forms and should not be construed as limited to only the embodiments set forth herein.
It will be understood that, although the terms first, second, etc. may be used herein to describe various elements, these elements should not be limited by these terms. These terms are only used to distinguish one element from another. For example, a first element could be termed a second element, and, similarly, a second element could be termed a first element, without departing from the scope of example embodiments. As used herein, the term and/or includes any and all combinations of one or more of the associated listed items.
It will be understood that when an element is referred to as being connected or coupled to another element, it can be directly connected or coupled to the other element or intervening elements may be present. In contrast, when an element is referred to as being directly connected or directly coupled to another element, there are no intervening elements present. Other words used to describe the relationship between elements should be interpreted in a similar manner (e.g., between and directly between each other, adjacent and directly adjacent, etc.).
The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of example embodiments. As used herein, the singular forms "a", "an" and "the" are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms "comprises" and/or "comprising," when used herein, specify the presence of stated features, integers, steps, operations, elements, and/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components, and/or groups thereof.
It should also be noted that, in some alternative implementations, the functions/acts noted may occur out of the order noted in the figures. For example, two figures shown in succession may in fact be executed substantially concurrently or may sometimes be executed in the reverse order, depending upon the functionality/acts involved.
Unless otherwise defined, all terms (including technical and scientific terms) used herein have the same meaning as commonly understood by one of ordinary skill in the art to which example embodiments belong. It will be further understood that terms, such as those defined in commonly used dictionaries, should be interpreted as having a meaning that is consistent with their meaning in the context of the relevant art and will not be interpreted in an idealized or overly formal sense unless expressly so defined herein.
Portions of the above example embodiments and corresponding detailed description are presented in terms of software, algorithms and symbolic representations of operations on data bits within a computer memory. These descriptions and representations are the ones by which those of ordinary skill in the art effectively convey the substance of their work to others of ordinary skill in the art. An algorithm, as the term is used here, and as it is used generally, is conceived to be a self-consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of optical, electrical, or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.
In the illustrative embodiments above, reference has been made to acts and symbolic representations of operations (e.g., in the form of flowcharts) that may be implemented as program modules or functional processes, including routines, programs, objects, components, data structures, etc., that perform particular tasks or implement particular abstract data types, and that may be described and/or implemented using existing hardware as existing structural elements. Such existing hardware may include one or more Central Processing Units (CPUs), Digital Signal Processors (DSPs), application specific integrated circuits, Field Programmable Gate Arrays (FPGAs) computers, and the like.
It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise, or as is apparent from the discussion, terms such as processing, computing, or determining or the like, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical, electronic quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.
It should also be noted that the software implemented aspects of the example embodiments are typically encoded on some form of non-transitory program storage medium or implemented over some type of transmission medium. The program storage medium may be magnetic (e.g., a floppy disk or a hard drive) or optical (e.g., a compact disk read only memory or a CD ROM), and may be read only or random access. Similarly, the transmission medium may be twisted wire pairs, coaxial cable, optical fiber, or some other suitable transmission medium known to the art. The example embodiments are not limited by these aspects of any given implementation.
Finally, it should also be noted that although the appended claims set forth particular combinations of features described herein, the scope of the present disclosure is not limited to the particular combinations claimed below, but extends to cover any combination of features or embodiments disclosed herein, whether or not that particular combination is specifically recited in the claims at that time.
Claims (20)
1. A method, comprising:
receiving, by a computing device, a text query at a first time;
receiving, by the computing device, a visual input associated with the text query at a second time after the first time;
generating text based on the visual input;
generating, by the computing device, a composite query based on a combination of the text query and the text based on the visual input; and
generating, by the computing device, search results based on the composite query, the search results including a plurality of links to content.
2. The method of claim 1, wherein the composite query is a first composite query, and wherein the creation of the first composite query comprises:
performing object identification on the visual input; and
performing semantic query addition on the query using at least the object identified based on the object identification to generate the first composite query, wherein the search results are based on the first composite query.
3. The method of claim 2, wherein the performing of the object identification uses a trained machine learning model.
4. The method of claim 2, wherein
The object identification is performed using a trained machine learning model,
the trained machine learning model generates classifiers for objects in the visual input, and
the performing of the semantic query addition includes generating the text based on the visual input based on the classifier of the object.
5. The method of claim 2, further comprising:
determining whether a first confidence level in the object identification satisfies a first condition; and
performing the semantic query addition on the query using at least the identified object that satisfies the first condition to generate a second composite query, wherein the search results are based on the second composite query.
6. The method of any of claims 2 to 5, further comprising:
determining whether a second confidence level in the object identification satisfies a second condition; and
performing the semantic query addition on the query using at least the identified objects that satisfy the second condition to generate a third composite query, wherein the search results are based on the third composite query.
7. The method of claim 6, wherein the second confidence level is higher than the first confidence level.
8. The method of claim 6, wherein the first and second conditions are configured by a user.
9. A method, comprising:
receiving, by a computing device, a text query;
receiving, by the computing device, a visual input associated with the query;
generating, by the computing device, search results based on the text query;
generating, by the computing device, text metadata based on the visual input;
filtering, by the computing device, the search results using the text metadata; and
generating, by the computing device, filtered search results based on the filtering, the filtered search results providing a plurality of links to content.
10. The method of claim 9, wherein the textual metadata is generated based on analyzing the visual input for semantic and visual entity information.
11. The method of claim 10, wherein the analysis of the visual input uses a multi-pass method.
12. The method of claim 10, wherein the analysis of the visual input uses a trained machine learning model.
13. The method of claim 10, wherein
The analysis of the visual input uses a trained machine learning model,
the trained machine learning model generates classifiers for objects in the visual input, and
the filtering of the search results includes generating the textual metadata based on the classifier of the object.
14. The method of any of claims 9 to 13, wherein the search results of the query are filtered based on matching the textual metadata with textual metadata of videos of a video visual metadata repository.
15. The method of any of claims 10-14, wherein analyzing the visual input for semantic and visual entity information comprises:
performing object identification on the visual input;
determining whether a first confidence level in the object identification satisfies a first condition, wherein
The filtering of the search results includes generating a second composite query using at least the identified objects that satisfy the first condition, and
the search results are based on the second composite query.
16. The method of claim 15, further comprising determining whether a second confidence level in the object identification satisfies a second condition, wherein
The filtering of the search results includes generating a third composite query using at least the identified objects that satisfy the second condition, and
the search results are based on the third composite query.
17. The method of claim 16, wherein the second confidence level is higher than the first confidence level.
18. A method, comprising:
receiving, by a computing device, content;
receiving, by the computing device, a visual input associated with the content;
performing, by the computing device, object identification on the visual input;
generating, by the computing device, semantic information based on the object identification; and
storing, by the computing device, the content and the semantic information associated with the content.
19. The method of claim 18, wherein the object identification uses a trained machine learning model.
20. The method of claim 18 or 19, wherein
The object identification is performed using a trained machine learning model,
the trained machine learning model generates classifiers for objects in the visual input, and
the generating of the semantic information includes generating text based on the classifier of the object.
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201962895278P | 2019-09-03 | 2019-09-03 | |
US62/895,278 | 2019-09-03 | ||
PCT/US2020/070492 WO2021046574A1 (en) | 2019-09-03 | 2020-09-03 | Camera input as an automated filter mechanism for video search |
Publications (1)
Publication Number | Publication Date |
---|---|
CN114080602A true CN114080602A (en) | 2022-02-22 |
Family
ID=72560945
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN202080044843.5A Pending CN114080602A (en) | 2019-09-03 | 2020-09-03 | Camera input as an automatic filter mechanism for video search |
Country Status (4)
Country | Link |
---|---|
US (1) | US20210064652A1 (en) |
EP (1) | EP3963477A1 (en) |
CN (1) | CN114080602A (en) |
WO (1) | WO2021046574A1 (en) |
Families Citing this family (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20220300550A1 (en) * | 2021-03-19 | 2022-09-22 | Google Llc | Visual Search via Free-Form Visual Feature Selection |
Family Cites Families (14)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20070255755A1 (en) * | 2006-05-01 | 2007-11-01 | Yahoo! Inc. | Video search engine using joint categorization of video clips and queries based on multiple modalities |
US20110208822A1 (en) * | 2010-02-22 | 2011-08-25 | Yogesh Chunilal Rathod | Method and system for customized, contextual, dynamic and unified communication, zero click advertisement and prospective customers search engine |
US20150088923A1 (en) * | 2013-09-23 | 2015-03-26 | Google Inc. | Using sensor inputs from a computing device to determine search query |
US9990433B2 (en) * | 2014-05-23 | 2018-06-05 | Samsung Electronics Co., Ltd. | Method for searching and device thereof |
US11288595B2 (en) * | 2017-02-14 | 2022-03-29 | Groq, Inc. | Minimizing memory and processor consumption in creating machine learning models |
US10453165B1 (en) * | 2017-02-27 | 2019-10-22 | Amazon Technologies, Inc. | Computer vision machine learning model execution service |
WO2018174849A1 (en) * | 2017-03-20 | 2018-09-27 | Google Llc | Contextually disambiguating queries |
US20190027147A1 (en) * | 2017-07-18 | 2019-01-24 | Microsoft Technology Licensing, Llc | Automatic integration of image capture and recognition in a voice-based query to understand intent |
US10970334B2 (en) * | 2017-07-24 | 2021-04-06 | International Business Machines Corporation | Navigating video scenes using cognitive insights |
AU2018324087A1 (en) * | 2017-08-31 | 2020-01-23 | Eagle View Technologies, Inc. | Systems and methods for automatic estimation of object characteristics from digital images |
US10474926B1 (en) * | 2017-11-16 | 2019-11-12 | Amazon Technologies, Inc. | Generating artificial intelligence image processing services |
US20190188811A1 (en) * | 2018-02-17 | 2019-06-20 | Constru Ltd | System and method for generating financial assessments based on construction site images |
US10496936B2 (en) * | 2018-03-05 | 2019-12-03 | Capital One Services, Llc | Systems and methods for preventing machine learning models from negatively affecting mobile devices through intermittent throttling |
US20190340567A1 (en) * | 2018-05-04 | 2019-11-07 | Microsoft Technology Licensing, Llc | Computer-implemented method and system for tracking inventory |
-
2020
- 2020-09-03 EP EP20775149.6A patent/EP3963477A1/en active Pending
- 2020-09-03 WO PCT/US2020/070492 patent/WO2021046574A1/en unknown
- 2020-09-03 CN CN202080044843.5A patent/CN114080602A/en active Pending
- 2020-09-03 US US16/948,119 patent/US20210064652A1/en not_active Abandoned
Also Published As
Publication number | Publication date |
---|---|
WO2021046574A1 (en) | 2021-03-11 |
US20210064652A1 (en) | 2021-03-04 |
EP3963477A1 (en) | 2022-03-09 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
AU2018201624B2 (en) | Relevance-based image selection | |
US8165406B2 (en) | Interactive concept learning in image search | |
US20190108242A1 (en) | Search method and processing device | |
US10635949B2 (en) | Latent embeddings for word images and their semantics | |
US11782928B2 (en) | Computerized information extraction from tables | |
US20070288453A1 (en) | System and Method for Searching Multimedia using Exemplar Images | |
Li et al. | Bootstrapping visual categorization with relevant negatives | |
AU2015259118A1 (en) | Natural language image search | |
CN101460947A (en) | Content based image retrieval | |
CN113661487A (en) | Encoder for generating dense embedded vectors using machine-trained entry frequency weighting factors | |
US20210103611A1 (en) | Context-based organization of digital media | |
FR2964212A1 (en) | EXTRACTION SYSTEMS AND METHODS USING PROBABILISTIC INFORMATION RETURN OF TRANSMEDIA RELEVANCE | |
Ayache et al. | Evaluation of active learning strategies for video indexing | |
US20160103915A1 (en) | Linking thumbnail of image to web page | |
US11854285B2 (en) | Neural network architecture for extracting information from documents | |
Jishan et al. | Hybrid deep neural network for bangla automated image descriptor | |
US20210064652A1 (en) | Camera input as an automated filter mechanism for video search | |
US11403339B2 (en) | Techniques for identifying color profiles for textual queries | |
CN115661846A (en) | Data processing method and device, electronic equipment and storage medium | |
Mao et al. | Visual arts search on mobile devices | |
Lin et al. | Image auto-annotation via tag-dependent random search over range-constrained visual neighbours | |
US11967128B2 (en) | Decompositional learning for color attribute prediction | |
WO2022031283A1 (en) | Video stream content | |
Reddy et al. | Automatic caption generation for annotated images by using clustering algorithm | |
Kabir et al. | Content-Based Image Retrieval Using AutoEmbedder |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
SE01 | Entry into force of request for substantive examination |