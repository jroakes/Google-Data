US20140108589A1 - Testing an executable binary file using an injection proxy - Google Patents
Testing an executable binary file using an injection proxy Download PDFInfo
- Publication number
- US20140108589A1 US20140108589A1 US13/649,295 US201213649295A US2014108589A1 US 20140108589 A1 US20140108589 A1 US 20140108589A1 US 201213649295 A US201213649295 A US 201213649295A US 2014108589 A1 US2014108589 A1 US 2014108589A1
- Authority
- US
- United States
- Prior art keywords
- response
- advertisement
- fields
- request
- data processing
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Abandoned
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/36—Preventing errors by testing or debugging software
- G06F11/3668—Software testing
- G06F11/3696—Methods or tools to render software testable
Definitions
- This specification relates to testing executable binary files.
- Binary files (“binaries”) are machine-executable files that have been compiled from source code written by a developer. Developers can test their binaries by running the binaries through test scenarios.
- a mock object is used to simulate a real object that, during actual, live run time, would be accessed by a binary.
- a mock object is a simulated object that mimics the behavior of the real object.
- a mock object the creation of which generally involves substantial effort, typically is specific to particulars of the binary in its current state. If the binary is subsequently modified, the mock object also ideally should be modified to test the modified binary. And if the binary under test is being changed rapidly, the mock object also may have to be updated rapidly to ensure that the simulation is up-to-date and not stale.
- This specification describes technologies relating to testing an executable binary file using an injection proxy to simulate real world situations.
- the injection proxy sits between the binary under test and a real object, such as a live backend system.
- the injection proxy modifies a response from the backend system by altering a specified set of fields. The other fields of the response remain unchanged and are thus based on the current status of the live backend system.
- the injection proxy returns the modified response to the binary under test.
- Methods for testing a binary may include receiving a request from a binary under test, transmitting the request to a live backend system, receiving a response to the transmitted request from the live backend system where the response includes a plurality of fields, modifying the received response by selectively altering a specified subset of the plurality of fields in the received response according to predetermined testing requirements and leaving the remaining fields in the received response unaltered, and transmitting the modified response to the binary under test.
- Other potential implementations include corresponding system, apparatus, and/or computer programs configured to perform the actions of the methods, encoded on computer storage devices.
- the method may further include generating a hash value based on the request and storing the modified response based on the hash value.
- the method may further include receiving a second request from the binary under test, generating a hash value based on the second request, determining that the hash value is associated with a stored response, and transmitting the stored response to the binary under test.
- the request may be a request for an advertisement.
- the response may be an advertisement.
- the binary under test may be a binary that renders the advertisement.
- the live backend system may be an advertisement server.
- the advertisement may include visible fields. Modifying the response may include modifying the visible fields of the advertisement.
- the visible fields of the advertisement may include one or more of a title of the advertisement, text in the advertisement, or a hyperlink in the advertisement.
- the method may further include receiving input identifying the specified subset of fields in the received response to be altered.
- the method may further include receiving input that controls how the specified subset of fields is to be altered.
- an injection proxy may be used instead of a mock object. Testing a binary using the injection proxy, as opposed to the mock object, helps to ensure that, for the unchanged fields, the response received by the binary reflects up-to-date responses from real objects accessed via the live backend. At the same time, the injection proxy can control the specified set of fields and set the returned responses to any values that make sense for the current binary being tested.
- the injection proxy is programmable via an application programming interface (API) that enables the testing team to change which of the fields in the injection proxy are passed through from the live backend unchanged and which specified set of fields are to be altered to perform the desired testing.
- API application programming interface
- FIG. 1 is a block diagram of an example system for testing a binary using an injection proxy.
- FIG. 2 is a block diagram of example units in an injection proxy for processing requests from a binary and responses from a live backend system.
- FIG. 3 is a flowchart of an example process for testing a binary using an injection proxy.
- FIG. 4 is a block diagram of a programmable processing system.
- FIG. 1 is a block diagram of an example system 100 for testing a binary 102 using an injection proxy 104 .
- the binary 102 may be a machine-executable file compiled from source code written by a developer.
- the binary 102 may include instructions that are executed by a processing device of a computer system to render content, such as a file, a web page, or an advertisement, for display on a display screen of the computer system.
- the live backend system 106 provides resources to the binary 102 .
- Examples of a live backend system 106 include a web server, an advertisement server, or a search engine.
- resources include a file, a web page, or an advertisement.
- a web server may provide web pages to the binary 102 .
- An advertisement server may provide advertisements to the binary 102 .
- a search engine may provide a search results in a search results page to the binary 102 .
- the injection proxy 104 sits between the binary 102 and the live backend system 106 .
- the injection proxy 104 acts as an intermediary between the binary 102 and the live backend system 106 .
- the binary 102 connects to the injection proxy 104 when requesting a resource from the live backend system 106 .
- the injection proxy 104 provides the resource to the binary 102 by connecting to the backend system 106 and requesting the resource from the backend system 106 on behalf of the binary 102 .
- the injection proxy 104 modifies the response by altering a specified set of fields of the resource, e.g., visible fields of an advertisement, that is desired for testing of the binary 102 .
- the injection proxy 104 returns the modified response to the binary 102 .
- the injection proxy 104 may store the response received from the backend system 106 or the modified response in a cache. If the injection proxy 104 subsequently receives a request for the same resource from the binary 102 , the injection proxy 104 may return a response to the binary 102 from the cache without requesting the resource from the backend system 106 .
- the injection proxy is programmable via an application programming interface (API) that enables a user to change which of the fields in a response are passed through from the live backend unchanged and which specified set of fields are to be altered to perform the desired testing.
- API application programming interface
- the injection proxy 104 may be an application running on the same computer system as the binary 102 .
- the injection proxy 104 may be implemented on a computer system or a server separate from the computer system that is executing the binary 102 .
- the binary 102 , the injection proxy 104 , and the live backend system 106 may be connected through a network (not shown), such as a local area network (LAN), wide area network (WAN), the Internet, or a combination thereof.
- LAN local area network
- WAN wide area network
- the Internet or a combination thereof.
- FIG. 2 is a block diagram of example components in the injection proxy 104 for processing requests from the binary 102 and responses from the backend system 106 .
- the components in the injection proxy 104 may include a key generator 202 , a cache 204 , a request forwarding unit 206 , and a response modifier 208 .
- the key generator 202 receives a request from the binary 102 and generates a key based on the request.
- the key generator 202 may be, for example, a hash function that generates a hash value based on the request.
- the hash function may map the request to an index corresponding to an entry of the cache 204 where a response to the request is or will be stored.
- the key is used to determine whether a response to the request is stored in the cache 204 and in which entry of the cache 204 to store a response received from the backend system 106 .
- the cache 204 returns the stored response.
- the cache 204 returns the response stored in the cache entry that corresponds to the key generated by the key generator 202 based on the request.
- the response returned by the cache 204 may be a response as originally received from the backend system 106 , a modified version of the response received from the backend system 106 , or both the original response and the modified response.
- the returned response may be modified by the response modifier 208 prior to transmitting the response to the binary 102 .
- the injection proxy 104 forwards the request from the binary 102 to the backend system 106 .
- the cache 204 may transmit a signal, such as a cache miss signal, to the request forwarding unit 206 indicating that the response is not stored in the cache.
- the request forwarding unit 206 forwards the request from the binary 102 to the backend system 106 .
- the cache 204 stores the response after the response is received from the backend system 106 .
- the cache 204 may store a response as originally received from the backend system 106 , a modified version of the response received from the backend system 106 , or both the original response and the modified response.
- the cache 204 stores the response in a cache entry that corresponds to the key generated by the key generator 202 based on the request associated with the response.
- the response modifier 208 may modify the response prior to storing the response in the cache 204 or transmitting the response to the binary 102 .
- the response modifier 208 may modify the response by altering a specified subset of fields of the resource included in the response that is desired for testing of the binary 102 .
- the response modifier 208 may modify the specified subset of fields in the resource based on input received from a user identifying the specified subset of fields that is to be altered.
- the response modifier 208 may modify the specified subset of fields in the resource based on input received from a user that controls how the specified subset of fields is to be altered.
- the injection proxy 104 receives a response from a backend system 106 , such as an advertisement server, that includes a resource, such as an advertisement.
- a backend system 106 such as an advertisement server
- the advertisement includes visible fields, such as a title text field, a body text field, or a hyperlink text field, that are displayed to a user.
- the advertisement also includes invisible fields, such as formatting fields and font fields, that are not displayed to a user.
- the response modifier 208 may be configured by a user to modify one or more of the visible fields of the advertisement while leaving the remaining fields, including the invisible fields, of the advertisement unaltered.
- a user may want to test whether the binary 102 correctly renders Unicode characters in the visible fields of an advertisement.
- the user can configure the response modifier 208 to insert a Unicode character in one or more of the visible fields of the advertisement returned by the backend system 106 .
- a user may want to test whether the binary 102 correctly renders an advertisement that includes the maximum number of characters allowed in the body of the advertisement.
- the user can configure the response modifier 208 to modify the body of the advertisement returned by the backend system 106 to include the maximum number of characters allowed.
- FIG. 3 is a flowchart of an example process 300 for testing a binary using an injection proxy. Briefly, the process 300 includes receiving a request from a binary under test, generating a key based on the request, and transmitting a response to the binary based on whether the key is associated with a stored response.
- the process 300 begins with the injection proxy receiving a request from a binary under test ( 302 ).
- the request may be a data structure that is transmitted from the binary to the injection proxy using a remote procedure call (RPC).
- RPC remote procedure call
- the request may be a request for a resource, such as an advertisement, from a live backend system, such as an advertisement server.
- the injection proxy generates a key based on the request ( 304 ).
- the injection proxy may include a hash function that generates the key, such as a hash value, based on the request.
- the injection proxy determines whether the key is associated with a response stored in the injection proxy ( 306 ).
- the injection proxy may access a cache and determine whether a cache entry corresponding to the key is storing a valid response to the request.
- the injection proxy transmits the stored response to the binary ( 308 ).
- the injection proxy may transmit the stored response without modification or modify the stored response before transmitting the modified response to the binary.
- the injection proxy transmits the request to the live backend system ( 310 ).
- the injection proxy modifies the response ( 314 ).
- the received response may be a data structure that includes multiple fields.
- the injection proxy may modify the received response by selectively altering a specified subset of fields in the received response, such as the visible fields of an advertisement included in the received response, according to predetermined testing requirements. The remaining fields, such as the invisible fields of the advertisement, in the received response remain unchanged and are thus based on the current status of the live backend system.
- the injection proxy stores the received response or the modified response ( 316 ).
- the injection proxy may store the received response or the modified response in a cache entry corresponding to the key generated based on the request.
- the injection proxy may simultaneously or subsequently transmit the modified response to the binary ( 318 ).
- Implementations of the subject matter and the operations described in this specification can be configured in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them.
- Implementations of the subject matter described in this specification can be configured as one or more computer programs, i.e., one or more modules of computer program instructions, encoded on computer storage medium for execution by, or to control the operation of, data processing apparatus.
- the program instructions can be encoded on an artificially-generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus.
- a computer storage medium can be, or be included in, a computer-readable storage device, a computer-readable storage substrate, a random or serial access memory array or device, or a combination of one or more of them.
- a computer storage medium is not a propagated signal, a computer storage medium can be a source or destination of computer program instructions encoded in an artificially-generated propagated signal.
- the computer storage medium can also be, or be included in, one or more separate physical components or media (e.g., multiple CDs, disks, or other storage devices).
- the operations described in this specification can be implemented as operations performed by a data processing apparatus on data stored on one or more computer-readable storage devices or received from other sources.
- the term “data processing apparatus” encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, a system on a chip, or multiple ones, or combinations, of the foregoing
- the apparatus can include special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
- the apparatus can also include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, a cross-platform runtime environment, a virtual machine, or a combination of one or more of them.
- the apparatus and execution environment can realize various different computing model infrastructures, such as web services, distributed computing and grid computing infrastructures.
- a computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, object, or other unit suitable for use in a computing environment.
- a computer program may, but need not, correspond to a file in a file system.
- a program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub-programs, or portions of code).
- a computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
- processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer.
- a processor will receive instructions and data from a read-only memory or a random access memory or both.
- the essential elements of a computer are a processor for performing actions in accordance with instructions and one or more memory devices for storing instructions and data.
- a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks.
- mass storage devices for storing data
- a computer need not have such devices.
- a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., a universal serial bus (USB) flash drive), to name just a few.
- PDA personal digital assistant
- GPS Global Positioning System
- USB universal serial bus
- Devices suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks.
- semiconductor memory devices e.g., EPROM, EEPROM, and flash memory devices
- magnetic disks e.g., internal hard disks or removable disks
- magneto-optical disks e.g., CD-ROM and DVD-ROM disks.
- the processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
- implementations of the subject matter described in this specification can be configured on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer.
- a display device e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor
- a keyboard and a pointing device e.g., a mouse or a trackball
- Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.
- a computer can interact with a user by sending documents to and receiving documents from a device that
- Implementations of the subject matter described in this specification can be configured in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back-end, middleware, or front-end components.
- the components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network.
- Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), an inter-network (e.g., the Internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks).
- LAN local area network
- WAN wide area network
- inter-network e.g., the Internet
- peer-to-peer networks e.g., ad hoc peer-to-peer networks.
- the computing system can include clients and servers.
- a client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
- a server transmits data (e.g., an HTML page) to a client device (e.g., for purposes of displaying data to and receiving user input from a user interacting with the client device).
- client device e.g., for purposes of displaying data to and receiving user input from a user interacting with the client device.
- Data generated at the client device e.g., a result of the user interaction
- FIG. 4 shows a block diagram of a programmable processing system (system).
- system 400 that can be utilized to implement the systems and methods described herein.
- the architecture of the system 400 can, for example, be used to implement a computer client, a computer server, or some other computer device.
- the system 400 includes a processor 410 , a memory 420 , a storage device 430 , and an input/output device 440 .
- Each of the components 410 , 420 , 430 , and 440 can, for example, be interconnected using a system bus 450 .
- the processor 410 is capable of processing instructions for execution within the system 400 .
- the processor 410 is a single-threaded processor.
- the processor 410 is a multi-threaded processor.
- the processor 410 is capable of processing instructions stored in the memory 420 or on the storage device 430 .
- the memory 420 stores information within the system 400 .
- the memory 420 is a computer-readable medium.
- the memory 420 is a volatile memory unit.
- the memory 420 is a non-volatile memory unit.
- the storage device 430 is capable of providing mass storage for the system 400 .
- the storage device 430 is a computer-readable medium.
- the storage device 430 can, for example, include a hard disk device, an optical disk device, or some other large capacity storage device.
- the input/output device 440 provides input/output operations for the system 400 .
- the input/output device 440 can include one or more of a network interface device, e.g., an Ethernet card, a serial communication device, e.g., and RS-232 port, and/or a wireless interface device, e.g., an 802.11 card.
- the input/output device can include driver devices configured to receive input data and send output data to other input/output devices, e.g., keyboard, printer and display devices 460 .
Abstract
Methods, systems, and apparatus for testing a binary are described. A method includes receiving a request from a binary under test, transmitting the request to a live backend system, receiving a response to the transmitted request from the live backend system where the received response including a plurality of fields, modifying the received response by selectively altering a specified subset of the plurality of fields in the received response according to predetermined testing requirements and leaving the remaining fields in the received response unaltered, and transmitting the modified response to the binary under test.
Description
- This specification relates to testing executable binary files.
- Binary files (“binaries”) are machine-executable files that have been compiled from source code written by a developer. Developers can test their binaries by running the binaries through test scenarios. Typically, a mock object is used to simulate a real object that, during actual, live run time, would be accessed by a binary. A mock object is a simulated object that mimics the behavior of the real object. But a mock object, the creation of which generally involves substantial effort, typically is specific to particulars of the binary in its current state. If the binary is subsequently modified, the mock object also ideally should be modified to test the modified binary. And if the binary under test is being changed rapidly, the mock object also may have to be updated rapidly to ensure that the simulation is up-to-date and not stale.
- This specification describes technologies relating to testing an executable binary file using an injection proxy to simulate real world situations. The injection proxy sits between the binary under test and a real object, such as a live backend system. The injection proxy modifies a response from the backend system by altering a specified set of fields. The other fields of the response remain unchanged and are thus based on the current status of the live backend system. The injection proxy returns the modified response to the binary under test.
- In general, an innovative aspect of the subject matter described in this specification can be implemented in methods for testing a binary using an injection proxy. Methods for testing a binary may include receiving a request from a binary under test, transmitting the request to a live backend system, receiving a response to the transmitted request from the live backend system where the response includes a plurality of fields, modifying the received response by selectively altering a specified subset of the plurality of fields in the received response according to predetermined testing requirements and leaving the remaining fields in the received response unaltered, and transmitting the modified response to the binary under test. Other potential implementations include corresponding system, apparatus, and/or computer programs configured to perform the actions of the methods, encoded on computer storage devices.
- These and other implementations can optionally include one or more of the following features. The method may further include generating a hash value based on the request and storing the modified response based on the hash value. The method may further include receiving a second request from the binary under test, generating a hash value based on the second request, determining that the hash value is associated with a stored response, and transmitting the stored response to the binary under test. The request may be a request for an advertisement. The response may be an advertisement. The binary under test may be a binary that renders the advertisement. The live backend system may be an advertisement server. The advertisement may include visible fields. Modifying the response may include modifying the visible fields of the advertisement. The visible fields of the advertisement may include one or more of a title of the advertisement, text in the advertisement, or a hyperlink in the advertisement. The method may further include receiving input identifying the specified subset of fields in the received response to be altered. The method may further include receiving input that controls how the specified subset of fields is to be altered.
- Particular implementations of the subject matter described in this specification may be implemented to realize one or more of the following potential advantages. To simulate real world situations, an injection proxy may be used instead of a mock object. Testing a binary using the injection proxy, as opposed to the mock object, helps to ensure that, for the unchanged fields, the response received by the binary reflects up-to-date responses from real objects accessed via the live backend. At the same time, the injection proxy can control the specified set of fields and set the returned responses to any values that make sense for the current binary being tested. The injection proxy is programmable via an application programming interface (API) that enables the testing team to change which of the fields in the injection proxy are passed through from the live backend unchanged and which specified set of fields are to be altered to perform the desired testing.
- Details of one or more implementations of the subject matter described in this specification are set forth in the accompanying drawings and description below. Other features, aspects, and potential advantages of the subject matter will become apparent from the description, the drawings, and the claims.
-
FIG. 1 is a block diagram of an example system for testing a binary using an injection proxy. -
FIG. 2 is a block diagram of example units in an injection proxy for processing requests from a binary and responses from a live backend system. -
FIG. 3 is a flowchart of an example process for testing a binary using an injection proxy. -
FIG. 4 is a block diagram of a programmable processing system. -
FIG. 1 is a block diagram of anexample system 100 for testing a binary 102 using aninjection proxy 104. Thebinary 102 may be a machine-executable file compiled from source code written by a developer. For example, thebinary 102 may include instructions that are executed by a processing device of a computer system to render content, such as a file, a web page, or an advertisement, for display on a display screen of the computer system. - The
live backend system 106 provides resources to the binary 102. Examples of alive backend system 106 include a web server, an advertisement server, or a search engine. Examples of resources include a file, a web page, or an advertisement. For example, a web server may provide web pages to thebinary 102. An advertisement server may provide advertisements to thebinary 102. A search engine may provide a search results in a search results page to thebinary 102. - The
injection proxy 104 sits between the binary 102 and thelive backend system 106. Theinjection proxy 104 acts as an intermediary between the binary 102 and thelive backend system 106. Thebinary 102 connects to theinjection proxy 104 when requesting a resource from thelive backend system 106. Theinjection proxy 104 provides the resource to the binary 102 by connecting to thebackend system 106 and requesting the resource from thebackend system 106 on behalf of thebinary 102. When theinjection proxy 104 receives a response from thebackend system 106, theinjection proxy 104 modifies the response by altering a specified set of fields of the resource, e.g., visible fields of an advertisement, that is desired for testing of thebinary 102. Theinjection proxy 104 returns the modified response to thebinary 102. Theinjection proxy 104 may store the response received from thebackend system 106 or the modified response in a cache. If theinjection proxy 104 subsequently receives a request for the same resource from thebinary 102, theinjection proxy 104 may return a response to thebinary 102 from the cache without requesting the resource from thebackend system 106. - The injection proxy is programmable via an application programming interface (API) that enables a user to change which of the fields in a response are passed through from the live backend unchanged and which specified set of fields are to be altered to perform the desired testing. In some implementations, the
injection proxy 104 may be an application running on the same computer system as thebinary 102. In some implementations, theinjection proxy 104 may be implemented on a computer system or a server separate from the computer system that is executing thebinary 102. In some implementations, thebinary 102, theinjection proxy 104, and thelive backend system 106 may be connected through a network (not shown), such as a local area network (LAN), wide area network (WAN), the Internet, or a combination thereof. -
FIG. 2 is a block diagram of example components in theinjection proxy 104 for processing requests from the binary 102 and responses from thebackend system 106. The components in theinjection proxy 104 may include akey generator 202, acache 204, arequest forwarding unit 206, and aresponse modifier 208. - The
key generator 202 receives a request from the binary 102 and generates a key based on the request. Thekey generator 202 may be, for example, a hash function that generates a hash value based on the request. The hash function may map the request to an index corresponding to an entry of thecache 204 where a response to the request is or will be stored. The key is used to determine whether a response to the request is stored in thecache 204 and in which entry of thecache 204 to store a response received from thebackend system 106. - If a response corresponding to the request is stored in the
cache 204, thecache 204 returns the stored response. Thecache 204 returns the response stored in the cache entry that corresponds to the key generated by thekey generator 202 based on the request. The response returned by thecache 204 may be a response as originally received from thebackend system 106, a modified version of the response received from thebackend system 106, or both the original response and the modified response. The returned response may be modified by theresponse modifier 208 prior to transmitting the response to the binary 102. - If a response corresponding to the request is not stored in the
cache 204, theinjection proxy 104 forwards the request from the binary 102 to thebackend system 106. Thecache 204 may transmit a signal, such as a cache miss signal, to therequest forwarding unit 206 indicating that the response is not stored in the cache. In response to the signal from thecache 204, therequest forwarding unit 206 forwards the request from the binary 102 to thebackend system 106. - The
cache 204 stores the response after the response is received from thebackend system 106. Thecache 204 may store a response as originally received from thebackend system 106, a modified version of the response received from thebackend system 106, or both the original response and the modified response. Thecache 204 stores the response in a cache entry that corresponds to the key generated by thekey generator 202 based on the request associated with the response. - When a response is received from the
backend system 106, theresponse modifier 208 may modify the response prior to storing the response in thecache 204 or transmitting the response to the binary 102. For example, theresponse modifier 208 may modify the response by altering a specified subset of fields of the resource included in the response that is desired for testing of the binary 102. Theresponse modifier 208 may modify the specified subset of fields in the resource based on input received from a user identifying the specified subset of fields that is to be altered. Theresponse modifier 208 may modify the specified subset of fields in the resource based on input received from a user that controls how the specified subset of fields is to be altered. - For example, the
injection proxy 104 receives a response from abackend system 106, such as an advertisement server, that includes a resource, such as an advertisement. The advertisement includes visible fields, such as a title text field, a body text field, or a hyperlink text field, that are displayed to a user. The advertisement also includes invisible fields, such as formatting fields and font fields, that are not displayed to a user. Theresponse modifier 208 may be configured by a user to modify one or more of the visible fields of the advertisement while leaving the remaining fields, including the invisible fields, of the advertisement unaltered. - For example, a user may want to test whether the binary 102 correctly renders Unicode characters in the visible fields of an advertisement. The user can configure the
response modifier 208 to insert a Unicode character in one or more of the visible fields of the advertisement returned by thebackend system 106. As another example, a user may want to test whether the binary 102 correctly renders an advertisement that includes the maximum number of characters allowed in the body of the advertisement. The user can configure theresponse modifier 208 to modify the body of the advertisement returned by thebackend system 106 to include the maximum number of characters allowed. -
FIG. 3 is a flowchart of an example process 300 for testing a binary using an injection proxy. Briefly, the process 300 includes receiving a request from a binary under test, generating a key based on the request, and transmitting a response to the binary based on whether the key is associated with a stored response. - In further detail, the process 300 begins with the injection proxy receiving a request from a binary under test (302). The request may be a data structure that is transmitted from the binary to the injection proxy using a remote procedure call (RPC). The request may be a request for a resource, such as an advertisement, from a live backend system, such as an advertisement server.
- The injection proxy generates a key based on the request (304). The injection proxy may include a hash function that generates the key, such as a hash value, based on the request.
- The injection proxy determines whether the key is associated with a response stored in the injection proxy (306). The injection proxy may access a cache and determine whether a cache entry corresponding to the key is storing a valid response to the request.
- If the key is associated with a stored response, the injection proxy transmits the stored response to the binary (308). The injection proxy may transmit the stored response without modification or modify the stored response before transmitting the modified response to the binary.
- If the key is not associated with a stored response, the injection proxy transmits the request to the live backend system (310). When the injection proxy receives a response from the backend system (312), the injection proxy modifies the response (314). The received response may be a data structure that includes multiple fields. The injection proxy may modify the received response by selectively altering a specified subset of fields in the received response, such as the visible fields of an advertisement included in the received response, according to predetermined testing requirements. The remaining fields, such as the invisible fields of the advertisement, in the received response remain unchanged and are thus based on the current status of the live backend system.
- The injection proxy stores the received response or the modified response (316). The injection proxy may store the received response or the modified response in a cache entry corresponding to the key generated based on the request. The injection proxy may simultaneously or subsequently transmit the modified response to the binary (318).
- Implementations of the subject matter and the operations described in this specification can be configured in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Implementations of the subject matter described in this specification can be configured as one or more computer programs, i.e., one or more modules of computer program instructions, encoded on computer storage medium for execution by, or to control the operation of, data processing apparatus. Alternatively or in addition, the program instructions can be encoded on an artificially-generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. A computer storage medium can be, or be included in, a computer-readable storage device, a computer-readable storage substrate, a random or serial access memory array or device, or a combination of one or more of them. Moreover, while a computer storage medium is not a propagated signal, a computer storage medium can be a source or destination of computer program instructions encoded in an artificially-generated propagated signal. The computer storage medium can also be, or be included in, one or more separate physical components or media (e.g., multiple CDs, disks, or other storage devices).
- The operations described in this specification can be implemented as operations performed by a data processing apparatus on data stored on one or more computer-readable storage devices or received from other sources.
- The term “data processing apparatus” encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, a system on a chip, or multiple ones, or combinations, of the foregoing The apparatus can include special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit). The apparatus can also include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, a cross-platform runtime environment, a virtual machine, or a combination of one or more of them. The apparatus and execution environment can realize various different computing model infrastructures, such as web services, distributed computing and grid computing infrastructures.
- A computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, object, or other unit suitable for use in a computing environment. A computer program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub-programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
- The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform actions by operating on input data and generating output. Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for performing actions in accordance with instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., a universal serial bus (USB) flash drive), to name just a few. Devices suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
- To provide for interaction with a user, implementations of the subject matter described in this specification can be configured on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input. In addition, a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a web browser on a user's client device in response to requests received from the web browser.
- Implementations of the subject matter described in this specification can be configured in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back-end, middleware, or front-end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), an inter-network (e.g., the Internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks).
- The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other. In some implementations, a server transmits data (e.g., an HTML page) to a client device (e.g., for purposes of displaying data to and receiving user input from a user interacting with the client device). Data generated at the client device (e.g., a result of the user interaction) can be received from the client device at the server.
- An example of one such type of computer is shown in
FIG. 4 , which shows a block diagram of a programmable processing system (system). Thesystem 400 that can be utilized to implement the systems and methods described herein. The architecture of thesystem 400 can, for example, be used to implement a computer client, a computer server, or some other computer device. - The
system 400 includes aprocessor 410, amemory 420, astorage device 430, and an input/output device 440. Each of thecomponents system bus 450. Theprocessor 410 is capable of processing instructions for execution within thesystem 400. In one implementation, theprocessor 410 is a single-threaded processor. In another implementation, theprocessor 410 is a multi-threaded processor. Theprocessor 410 is capable of processing instructions stored in thememory 420 or on thestorage device 430. - The
memory 420 stores information within thesystem 400. In one implementation, thememory 420 is a computer-readable medium. In one implementation, thememory 420 is a volatile memory unit. In another implementation, thememory 420 is a non-volatile memory unit. - The
storage device 430 is capable of providing mass storage for thesystem 400. In one implementation, thestorage device 430 is a computer-readable medium. In various different implementations, thestorage device 430 can, for example, include a hard disk device, an optical disk device, or some other large capacity storage device. - The input/
output device 440 provides input/output operations for thesystem 400. In one implementation, the input/output device 440 can include one or more of a network interface device, e.g., an Ethernet card, a serial communication device, e.g., and RS-232 port, and/or a wireless interface device, e.g., an 802.11 card. In another implementation, the input/output device can include driver devices configured to receive input data and send output data to other input/output devices, e.g., keyboard, printer anddisplay devices 460. - While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any inventions or of what may be claimed, but rather as descriptions of features specific to particular implementations of particular inventions. Certain features that are described in this specification in the context of separate implementations can also be configured in combination in a single implementation. Conversely, various features that are described in the context of a single implementation can also be configured in multiple implementations separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.
- Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system components in the implementations described above should not be understood as requiring such separation in all implementations, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
- Thus, particular implementations of the subject matter have been described. Other implementations are within the scope of the following claims. In some cases, the actions recited in the claims can be performed in a different order and still achieve desirable results. In addition, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In certain implementations, multitasking and parallel processing may be advantageous.
Claims (24)
1. A method performed by a data processing apparatus, the method comprising:
receiving a request from a binary under test;
transmitting the request to a live backend system;
receiving a response to the transmitted request from the live backend system, the received response including a plurality of fields;
modifying the received response by selectively altering a specified subset of the plurality of fields in the received response according to predetermined testing requirements and leaving the remaining fields in the received response unaltered; and
transmitting the modified response to the binary under test.
2. The method of claim 1 , further comprising:
generating a key based on the request; and
storing the modified response based on the key.
3. The method of claim 2 , further comprising:
receiving a second request from the binary under test;
generating a key based on the second request;
determining that the key is associated with a stored response; and
transmitting the stored response to the binary under test.
4. The method of claim 1 , wherein the request comprises a request for an advertisement, the response comprises an advertisement, the binary under test comprises a binary that renders the advertisement, and the live backend system comprises an advertisement server.
5. The method of claim 4 , wherein the advertisement includes visible fields and invisible fields, and modifying the response comprises:
modifying visible fields of the advertisement.
6. The method of claim 5 , wherein the visible fields of the advertisement include one or more of a title of the advertisement, text in the advertisement, or a hyperlink in the advertisement.
7. The method of claim 1 , further comprising:
receiving input identifying the specified subset of fields in the received response to be altered.
8. The method of claim 1 , further comprising:
receiving input that controls how the specified subset of fields is to be altered.
9. A computer storage medium encoded with instructions that when executed by a data processing device cause the data processing device to perform operations comprising:
receiving a request from a binary under test;
transmitting the request to a live backend system;
receiving a response to the transmitted request from the live backend system, the received response including a plurality of fields;
modifying the received response by selectively altering a specified subset of the plurality of fields in the received response according to predetermined testing requirements and leaving the remaining fields in the received response unaltered; and
transmitting the modified response to the binary under test.
10. The computer storage medium of claim 9 , wherein the instructions that when executed by the data processing device cause the data processing device to perform operations further comprising:
generating a key based on the request; and
storing the modified response based on the key.
11. The computer storage medium of claim 10 , wherein the instructions that when executed by the data processing device cause the data processing device to perform operations further comprising:
receiving a second request from the binary under test;
generating a key based on the second request;
determining that the key is associated with a stored response; and
transmitting the stored response to the binary under test.
12. The computer storage medium of claim 9 , wherein the request comprises a request for an advertisement, the response comprises an advertisement, the binary under test comprises a binary that renders the advertisement, and the live backend system comprises an advertisement server.
13. The computer storage medium of claim 12 , wherein the advertisement includes visible fields and invisible fields, and modifying the response comprises:
modifying visible fields of the advertisement.
14. The computer storage medium of claim 13 , wherein the visible fields of the advertisement include one or more of a title of the advertisement, text in the advertisement, or a hyperlink in the advertisement.
15. The computer storage medium of claim 9 , wherein the instructions that when executed by the data processing device cause the data processing device to perform operations further comprising:
receiving input identifying the specified subset of fields in the received response to be altered.
16. The computer storage medium of claim 9 , wherein the instructions that when executed by the data processing device cause the data processing device to perform operations further comprising:
receiving input that controls how the specified subset of fields is to be altered.
17. A system, comprising:
a data processing apparatus; and
a non-transitory computer storage medium encoded with instructions that when executed by the data processing apparatus cause the data processing apparatus to perform operations comprising:
receiving a request from a binary under test;
transmitting the request to a live backend system;
receiving a response to the transmitted request from the live backend system, the received response including a plurality of fields;
modifying the received response by selectively altering a specified subset of the plurality of fields in the received response according to predetermined testing requirements and leaving the remaining fields in the received response unaltered; and
transmitting the modified response to the binary under test.
18. The system of claim 17 , wherein the instructions that when executed by the data processing device cause the data processing device to perform operations further comprising:
generating a key based on the request; and
storing the modified response based on the key.
19. The system of claim 18 , wherein the instructions that when executed by the data processing device cause the data processing device to perform operations further comprising:
receiving a second request from the binary under test;
generating a key based on the second request;
determining that the key is associated with a stored response; and
transmitting the stored response to the binary under test.
20. The system of claim 17 , wherein the request comprises a request for an advertisement, the response comprises an advertisement, the binary under test comprises a binary that renders the advertisement, and the live backend system comprises an advertisement server.
21. The system of claim 20 , wherein the advertisement includes visible fields and invisible fields, and modifying the response comprises:
modifying visible fields of the advertisement.
22. The system of claim 21 , wherein the visible fields of the advertisement include one or more of a title of the advertisement, text in the advertisement, or a hyperlink in the advertisement.
23. The system of claim 17 , wherein the instructions that when executed by the data processing device cause the data processing device to perform operations further comprising:
receiving input identifying the specified subset of fields in the received response to be altered.
24. The system of claim 17 , wherein the instructions that when executed by the data processing device cause the data processing device to perform operations further comprising:
receiving input that controls how the specified subset of fields is to be altered.
Priority Applications (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/649,295 US20140108589A1 (en) | 2012-10-11 | 2012-10-11 | Testing an executable binary file using an injection proxy |
PCT/US2013/064397 WO2014059182A1 (en) | 2012-10-11 | 2013-10-10 | Testing an executable binary file using an injection proxy |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/649,295 US20140108589A1 (en) | 2012-10-11 | 2012-10-11 | Testing an executable binary file using an injection proxy |
Publications (1)
Publication Number | Publication Date |
---|---|
US20140108589A1 true US20140108589A1 (en) | 2014-04-17 |
Family
ID=50476457
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US13/649,295 Abandoned US20140108589A1 (en) | 2012-10-11 | 2012-10-11 | Testing an executable binary file using an injection proxy |
Country Status (2)
Country | Link |
---|---|
US (1) | US20140108589A1 (en) |
WO (1) | WO2014059182A1 (en) |
Cited By (16)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20150205702A1 (en) * | 2008-09-30 | 2015-07-23 | Interactive TKO, Inc | Service modeling and virtualization |
US20150212927A1 (en) * | 2014-01-24 | 2015-07-30 | Bank Of America Corporation | Application Testing Automation |
CN106648945A (en) * | 2016-09-30 | 2017-05-10 | 北京金山安全软件有限公司 | Interface data testing method and device and electronic equipment |
US9727314B2 (en) | 2014-03-21 | 2017-08-08 | Ca, Inc. | Composite virtual services |
US9886365B2 (en) | 2016-01-07 | 2018-02-06 | Ca, Inc. | Transactional boundaries for software system debugging |
US9898390B2 (en) | 2016-03-30 | 2018-02-20 | Ca, Inc. | Virtual service localization |
US9946639B2 (en) | 2016-03-30 | 2018-04-17 | Ca, Inc. | Transactional boundaries for virtualization within a software system |
US9983856B2 (en) | 2016-01-08 | 2018-05-29 | Ca, Inc. | Transaction flow visualization |
US10025839B2 (en) | 2013-11-29 | 2018-07-17 | Ca, Inc. | Database virtualization |
US10114736B2 (en) | 2016-03-30 | 2018-10-30 | Ca, Inc. | Virtual service data set generation |
US20180342266A1 (en) * | 2013-06-05 | 2018-11-29 | Snakt, Inc. | Methods and systems for creating, combining, and sharing time-constrained videos |
US10154098B2 (en) | 2016-01-07 | 2018-12-11 | Ca, Inc. | Transactional boundaries for software system profiling |
US10296445B2 (en) | 2015-09-13 | 2019-05-21 | Ca, Inc. | Automated system documentation generation |
US10341214B2 (en) | 2016-03-30 | 2019-07-02 | Ca, Inc. | Scenario coverage in test generation |
US10394583B2 (en) | 2016-03-31 | 2019-08-27 | Ca, Inc. | Automated model generation for a software system |
US10628420B2 (en) | 2015-12-18 | 2020-04-21 | Ca, Inc. | Dynamic virtual service |
Citations (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20070174429A1 (en) * | 2006-01-24 | 2007-07-26 | Citrix Systems, Inc. | Methods and servers for establishing a connection between a client system and a virtual machine hosting a requested computing environment |
US20080139191A1 (en) * | 2006-12-08 | 2008-06-12 | Miguel Melnyk | Content adaptation |
US20080189247A1 (en) * | 2007-02-01 | 2008-08-07 | Yahoo! Inc. | Method and system for improved categorical searching |
US20080270998A1 (en) * | 2003-09-19 | 2008-10-30 | Matador Technologies Corp. | Application integration testing |
US20100281102A1 (en) * | 2009-05-02 | 2010-11-04 | Chinta Madhav | Methods and systems for launching applications into existing isolation environments |
Family Cites Families (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US7624370B2 (en) * | 2005-04-18 | 2009-11-24 | Research In Motion Limited | System and method for facilitating development of an application and supporting access to a plurality of heterogeneous backend servers |
US7526680B2 (en) * | 2005-06-15 | 2009-04-28 | International Business Machines Corporation | Stress testing a website having a backend application |
US7886284B2 (en) * | 2006-09-05 | 2011-02-08 | International Business Machines Corporation | Using a backend simulator to test and develop xforms templates before linking the xforms templates to backend data processing systems |
US20110321013A1 (en) * | 2010-06-23 | 2011-12-29 | Quickunit Ltd | Interactive environment for test case generation associated with a computer code |
US8589883B2 (en) * | 2010-07-22 | 2013-11-19 | Sap Ag | Automation of testing for user interface applications |
-
2012
- 2012-10-11 US US13/649,295 patent/US20140108589A1/en not_active Abandoned
-
2013
- 2013-10-10 WO PCT/US2013/064397 patent/WO2014059182A1/en active Application Filing
Patent Citations (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20080270998A1 (en) * | 2003-09-19 | 2008-10-30 | Matador Technologies Corp. | Application integration testing |
US20070174429A1 (en) * | 2006-01-24 | 2007-07-26 | Citrix Systems, Inc. | Methods and servers for establishing a connection between a client system and a virtual machine hosting a requested computing environment |
US20080139191A1 (en) * | 2006-12-08 | 2008-06-12 | Miguel Melnyk | Content adaptation |
US20080189247A1 (en) * | 2007-02-01 | 2008-08-07 | Yahoo! Inc. | Method and system for improved categorical searching |
US20100281102A1 (en) * | 2009-05-02 | 2010-11-04 | Chinta Madhav | Methods and systems for launching applications into existing isolation environments |
Cited By (19)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US10565086B2 (en) * | 2008-09-30 | 2020-02-18 | Ca, Inc. | Service modeling and virtualization |
US20150205702A1 (en) * | 2008-09-30 | 2015-07-23 | Interactive TKO, Inc | Service modeling and virtualization |
US20180342266A1 (en) * | 2013-06-05 | 2018-11-29 | Snakt, Inc. | Methods and systems for creating, combining, and sharing time-constrained videos |
US10706888B2 (en) * | 2013-06-05 | 2020-07-07 | Snakt, Inc. | Methods and systems for creating, combining, and sharing time-constrained videos |
US10025839B2 (en) | 2013-11-29 | 2018-07-17 | Ca, Inc. | Database virtualization |
US20150212927A1 (en) * | 2014-01-24 | 2015-07-30 | Bank Of America Corporation | Application Testing Automation |
US9170921B2 (en) * | 2014-01-24 | 2015-10-27 | Bank Of America Corporation | Application testing automation |
US9727314B2 (en) | 2014-03-21 | 2017-08-08 | Ca, Inc. | Composite virtual services |
US10296445B2 (en) | 2015-09-13 | 2019-05-21 | Ca, Inc. | Automated system documentation generation |
US10628420B2 (en) | 2015-12-18 | 2020-04-21 | Ca, Inc. | Dynamic virtual service |
US10154098B2 (en) | 2016-01-07 | 2018-12-11 | Ca, Inc. | Transactional boundaries for software system profiling |
US9886365B2 (en) | 2016-01-07 | 2018-02-06 | Ca, Inc. | Transactional boundaries for software system debugging |
US9983856B2 (en) | 2016-01-08 | 2018-05-29 | Ca, Inc. | Transaction flow visualization |
US10114736B2 (en) | 2016-03-30 | 2018-10-30 | Ca, Inc. | Virtual service data set generation |
US9946639B2 (en) | 2016-03-30 | 2018-04-17 | Ca, Inc. | Transactional boundaries for virtualization within a software system |
US10341214B2 (en) | 2016-03-30 | 2019-07-02 | Ca, Inc. | Scenario coverage in test generation |
US9898390B2 (en) | 2016-03-30 | 2018-02-20 | Ca, Inc. | Virtual service localization |
US10394583B2 (en) | 2016-03-31 | 2019-08-27 | Ca, Inc. | Automated model generation for a software system |
CN106648945A (en) * | 2016-09-30 | 2017-05-10 | 北京金山安全软件有限公司 | Interface data testing method and device and electronic equipment |
Also Published As
Publication number | Publication date |
---|---|
WO2014059182A1 (en) | 2014-04-17 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US20140108589A1 (en) | Testing an executable binary file using an injection proxy | |
JP6173546B2 (en) | Redirect reduction | |
US9934129B1 (en) | Determining application test results using screenshot metadata | |
US9124549B1 (en) | Automated web frontend sharding | |
US9547721B2 (en) | Native application search results | |
US10091313B2 (en) | Method and system for tracking web link usage | |
US8738448B2 (en) | Web page ad slot identification | |
US9723061B1 (en) | Transport protocol independent communications library | |
Pacheco | Microservice Patterns and Best Practices: Explore patterns like CQRS and event sourcing to create scalable, maintainable, and testable microservices | |
US9389891B2 (en) | Custom browser-side spreadsheet functions | |
JP2010500689A (en) | Method for enabling web analysis of interactive web applications | |
US20180131779A1 (en) | Recording And Triggering Web And Native Mobile Application Events With Mapped Data Fields | |
AU2014223495B2 (en) | Caching pagelets of structured documents | |
US20230106266A1 (en) | Indexing Access Limited Native Applications | |
US9069873B2 (en) | Apparatus and method for creating mashup web application | |
US9369544B1 (en) | Testing compatibility with web services | |
US20130124971A1 (en) | Real time web script refresh using asynchronous polling without full web page reload | |
Pan et al. | Gray computing: A framework for computing with background javascript tasks | |
CN111870937B (en) | Data processing method, simulation server and timeliness application | |
CN116820991A (en) | Processing method and device of resource access logic, electronic equipment and storage medium | |
Hansson | Multi-Target Mobile App for eDOCS DM | |
US20140229524A1 (en) | Network communication latency |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:DHANDA, SANJEEV;REEL/FRAME:029608/0137Effective date: 20121008 |
|
STCB | Information on status: application discontinuation |
Free format text: ABANDONED -- FAILURE TO RESPOND TO AN OFFICE ACTION |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044144/0001Effective date: 20170929 |