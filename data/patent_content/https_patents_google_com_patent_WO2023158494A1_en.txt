WO2023158494A1 - Neural architecture search with improved computational efficiency - Google Patents
Neural architecture search with improved computational efficiency Download PDFInfo
- Publication number
- WO2023158494A1 WO2023158494A1 PCT/US2022/054079 US2022054079W WO2023158494A1 WO 2023158494 A1 WO2023158494 A1 WO 2023158494A1 US 2022054079 W US2022054079 W US 2022054079W WO 2023158494 A1 WO2023158494 A1 WO 2023158494A1
- Authority
- WO
- WIPO (PCT)
- Prior art keywords
- neural network
- computing system
- architecture
- new architecture
- computer
- Prior art date
Links
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
- G06N3/082—Learning methods modifying the architecture, e.g. adding, deleting or silencing nodes or connections
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/0499—Feedforward networks
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
- G06N3/092—Reinforcement learning
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
- G06N3/0985—Hyperparameter optimisation; Meta-learning; Learning-to-learn
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/048—Activation functions
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
- G06N3/084—Backpropagation, e.g. using gradient descent
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
- G06N3/096—Transfer learning
Definitions
- the present disclosure relates generally to systems and methods for neural architecture search. More particularly, the present disclosure relates to neural architecture search techniques that have improved computational efficiency via performance of a constraint-based screening and improved gradient update approach. Further, the proposed approaches provide significant improvements for certain modalities of input data, such as tabular datasets.
- Artificial neural networks are a class of machine-learned models that are especially powerful, accurate, or otherwise high- performing for various tasks.
- An artificial neural network can include a group of connected nodes, which can also be referred to as (artificial) neurons or perceptrons.
- An artificial neural network can be organized into one or more layers.
- Artificial neural networks that include multiple layers can be referred to as “deep” networks.
- Example artificial neural networks include feed-forward neural networks, recurrent neural networks, convolutional neural networks, other forms of artificial neural networks, or combinations thereof. Each of these example types has different internal structures or “architectures” that enable, in part, the particular benefits provided by that type of artificial neural network.
- the architecture of an artificial neural network can correspond to or include the structure, arrangement, number, types, behavior, operations performed by, and/or other properties of the neurons or layers of neurons included in the network.
- Neural architecture search uses the principles and techniques of machine learning to automate or “learn” the design of new artificial neural network architectures.
- neural architecture search (NAS) techniques may seek to automate the specification and discovery of entire neural network topologies, activation functions, gradient update rules, and/or many other complex details that underlie state-of-the-art deep learning architectures. These efforts assume various names in addition to neural architecture search, including “learning to learn,” “AutoML,” “meta-learning,” or the like.
- NAS approaches have largely been confined to searching for architectures for image processing. For vision tasks, optimizing the models to make them suitable for practical deployment often relies on NAS that targets convolutional networks on vision benchmarks.
- NAS has shown strong outcomes for model architectures for vision processing, direct application of the vision approaches for tabular data is suboptimal. In particular, existing vision-based NAS techniques struggle to find the optimal architectures for tabular datasets. The failure is likely caused at least in part by the interaction of the search space and the reinforcement learning (RL) controller.
- RL reinforcement learning
- a popular approach is to use a factorized RL controller, which assumes that all choices can be made independently.
- the search space consists of a limited number of options per layer.
- the optimal solution is to set the size of layer 1 to 4 and layer 2 to 2. Finding this solution is difficult with a cost penalty.
- the RL controller is initialized with uniform probabilities. As a result, it is quite likely that the RL controller will initially be penalized heavily when choosing option 4 for the first layer, since two thirds of the choices for the second layer will result in a model that is too expensive. As a result, option 4 for the first layer is quickly discarded by the RL controller and the NAS process gets stuck in a local optimum. [0012] To circumvent this problem, one could attempt to learn a non-factorized probability distribution. However, this requires a more complicated model, e.g., an LSTM, that is often more difficult to tune.
- One example aspect of the present disclosure is directed to a computer- implemented method of neural architecture search with increased computational efficiency.
- the method includes defining, by a computing system comprising one or more computing devices, a plurality of searchable parameters that control an architecture of a neural network, wherein the neural network is configured to process input data to produce inferences.
- the method includes, for one or more iterations: determining, by the computing system using a controller model, a new set of values for the plurality of searchable parameters to generate a new architecture for the neural network; determining, by the computing system, whether the neural network with the new architecture satisfies one or more constraints; when the neural network with the new architecture does not satisfy the one or more constraints: discarding, by the computing system, the new architecture; and when the neural network with the new architecture satisfies the one or more constraints: determining, by the computing system, one or more performance metrics for the neural network with the new architecture relative to production of inferences for a set of validation data; evaluating, by the computing system, a value function that provides a value based at least in part on the one or more performance metrics and a conditional probability of the new architecture for the neural network given that the new architecture for the neural network satisfies the one or more constraints; and updating, by the computing system, one or more values of one or more parameters of the controller model based on the value function.
- Another example aspect of the present disclosure is directed to a computer system that includes one or more processors and one or more non-transitory computer- readable media that collectively store instructions that, when executed by the one or more processors, cause the computing system to perform operations.
- the operations include determining, by the computing system using a controller model, a new set of values for a plurality of searchable parameters to generate a new architecture for the neural network; determining, by the computing system, one or more performance metrics for the neural network with the new architecture relative to production of inferences for a set of validation data; evaluating, by the computing system, a value function that provides a value based at least in part on the one or more performance metrics and a conditional probability of the new architecture for the neural network given that the new architecture for the neural network satisfies one or more constraints; and updating, by the computing system, one or more values of one or more parameters of the controller model based on the value function.
- Another example aspect of the present disclosure is directed to one or more non- transitory computer-readable media that collectively store a neural network having a final architecture identified by performance of operations for a plurality of iterations.
- the operations include determining, by the computing system using a controller model, a new set of values for a plurality of searchable parameters to generate a new architecture for the neural network; determining, by the computing system, one or more performance metrics for the neural network with the new architecture relative to production of inferences for a set of validation data; evaluating, by the computing system, a value function that provides a value based at least in part on the one or more performance metrics and a conditional probability of the new architecture for the neural network given that the new architecture for the neural network satisfies one or more constraints; and updating, by the computing system, one or more values of one or more parameters of the controller model based on the value function [0017]
- Other aspects of the present disclosure are directed to various systems, apparatuses, non-transitory computer-readable media, user interface
- Figure 1A depicts a block diagram of an example neural architecture search according to example embodiments of the present disclosure.
- Figure 1B depicts a block diagram of an example neural architecture search according to example embodiments of the present disclosure.
- Figure 2A depicts a block diagram of an example computing system according to example embodiments of the present disclosure.
- Figure 2B depicts a block diagram of an example computing device according to example embodiments of the present disclosure.
- Figure 2C depicts a block diagram of an example computing device according to example embodiments of the present disclosure.
- Reference numerals that are repeated across plural figures are intended to identify the same features in various implementations.
- DETAILED DESCRIPTION Overview [0027]
- the present disclosure is directed to neural architecture search techniques that have improved computational efficiency via performance of an initial constraint evaluation and improved gradient update approach. Further, the proposed approaches provide significant improvements for certain modalities of input data, such as tabular datasets.
- certain existing NAS algorithms designed for image search spaces incorporate resource constraints directly into the reinforcement learning rewards.
- search spaces for tabular NAS pose considerable challenges for these existing reward-shaping methods.
- example systems described herein can immediately discard any architecture that violates one or more constraints that have been established. Discarding can include flagging, marking, or otherwise treating the architecture as no longer a candidate for providing as a result of the search.
- some example systems can implement a Monte-Carlo-based correction to the RL policy gradient update to account for this extra filtering step. Results on several tabular datasets show that the proposed approach efficiently finds high-quality models that satisfy the given constraints.
- one example aspect of the present disclosure identifies failure cases of existing resource-aware NAS methods on tabular data and links these cases to the cost penalty in the reward.
- Another example aspect of the present disclosure proposes and evaluates an alternative: a rejection mechanism which ensures that the RL controller can only select architectures that satisfy one or more constraints (e.g., user-specified resource constraint(s)). Instead of reward shaping, this extra rejection step allows the RL controller to more immediately explore parts of the search space which would otherwise be overlooked (e.g., due to focusing on a local, but not global optimum).
- the rejection mechanism can in some settings introduce a systematic bias into the RL gradient updates, which can skew the search results.
- the present disclosure also introduces a theoretically motivated and empirically effective correction into the proposed gradient updates.
- This correction can be computed exactly for small search spaces. When the search space is large, the correction can be efficiently approximated with Monte-Carlo sampling, as described herein.
- Example implementations of the present disclosure which implement these aspects can be referred to as TabNAS, a RL-based weight-sharing NAS with the rejection- based reward that can robustly and efficiently find a feasible architecture that has optimal performance within given constraint(s).
- the present disclosure provides a number of technical effects and benefits.
- the systems and methods of the present disclosure are able to generate new neural architectures much faster and using much fewer computing resources (e.g., less processing power, less memory usage, less power consumption, etc.), for example as compared to naive search techniques which search the entire search space.
- the systems and methods of the present disclosure are able to generate new neural architectures that are better suited for resource- constrained environments, for example as compared to search techniques which do not contain constraints on the size and/or runtime of the network.
- the resulting neural architectures are able to be run relatively faster and using relatively fewer computing resources (e.g., less processing power, less memory usage, less power consumption, etc.), all while remaining competitive with or even exceeding the performance (e.g., accuracy) of current state-of-the-art models.
- the search technique described herein can automatically find significantly better models than existing approaches and achieve a new state-of-the-art trade-off between performance and runtime/size.
- the proposed systems and methods conserve computational resources by choosing not to explore candidate architectures that do not satisfy constraint(s).
- the present disclosure provides a novel approach for automatically learning neural network architectures that are particularly suitable for processing of tabular data sets, which existing vision-focused NAS techniques would fail to discover.
- the proposed systems and methods improve the performance of a computer system on tasks associated with processing and/or generating inferences from tabular data.
- Hyperparameters are the non-architectural parameters that control the training process of either stand-alone training or RL, including learning rate, optimizer type, optimizer parameters, etc.
- Neural architecture A neural network with specified architecture and hyperparameters can be referred to as a model. The number of hidden nodes after each weight matrix and activation function is called a hidden layer size. A single network in the search space can be denoted with hyphen-connected choices. For example, when searching for hidden layer sizes, in the space of 3-hidden-layer ReLU networks, 32-144-24 denotes the candidate where the sizes of the first, second and third hidden layers are 32, 144 and 24, respectively.
- Loss-resource tradeoff and reference architectures Within the hidden layer size search space, the validation loss in general decreases with the increase of the number of parameters, giving the loss-resource tradeoff. Loss and number of parameters can be understood as two costs for the NAS problem. Thus, there are Pareto-optimal models that achieve the smallest loss among all models with a given bound on the number of parameters. Given a certain architecture that outperforms others with a similar or less number of parameters, example implementations can perform resource-constrained NAS with the number of parameters of this given architecture as the resource target or constraint.
- This architecture can be referred to as the reference (architecture) of NAS, and its performance the reference performance.
- NAS can be performed with the goal of matching (the size and performance of) the reference.
- the RL controller only has knowledge of the number of parameters of the reference, and is not informed of its hidden layer sizes.
- x (k) denotes the k-th sample.
- Example RL algorithms can learn a set of logits in which l ij is the logit associated with the j-th choice for the i-th hidden layer.
- the probability of sampling the j-th choice for the i-th layer p ij is given by the SoftMax function:
- an architecture y can be sampled to compute the single- step RL objective J(y), and update the logits with ⁇ J(y): an unbiased estimate of the gradient of the RL value function.
- the number of parameters which can be easily computed for neural networks, can be used as a cost metric or constraint. Other metrics can be used as well – the systems and methods of the present disclosure do not depend on the specific cost used. Additional example constraints include a runtime latency, a serving latency, a training latency, and/or various other measurable characteristics of an architecture or model.
- Example Neural Architecture Search Techniques [0046] This section provides the details of various example implementations of the present disclosure. These details are provided as examples of how the proposed techniques could be implemented, but the proposed techniques are not limited to these example details. A more general description of the proposed approaches is contained in the following section.
- some of the example systems for NAS described herein can be decomposed into three main components: weight-sharing with layer warmup, REINFORCE with one-shot search, and Monte Carlo (MC) sampling with rejection.
- a SuperNet which is a network that layer-wise has width to be the largest choice within the search space.
- a computer system implementing the NAS process (a “search system”) can first stochastically update the weights of the entire SuperNet to “warm up” over the first 25% of search epochs. Then the search system can alternate between updating the shared model weights (which are used to estimate the quality of different child models) and the RL controller (which focuses the search on the most promising parts of the space).
- the search system in each iteration, can first sample a child network from the current layer-wise probability distributions and update the corresponding weights within the SuperNet (weight update), then sample another child network to update the layerwise logits that give the probability distributions (RL update).
- the latter RL update is only performed if the sampled network is feasible.
- rejection with Monte-Carlo sampling can be used to update the logits with a sampling probability conditional on the feasible set, as described in more detail elsewhere herein.
- some example implementations can split the labelled portion of a dataset into training and validation splits. Weight updates can be carried out on the training split; RL updates can be performed on the validation split.
- Example Weight Sharing with Layer Warmup has shown success on various computer vision tasks and NAS benchmarks.
- some example implementations can build a SuperNet where the size of each hidden layer is the largest value in the search space.
- the child network uses only the first l i hidden nodes in that layer to compute the output in the forward pass.
- the weights that are included in the child network can be updated in the backward pass.
- the weights of the child network can be used to estimate the quality reward that is used to update the controller (e.g., the logits).
- warmup helps to ensure that the SuperNet weights are sufficiently trained to properly guide the RL updates.
- the search system can train all weights of the SuperNet, and with probability 1- p the search system only train the weights of a random child model.
- the search system can do warmup in the first 25% epochs, during which the probability p decays (e.g., linearly) from 1 to 0.
- the RL controller can be disabled during this period.
- an example search system can learn a separate probability distribution over C i size candidates for each layer.
- the distribution is given by C i logits via the SoftMax function.
- Each layer has its own independent set of logits.
- the REINFORCE-based algorithm can train the SuperNet weights and learn the logits that give the sampling probabilities over size candidates by alternating between weight and RL updates.
- the search system in each iteration, can first sample a child network x from the SuperNet and compute its training loss in the forward pass. Then the search system can update the weights in the child network with gradients of the training loss computed in the backward pass. This weight update step trains the weights of the sampled network. The weights in the architectures with larger sampling probabilities are sampled and thus trained more often.
- the search system can then update the logits for the RL controller by sampling a child network y that is independent of the network x from the same layerwise distributions, computing the quality reward Q(y) as 1- loss(y) on the validation set, and then updating the controller (e.g., the logits) with the gradient of the product of the advantage of the current network’s reward over past rewards (usually an exponential moving average) and the log-probability of the current sample.
- the alternation creates a positive feedback loop that trains the weights and updates the logits of the large-probability child networks; thus the layer-wise sampling probabilities gradually converge to more deterministic distributions, under which one or several architectures are finally selected.
- Algorithm 1 (Resource-Oblivious) One-Shot Training and REINFORCE: Input: search space S, weight learning rate ⁇ , RL learning rate ⁇
- RL update: for i 1
- Example Rejection-Based Reward with MC Sampling [0063] Only a subset of the architectures in the search space ⁇ will satisfy a set of given resource constraint(s), V denotes this set of feasible architectures.
- a resource target T 0 is often used in an RL reward.
- a latency-aware reward combines its quality Q(y) and resource consumption T(y) into a single reward.
- Certain prior works propose the reward functions Q(y) ⁇ (T(y)/T 0 ) ⁇ and Q(y) ⁇ max ⁇ 1, T(y)/T 0 ) ⁇ ⁇ while others propose the absolute value reward (or Abs Reward) Q(y) + ⁇
- ⁇ is a hyperparameter that needs careful tuning.
- the idea behind these reward functions is to encourage models with high quality with respect the resource target.
- the factorized search space determines that a separate (independent) probability distribution is learned for the choices of each layer. While this distribution is efficient to learn, the independence assumption makes it difficult for a RL controller with a resource-aware reward to choose a bottleneck structure.
- a bottleneck requires the controller to select large sizes for some layers and small layer sizes for others. But decisions for different layers are made independently, and both very large and very small layer sizes, when selected independently of each other, have very negative expected rewards. Small layers are likely to have suboptimal quality, and large layers are likely to exceed the resource constraints.
- a rejection-based RL reward is provided, one example of which is shown in Algorithm 2.
- REINFORCE optimizes a set of logits which define a probability distribution p over architectures.
- a random architecture y is sampled from p and then its quality Q(y) is estimated.
- Updates to the logits l ij take the form where ⁇ is the learning rate, and is a moving average of recent rewards. can be referred to as a value function. If y is better (resp. worse) than average then will be positive (resp. negative), so the REINFORCE update will increase (resp. decrease) the probability of sampling the same architecture in the future.
- the search system can sample N architectures ⁇ z (k) ⁇ k ⁇ [N] within the search space with a proposal distribution q, and get as an estimate of P(V).
- p (k) is the probability of sampling z (k) with the factorized layerwise distributions, and is thus differentiable with respect to the logits.
- q (k) is the probability of sampling z (k) with the proposal distribution, and is therefore non-differentiable. is an unbiased and consistent estimate of P(V), and is a consistent estimate of .
- a larger N gives better result; in some example experiments, less than the size of the sample space was able to achieve a faithful estimate because neighboring RL steps can correct the estimates of each other.
- Example Neural Architecture Search [0074] Instead of hand-designing an architecture, aspects of the present disclosure perform an architecture search for automatic design within a huge search space.
- FIG. 1A depicts a graphical diagram of an example reinforcement learning approach to neural architecture search according to example embodiments of the present disclosure.
- the illustrated neural architecture search can perform an architecture search within a search space 12.
- the search space 12 can define or contain a number of searchable parameters. Acceptable values or ranges of values can be provided for each searchable parameter.
- the search process can iteratively search within the search space 12 to identify optimal network architectures within the search space 12. [0077] Having defined the search space 12, the search process can proceed on an iterative basis.
- the reinforcement learning process shown in Figure 1A includes a controller 30 that operates to generate (e.g., select values for) a new architecture 18.
- the controller 30 can act as an agent in a reinforcement learning scheme to select values for the searchable parameters of the search space 12 to generate the new architecture 18.
- the controller 30 can apply a policy (e.g., output a prediction (e.g., a probabilistic prediction) on the basis of its learned parameter values) to select the values for the searchable parameters to generate the new architecture 18.
- the controller 30 can be a recurrent neural network.
- the controller 30 can include a plurality of sets of logits that are respectively associated with the plurality of searchable parameters.
- each of the plurality of sets of logits generates its respective prediction independent of the other sets of logits.
- the search process can first perform a constraint evaluation process 20 that determines whether the new architecture 18 satisfies one or more constraints.
- the constraints evaluated at 20 can include constraints on the number of parameters, storage space required by the model, model runtime, training latency, serving latency, interoperability to certain hardware accelerators, parallelizability, etc.
- some or all of the constraint(s) can be evaluated prior to any training 22 and/or evaluation 24 of the new architecture 18.
- a constraint on a number of parameters can easily be evaluated by simply analyzing the number of parameters included in the architecture 18.
- some or all of the constraints can be evaluated at the beginning or during training 22 and/or evaluation 24.
- a constraint on the runtime of the new architecture 18 may require some number of initial forward passes using the network to evaluate the runtime of the network.
- the runtime of the network can be estimated (e.g., without performing any forward passes through the network) and the runtime constraint can be evaluated based on such estimation.
- the new architecture 18 does not satisfy the constraint(s), then it can be discarded (e.g., with little to no time spent on training 22 and/or evaluation 24).
- the search process can return to the candidate generation stage and generate another new architecture.
- the controller 30 can generate another new architecture. Discarding can include flagging, marking, or otherwise treating the new architecture 18 as no longer a candidate for providing as a result of the search.
- the new architecture 18 may be deleted or optionally retained in memory (e.g., as an artefact of the search).
- the new architecture 18 does satisfy the constraint(s), then it can be trained 22 on a set of training data and then evaluated 24 on a set of evaluation data (e.g., validation data). In some implementations in which weight sharing is used (as described above), training 22 may not be necessary or performed.
- training 22 may be performed on a first candidate architecture to update shared weights while the evaluation 24 can be performed on a second, different candidate architecture after the shared weights have been updated.
- Figure 1A shows an approach in which each candidate architecture is both trained and evaluated.
- other implementations of the present disclosure alternate between training a candidate architecture (e.g., a model that includes shared weights, where training is performed to update the shared weights) and evaluating a performance of a candidate architecture (e.g., where evaluation is performed to update the controller 30). This arrangement is described in certain sections above and also shown in Figure 1B. Further, while Figure 1B shows constraint evaluation occurring during a training loop, this is not required.
- evaluation 24 can include assessing one or more performance metrics (e.g., a fitness function ) for a trained model having the new architecture 18.
- the fitness function can be various forms of loss functions and/or performance metrics (e.g., accuracy, recall, area under curve, resource-aware losses, etc.)
- the search system can use the performance metric(s) measured at evaluation 24 to determine a reward 32 to provide to the controller 30 in a reinforcement learning scheme.
- the reward can be correlated to the performance of the architecture 18 (e.g., a better performance results in a larger reward and vice versa).
- determining the reward 32 can include evaluating, by the computing system, a value function that provides a value based at least in part on the one or more performance metrics and a conditional probability of the new architecture 18 for the neural network given that the new architecture for the neural network satisfies the one or more constraints.
- the conditional probability can be an exact conditional probability. In other implementations, the conditional probability comprises an estimated conditional probability.
- evaluating, by the computing system, the value function can include performing, by the computing system, a Monte-Carlo sampling technique to determine the estimated conditional probability.
- a Monte-Carlo sampling technique to determine the estimated conditional probability.
- the policy of the controller 30 can be updated based on the reward 32.
- the search system can update one or more values of one or more parameters of the controller model based on the value function described above.
- the controller 30 can learn (e.g., through update of its policy based on the reward 32) to produce architectures 18 that provide strong performance. In some implementations, if the architecture 18 fails the constraint evaluation 20, the controller 30 can be provided with zero reward, negative reward, or a relatively low reward.
- FIG. 1A depicts a block diagram of an example computing system 100 according to example embodiments of the present disclosure.
- the system 100 includes a user computing device 102, a server computing system 130, and an architecture search computing system 150 that are communicatively coupled over a network 180.
- the user computing device 102 can be any type of computing device, such as, for example, a personal computing device (e.g., laptop or desktop), a mobile computing device (e.g., smartphone or tablet), a gaming console or controller, a wearable computing device, an embedded computing device, or any other type of computing device.
- the user computing device 102 includes one or more processors 112 and a memory 114.
- the one or more processors 112 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, a FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected.
- the memory 114 can include one or more non-transitory computer-readable storage mediums, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof.
- the memory 114 can store data 116 and instructions 118 which are executed by the processor 112 to cause the user computing device 102 to perform operations.
- the user computing device 102 can store or include one or more neural networks 120.
- the neural networks 120 can be or can otherwise include various machine-learned models such feed-forward neural networks, recurrent neural networks (e.g., long short-term memory recurrent neural networks), convolutional neural networks or other forms of neural networks.
- the one or more neural networks 120 can be received from the server computing system 130 over network 180, stored in the user computing device memory 114, and then used or otherwise implemented by the one or more processors 112.
- the user computing device 102 can implement multiple parallel instances of a single neural network 120
- one or more neural networks 140 can be included in or otherwise stored and implemented by the server computing system 130 that communicates with the user computing device 102 according to a client-server relationship.
- the neural networks 140 can be implemented by the server computing system 140 as a portion of a web service.
- one or more networks 120 can be stored and implemented at the user computing device 102 and/or one or more networks 140 can be stored and implemented at the server computing system 130.
- the user computing device 102 can also include one or more user input component 122 that receives user input.
- the user input component 122 can be a touch-sensitive component (e.g., a touch-sensitive display screen or a touch pad) that is sensitive to the touch of a user input object (e.g., a finger or a stylus).
- the touch-sensitive component can serve to implement a virtual keyboard.
- Other example user input components include a microphone, a traditional keyboard, or other means by which a user can provide user input.
- the server computing system 130 includes one or more processors 132 and a memory 134.
- the one or more processors 132 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, a FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected.
- the memory 134 can include one or more non-transitory computer-readable storage mediums, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof.
- the memory 134 can store data 136 and instructions 138 which are executed by the processor 132 to cause the server computing system 130 to perform operations.
- the server computing system 130 includes or is otherwise implemented by one or more server computing devices.
- the server computing system 130 can store or otherwise include one or more machine-learned neural networks 140.
- the neural networks 140 can be or can otherwise include feed forward neural networks, deep neural networks, recurrent neural networks, and convolutional neural networks.
- the user computing device 102 and/or the server computing system 130 can train and/or evaluate the networks 120 and/or 140 via interaction with the architecture search computing system 150 that is communicatively coupled over the network 180.
- the architecture search computing system 150 can be separate from the server computing system 130 or can be a portion of the server computing system 130.
- the architecture search computing system 150 includes one or more processors 152 and a memory 154.
- the one or more processors 152 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, a FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected.
- the memory 154 can include one or more non-transitory computer- readable storage mediums, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof.
- the memory 154 can store data 156 and instructions 158 which are executed by the processor 152 to cause the architecture search computing system 150 to perform operations.
- the architecture search computing system 150 includes or is otherwise implemented by one or more server computing devices.
- the architecture search computing system 150 can include a model trainer 160 that trains and/or evaluates the machine-learned networks 120 and/or 140 stored at the user computing device 102 and/or the server computing system 130 using various training or learning techniques, such as, for example, backwards propagation of errors.
- performing backwards propagation of errors can include performing truncated backpropagation through time.
- the model trainer 160 can perform a number of generalization techniques (e.g., weight decays, dropouts, etc.) to improve the generalization capability of the models being trained.
- the model trainer 160 can train the neural networks 120 and/or 140 based on a set of training data 162.
- the training examples can be provided by the user computing device 102.
- the network 120 provided to the user computing device 102 can be trained by the architecture search computing system 150 on user-specific data received from the user computing device 102. In some instances, this process can be referred to as personalizing the model.
- the architecture search computing system 150 can also include a network searcher 159.
- the network searcher 159 can have the components and framework described herein, such as, for example, as illustrated in Figure 1A.
- the network searcher 159 can include a controller (e.g., an RNN-based controller) and/or a reward generator.
- the network searcher 159 can cooperate with the model trainer 160 to train the controller and/or generated architectures.
- the architecture search computing system 150 can also optionally be communicatively coupled with various other devices (not specifically shown) that measure performance parameters of the generated networks (e.g., mobile phone replicas which replicate mobile phone performance of the networks to evaluate hardware- specific runtimes).
- Each of the model trainer 160 and the network searcher 159 can include computer logic utilized to provide desired functionality.
- Each of the model trainer 160 and the network searcher 159 can be implemented in hardware, firmware, and/or software controlling a general purpose processor.
- each of the model trainer 160 and the network searcher 159 can include program files stored on a storage device, loaded into a memory and executed by one or more processors.
- each of the model trainer 160 and the network searcher 159 can include one or more sets of computer-executable instructions that are stored in a tangible computer-readable storage medium such as RAM hard disk or optical or magnetic media.
- the network 180 can be any type of communications network, such as a local area network (e.g., intranet), wide area network (e.g., Internet), or some combination thereof and can include any number of wired or wireless links.
- communication over the network 180 can be carried via any type of wired and/or wireless connection, using a wide variety of communication protocols (e.g., TCP/IP, HTTP, SMTP, FTP), encodings or formats (e.g., HTML, XML), and/or protection schemes (e.g., VPN, secure HTTP, SSL).
- TCP/IP Transmission Control Protocol/IP
- HTTP HyperText Transfer Protocol
- SMTP Simple Stream Transfer Protocol
- FTP e.g., HTTP
- FTP encodings or formats
- protection schemes e.g., VPN, secure HTTP, SSL
- the machine-learned models described in this specification may be used in a variety of tasks, applications, and/or use cases.
- the input to the machine-learned model(s) of the present disclosure can be image data.
- the machine-learned model(s) can process the image data to generate an output.
- the machine-learned model(s) can process the image data to generate an image recognition output (e.g., a recognition of the image data, a latent embedding of the image data, an encoded representation of the image data, a hash of the image data, etc.).
- the machine-learned model(s) can process the image data to generate an image segmentation output.
- the machine- learned model(s) can process the image data to generate an image classification output.
- the machine-learned model(s) can process the image data to generate an image data modification output (e.g., an alteration of the image data, etc.).
- the machine-learned model(s) can process the image data to generate an encoded image data output (e.g., an encoded and/or compressed representation of the image data, etc.).
- the machine-learned model(s) can process the image data to generate an upscaled image data output.
- the machine-learned model(s) can process the image data to generate a prediction output.
- the input to the machine-learned model(s) of the present disclosure can be text or natural language data.
- the machine-learned model(s) can process the text or natural language data to generate an output.
- the machine- learned model(s) can process the natural language data to generate a language encoding output.
- the machine-learned model(s) can process the text or natural language data to generate a latent text embedding output.
- the machine- learned model(s) can process the text or natural language data to generate a translation output.
- the machine-learned model(s) can process the text or natural language data to generate a classification output.
- the machine-learned model(s) can process the text or natural language data to generate a textual segmentation output.
- the machine-learned model(s) can process the text or natural language data to generate a semantic intent output.
- the machine-learned model(s) can process the text or natural language data to generate an upscaled text or natural language output (e.g., text or natural language data that is higher quality than the input text or natural language, etc.).
- the machine-learned model(s) can process the text or natural language data to generate a prediction output.
- the input to the machine-learned model(s) of the present disclosure can be speech data.
- the machine-learned model(s) can process the speech data to generate an output.
- the machine-learned model(s) can process the speech data to generate a speech recognition output.
- the machine- learned model(s) can process the speech data to generate a speech translation output.
- the machine-learned model(s) can process the speech data to generate a latent embedding output.
- the machine-learned model(s) can process the speech data to generate an encoded speech output (e.g., an encoded and/or compressed representation of the speech data, etc.).
- the machine-learned model(s) can process the speech data to generate an upscaled speech output (e.g., speech data that is higher quality than the input speech data, etc.).
- the machine-learned model(s) can process the speech data to generate a textual representation output (e.g., a textual representation of the input speech data, etc.).
- the machine- learned model(s) can process the speech data to generate a prediction output.
- the input to the machine-learned model(s) of the present disclosure can be latent encoding data (e.g., a latent space representation of an input, etc.).
- the machine-learned model(s) can process the latent encoding data to generate an output.
- the machine-learned model(s) can process the latent encoding data to generate a recognition output.
- the machine-learned model(s) can process the latent encoding data to generate a reconstruction output.
- the machine-learned model(s) can process the latent encoding data to generate a search output.
- the machine-learned model(s) can process the latent encoding data to generate a reclustering output.
- the machine-learned model(s) can process the latent encoding data to generate a prediction output.
- the input to the machine-learned model(s) of the present disclosure can be statistical data.
- Statistical data can be, represent, or otherwise include data computed and/or calculated from some other data source.
- the machine-learned model(s) can process the statistical data to generate an output.
- the machine- learned model(s) can process the statistical data to generate a recognition output.
- the machine-learned model(s) can process the statistical data to generate a prediction output.
- the machine-learned model(s) can process the statistical data to generate a classification output.
- the machine-learned model(s) can process the statistical data to generate a segmentation output.
- the machine-learned model(s) can process the statistical data to generate a visualization output.
- the machine-learned model(s) can process the statistical data to generate a diagnostic output.
- the input to the machine-learned model(s) of the present disclosure can be sensor data.
- the machine-learned model(s) can process the sensor data to generate an output.
- the machine-learned model(s) can process the sensor data to generate a recognition output.
- the machine-learned model(s) can process the sensor data to generate a prediction output.
- the machine-learned model(s) can process the sensor data to generate a classification output.
- the machine-learned model(s) can process the sensor data to generate a segmentation output.
- the machine-learned model(s) can process the sensor data to generate a visualization output.
- the machine-learned model(s) can process the sensor data to generate a diagnostic output.
- the machine-learned model(s) can process the sensor data to generate a detection output.
- the machine-learned model(s) can be configured to perform a task that includes encoding input data for reliable and/or efficient transmission or storage (and/or corresponding decoding).
- the task may be an audio compression task.
- the input may include audio data and the output may comprise compressed audio data.
- the input includes visual data (e.g. one or more images or videos), the output comprises compressed visual data, and the task is a visual data compression task.
- the task may comprise generating an embedding for input data (e.g. input audio or visual data).
- the input includes visual data and the task is a computer vision task.
- the input includes pixel data for one or more images and the task is an image processing task.
- the image processing task can be image classification, where the output is a set of scores, each score corresponding to a different object class and representing the likelihood that the one or more images depict an object belonging to the object class.
- the image processing task may be object detection, where the image processing output identifies one or more regions in the one or more images and, for each region, a likelihood that region depicts an object of interest.
- the image processing task can be image segmentation, where the image processing output defines, for each pixel in the one or more images, a respective likelihood for each category in a predetermined set of categories.
- the set of categories can be foreground and background.
- the set of categories can be object classes.
- the image processing task can be depth estimation, where the image processing output defines, for each pixel in the one or more images, a respective depth value.
- the image processing task can be motion estimation, where the network input includes multiple images, and the image processing output defines, for each pixel of one of the input images, a motion of the scene depicted at the pixel between the images in the network input.
- the input includes audio data representing a spoken utterance and the task is a speech recognition task.
- the output may comprise a text output which is mapped to the spoken utterance.
- the task comprises encrypting or decrypting input data.
- the task comprises a microprocessor performance task, such as branch prediction or memory address translation.
- Figure 2A illustrates one example computing system that can be used to implement the present disclosure.
- the user computing device 102 can include the model trainer 160 and the training dataset 162.
- the networks 120 can be both trained and used locally at the user computing device 102.
- the user computing device 102 can implement the model trainer 160 to personalize the networks 120 based on user-specific data.
- Figure 2B depicts a block diagram of an example computing device 10 according to example embodiments of the present disclosure.
- the computing device 10 can be a user computing device or a server computing device.
- the computing device 10 includes a number of applications (e.g., applications 1 through N).
- Each application contains its own machine learning library and machine-learned model(s).
- each application can include a machine-learned model.
- Example applications include a text messaging application, an email application, a dictation application, a virtual keyboard application, a browser application, etc.
- each application can communicate with a number of other components of the computing device, such as, for example, one or more sensors, a context manager, a device state component, and/or additional components.
- each application can communicate with each device component using an API (e.g., a public API).
- an API e.g., a public API
- FIG. 2C depicts a block diagram of an example computing device 50 according to example embodiments of the present disclosure.
- the computing device 50 can be a user computing device or a server computing device.
- the computing device 50 includes a number of applications (e.g., applications 1 through N). Each application is in communication with a central intelligence layer.
- Example applications include a text messaging application, an email application, a dictation application, a virtual keyboard application, a browser application, etc.
- each application can communicate with the central intelligence layer (and model(s) stored therein) using an API (e.g., a common API across all applications).
- the central intelligence layer includes a number of machine-learned models. For example, as illustrated in Figure 2C, a respective machine-learned model (e.g., a model) can be provided for each application and managed by the central intelligence layer. In other implementations, two or more applications can share a single machine-learned model. For example, in some implementations, the central intelligence layer can provide a single model (e.g., a single model) for all of the applications. In some implementations, the central intelligence layer is included within or otherwise implemented by an operating system of the computing device 50. [0126] The central intelligence layer can communicate with a central device data layer. The central device data layer can be a centralized repository of data for the computing device 50.
- the central device data layer can communicate with a number of other components of the computing device, such as, for example, one or more sensors, a context manager, a device state component, and/or additional components.
- the central device data layer can communicate with each device component using an API (e.g., a private API).
- API e.g., a private API.
- Databases and applications can be implemented on a single system or distributed across multiple systems. Distributed components can operate sequentially or in parallel.
- FIG. 1 While the present subject matter has been described in detail with respect to various specific example embodiments thereof, each example is provided by way of explanation, not limitation of the disclosure. Those skilled in the art, upon attaining an understanding of the foregoing, can readily produce alterations to, variations of, and equivalents to such embodiments. Accordingly, the subject disclosure does not preclude inclusion of such modifications, variations and/or additions to the present subject matter as would be readily apparent to one of ordinary skill in the art. For instance, features illustrated or described as part of one embodiment can be used with another embodiment to yield a still further embodiment. Thus, it is intended that the present disclosure cover such alterations, variations, and equivalents.
Abstract
Provided are neural architecture search techniques that have improved computational efficiency via performance of an initial constraint evaluation and improved gradient update approach. Further, the proposed approaches provide significant improvements for certain modalities of input data, such as tabular datasets.
Description
NEURAL ARCHITECTURE SEARCH WITH IMPROVED COMPUTATIONAL EFFICIENCY RELATED APPLICATIONS [0001] This application claims priority to and the benefit of United States Provisional Patent Application Number 63/310,837, filed February 16, 2022. United States Provisional Patent Application Number 63/310,837 is hereby incorporated by reference in its entirety. FIELD [0002] The present disclosure relates generally to systems and methods for neural architecture search. More particularly, the present disclosure relates to neural architecture search techniques that have improved computational efficiency via performance of a constraint-based screening and improved gradient update approach. Further, the proposed approaches provide significant improvements for certain modalities of input data, such as tabular datasets. BACKGROUND [0003] Artificial neural networks (also referred to simply as “neural networks”) are a class of machine-learned models that are especially powerful, accurate, or otherwise high- performing for various tasks. An artificial neural network can include a group of connected nodes, which can also be referred to as (artificial) neurons or perceptrons. An artificial neural network can be organized into one or more layers. Artificial neural networks that include multiple layers can be referred to as “deep” networks. [0004] Example artificial neural networks include feed-forward neural networks, recurrent neural networks, convolutional neural networks, other forms of artificial neural networks, or combinations thereof. Each of these example types has different internal structures or “architectures” that enable, in part, the particular benefits provided by that type of artificial neural network. For example, the architecture of an artificial neural network can correspond to or include the structure, arrangement, number, types, behavior, operations performed by, and/or other properties of the neurons or layers of neurons included in the network. [0005] More particularly, one developing field of study is that of neural architecture search. Neural architecture search uses the principles and techniques of machine learning to automate or “learn” the design of new artificial neural network architectures. In particular, as
examples, neural architecture search (NAS) techniques may seek to automate the specification and discovery of entire neural network topologies, activation functions, gradient update rules, and/or many other complex details that underlie state-of-the-art deep learning architectures. These efforts assume various names in addition to neural architecture search, including “learning to learn,” “AutoML,” “meta-learning,” or the like. [0006] It is often observed that to improve the performance of a machine learning model, one can scale it up. However this is not always possible when machine learning models are deployed since larger networks are also more computationally expensive as measured by inference time, memory usage, energy or processor consumption, etc. These computational costs limit the application of large models: training these models is unsustainable, and inference is often too slow to satisfy end user requirements. [0007] Further, the best neural architecture for a given machine learning problem depends on many factors: not only on resource constraints including latency, compute, energy consumption, etc., but also on the complexity and structure of the dataset. For example, one of the most widespread applications of machine learning in industry is for generation of inferences based on tabular data. However, NAS for tabular datasets is an important but under-explored problem. [0008] Instead, existing NAS approaches have largely been confined to searching for architectures for image processing. For vision tasks, optimizing the models to make them suitable for practical deployment often relies on NAS that targets convolutional networks on vision benchmarks. [0009] While NAS has shown strong outcomes for model architectures for vision processing, direct application of the vision approaches for tabular data is suboptimal. In particular, existing vision-based NAS techniques struggle to find the optimal architectures for tabular datasets. The failure is likely caused at least in part by the interaction of the search space and the reinforcement learning (RL) controller. [0010] In particular, in vision, a popular approach is to use a factorized RL controller, which assumes that all choices can be made independently. The search space consists of a limited number of options per layer. For tabular data, there are typically more options per layer, but there are fewer layers overall. For example, feedforward networks with bottleneck structures often outperform other feed-forward networks of similar size on tabular data. In such a bottleneck architecture, there exists at least one hidden layer that is much narrower than its preceding and following layers. A popular hypothesis is that its weights resemble the low-rank factors of a wider network, and thus mimics the behavior of the latter with less cost.
These bottleneck structures often have a very good tradeoff between cost and quality but finding these bottleneck structures is difficult for a factorized RL controller. [0011] To understand why, consider the following toy example with 2 layers. For each layer, the controller can choose a layer size of 2, 3, or 4 and the maximum compute budget is set to 25. The optimal solution is to set the size of layer 1 to 4 and layer 2 to 2. Finding this solution is difficult with a cost penalty. The RL controller is initialized with uniform probabilities. As a result, it is quite likely that the RL controller will initially be penalized heavily when choosing option 4 for the first layer, since two thirds of the choices for the second layer will result in a model that is too expensive. As a result, option 4 for the first layer is quickly discarded by the RL controller and the NAS process gets stuck in a local optimum. [0012] To circumvent this problem, one could attempt to learn a non-factorized probability distribution. However, this requires a more complicated model, e.g., an LSTM, that is often more difficult to tune. SUMMARY [0013] Aspects and advantages of embodiments of the present disclosure will be set forth in part in the following description, or can be learned from the description, or can be learned through practice of the embodiments. [0014] One example aspect of the present disclosure is directed to a computer- implemented method of neural architecture search with increased computational efficiency. The method includes defining, by a computing system comprising one or more computing devices, a plurality of searchable parameters that control an architecture of a neural network, wherein the neural network is configured to process input data to produce inferences. The method includes, for one or more iterations: determining, by the computing system using a controller model, a new set of values for the plurality of searchable parameters to generate a new architecture for the neural network; determining, by the computing system, whether the neural network with the new architecture satisfies one or more constraints; when the neural network with the new architecture does not satisfy the one or more constraints: discarding, by the computing system, the new architecture; and when the neural network with the new architecture satisfies the one or more constraints: determining, by the computing system, one or more performance metrics for the neural network with the new architecture relative to production of inferences for a set of validation data; evaluating, by the computing system, a value function that provides a value based at least in part on the one or more performance
metrics and a conditional probability of the new architecture for the neural network given that the new architecture for the neural network satisfies the one or more constraints; and updating, by the computing system, one or more values of one or more parameters of the controller model based on the value function. [0015] Another example aspect of the present disclosure is directed to a computer system that includes one or more processors and one or more non-transitory computer- readable media that collectively store instructions that, when executed by the one or more processors, cause the computing system to perform operations. The operations include determining, by the computing system using a controller model, a new set of values for a plurality of searchable parameters to generate a new architecture for the neural network; determining, by the computing system, one or more performance metrics for the neural network with the new architecture relative to production of inferences for a set of validation data; evaluating, by the computing system, a value function that provides a value based at least in part on the one or more performance metrics and a conditional probability of the new architecture for the neural network given that the new architecture for the neural network satisfies one or more constraints; and updating, by the computing system, one or more values of one or more parameters of the controller model based on the value function. [0016] Another example aspect of the present disclosure is directed to one or more non- transitory computer-readable media that collectively store a neural network having a final architecture identified by performance of operations for a plurality of iterations. The operations include determining, by the computing system using a controller model, a new set of values for a plurality of searchable parameters to generate a new architecture for the neural network; determining, by the computing system, one or more performance metrics for the neural network with the new architecture relative to production of inferences for a set of validation data; evaluating, by the computing system, a value function that provides a value based at least in part on the one or more performance metrics and a conditional probability of the new architecture for the neural network given that the new architecture for the neural network satisfies one or more constraints; and updating, by the computing system, one or more values of one or more parameters of the controller model based on the value function [0017] Other aspects of the present disclosure are directed to various systems, apparatuses, non-transitory computer-readable media, user interfaces, and electronic devices. [0018] These and other features, aspects, and advantages of various embodiments of the present disclosure will become better understood with reference to the following description and appended claims. The accompanying drawings, which are incorporated in and constitute
a part of this specification, illustrate example embodiments of the present disclosure and, together with the description, serve to explain the related principles. [0019] The attached Appendix, which is fully incorporated into and forms a portion of this disclosure, describes example implementations of the systems and methods described herein. The systems and methods of the present disclosure are not limited to the example implementations described in the Appendix. BRIEF DESCRIPTION OF THE DRAWINGS [0020] Detailed discussion of embodiments directed to one of ordinary skill in the art is set forth in the specification, which makes reference to the appended figures, in which: [0021] Figure 1A depicts a block diagram of an example neural architecture search according to example embodiments of the present disclosure. [0022] Figure 1B depicts a block diagram of an example neural architecture search according to example embodiments of the present disclosure. [0023] Figure 2A depicts a block diagram of an example computing system according to example embodiments of the present disclosure. [0024] Figure 2B depicts a block diagram of an example computing device according to example embodiments of the present disclosure. [0025] Figure 2C depicts a block diagram of an example computing device according to example embodiments of the present disclosure. [0026] Reference numerals that are repeated across plural figures are intended to identify the same features in various implementations. DETAILED DESCRIPTION Overview [0027] Generally, the present disclosure is directed to neural architecture search techniques that have improved computational efficiency via performance of an initial constraint evaluation and improved gradient update approach. Further, the proposed approaches provide significant improvements for certain modalities of input data, such as tabular datasets. [0028] In particular, certain existing NAS algorithms designed for image search spaces incorporate resource constraints directly into the reinforcement learning rewards. However, search spaces for tabular NAS pose considerable challenges for these existing reward-shaping
methods. Therefore, the present disclosure proposes a new reinforcement learning (RL) controller to address these challenges. [0029] In particular, in some example implementations, when candidate architectures are sampled during a search, example systems described herein can immediately discard any architecture that violates one or more constraints that have been established. Discarding can include flagging, marking, or otherwise treating the architecture as no longer a candidate for providing as a result of the search. According to another example aspect of the present disclosure, some example systems can implement a Monte-Carlo-based correction to the RL policy gradient update to account for this extra filtering step. Results on several tabular datasets show that the proposed approach efficiently finds high-quality models that satisfy the given constraints. [0030] Thus, one example aspect of the present disclosure identifies failure cases of existing resource-aware NAS methods on tabular data and links these cases to the cost penalty in the reward. [0031] Another example aspect of the present disclosure proposes and evaluates an alternative: a rejection mechanism which ensures that the RL controller can only select architectures that satisfy one or more constraints (e.g., user-specified resource constraint(s)). Instead of reward shaping, this extra rejection step allows the RL controller to more immediately explore parts of the search space which would otherwise be overlooked (e.g., due to focusing on a local, but not global optimum). [0032] The rejection mechanism can in some settings introduce a systematic bias into the RL gradient updates, which can skew the search results. To compensate for this bias, the present disclosure also introduces a theoretically motivated and empirically effective correction into the proposed gradient updates. This correction can be computed exactly for small search spaces. When the search space is large, the correction can be efficiently approximated with Monte-Carlo sampling, as described herein. [0033] Example implementations of the present disclosure which implement these aspects can be referred to as TabNAS, a RL-based weight-sharing NAS with the rejection- based reward that can robustly and efficiently find a feasible architecture that has optimal performance within given constraint(s). [0034] The present disclosure provides a number of technical effects and benefits. As one example, the systems and methods of the present disclosure are able to generate new neural architectures much faster and using much fewer computing resources (e.g., less
processing power, less memory usage, less power consumption, etc.), for example as compared to naive search techniques which search the entire search space. [0035] As another technical effect and benefit, the systems and methods of the present disclosure are able to generate new neural architectures that are better suited for resource- constrained environments, for example as compared to search techniques which do not contain constraints on the size and/or runtime of the network. That is, the resulting neural architectures are able to be run relatively faster and using relatively fewer computing resources (e.g., less processing power, less memory usage, less power consumption, etc.), all while remaining competitive with or even exceeding the performance (e.g., accuracy) of current state-of-the-art models. Thus, as another example technical effect and benefit, the search technique described herein can automatically find significantly better models than existing approaches and achieve a new state-of-the-art trade-off between performance and runtime/size. [0036] In addition to identifying superior architectures, the proposed systems and methods conserve computational resources by choosing not to explore candidate architectures that do not satisfy constraint(s). In particular, by rejecting candidate architectures that do not meet constraint(s) on the final output architecture prior to completing training and evaluation of such candidate architectures, computational resources that would have been expended training and evaluating the rejected architectures can be conserved. Thus, compared to approaches which simply include constraints in the reward function, the overall expenditure of computational resources can be reduced. [0037] Further, the present disclosure provides a novel approach for automatically learning neural network architectures that are particularly suitable for processing of tabular data sets, which existing vision-focused NAS techniques would fail to discover. Thus, the proposed systems and methods improve the performance of a computer system on tasks associated with processing and/or generating inferences from tabular data. However, although aspects of the present disclosure are described relative to neural networks for processing of tabular data, the architecture search systems and methods described herein are also applicable to search for neural network architectures suitable for performing various other tasks. As an example, the architecture search systems and methods described herein may provide particular benefit in identifying network architectures for any application or domain in which network training and/or inference is particularly computationally demanding. [0038] With reference now to the Figures, example embodiments of the present disclosure will be discussed in further detail.
Example Notation and Terminology [0039] Math basics. Define [n] = {1,… ,n} for a positive integer n. With a Boolean variable the indicator function
Claims
WHAT IS CLAIMED IS: 1. A computer-implemented method of neural architecture search with increased computational efficiency, the method comprising: defining, by a computing system comprising one or more computing devices, a plurality of searchable parameters that control an architecture of a neural network, wherein the neural network is configured to process input data to produce inferences; and for one or more iterations: determining, by the computing system using a controller model, a new set of values for the plurality of searchable parameters to generate a new architecture for the neural network; determining, by the computing system, whether the neural network with the new architecture satisfies one or more constraints; when the neural network with the new architecture does not satisfy the one or more constraints: discarding, by the computing system, the new architecture; and when the neural network with the new architecture satisfies the one or more constraints: determining, by the computing system, one or more performance metrics for the neural network with the new architecture relative to production of inferences for a set of validation data; evaluating, by the computing system, a value function that provides a value based at least in part on the one or more performance metrics and a conditional probability of the new architecture for the neural network given that the new architecture for the neural network satisfies the one or more constraints; and updating, by the computing system, one or more values of one or more parameters of the controller model based on the value function.
2. The computer-implemented method of claim 1, wherein the conditional probability comprises an exact conditional probability.
3. The computer-implemented method of claim 1, wherein the conditional probability comprises an estimated conditional probability.
4. The computer-implemented method of claim 3, wherein evaluating, by the computing system, the value function comprises performing, by the computing system, a Monte-Carlo sampling technique to determine the estimated conditional probability.
5. The computer-implemented method of any preceding claim, wherein: the one or more constraints comprise a size constraint that requires that a number of parameters included in the new network architecture does not exceed a threshold number of parameters.
6. The computer-implemented method of any preceding claim, wherein: the one or more constraints comprise a training latency constraint that requires that training of neural network with the new architecture does not exceed a threshold training time.
7. The computer-implemented method of any preceding claim, wherein: the one or more constraints comprise a runtime latency constraint that requires that ta runtime latency of neural network with the new architecture does not exceed a threshold runtime.
8. The computer-implemented method of any preceding claim, wherein the validation data comprises tabular data.
9. The computer-implemented method of any preceding claim, wherein discarding, by the computing system, the new architecture comprises discarding, by the computing system, the new architecture prior to completion of training of a neural network having the new architecture.
10. The computer-implemented method of any preceding claim, wherein the controller model comprises a plurality of sets of logits that are respectively associated with
the plurality of searchable parameters, and wherein each of the plurality of sets of logits generates its respective prediction independent of the other sets of logits.
11. A computer system, comprising: one or more processors; and one or more non-transitory computer-readable media that collectively store instructions that, when executed by the one or more processors, cause the computing system to perform operations, the operations comprising: determining, by the computing system using a controller model, a new set of values for a plurality of searchable parameters to generate a new architecture for the neural network; determining, by the computing system, one or more performance metrics for the neural network with the new architecture relative to production of inferences for a set of validation data; evaluating, by the computing system, a value function that provides a value based at least in part on the one or more performance metrics and a conditional probability of the new architecture for the neural network given that the new architecture for the neural network satisfies one or more constraints; and updating, by the computing system, one or more values of one or more parameters of the controller model based on the value function.
12. The computer system of claim 11, wherein the conditional probability comprises an exact conditional probability.
13. The computer system of claim 11, wherein the conditional probability comprises an estimated conditional probability.
14. The computer system of claim 13, wherein evaluating, by the computing system, the value function comprises performing, by the computing system, a Monte-Carlo sampling technique to determine the estimated conditional probability.
15. The computer system of any of claims 11-14, wherein: the one or more constraints comprise a size constraint that requires that a number of parameters included in the new network architecture does not exceed a threshold number of parameters.
16. The computer system of any of claims 11-15, wherein: the one or more constraints comprise a training latency constraint that requires that training of neural network with the new architecture does not exceed a threshold training time.
17. The computer system of any of claims 11-16, wherein: the one or more constraints comprise a runtime latency constraint that requires that ta runtime latency of neural network with the new architecture does not exceed a threshold runtime.
18. The computer system of any of claims 11-17, wherein the validation data comprise tabular data.
19. One or more non-transitory computer-readable media that collectively store a neural network having a final architecture identified by performance of operations for a plurality of iterations, the operations comprising: determining, by the computing system using a controller model, a new set of values for a plurality of searchable parameters to generate a new architecture for the neural network; determining, by the computing system, one or more performance metrics for the neural network with the new architecture relative to production of inferences for a set of validation data; evaluating, by the computing system, a value function that provides a value based at least in part on the one or more performance metrics and a conditional probability of the new architecture for the neural network given that the new architecture for the neural network satisfies one or more constraints; and updating, by the computing system, one or more values of one or more parameters of the controller model based on the value function.
20. The one or more non-transitory computer-readable media of claim 19, wherein the training data and the validation data comprise tabular data.
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US202263310837P | 2022-02-16 | 2022-02-16 | |
US63/310,837 | 2022-02-16 |
Publications (1)
Publication Number | Publication Date |
---|---|
WO2023158494A1 true WO2023158494A1 (en) | 2023-08-24 |
Family
ID=85199062
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
PCT/US2022/054079 WO2023158494A1 (en) | 2022-02-16 | 2022-12-27 | Neural architecture search with improved computational efficiency |
Country Status (1)
Country | Link |
---|---|
WO (1) | WO2023158494A1 (en) |
Citations (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20190354837A1 (en) * | 2018-05-18 | 2019-11-21 | Baidu Usa Llc | Resource-efficient neural architects |
-
2022
- 2022-12-27 WO PCT/US2022/054079 patent/WO2023158494A1/en unknown
Patent Citations (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20190354837A1 (en) * | 2018-05-18 | 2019-11-21 | Baidu Usa Llc | Resource-efficient neural architects |
Non-Patent Citations (3)
Title |
---|
BENDER GABRIEL ET AL: "Can Weight Sharing Outperform Random Architecture Search? An Investigation With TuNAS", 2020 IEEE/CVF CONFERENCE ON COMPUTER VISION AND PATTERN RECOGNITION (CVPR), 13 August 2020 (2020-08-13), pages 1 - 13, XP093031749, Retrieved from the Internet <URL:https://arxiv.org/pdf/2008.06120.pdf> [retrieved on 20230315], DOI: 10.1109/CVPR42600.2020.01433 * |
NICK ERICKSON ET AL: "AutoGluon-Tabular: Robust and Accurate AutoML for Structured Data", ARXIV.ORG, CORNELL UNIVERSITY LIBRARY, 201 OLIN LIBRARY CORNELL UNIVERSITY ITHACA, NY 14853, 14 March 2020 (2020-03-14), XP081621393 * |
YANG CHENGRUN ET AL: "TabNAS: Rejection Sampling for Neural Architecture Search on Tabular Datasets", 20 October 2022 (2022-10-20), pages 1 - 30, XP093031290, Retrieved from the Internet <URL:https://arxiv.org/pdf/2204.07615.pdf> [retrieved on 20230313], DOI: 10.48550/arxiv.2204.07615 * |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
EP3711000B1 (en) | Regularized neural network architecture search | |
US11138471B2 (en) | Augmentation of audiographic images for improved machine learning | |
CN110503192B (en) | Resource efficient neural architecture | |
US20230015737A1 (en) | Contrastive Pre-Training for Language Tasks | |
CN111406267A (en) | Neural architecture search using performance-predictive neural networks | |
US11610097B2 (en) | Apparatus and method for generating sampling model for uncertainty prediction, and apparatus for predicting uncertainty | |
US20210383223A1 (en) | Joint Architecture And Hyper-Parameter Search For Machine Learning Models | |
He et al. | Structured pruning for deep convolutional neural networks: A survey | |
US20220366257A1 (en) | Small and Fast Video Processing Networks via Neural Architecture Search | |
CN113826125A (en) | Training machine learning models using unsupervised data enhancement | |
US20200074296A1 (en) | Learning to search deep network architectures | |
CN115104105A (en) | Antagonistic autocoder architecture for graph-to-sequence model approach | |
US20190228297A1 (en) | Artificial Intelligence Modelling Engine | |
US20230267315A1 (en) | Diffusion Models Having Improved Accuracy and Reduced Consumption of Computational Resources | |
Zhan et al. | Deep model compression via two-stage deep reinforcement learning | |
Szwarcman et al. | Quantum-inspired evolutionary algorithm applied to neural architecture search | |
Rizos et al. | Modelling sample informativeness for deep affective computing | |
US20210383237A1 (en) | Training Robust Neural Networks Via Smooth Activation Functions | |
US20230059708A1 (en) | Generation of Optimized Hyperparameter Values for Application to Machine Learning Tasks | |
CN113673235A (en) | Energy-based language model | |
Gao | Game-theoretic approaches for generative modeling | |
JP2022523207A (en) | Systems and methods for generating pyramid layer architectures | |
CN115345303A (en) | Convolutional neural network weight tuning method, device, storage medium and electronic equipment | |
WO2023158494A1 (en) | Neural architecture search with improved computational efficiency | |
Thavasimani et al. | Deep learning techniques: A case study on comparative analysis of various optimizers to detect bots from CRESCI-2017 dataset |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
121 | Ep: the epo has been informed by wipo that ep was designated in this application |
Ref document number: 22854616Country of ref document: EPKind code of ref document: A1 |