CN114930357A - Privacy preserving machine learning via gradient boosting - Google Patents
Privacy preserving machine learning via gradient boosting Download PDFInfo
- Publication number
- CN114930357A CN114930357A CN202180007358.5A CN202180007358A CN114930357A CN 114930357 A CN114930357 A CN 114930357A CN 202180007358 A CN202180007358 A CN 202180007358A CN 114930357 A CN114930357 A CN 114930357A
- Authority
- CN
- China
- Prior art keywords
- share
- user profile
- computing system
- mpc
- user
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
- 238000010801 machine learning Methods 0.000 title claims abstract description 281
- 238000000034 method Methods 0.000 claims abstract description 234
- 239000013598 vector Substances 0.000 claims description 167
- 230000006870 function Effects 0.000 claims description 110
- 238000009826 distribution Methods 0.000 claims description 82
- 238000012549 training Methods 0.000 claims description 63
- 238000003860 storage Methods 0.000 claims description 33
- 230000009466 transformation Effects 0.000 claims description 33
- 238000004590 computer program Methods 0.000 claims description 15
- 238000013528 artificial neural network Methods 0.000 claims description 6
- 238000003066 decision tree Methods 0.000 claims description 6
- 238000000638 solvent extraction Methods 0.000 claims description 5
- 238000009795 derivation Methods 0.000 claims 1
- 230000008569 process Effects 0.000 description 87
- 239000011159 matrix material Substances 0.000 description 34
- 238000010586 diagram Methods 0.000 description 26
- 238000012545 processing Methods 0.000 description 26
- 230000002776 aggregation Effects 0.000 description 23
- 238000004220 aggregation Methods 0.000 description 23
- 230000004044 response Effects 0.000 description 21
- 238000004364 calculation method Methods 0.000 description 20
- 238000013215 result calculation Methods 0.000 description 17
- 238000004422 calculation algorithm Methods 0.000 description 15
- 238000004891 communication Methods 0.000 description 11
- 235000014510 cooky Nutrition 0.000 description 9
- 238000011156 evaluation Methods 0.000 description 9
- 230000003993 interaction Effects 0.000 description 8
- 238000013507 mapping Methods 0.000 description 8
- 239000002131 composite material Substances 0.000 description 7
- 238000013515 script Methods 0.000 description 7
- 230000009471 action Effects 0.000 description 6
- 230000005540 biological transmission Effects 0.000 description 6
- 239000000047 product Substances 0.000 description 6
- 238000007637 random forest analysis Methods 0.000 description 6
- 230000000694 effects Effects 0.000 description 5
- 230000001965 increasing effect Effects 0.000 description 5
- 230000036961 partial effect Effects 0.000 description 5
- 238000012795 verification Methods 0.000 description 5
- 230000009286 beneficial effect Effects 0.000 description 4
- 230000008901 benefit Effects 0.000 description 4
- 238000013500 data storage Methods 0.000 description 4
- 230000003287 optical effect Effects 0.000 description 3
- 230000000644 propagated effect Effects 0.000 description 3
- 101710165595 Mitochondrial pyruvate carrier 2 Proteins 0.000 description 2
- 102100025031 Mitochondrial pyruvate carrier 2 Human genes 0.000 description 2
- 101710101698 Probable mitochondrial pyruvate carrier 2 Proteins 0.000 description 2
- 230000004931 aggregating effect Effects 0.000 description 2
- 238000013459 approach Methods 0.000 description 2
- 230000001934 delay Effects 0.000 description 2
- 238000013461 design Methods 0.000 description 2
- 238000007726 management method Methods 0.000 description 2
- 238000004519 manufacturing process Methods 0.000 description 2
- 238000010295 mobile communication Methods 0.000 description 2
- 238000000926 separation method Methods 0.000 description 2
- 239000013589 supplement Substances 0.000 description 2
- 238000012360 testing method Methods 0.000 description 2
- 238000012546 transfer Methods 0.000 description 2
- 230000001131 transforming effect Effects 0.000 description 2
- 238000009827 uniform distribution Methods 0.000 description 2
- FGRBYDKOBBBPOI-UHFFFAOYSA-N 10,10-dioxo-2-[4-(N-phenylanilino)phenyl]thioxanthen-9-one Chemical compound O=C1c2ccccc2S(=O)(=O)c2ccc(cc12)-c1ccc(cc1)N(c1ccccc1)c1ccccc1 FGRBYDKOBBBPOI-UHFFFAOYSA-N 0.000 description 1
- FFBHFFJDDLITSX-UHFFFAOYSA-N benzyl N-[2-hydroxy-4-(3-oxomorpholin-4-yl)phenyl]carbamate Chemical compound OC1=C(NC(=O)OCC2=CC=CC=C2)C=CC(=C1)N1CCOCC1=O FFBHFFJDDLITSX-UHFFFAOYSA-N 0.000 description 1
- 239000000872 buffer Substances 0.000 description 1
- 239000006227 byproduct Substances 0.000 description 1
- 230000008859 change Effects 0.000 description 1
- 238000010411 cooking Methods 0.000 description 1
- 230000007423 decrease Effects 0.000 description 1
- 230000003247 decreasing effect Effects 0.000 description 1
- 230000007123 defense Effects 0.000 description 1
- 230000002708 enhancing effect Effects 0.000 description 1
- 238000010413 gardening Methods 0.000 description 1
- 239000011521 glass Substances 0.000 description 1
- 230000003116 impacting effect Effects 0.000 description 1
- 230000006872 improvement Effects 0.000 description 1
- 230000002427 irreversible effect Effects 0.000 description 1
- 238000005304 joining Methods 0.000 description 1
- 239000004973 liquid crystal related substance Substances 0.000 description 1
- RBNIGDFIUWJJEV-UHFFFAOYSA-N methyl 2-(n-benzoyl-3-chloro-4-fluoroanilino)propanoate Chemical compound C=1C=C(F)C(Cl)=CC=1N(C(C)C(=O)OC)C(=O)C1=CC=CC=C1 RBNIGDFIUWJJEV-UHFFFAOYSA-N 0.000 description 1
- 238000003062 neural network model Methods 0.000 description 1
- 238000004321 preservation Methods 0.000 description 1
- 238000004801 process automation Methods 0.000 description 1
- 230000009467 reduction Effects 0.000 description 1
- 230000002829 reductive effect Effects 0.000 description 1
- 230000002441 reversible effect Effects 0.000 description 1
- 230000011218 segmentation Effects 0.000 description 1
- 239000004065 semiconductor Substances 0.000 description 1
- 230000001953 sensory effect Effects 0.000 description 1
- 238000007619 statistical method Methods 0.000 description 1
- 239000000758 substrate Substances 0.000 description 1
- 238000000844 transformation Methods 0.000 description 1
- 230000007704 transition Effects 0.000 description 1
- 230000000007 visual effect Effects 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N20/00—Machine learning
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N20/00—Machine learning
- G06N20/20—Ensemble learning
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/60—Protecting data
- G06F21/62—Protecting access to data via a platform, e.g. using keys or access control rules
- G06F21/6218—Protecting access to data via a platform, e.g. using keys or access control rules to a system of files or objects, e.g. local or distributed file system or database
- G06F21/6245—Protecting personal data, e.g. for financial or medical purposes
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N5/00—Computing arrangements using knowledge-based models
- G06N5/04—Inference or reasoning models
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/08—Key distribution or management, e.g. generation, sharing or updating, of cryptographic keys or passwords
- H04L9/0816—Key establishment, i.e. cryptographic processes or cryptographic protocols whereby a shared secret becomes available to two or more parties, for subsequent use
- H04L9/085—Secret sharing or secret splitting, e.g. threshold schemes
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/30—Public key, i.e. encryption algorithm being computationally infeasible to invert or user's encryption keys not requiring secrecy
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/32—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols including means for verifying the identity or authority of a user of the system or for message authentication, e.g. authorization, entity authentication, data integrity or data verification, non-repudiation, key authentication or verification of credentials
- H04L9/321—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols including means for verifying the identity or authority of a user of the system or for message authentication, e.g. authorization, entity authentication, data integrity or data verification, non-repudiation, key authentication or verification of credentials involving a third party or a trusted authority
- H04L9/3213—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols including means for verifying the identity or authority of a user of the system or for message authentication, e.g. authorization, entity authentication, data integrity or data verification, non-repudiation, key authentication or verification of credentials involving a third party or a trusted authority using tickets or tokens, e.g. Kerberos
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/32—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols including means for verifying the identity or authority of a user of the system or for message authentication, e.g. authorization, entity authentication, data integrity or data verification, non-repudiation, key authentication or verification of credentials
- H04L9/3247—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols including means for verifying the identity or authority of a user of the system or for message authentication, e.g. authorization, entity authentication, data integrity or data verification, non-repudiation, key authentication or verification of credentials involving digital signatures
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N5/00—Computing arrangements using knowledge-based models
- G06N5/01—Dynamic search techniques; Heuristics; Dynamic trees; Branch-and-bound
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L2209/00—Additional information or applications relating to cryptographic mechanisms or cryptographic arrangements for secret or secure communication H04L9/00
- H04L2209/46—Secure multiparty computation, e.g. millionaire problem
Abstract
This describes a privacy preserving machine learning platform. In one aspect, a method includes receiving, by a first computing system of a plurality of multi-party computing (MPC) systems, an inference request comprising a first share of a given user profile. A predictive label for a given user profile is determined based at least in part on the first machine learning model. Prediction residual values indicative of prediction errors in the prediction labels for a given user profile are determined. The first computing system determines a first share of the prediction residual values for the given user profile based at least in part on the first share of the given user profile and the second machine learning model. The first computing system receives, from a second computing system of the MPC computing systems, data indicative of a second share of the prediction residual values for the given user profile.
Description
Cross Reference to Related Applications
This application claims priority to IL application No.277910 filed on 9/10/2020. The disclosures of the above applications are incorporated herein by reference in their entirety.
Technical Field
The specification relates to a privacy preserving machine learning platform using secure multiparty computing to train and use machine learning models.
Background
Some machine learning models are trained based on data collected from multiple sources, e.g., across multiple websites and/or native applications. However, the data may include private or sensitive data that should not be shared or allowed to be revealed to other parties.
Disclosure of Invention
In general, one innovative aspect of the subject matter described in this specification can be embodied in methods that include: receiving, by a first computing system of a plurality of multi-party computing (MPC) computing systems, an inference request comprising a first share of a given user profile; determining a predictive label for a given user profile based at least in part on a first machine learning model trained using a plurality of user profiles; determining a prediction residual value for a given user profile indicative of a prediction error in the prediction label; generating, by the first computing system, a first share of inferences based at least in part on the prediction labels and the prediction residual values determined for the given user profile; and providing, by the first computing system to a client device, the first share of the inference result and a second share of the inference result received from the second computing system. Determining the prediction residual value for the given user profile comprises determining, by the first computing system, a first share of the prediction residual value for the given user profile based at least in part on the first share of the given user profile and a second machine learning model trained using the plurality of user profiles and data indicative of differences between a plurality of real labels of the plurality of user profiles and a plurality of prediction labels as determined for the plurality of user profiles using the first machine learning model; receiving, by the first computing system from a second computing system of the plurality of MPC computing systems, data indicative of a second share of the prediction residual values for the given user profile determined by the second computing system based at least in part on the second share of the given user profile and a second set of one or more machine learning models; and determining the prediction residual value for the given user profile based at least in part on the first and second shares of the prediction residual value. Other embodiments of this aspect include corresponding apparatuses, systems, and computer programs, configured to perform aspects of the methods, encoded on computer storage devices.
These and other embodiments can each optionally include one or more of the following features. In some aspects, determining the predictive label for the given user profile comprises: determining, by the first computing system, a first share of the predictive tag based at least in part on: (i) a first share of the given user profile, (ii) the first machine learning model trained using the plurality of user profiles, and (iii) one or more real tags of the plurality of user profiles, the plurality of real tags including one or more real tags of each user profile of the plurality of user profiles; receiving, by the first computing system from the second computing system, data indicative of a second share of the predictive label determined by the second computing system based at least in part on the second share of the given user profile and the first set of one or more machine learning models; and determining the predictive label based at least in part on the first share and the second share of the predictive label.
In some implementations, the method further includes applying, by the first computing system, a transformation to the first share of a given user profile to obtain a first transformed share of the given user profile. In such embodiments, determining, by the first computing system, the first share of the predictive tag comprises determining, by the first computing system, a first share of the predictive tag based at least in part on the first transformed share of the given user profile. In some such embodiments, the transform is a stochastic projection, such as the Johnson-Lindenstaus (J-L) transform. In some of the above embodiments, determining, by the first computing system, the first share of the predictive tag comprises: providing, by the first computing system, the first transformed share of the given user profile as input to the first machine learning model to obtain as output a first share of the predictive label for a given user profile.
In some examples, the method further includes evaluating performance of the first machine learning model, and training the second machine learning model using data determined while evaluating performance of the first machine learning model. In these examples, evaluating performance of the first machine learning model includes, for each of the plurality of user profiles: determining a prediction label for the user profile and determining a residual value for the user profile indicative of an error in the prediction label. Further, in these examples, determining the predictive label for the user profile includes: determining, by the first computing system, a first share of a predictive tag of the user profile based at least in part on: (i) a first share of the user profile, (ii) the first machine learning model, and (iii) one or more of the plurality of real tags of the plurality of user profiles; receiving, by the first computing system from the second computing system, data indicative of a second share of the predictive label of the user profile determined by the second computing system based at least in part on the second share of the user profile and a first set of one or more machine learning models maintained by the second computing system; and determining the predictive label for the user profile based at least in part on the first and second shares of the predictive label. Additionally, in such examples, determining the residual values of the user profile comprises: determining, by the first computing system, a first share of the residual values for the user profile based at least in part on the predicted tags determined for the user profile and a first share of real tags of the user profile included in the plurality of real tags; receiving, by the first computing system from the second computing system, data indicative of a second share of the residual values of the user profile determined by the second computing system based at least in part on the predicted tag determined for the user profile and a second share of the real tag of the user profile; and determining the residual value of the user profile based at least in part on the first and second shares of the residual value. In the foregoing example, training the second machine learning model using data determined in evaluating performance of the first machine learning model comprises: training the second machine learning model using data indicative of the residual values determined for the plurality of user profiles when evaluating the performance of the first machine learning model.
In some of the above examples, prior to evaluating the performance of the first machine learning model, the method further comprises deriving a set of parameters of a function, and configuring the first machine learning model to generate an initial predictive label for a user profile given the user profile as input and applying the function as defined based on the derived set of parameters to the initial predictive label of the user profile to generate a first share of predictive labels for the user profile as output. In at least some of these examples, deriving the set of parameters of the function includes: (i) deriving, by the first computing system, a first share of the set of parameters for the function based at least in part on a first share of each of the plurality of real tags, (ii) receiving, by the first computing system from the second computing system, data indicative of a second share of the set of parameters for the function derived by the second computing system based at least in part on a second share of each of the plurality of real tags, and (iii) deriving the set of parameters for the function based at least in part on the first share and the second share of the set of parameters for the function. In at least some of the above examples, the function is a quadratic polynomial function.
In some such examples, the method further includes estimating, by the first computing system, a first share of a set of distribution parameters based at least in part on the first share of each of the plurality of real tags. In these examples, deriving, by the first computing system, the first share of the set of parameters of the function based at least in part on the first share of each of the plurality of real tags comprises: deriving, by the first computing system, a first share of the set of parameters of the function based at least in part on the first share of the set of distribution parameters. In at least some of the above examples, the set of distribution parameters includes: (i) one or more parameters of a probability distribution of prediction errors for a real tag of a first value of the plurality of real tags, and (ii) one or more parameters of a probability distribution of prediction errors for a real tag of a second value of the plurality of real tags. In these examples, the second value is different from the first value. Further, in at least some of the examples above, the first share of the residual values for the user profile is indicative of a difference in value between the predicted tag determined for the user profile and the first share of the real tag for the user profile, and the second share of the residual values for the user profile is indicative of a difference in value between the predicted tag determined for the user profile and the second share of the real tag for the user profile.
In some implementations, (i) the first machine learning model includes a k-nearest neighbor model maintained by the first computing system, (ii) the first set of one or more machine learning models includes a k-nearest neighbor model maintained by the second computing system, (iii) the second machine learning model includes at least one of: (iii) a Deep Neural Network (DNN) maintained by the first computing system and a Gradient Boosting Decision Tree (GBDT) maintained by the first computing system, and/or (iv) the second set of one or more machine learning models comprises at least one of: a DNN maintained by the second computing system and a GBDT maintained by the second computing system.
In at least some of these embodiments, determining, by the first computing system, the first share of the predictive tag comprises: (i) identifying, by the first computing system, a first set of nearest neighbor user profiles based at least in part on the first shares of the given user profile and the k nearest neighbor model maintained by the first computing system, (ii) receiving, by the first computing system from the second computing system, data indicative of a second set of nearest neighbor profiles identified by the second computing system based at least in part on the second shares of the given user profile and the k nearest neighbor model maintained by the second computing system, (iii) identifying k nearest neighbor user profiles of the plurality of user profiles that are deemed most similar to the given user profile based at least in part on the first set and the second set of nearest neighbor user profiles, and (iv) determining, by the first computing system, the real label of the predictive label based at least in part on the real label of each of the k nearest neighbor user profiles A first fraction.
In at least some of the above embodiments, determining, by the first computing system, the first share of the predictive tags further includes (i) determining, by the first computing system, a first share of a sum of the real tags of the k nearest neighbor user profiles, (ii) receiving, by the first computing system, a second share of the sum of the real tags of the k nearest neighbor user profiles from the second computing system, and (iii) determining the sum of the real tags of the k nearest neighbor user profiles based at least in part on the first share and the second share of the sum of the real tags of the k nearest neighbor user profiles. Further, in some such embodiments, determining, by the first computing system, the first share of the predictive tag further comprises applying a function to a sum of the real tags of the k nearest neighbor user profiles to generate the first share of the predictive tag for the given user profile. In some of the above embodiments, the first share of the predictive labels of the given user profile comprises a sum of the real labels of the k nearest neighbor user profiles.
In some of the above embodiments, determining, by the first computing system, the first share of the predicted tag based at least in part on the real tag of each of the k nearest neighbor user profiles comprises determining, by the first computing system, a first share of a set of predicted tags based at least in part on a set of real tags of each of the k nearest neighbor user profiles respectively corresponding to a set of categories. In these embodiments, determining, by the first computing system, a first share of the predictive tag set comprises: including, for each category in the set: (i) determining a first share of frequencies at which real tags corresponding to the category in the set of real tags of a user profile of the k nearest neighbor user profiles are first values of real tags, (ii) receiving, by the first computing system from the second computing system, a second share of frequencies at which real tags corresponding to the category in the set of real tags of a user profile of the k nearest neighbor user profiles are the first values of real tags, and (iii) determine a frequency that a real tag corresponding to the category in the set of real tags for a user profile of the k nearest neighbor user profiles is a real tag of the first value based at least in part on the first and second shares of frequencies that the real tag corresponding to the category in the set of real tags for a user profile of the k nearest neighbor user profiles is the real tag of the first value. In some of these embodiments, determining, by the first computing system, the first quota of the set of predicted tags includes, for each category in the set: applying a function corresponding to the category to a frequency of real tags corresponding to the category in the set of real tags for a user profile of the k nearest neighbor user profiles being real tags of the first value to generate a first share of predicted tags corresponding to the category for the given user profile.
Another innovative aspect of the subject matter described in this specification can be embodied in methods that include: receiving, by a secure MPC cluster of a computing system, an inference request associated with a given user profile; determining, by the MPC cluster, a predictive label for the given user profile based at least in part on a first machine learning model trained using a plurality of user profiles; determining, by the MPC cluster, prediction residual values of the given user profile indicative of prediction errors in the prediction labels based at least in part on the given user profile and a second machine learning model trained using the user profile and data indicative of differences between real labels of the user profile and prediction labels determined for the user profile using the first machine learning model; generating, by the MPC cluster, data representing an inference result based at least in part on the prediction labels and the prediction residual values determined for the given user profile; and providing, by the MPC cluster, the data representing the inference to a client device. Other embodiments of this aspect include corresponding apparatuses, systems, and computer programs, configured to perform aspects of the methods, encoded on computer storage devices.
These and other embodiments can each optionally include one or more of the following features. In some aspects, the inference request includes an encrypted second share of the given user profile encrypted using an encryption key of the second computing system. Some aspects may include transmitting the encrypted second share of the given user profile to the second computing system.
In some aspects, determining the predictive label for a given user profile comprises determining, by the MPC cluster, the predictive label for a given user profile based at least in part on: (i) the given user profile, (ii) the first machine learning model trained using the user profile, and (iii) one or more of the real tags of the user profile, the real tags comprising one or more real tags of each of the plurality of user profiles.
In some embodiments, the method further comprises applying, by the MPC cluster, a transformation to the given user profile to obtain a transformed version of the given user profile. In these embodiments, determining, by the MPC cluster, the prediction label comprises determining, by the MPC cluster, the prediction label based at least in part on the transformed version of the given user profile. In some such embodiments, the transform is a stochastic projection, such as the Johnson-Lindenstaus (J-L) transform. In at least some of the above embodiments, determining, by the MPC cluster, the prediction label includes providing, by the MPC cluster, the transformed version of the given user profile as input to the first machine learning model to obtain, as output, the prediction label for the given user profile.
In some examples, the method further includes evaluating performance of the first machine learning model, and training the second machine learning model using data determined while evaluating performance of the first machine learning model. In such an example, (1) determining, by the MPC cluster, a predictive label for the user profile based at least in part on: (i) the user profile, (ii) the first machine learning model, and (iii) one or more of the real labels of the user profile, and (2) determining, by the MPC cluster, a residual value of the user profile indicative of a prediction error in the prediction label based at least in part on the prediction label determined for the user profile and a real label of the user profile included in the real labels. In the above example, training the second machine learning model using the data determined in evaluating the performance of the first machine learning model comprises: training the second machine learning model using data indicative of the residual values determined for the user profile when evaluating performance of the first machine learning model.
In at least some of the above examples, prior to evaluating performance of the first machine learning model, the method further includes deriving, by the MPC cluster, a set of parameters of a function based at least in part on the real label, and configuring the first machine learning model to generate an initial prediction label for a user profile given the user profile as input, and applying the function as defined based on the derived set of parameters to the initial prediction label for the user profile to generate a prediction label for the user profile as output. In some such examples, the method further comprises estimating, by the MPC cluster, a set of normal distribution parameters based at least in part on the true label. In these examples, deriving, by the MPC cluster, the set of parameters for the function based at least in part on the real label comprises: deriving, by the MPC cluster, the set of parameters of the function based at least in part on the estimated set of normal distribution parameters. In some of the above examples, the set of distribution parameters includes: one or more parameters of a probability distribution of prediction errors of a genuine tag of a first value of the genuine tags, and one or more parameters of a probability distribution of prediction errors of a genuine tag of a second value of the genuine tags, the second value being different from the first value. Further, in some of the above examples, the function is a quadratic polynomial function. In at least some of the above examples, the residual value of the user profile is indicative of a difference in value between the predicted tag determined for the user profile and a true tag of the user profile.
In some embodiments, the first machine learning model comprises a k-nearest neighbor model. In some of these embodiments, determining, by the MPC cluster, the predictive label comprises: (i) identifying, by the MPC cluster, k nearest ones of the user profiles deemed to be most similar to the given user profile based at least in part on the given user profile and the k nearest neighbor model, and (ii) determining, by the MPC cluster, the predictive label based at least in part on a true label of each of the k nearest neighbor user profiles.
In at least some of the above embodiments, determining, by the MPC cluster, the predicted label based at least in part on the real label of each of the k nearest neighbor user profiles comprises determining, by the MPC cluster, a sum of the real labels of the k nearest neighbor user profiles. In some such embodiments, determining, by the MPC cluster, the predicted label further comprises applying a function to the sum of the true labels of the k nearest neighbor user profiles to generate the predicted label for the given user profile. Further, in at least some of the above embodiments, the predicted label for the given user profile comprises the sum of the true labels of the k nearest neighbor user profiles.
In at least some of the above embodiments, determining, by the MPC cluster, the prediction label based at least in part on the real label of each of the k nearest neighbor user profiles comprises: determining, by the MPC cluster, a predicted set of labels based at least in part on the real set of labels of each of the k nearest neighbor user profiles respectively corresponding to a set of classes. In these embodiments, determining, by the MPC cluster, the set of predictive labels comprises: for each category in the set, determining a frequency with which a real label corresponding to a category in the set of real labels of a user profile of the k nearest neighbor user profiles is a real label of a first value. In some of these embodiments, determining, by the MPC cluster, the set of predictive labels comprises: for each category in the set, a function corresponding to the category is applied to the determined frequency to generate a predictive label for the category for the given user profile.
In some examples, each authentic tag is encrypted. In some embodiments, the inference result comprises a sum of the prediction tag and the prediction residual value. In some examples, the second machine learning model includes at least one of a deep neural network, a gradient boosting decision tree, and a random forest model.
In some examples, the client device computes the given user profile using a plurality of feature vectors, each feature vector including feature values related to events of a user of the client device and a rate of decay of each feature vector.
In some examples, the client device computes the given user profile using a plurality of feature vectors, each feature vector comprising feature values related to events of a user of the client device. Calculating the given user profile can include classifying one or more feature vectors as sparse feature vectors and classifying one or more feature vectors as dense feature vectors. Some aspects can include generating a first share of the given user profile and a corresponding second share of the given user profile for one or more second computing systems using the sparse feature vector and the dense feature vector. Generating the first shares and the respective one or more second shares of the given user profile can include partitioning the sparse feature vector using a functional secret shared shares (FSS) technique.
Yet another innovative aspect of the subject matter described in this specification can be embodied in methods that include: receiving, by a first computing system of the plurality of MPC systems, an inference request comprising a first share of a given user profile; identifying k nearest neighbor user profiles of a plurality of user profiles that are considered most similar to the given user profile, comprising: identifying, by the first computing system, a first set of nearest neighbor user profiles based on the first share of the given user profile and a first k-nearest neighbor model trained using the user profile; receiving, by the first computing system from each of one or more second computing systems of the plurality of MPC systems, data indicative of a respective second set of nearest neighbor profiles identified by the second computing system based on a respective second share of the given user profile and a respective second k-nearest neighbor model trained by the second computing system; identifying, by the first computing system, k nearest neighbor user profiles based on the first set of nearest neighbor user profiles and each second set of nearest neighbor user profiles; generating, by the first computing system, a first share of inferences based on respective labels of each of the k nearest neighbor user profiles, wherein the labels of each user profile predict one or more user groups to which a user corresponding to the user profile will be added, and wherein the inferences indicate whether a given user corresponding to the given user profile will be added to a given user group; and providing, by the first computing system to the client device, the first share of the inference result and the respective second share of the inference result received from each of the one or more second computing systems. Other embodiments of this aspect include corresponding apparatuses, systems, and computer programs, configured to perform aspects of the methods, encoded on computer storage devices.
These and other embodiments can each optionally include one or more of the following features. In some aspects, the inference request includes an encrypted second share of the given user profile encrypted using an encryption key of the second computing system. Some aspects can include transmitting the encrypted second share of the given user profile to the second computing system.
In some aspects, the second share of the inference result is encrypted using an encryption key of an application of the client device. In some aspects, the label of each user profile has a boolean type for binary classification. Generating the first share of the inference result can include determining a first share of a sum of labels of the k nearest neighbor user profiles, receiving a second share of the sum of labels of the k nearest neighbor user profiles from the second computing system, determining the sum of labels based on the first share of the sum of labels and the second share of the sum of labels, determining that the sum of labels exceeds a threshold, in response to determining that the sum of labels exceeds a threshold, determining to add a given user to a given user group as the inference result, and generating the first share of the inference result based on the inference result.
In some aspects, the tag of each user profile has a numerical value. Generating the first share of the inference result may include determining a first share of a sum of tags of k nearest neighbor user profiles, receiving a second share of a sum of tags of k nearest neighbor user profiles from the second computing system, determining the sum of the tags based on the first share of the sum of the tags and the second share of the sum of the tags, determining that the given user is to join the given user group as an inference result based on the sum of the tags, and generating the first share of the inference result based on the inference result.
In some aspects, the label of each user profile has a category value. Generating the first share of the inference can include: for each tag in the set of tags, determining that a user profile of the k nearest neighbor profiles has a first share of a frequency of the tag, receiving, from the second computing system, a second share of the frequency of the tag for the user profile of the k nearest neighbor profiles, and determining that the user profile of the k nearest neighbor profiles has the frequency of the tag based on the first and second shares of the frequency of the tag for the user profile of the k nearest neighbor profiles. Some aspects can include identifying a label with a highest frequency, assigning the given user to join a given user group corresponding to the label with the highest frequency as an inference result, and generating a first share of the inference result based on the inference result.
Some aspects can include training a first k-nearest neighbor model. The training can include creating a first share of a random bit flipping pattern in cooperation with the second computing system, generating a first share of a bit matrix by projecting the first share of each of the user profiles onto a set of random projection planes, modifying the first share of the bit matrix by modifying one or more bits of the first share of the bit matrix using the first share of the bit flipping pattern, providing a first portion of the modified first share of the bit matrix to the second computing system, receiving from the second computing system a second half of a modified second share of the bit matrix generated by the second computing system using a second share of a user profile of the plurality of user profiles and a second share of the random bit pattern, and reconstructing, by the first computing system, a second half of the modified second share of the bit matrix using the modified first half of the bit matrix and the modified second half of the bit matrix Bit vectors of a second half of the first bit matrix. Creating a first share of a random bit flipping pattern in cooperation with the second computing system can include generating a first m-dimensional vector including a plurality of first elements each having a value of zero or one, splitting the first m-dimensional vector into two shares, providing the first share of the first m-dimensional vector to the second computing system, receiving a first share of a second m-dimensional vector from the second computing system, and calculating, in cooperation with the second computing system, a first share of the random bit flipping pattern using the first m-dimensional vector and the second m-dimensional vector shares. In some aspects, the plurality of MPC computing systems comprises more than two MPC computing systems.
The subject matter described in this specification can be implemented in particular embodiments to realize one or more of the following advantages. The machine learning techniques described in this document are capable of identifying users with similar interests and extending user group membership while protecting the privacy of the users, e.g., without revealing the users' online activity to any computing system. This protects the privacy of the user with respect to these platforms and protects the security of the data from being corrupted during transmission or from the platform. Cryptographic techniques such as secure multi-party computing (MPC) can extend user groups based on similarities in user profiles without using third-party cookies, which protects user privacy without negatively impacting the ability to extend user groups, and in some cases provides better user group extension based on a more complete profile than can be achieved using third-party cookies. The MPC technique can ensure that as long as one of the computing systems in the MPC cluster is honest, no user data is available in the clear by either computing system or the other. Thus, the claimed method allows user data to be identified, grouped and transmitted in a secure manner without requiring the use of third party cookies to determine any relationships between user data. This is a different approach than previously known methods, which typically require third party cookies to determine the relationship between data. By grouping user data in this manner, the efficiency of transferring data content to user devices is increased since data content not associated with a particular user need not be transferred. In particular, third party cookies are not needed, thereby avoiding the storage of third party cookies and improving memory usage. Exponential decay techniques can be used to build a user profile at a client device to reduce the data size of the raw data required to build the user profile, thereby reducing the data storage requirements of the client device, which typically has very limited data storage. For example, the accuracy of classification, e.g., for user group extension, can be improved by training a stronger model, e.g., a deep neural network model, based on another model, e.g., a k-nearest neighbor model. That is, the techniques described herein can improve accuracy by training a strong learner based on a weaker learner.
Various features and advantages of the foregoing subject matter are described below with reference to the drawings. Additional features and advantages will be apparent from the subject matter described herein and the claims.
Drawings
FIG. 1 is a block diagram of an environment in which a secure MPC cluster trains a machine learning model and a machine learning model is used to extend a group of users.
FIG. 2 is a swim lane diagram of an example process for training a machine learning model and adding a user to a user group using the machine learning model.
Fig. 3 is a flow diagram illustrating an example process for generating a user profile and sending a share of the user profile to an MPC cluster.
FIG. 4 is a flow diagram illustrating an example process for generating a machine learning model.
FIG. 5 is a flow diagram illustrating an example process for adding a user to a user group using a machine learning model.
FIG. 6 is a conceptual diagram of an exemplary framework for generating inference results of a user profile.
FIG. 7 is a conceptual diagram of an exemplary framework for generating inferences for a user profile with enhanced performance.
FIG. 8 is a flow diagram illustrating an example process for generating inferences of a user profile with elevated performance at an MPC cluster.
FIG. 9 is a flow diagram illustrating an example process for preparing and performing training of a second machine learning model for boosting inference performance at an MPC cluster.
FIG. 10 is a conceptual diagram of an exemplary framework for evaluating performance of a first machine learning model.
FIG. 11 is a flow diagram illustrating an example process for evaluating performance of a first machine learning model at an MPC cluster.
FIG. 12 is a flow diagram illustrating an example process for generating inferences of a user profile with increased performance at a computing system of an MPC cluster.
FIG. 13 is a block diagram of an example computer system.
Like reference numbers and designations in the various drawings indicate like elements.
Detailed Description
In general, this document describes systems and techniques for training and using machine learning models to extend user group membership while protecting user privacy and ensuring data security. Typically, rather than creating and maintaining a user profile at a computing system of another entity, such as a content platform, the user profile is maintained at the user's client device. To train the machine learning model, a user's client device can optionally send its encrypted user profile (e.g., as a secret share of the user profile) along with other data to multiple computing systems of a secure multi-party computing (MPC) cluster via a content platform. For example, each client device can generate two or more secret shares of the user profile and send the respective secret shares to each computing system. The computing systems of the MPC cluster can use MPC techniques to train the machine learning model for suggesting user groups for the user based on the user's profile in a manner that prevents any computing system of the MPC cluster (or another party other than the user itself) from obtaining any user profile in the clear, thereby protecting user privacy. For example, using the secret shares and MPC techniques described in this document enables machine learning models to be trained and used, while user profile data for each user is always encrypted when the data is external to the user's device. The machine learning model can be a k-nearest neighbor (k-NN) model.
After the machine learning model is trained, the machine learning model can be used to suggest one or more user groups for each user based on the user's profile. For example, a user's client device can query the MPC cluster for a group of users suggested for that user, or determine whether a user should be added to a particular group of users. Various inference techniques, such as binary classification, regression (e.g., using arithmetic mean or root mean square), and/or multi-class classification can be used to identify groups of users. User group membership of a user can be used in a privacy-preserving and secure manner to provide content to the user.
Example System for generating and Using machine learning models
FIG. 1 is a block diagram of an environment 100 in which a secure MPC 130 cluster trains machine learning models and machine learning models to be used to extend user groups. The example environment 100 includes a data communication network 105, such as a Local Area Network (LAN), a Wide Area Network (WAN), the internet, a mobile network, or a combination thereof. Network 105 connects client devices 110, secure MPC cluster 130, publisher 140, website 142, and content platform 150. Example environment 100 may include many different client devices 110, secure MPC clusters 130, publishers 140, websites 142, and content platforms 150.
The client device 110 is an electronic device capable of communicating over the network 105. Example client devices 110 include personal computers, mobile communication devices (e.g., smart phones), and other devices capable of sending and receiving data over the network 105. The client device can also include a digital assistant device that accepts audio input through a microphone and outputs audio output through a speaker. When the digital assistant detects a "hot word" or "hot phrase" that activates the microphone to accept audio input, the digital assistant can be placed in a listening mode (e.g., ready to accept audio input). The digital assistant device can also include a camera and/or a display to capture images and visually present information. The digital assistant can be implemented in different forms of hardware devices, including a wearable device (e.g., a watch or glasses), a smartphone, a speaker device, a tablet device, or another hardware device. The client devices can also include digital media devices, such as streaming devices that plug into a television or other display to stream video to the television, or gaming devices or consoles.
The client device 110 typically includes an application 112, such as a web browser and/or a native application, to facilitate sending and receiving data over the network 105. A native application is an application developed for a particular platform or a particular device (e.g., a mobile device with a particular operating system). The publisher 140 can develop and provide, for example, making a local application available for download to the client device 110. For example, in response to a user of the client device 110 entering a resource address of the resource 145 in an address bar of the web browser or selecting a link referencing the resource address, the web browser can request the resource 145 from a web server hosting the publisher's 140 website 142. Similarly, the native application can request application content from a publisher's remote server.
Some resources, application pages, or other application content can include digital component slots for presenting the resources 145 or application pages to digital components. As used throughout this document, the phrase "digital component" refers to a discrete unit of digital content or digital information (e.g., a video clip, an audio clip, a multimedia clip, an image, text, or another unit of content). The digital components can be electronically stored in the physical memory device as a single file or collection of files, and the digital components can take the form of video files, audio files, multimedia files, image files, or text files, and include advertising information such that the advertisement is one type of digital component. For example, the digital component may be content intended to supplement a web page or other resource presented by the application 112. More specifically, the digital components may include digital content related to resource content (e.g., the digital components may be related to the same subject matter as the web page content, or related to a related subject matter). Thus, the provision of digital components can supplement and enhance web page or application content as a whole.
When application 112 loads a resource (or application content) that includes one or more slots for digital components, application 112 can request digital components for each slot. In some implementations, the digital component slot can include code (e.g., script) that causes the application 112 to request the digital component from a digital component distribution system that selects the digital component and provides the digital component to the application 112 for presentation to a user of the client device 110.
The content platform 150 can include a Supply Side Platform (SSP) and a demand side platform (SSP). In general, the content platform 150 manages the selection and distribution of digital components on behalf of the publishers 140 and digital component providers 160.
Some publishers 140 use SSPs to manage the process of obtaining digital components for their digital component slots of resources and/or applications. SSPs are technical platforms implemented as hardware and/or software that automate the process of obtaining digital components of resources and/or applications. Each publisher 140 can have a corresponding SSP or SSPs. Some publishers 140 may use the same SSP.
The digital component provider 160 can create (or otherwise publish) digital components that are presented in digital component slots of publishers' resources and applications. The digital component provider 160 can use the DSP to manage the provisioning of its digital components for presentation in the digital component slots. A DSP is a technical platform implemented in hardware and/or software that will distribute digital components for process automation presented with resources and/or applications. The DSP can interact with multiple supply side platforms SSP on behalf of a digital component provider 160 to provide digital components for presentation with multiple different publisher 140 resources and/or applications. In general, the DSP is capable of receiving a request for a digital component (e.g., from the SSP), generating (or selecting) selection parameters for one or more digital components created by one or more digital component providers based on the request, and providing data and the selection parameters related to the digital component (e.g., the digital component itself) to the SSP. The SSP can then select a digital component for presentation at the client device 110 and provide the client device 110 with data that causes the client device 110 to present the digital component.
In some cases, it may be beneficial for a user to receive digital components related to web pages, application pages, or other electronic resources that the user previously accessed and/or interacted with. To distribute such digital components to users, users can be assigned to groups of users, e.g., groups of user interests, groups of similar users, or other group types involving similar user data. For example, a user can be assigned to a user interest group when the user accesses a particular resource or performs a particular action at the resource (e.g., interacts with a particular item presented on a web page or adds an item to a virtual shopping cart). In another example, users can be assigned to groups of users based on a history of activities, e.g., a history of resources accessed and/or actions performed at the resources. In some implementations, the user group can be generated by the digital component provider 160. That is, each digital component provider 160 can assign users to their group of users when the users access electronic resources of the digital component provider 160.
To protect user privacy, group memberships for a user can be maintained at the user's client device 110, e.g., through one of the applications 112 or the operating system of the client device 110, rather than through a digital component provider, content platform, or other party. In a particular example, a trusted program (e.g., a web browser) or operating system can maintain a list of user group identifiers ("user group list") for a user using the web browser or another application. The user group list can comprise a group identifier for each user group to which the user has been added. The digital component provider 160 that creates the user group can specify the user group identifier for its user group. The user group identifier of the user group can describe the group (e.g. a gardening group) or a code (e.g. a non-descriptive alphanumeric sequence) representing the group. The user group list of the user can be stored in a secure storage at the client device 110 and/or can be encrypted at the time of storage to prevent others from accessing the list.
When the application 112 presents resources or application content related to the digital component provider 160 or a web page on the website 142, the resource can request that the application 112 add one or more user group identifiers to the user group list. In response, the application 112 can add one or more user group identifiers to the user group list and securely store the user group list.
The content platform 150 can use the user group membership of the user to select digital components or other content that may be of interest to the user or that may be beneficial to the user/user device in another manner. For example, such digital components or other content may include data that improves the user experience, improves the operation of the user device, or benefits the user or user device in some other manner. However, the user group identifier of the user's user group list can be provided in a manner that prevents the content platform 150 from associating the user group identifier with a particular user, thereby protecting user privacy when using the user group member data to select digital components.
The application 112 can provide the user group identifier from the user group list to a trusted computing system that interacts with the content platform 150 to select a digital component for presentation at the client device 110 based on user group membership in a manner that prevents the content platform 150 or any other entity that is not the user itself from knowing the user's full user group membership.
In some cases, it may be beneficial for users and digital component providers to extend a user group to include users with similar interests or other similar data as users who are already members of the user group.
Advantageously, users can be added to a group of users without using third party cookies. As described above, the user profile can be maintained at the client device 110. This protects user privacy by eliminating the user's cross-domain browsing history to be shared with external parties, reduces bandwidth consumed by transmitting cookies over the network 105 (which is quite large aggregated over millions of users), reduces storage requirements of the content platform 150 that typically stores such information, and reduces battery consumption used by the client device 110 to maintain and transmit cookies.
For example, the first user may be interested in skiing and may be a member of a user group of a particular ski field. The second user may also be interested in skiing, but is not aware of this ski field and is not a member of the ski field. If two users have similar interests or data, e.g., similar user profiles, the second user may be added to a group of users of the ski field, such that the second user receives content, e.g., digital components, that is relevant to the ski field and that may be of interest or otherwise beneficial to the second user or their user device. In other words, the user group may be expanded to include other users with similar user data.
The secure MPC cluster 130 can train a machine learning model that suggests user groups to the user (or its application 112) based on the user's profile, or can be used to generate suggestions of user groups. Secure MPC cluster 130 includes two computing systems MPCs 1 And MPC 2 Which executes secure MPC techniques to train machine learning models. Although the example MPC cluster 130 includes two computing systems, more computing systems can be used as long as the MPC cluster 130 includes more than one computing system. For example, the MPC cluster 130 can include three computing systems, four computing systems, or other suitable number of computing systems. The use of more computing systems in the MPC cluster 130 can provide more security and fault tolerance, but can also increase the complexity of the MPC process.
Computing system MPC 1 And MPC 2 Can be operated by different entities. As such, each entity may not have access to the full user profile in the clear. Plaintext is text that has not been computationally marked, specially formatted, or written in code or data (including binary files) in a form that can be viewed or used without being representedA key or other decryption device or other decryption process is required. For example, a computing system MPC 1 Or MPC 2 Can be operated by a trusted party other than the user, publisher 140, content platform 150, and digital component provider 160. For example, an industry group, government group, or browser developer may maintain and operate a computing system MPC 1 And MPC 2 One of them. Other computing systems may be operated by different ones of these groups, such that different trusted parties operate each computing system MPC 1 And MPC 2 . Preferably, the MPC of the different computing systems is operated 1 And MPC 2 Without the incentive to collude to compromise the privacy of the user. In some embodiments, a computing system MPC 1 And MPC 2 Are architecturally separated and are monitored so as not to communicate with each other outside of performing the secure MPC process described in this document.
In some embodiments, the MPC cluster 130 trains one or more k-NN models for each content platform 150 and/or for each digital component provider 160. For example, each content platform 150 can manage the distribution of digital components of one or more digital component providers 160. The content platform 150 may request the MPC cluster 130 to train the k-NN model of one or more digital component providers 160 for the content platform 150 to manage the distribution of its digital components. In general, the k-NN model represents the distance between the user profiles (and optionally additional information) of a set of users. Each k-NN model of a content platform can have a unique model identifier. An example process for training the k-NN model is illustrated in FIG. 4 and described below.
After training the k-NN model for the content platform 150, the content platform 150 may query the k-NN model or cause the application 112 of the client device 110 to query the k-NN model to identify one or more user groups for the user of the client device 110. For example, the content platform 150 can query the k-NN model to determine whether a threshold number "k" of user profiles that are closest to the user are members of a particular user group. If so, the content platform 150 may add the user to the group of users. If a user group is identified for the user, content platform 150 or MPC cluster 130 can request application 112 to add the user to the user group. If approved by the user and/or the application 112, the application 112 may add the user group identifier for the user group to a list of user groups stored at the client device 110.
In some implementations, the application 112 can provide a user interface that enables a user to manage the group of users to which the user is assigned. For example, the user interface can enable the user to remove the user group identifier, preventing all or a particular resource 145, publisher 140, content platform 150, digital component provider 160, and/or MPC cluster 130 from adding the user to the user group (e.g., preventing an entity from adding the user group identifier to a list of user group identifiers maintained by the application 112). This provides better transparency, selection/consent and control for the user.
In addition to the description throughout this document, a user may be provided with controls (e.g., user interface elements with which the user is able to interact) allowing the user to make selections as to whether and when the systems, programs, or features described herein may enable the collection of user information (e.g., information about the user's social network, social actions or activities, profession, the user's preferences, or the user's current location), and whether the user is sent content or communications from a server. In addition, certain data may be processed in one or more ways before it is stored or used, so that personally identifiable information is removed. For example, the identity of the user may be processed such that personally identifiable information cannot be determined for the user, or the geographic location of the user may be generalized (such as to a city, zip code, or state level) where location information is obtained such that a particular location of the user cannot be determined. Thus, the user may have control over what information is collected about the user, how the information is used, and what information is provided to the user.
Example Process for generating and Using machine learning models
FIG. 2 is a swim lane diagram of an example process 200 for training a machine learning model and adding a user to a user group using the machine learning model. The operation of the process 200 can be performed, for example, by the client device 110, the MPC cluster 130 MPC of computing system 1 And MPC 2 And a content platform 150. The operations of process 200 can also be implemented as instructions stored on one or more computer-readable media, which may be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of process 200. Although the process 200 and other processes below are described in terms of two computing system MPC clusters 130, MPC clusters having more than two computing systems can also be used to perform similar processes.
The content platform 150 can initiate training and/or updating of one of its machine learning models by requesting that the applications 112 running on the client devices 110 generate user profiles for their respective users and upload secret shares and/or encrypted versions of the user profiles to the MPC cluster 130. For the purposes of this document, a secret share of a user profile can be considered an encrypted version of the user profile because the secret share is not in the clear. Upon generation, each application 112 can store data of a user profile and generate an updated user profile in response to receiving a request from the content platform 150. Since the content and machine learning models of a user profile differ for different content platforms 150, the application 112 running on the user's client device 110 is able to maintain data for multiple user profiles, and generate multiple user profiles, each user profile being specific to a particular content platform or a particular model owned by a particular content platform.
The application 112 running on the client device 110 builds a user profile for the user of the client device 110 (step 202). The user profile of the user can include data related to events initiated by the user and/or events that may have been initiated by the user with respect to an electronic resource (e.g., web page or application content). The event can include a view of the electronic resource, a view of the digital component, a user interaction, or a lack of user interaction with the electronic resource or the digital component (e.g., a selection of the electronic resource or the digital component), a transition that occurs after the user interacts with the electronic resource, and/or other suitable events related to the user and the electronic resource.
The user profile of the user can be specific to the content platform 150 or a selected machine learning model owned by the content platform 150. For example, as described in more detail below with reference to fig. 3, each content platform 150 can request that the application 112 generate or update a user profile specific to that content platform 150.
The user profile of the user can be in the form of a feature vector. For example, the user profile may be an n-dimensional feature vector. Each of the n dimensions can correspond to a particular feature, and the value of each dimension can be a value of a feature of the user. For example, one dimension may be directed to whether a particular digital component is presented to (or interacts with) a user. In this example, the value of the feature may be "1" if the digital component is presented to (or interacts with) the user, or "0" if the digital component has not been presented to (or interacted with) the user. An example process for generating a user profile for a user is illustrated in fig. 3 and described below.
In some implementations, content platform 150 may want to train a machine learning model based on additional signals, such as contextual signals, signals related to particular digital components, or signals related to a user that application 112 may not be aware of or that application 112 may not have access to, such as the current weather at the user's location. For example, the content platform 150 may want to train the machine learning model to predict whether a user will interact with a particular digital component if the digital component is presented to the user in a particular context. In this example, for each presentation of a digital component to the user, the context signals can include the geographic location of the client device 110 at the time (if permission was granted by the user), a signal describing the content of the electronic resource presenting the digital component, and a signal describing the digital component, e.g., the content of the digital component, the type of the digital component, where on the electronic resource the digital component was presented, etc. In another example, one dimension may be for whether a digital component presented to a user is of a particular type. In this example, the value may be 1 for travel, 2 for cooking, 3 for movie, etc. For convenience of subsequent description, P i Will represent the user profile and the ith userBoth additional signals associated with the profile (e.g., context signals and/or digital component level signals).
In some embodiments, the application 112 can also provide one or more tags to the MPC cluster 130. While the labels may not be used to train a particular architecture machine learning model (e.g., k-NN), the labels can be used to fine-tune hyper-parameters (e.g., the value of k) that control the model training process, or to evaluate the quality of the trained machine learning model, or to make predictions, i.e., to determine whether to suggest user groups for the user. The tags can include, for example, one or more of the user group identifiers for the user and accessible to the content platform 150. That is, the tag can include a user group for management by the content platform 150 or a user group identifier that the content platform 150 can read access to. In some embodiments, a single tag includes multiple user group identifiers for a user. In some embodiments, the tags of the users can be heterogeneous and include all user groups including users as members and additional information, e.g., whether the user interacts with a given digital component. This enables the k-NN model to be used to predict whether another user will interact with a given digital component. The tags of each user profile can indicate user group membership of the user corresponding to the user profile.
The tags of the user profile predict a group of users to which the user corresponding to the input will be or should be added. For example, the labels of the k nearest neighbor user profiles corresponding to the input user profile predict a user group that a user corresponding to the input user profile will join or should join, e.g., based on similarities between the user profiles. These predictive tags can be used to suggest a group of users to the user or to request that the application add the user to the group of users corresponding to the tag.
If tags are included, the application 112 can also associate each label with i Divided into a plurality of shares, e.g. [ label ] i，1 ]And [ label i，2 ]. Thus, in a computing system MPC 1 And MPC 2 Without collusion between them, computing system MPC 1 And MPC 2 Can not be driven from [ P ] i，1 ]Or [ P i，2 ]Reconstruction of P i Or from [ label i，1 ]Or [ label i，2 ]Reconstructed label i 。
The content platform 150 can receive shares of the user profile and shares of the tags from a plurality of client devices. Content platform 150 can upload shares of a user profile to computing system MPC 1 And MPC 2 To initiate training of the machine learning model. Although the tags may not be used in the training process, content platform 150 can upload the share of the tags to computing system MPC 1 And MPC 2 For use in later evaluation of model quality or querying of the model.
The content platform 150 encrypts the first encrypted share (e.g., PubKeyEncrypt ([ P ]) received from each client device 110 i，1 ]||[label i，1 ]，MPC 1 ) Upload to computing System MPC 1 (step 210). Similarly, the content platform 150 encrypts a second encrypted share (e.g., PubKeyEncrypt ([ P ]) i，2 ]||[label i，2 ]，MPC 2 ) Upload to computing System MPC 2 (step 212). The two uploads can be batch-wise and can include encrypted shares of the user profile and the label received during a particular time period for training the machine learning model.
In some implementations, content platform 150 uploads the first encrypted share to computing system MPC 1 Must be in order with content platform 150 to upload the second encrypted share to computing system MPC 2 Are matched. This enables a computing system MPC 1 And MPC 2 Two shares of the same secret, e.g. two shares of the same user profile, can be correctly matched.
In some implementations, the content platform 150 can explicitly assign the same pseudo-random or sequentially generated identifier to shares of the same secret to facilitate matching. While some MPC techniques can rely on random shuffling of inputs or intermediate results, MPC techniques described in this document may not include such random shuffling and may instead rely on an upload order to match.
In some implementations, operations 208, 210, and 212 can be performed by application 112 in which [ P ] is to be performed i，1 ]||[label i，1 ]Direct upload to MPC 1 And will [ P i，2 ]||[label i，2 ]To MPC 2 Alternative processes of (2) instead. This alternative process can reduce the architectural cost of the content platform 150 to support the operations 208, 210, and 212, and reduce the need to start training or updating the MPC 1 And MPC 2 The time delay of the machine learning model in (1). For example, this eliminates the transmission of data to the content platform 150, which the content platform 150 then transmits to the MPC 1 And MPC 2 . Doing so reduces the amount of data transferred over the network 105 and reduces the complexity of the logic of the content platform 150 in processing such data.
Computing system MPC 1 And MPC 2 A machine learning model is generated (step 214). Each generation of a new machine learning model based on user profile data can be referred to as a training session. Computing system MPC 1 And MPC 2 The machine learning model can be trained based on the encrypted shares of the user profile received from the client device 110. For example, a computing system MPC 1 And MPC 2 The k-NN model can be trained based on the share of the user profile using MPC techniques.
To minimize or at least reduce cryptographic computations, and thus placement at a computing system MPC during both model training and inference to protect user privacy and data 1 And MPC 2 With computational burden, the MPC cluster 130 can quickly, safely and probabilistically quantify the two user profiles P using a stochastic projection technique, such as SimHash i And P j The similarity between them. SimHash is a rapidTechniques to estimate similarity between two data sets. Two user profiles P i And P j Similarity between them can be determined by determining a profile representing two user profiles P i And P j Is determined, the Hamming distance high probability being inversely proportional to the cosine distance between the two user profiles.
Conceptually, for each training session, m random projection hyperplanes U ═ U can be generated 1 ，U 2 ，...，U m }. The random projection hyperplane can also be referred to as a random projection plane. Computing system MPC 1 And MPC 2 One purpose of the multi-step computation in between is for each user profile P used in the training of the k-NN model i Creating a bit vector B of length m i . At the bit vector B i In each bit B i，j Representing projection plane U j And a user profile P i I.e. for all j e 1, m]，B i，j ＝sign(U j ⊙P i ) Wherein, a indicates the dot product of two vectors of equal length. I.e. each bit represents a user profile P i Lying in a plane U j Which side of the frame. Bit value 1 represents a positive sign and bit value 0 represents a negative sign.
At each end of a multi-step computation, two computing systems MPC 1 And MPC 2 Each of which generates an intermediate result comprising a bit vector of each user profile in clear text, a share of each user profile, and a share of a label of each user profile. For example, a computing system MPC 1 The intermediate results of (a) can be the data shown in table 1 below. Computing system MPC 2 There will be similar intermediate results but with different shares per user profile and per label. To add additional privacy protection, each of the two servers in the MPC cluster 130 can only get half of the m-dimensional bit vector in the clear, e.g., computing system MPC 1 Obtaining the first m/2-dimension of all m-dimension bit vectors, calculating the MPC of the system 2 The second m/2-dimension of all m-dimension bit vectors is obtained.
TABLE 1
Bit vector in plaintext form | For P i MPC of 1 Portion(s) of | For label i MPC of 1 Portion(s) of |
... | ... | ... |
B i | ... | ... |
B i+1 | ... | ... |
... | ... | ... |
Given two arbitrary user profile vectors P of unit length i ≠ j i And P j It has been shown that two user profile vectors P, provided that the number m of random projections is sufficiently large i And P j Bit vector B of i And B j Hamming distance between high probability and user profile vector P i And P j The cosine distance between them is proportional.
Based on the intermediate results shown above, and because of the bit vector B i Is plain text, each computing system MPC 1 And MPC 2 The respective k-NN models can be independently created using the k-NN algorithm, for example, by training. Computing system MPC 1 And MPC 2 The same or different k-NN algorithms can be used. An example process for training the k-NN model is illustrated in FIG. 4 and described below. Once the k-NN model is trained, the application 112 can query the k-NN model to determine whether to add the user to the user group.
The application 112 submits an inference request to the MPC cluster 130 (step 216). In this example, application 112 communicates an inference request to computing system MPC 1 . In other examples, application 112 can communicate an inference request to computing system MPC 2 . The application 112 can submit the inference request in response to a request from the content platform 150 to submit the inference request. For example, the content platform 150 can request that the application 112 query the k-NN model to determine whether the user of the client device 110 should be added to a particular user group. This request can be referred to as an inference request to infer whether the user should be added to a group of users.
To initiate an inference request, content platform 150 can send an inference request token M to application 112 infer . Inference request token M infer Enabling servers in the MPC cluster 130 to verify that the application 112 is authorized to query a particular machine-learning model owned by a particular domain. If the model access control is optional, infer the request token M infer Is optional. Inference request token M infer Can have the following items shown and described in table 2 below.
TABLE 2
In this example, the inference request token M infer Including seven items and a digital signature generated based on the seven items using the private key of the content platform 150. eTLD + 1 is the effective top field (eTLD) over the common suffix plus one level. Example eTLD +1 is "example.com", where ". com" is the top level domain.
To is coming toRequesting inferences for a particular user, the content platform 150 can generate an inference request token M infer And sends the token to the application 112 running on the user's client device 110. In some implementations, the content platform 150 uses the public key pair inference request token M of the application 112 infer Encryption is performed so that only the application 112 can use its secret private key corresponding to the public key to deduce the request token M infer Decryption is performed. That is, the content platform can send PubKeyEnc (M) to the application 112 infer ，application_public_key)。
Conceptually, the inference request can include a model identifier of the machine learning model, the current user profile P i K (number of nearest neighbors to extract), optionally additional signals (e.g., context signals or digital component signals), aggregation functions, and aggregation function parameters. However, to prevent the clear form of the user profile P i Leakage to computing system MPC 1 Or MPC 2 And thus protecting user privacy, the application 112 can profile the user P i Split into separate for MPC 1 And MPC 2 Two shares of [ P ] i，1 ]And [ P i，2 ]. The application 112 can then select, e.g., randomly or pseudo-randomly, two computing system MPCs 1 Or MPC 2 For querying. If application 112 selects computing system MPC 1 Then the application 112 can then send the MPC to the computing system 1 Sending with first quota P i，1 ]And a second fractionEncrypted version of (e.g., PubKeyEncrypt ([ P ]) i，2 ]，MPC 2 ) A single request for the content of the content. In this example, application 112 uses a computing system MPC 2 To encrypt the second share P i，2 ]To prevent computing system MPC 1 Access [ P ] i ，2]This will enable the computing system MPC 1 Can be according to [ P i，1 ]And [ P i，2 ]To reconstruct the user profile P i 。
As described in more detail below, a computing system MPC 1 And MPC 2 Cooperatively computing k with a user profile P i The nearest neighbors. Computing system MPC 1 And MPC 2 One of several possible machine learning techniques (e.g., binary classification, multi-class classification, regression, etc.) can then be used to determine whether to add the user to the user group based on the k nearest neighbor user profiles. For example, the aggregation function can identify machine learning techniques (e.g., binary, multi-class, regression), and the aggregation function parameters can be based on the aggregation function. The aggregation function can define a calculation, e.g., a sum, a logical AND OR, OR another suitable function that is performed using the parameters. For example, the aggregation function can be in the form of an equation that includes the function and parameters used in the equation.
In some implementations, the aggregation function parameters can include a user group identifier for the user group for which the content platform 150 is querying the k-NN model. For example, the content platform 150 may want to know whether to add a user to a user group that is related to hiking and has a user group identifier "hiking". In this example, the aggregation function parameters can include a "hiking" user group identifier. Generally speaking, computing system MPC 1 And MPC 2 Whether to add a user to a user group can be determined based on the number of k nearest neighbors that are members of the user group, e.g., based on their labels.
The MPC cluster 130 provides the inference to the application 112 (step 218). In this example, a computing system MPC receiving a query 1 The inference is sent to application 112. The inference results can indicate whether the application 112 should add the user to zero or moreA group of users. For example, the user group result can specify a user group identifier for the user group. However, in this example, computing system MPC 1 The user group will be known. To prevent this, the computing system MPC 1 The share of the inference result can be calculated and the system MPC calculated 2 Another share of the same inference result can be computed. Computing system MPC 2 Capable of providing an encrypted version of its share to a computing system MPC 1 Where the share is encrypted using the public key of the application 112. Computing system MPC 1 Capable of providing computing system MPC to application 112 1 Computing system MPC for quotients of inference results and user group results 2 An encrypted version of the share of (a). Application 112 is capable of decrypting computing system MPC 2 And calculating an inference result from the two shares. An example process for querying the k-NN model to determine whether to add a user to a user group is illustrated in FIG. 5 and described below. In some embodiments, to prevent computing system MPC 1 Counterfeit computing system MPC 2 Computing the system MPC 2 The results of the application 112 are digitally signed before or after encrypting the results using their public key. Application 112 uses MPC 2 To verify a computing system MPC 2 The digital signature of (1).
The content platform 150 transmits the content to the application 112 (step 224). For example, the content platform 150 can select a digital component based on the user group identifier and provide the digital component to the application 112. In some implementations, the content platform 150 cooperates with the application 112 to select the digital component based on the user group identifier without revealing the user group identifier outside of the application 112.
The application 112 displays or otherwise implements the received content (step 226). For example, the application 112 can display the received digital component in a digital component slot of the electronic resource.
Example Process for generating a user Profile
Fig. 3 is a flow diagram illustrating an example process 300 for generating a user profile and sending a share of the user profile to an MPC cluster. The operations of process 300 can be implemented, for example, by client device 110 of fig. 1, for example, by application 112 running on client device 110. The operations of process 300 can also be implemented as instructions stored on one or more computer-readable media, which may be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of process 300.
The application 112 executing on the user's client device 110 receives data for the event (step 302). An event can be, for example, a presentation of an electronic resource at client device 110, a presentation of a digital component at client device 110, a user interaction with an electronic resource or digital component at client device 110, or a transformation of a digital component, or a lack of user interaction or transformation with a presented electronic resource or digital component. When an event occurs, the content platform 150 can provide data related to the event to the application 112 for generating a user profile for the user.
The application 112 can generate a different user profile for each content platform 150. That is, a user profile for a user and for a particular content platform 150 may only include event data received from the particular content platform 150. This protects user privacy by not sharing data related to events of other content platforms with the content platform. In some implementations, the application 112 can generate a different user profile for each machine learning model owned by the content platform 150 at the request of the content platform 150. Different machine learning models may require different training data based on design goals. For example, the first model may be used to determine whether to add a user to a group of users. The second model may be used to predict whether the user will interact with the digital component. In this example, the user profile of the second model can include additional data that the user profile of the first model does not have, e.g., whether the user interacted with the digital component.
TABLE 3
The model identifiers identify machine learning models, e.g., k-NN models, that the user profile is to be used to train or to make user group inferences. A profile record is an n-dimensional feature vector that includes event-specific data, such as the type of event, electronic resources or digital components, the time at which the event occurred, and/or other suitable event data that the content platform 150 wishes to use in training the machine learning model and making user group inferences. A digital signature is generated based on the seven items using a private key of the content platform 150.
In some embodiments, to protect the update token M during transmission update The content platform 150 is updating the token M update Updates before sending to application 112Token M update Encryption is performed. For example, the content platform 150 can use a public key of an application, e.g., PubKeyEnc (M) update Application _ public _ key) to encrypt the update token M update 。
In some implementations, the content platform 150 can send the event data to the application 112 without encoding the event data or the update request in the form of a profile update token, Mupdate. For example, scripts originating from the content platform 150 running inside the application 112 may directly communicate event data and update requests to the application 112 via a scripting API, where the application 112 relies on the world Wide Web Consortium (W3C) origin-based security model and/or (HyperText transfer protocol secure) HTTPS to protect the event data and update requests from forgery or leakage.
The application 112 stores data for the event (step 304). If the event data is encrypted, the application 112 can decrypt the event data using its private key, which corresponds to the public key used to encrypt the event data. If so, to update the token M update The application 112 can verify the update token M before storing the event data update . The application 112 is able to verify the update token M by update : (i) verify the digital signature using a public key of the content platform 150 corresponding to a private key of the content platform 150 used to generate the digital signature, and (ii) ensure that the token creation timestamp is not stale, e.g., the time indicated by the timestamp is within a threshold amount of time of the current time at which verification is occurring. If the token M is updated update Valid, the application 112 can store the event data, for example, by storing an n-dimensional profile record. If any of the verifications fail, the application 112 may ignore the update request, for example, by not storing the event data.
For each machine learning model, for example, for each unique model identifier, the application 112 can store event data for that model. For example, the application 112 can maintain a data structure comprising a set of n-dimensional feature vectors (e.g., a profile record of an update token) for each unique model identifier and an expiration time for each feature vector. Each feature vector can include feature values for features related to events of the user of the client device 110. An example data structure for the model identifier is shown in Table 4 below.
TABLE 4
Feature vector | Expiration date |
n-dimensional feature vector | Time of expiry |
... | ... |
Upon receipt of a valid update token M update Application 112 can update token M update Is added to the data structure to update the update token M included in the update token update The data structure of the model identifier in (1). The application 112 can periodically clear expired feature vectors from the data structure to reduce the storage size.
The application 112 determines whether to generate a user profile (step 306). For example, the application 112 may generate a user profile for a particular machine learning model in response to a request from the content platform 150. The request may be to generate a user profile and return the share of the user profile to the content platform 150. In some implementations, the application 112 may upload the generated user profiles directly to the MPC cluster 130, e.g., rather than sending them to the content platform 150. To ensure security of requests to generate and return shares of a user profile, the content platform 150 can send an upload token M to the application 112 upload 。
Upload token M upload Can have and update token M update Similar structure, but with different operations (e.g., "update server" instead of "accumulate user profile"). Upload token M upload Additional terms for operation delay can also be included. The operational delay can indicate that the application 112 delays calculating and uploading shares of the user profile while the application 112 accumulates more event data, e.g., more feature vectors. This enables the machine learning model to capture user event data immediately before and after certain key events, for example, joining a user group. The operation delay can specify a delay period. In this example, the digital signature can be generated based on the other seven items and operational delays in table 3 using the private key of the content platform. The content platform 150 can use the public key of the application to update the token M update Similar manner encrypts the upload token M upload (e.g., PubKeyEnc (M) upload Application _ public _ key)) to protect the upload token M during transmission upload 。
In some implementations, the content platform 150 can request the application 112 to upload the user profile without uploading the token M with the profile upload Encodes the upload request. For example, a script originating from a content platform 150 running within the application 115 may be via the script API directly communicates the upload request to application 115, where application 115 relies on W3C to protect the upload request from forgery or leakage based on the security model of the source and/or HTTPS.
If it is determined that a user profile is not to be generated, the process 300 can return to operation 302 and wait for additional event data from the content platform 150. If it is determined that a user profile is generated, the application 112 generates a user profile (step 308).
In some implementations, the decay rate can be used to calculate a user profile. Since there may be many content platforms 150 that use MPC cluster 130 to train machine learning models and each content platform 150 may have multiple machine learning models, storing user feature vector data may result in significant data storage requirements. Using the decay technique can significantly reduce the amount of data stored at each client device 110 for the purpose of generating a user profile for training the machine learning model.
Suppose that, for a given machine learning model, there are k feature vectors { F } 1 ，F 2 ，...F k Are each an n-dimensional vector and their corresponding ages (records _ age _ in _ seconds) i ). The application 112 can calculate the user profile using the following relationship 1:
relation 1:client device 110, and the parameter decay _ rate _ in _ seconds is the decay rate of the profile record (e.g., accommodated in the update token M) in seconds update Item 6) of (4). Thus, the most recent feature vector carries more weight. This also enables the application 112 to avoid storing feature vectors and to store profile records only in constant storage. The application 112 only has to store the n-dimensional vector P and the timestamp user profile time for each model identifier, instead of multiple individual feature vectors for each model identifier. This significantly reduces the amount of data that must be stored at the client device 110, many client devices typically having limited data storage capacity.
To initialize the n-dimensional vector user profile P and timestamps, an application can set the vector P to an n-dimensional vector with each dimension having a value of zero and the user _ profile _ time to an epoch (epoch). In order to utilize the new feature vector F at any time x Updating the user profile P, the application 112 can use the following relationship 2:
the application 112 is also able to update the user profile time to the current time (current _ time) when updating the user profile with relation 2. Note that if application 112 calculates a user profile using the decay rate algorithm described above, operations 304 and 308 are omitted.
The application 112 generates shares of the user profile (step 310). The application 112 can use a pseudo-random function to profile the user P i (e.g., an n-dimensional vector P) is partitioned into a plurality of shares. That is, application 112 can use a pseudo-random function PRF (P) i ) Generating a user profile P i Two shares of { [ P ] i，1 ]，[P i，2 ]}. The exact segmentation can depend on the application 112A secret shared share algorithm and a cryptographic library are used. In some embodiments, the application uses Shamir's secret share scheme. If one or more shares of tags are provided, the application 112 can also generate a share of tags.
Example Process for generating and Using machine learning models
FIG. 4 is a flow diagram illustrating an example process 400 for generating a machine learning model. The operations of process 400 can be implemented, for example, by MPC cluster 130 of fig. 1. The operations of process 400 can also be implemented as instructions stored on one or more computer-readable media, which may be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of process 400.
The MPC cluster 130 obtains a share of the user profile (step 402). The content platform 150 can request the MPC cluster 130 to train the machine learning model by transmitting a share of the user profile to the MPC cluster 130. The content platform 150 can access encrypted shares for the machine learning model received from the client devices 110 over a given period of time and upload those shares to the MPC cluster 130.
For example, content platform 150 can send a MPC to a computing system 1 Transmitting encrypted first shares of user profiles and each user profile P i Its encrypted first share of the tag (e.g., PubKeyEncrypt ([ P ]) i，1 ]||[label i，1 ]，MPC 1 ). Similarly, content platform 150 can send a MPC to a computing system 2 Transmitting encrypted second shares of user profiles and each user profile P i Of its tag (e.g., PubKeyEncrypt ([ P ]) i，2 ]||[label i，2 ]，MPC 2 )。
In some implementations where the application 112 sends the MPC cluster 130 a secret share of the user profile directly, the content platform 150 can request the MPC cluster 130 to train the machine learning model by communicating a training request to the MPC cluster 130.
Computing system MPC 1 And MPC 2 A random projection plane is created (step 404). Computing system MPC 1 And MPC 2 Can collaboratively create m random projection planes U ═ { U ═ U 1 ，U 2 ，...，U m }. These random projection planes should be kept to two computing systems MPC 1 And MPC 2 Secret share between. In some embodiments, a computing system MPC 1 And MPC 2 Random projection planes are created and their secrecy is maintained using the Diffie-Hellman key exchange technique.
As described in more detail below, a computing system MPC 1 And MPC 2 Their share of each user profile is projected onto each random projection plane and for each random projection plane it is determined whether the share of the user profile is on one side of the random projection plane. MPC for each computing system 1 And MPC 2 The bit vectors in the secret shares can then be constructed from the secret shares of the user profile based on the results of each random projection. Partial knowledge of the user's bit vector, e.g. user profile P i Whether or not in the projection plane U k To allow computing system MPC 1 Or MPC 2 Obtain information about P i Some knowledge of the distribution of (a), relative to the user profile P i The prior knowledge of having a unit length is increasing. To prevent computing system MPC 1 And MPC 2 Gaining access to the information (e.g., in being hidden from the userIn embodiments where privacy and/or data security is desired or preferred), in some embodiments the random projection plane is in secret share, so the computing system MPC 1 And MPC 2 The random projection plane cannot be accessed in the clear. In other embodiments, a random bit flipping pattern can be applied on the random projection results using a secret shared share algorithm, as described in optional operations 406 and 408.
To demonstrate how to flip bits via secret shares, assume that there are two secrets x and y whose values are zero or one with equal probability. If y is 0, the equation operates [ x ]]＝＝[y]The bits of x will be flipped and if y ═ 1, the bits of x will be held. This operation can require two computing systems MPC 1 And MPC 2 Remote Procedure Calls (RPCs) in between, and the number of rounds depends on the data size and the secret shared share algorithm selected.
MPC for each computing system 1 And MPC 2 An m-dimensional vector of secrets is created (step 406). Computing system MPC 1 M-dimensional vector S that can create secrets 1 ，S 2 ，...S m H, each element S i With equal probability having a value of zero or one. Computing system MPC 1 Dividing its m-dimensional vector into two shares, the first share { [ S { [ 1，1 ]、[S 2，1 ]、...[S m，1 ]And a second share { [ S ] 1，2 ]、[S 2，1 ]、...[S m，2 ]}. Computing system MPC 1 Capable of keeping a first share secret and providing a second share to the computing system MPC 2 . Computing system MPC 1 The m-dimensional vector S can then be discarded 1 ，S 2 ，...S m }。
Computing system MPC 2 M-dimensional vector T capable of creating secrets 1 ，T 2 ，...T m H, each element T i Having a value of zero or one. Computing system MPC 2 Dividing its m-dimensional vector into two shares, the first share
Two computing systems MPC 1 And MPC 2 The share of the bit flipping pattern is calculated using secure MPC techniques (step 408). Computing system MPC 1 And MPC 2 Capable of utilizing a computing system MPC 1 And MPC 2 Multiple round trips in between use secret share MPC equality tests to compute the shares of the bit flip pattern. The bit flipping pattern can be based on the above operation [ x ] ]＝＝[y]. That is, the bit flip pattern can be { S } 1 ＝T 1 ，S 2 ＝T 2 ，...S m ＝T m }. Let each ST i ＝(S i ＝＝T i ). Each ST i Have a value of zero or one. After MPC operation is completed, computing system MPC 1 First share with bit flipping pattern { [ ST { [ 1，1 ]，[ST 2，1 ]，...[ST m，1 ]And computing the system MPC 2 Second share with bit flipping pattern { [ ST { [ 1，2 ]，[ST 2，2 ]，...[ST m，2 ]}. Each ST i Is used to make two computing systems MPC 1 And MPC 2 Can be applied to two computing systems MPC 1 And MPC 2 Any of which flip bits in the bit vector in an opaque manner.
Each computing system MPC 1 And MPC 2 Its share of each user profile is projected to each random projection plane (step 410). I.e. for computing systems MPC 1 Receiving each user profile of the share, computing the system MPC 1 Can reduce the share [ P ] i，1 ]Projected onto each projection plane U j The above. For each share of the user profile and for each random projection plane U j Performing this operation produces a matrix R of dimensions z x m, where z is the number of available user profiles and m is the number of random projection planes. Each element R in the matrix R i，j Can be calculated by projecting planesSide U j And fraction [ P i，1 ]By dot product of, e.g., R i，j ＝U j ⊙[P i，1 ]. Operation |, indicates the dot product of two vectors of equal length.
Computing system MPC if bit flipping is used 1 Can be used in a computing system MPC 1 And MPC 2 Bit flipping patterns shared in secrecy therebetween to modify one or more elements R in a matrix i，j The value of (c). For each element R in the matrix R i，j Computing system MPC 1 Can calculate [ ST j，1 ]＝＝sign(R i，j ) As the element R i，j The value of (c). Thus, if in bit flip mode, a bit is present
Similarly, for computing systems MPC 2 Receiving each user profile of the share, computing the system MPC 2 Can reduce the share [ P ] i，2 ]Projected onto each projection plane U j The above. For each share of the user profile and for each random projection plane U j Performing this operation produces a matrix R' in the dimension z × m, where z is the number of available user profiles and m is the number of random projection planes. Each element R in the matrix R i，j ' capable of calculating the projection plane U j And fraction [ P i，2 ]Dot product of, e.g., R' i，j ＝U j ⊙[P i，2 ]. Operation |, indicates the dot product of two vectors of equal length.
Computing system MPC if bit flipping is used 2 Can be used in a computing system MPC 1 And MPC 2 Bit flipping patterns secretly shared between to modify one or more elements R in a matrix i，j The value of. For each element R in the matrix R i，j ', computing system MPC 2 Can calculate [ ST j，2 ]＝＝sign(R i，j ') as element R i，j A value of. Thus, if in bit flip mode at bit ST j Element R in (1) i，j The corresponding bit of' has a value of zero, the sign of the element will be flipped. This calculation can require multiple RPCs for the computing system MPC 1 。
Computing system MPC 1 And MPC 2 The bit vectors are reconstructed (step 412). Computing system MPC 1 And MPC 2 The bit vector of the user profile can be reconstructed based on matrices R and R' having exactly the same size. For example, a computing system MPC 1 Being able to send a part of the columns of matrix R to the computing system MPC 2 And computing the system MPC 2 The remainder of the columns of matrix R' can be sent to the MPC 1 . In a particular example, a computing system MPC 1 It is possible to send the first half of the columns of the matrix R to the computing system MPC 2 And computing the system MPC 2 The second half of the columns of matrix R' can be sent to the MPC 1 . Although in this example columns are used for horizontal reconstruction and it is preferred to protect user privacy, in other examples rows can be used for vertical reconstruction.
In this example, a computing system MPC 2 The first half of the columns of matrix R' can be coupled to the slave computing system MPC 1 The first half of the columns of the received matrix R are combined to reconstruct the first half of the bit vector (i.e., m/2 dimensions). Similarly, computing system MPC 1 The second half of the columns of the matrix R can be coupled to the slave computing system MPC 2 The second half of the columns of the received matrix R' are combined to reconstruct the second half of the bit vector (i.e., m/2 dimensions). Conceptually, computing system MPC 1 And MPC 2 The corresponding shares of the plaintext reconstruction bit matrix B in the two matrices R and R' have now been combined. This bit matrix B will include the bit vectors of the projection results (onto each projection plane) for each user profile whose share was received from the content platform 150 for the machine learning model. Each of the two servers in MPC cluster 130 owns half of bit matrix B in the clear.
However, if bit flipping is used, the meterCalculation system MPC 1 And MPC 2 The bits of the elements in matrices R and R' have been flipped for a random pattern fixed by the machine learning model. This random bit flipping pattern for two computing systems MPC 1 And MPC 2 Is opaque, such that the computing system MPC 1 And MPC 2 The original user profile cannot be inferred from the bit vectors of the projection results. Cryptographic design also prevents MPC by partitioning bit vectors horizontally 1 And MPC 2 Inferring original user profiles, i.e. computing systems MPC 1 The second half of the bit vector of the projection result is kept in plain text and the system MPC is calculated 2 The plaintext holds the first half of the bit vector of the projection result.
Computing system MPC 1 And MPC 2 A machine learning model is generated (step 414). Computing system MPC 1 The second half of the bit vector can be used to generate the k-NN model. Similarly, computing system MPC 2 The first half of the bit vector can be used to generate the k-NN model. Generating a model using bit flipping and horizontal partitioning of a matrix applies the principles of depth defense to protect the privacy of the user profile used to generate the model.
In general, each k-NN model represents a cosine similarity (or distance) between the user profiles of a set of users. By a computing system MPC 1 The generated k-NN model represents the similarity between the second half of the bit vectors, as determined by the computing system MPC 2 The generated k-NN model represents the similarity between the first halves of the bit vectors. For example, each k-NN model can define cosine similarities between the first halves of its bit vectors.
By a computing system MPC 1 And MPC 2 The two generated k-NN models can be referred to as k-NN models, which have unique model identifiers as described above. Computing system MPC 1 And MPC 2 Their models can be stored, as well as the share of the tags for each user profile used to generate the models. The content platform 150 can then query the model to make inferences about the user group for the user.
Example Process for inferring user groups Using machine learning models
FIG. 5 is a flow diagram illustrating an example process 500 for adding a user to a user group using a machine learning model. The operations of process 500 can be implemented, for example, by MPC cluster 130 of fig. 1 and client device 110, such as application 112 running on client device 110. The operations of process 500 can also be implemented as instructions stored on one or more computer-readable media, which may be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of process 500.
The MPC cluster 130 receives an inference request for a given user profile (step 502). An application 112 running on a user's client device 110 can communicate an inference request to MPC cluster 130, for example, in response to a request from content platform 150. For example, the content platform 150 can transmit an upload token M to the application 112 infer To request the application 112 to submit an inference request to the MPC cluster 130. The inference request can be a query as to whether the user should be added to any number of groups of users.
Inference request token M infer The share of a given user profile of the user, the model identifier of the machine learning model (e.g., k-NN model) and the owner domain to be used for inference, the number of nearest neighbors k of the given user profile to be used for inference, additional signals (e.g., context signals or digital component signals), the aggregation function to be used for inference and any aggregation function parameters to be used for inference, and the signature of all of the above information created by the owner domain using the owner domain secret private key can be included.
As mentioned above, to prevent the clear text form of a given user profile P i Leakage to computing system MPC 1 Or MPC 2 And thus protecting user privacy, the application 112 can profile a given user P i Split into separate for MPC 1 And MPC 2 Two shares of [ P ] i，1 ]And [ P i，2 ]. Application 112 can then send the computing system MPC 1 Sending a first share P with a given user profile i，1 ]And an encrypted version of the second share (e.g., toPubKeyEncrypt ([ P ] of a given user profile i，2 ]，MPC 2 ) A single inference request. The inference request may also include an inference request token M infer Enabling the MPC cluster 130 to authenticate the inference request. By sending an inference request that includes the first share and the encrypted second share, the number of outgoing requests sent by the application 112 is reduced, resulting in computation, bandwidth, and battery savings at the client device 110.
In other implementations, the application 112 can assign a first share [ P ] of a given user profile i，1 ]Send to computing system MPC 1 And a second share of the given user profile P i，2 ]Sending to a computing System MPC 2 . By dividing a second share P of a given user profile i，2 ]Send to computing system MPC 2 Without going through the computing system MPC 1 The second share does not need to be encrypted to prevent the computing system MPC from being encrypted 1 Accessing a second share of a given user profile P i，2 ]。
MPC for each computing system 1 And MPC 2 The k nearest neighbors of a given user profile in the secret share representation are identified (step 504). Computing system MPC 1 Can use a first share P of a given user profile i，1 ]To calculate half of the bit vector for a given user profile. To generate the bit vectors, the system MPC is calculated 1 Operations 410 and 412 of process 400 of fig. 4 can be used. I.e. computing system MPC 1 The shares P of a given user profile can be projected using random projection vectors generated for the k-NN model i，1 ]And creates a secret share of the bit vector for a given user profile. Computing System MPC if bit flipping is used to generate k-NN model 1 The first share of the bit flip pattern used to generate the k-NN model can then be used { [ ST ] 1，1 ]，[ST 2，1 ]，...[ST m，1 ]The secret share of the bit vector of a given user profile.
Similarly, computing system MPC 1 Enabling a computing system MPC 2 Providing an encrypted second share of a given user profile, PubKeyEncrypt ([ P ] i，2 ]，MPC 2 )。Computing system MPC 2 Capable of decrypting a second share P of a given user profile using its private key i，2 ]And using a second share of the given user profile P i，2 ]To calculate half of the bit vector for a given user profile. I.e. computing system MPC 2 The shares [ P ] of a given user profile can be projected using random projection vectors generated for the k-NN model i，2 ]And creates a bit vector for a given user profile. Computing System MPC if bit flipping is used to generate k-NN model 2 Then a second share of the bit flip pattern used to generate the k-NN model can be used { [ ST ] 1，2 ]，[ST 2，2 ]，...[ST m，2 ]The elements of the bit vector for a given user profile are modified. Computing system MPC 1 And MPC 2 The bit vector is then reconstructed using horizontal partitioning, as described in operation 412 in fig. 4. After reconstruction is complete, the system MPC is calculated 1 Having the first half of the total bit vector of a given user profile, and computing the system MPC 2 The second half of the total bit vector with the given user profile.
MPC for each computing system 1 And MPC 2 Half of the bit vector of its given user profile and its k-NN model are used to identify k 'nearest neighbor user profiles, where k' ═ a × k, where a is determined empirically based on actual production data and statistical analysis. For example, a-3 or another suitable number. Computing system MPC 1 The hamming distance between the first half of the total bit vector and the bit vector of each user profile of the k-NN model can be calculated. Computing system MPC 1 K 'nearest neighbors, e.g., k' user profiles with the lowest hamming distances, are then identified based on the calculated hamming distances. In other words, computing system MPC 1 A set of nearest neighbor user profiles is identified based on the shares of a given user profile and a k-nearest neighbor model trained using a plurality of user profiles. Example results in tabular form are shown in table 5 below.
TABLE 5
In table 5, each row is for a particular nearest neighbor user profile and includes the first half of the bit vector for each user profile and the bit vector for the user profile 1 The hamming distance between the bit vectors of a given user profile is calculated. The row for a particular nearest neighbor user profile also includes a first share of the user profile and a first share of a tag associated with the user profile.
Similarly, computing system MPC 2 The hamming distance between the second half of the total bit vector and the bit vector of each user profile of the k-NN model can be calculated. Computing system MPC 2 K 'nearest neighbors, e.g., k' user profiles with the lowest hamming distances, are then identified based on the calculated hamming distances. Example results in tabular form are shown in table 6 below.
TABLE 6
In table 6, each row is for a particular nearest neighbor user profile, and includes that user profile and is calculated by the computing system MPC 2 A hamming distance between the given user profiles is calculated. The row for a particular nearest neighbor user profile also includes a second share of the user profile and a second share of the label associated with the user profile.
Computing system MPC 1 And MPC 2 The list of row identifiers (row IDs) and hamming distance pairs can be exchanged for each other. Thereafter, each computing system MPC 1 And MPC 2 The k nearest neighbors can be selected independently using the same algorithm and input data. For example, a computing system MPC 1 Can find a pair from a computing system MPC 1 And MPC 2 Both partial query results have a common line identifier. For each i in the common row identifier, the computing system MPC 1 Calculating a combined Hamming distance d from the two partial Hamming distances i E.g. d i ＝d i，1 +d i，2 . Computing system MPC 1 Can then be based on the combined Hamming distance d i The common row identifiers are sorted and the k nearest neighbors are selected. The k nearest neighbor line identifiers can be represented as ID ═ ID 1 ，...id k }. It can be shown that if a is large enough, the high probability of k nearest neighbors determined in the above algorithm is true k nearest neighbors. However, a large value of a results in high calculation cost. In some embodiments, a computing system MPC 1 And MPC 2 Engaging in a Privacy Set Intersection (PSI) algorithm to determine privacy to a MPC from a computing system 1 And MPC 2 The partial query result of (1) a common line identifier. Furthermore, in some embodiments, the MPC 1 And MPC 2 Participate in an enhanced Privacy Set Intersection (PSI) algorithm to compute a privacy score for a MPC from a computer system 1 And MPC 2 D of a line identifier common to both partial query results i ＝d i，1 +d i，2 And not towards MPC 1 Or MPC 2 Disclosure of everything, but of i The first k nearest neighbors determined.
It is determined whether to add the user to the user group (step 506). This determination can be made based on the k nearest neighbor profiles and their associated labels. The determination is also based on the aggregation function used and any aggregation parameters of the aggregation function. The aggregation function can be selected based on the nature of the machine learning problem, e.g., binary classification, regression (e.g., using arithmetic mean or root mean square), multi-class classification, and weighted k-NN. Each way of determining whether to add a user to a user group can include different interactions between the MPC cluster 130 and the applications 112 running on the clients 110, as described in more detail below.
If it is determined that the user is not to be added to the user group, the application 112 may not add the user to the user group (step 508). If it is determined to add the user to the user group, the application 112 can add the user to the user group, for example, by updating a user group list stored at the client device 110 to include the user group identifier of the user group (step 510).
Example binary class inference techniques
For binary classification, inferenceThe request can include a threshold, L true And L false As an aggregation function parameter. The tag value is of the boolean type, i.e., true or false. the threshold parameter can indicate that a truth label must be had in order to add a user to the user group L true Is determined by the threshold percentage of k nearest neighbor profiles. Otherwise, the user will be added to the user group L false . In one approach, if the number of nearest neighbor user profiles with a tag value of true is greater than the product of threshold and k, the MPC cluster 130 may instruct the application 112 to add the user to the user group L true (otherwise L) false ). However, computing system MPC 1 The inference results will be learned, e.g. the user group that the user should join.
To protect user privacy, inference requests can include clear text thresholds for computing systems MPC 1 First fraction of [ L ] true，1 ]And [ L false，1 ]And for computing systems MPC 2 Encrypted second share of PubKeyEncrypt ([ L) true，2 ]||[L false，2 ]||application_public_key，MPC 2 ). In this example, application 112 can be in accordance with [ L ] true，2 ]、[L fasle，2 ]And the public key of application 112 to generate a composite message, as represented by the symbol | |, and using computing system MPC 2 The public key of (a) to encrypt the composite message. Slave computing system MPC 1 The inferred response to application 112 can include a calculation system MPC 1 First share [ L ] of the determined inference result result，1 ]And by a computing system MPC 2 Second share [ L ] of the determined inference result result，2 ]。
To prevent the second share from being calculated by the system MPC 1 Accessing and thus enabling a computing system MPC 1 Calculation system MPC capable of obtaining an inference result in plain text 2 A second share [ L ] of the inference result result，2 ]An encrypted (and optionally digitally signed) version of (e.g., PubKeySign (PubKeyEncrypt ([ L ]) result，2 ]，application_public_key)，MPC 2 ) Send to computing system MPC 1 For inclusion in the inferred response sent to application 112. In this exampleApplication 112 can use a computing system MPC for generating digital signatures 2 Computing system MPC corresponding to private key of 2 Verifies the digital signature and uses the second share L for encrypting the inference result result，2 ]The application 112 private key corresponding to the public key of (application _ public _ key) to decrypt the second share L of the inference result result，2 ]。
The application 112 can then be able to base the first share [ L [ ] result，1 ]And a second fraction [ L result，2 ]To reconstruct the inference result L result . Using digital signatures to enable application 112 to detect signals from computing system MPC 2 Counterfeiting of the result of (A), e.g. by a computing system MPC 1 . Depending on the desired level of security, which parties operate the computing systems of the MPC cluster 130, and the assumed security model, a digital signature may not be needed.
Computing system MPC 1 And MPC 2 The fraction [ L ] of binary classification results can be determined using MPC techniques result，1 ]And [ L result，2 ]. In binary classification, the label of a user profile 1 Is zero (false) or one (true). Assume that the selected k nearest neighbor identifiers id 1 ，...id k Identification, calculating system MPC 1 And MPC 2 The sum of the labels of the k nearest neighbor user profiles (sum of labels) can be calculated, where the sum is represented by the following relation 3:
relation 3: sum of labels ∑ sum i∈{id1，...idk }label i
To determine this sum, the system MPC is calculated 1 To a computing system MPC 2 Sending ID (i.e., { ID }) 1 ，...id k }). Computing system MPC 2 It can be verified that the number of row identifiers in the ID is greater than the threshold for enforcing k-anonymity. Meter mat system MPC 2 The sum of tags [ sum _ of _ labgls ] can then be calculated using the following relationship 4 2 ]Second fraction of (c):
relationship 4: [ sum _ of _ labels) 2 ]＝∑ i∈{id1，...idk} [label i，2 ]
Computing system MPC 1 The sum of labels [ sum _ of _ labels ] can also be calculated using the following relationship 5 1 ]First fraction of (c):
relation 5: [ sum _ of _ labels) 1 ]＝∑ i∈{id1，...idk} [label i，1 ]
If the sum of labels sum _ of _ labels is the computing system MPC 1 And MPC 2 Computing system MPC should know as little confidential information as possible 1 The sum of labels can be calculated 1 ]Is below a threshold, e.g., [ below _ threshold [ ] 1 ]＝[sum_of_labels 1 ]< threshold x k. Similarly, computing system MPC 2 The sum of labels can be calculated 2 ]Is below a threshold, e.g., [ below threshold [ ] 2 ]＝[sum of labels 2 ]< threshold x k. Computing system MPC 1 Can continue to pass through the below threshold 1 ]×[L false，1 ]+(1-[below_threshold 1 ])×[L true，1 ]To calculate an inference result [ L result，1 ]. Similarly, computing system MPC 2 Can pass through [ below _ threshold 2 ]×[L false，2 ]+(1-[below_threshold 2 ])×[L true，2 ]To calculate [ L ] result，2 ]。
If the sum of the labels sum of labels, Sum _ of _ labels, is not confidential information, the computing system MPC is calculated 1 And MPC 2 Can be based on [ sum _ of _ labels 1 ]And [ sum _ of _ labels 2 ]Sum _ of _ labels is reconstructed. Computing system MPC 1 And MPC 2 The parameter below _ threshold can then be set to sum _ of _ labels < threshold × k, e.g. to one if it is below the threshold, or to zero if it is not below the threshold.
After calculating the parameter below _ threshold, the system MPC is calculated 1 And MPC 2 Can continue to determine the inference result L result . For example, a computing system MPC 2 Can be based on the value of below _ threshold, [ L ] result，2 ]Is set to [ L true，2 ]Or [ L false，2 ]. For example, a computing system MPC 2 Can be set [ L ] if the sum of tags is not below a threshold result，2 ]Is set as [ L true，2 ]Or set to [ L ] if the sum of tags is below a threshold false，2 ]. Computing system MPC 2 An encrypted second share (PubKeyEncrypt (L) of the inference result may then be used result，2 ]，application_public_key))[11]Or a digitally signed version of the result is returned to the computing system MPC 1 。
Similarly, computing system MPC 1 Can be based on the value of below _ threshold, [ L ] result，1 ]Is set to [ L true，1 ]Or [ L false，1 ]. For example, a computing system MPC 1 Can set L if the sum of tags is not less than the threshold result，1 ]Is set to [ L true，1 ]Or set to [ L ] if the sum of tags is below a threshold false，1 ]. Computing system MPC 1 Can assign a first share L of the inference result result，1 ]And an encrypted second share of the inference result L result，2 ]As an inference response to the application 112. The application 112 can then calculate an inference result based on the two shares, as described above.
Example Multi-class Classification inference techniques
For multi-class classification, the labels associated with each user profile can be classification features. The content platform 150 can specify a look-up table that maps any possible category value to a corresponding user group identifier. The lookup table can be one of the aggregation function parameters included in the inference request.
Within the k nearest neighbors found, the MPC cluster 130 finds the most frequent label value. The MPC cluster 130 can then find the user group identifier corresponding to the most frequent tag value in the lookup table and request the application 112 to add the user to the user group corresponding to the user group identifier, for example, by adding the user group identifier to a list of user groups stored at the client device 110.
Similar to binary classification, preferably hiding is from the computing system MPC 1 And MPC 2 Is deduced as a result L result . For this purpose, use is made of112 or the content platform 150 can create two lookup tables, each mapping a class value to an inference result L result The corresponding share of (c). For example, the application can create a mapping of the class value to a first share [ L [ ] result1 ]And mapping the class value to a second share L result2 ]Of the second look-up table. MPC from application to computing system 1 Can include a request for inference of a computing system MPC 1 And for computing system MPC 2 The encrypted version of the second lookup table. The second lookup table can use a computing system MPC 2 Is encrypted. For example, a composite message including a second lookup table and a public key of an application can use a computing system MPC 2 Encrypted with a public key, e.g. PubKeyEncrypt (lookup table2| | | application _ public _ key, MPC 2 )。
By a computing system MPC 1 The inferred response sent can include sending by the computing system MPC 1 First share [ L ] of the generated inference result result1 ]. Similar to binary classification, to prevent the second share from being calculated by the system MPC 1 Accessing and thus enabling a computing system MPC 1 Computing system MPC capable of obtaining an inference result in clear text 2 A second share [ L ] of the inference result result，2 ]An encrypted (and optionally digitally signed) version of (e.g., PubKeySign (PubKeyEncrypt ([ L ]) result，2 ]，application_public_key)，MPC 2 ) Send to computing system MPC 1 For inclusion in the inference results sent to application 112. Application 112 can be based on [ L result1 ]And [ L result2 ]Reconstruction of the inference result L result 。
Assume that there are w valid labels { l ] for the multiclass classification problem 1 ，l 2 ，...l w }. To determine inference results L in multi-class classification result Fraction of (A) [ L ] result1 ]And [ L result2 ]Computing system MPC 1 To a computing system MPC 2 Sending ID (i.e., { ID }) 1 ，...id k }). Computing system MPC 2 It can be verified that the number of row identifiers in the ID is greater than the threshold for enforcing k-anonymityThe value is obtained. In general, k in k-NN can be significantly larger than k in k-anonymity. Computing system MPC 2 Then the jth label [ l ] can be calculated j，2 ]Second frequency share [ frequency ] j，2 ]Which is defined using the following relationship 6.
similarly, computing system MPC 1 Calculate jth tag [ l ] j，1 ]First frequency share of (1) j，1 ]Which is defined using relation 7 below.
assume the frequency (frequency) of the tags within k nearest neighbors i ) Not sensitive, computing system MPC 1 And MPC 2 Two shares [ frequency ] that can be based on the label i，l ]And [ frequency ] i，2 ]Reconstructing frequency i . Computing system MPC 1 And MPC 2 Then the frequency can be determined index Index parameter (index) having a maximum value, e.g., index ═ argmax i (frequency i )。
Computing system MPC 2 Then the share corresponding to the tag with the highest frequency L can be looked up in its look-up table result，2 ]And PubKeyEncrypt ([ L ] L) result，2 ]Application _ public _ key) to the computing system MPC 1 . Computing system MPC 1 The share corresponding to the tag with the highest frequency L can be similarly looked up in its look-up table result，1 ]. Meter mat system MPC 1 The application 112 can then be distributed to include two shares (e.g., [ L ] result，1 ]And PubKeyEncrypt ([ L) result，2 ]Application _ public _ key)). As described above, the second share can be calculated by the computing system MPC 2 Digitally signing to prevent computing system MPC 1 Counterfeit computing system MPC 2 In response to (2). Applications 112 can then calculate an inference result based on the two shares, as described above, and add the user to the group of users identified by the inference result.
Example regression inference techniques
For regression, the label associated with each user profile P must be numeric. The content platform 150 can specify an ordered list of thresholds, e.g., (-infinity < t) 0 ＜t 1 ＜...＜t n < ∞) and a list of user group identifiers, e.g., { L 0 ，L 1 ，...L n ，L n+1 }. In addition, content platform 150 can specify an aggregation function, such as an arithmetic mean or root mean square.
Within the k nearest neighbors found, the MPC cluster 130 computes the average of the label values (result), and then uses the result lookup mapping to find the inference result L result . For example, the MPC cluster 130 can identify tags based on an average of the tag values using the following relationship 8:
relationship 8:
if result is less than t 0 ，L result ←L 0 ；
If result > t n ，L result ←L n+1 ；
If t is x ＜result≤t x+1 ，L result ←L x+1
I.e. if the result is less than or equal to the threshold t o Then conclude result L result Is L 0 . If the result is greater than the threshold t n Then conclude result L result Is L n+1 . Otherwise, if the result is greater than the threshold t x And is less than or equal to the threshold value t x+1 Then conclude result L result Is L x+1 . Computing system MPC 1 The requesting application 112 then adds the user to the corresponding inference result L result By including the inference result L, for example result The inference response is sent to application 112.
Similar to the other classification techniques described above, MPC can be derived from a computing system 1 And MPC 2 Hide and push awayBreaking result L result . To this end, the inference request from application 112 can include information for the computing system MPC 1 Tag [ L ] i，1 ]And for computing the system MPC 2 Tag [ L ] i，2 ]Encrypted second share (e.g., PubKeyEncrypt ([ L ]) 0，2 ||...|L n+1，2 ||application_public_key，MPC 2 ))。
By a computing system MPC 1 The inference result sent can include a calculation system MPC 1 First share [ L ] of the generated inference result result1 ]. Similar to binary classification, to prevent the second part from being processed by the computing system MPC 1 Accessing and thus enabling a computing system MPC 1 Calculation system MPC capable of obtaining an inference result in plain text 2 A second share [ L ] of the inferred result result，2 ]An encrypted (and optionally digitally signed) version of (e.g., PubKeySign (PubKeyEncrypt ([ L ]) result，2 ]，application_public_key)，MPC 2 ) Send to computing system MPC 1 For inclusion in the inference results sent to application 112. Application 112 can be based on [ L result1 ]And [ L result2 ]Reconstruction of the inference result L result 。
Computing a system MPC when the aggregation function is an arithmetic mean 1 And MPC 2 The sum of labels, is computed, similar to binary classification. Computing System MPC if the sum of tags is not sensitive 1 And MPC 2 Two shares can be calculated 1 ]And [ sum _ of _ labels [ ] 2 ]The sum of labels is then reconstructed based on these two shares. Computing system MPC 1 And MPC 2 The average of the tags can then be calculated by dividing the sum of the tags by the number of nearest neighbor tags, e.g., by k.
Computing system MPC 1 The average can then be compared to a threshold using the relationship 8 to identify a first share of the tag corresponding to the average and the first share L result，1 ]Set to the first share of the identified tag. Similarly, computing system MPC 2 The average can be related to the threshold using a relationship of 8The values are compared to identify a second share of the tag corresponding to the average value, and the second share L result，2 ]Set to a second share of the identifier tag. Computing system MPC 2 The public key of the application 112 (e.g., PubKeyEncrypt ([ L ") can be used result，2 ]Application _ public _ key)) to encrypt the second share L result，2 ]And sending the encrypted second share to the computing system MPC 1 . Computing system MPC 1 The first share and the encrypted second share (which can optionally be digitally signed as described above) can be provided to the application 112. The application 112 may then add the user to the user list L by a tag (e.g., a user group identifier) result An identified group of users.
Computing a system MPC if the sum of tags is sensitive 1 And MPC 2 It may not be possible to construct sum of labels in plaintext. In contrast, computing system MPC 1 Can calculate the mask pair
In addition, a computing system MPC 1 Can calculateMPC cluster 130 will return L when it is 1 i If use default is 1, Ln +1 will be returned. This condition can be expressed in relation 9 below.
the corresponding cryptographic implementation can be represented by the following relations 10 and 11.
if L is i Is in the clear, these calculations do not require the computing system MPC 1 And MPC 2 Any round trip calculation between, if L i Is a secret share, these calculations involve one round trip calculation. Computing system MPC 1 Two shares of the result (e.g., [ L ]) can be made result，1 ]And [ L result，2 ]Provided to the application 112, wherein the second share is calculated by the computing system MPC 2 Encrypted and optionally digitally signed as described above. In this way, application 112 can determine the inference result Lresult without computing system MPC 1 Or MPC 2 Learning anything about the instant or final result.
For root mean square, calculate system MPC 1 Will ID (i.e. { ID } 1 ，...id k }) to the computing system MPC 2 . Computing system MPC 2 It can be verified that the number of row identifiers in the ID is greater than a threshold to enforce k-anonymity. Computing system MPC 2 The second share of the sum of square parameters (e.g., sum of squares of label values) can be calculated using the following relationship 12.
similarly, computing system MPC 1 The following relationship 13 can be used to calculate the first share of the sum of square labels parameter.
assuming the sum of square labels parameter is not sensitive, the system MPC is calculated 1 And MPC 2 Can be based on two shares [ sum of square _ labels 1 ]And [ sum _ of _ square _ labels 2 ]To reconstruct the sum of square parameters. Computing system MPC 1 And MPC 2 The root mean square of the tags can be calculated by dividing sum of square labels by the number of nearest neighbor tags, e.g., by k, and then calculating the square root.
Whether the mean is calculated via arithmetic mean or root mean square, the system MPC is calculated 1 The average can then be compared to a threshold using the relationship 8 to identify the label corresponding to the average and to compare the first share [ L [ ] result，1 ]Set to the identified tag. Similarly, computing system MPC 2 The average can be compared to a threshold using a relationship 8 to identify the tag (or secret share of the tag) corresponding to the average, and the second share L result，2 ]Set to the identifier tag (or secret share of the identifier tag). Computing system MPC 2 The public key of the application 112 (e.g., PubKeyEncrypt ([ L ") can be used result，2 ]Application _ public _ key)) to encrypt the second share L result，2 ]And sending the encrypted second share to the computing system MPC 1 . Computing system MPC 1 Can add the first portionThe secret second share (which can optionally be digitally signed as described above) is provided to the application 112 as an inference result. Application 112 can then add the user to the user's L result The tag (e.g., user group identifier) of (a) identifies the user group. If the sum of square labels parameter is sensitive, the system MPC is calculated 1 And MPC 2 A cryptographic protocol similar to that used in the arithmetic mean example can be executed to compute the share of the inference result.
In the above technique of inferring the results of the classification and regression problems, all k nearest neighbors have equal influence, e.g., equal weight, on the final inference result. For many classification and regression problems, if each of the k neighbors is assigned a current neighbor and a query parameter P i The weight that monotonically decreases as the hamming distance between increases, the model quality can be improved. A common kernel function with this property is the Epanechnikov (parabolic) kernel function. Both hamming distance and weight can be calculated in plain text.
Sparse feature vector user profiles
When features of the electronic resource are included in the user profile and used to generate the machine learning model, the resulting feature vector can include high cardinality classification features such as domain, URL, and IP address. These feature vectors are sparse, with most elements having zero values. The application 112 may split the feature vector into two or more dense feature vectors, but the machine learning platform would consume too much client device upload bandwidth to be practical. To prevent this problem, the above-described systems and techniques can be adapted to better process sparse feature vectors.
When providing the feature vector for the event to the client device, computer readable code (e.g., script) of the content platform 150 included in the electronic resource can invoke an application (e.g., browser) API to specify the feature vector for the event. The code or content platform 150 is able to determine whether (some portion of) the feature vectors are dense or sparse. If the feature vector (or some portion thereof) is dense, the code can be passed in the value vector as an API parameter. If the feature vector (or some portion thereof) is sparse, the code can be passed in a map, e.g., an indexed key/value pair of those feature elements that have non-zero feature values, where the key is the name or index of such feature elements. If the feature vector (or some portion thereof) is sparse and the non-zero feature values are always the same value, e.g., 1, then the code can be passed in the set whose elements are the names or indices of such feature elements.
When aggregating feature vectors to generate a user profile, the application 112 can process dense and sparse feature vectors differently. The user profile (or some portion thereof) computed from the dense vectors remains as a dense vector. The user profile (or a portion thereof) computed from the mapping remains the mapping until the fill rate is high enough that the mapping no longer saves storage costs. At this point, the application 112 converts the sparse vector representation to a dense vector representation.
In some implementations, the application 112 can classify some of the feature vectors or some portions of the feature vectors as sparse feature vectors and some as dense feature vectors. The application 112 can then process each type of feature vector differently when generating the user profile and/or shares of the user profile.
If the aggregation function is a summation, the user profile (or a portion thereof) computed from the set can be a mapping. For example, each feature vector can have a category feature "visited domain". The aggregation function, i.e., the summation, will count the number of times the user accesses the publisher domain. If the aggregation function is a logical OR (OR), the user profile (OR some portion thereof) computed from the set can be kept as a set. For example, each feature vector can have a category feature "visited domain". The aggregation function, i.e. the logical OR, will calculate all publisher domains visited by the user, regardless of the frequency of the visits.
To send the user profile to the MPC cluster 130 for ML training and prediction, the application 112 can split the dense portion of the user profile from any standard cryptographic library that supports secret shares. To segment the sparse portion of the user profile without significantly increasing the client device upload bandwidth and computational cost, a functional secret shared shares (FSS) technique can be used. In this example, the content platform 150 assigns a unique index to each possible element in the sparse portion of the user profile, sequentially starting with 1. Assume that the valid range of indices is within 1, N (inclusive).
For a user profile calculated by an application having a non-zero value P i 1 ≦ i ≦ N, the application 112 can create two pseudo-random functions (PRF) g with the following properties i And h i ：
Using FSS, g i Or h i Can be succinctly represented, for example, by log 2 (N) size _ of _ tag bits, and it is not possible to do so according to g i Or h i Inferring i or P i . To prevent a brute force security attack, the size _ of _ tag is typically 96 bits or more. Outside the N dimensions, it is assumed that there are N dimensions with non-zero values, where N < N. For each of the n dimensions, the application 112 can construct two pseudo-random functions g and h as described above. Furthermore, the application 112 can pack all concise representations of n functions G into a vector G, and pack concise representations of n functions H into another vector H in the same order.
Further, the application 112 can split the dense portion of the user profile P into two additional secret shares [ P 1 ]And [ P 2 ]. Application 112 can then apply P 1 ]And G are sent to the computing system MPC 1 And will [ P ] 2 ]And H are sent to MPC 2 . When N < N, | G | × log is required for transmission of G 2 (N)×size_of_tag＝n×log 2 (N) x size _ of _ tag bits, which may be much smaller than the N bits needed if the application 112 transmits sparse portions of the user profile in dense vectors.
While computing system MPC 1 Receiving g i And computing a system MPC 2 Receiving h i Time, two computing systems MPC 1 And MPC 2 The secret shares of Shamir can be independently created. For any j, where 1 ≦ j ≦ N, the system MPC is calculated 1 Creating a coordinate [1, 2 × g ] for two dimensions i (j)]And computing the system MPC 2 Creating coordinates in respect of two dimensions[-1，2×h i (j)]A point of (c). If two computing systems MPC 1 And MPC 2 Cooperatively constructing a line y ═ a through two points 0 +a 1 X, then the relationships 14 and 15 are formed.
Relationship 14: 2 Xg i (j)＝a 0 +a 1
Relationship 15: 2 x h i (j)＝a 0 -a 1
If these two relationships are added together, this results in 2 × g i (j)+2×h i (j)＝(a 0 +a 1 )+(a 0 -a 1 ) This is simplified to a 0 ＝g i (j)+h i (j) In that respect Thus, [1, 2 Xg i (j)]And [ -1, 2 × h i (j)]Are two secret shares, i.e., Pi, of the ith non-zero element in the sparse array.
Computing system MPC during stochastic projection operation of machine learning training process 1 Can be independently driven from [ P ] 1 ]And G combine vectors of secret shares of their user profiles. From the above description, | G | ═ n is known, where n is the number of non-zero elements in the sparse portion of the user profile. In addition, the sparse portion of the user profile is known to be N-dimensional, where N < N.
Let G ═ G 1 ，...g n }. For the j-th dimension, where 1 ≦ j ≦ N, and 1 ≦ k ≦ N, let
Let [ SP) 1 ]＝{[SP 1，1 ]，...[SP N，1 ]I.e. reconstructed secret shares in a dense representation of the sparse part of the user profile. By connecting [ P ] 1 ]And [ SP 1 ]Meter for measuringCalculation system MPC 1 The full secret shares of the original user profile can be reconstructed. Computing system MPC 1 Then can project [ P ] randomly 1 ]||[SP 1 ]. Similarly, computing system MPC 2 Capable of projecting [ P ] randomly 2 ]||[SP 2 ]. After projection, the techniques described above can be used to generate machine learning models in a similar manner.
FIG. 6 is a conceptual diagram of an exemplary framework for generating inferences for a user profile in system 600. More particularly, the schematic depicts stochastic projection logic 610, first machine learning model 620, and final result calculation logic 640, which collectively comprise system 600. In some embodiments, the functionality of system 600 may be provided in a secure and distributed manner by multiple computing systems in an MPC cluster. The techniques described with reference to system 600 may, for example, be similar to those described above with reference to fig. 2-5. For example, the functionality associated with stochastic projection logic 610 may correspond to the functionality of one or more of the stochastic projection techniques described above with reference to fig. 2 and 4. Similarly, in some examples, the first machine learning model 620 may correspond to one or more machine learning models described above with reference to fig. 2, 4, and 5, such as one or more of those described above in connection with steps 214, 414, and 504. In some examples, the encrypted tag data set 626, which may be maintained and used by the first machine learning model 620 and stored in the one or more storage units, can include at least one real tag for each user profile used to generate or train or evaluate training quality or fine tune the process of training the first machine learning model 620, such as those tags that may be associated with k nearest neighbor profiles as described above with reference to step 506 of fig. 5. That is, the encrypted tag data set 626 may include at least one authentic tag for each of n user profiles, where n is the total number of user profiles used to train the first machine learning model 620. For example, the encrypted tag data set 626 may include a jth user profile (P) of the n user profiles j ) At least one real label (L) j ) K-th user profile (P) of n user profiles k ) Is/are as followsAt least one genuine label (L) k ) The l user profile (P) of the n user profiles l ) At least one real label (L) l ) Wherein j is more than or equal to 1, k, l is less than or equal to n, and the like. Such real tags associated with the user profile used to generate or train the first machine learning model 620 and included as part of the encrypted tag data set 626 can be encrypted, e.g., represented as secret shares. Additionally, in some examples, final result calculation logic 640 may correspond to logic employed in connection with performing one or more operations for generating an inferred result, such as one or more of those described above with reference to step 218 in fig. 2. The first machine learning model 620 and the final result calculation logic 640 can be configured to employ one or more inference techniques including binary classification, regression, and/or multi-class classification techniques.
In the example of fig. 6, system 600 is depicted as performing one or more operations at inferred times. Random projection logic 610 can be employed to apply a random projection transform to a user profile 609 (P) i ) To obtain a transformed user profile 619 (P) i '). The transformed user profile 619, as obtained by employing the random projection logic 610, can be in plaintext. For example, random projection logic 610 may be used, at least in part, to utilize random noise-obscuring feature vectors, such as feature vectors included or indicated in user profile 609 and other user profiles, to protect user privacy.
The first machine learning model 620 can be trained and subsequently utilized to receive the transformed user profile 619 as input and generate at least one predictive tag 629 in response theretopredictive tag 629 obtained using the first machine learning model 620 can be encrypted. In some implementations, the first machine learning model 620 includes a k-nearest neighbor (k-NN) model 622 and a label predictor 624. In such an implementation, the k-NN model 622 can be used by the first machine learning model 620 to identify the k nearest neighbor user profiles that are considered most similar to the transformed user profile 619. In thatIn some examples, models other than k-NN models, such as models rooted in one or more prototype methods, may be used as models 622. The label predictor 624 can then identify a true label for each of the k nearest neighbor user profiles from the true labels included in the encrypted label data set 626 and determine at least one predicted label 629 based on the identified labels. In some implementations, the tag predictor 624 can apply a softmax function to the data it receives and/or generates when determining the at least one predicted tag 629.
For embodiments in which the first machine learning model 620 and the final result calculation logic 640 are configured to employ regression techniques, the at least one predicted label 629 may correspond to, for example, a single label representing an integer, such as the sum of the true labels of the k nearest neighbor user profiles as determined by the label predictor 624. This sum of the true labels of the k nearest neighbor user profiles as determined by label predictor 624 is effectively equivalent to the average of the true labels of the k nearest neighbor user profiles as scaled by a factor k. Similarly, for embodiments in which the first machine learning model 620 and the final result calculation logic 640 are configured to employ binary classification techniques, the at least one prediction label 629 may correspond to, for example, a single label representing an integer determined by the label predictor 624 based at least in part on such a sum. In the case of binary classification, each of the true labels of the k nearest neighbor user profiles may be a binary value of zero or one, such that the above-mentioned average may be a numerical value between zero and one (e.g., 0.3, 0.8, etc.), e.g., which actually represents a predicted probability that the true label of the user profile received as input by the first machine-learned model 620 (e.g., transformed user profile 619) is equal to one. Additional details are provided below with reference to fig. 9-11 regarding the nature of the at least one predictive label 629 and the manner in which the first machine learning model 620 and the final result calculation logic 640 are configured to employ regression techniques and the manner in which the first machine learning model 620 and the final result calculation logic 640 are configured to employ binary classification techniques to determine the at least one predictive label 629.
For embodiments in which the first machine learning model 620 and the final result calculation logic 640 are configured to employ multi-class classification techniques, the at least one prediction label 629 may correspond to a vector or set of prediction labels as determined by the label predictor 624. Each predictive label in such a vector or set of predictive labels may correspond to a respective category and may be determined by the label predictor 624 based at least in part on a majority vote or frequency at which the true label corresponding to a respective category in the vector or set of true labels of the user profile of the k nearest neighbor user profiles is a true label of a first value (e.g., one) as determined by the label predictor 624. Much like binary classification, in the case of multi-class classification, each true label in each vector or set of true labels of a user profile in the k nearest neighbor user profiles may be a binary value of zero or one. Additional details are provided below with reference to fig. 9-11 regarding the nature of the at least one predictive label 629 and the manner in which the at least one predictive label 629 may be determined for embodiments in which the first machine learning model 620 and the final result calculation logic 640 are configured to employ multi-class classification techniques.
The final Result calculation logic 640 can be used to generate an inference Result 649 (Result) based on at least one prediction tag 629 i ). For example, the final result calculation logic 640 can be used to evaluate at least one predictive label 629 relative to one or more thresholds and determine an inference result 649 based on the evaluation result. In some examples, the inference result 649 may indicate whether a user associated with the user profile 609 is to be added to one or more user groups. In some implementations, the at least one predictive label 629 can be included or otherwise indicated in the inference result 649.
In some embodiments, system 600 as depicted in fig. 6 can represent a system as implemented by an MPC cluster, such as MPC cluster 130 of fig. 1. Thus, it should be understood that in at least some of these embodiments, some or all of the functionality described herein with reference to the elements shown in fig. 6 may be provided in a secure and distributed manner by two or more computing systems of an MPC cluster. For example, each of the two or more computing systems of the MPC cluster may provide a respective share of the functionality described herein with reference to fig. 6. In this example, two or more computing systems may operate in parallel and exchange secret shares to cooperatively perform operations similar or equivalent to those described herein with reference to fig. 6. In at least some of the above embodiments, the user profile 609 may represent a share of the user profile. In such embodiments, one or more of the other data or quantities described herein with reference to fig. 6 may also represent secret shares thereof. It should be appreciated that in providing the functionality described herein with reference to fig. 6, additional operations may be performed by two or more computing systems for the purpose of protecting user privacy. Examples of one or more of the above-described embodiments are described in more detail below, for example, with reference to fig. 12 and elsewhere herein. In general, in at least some embodiments, a "share" as described below and elsewhere herein can correspond to a secret share.
While the training process for k-NN models, such as k-NN model 622, may be relatively fast and simple, as knowledge of the labels is not required, in some cases, the quality of such models can leave room for improvement. Accordingly, in some embodiments, one or more of the systems and techniques described in further detail below may be utilized to enhance the performance of the first machine learning model 620.
FIG. 7 is a conceptual diagram of an exemplary framework for generating inferences of a user profile with enhanced performance in system 700. In some embodiments, the one or more elements 609- "629 as depicted in fig. 7 may be similar or equivalent to the one or more elements 609-" 629 as described above with reference to fig. 6, respectively. Much like system 600, system 700 includes random projection logic 610 and first machine learning model 620, and is depicted as performing one or more operations at inferred times.
However, unlike system 600, system 700 further includes a second machine learning model 730 that is trained and then leveraged by receiving transformed user profile 619For input and generation of prediction residual values 739 (residual) indicative of the amount of prediction error in at least one prediction tag 629 i ) As an output to improve the performance of the first machine learning model 620. For example, the accuracy of the second machine learning model can be higher than the accuracy of the first machine learning model. The prediction residual value 739 obtained using the second machine learning model 730 can be plaintext. Final Result calculation logic 740 included in system 700 can be employed in place of final Result calculation logic 640 to generate inference results 749 (Result) based on at least one prediction tag 629 and further based on prediction residual values 739 i ). Given that the prediction residual values 739 are indicative of an amount of prediction error in at least one prediction tag 629, relying on at least one prediction tag 629 and in cooperation with the prediction residual values 739 may enable the final result calculation logic 740 to effectively compensate or cancel at least some errors that may be expressed in at least one prediction tag 629, thereby enhancing one or both of the accuracy and reliability of the inference results 749 produced by the system 700.
For example, final result calculation logic 740 can be used to calculate a sum of at least one prediction label 629 and prediction residual values 739. In some examples, final result calculation logic 740 can be further used to evaluate such calculations against one or more thresholds and determine an inference result 749 based on the results of the evaluation. In some embodiments, such a calculated sum of at least one prediction label 629 and prediction residual values 739 can be included or otherwise indicated in the inference 649 in fig. 6 or the inference 749 in fig. 7.
The second machine learning model 730 may include or correspond to one or more of a Deep Neural Network (DNN), a gradient boosting decision tree, and a random forest model. That is, the first machine learning model 620 and the second machine learning model 730 may be architecturally different from each other. In some embodiments, the second machine learning model 730 may be trained using one or more gradient boosting algorithms, one or more gradient decreasing algorithms, or a combination thereof.
Using a lifting algorithm, which typically employs residuals as described in more detail in this document, a weaker machine learning model, e.g., a k-nearest neighbor model, can be used to train a stronger machine learning model, e.g., DNN. Unlike the training process of a weak learner, the training labels of a strong learner are the residuals of the weak learner. Using such residuals enables training of more accurate strong learners.
The second machine learning model 730 can be trained using the same set of user profiles used to train the first machine learning model 620 and data indicating the differences between the authentic labels for such set of user profiles and the predicted labels for such set of user profiles determined using the first machine learning model 620. As such, the process of training the second machine learning model 730 is performed after at least a portion of the process of training the first machine learning model 620 is performed. Data used to train the second machine learning model 730, such as data indicative of differences between predicted labels and authentic labels determined using the first machine learning model 620, may be generated or otherwise obtained by a process that evaluates the performance of the first machine learning model 620 as trained. Examples of such processes are described in more detail below with reference to fig. 10-11.
As described above, random projection logic 610, as included in systems 600 and 700, may be employed, at least in part, to utilize random noise to blur feature vectors, such as feature vectors included or indicated in user profile 609 and other user profiles, to protect user privacy. To enable the training and prediction for the learning of the vehicle, the random projective transformation applied by the random projection logic 610 requires some idea of preserving the distance between the feature vectors. One example of a stochastic projection technique that can be employed in the stochastic projection logic 610 includes a SimHash technique. This technique, and others described above, can be used to blur the feature vectors while preserving the cosine distance between the feature vectors.
While the preservation of cosine distances between feature vectors may prove sufficient for training and using k-NN models, such as k-NN model 622 of first machine learning model 620, it may be less than ideal for training and using one or more models of other types of models, such as second machine learning model 730. Thus, in some embodiments, it may be desirable to employ a stochastic projection technique in stochastic projection logic 610 that can be used to blur feature vectors while preserving euclidean distances between such feature vectors. One example of such a stochastic projection technique includes the Johnson-lindenstruss (J-L) technique or transform.
As described above, one attribute of the J-L transform is that it preserves the Euclidean distance between feature vectors using probabilities. In addition, the J-L transform is lossy, irreversible, and contains random noise. Thus, even if two or more servers or computing systems of an MPC cluster collude, they will not be able to derive a user profile (P) from using the J-L transformation technique i ') obtaining the original user profile (P) i ) Accurate reconstruction of the object. As such, employing J-L transformation techniques for the purpose of transforming user profiles in one or more systems described herein may be used to provide user privacy protection. Further, the J-L transform technique can be used as the dimension reduction technique. Thus, one advantageous byproduct of employing the J-L transformation technique for the purpose of transforming user profiles in one or more systems described herein is that it can actually be used to significantly increase the speed at which subsequent processing steps can be performed by such systems.
In general, given an arbitrarily small ε > 0, there is a J-L transform that can be applied to transform P i To P i ′，P j To P j ', j ≦ n for any 1 ≦ i, where n is the number of training examples, and:
(1-ε)×|P i -P j | 2 ≤|P′ i -P′ j | 2 ≤(1+ε)×|P i -P j | 2 that is, applying the J-L transform may change the Euclidean distance between two arbitrarily selected training examples by no more than a small fraction ε. For at least the foregoing reasons, in some embodiments, J-L transform techniques may be employed in random projection logic 610 as described herein.
In some embodiments, the system 700 as depicted in fig. 7 can represent a system as implemented by an MPC cluster such as MPC cluster 130 of fig. 1. Thus, it should be understood that in at least some of these embodiments, some or all of the functionality described herein with reference to the elements shown in fig. 7 may be provided in a secure and distributed manner by two or more computing systems of an MPC cluster. For example, each of the two or more computing systems of the MPC cluster may provide a respective share of the functionality described herein with reference to fig. 7. In this example, two or more computing systems may operate in parallel and exchange secret shares to cooperatively perform operations similar or equivalent to those described herein with reference to fig. 7. In at least some of the above embodiments, the user profile 609 may represent a secret share of the user profile. In such embodiments, one or more of the other data or quantities described herein with reference to fig. 7 may also represent secret shares thereof. It should be appreciated that in providing the functionality described herein with reference to fig. 7, additional operations may be performed by two or more computing systems for the purpose of protecting user privacy. Examples of one or more of the above-described embodiments are described in more detail below, for example, with reference to fig. 12 and elsewhere herein.
FIG. 8 is a flow diagram illustrating an example process 800 for generating inferred results of a user profile at an MPC cluster with, for example, higher accuracy boost performance. One or more of the operations described with reference to fig. 8 may be performed, for example, at inferred times. The operations of the process 800 can be implemented, for example, by an MPC cluster such as the MPC cluster 130 of fig. 1, and can also correspond to one or more of the operations described above with reference to fig. 7. One or more of the operations described with reference to fig. 8 may be performed, for example, at inferred times.
In some embodiments, some or all of the functionality described herein with reference to the elements shown in fig. 8 may be provided in a secure and distributed manner by two or more computing systems of an MPC cluster, such as MPC cluster 130 of fig. 1. For example, each of the two or more computing systems of the MPC cluster may provide a respective share of the functionality described herein with reference to fig. 8. In this example, two or more computing systems may operate in parallel and exchange secret shares to cooperatively perform operations similar or equivalent to those described herein with reference to fig. 8. It should be appreciated that in providing the functionality described herein with reference to fig. 8, additional operations may be performed by two or more computing systems for the purpose of protecting user privacy. Examples of one or more of the above-described embodiments are described in more detail below, for example, with reference to fig. 12 and elsewhere herein. The operations of process 800 can also be implemented as instructions stored on one or more computer-readable media, which may be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of process 800.
The MPC cluster receives an inference request associated with a particular user profile (step 802). For example, this may correspond to one or more operations similar or equivalent to one or more operations performed in connection with MPC cluster 130 receiving inference requests from applications 112, as described above with reference to fig. 1.
The MPC cluster determines a predicted label for a particular user profile based on the particular user profile, a first machine-learned model trained using a plurality of user profiles, and one or more of a plurality of real labels for the plurality of user profiles (step 804). For example, this can correspond to combining the first machine learning model 620 for obtaining at least one predictive tag 629
In this example, the plurality of true tags of the plurality of user profiles may correspond to the true tags included as part of the encrypted tag data 626, which are the true tags of the plurality of user profiles used to train the first machine learning model 620. The one or more real tags from the plurality of real tags may include at least one real tag for each of the k nearest neighbor user profiles identified by the k-NN model 622 of the first machine learning model 620, upon which the determination of the predicted tag for a particular user profile is based. In some examples, each of the plurality of authentic tags is encrypted, as is the case in the examples of fig. 6-7. Some of the various methods in which the true labels of the k nearest neighbor user profiles can be used to determine the predicted labels are described in detail above. As is apparent above, the method or manner in which such real tags are utilized to determine predictive tags may depend, at least in part, on the type of inference technique employed (e.g., regression techniques, binary classification techniques, multi-class classification techniques, etc.).
Based on a particular user profile and a second machine-learning model trained using multiple user profiles and data indicative of differences between a plurality of real labels of the multiple user profiles and a plurality of predicted labels determined for the multiple user profiles using the first machine-learning model, the MPC cluster determines prediction residual values indicative of prediction errors in the predicted labels (step 806). For example, this may correspond to combining with the second machine learning model 730 to obtain a prediction residual value 739 (residual) i ) And one or more operations performed similar or equivalent to one or more operations described above with reference to fig. 7. Thus, in some embodiments, the second machine learning model comprises at least one of a deep neural network, a gradient boosting decision tree, and a random forest model.
The MPC cluster generates data representing the inference result based on the prediction labels and the prediction residual values (step 808). For example, this may correspond to combining the final Result calculation logic 740 to generate the inference Result 749 (Result) i ) One or more operations performed similar or equivalent to one or more operations described above with reference to fig. 7. Thus, in some examples, the inference result includes or corresponds to a sum of the prediction tag and the prediction residual value.
The MPC cluster provides data representing the inferred result to the client device (step 810). For example, this may correspond to one or more operations similar or equivalent to one or more operations performed in connection with MPC cluster 130 providing inferred results to client device 110 on which application 112 is running, as described above with reference to fig. 1-2.
In some implementations, the process 800 further includes one or more operations in which the MPC cluster applies a transformation to the particular user profile to obtain a transformed version of the particular user profile. In these embodiments, to determine the predictive label, the MPC cluster determines the predictive label based at least in part on the transformed version of the particular user profile. For example, this may correspond to combining random projection logic 610 for applying a random projection transform to a user profile 609 (P) i ) To obtain a transformed user profile 619 (P) i ') one or more operations similar or equivalent to the one or more operations performed above with reference to figures 6-7. Thus, in some examples, the transformation may be a random projection. Further, in at least some of these examples, the random projection may be a Johnson-Lindenstaus (J-L) transform. In at least some of the above embodiments, to determine the prediction label, the MPC cluster provides a transformed version of the particular user profile as an input to the first machine learning model to obtain as an output the prediction label for the particular user profile. For example, this may correspond to receiving the transformed user profile 619 (P) in conjunction with the first machine learning model 620 (P) i ') as input and in response thereto generate at least one predictive tag 629
As described above, in some embodiments, the first machine learning model includes a k-nearest neighbor model. In at least some of these embodiments, to determine the predicted label, the MPC cluster identifies k nearest neighbor user profiles of the plurality of user profiles that are deemed to be most similar to the particular user profile based at least in part on the particular user profile and the k nearest neighbor model, and determines the predicted label based at least in part on the true label of each of the k nearest neighbor user profiles. In some such embodiments, to determine the predictive label based at least in part on the true label of each of the k nearest neighbor user profilesThe MPC cluster determines the sum of the true labels of the k nearest neighbor user profiles. For example, this can correspond to combining the first machine learning model 620 for obtaining at least one predictive label 629 in one or more embodiments in which one or more regression and/or binary classification techniques are employed
In at least some of the above embodiments, to determine the predicted label based at least in part on the true label of each of the k nearest neighbor user profiles, the MPC cluster determines the predicted label set based at least in part on the true label set of each of the k nearest neighbor user profiles respectively corresponding to the class set, and to determine the predicted label set, the MPC cluster performs an operation for each class in the set. Such operations can include one or more operations in which the MPC cluster determines a majority vote or frequency at which the true label corresponding to a category in the set of true labels of the user profile of the k nearest neighbor user profiles is a true label of a first value. For example, this can correspond to obtaining at least one predictive label 629 in connection with the first machine learning model 620 for one or more embodiments in which one or more multi-class classification techniques are employed
FIG. 9 is a flow diagram illustrating an example process 900 for preparing and performing training of a second machine learning model for boosting inference performance at an MPC cluster. In some embodiments, the operations of process 900 can be implemented, for example, by an MPC cluster such as MPC cluster 130 of fig. 1 and can also correspond to one or more of the operations described above with reference to fig. 2, 4, 6, and 7. In some embodiments, some or all of the functionality described herein with reference to the elements shown in fig. 9 may be provided in a secure and distributed manner by two or more computing systems of an MPC cluster, such as MPC cluster 130 of fig. 1. For example, each of the two or more computing systems of the MPC cluster may provide a respective secret share of the functionality described herein with reference to fig. 9. In this example, two or more computing systems may operate in parallel and exchange secret shares to cooperatively perform operations similar or equivalent to those described herein with reference to fig. 9. It should be appreciated that in providing the functionality described herein with reference to fig. 9, additional operations may be performed by two or more computing systems for the purpose of protecting user privacy. Examples of one or more of the above-described embodiments are described in more detail below, for example, with reference to fig. 12 and elsewhere herein. The operations of process 900 can also be implemented as instructions stored on one or more computer-readable media, which may be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of process 900.
The MPC cluster trains a first machine learning model using a plurality of user profiles (step 910). For example, the first machine learning model may correspond to the first machine learning model 620, as described above. Similarly, the plurality of user profiles used to train the first machine learning model may correspond to the number n of user profiles used to train the first machine learning model 620, whose authentic tags may be included in the set of encrypted tag data 626, as described above.
The MPC cluster evaluates the performance of the first machine learning model trained using the plurality of user profiles (step 920). Additional details regarding what such an evaluation may involve are provided below with reference to fig. 10-11.
In some embodiments, the data generated in such an evaluation can be utilized by the MPC cluster or another system in communication with the MPC cluster to determine whether performance of a first machine learning model, such as the first machine learning model 620, warrants a boost, for example, by a second machine learning model, such as the second machine learning model 730. Examples of data generated in such an evaluation that can be used in this manner are described in further detail below with reference to profile and residual data set 1070 of fig. 10 and step 1112 of fig. 11.
For example, in some cases, the MPC cluster or another system in communication with the MPC cluster may determine, based on data generated in such an evaluation, that the performance (e.g., prediction accuracy) of the first machine learning model satisfies one or more thresholds, and thus does not necessitate a boost. In this case, the MPC cluster may refrain from training and implement the second machine learning model based on the determination. However, in other cases, the MPC cluster or another system in communication with the MPC cluster may determine, based on data generated in such an evaluation, that the performance (e.g., prediction accuracy) of the first machine learning model meets one or more thresholds, and thus does necessitate a boost. In these cases, the MPC cluster may receive an upgrade in functionality comparable to that obtained when transitioning from system 600 to system 700 based on this determination as described above with reference to fig. 6-7. To receive such a functional upgrade, the MPC cluster may continue to train and implement a second machine learning model, such as second machine learning model 730, for use in improving the performance, e.g., accuracy, of the first machine learning model using the residual values. In some examples, data generated in such an evaluation may additionally or alternatively be provided to one or more entities associated with the MPC cluster. In some such examples, one or more entities may make their own determinations as to whether performance of the first machine learning model is necessarily improved, and proceed accordingly. Other configurations are possible.
The MPC cluster trains a second machine learning model using a data set that includes data generated in evaluating the performance of the first machine learning model (step 930). Examples of such data can include the data described below with reference to profile and residual data set 1070 of fig. 10 and step 1112 of fig. 11.
In some embodiments, the process 900 further includes additional steps 912 and 916, which will be described in more detail below. In such embodiments, steps 912 and 916 are performed before steps 920 and 930, but can be performed after step 910.
FIG. 10 is a conceptual diagram of an exemplary framework for evaluating performance of a first machine learning model in system 1000. In some embodiments, the one or more elements 609-629 as depicted in fig. 10 may be similar or equivalent to the one or more elements 609-629 as described above with reference to fig. 6-7, respectively. In some examples, one or more of the operations described herein with reference to fig. 10 may correspond to one or more of those operations described above with reference to step 920 of fig. 9.
However, unlike systems 600 and 700, system 1000 further includes residual calculation logic 1060. Further, in the example of FIG. 10, user profile 609 (P) i ) Corresponding to one of the plurality of user profiles used to train the first machine learning model 620, and in the example of fig. 6 and 7, the user profile 609 (P) i ) May not necessarily correspond to one of the plurality of user profiles used to train the first machine learning model 620, but simply correspond to the user profile associated with the inference request received at the inference time. In some examples, the plurality of user profiles described above used to train the first machine learning model 620 may correspond to the plurality of user profiles described above with reference to step 910 of fig. 9. Residual calculation logic 1060 may be used to calculate a residual based on at least one prediction tag 629 and at least one true tag 1059 (L) i ) Generating a residual value 1069 (residual) indicative of an amount of error in at least one prediction tag 629 i ). At least one predictive tag 629residual calculation logic 1060 may employ the secret share to calculate a difference in value between the at least one predictive tag 629 and the at least one authentic tag 1059. In some embodiments, residual values 1069 may correspond to the difference in the values described above.
The residual values 1069 can be stored in association with the transformed user profile 619, for example in a memory, as part of the profile and residual data set 1070. In some examples, the data included in profile and residual data set 1070 may correspond to one or both of the data described above with reference to step 930 of fig. 9 and the data described below with reference to step 1112 of fig. 11. In some embodiments, residual values 1069 are in the form of secret shares to protect user privacy and user security.
In some embodiments, as depicted in fig. 10, system 1000 can represent a system as implemented by an MPC cluster, such as MPC cluster 130 of fig. 1. Thus, it should be understood that in at least some of these embodiments, some or all of the functionality described herein with reference to the elements shown in fig. 10 may be provided in a secure and distributed manner by two or more computing systems of an MPC cluster. For example, each of the two or more computing systems of the MPC cluster may provide a respective share of the functionality described herein with reference to fig. 10. In this example, two or more computing systems may operate in parallel and exchange secret shares to cooperatively perform operations similar or equivalent to those described herein with reference to fig. 10. In at least some of the above embodiments, the user profile 690 may represent secret shares of the user profile. In such embodiments, one or more of the other data or quantities described herein with reference to fig. 10 may also represent secret shares thereof. It should be appreciated that in providing the functionality described herein with reference to fig. 10, additional operations may be performed by two or more computing systems for the purpose of protecting user privacy. Examples of one or more of the above-described embodiments are described in more detail below, for example, with reference to fig. 12 and elsewhere herein.
FIG. 11 is a flow diagram illustrating an example process 1100 for evaluating performance of a first machine learning model at an MPC cluster. The operations of the process 1100 can be implemented, for example, by an MPC cluster such as the MPC cluster 130 of fig. 1 and can also correspond to one or more of the operations described above with reference to fig. 9-10. In some examples, one or more of the operations described herein with reference to fig. 11 may correspond to one or more of those operations described above with reference to step 920 of fig. 9. In some embodiments, some or all of the functionality described herein with reference to fig. 11 may be provided in a secure and distributed manner by two or more computing systems in an MPC cluster, such as MPC cluster 130 of fig. 1. For example, each of the two or more computing systems of the MPC cluster may provide a respective share of the functionality described herein with reference to fig. 11. In this example, two or more computing systems may operate in parallel and exchange secret shares to cooperatively perform operations similar or equivalent to those described herein with reference to fig. 11. It should be appreciated that in providing the functionality described herein with reference to fig. 11, additional operations may be performed by two or more computing systems for the purpose of protecting user privacy. Examples of one or more of the above-described embodiments are described in more detail below, for example, with reference to fig. 12 and elsewhere herein. The operations of process 1100 can also be implemented as instructions stored on one or more computer-readable media, which can be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of process 1100.
The MPC cluster selects an ith user profile and at least one corresponding real label ([ P ]) i ，L i ]) Where i is initially set to a value of one (step 1102- & 1104) and incremented through the recursion until i equals n (step 1114- & 1116), where n equals the total number of user profiles used to train the first machine learning model. In other words, the process 1100 includes performing steps 1106-1112 as described below for each of the n user profiles used to train the first machine learning model.
In some embodiments, the ith user profile may represent a secret share of the user profile. In such embodiments, one or more of the other data or quantities described herein with reference to fig. 11 may also represent a portion thereof.
MPC cluster applies random projection to ith user Profile (P) i ) To obtain the ith user profile (P) i ') is generated (step 1106). This may be, for exampleCorresponding to and incorporating random projection logic 610 for applying a random projection transform to a user profile 609 (P) i ) To obtain a transformed user profile 619 (P) i ') one or more operations similar or equivalent to those performed above with reference to fig. 10.
MPC cluster will be the ith user profile (P) i ') as input to a first machine learning model to obtain a profile for the ith user (P) i ') at least one predictive tag for a transformed version ofpredictive tag 629
MPC cluster is based at least in part on a set of rules for an ith user profile (P) i ) At least one real label (L) i ) And at least one predictive tagresidual calculation logic 1060 for basing at least in part on at least one real tag 1059 (L) i ) And at least one predictive label 629
MPC cluster and ith user profile (P) i ') storing the computed residual values (Residu) in association with the transformed version e i ) (step 1112). For example, this may correspond to a combined residual value 1069 (residual) i ) E.g., with the transformed user profile 619 (P) i ') one or more operations similar or equivalent to one or more operations performed as part of the profile and residual data set 1070, as described above with reference to figure 10. In some examples, the data may correspond to data as described above with reference to step 930 of fig. 9. As such, in these examples, some or all of the data stored in this step may be used as data for training a second machine learning model, such as second machine learning model 730.
Referring again to step 1108-step 1108, the first machine learning model identifies an ith user profile (P) that is deemed to be associated with i ') a number of k nearest neighbor user profiles whose versions are most similar, identifying at least one real label for each of the k nearest neighbor user profiles, calculating a sum of the real labels of the k nearest neighbor user profiles, and using the sum as at least one predicted labelstep 1110 are given by:
similarly, for at least some embodiments in which the first machine learning model is configured to employ a binary classification technique, the MPC cluster obtains at least one predictive label at step 1108
However, unlike embodiments in which the first machine learning model is configured to employ a regression technique, in embodiments in which the first machine learning model is configured to employ a binary classification technique, each of the true labels of the k nearest neighbor user profiles may be a binary value of zero or one, such that the aforementioned average may be a numerical value between zero and one(e.g., 0.3, 0.8, etc.). Although the MPC cluster may compute and use the sum of the true labels (sum of labels) of the k nearest neighbor user profiles as the at least one predicted label at step 1108 in embodiments in which binary classification techniques are employedmachine learning model 730. More specifically, because each of the real tags of the k nearest neighbor user profiles may be a binary value of zero or one, in embodiments employing binary classification techniques, such residual values (Residue) are used i ) Can potentially indicate at least one genuine label (L) i ) And thus potentially may be indicated by a residual value (Residue) in a certain capacity at or after step 1112 may be processed i ) One or more system and/or entity inferences about the data.
For example, consider a case where a binary classification technique is to be employed and L i 1, k 15 andstep 1110, then the residual value (residual) in this first example i ) Will be given by: residue i 15, (1) -12-3. Thus, in this first example, the residual value (Residue) is i ) Will equal a value of (plus) 3. Now, consider the case where a binary classification technique is to be employed and L i 0, and k andstep 1110, for example i ) Residual value (residual) in this second example i ) Will be given by: residue i (15) (0) -12. Thus, in this first example, the residual value (residual) i ) Will equal a value of-12. In fact, in the case of the first and second examples described above, the positive residual value (residual) i ) Can be reacted with L i L correlation, and negative residual value (Residue) i ) Can be reacted with L i 0 is relevant.
To understand why this is possible according to Residue i Deducing L i Consider a user profile in which the residual for training the first machine learning model whose true label is equal to 0 is assumed to be satisfied with a sign
In view of the foregoing, as described below, in some embodiments, different methods can be employed to perform one or more operations associated with step 1108 and 1110 for embodiments in which binary classification techniques are employed. In some embodiments, to force the residuals of the two classes of training examples to have the same normal distribution, the MPC cluster can apply a transformation to the sum of the true labels of the k nearest neighbor user profiles (sum _ of _ labels) such that it is based on L i And
(i)F(μ 0 )＝0
(ii)f(μ 1 )＝1
(iii)σ 0 ×f′(μ 0 )＝σ 1 ×f′(μ 1 )
Where f' is the derivative of f.
One example of a transformation with the above-described properties that may be employed in such an implementation is a quadratic polynomial transformation of shape f (x) a 2 x 2 +a 1 x+a 0 Wherein f' (x) ═ 2a 2 x+a 1 . In some examples, an MPC cluster can be based on three constraints fromTo deterministically find the coefficient value a 2 ，a 1 ，a 0 }：
(i)a′ 2 ＝σ 0 -σ 1
(ii)a′ 1 ＝2(σ 1 μ 1 -σ 0 μ 0 )
(iii)a′ 0 ＝μ 0 (μ 0 σ 0 +μ 0 σ 1 -2μ 1 σ 1 )
In these examples, the MPC cluster can cluster the coefficients { a } 2 ，a 1 ，a 0 The calculation is: { a 2 ，a 1 ，a 0 }＝D×{a 2 ′，a 1 ′，a 0 '}. MPC cluster can compute { a using addition and multiplication operations, e.g., on secret shares 2 ′，a 1 ′，a 0 ' } and D. The transformation f (x) is a 2 x 2 +a 1 x+a 0 Mirror symmetry is also around:
to calculate the above coefficients and other values depending on them, the MPC cluster may first estimate equal to zero, μ, respectively 0 And σ 0 And the mean and standard deviation of the probability distribution of the prediction error (e.g., residual value) of the true label, and equal to one, mu, respectively 1 And σ 1 The mean and standard deviation of the probability distribution of the prediction error (e.g., residual value) of the true tag of (a). In some examples, the standard deviation σ is replaced or added to 0 The variance σ of the probability distribution of the prediction error of the real label equal to zero can be determined 0 2 And in addition to or instead of the standard deviation sigma 1 The variance σ of the probability distribution of the prediction error of the real label equal to one can be determined 1 2 。
In some instances, the given probability distribution of prediction errors may correspond to a normal distribution, and in other instances, the given probability distribution of prediction errors may correspond to a probability distribution other than a normal distribution, such as a bernoulli distribution, a uniform distribution, a binomial distribution, a hypergeometric distribution, an exponential distribution, and so forth. In such other instances, the estimated distribution parameters may include parameters other than the mean, standard deviation, and variance in some examples, such as one or more parameters that are specific to the characteristics of a given probability distribution of prediction errors. For example, the distribution parameters estimated for a given probability distribution corresponding to uniformly distributed prediction errors may include minimum and maximum parameters (a and b), while the distribution parameters estimated for a given probability distribution corresponding to exponentially distributed prediction errors may include at least one rate parameter (λ). In some implementations, one or more operations similar to the one or more operations performed in conjunction with the process 1110 of fig. 11 may be performed such that data indicative of prediction error of the first machine learning model can be obtained and used to estimate such distribution parameters. In at least some of the above embodiments, the data indicative of the prediction errors of the first machine learning model can be obtained and utilized to (i) identify a particular type of probability distribution from among several different types of probability distributions (e.g., normal distribution, bernoulli distribution, uniform distribution, binomial distribution, hypergeometric distribution, exponential distribution, etc.) that most closely corresponds to the shape of the probability distribution for a given subset of the prediction errors indicated by the data, and (ii) estimate one or more parameters of the probability distribution for the given subset of the prediction errors indicated by the data from the identified particular type of probability distribution. Other configurations are also possible.
Referring again to examples where the estimated distribution parameters include mean and standard deviation, in these examples, to estimate such distribution parameters for a true label equal to zero, the MPC cluster can compute:
wherein:
count 0 ＝∑ i (1-L i )
in some examples, the MPC cluster is based on variance σ 0 2 Calculating the standard deviation sigma 0 E.g. by calculating the variance σ 0 2 The square root of (a). Similarly, to estimate the distribution parameters of such a true tag equal to one, the MPC cluster can compute:
wherein:
count 1 ＝∑L i
in some examples, the MPC cluster is based on variance σ 1 2 Calculating the standard deviation sigma 1 E.g. by calculating the variance σ 1 2 The square root of (c).
Once such distribution parameters are estimated, coefficients can be calculated, stored, and later used to apply the corresponding transformation f to the sum of the real labels of the k nearest neighbor user profiles (sum _ of _ labels). In some examples, the coefficients are used to configure the first machine learning model such that, continuing, the first machine learning model applies, in response to the input, the corresponding transformation f to a sum of the true labels of the k nearest neighbor user profiles.
Much like the binary classification, in the case of a multi-class classification, each real label in each vector or set of real labels of a user profile in the k nearest neighbor user profiles may be a binary value of zero or one. To this end, a method similar to that described above with reference to binary classification may also be employed in embodiments in which the multi-class classification technique is implemented, such that L is based on i And
For arbitrarily chosen jth label, the MPC cluster can be based on l j Whether it is the training label for the training example divides the training example into two groups. For l therein j Is a training example set of training labels, and an MPC cluster can assume frequency j In a normal distribution, and the mean value mu is calculated 1 Sum variance σ 1 . On the other hand, for l j Rather than training example sets of training labels, an MPC cluster may assume a frequency j Is in normal distribution, and is calculatedMean value μ 0 Sum variance σ 0 。
Similar to binary classification, in the case of multi-class classification, the prediction of the k-NN model is likely to be biased (e.g., μ 0 > 0, where it should already be 0, and μ 1 < k, where it should already be k). In addition, σ is not guaranteed 0 ＝＝σ 1 . Thus, similar to the two-class classification, in the case of a multiple class classification, the MPC cluster is predicting frequency j The transformation f is applied so that after transformation, the Residue for both groups i Have substantially the same normal distribution. To achieve such a goal, the transformation f needs to satisfy the following properties:
(i)f(μ 0 )＝0
(ii)f(μ 1 )＝k
(iii)σ 0 ×f′(μ 0 )＝σ 1 ×f′(μ 1 )
where f' is the derivative of f.
The three attributes described above are very similar to their counterparts in the binary classification case. In the case of multi-class classification, one example of a transformation having the above-described properties that may be employed is a quadratic polynomial transformation of shape f (x) -a 2 x 2 +a 1 x+a 0 Wherein f' (x) ═ 2a 2 x+a 1 . In some examples, an MPC cluster can deterministically calculate coefficient values { a ] based on three linear equations from three constraints 2 ，a 1 ，a 0 }.
(i)a′ 2 ＝σ 0 -σ 1
(ii)a′ 1 ＝2(σ 1 μ 1 -σ 0 μ 0 )
(iii)a′ 0 ＝μ 0 (μ 0 σ 0 +μ 0 σ 1 -2μ 1 σ 1 )
Note that the transformations for the binary and multiclass classifications are almost identical, the only difference being that in multiclass classifications with k-NN models, the value of D can be scaled by a factor k in some embodiments.
Referring again to FIG. 9, in some embodiments, one or more of steps 912-916 may correspond to one or more of the operations described above, wherein the method for defining at least one function or transformation can be employed by the MPC cluster such that it is based on L i And steps 920 and 930, and may be performed after step 910.
The MPC cluster estimates a set of distribution parameters based on the plurality of true labels for the plurality of user profiles (step 912). For example, this may correspond to calculating the parameter μ as described above based on the real label associated with the same user profile utilized in step 910 in connection with the MPC cluster 0 、σ 0 2 、σ 0 、μ 1 、σ 1 2 And σ 1 One or more operations similar or equivalent to the one or more of the operations described.
The MPC cluster derives a function based on the estimated set of distribution parameters (step 914). For example, this may correspond to a parameter or coefficient (such as { a } that effectively defines a function in connection with MPC cluster computation 2 ，a 1 ，a 0 H) one or more operations similar or equivalent to the one or more operations performed. Thus, in some embodiments, to derive the function in step 914, the MPC cluster derives a set of parameters for the function, e.g., { a } 2 ，a 1 ，a 0 }。
The MPC cluster configures the first machine learning model to generate an initial predictive label given the user profile as an input and applies the derived function to the initial predictive label to generate a predictive label for the user profile as an output (step 916). For example, this may correspond to one or more operations similar or equivalent to one or more operations performed by the first machine learning model in conjunction with the MPC cluster such that the first machine learning model continues to perform in response to the input (in the case of binary classification) applying the corresponding transformation f to the sum of the true labels of the k nearest neighbor user profiles. In the case of multi-class classification, the transformation f may represent one of w different functions, the MPC cluster configuring the first machine-learned model to be applied to a respective one of w different values in a vector or set corresponding to the w different classes. As described above, each of the w different values may correspond to a frequency value.
In the case where steps 912-916 have been performed and the first machine learning model has been configured in this manner, the data generated in step 920 and subsequently utilized, for example, in step 930, may not be used to predict the true label (L) i )。
Referring again to fig. 8, in some implementations, the process 800 may include one or more steps corresponding to one or more of the operations described above with reference to fig. 9-11.
In some implementations, the process 800 further includes one or more operations in which the MPC cluster evaluates the performance of the first machine learning model. For example, this may correspond to one or more operations similar or equivalent to the one or more operations performed in connection with the MPC cluster performing step 920 as described above with reference to fig. 9. In these embodiments, to evaluate the performance of the first machine learning model, for each of a plurality of user profiles, the MPC cluster determines a predictive label for the user profile based at least in part on: (i) a user profile, (ii) a first machine learning model, and (iii) one or more of a plurality of real labels of the plurality of user profiles, and determining a residual value of the user profile indicative of a prediction error in the prediction label based at least in part on the prediction label determined for the user profile and a real label of the user profile included in the plurality of real labels. This may correspond to one or more operations similar or equivalent to the one or more operations performed in connection with the MPC cluster performing steps 1108-1106 as described above with reference to fig. 11, for example. Additionally, in these embodiments, the process 800 further includes one or more operations in which the MPC cluster trains a second machine learning model using data indicative of residual values determined for the plurality of user profiles in evaluating the performance of the first machine learning model. For example, this may correspond to one or more operations similar or equivalent to the one or more operations performed in connection with the MPC cluster performing step 930 as described above with reference to fig. 9.
In at least some of the above embodiments, the residual value of the user profile is indicative of a difference in value between a predicted tag determined for the user profile and a true tag of the user profile. This may be the case, for example, where an example of a regression technique is employed.
In at least some of the above embodiments, before the MPC cluster evaluates the performance of the first machine learning model, the process 800 further includes one or more operations in which the MPC cluster derives a function based at least in part on the plurality of truth labels and configures the first machine learning model to use the function to generate, given the user profile as an input, a predicted label for the user profile as an output. This may correspond to one or more operations similar or equivalent to the one or more operations performed in connection with the MPC cluster performing steps 914 and 916 as described above with reference to fig. 9, for example. Thus, in some embodiments, to derive the function at this step, the MPC cluster derives a set of parameters for the function, e.g., { a } 2 ，a 1 ，a 0 }。
In at least some of the above embodiments, the process 800 further includes one or more operations in which the MPC cluster estimates a set of distribution parameters based at least in part on the plurality of truth labels. In such embodiments, to derive the function based at least in part on the plurality of true tags, the MPC cluster derives the function based at least in part on the estimated set of distribution parameters. For example, this may correspond to one or more operations similar to or the like performed in connection with the MPC cluster performing steps 912 and 914 as described above with reference to FIG. 9 One or more operations of the effect. Thus, the above-mentioned distribution parameter set can include one or more parameters of a probability distribution of the prediction error of the real tag of the first value among the plurality of real tags, for example, a mean (μ) of a normal distribution of the prediction error of the real tag of the first value among the plurality of real tags 0 ) Sum variance (σ) 0 ) And one or more parameters of a probability distribution of the prediction error of the genuine tag of a second value among the plurality of genuine tags, for example, a mean (μ) of a normal distribution of the prediction error of the genuine tag of a second different value among the plurality of genuine tags 1 ) Sum variance (σ) 1 ). As noted above, in some examples, the set of distribution parameters described above can include other types of parameters. Further, in at least some of the above embodiments, the function is a quadratic polynomial function, e.g., f (x) a 2 x 2 +a 1 x+a 0 Wherein f' (x) ═ 2a 2 x+a 1 。
In at least some of the above embodiments, to configure the first machine learning model to use a function to generate the predictive label of the user profile as an output given the user profile as an input, the MPC cluster configures the first machine learning model to, given the user profile as an input: (i) generating an initial predictive label for the user profile, and (ii) applying a function to the initial predictive label for the user profile to generate as output the predictive label for the user profile. For example, for an example in which a binary classification technique is employed, this may correspond to a case in which the MPC cluster configures the first machine learning model to, given the user profile as input: (i) calculating the sum of the true labels of the k nearest neighbor user profiles (sum of labels) and (ii) applying a function (transformation f) to the initial predicted labels of the user profiles to generate user profiles
As described above, in at least some of the above embodiments, to determine the predicted label based at least in part on the true label of each of the k nearest neighbor user profiles, the MPC cluster determines a set of predicted labels based at least in part on the set of true labels of each of the k nearest neighbor user profiles respectively corresponding to the set of classes, and to determine the set of predicted labels, the MPC cluster performs an operation for each class in the set. Such operations can include one or more operations in which the MPC cluster determines a frequency with which a real label corresponding to a category in the set of real labels of a user profile of the k nearest neighbor user profiles is a real label of a first value. For example, this may correspond to combining the first machine learning model 620 for obtaining at least one prediction index in one or more embodiments in which one or more multiclass classification techniques are employedStick 629
FIG. 12 is a flow diagram illustrating an example process 1200 for generating inferences of a user profile with increased performance at a computing system of an MPC cluster. One or more of the operations described with reference to fig. 12 may be performed, for example, at inferred times. At least some of the operations of the process 1200 can be implemented, for example, by a first computing system of an MPC cluster, such as the MPCs of the MPC cluster 130 of fig. 1 1 And can also correspond to one or more of the operations described above with reference to fig. 8. However, in process 1200, one or more operations can be performed on the secret shares to provide user data privacy protection. In general, "shares," as described below and elsewhere herein, may correspond in at least some embodiments to secret shares. Other configurations are possible. One or more of the operations described with reference to fig. 12 may be performed, for example, at inferred times.
A first computing system of the MPC cluster receives an inference request associated with a given user profile (step 1202). For example, this may correspond to an MPC in conjunction with MPC cluster 130 1 One or more operations performed by receiving an inference request from application 112 are similar or equivalent to one or more operations described above with reference to fig. 1. In some embodiments, this may correspond to one or more operations similar or equivalent to one or more operations performed in conjunction with step 802 as described above with reference to fig. 8.
The first computing system of the MPC cluster determines a prediction tag for a given user profile (steps 1204-1208). In some embodiments, this may correspond to one or more operations similar or equivalent to one or more operations performed in conjunction with step 804 as described above with reference to fig. 8. However, in steps 1204 and 1208, the determination of the predictive tag for a given user profile can be performed on secret shares in order to provide user data privacy protection. To determine the predictive label for the given user profile, the first computing system of the MPC cluster (i) determines a first share of the predictive label based at least in part on the first share of the given user profile, a first machine learning model trained using the plurality of user profiles, and one or more of the plurality of real labels of the plurality of user profiles (step 1204), (ii) receives, from the second computing system of the MPC cluster, data indicative of a second share of the predictive label determined by the second computing system of the MPC cluster based at least in part on the second share of the given user profile and the first set of one or more machine learning models, and (iii) determines the predictive label based at least in part on the first and second shares of the predictive label (step 1208). For example, the second computing system of the MPC cluster may correspond to the MPCs of MPC cluster 130 of fig. 1 2 。
In this example, the plurality of true tags of the plurality of user profiles may correspond to the true tags included as part of the encrypted tag data 626, which are the true tags of the plurality of user profiles used to train and/or evaluate the first machine learning model 620. In some examples, the plurality of real tags may correspond to a share of another set of real tags. The one or more real tags from the plurality of real tags may include at least one real tag for each of the k nearest neighbor user profiles identified by the k-NN model 622 of the first machine learning model 620, where the determination of the predicted tag for a given user profile is based on the one or more real tags. In some examples, each of the plurality of authentic tags is encrypted, as is the case in the examples of fig. 6-7. Some of the various methods by which the k nearest neighbor user profiles can be used to determine predictive labels are described in detail above. As is apparent above, the method or manner in which such real labels are utilized to determine predictive labels may depend, at least in part, on the type of inference technique employed (e.g., regression techniques, binary classification techniques, multi-class classification techniques, etc.). Additional details regarding secret share exchanges that may be performed in association with k-NN computations are provided above with reference to fig. 1-5.
The first computing system of the MPC cluster determines prediction residual values indicative of the prediction error in the prediction tag (steps 1210-1214). In some embodiments, this may correspond to one or more operations similar or equivalent to one or more operations performed in conjunction with step 806 as described above with reference to fig. 8. However, in steps 1210 and 1214, the determination of the prediction residual value can be performed on the secret share in order to provide user data privacy protection. To determine the predicted residual values, the first computing system of the MPC cluster (i) determines a first share of the predicted residual values for the given user profile based at least in part on the first share of the given user profile and a second machine-learned model trained using the plurality of user profiles and data indicative of differences between a plurality of real labels of the plurality of user profiles and a plurality of predicted labels determined for the plurality of user profiles using the first machine-learned model (step 1210), (ii) receives data from the second computing system of the MPC cluster indicative of a second share of the predicted residual values for the given user profile determined by the second computing system of the MPC cluster based at least in part on the second share of the given user profile and a second set of one or more machine-learned models (step 1212), and (iii) based at least in part on the first share and the second share of the predicted residual values, to determine the prediction residual values for a given user profile (step 1214).
The first computing system of the MPC cluster generates data representing the inference result based on the prediction labels and the prediction residual values (step 1216). In some embodiments, this may correspond to one or more operations similar or equivalent to one or more operations performed in conjunction with step 808 as described above with reference to fig. 8. Thus, in some examples, the inference result includes or corresponds to a sum of the prediction tag and the prediction residual value.
The first computing system of the MPC cluster provides data representing the inference to the client device (step 1218). In some embodiments, this may correspond to one or more operations similar or equivalent to one or more operations performed in conjunction with step 810 as described above with reference to fig. 8. For example, this may correspond to one or more operations similar or equivalent to one or more operations performed in connection with MPC cluster 130 providing inferred results to client device 110 on which application 112 is running, as described above with reference to fig. 1-2.
In some implementations, the process 1200 further includes one or more operations in which the first computing system of the MPC cluster applies the transformation to the first share of the given user profile to obtain a first transformed share of the given user profile. In these embodiments, to determine the predictive label, the first computing system of the MPC cluster determines a first share of the predictive label based at least in part on the first transformed share of the given user profile. For example, this may correspond to use in conjunction with random projection logic 610 to apply a random projection transform to a user profile 609 (P) i ) To obtain a transformed user profile 619 (P) i ') one or more operations similar or equivalent to the one or more operations performed above with reference to figures 6-8.
In at least some of the above embodiments, to determine the first share of the predictive tag, the first computing system of the MPC cluster provides the first transformed share of the given user profile as an input to the first machine learning model to obtain the first share of the predictive tag of the given user profile as an output. For example, this may correspond to receiving the transformed user profile 619 (P) in conjunction with the first machine learning model 620 i ') as input and in response thereto generate at least one predictive tag 629
In some examples, the transformation may be a random projection. Further, in at least some of these examples, the aforementioned random projection may be a Johnson-lindenstruss (J-L) transform.
In some embodiments, to apply the J-L transform, the MPC cluster can generate a projection matrix R of the ciphertext. To make n dimension P i Projected into the k dimension, the MPC cluster can generate an n × k random matrix R. For example, a first computing system (e.g., MPC) 1 ) It is possible to create an n × k random matrix A with a 50% probability of A i，j 1, 50% probability of A i，j 0. The first computing system can split A into two shares [ A 1 ]And [ A ] 2 ]Discard A, keep secret [ A 1 ]And will [ A ] 2 ]To a second computing system (e.g. MPC) 2 ). Similarly, the second computing system can create an n × k random matrix B whose elements have the same distribution of elements of a. The second computing system can split B into two shares [ B 1 ]And [ B 2 ]Discard B, keep secret [ B 2 ]And will [ B ] 1 ]To the first computing system.
Then, the first computing system can compare [ R [ ] 1 ]Calculated as 2 × ([ A ] 1 ]＝＝[B 1 ]) -1. Similarly, the second computing system can compare [ R [ ] 2 ]Calculated as 2 × ([ A ] 2 ]＝＝[B 2 ]) -1. Thus, [ R ] 1 ]And [ R ] 2 ]Are two secret shares of R whose elements are 1 or-1 with equal probability.
Actual random projection of P in dimension 1 × n i And the secret share of the projection matrix R of dimension n x k to produce a 1 x k result. Assuming n > k, the J-L transform reduces the dimensionality of the training data from n to k. To perform the above projection in the encrypted data, the first computing system can calculate [ P [ ] i，1 ]⊙[R i，1 ]This requires multiplication between two shares and addition between two shares.
As described above, in some embodiments, the first machine learning model comprises a k-nearest neighbor model maintained by a first computing system of the MPC cluster and the first set of one or more machine learning models comprises a k-nearest neighbor model maintained by a second computing system of the MPC cluster. In some examples, the two aforementioned k-nearest neighbor models may be identical or nearly identical to each other. That is, in some examples, the first and second computing systems maintain copies of the same k-NN model, and each copy stores their own share of the real tags. In some examples, a model rooted at one or more prototype methods may be implemented in place of one or both of the k-nearest neighbor models described above.
In at least some of these embodiments, to determine the predictive label, the first computing system of the MPC cluster (i) identifies a first set of nearest neighbor user profiles based at least in part on the first share of the given user profile and a k-nearest neighbor model maintained by the first computing system of the MPC cluster, (ii) receives, from the second computing system of the MPC cluster, data indicative of a second set of nearest neighbor profiles identified by the second computing system of the MPC cluster based at least in part on the second share of the given user profile and the k-nearest neighbor model maintained by the second computing system of the MPC cluster, (iii) identifies k nearest neighbor user profiles of the plurality of user profiles that are deemed most similar to the given user profile based at least in part on the first set and the second set of nearest neighbor user profiles, and determining a first share of predicted labels based at least in part on the real labels of each of the k nearest neighbor user profiles. For example, this can correspond to combining the first machine learning model 620 for obtaining at least one predictive label 629 in one or more embodiments in which one or more regression and/or binary classification techniques are employed
In some of the above embodiments, to determine the first share of predicted labels, the first computing system of the MPC cluster (i) determines a first share of the sum of the real labels of the k nearest neighbor user profiles, (ii) receives a second share of the sum of the real labels of the k nearest neighbor user profiles from the second computing system of the MPC cluster, and (iii) is based at least in part on the k nearest neighbor user profilesThe first and second shares of the sum of the real tags of the profile determine the sum of the real tags of the k nearest neighbor user profiles. For example, this can correspond to obtaining at least one predictive label 629 for use in conjunction with the first machine learning model 620 in one or more embodiments in which one or more multi-class classification techniques are employed
In some embodiments, the second machine learning model includes at least one of a Deep Neural Network (DNN), a Gradient Boosting Decision Tree (GBDT), and a random forest model maintained by the first computing system of the MPC cluster, and the second set of one or more machine learning models includes at least one of a DNN, a GBDT, and a random forest model maintained by the second computing system of the MPC cluster. In some examples, the two models maintained by the first and second computing systems (e.g., DNNs, GBDTs, random forest models, etc.) may be the same or nearly the same as each other.
In some implementations, the process 1200 further includes one or more operations in which the MPC cluster evaluates performance of the first machine learning model and trains the second machine learning model using data indicative of the predicted residual values determined for the plurality of user profiles when evaluating performance of the first machine learning model. For example, this may correspond to one or more operations similar or equivalent to one or more operations performed in connection with the MPC cluster performing step 920 as described above with reference to fig. 8-9. However, in such embodiments, one or more operations can be performed on the secret share in order to provide user data privacy protection. In these embodiments, to evaluate the performance of the first machine learning model, for each of a plurality of user profiles, the MPC cluster determines a prediction label for the user profile and determines a residual value for the user profile that is indicative of a prediction error in the prediction label. To determine the predictive label of the user profile, a first computing system of the MPC cluster (i) determines a first share of the predictive label of the user profile based at least in part on the first share of the user profile, the first machine learning model, and one or more of the plurality of real labels of the plurality of user profiles, (ii) receives data from a second computing system of the MPC cluster indicating a second share of the predictive label of the user profile determined by the second computing system of the MPC cluster based at least in part on the second share of the user profile and a first set of one or more machine learning models maintained by the second computing system of the MPC cluster, and (iii) determines the predictive label of the user profile based at least in part on the first share and the second share of the predictive label. To determine residual values of the user profile indicative of errors in the prediction labels, a first computing system of the MPC cluster (i) determines a first share of residual values of the user profile based at least in part on the prediction labels determined for the user profile and a first share of true labels of the user profile included in the plurality of true labels, (ii) receives data from a second computing system of the MPC cluster indicative of a second share of residual values of the user profile determined by a second computing system of the MPC cluster based at least in part on the prediction labels determined for the user profile and a second share of true labels of the user profile, and (iii) determines residual values of the user profile based at least in part on the first and second shares of residual values. For example, this may correspond to one or more operations similar or equivalent to one or more operations performed in connection with the MPC cluster performing steps 1108 and 1106 as described above with reference to fig. 11. Additionally, in these embodiments, the process 1200 further includes one or more operations in which the MPC cluster trains a second machine learning model using data indicative of residual values determined for the plurality of user profiles in evaluating the performance of the first machine learning model. For example, this may correspond to one or more operations similar or equivalent to those performed in connection with the MPC cluster performing the one or more operations performed at step 930 as described above with reference to fig. 9.
In at least some of the above embodiments, the first share of the residual values of the user profile is indicative of a difference in values between a predicted label determined for the user profile by the first machine learning model and a first share of the true labels of the user profile, and the second share of the residual values of the user profile is indicative of a difference in values between a predicted label determined for the user profile by the first machine learning model and a second share of the true labels of the user profile. This may be the case, for example, where an example of a regression technique is employed.
In at least some of the above embodiments, before the MPC cluster evaluates the performance of the first machine learning model, the process 1200 further includes one or more operations in which the MPC cluster (i) derives a function and (ii) configures the first machine learning model to generate an initial predictive label for the user profile given the user profile as an input and applies the function to the initial predictive label for the user profile to generate a first share of the predictive label for the user profile as an output. This may correspond to one or more operations similar or equivalent to the one or more operations performed in connection with the MPC cluster performing steps 914 and 916 as described above with reference to fig. 8-9, for example. To derive the function, a first computing system of the MPC cluster (i) derives a first share of the function based at least in part on the first share of each of the plurality of real tags, (ii) receives, from a second computing system of the MPC cluster, data indicative of a second share of the function derived by a second computing system of the MPC cluster based at least in part on the second share of each of the plurality of real tags, and (iii) derives the function based at least in part on the first share and the second share of the function. For example, for an example in which a binary classification technique is employed, this may correspond to a case in which the MPC cluster configures the first machine learning model to, given the user profile as input: (i) calculating a sum of the true labels (sum of labels) of the k nearest neighbor user profiles, and (ii) applying a function (transformation f) to the initial predictive labels of the user profiles to generate the predictive labels of the user profiles
When implemented on secret shares, the first computing system (e.g., the first computing system)Such as MPC 1 ) It is possible to calculate:
[count 0，1 ]＝∑ i (1-[L i，1 ])
similarly, when implemented on a secret share, a second computing system (e.g., MPC) 2 ) It is possible to calculate:
[count 0，2 ]＝∑ i (1-[L i，2 ])
the MPC cluster can then reconstruct sum as described in plain text above 0 、count 0 、sum_of_square 0 And calculating the distribution
Similarly, to calculate the distribution
[count 1，1 ]＝∑ i [L i，1 ]
and, a second computing system (e.g., MPC) 2 ) It is possible to calculate:
[count 1，2 ]＝∑ i [L i，2 ]
the MPC cluster may then reconstruct sum as described above in the specification 1 、count 1 、sum_of_square 1 And calculating the distribution
In at least some of the above embodiments, the MPC cluster can employ one or more fixed point computation techniques to determine the residual value for each user profile when evaluating the performance of the first machine learning model. More specifically, when evaluating the performance of the first machine learning model, to determine a first share of the residual values for each user profile, the first computing system of the MPC cluster scales the corresponding true label or its share by a particular scaling factor by which the coefficient { a } associated with the function is scaled 2 ，a 1 ，a 0 And the scaled coefficients are rounded to the nearest integer. In such an embodiment, a second computing system of the MPC cluster may perform similar operations to determine a second share of the residual values for each user profile. The MPC cluster can thus compute the residual values using the secret shares, reconstruct the plaintext residual values from the two secret shares, and divide the plaintext residual values by the scaling factor.
In at least some of the above embodiments, the process 1200 further comprises wherein the MPCThe first computing system of the cluster estimates one or more operations to distribute the first share of the parameter set based at least in part on the first component of each of the plurality of genuine tags. In some such embodiments, to derive the first share of the function based at least in part on the first share of each of the plurality of real tags, the first computing system of the MPC cluster derives the first share of the function based at least in part on the first share of the set of distribution parameters. This may correspond to one or more operations similar or equivalent to the one or more operations performed in connection with the MPC cluster performing steps 912-914 as described above with reference to fig. 8-9, for example. Thus, the above-mentioned distribution parameter set can include one or more parameters of a probability distribution of the prediction error of the real tag of the first value among the plurality of real tags, for example, a mean (μ) of a normal distribution of the prediction error of the real tag of the first value among the plurality of real tags 0 ) Sum variance (σ) 0 ) And one or more parameters of a probability distribution of the prediction error of the real label of a second value of the plurality of real labels, e.g., a mean (μ) of a normal distribution of the prediction error of the real label of a second different value of the plurality of real labels 1 ) Sum variance (σ) 1 ). As described above, in some examples, the set of distribution parameters described above can include other types of parameters. Further, in at least some of the above embodiments, the function is a quadratic polynomial function, e.g., f (x) a 2 x 2 +a 1 x+a 0 Wherein f' (x) ═ 2a 2 x+a 1 Although other functions may be employed in some examples.
In some examples, to determine the first share of the predicted tags, the first computing system of the MPC cluster (i) determines a first share of the sum of the real tags of the k nearest neighbor user profiles, (ii) receives a second share of the sum of the real tags of the k nearest neighbor user profiles from the second computing system of the MPC cluster, and (iii) determines the sum of the real tags of the k nearest neighbor user profiles based at least in part on the first share and the second share of the sum of the real tags of the k nearest neighbor user profiles. This may be, for example, where regression or binary classification techniques are employed An embodiment of (1). In some of the above examples, the first share of predicted labels may correspond to a sum of the real labels of the k nearest neighbor user profiles. This may be, for example, for a system in which regression classification techniques are employed
As described above, in some of the above embodiments, to determine the first share of the predicted tag based at least in part on the real tag of each of the k nearest neighbor user profiles, the first computing system of the MPC cluster determines the first share of the predicted tag set based at least in part on the real tag set of each of the k nearest neighbor user profiles corresponding to the class set. To determine a first share of the set of predicted tags, for each category in the set, the first computing system of the MPC cluster (i) determines a first share of frequencies at which real tags corresponding to a category in the set of real tags for a user profile in the k nearest neighbor user profiles are the real tags of the first value, (ii) receives a second share of frequencies at which real tags corresponding to a category in the set of real tags for a user profile in the k nearest neighbor user profiles are the real tags of the first value, and (iii) determine a frequency that a real tag corresponding to a category in the set of real tags for the user profile of the k nearest neighbor user profiles is a real tag of the first value based at least in part on the first share and the second share of the frequency that a real tag corresponding to a category in the set of real tags for the user profile of the k nearest neighbor user profiles is a real tag of the first value. Such operations can include a first computing system of the MPC cluster determining the k most recent One or more operations of a frequency at which a real tag corresponding to a category in a set of real tags of a user profile in a neighbor user profile is a real tag of a first value. For example, this can correspond to obtaining at least one predictive label 629 in one or more embodiments in conjunction with the first machine learning model 620 for employing one or more multi-class classification techniques therein
In at least some of the above embodiments, to determine the first share of the set of predicted labels, for each category in the set, the first computing system of the MPC cluster applies a function corresponding to the category to a frequency of real labels for which a real label corresponding to the category in the set of real labels for a user profile in the k nearest neighbor user profiles is the first value to generate the first share of predicted labels corresponding to the category for the given user profile. For example, the respective function may correspond to one of w different functions derived by the MPC cluster for w different classes, as described above with reference to step 914 of fig. 8-9.
For multi-class classification problems, when evaluating the performance (e.g., quality) of the first machine learning model, for each training example/query, the MPC cluster can find the k nearest neighbors and calculate the frequency of their labels on secret shares.
For example, consider a classification problem where it is assumed for multiple classes l 1 ，l 2 ，...l w There are w examples of valid labels (e.g., classes). In the group of { id 1 ，id 2 ，...id k In k neighbors of the identification, a first computing system (e.g., MPC) 1 ) The frequency of the jth tag can be calculated as [ l ] as follows j，1 ]：
The first computing system can calculate the frequency [ label ] according to the following formula of the real label 1 ]：
[expected_frequency j，1 ]＝k×([label 1 ]＝＝j)
Thus, the first computing system is able to compute:
[Residue j，1 ]＝[expected_frequency j，1 ]-[frequency j，1 ]
and, [ Residue j，1 ]Equivalent to:
similarly, a second computing system (e.g., MPC) 2 ) It is possible to calculate:
in the case of binary classification and regression, the residual values can be a numeric type of secret message for each inference. Conversely, in the case of multi-class classification, for each inference, the residual values can be a secret message of a vector of values, as shown above.
FIG. 13 is a block diagram of an example computer system 1300 that can be used to perform the operations described above. System 1300 includes a processor 1310, a memory 1320, a storage device 1330, and an input/output device 1340. Each of the components 1310, 1320, 1330, and 1340 can be interconnected, for example, using a system bus 1350. The processor 1310 is capable of processing instructions for execution within the system 1300. In some implementations, the processor 1310 is a single-threaded processor. In another implementation, the processor 1310 is a multi-threaded processor. The processor 1310 is capable of processing instructions stored in the memory 1320 or on the storage device 1330.
The storage device 1330 can provide mass storage for the system 1300. In some implementations, the storage device 1330 is a computer-readable medium. In various different implementations, the storage device 1330 can include, for example, a hard disk device, an optical disk device, a storage device shared by multiple computing devices over a network (e.g., a cloud storage device), or some other mass storage device.
The input/output device 1340 provides input/output operations for the system 1300. In some implementations, the input/output devices 1340 can include one or more of the following: network interface devices, such as an ethernet card, serial communication devices, such as, and RS-232 port, and/or wireless interface devices, such as, and 802.11 card. In another embodiment, the input/output devices can include driver devices configured to receive input data and send output data to external devices 1360, such as keyboards, printers, and display devices. However, other implementations can also be used, such as mobile computing devices, mobile communication devices, set-top box television client devices, and so forth.
Although an example processing system is depicted in FIG. 13, implementations of the subject matter and the functional operations described in this specification can be implemented in other types of digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them.
Embodiments of the subject matter and the operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions, encoded on a computer storage medium (or multiple media) for execution by, or to control the operation of, data processing apparatus. Alternatively or in addition, the program instructions can be encoded on an artificially generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by the data processing apparatus. The computer storage medium can be or be included in a computer-readable storage device, a computer-readable storage substrate, a random or serial access memory array or device, or a combination of one or more of them. Further, although the computer storage medium is not a propagated signal, the computer storage medium can be a source or destination of computer program instructions encoded in an artificially generated propagated signal. The computer storage medium can also be or be included in one or more separate physical components or media (e.g., multiple CDs, disks, or other storage devices).
The operations described in this specification can be implemented as operations performed by data processing apparatus on data stored on one or more computer-readable storage devices or received from other sources.
The term "data processing apparatus" encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, a system on a chip, or a plurality or combination of the foregoing. The apparatus can comprise special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit). The apparatus can include, in addition to hardware, code that creates a runtime environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, a cross-platform runtime environment, a virtual machine, or a combination of one or more of them. The apparatus and operating environment are capable of implementing a variety of different computing model infrastructures, such as web services, distributed computing and grid computing infrastructures.
A computer program (also known as a program, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, object, or other unit suitable for use in a computing environment. The computer program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.
The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform actions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for performing actions in accordance with the instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a Personal Digital Assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., a Universal Serial Bus (USB) flash drive), to name a few. Devices suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, such as internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can also be used to provide for interaction with the user; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input. In addition, the computer is able to interact with the user by sending and receiving documents to and from the device used by the user; for example, by sending a web page to a web browser on a user's client device in response to a request received from the web browser.
Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described is this specification, or any combination of one or more such back-end, middleware, or front-end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network ("LAN") and a wide area network ("WAN"), an internetwork (e.g., the internet), and a peer-to-peer network (e.g., an ad hoc peer-to-peer network).
The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other. In some embodiments, the server transmits data (e.g., HTML pages) to the client device (e.g., for the purpose of displaying data to a user interacting with the client device and receiving user input from the user). Data generated at the client device (e.g., a result of the user interaction) can be received at the server from the client device.
While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any inventions or of what may be claimed, but rather as descriptions of features specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.
Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In some cases, multitasking and parallel processing may be advantageous. Moreover, the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
Thus, particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. In some cases, the actions recited in the claims can be performed in a different order and still achieve desirable results. In addition, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In some embodiments, multitasking and parallel processing may be advantageous.
Claims (22)
1. A computer-implemented method, comprising:
receiving, by a first computing system of a plurality of multi-party computing (MPC) computing systems, an inference request comprising a first share of a given user profile;
Determining a predictive label for the given user profile based at least in part on a first machine learning model trained using a plurality of user profiles;
determining prediction residual values for the given user profile indicative of prediction errors in the prediction labels, comprising:
determining, by the first computing system, a first share of the prediction residual values for the given user profile based at least in part on the first share of the given user profile and a second machine learning model trained using the plurality of user profiles and data indicative of differences between a plurality of real labels of the plurality of user profiles and a plurality of predicted labels determined for the plurality of user profiles using the first machine learning model;
receiving, by the first computing system from a second computing system of the plurality of MPC computing systems, data indicative of a second share of the prediction residual values for the given user profile determined by the second computing system based at least in part on the second share of the given user profile and a second set of one or more machine learning models; and
determining the prediction residual value for the given user profile based at least in part on the first and second shares of the prediction residual value;
Generating, by the first computing system, a first share of an inference result based at least in part on the prediction labels and the prediction residual values determined for the given user profile; and
providing, by the first computing system to a client device, the first share of the inference result and a second share of the inference result received from the second computing system.
2. The computer-implemented method of claim 1, wherein determining the predictive label for the given user profile comprises:
determining, by the first computing system, a first share of the predictive tag based at least in part on: (i) a first share of the given user profile, (ii) the first machine learning model trained using the plurality of user profiles, and (iii) one or more real tags of the plurality of user profiles, the plurality of real tags including one or more real tags of each user profile of the plurality of user profiles;
receiving, by the first computing system from the second computing system, data indicative of a second share of the predictive label determined by the second computing system based at least in part on the second share of the given user profile and the first set of one or more machine learning models; and
Determining the predictive label based at least in part on the first share and the second share of the predictive label.
3. The computer-implemented method of any preceding claim, further comprising:
applying, by the first computing system, a transformation to the first share of the given user profile to obtain a first transformed share of the given user profile, wherein determining, by the first computing system, the first share of the predictive tag comprises:
determining, by the first computing system, a first share of the predictive tag based at least in part on the first transformed share of the given user profile.
4. The computer-implemented method of claim 3, wherein the transform comprises a Johnson-lindenstruss (J-L) transform.
5. The computer-implemented method of claim 3, wherein determining, by the first computing system, the first share of the predictive tag comprises:
providing, by the first computing system, the first transformed share of the given user profile as input to the first machine learning model to obtain as output a first share of the predictive label for the given user profile.
6. The computer-implemented method of any preceding claim, further comprising:
evaluating performance of the first machine learning model, including, for each of the plurality of user profiles:
determining a predictive label for the user profile, comprising:
determining, by the first computing system, a first share of a predictive tag of the user profile based at least in part on: (i) a first share of the user profile, (ii) the first machine learning model, and (iii) one or more of the plurality of real tags of the plurality of user profiles;
receiving, by the first computing system from the second computing system, data indicative of a second share of the predictive label of the user profile determined by the second computing system based at least in part on a second share of the user profile and the first set of one or more machine learning models maintained by the second computing system; and
determining the predictive label for the user profile based at least in part on the first and second shares of the predictive label;
determining a residual value of the user profile indicative of an error in the prediction tag, comprising:
Determining, by the first computing system, a first share of the residual values for the user profile based at least in part on the predicted tag determined for the user profile and a first share of real tags included in the plurality of real tags for the user profile;
receiving, by the first computing system from the second computing system, data indicative of a second share of the residual values of the user profile determined by the second computing system based at least in part on the predicted tag determined for the user profile and a second share of the real tag of the user profile; and
determining the residual value of the user profile based at least in part on the first and second shares of the residual value; and
training the second machine learning model using data indicative of the residual values determined for the plurality of user profiles when evaluating the performance of the first machine learning model.
7. The computer-implemented method of claim 6, further comprising:
prior to evaluating the performance of the first machine learning model:
a set of parameters of a derivation function, comprising:
Deriving, by the first computing system, a first share of the set of parameters of the function based at least in part on a first share of each of the plurality of real tags;
receiving, by the first computing system from the second computing system, data indicative of a second share of the set of parameters of the function derived by the second computing system based at least in part on the second share of each of the plurality of real tags; and
deriving the set of parameters of the function based at least in part on the first and second shares of the set of parameters of the function; and
configuring the first machine learning model to generate an initial predictive label for a user profile given the user profile as an input and apply the function as defined based on the derived set of parameters to the initial predictive label of the user profile to generate a first share of predictive labels for the user profile as an output.
8. The computer-implemented method of claim 7, further comprising:
estimating, by the first computing system, a first share of a set of distribution parameters based at least in part on the first share of each of the plurality of real tags, wherein deriving, by the first computing system, the first share of the set of parameters of the function based at least in part on the first share of each of the plurality of real tags comprises:
Deriving, by the first computing system, a first share of the set of parameters of the function based at least in part on the first share of the set of distribution parameters.
9. The computer-implemented method of claim 8, wherein the set of distribution parameters includes one or more parameters of a probability distribution of prediction errors for a real tag of a first value of the plurality of real tags and one or more parameters of a probability distribution of prediction errors for a real tag of a second value of the plurality of real tags, the second value different from the first value.
10. The computer-implemented method of claim 6, wherein:
the first share of the residual value of the user profile is indicative of a difference in value between the predicted tag determined for the user profile and the first share of the real tag of the user profile; and
the second share of the residual values for the user profile is indicative of a difference in value between the predicted tag determined for the user profile and the second share of the real tag for the user profile.
11. The computer-implemented method of any of claims 1 to 2, wherein:
The first machine learning model comprises a k-nearest neighbor model maintained by the first computing system;
the first set of one or more machine learning models comprises a k-nearest neighbor model maintained by the second computing system;
the second machine learning model comprises at least one of: a Deep Neural Network (DNN) maintained by the first computing system and a Gradient Boosting Decision Tree (GBDT) maintained by the first computing system; and
the second set of one or more machine learning models includes at least one of: a DNN maintained by the second computing system and a GBDT maintained by the second computing system.
12. The computer-implemented method of claim 11, wherein determining, by the first computing system, the first share of the predictive tag comprises:
identifying, by the first computing system, a first set of nearest neighbor user profiles based at least in part on the first share of the given user profile and the k-nearest neighbor model maintained by the first computing system;
receiving, by the first computing system from the second computing system, data indicative of a second set of nearest neighbor profiles identified by the second computing system based at least in part on the second share of the given user profile and the k-nearest neighbor model maintained by the second computing system;
Identifying k nearest neighbor user profiles of the plurality of user profiles that are deemed to be most similar to the given user profile based at least in part on the first set and the second set of nearest neighbor user profiles; and
determining, by the first computing system, the first share of the predicted labels based at least in part on real labels of each of the k nearest neighbor user profiles.
13. The computer-implemented method of claim 12, wherein determining, by the first computing system, the first share of the predictive tag further comprises:
determining, by the first computing system, a first share of the sum of the real labels of the k nearest neighbor user profiles;
receiving, by the first computing system from the second computing system, a second share of the sum of the real labels of the k nearest neighbor user profiles; and
determining the sum of the real tags of the k nearest neighbor user profiles based at least in part on the first share and the second share of the sum of the real tags of the k nearest neighbor user profiles.
14. The computer-implemented method of claim 13, wherein determining, by the first computing system, the first share of the predictive tag further comprises:
Applying a function to the sum of the real labels of the k nearest neighbor user profiles to generate the first share of the predicted labels for the given user profile.
15. The computer-implemented method of claim 13, wherein the first share of the predictive labels for the given user profile comprises the sum of the real labels for the k nearest neighbor user profiles.
16. The computer-implemented method of claim 12, wherein determining, by the first computing system, the first share of the predictive tag based at least in part on the real tag of each of the k nearest neighbor user profiles comprises:
determining, by the first computing system, a first share of a set of predicted tags based at least in part on a set of real tags respectively corresponding to each of the k nearest neighbor user profiles of a set of categories, including, for each category in the set:
determining a first share of a frequency with which real tags corresponding to the category in the set of real tags of a user profile of the k nearest neighbor user profiles are real tags of a first value;
Receiving, by the first computing system from the second computing system, a second share of frequencies at which real tags corresponding to the category in the set of real tags of a user profile of the k nearest neighbor user profiles are real tags of the first value; and
determining a frequency that a real tag corresponding to the category in the set of real tags for a user profile of the k nearest neighbor user profiles is the first value of real tags based at least in part on the first and second shares of the frequency that a real tag corresponding to the category in the set of real tags for a user profile of the k nearest neighbor user profiles is the first value of real tags.
17. The computer-implemented method of claim 16, wherein determining, by the first computing system, the first quota of the set of predicted tags comprises, for each category in the set:
applying a function corresponding to the category to a frequency at which a real label corresponding to the category in the set of real labels for a user profile of the k nearest neighbor user profiles is a real label of the first value to generate a first share of predicted labels corresponding to the category for the given user profile.
18. The computer-implemented method of claim 1, wherein the client device computes the given user profile using a plurality of feature vectors, each feature vector of the plurality of feature vectors comprising a feature value related to an event of a user of the client device and a decay rate of each feature vector.
19. The computer-implemented method of claim 1, wherein the client device computes the given user profile using a plurality of feature vectors, each feature vector of the plurality of feature vectors comprising feature values related to an event of a user of the client device, wherein computing the given user profile comprises:
classifying one or more of the plurality of feature vectors as sparse feature vectors; and
classifying one or more of the plurality of feature vectors as dense feature vectors, the method further comprising:
generating the first share of the given user profile and a respective second share of the given user profile for the one or more second computing systems using the sparse feature vector and the dense feature vector, wherein generating the first share and the respective one or more second shares of the given user profile comprises partitioning the sparse feature vector using a functional secret shared shares (FSS) technique.
20. A system, comprising:
one or more processors; and
one or more storage devices storing instructions that, when executed by the one or more processors, cause the one or more processors to perform the method of any preceding claim.
21. A computer-readable storage medium carrying instructions that, when executed by one or more processors, cause the one or more processors to perform the method of any one of claims 1-19.
22. A computer program product comprising instructions which, when executed by a computer, cause the computer to perform the steps of the method according to any one of claims 1 to 19.
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
IL277910 | 2020-10-09 | ||
IL277910A IL277910A (en) | 2020-10-09 | 2020-10-09 | Privacy preserving machine learning via gradient boosting |
PCT/US2021/054183 WO2022076826A1 (en) | 2020-10-09 | 2021-10-08 | Privacy preserving machine learning via gradient boosting |
Publications (1)
Publication Number | Publication Date |
---|---|
CN114930357A true CN114930357A (en) | 2022-08-19 |
Family
ID=81126088
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN202180007358.5A Pending CN114930357A (en) | 2020-10-09 | 2021-10-08 | Privacy preserving machine learning via gradient boosting |
Country Status (7)
Country | Link |
---|---|
US (1) | US20230034384A1 (en) |
EP (1) | EP4058951A1 (en) |
JP (1) | JP7361928B2 (en) |
KR (1) | KR20220101671A (en) |
CN (1) | CN114930357A (en) |
IL (1) | IL277910A (en) |
WO (1) | WO2022076826A1 (en) |
Families Citing this family (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US11695772B1 (en) * | 2022-05-03 | 2023-07-04 | Capital One Services, Llc | System and method for enabling multiple auxiliary use of an access token of a user by another entity to facilitate an action of the user |
CN116388954B (en) * | 2023-02-23 | 2023-09-01 | 西安电子科技大学 | General secret state data security calculation method |
CN117150551B (en) * | 2023-09-04 | 2024-02-27 | 东方魂数字科技(北京)有限公司 | User privacy protection method and system based on big data |
Family Cites Families (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
JP6556659B2 (en) | 2016-05-17 | 2019-08-07 | 日本電信電話株式会社 | Neural network system, share calculation device, neural network learning method, program |
EP4220464A1 (en) | 2017-03-22 | 2023-08-02 | Visa International Service Association | Privacy-preserving machine learning |
WO2019048390A1 (en) | 2017-09-07 | 2019-03-14 | Koninklijke Philips N.V. | A multi-party computation system for learning a classifier |
-
2020
- 2020-10-09 IL IL277910A patent/IL277910A/en unknown
-
2021
- 2021-10-08 KR KR1020227019999A patent/KR20220101671A/en unknown
- 2021-10-08 JP JP2022537713A patent/JP7361928B2/en active Active
- 2021-10-08 CN CN202180007358.5A patent/CN114930357A/en active Pending
- 2021-10-08 EP EP21802114.5A patent/EP4058951A1/en active Pending
- 2021-10-08 WO PCT/US2021/054183 patent/WO2022076826A1/en unknown
- 2021-10-08 US US17/786,006 patent/US20230034384A1/en active Pending
Also Published As
Publication number | Publication date |
---|---|
KR20220101671A (en) | 2022-07-19 |
JP2023509589A (en) | 2023-03-09 |
JP7361928B2 (en) | 2023-10-16 |
EP4058951A1 (en) | 2022-09-21 |
IL277910A (en) | 2022-05-01 |
WO2022076826A1 (en) | 2022-04-14 |
US20230034384A1 (en) | 2023-02-02 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US20230214684A1 (en) | Privacy preserving machine learning using secure multi-party computation | |
US20160004874A1 (en) | A method and system for privacy preserving matrix factorization | |
JP7361928B2 (en) | Privacy-preserving machine learning via gradient boosting | |
KR20160041028A (en) | A method and system for privacy preserving matrix factorization | |
Niu et al. | Toward verifiable and privacy preserving machine learning prediction | |
Liu et al. | Secure multi-label data classification in cloud by additionally homomorphic encryption | |
Lyu et al. | Towards fair and decentralized privacy-preserving deep learning with blockchain | |
JP7471445B2 (en) | Privacy-preserving machine learning for content delivery and analytics | |
WO2022072146A1 (en) | Privacy preserving centroid models using secure multi-party computation | |
JP7422892B2 (en) | Processing machine learning modeling data to improve classification accuracy | |
US20230078704A1 (en) | Privacy preserving machine learning labelling | |
Kaleli et al. | SOM-based recommendations with privacy on multi-party vertically distributed data | |
Datta et al. | Private data aggregation over selected subsets of users | |
Xu et al. | FedG2L: a privacy-preserving federated learning scheme base on “G2L” against poisoning attack | |
Jung | Ensuring Security and Privacy in Big Data Sharing, Trading, and Computing | |
Yang | Improving privacy preserving in modern applications | |
US20240163341A1 (en) | Privacy preserving centroid models using secure multi-party computation | |
Ma et al. | Blockchain-Based Privacy-Preserving Federated Learning for Mobile Crowdsourcing | |
Bao | Privacy-Preserving Cloud-Assisted Data Analytics | |
Tran et al. | A comprehensive survey and taxonomy on privacy-preserving deep learning | |
Mosher | Privacy and Fairness for Online Targeted Advertising | |
Hou et al. | Fine-Grained Access Control Proxy Re-encryption with HRA Security from Lattice | |
Khan et al. | Secure semantic search using deep learning in a blockchain-assisted multi-user setting | |
Ren et al. | Application: Privacy, Security, Robustness and Trustworthiness in Edge AI |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
SE01 | Entry into force of request for substantive examination |