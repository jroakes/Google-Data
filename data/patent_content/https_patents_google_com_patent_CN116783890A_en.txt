CN116783890A - Chroma transform type determination - Google Patents
Chroma transform type determination Download PDFInfo
- Publication number
- CN116783890A CN116783890A CN202180091033.XA CN202180091033A CN116783890A CN 116783890 A CN116783890 A CN 116783890A CN 202180091033 A CN202180091033 A CN 202180091033A CN 116783890 A CN116783890 A CN 116783890A
- Authority
- CN
- China
- Prior art keywords
- block
- chroma
- transform type
- luma
- transform
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
- 241000023320 Luma <angiosperm> Species 0.000 claims abstract description 296
- OSWPMRLSEDHDFF-UHFFFAOYSA-N methyl salicylate Chemical compound COC(=O)C1=CC=CC=C1O OSWPMRLSEDHDFF-UHFFFAOYSA-N 0.000 claims abstract description 296
- 208000037170 Delayed Emergence from Anesthesia Diseases 0.000 claims abstract description 101
- 230000001131 transforming effect Effects 0.000 claims abstract description 41
- 238000013139 quantization Methods 0.000 claims abstract description 33
- 238000000034 method Methods 0.000 claims description 128
- 238000000638 solvent extraction Methods 0.000 claims description 21
- 230000004044 response Effects 0.000 claims description 8
- 230000009466 transformation Effects 0.000 abstract description 15
- 238000004891 communication Methods 0.000 description 122
- 238000005192 partition Methods 0.000 description 44
- 230000008569 process Effects 0.000 description 17
- 238000001914 filtration Methods 0.000 description 15
- 238000012545 processing Methods 0.000 description 13
- 238000010586 diagram Methods 0.000 description 12
- 238000013500 data storage Methods 0.000 description 10
- 230000006835 compression Effects 0.000 description 7
- 238000007906 compression Methods 0.000 description 7
- 230000002123 temporal effect Effects 0.000 description 7
- 239000013598 vector Substances 0.000 description 7
- 239000011159 matrix material Substances 0.000 description 6
- 238000004590 computer program Methods 0.000 description 5
- 230000003287 optical effect Effects 0.000 description 5
- 230000005540 biological transmission Effects 0.000 description 4
- 230000006870 function Effects 0.000 description 4
- 230000008859 change Effects 0.000 description 3
- 238000003491 array Methods 0.000 description 2
- 230000001413 cellular effect Effects 0.000 description 2
- 230000001419 dependent effect Effects 0.000 description 2
- 238000013461 design Methods 0.000 description 2
- 229910001416 lithium ion Inorganic materials 0.000 description 2
- 238000012986 modification Methods 0.000 description 2
- 230000004048 modification Effects 0.000 description 2
- QELJHCBNGDEXLD-UHFFFAOYSA-N nickel zinc Chemical compound [Ni].[Zn] QELJHCBNGDEXLD-UHFFFAOYSA-N 0.000 description 2
- 230000011664 signaling Effects 0.000 description 2
- 230000003595 spectral effect Effects 0.000 description 2
- 238000012360 testing method Methods 0.000 description 2
- HBBGRARXTFLTSG-UHFFFAOYSA-N Lithium ion Chemical compound [Li+] HBBGRARXTFLTSG-UHFFFAOYSA-N 0.000 description 1
- OJIJEKBXJYRIBZ-UHFFFAOYSA-N cadmium nickel Chemical compound [Ni].[Cd] OJIJEKBXJYRIBZ-UHFFFAOYSA-N 0.000 description 1
- 229910052804 chromium Inorganic materials 0.000 description 1
- 238000003066 decision tree Methods 0.000 description 1
- 238000000354 decomposition reaction Methods 0.000 description 1
- 230000000694 effects Effects 0.000 description 1
- 230000008030 elimination Effects 0.000 description 1
- 238000003379 elimination reaction Methods 0.000 description 1
- 239000000835 fiber Substances 0.000 description 1
- 239000000446 fuel Substances 0.000 description 1
- 229910052987 metal hydride Inorganic materials 0.000 description 1
- 229910052759 nickel Inorganic materials 0.000 description 1
- PXHVJJICTQNCMI-UHFFFAOYSA-N nickel Substances [Ni] PXHVJJICTQNCMI-UHFFFAOYSA-N 0.000 description 1
- -1 nickel metal hydride Chemical class 0.000 description 1
- 230000009467 reduction Effects 0.000 description 1
- 239000004065 semiconductor Substances 0.000 description 1
- 239000007787 solid Substances 0.000 description 1
- 238000013519 translation Methods 0.000 description 1
- 230000014616 translation Effects 0.000 description 1
- 229910052720 vanadium Inorganic materials 0.000 description 1
Classifications
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/102—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or selection affected or controlled by the adaptive coding
- H04N19/12—Selection from among a plurality of transforms or standards, e.g. selection between discrete cosine transform [DCT] and sub-band transform or selection between H.263 and H.264
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/102—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or selection affected or controlled by the adaptive coding
- H04N19/103—Selection of coding mode or of prediction mode
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/102—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or selection affected or controlled by the adaptive coding
- H04N19/119—Adaptive subdivision aspects, e.g. subdivision of a picture into rectangular or non-rectangular coding blocks
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/102—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or selection affected or controlled by the adaptive coding
- H04N19/124—Quantisation
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/102—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or selection affected or controlled by the adaptive coding
- H04N19/13—Adaptive entropy coding, e.g. adaptive variable length coding [AVLC] or context adaptive binary arithmetic coding [CABAC]
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/134—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or criterion affecting or controlling the adaptive coding
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/169—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding
- H04N19/17—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding the unit being an image region, e.g. an object
- H04N19/172—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding the unit being an image region, e.g. an object the region being a picture, frame or field
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/169—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding
- H04N19/17—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding the unit being an image region, e.g. an object
- H04N19/176—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding the unit being an image region, e.g. an object the region being a block, e.g. a macroblock
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/169—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding
- H04N19/18—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding the unit being a set of transform coefficients
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/169—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding
- H04N19/186—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding the unit being a colour or a chrominance component
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/60—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using transform coding
- H04N19/61—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using transform coding in combination with predictive coding
Abstract
For a coded block of an image, a luminance prediction block is generated, a luminance residual block is generated, a quantized luminance block is generated after transforming the luminance residual block using a luminance transformation type, and the quantized luminance block is entropy-encoded. Generating a chroma prediction block, generating a chroma residual block, determining an initial chroma transform type of the chroma residual block as a luma transform type, generating a quantized chroma block using the chroma residual block transformed by a final chroma transform type, and entropy-encoding the quantized chroma block. When the initial chroma transform type is a transform type other than the default transform type, the final chroma transform type is the initial chroma transform type or the default transform type, and the quantization coefficients of the quantized chroma block depend on the quantization coefficients of the quantized luma block.
Description
Background
Digital images and video can be used, for example, over the internet to conduct a remote business meeting via video conferencing, high definition video entertainment, video advertising, or sharing of user-generated content. High performance compression may be advantageous for transmission and storage due to the large amount of data involved in transferring and processing image and video data.
Disclosure of Invention
The present application relates to encoding and decoding of image data, video stream data, or both, to enable transmission or storage. Disclosed herein are aspects of systems, methods, and apparatus for encoding and decoding, wherein a chroma transform type of a chroma block may be determined at an encoder using various techniques that are implicitly, explicitly, or both, identified to a decoder. The chroma blocks may be encoded such that the reconstructed chroma blocks are identical at the encoder and decoder regardless of how the chroma transform type is determined.
One aspect of the teachings herein is a method that includes partitioning a current image to be encoded into a plurality of compiled blocks. The method further includes, for a compiled block of the plurality of compiled blocks of the current image: generating a luminance prediction block for a luminance (luma) coding block including luminance (luma) information of the coding block; generating a luma residual block as a difference between the luma coded block and the luma prediction block; generating a quantized luminance block after transforming the luminance residual block using a luminance transform type; entropy encoding the quantized luma block into a bitstream; generating a chroma prediction block for a chroma (chroma) coded block that includes chroma (chroma) information for the coded block; generating a chroma residual block as a difference between the chroma coding block and the chroma prediction block; determining an initial chroma transform type of the chroma residual block as the luma transform type; generating a quantized chroma block using the chroma residual block transformed by a final chroma transform type; and entropy encoding the quantized chroma block into the bitstream. When the initial chroma transform type is a transform type other than a default transform type, the final chroma transform type is the initial chroma transform type or the default transform type, and the quantized coefficients of the quantized chroma block depend on the quantized coefficients of the quantized luma block.
Another aspect of the teachings herein is a method comprising: a bitstream is received, the bitstream comprising encoded coded blocks of a current image partitioned into a plurality of coded blocks. The coded blocks of the plurality of coded blocks are coded by the above method. The method receives the bitstream and entropy decodes the quantized luma block for an encoded coded block; generating a dequantized luminance block by dequantizing the quantized luminance block; generating the luminance residual block by transforming the dequantized luminance block using the luminance transform type; generating a luminance prediction block for the luminance coding block; generating the luma coding block by adding the luma prediction block to the luma residual block; entropy decoding the quantized chrominance blocks; generating a dequantized chroma block by dequantizing the quantized chroma block; determining a chroma transform type of the dequantized chroma block as the luma transform type; generating the chroma residual block by transforming the dequantized chroma block using the chroma transform type; generating a chroma prediction block for the chroma coding block; generating the chroma coding block by adding the chroma prediction block to the chroma residual block; and reconstructing the coded block by combining the luma coded block and the chroma coded block.
Another aspect of the teachings herein is an apparatus comprising: a processor that performs either or both of the methods described above.
These and other variations will be described in additional detail hereinafter.
Drawings
The description herein makes reference to the accompanying drawings wherein like reference numerals refer to like parts throughout the several views unless otherwise specified or clear from the context.
FIG. 1 is a diagram of a computing device according to an embodiment of the present disclosure.
Fig. 2 is a diagram of a computing and communication system according to an embodiment of the present disclosure.
Fig. 3 is a diagram of a video stream for use in encoding and decoding according to an embodiment of the present disclosure.
Fig. 4 is a block diagram of an encoder according to an embodiment of the present disclosure.
Fig. 5 is a block diagram of a decoder according to an embodiment of the present disclosure.
Fig. 6 is a block diagram of a representation of a portion of an image according to an embodiment of the present disclosure.
Fig. 7 is a flowchart of an example of a method of encoding according to an embodiment of the present disclosure.
Fig. 8 is a flowchart of an example of a method of decoding according to an embodiment of the present disclosure.
Detailed Description
Image and video compression schemes may include decomposing an image or frame into smaller portions, such as blocks, and using techniques to generate an output bitstream to minimize bandwidth utilization of information included in each block in the output. In some implementations, the information included in each block in the output may be limited by reducing spatial redundancy, reducing temporal redundancy, or a combination thereof. For example, temporal or spatial redundancy may be reduced by predicting a frame or a portion thereof based on information available to both the encoder and decoder, and including information in the encoded bitstream that represents the difference or residual between the predicted frame and the original frame. The residual information may be further compressed by transforming the residual information into transform coefficients, quantizing the transform coefficients, and entropy coding the quantized transform coefficients. Other coding information, such as motion information, may be included in the encoded bitstream, which may include sending predicted difference information based on the coding information, which may be entropy coded to further reduce the corresponding bandwidth utilization. The coded bit stream can be decoded to reconstruct the block and source images from limited information. In some implementations, the accuracy, efficiency, or both of compiling a block using inter-prediction or intra-prediction may be limited.
A codec implementing image or video compression generally compiles color information separately, for example, as first, second, and third planes of color information. For example, in the case where color information is divided into luminance information and color degree information including, but not limited to, YCbCr, YUV, or YU 'V', the luminance information may be compiled separately from the color degree information. In some codecs, one or more coding modes for coding one color plane (e.g., luminance information), such as a prediction mode or type for reducing temporal or spatial redundancy in the information or a transform mode or type for transforming related residual information, may be used for coding other color planes (e.g., chrominance information). In other codecs, the one or more coding modes for some color planes may be a default mode or type (e.g., for a block) that does not change within an image or frame.
For example, the type of transform that a codec may require to compile a plane of color degree information for a block depends on (i.e., is the same as) the type of transform that is used to compile a plane of luminance information for the block. Herein, a plane of luminance information of a block may be referred to as a luminance block, and a plane of chrominance information of a block may be referred to as a chrominance block. In an encoder that determines that a luma block uses a transform type other than the default transform type, a chroma block is also designated as using the transform type. After transforming and optionally quantizing the residual of the luminance block, there may be no non-zero transform coefficients remaining. The transform type may then revert to a default transform type (e.g., discrete Cosine Transform (DCT)), such that the transform type need not be signaled separately for the current block. The decoder will then use the DCT for decoding each of the luma and chroma blocks of the current block. However, this may be a problem because by the time it is decided to revert the luma block to the default transform type, one or both chroma blocks may already be in the encoding pipeline using the original transform type. The chroma blocks will have to be re-encoded using the new transform type, using additional computing resources, or both, slowing the encoding process. Alternatively, the chroma block will be encoded using the original transform type, but the decoder will use the default transform type that the luma block is using.
What has been described above is one example of how the dependency of the transform type of one plane of color information on the transform type of another plane of color information may present problems to some encoder architectures, particularly with respect to some hardware encoder architectures. More generally, such dependencies may reduce coding efficiency, such as increasing coding time or required processing resources, or increasing the number of bits required to represent a chroma block compared to the quality of the reconstructed chroma block. This may be due to the use of different transforms for encoding and decoding the chroma blocks or the need to re-encode the chroma blocks, but may also result from forcing less than ideal transform types into one or both planes of color data. In accordance with the teachings herein, various techniques may be implemented to address these issues by allowing for the desired reduction or even elimination of reliance on different planes of transform types for color information. After describing the environment in which the techniques may be implemented, details of these techniques are described below.
Fig. 1 is a diagram of a computing device 100 according to an embodiment of the present disclosure. The computing device 100 is shown to include a memory 110, a processor 120, a User Interface (UI) 130, an electronic communication unit 140, a sensor 150, a power supply 160, and a bus 170. As used herein, the term "computing device" includes any unit or combination of units capable of performing any method disclosed herein or any one or more portions thereof.
Computing device 100 may be a stationary computing device such as a Personal Computer (PC), server, workstation, minicomputer, or mainframe computer; or a mobile computing device such as a mobile phone, personal Digital Assistant (PDA), laptop or tablet PC. Although shown as a single unit, any one or more elements of computing device 100 can be integrated into any number of separate physical units. For example, the user interface 130 and the processor 120 can be integrated in a first physical unit, while the memory 110 can be integrated in a second physical unit.
Memory 110 can include any non-transitory computer-usable or computer-readable medium such as any tangible apparatus that can, for example, contain, store, communicate, or transport data 112, instructions 114, operating system 116, or any information associated therewith for use by or in connection with other components of computing device 100. The non-transitory computer-usable or computer-readable medium may be, for example, a solid state disk, a memory card, a removable medium, a read-only memory (ROM), a random-access memory (RAM), any type of disk including hard disks, floppy disks, optical disks, magnetic or optical cards, an Application Specific Integrated Circuit (ASIC), or any type of non-transitory medium suitable for storing electronic information, or any combination thereof.
Although shown as a single unit, memory 110 may include multiple physical units, such as one or more primary memory units, such as random access memory units, one or more secondary data storage units, such as disks, or a combination thereof. For example, the data 112, or a portion thereof, the instructions 114, or a portion thereof, or both, may be stored in a secondary storage unit, and may be loaded or otherwise transferred to a primary storage unit in connection with processing the respective data 112, executing the respective instructions 114, or both. In some implementations, the memory 110, or a portion thereof, may be a removable memory.
The data 112 can include information such as input audio data, encoded audio data, decoded audio data, and the like. The instructions 114 can include instructions, such as code, for performing any of the methods disclosed herein or any one or more portions thereof. The instructions 114 can be implemented in hardware, software, or any combination thereof. For example, the instructions 114 may be implemented as information stored in the memory 110, such as a computer program that may be executed by the processor 120 to perform any of the corresponding methods, algorithms, aspects, or combinations thereof as described herein.
Although shown as being included in memory 110, in some embodiments, instructions 114 or portions thereof may be implemented as special purpose processors or circuitry that is capable of including specialized hardware for performing any method, algorithm, aspect, or combination thereof as described herein. Portions of instructions 114 can be distributed across multiple processors on the same machine or different machines, or across a network such as a local area network, a wide area network, the internet, or a combination thereof.
Processor 120 can include any device or system capable of manipulating or processing digital signals or other electronic information, now or later developed, including an optical processor, a quantum processor, a molecular processor, or a combination thereof. For example, the processor 120 can include a special purpose processor, a Central Processing Unit (CPU), a Digital Signal Processor (DSP), a plurality of microprocessors, one or more microprocessors in association with a DSP core, a controller, a microcontroller, application Specific Integrated Circuits (ASICs), field Programmable Gate Arrays (FPGAs), programmable logic arrays, programmable logic controllers, microcode, firmware, any type of Integrated Circuit (IC), a state machine, or any combination thereof. As used herein, the term "processor" includes a single processor or multiple processors.
The user interface 130 can include any element capable of interfacing with a user, such as a virtual or physical keypad, a touchpad, a display, a touch display screen, a speaker, a microphone, a camera, a sensor, or any combination thereof. For example, the user interface 130 may be an audiovisual display device, and the computing device 100 may use the user interface 130 to present audio, such as decoded audio, such as in connection with displaying video, such as decoded video. Although shown as a single unit, the user interface 130 may include one or more physical units. For example, the user interface 130 may include an audio interface for performing audio communication with a user, and a touch display for performing vision-and touch-based communication with a user.
The electronic communication unit 140 is capable of transmitting, receiving, or both transmitting and receiving signals via a wired or wireless electronic communication medium 180 such as: a Radio Frequency (RF) communication medium, an Ultraviolet (UV) communication medium, a visible light communication medium, a fiber optic communication medium, a wireline communication medium, or a combination thereof. For example, as shown, the electronic communication unit 140 is operatively connected to an electronic communication interface 142, such as an antenna, configured to communicate via wireless signals.
Although electronic communication interface 142 is shown in fig. 1 as a wireless antenna, electronic communication interface 142 may be a wireless antenna as shown, a wired communication port such as an ethernet port, an infrared port, a serial port, or any other wired or wireless unit capable of interfacing with a wired or wireless electronic communication medium 180. Although fig. 1 shows a single electronic communication unit 140 and a single electronic communication interface 142, any number of electronic communication units and any number of electronic communication interfaces can be used.
The sensor 150 may include, for example, an audio sensing device, a visible light sensing device, a motion sensing device, or a combination thereof. For example, the 100 sensor 150 may include a sound sensing device such as a microphone, or any other sound sensing device now existing or later developed that is capable of sensing sounds made by a user operating the computer device 100, such as speech or other utterances, in the vicinity of the computer device 100. In another example, the sensor 150 may include a camera, or any other image sensing device that is capable of sensing an image, such as an image of a user operating the computing device, either existing or later developed. Although a single sensor 150 is shown, the computing device 100 may include many sensors 150. For example, the computing device 100 may include a first camera oriented with a field of view directed toward a user of the computing device 100, and a second camera oriented with a field of view away from the user of the computing device 100.
The power supply 160 may be any suitable device for powering the computing device 100. For example, the power supply 160 can include: a wired external power interface; one or more dry cells such as nickel cadmium (NiCd), nickel zinc (NiZn), nickel metal hydride (NiMH), lithium ion (Li-ion); a solar cell; a fuel cell; or any other device capable of powering the computing device 100. Although a single power supply 160 is shown in fig. 1, the computing device 100 may include multiple power supplies 160, such as a battery and a wired external power interface.
Although shown as separate units, electronic communication unit 140, electronic communication interface 142, user interface 130, power supply 160, or portions thereof may be configured as a combined unit. For example, the electronic communication unit 140, the electronic communication interface 142, the user interface 130, and the power supply 160 may be implemented as communication ports capable of interfacing with external display devices to provide communication, power, or both.
One or more of the memory 110, the processor 120, the user interface 130, the electronic communication unit 140, the sensor 150, or the power supply 160 may be operably coupled via a bus 170. Although a single bus 170 is shown in fig. 1, the computing device 100 may include multiple buses. For example, the memory 110, the processor 120, the user interface 130, the electronic communication unit 140, the sensor 150, and the bus 170 may receive power from the power supply 160 via the bus 170. In another example, the memory 110, the processor 120, the user interface 130, the electronic communication unit 140, the sensor 150, the power supply 160, or a combination thereof may communicate data via the bus 170, such as by sending and receiving electronic signals.
Although not separately shown in fig. 1, one or more of the processor 120, the user interface 130, the electronic communication unit 140, the sensor 150, or the power supply 160 may include an internal memory, such as an internal buffer or register. For example, the processor 120 may include an internal memory (not shown) and may read the data 112 from the memory 110 into the internal memory (not shown) for processing.
Although shown as separate elements, the memory 110, processor 120, user interface 130, electronic communication unit 140, sensor 150, power supply 160, and bus 170, or any combination thereof, can be integrated in one or more electronic units, circuits, or chips.
Fig. 2 is a diagram of a computing and communication system 200 according to an embodiment of the present disclosure. The computing and communication system 200 is shown to include computing and communication devices 100A, 100B, 100C, access points 210A, 210B, and a network 220. For example, the computing and communication system 200 may be a multiple access system that provides communications, such as voice, audio, data, video, messaging, broadcast, or a combination thereof, to one or more wired or wireless communication devices, such as computing and communication devices 100A, 100B, 100C. Although for simplicity fig. 2 shows three computing and communication devices 100A, 100B, 100C, two access points 210A, 210B, and one network 220, any number of computing and communication devices, access points, and networks can be used.
The computing and communication devices 100A, 100B, 100C may be, for example, computing devices, such as computing device 100 shown in fig. 1. For example, the computing and communication devices 100A, 100B may be user devices such as mobile computing devices, laptops, thin clients, or smart phones, while the computing and communication device 100C may be a server such as a mainframe or cluster. Although computing and communication device 100A and computing and communication device 100B are described as user devices and computing and communication device 100C is described as a server, any computing and communication device may perform some or all of the functions of a server, some or all of the functions of a user device, or some or all of the functions of a server and a user device. For example, the server computing and communication device 100C may receive, encode, process, store, transmit, or a combination thereof, and one or both of the computing and communication device 100A and the computing and communication device 100B may receive, decode, process, store, present, or a combination thereof, the audio data.
Each computing and communication device 100A, 100B, 100C, which may include a User Equipment (UE), mobile station, fixed or mobile subscriber unit, cellular telephone, personal computer, tablet computer, server, consumer electronics, or any similar device, can be configured to perform wired or wireless communications, such as via network 220. For example, the computing and communication devices 100A, 100B, 100C can be configured to transmit or receive wired or wireless communication signals. Although each computing and communication device 100A, 100B, 100C is shown as a single unit, the computing and communication devices can include any number of interconnected elements.
Each access point 210A, 210B may be any type of device configured to communicate with computing and communication devices 100A, 100B, 100C, network 220, or both, via wired or wireless communication links 180A, 180B, 180C. For example, the access points 210A, 210B can include base stations, base Transceiver Stations (BTSs), node bs, enhanced node bs (eNode-bs), home node bs (HNode-bs), wireless routers, wired routers, hubs, relays, switches, or any similar wired or wireless devices. Although each access point 210A, 210B is shown as a single unit, the access points can include any number of interconnected elements.
Network 220 may be any type of network configured to provide data such as voice, data, applications, voice over internet protocol (VoIP), or any other communication protocol, or combination of communication protocols, over a wired or wireless communication link. For example, the network 220 may be a Local Area Network (LAN), wide Area Network (WAN), virtual Private Network (VPN), mobile or cellular telephone network, the Internet, or any other means of electronic communication. The network can use a communication protocol such as Transmission Control Protocol (TCP), user Datagram Protocol (UDP), internet Protocol (IP), real-time transport protocol (RTP), hypertext transport protocol (HTTP), or a combination thereof.
The computing and communication devices 100A, 100B, 100C are capable of communicating with each other via the network 220 using one or more wired or wireless communication links, or via a combination of wired and wireless communication links. For example, as shown, computing and communication devices 100A, 100B can communicate via wireless communication links 180A, 180B, and computing and communication device 100C can communicate via wired communication link 180C. Any of the computing and communication devices 100A, 100B, 100C may communicate using any one or more wired or wireless communication links. For example, a first computing and communication device 100A may communicate via a first access point 210A using a first type of communication link, a second computing and communication device 100B may communicate via a second access point 210B using a second type of communication link, and a third computing and communication device 100C may communicate via a third access point (not shown) using a third type of communication link. Similarly, the access points 210A, 210B can communicate with the network 220 via one or more types of wired or wireless communication links 230A, 230B. Although fig. 2 shows the computing and communication devices 100A, 100B, 100C communicating via the network 220, the computing and communication devices 100A, 100B, 100C can communicate with each other via any number of communication links, such as direct wired or wireless communication links.
In some implementations, communication between the computing and one or more of the communication devices 100A, 100B, 100C may omit communication via the network 220 and may include transferring data via another medium (not shown), such as a data storage device. For example, the server computing and communication device 100C may store audio data, such as encoded audio data, in a data storage device, such as a portable data storage unit, and one or both of the computing and communication device 100A or the computing and communication device 100B may access, read, or retrieve the stored audio data from the data storage unit, such as by physically disconnecting the data storage device from the server computing and communication device 100C and physically connecting the data storage device to the computing and communication device 100A or the computing and communication device 100B.
Other implementations of computing and communication system 200 are possible. For example, in an embodiment, the network 220 may be an ad-hoc (ad-hoc) network and one or more of the access points 210A, 210B can be omitted. The computing and communication system 200 may include devices, units, or elements not shown in fig. 2. For example, computing and communication system 200 may include many more communication devices, networks, and access points.
Fig. 3 is a diagram of a video stream 300 for use in encoding and decoding according to an embodiment of the present disclosure. A video stream 300, such as a video stream captured by a camera or a video stream generated by a computing device, may include a video sequence 310. Video sequence 310 may include a sequence of adjacent frames 320. Although three adjacent frames 320 are shown, the video sequence 310 can include any number of adjacent frames 320.
Each frame 330 from adjacent frames 320 may represent a single image from the video stream. Although not shown in fig. 3, frame 330 may include one or more segments, tiles, or planes that may be independently compiled or otherwise processed, such as in parallel. Frame 330 may include one or more tiles 340. Each of tiles 340 may be rectangular areas of a frame that can be independently compiled. Each of tiles 340 may include a respective block 350. Although not shown in fig. 3, the block can include pixels. For example, a block can include a 16 x 16 group of pixels, an 8 x 8 group of pixels, an 8 x 16 group of pixels, or any other group of pixels. The term "block" can include a super block, a macroblock, a segment, a slice, or any other portion of a frame, unless otherwise indicated herein. A frame, block, pixel, or combination thereof can include display information such as light brightness information, color degree information, or any other information that can be used to store, modify, transmit, or display a video stream or portion thereof.
Fig. 4 is a block diagram of an encoder 400 according to an embodiment of the present disclosure. The encoder 400 can be implemented in a device such as the computing device 100 shown in fig. 1 or the computing and communication devices 100A, 100B, 100C shown in fig. 2 as a computer software program stored, for example, in a data storage unit such as the memory 110 shown in fig. 1. The computer software program can include machine instructions that can be executed by a processor, such as processor 120 shown in fig. 1, and that can cause the device to encode video data as described herein. Encoder 400 can be implemented as specialized hardware included in computing device 100, for example.
The encoder 400 is capable of encoding an input video stream 402, such as the video stream 300 shown in fig. 3, to generate an encoded (compressed) bitstream 404. In some implementations, the encoder 400 may include a forward path for generating the compressed bit stream 404. The forward path may include an intra/inter prediction unit 410, a transform unit 420, a quantization unit 430, an entropy encoding unit 440, or any combination thereof. In some implementations, the encoder 400 may include a reconstruction path (indicated by broken connection lines) to reconstruct a frame used to encode additional blocks. The reconstruction path may include a dequantization unit 450, an inverse transformation unit 460, a reconstruction unit 470, a filtering unit 480, or any combination thereof. Other structural variations of encoder 400 can be used to encode video stream 402.
To encode the video stream 402, each frame within the video stream 402 can be processed in units of blocks. Accordingly, a current block may be identified from blocks in a frame, and may be encoded.
At the intra/inter prediction unit 410, the current block can be encoded using intra prediction that may be within a single frame or inter prediction from frame to frame. Intra-prediction may include generating a prediction block from samples in the current frame that have been previously encoded and reconstructed. Inter-prediction may include generating a prediction block from samples in one or more previously constructed reference frames. Generating the prediction block for the current block in the current frame may include performing motion estimation to generate a motion vector indicative of an appropriate reference portion of the reference frame.
The intra/inter prediction unit 410 may subtract a prediction block from a current block (original block) to generate a residual block. The transform unit 420 may perform a block-based transform, which may include transforming the residual block into transform coefficients in, for example, the frequency domain. Examples of block-based transforms include the Karhunen-loeve transform (KLT), discrete Cosine Transform (DCT), singular value decomposition transform (SVD), and Asymmetric Discrete Sine Transform (ADST). In an example, the DCT may include transforming the block into the frequency domain. The DCT may include using spatial frequency based transform coefficient values with the lowest frequency (i.e., DC) coefficients at the top left of the matrix and the highest frequency coefficients at the bottom right of the matrix.
The quantization unit 430 may convert the transform coefficients into discrete quantized values, which may be referred to as quantized transform coefficients or quantization levels. The quantized transform coefficients can be entropy encoded by entropy encoding unit 440 to produce entropy encoded coefficients. Entropy encoding can include using probability distribution metrics. The entropy encoded coefficients, information for decoding the block, which may include the type of prediction used, the motion vector, and the quantizer values, can be output to the compressed bit stream 404. The compressed bit stream 404 can be formatted using various techniques such as Run Length Encoding (RLE) and zero run length coding.
The reconstruction path can be used to maintain reference frame synchronization between the encoder 400 and a corresponding decoder, such as the decoder 500 shown in fig. 5. The reconstruction path may be similar to the decoding process discussed below and may include decoding the encoded frame or a portion thereof, which may include decoding the encoded block, which may include dequantizing the quantized transform coefficients at dequantizing unit 450 and inverse transforming the dequantized transform coefficients at inverse transforming unit 460 to produce the derived residual block. The reconstruction unit 470 may add the prediction block generated by the intra/inter prediction unit 410 to the derived residual block to create a decoded block. The filtering unit 480 can be applied to the decoded block to generate a reconstructed block, which may reduce distortion, such as block artifacts. Although one filtering unit 480 is shown in fig. 4, filtering the decoding block may include loop filtering, deblocking filtering, or other types of filtering or combinations of various types of filtering. The reconstructed block may be stored or otherwise accessible as a reconstructed block that may be part of a reference frame for encoding another portion of the current frame, another frame, or both, as indicated by the dashed line at 482. Coding information, such as deblocking threshold index values, of frames may be encoded, included in compressed bitstream 404, or both, as indicated by the dashed line at 484.
Other variations of encoder 400 can be used to encode compressed bit stream 404. For example, the non-transform based encoder 400 can directly quantize the residual block without a transform unit 420. In some embodiments, the quantization unit 430 and the dequantization unit 450 may be combined into a single unit.
Fig. 5 is a block diagram of a decoder 500 according to an embodiment of the present disclosure. The decoder 500 can be implemented in a device such as the computing device 100 shown in fig. 1 or the computing and communication devices 100A, 100B, 100C shown in fig. 2 as a computer software program stored, for example, in a data storage unit such as the memory 110 shown in fig. 1. The computer software program can include machine instructions that can be executed by a processor, such as processor 120 shown in fig. 1, and that can cause the device to decode video data as described herein. Decoder 500 can be implemented as specialized hardware included in computing device 100, for example.
The decoder 500 may receive a compressed bitstream 502, such as the compressed bitstream 404 shown in fig. 4, and may decode the compressed bitstream 502 to generate an output video stream 504. The decoder 500 may include an entropy decoding unit 510, a dequantization unit 520, an inverse transformation unit 530, an intra/inter prediction unit 540, a reconstruction unit 550, a filtering unit 560, or any combination thereof. Other structural variations of decoder 500 can be used to decode compressed bit stream 502.
The entropy decoding unit 510 may decode the data elements within the compressed bitstream 502 using, for example, context-adaptive binary arithmetic decoding to produce a set of quantized transform coefficients. The dequantization unit 520 can dequantize the quantized transform coefficients, and the inverse transformation unit 530 can inverse transform the dequantized transform coefficients to generate a derived residual block, which may correspond to the derived residual block generated by the inverse transformation unit 460 shown in fig. 4. Using header information decoded from the compressed bitstream 502, the intra/inter prediction unit 540 may generate a prediction block corresponding to the prediction block created in the encoder 400. At the reconstruction unit 550, the prediction block can be added to the derived residual block to create a decoded block. The filtering unit 560 can be applied to the decoded block to reduce artifacts such as block artifacts, which may include loop filtering, deblocking filtering, or other types of filtering, or combinations of various types of filtering, and which may include generating a reconstructed block that may be output as the output video stream 504.
Other variations of decoder 500 can be used to decode compressed bit stream 502. For example, decoder 500 can generate output video stream 504 without a deblocking filtering unit.
Fig. 6 is a block diagram of a representation of a portion 600 of a frame, such as frame 330 shown in fig. 3, in accordance with an embodiment of the present disclosure. As shown, the portion 600 of the frame includes four 64 x 64 blocks 610 located in two rows and two columns in a matrix or cartesian plane. In some embodiments, a 64×64 block may be the largest coding unit, n=64. Each 64 x 64 block may include four 32 x 32 blocks 620. Each 32 x 32 block may include four 16 x 16 blocks 630. Each 16 x 16 block may include four 8 x 8 blocks 640. Each 8 x 8 block 640 may include four 4 x 4 blocks 650. Each 4 x 4 block 650 may include 16 pixels, which 16 pixels may be represented in four rows and four columns in each respective block in a cartesian plane or matrix. The pixels may include information representing an image captured in the frame, such as brightness information, color information, and position information. In some embodiments, a block, such as a 16 x 16 block of pixels as shown, may include: a luminance block 660, which may include a luminance pixel 662; and two chroma blocks 670, 680, such as a U or Cb chroma block 670 and a V or Cr chroma block 680. The chrominance blocks 670, 680 may include chrominance pixels 690. For example, as shown, luminance block 660 may include 16 x 16 luminance pixels 662 and each color chroma block 670, 680 may include 8 x 8 color degree pixels 690. Although one arrangement of blocks is shown, any arrangement may be used. Although fig. 6 shows an nxn block, in some embodiments, an nxm block may be used. For example, 32×64 blocks, 64×32 blocks, 16×32 blocks, 32×16 blocks, or any other size block may be used. In some embodiments, an nx2n block, a 2nxn block, or a combination thereof may be used.
Image or video compilation may include in-order block-level compilation. Ordered block-level compilation may include compiling blocks of a frame in an order, such as a raster scan order, wherein blocks may be identified and processed starting from blocks in an upper left corner of the frame or a portion of the frame, and proceeding from left to right along the rows and from top to bottom rows, thereby identifying each block in turn for processing. For example, a 64×64 block in the top row and left column of a frame may be a first block that is compiled, and a 64×64 block immediately to the right of the first block may be a second block that is compiled. The second row from the top may be a compiled second row such that 64 x 64 blocks in the left column of the second row may be compiled after 64 x 64 blocks in the right-most column of the first row.
Compiling the blocks may include compiling using a quadtree, which may include compiling smaller block units within the blocks in raster scan order. For example, the 64×64 blocks shown in the bottom left corner of the portion of the frame shown in fig. 6 may be compiled using a quadtree, in which the top left 32×32 block may be compiled, then the top right 32×32 block may be compiled, then the bottom left 32×32 block may be compiled, and then the bottom right 32×32 block may be compiled. Each 32 x 32 block may be compiled using a quadtree, where the top left 16 x 16 block may be compiled, then the top right 16 x 16 block may be compiled, then the bottom left 16 x 16 block may be compiled, and then the bottom right 16 x 16 block may be compiled. Each 16 x 16 block may be compiled using a quadtree, where the top left 8 x 8 block may be compiled, then the top right 8 x 8 block may be compiled, then the bottom left 8 x 8 block may be compiled, then the bottom right 8 x 8 block may be compiled. Each 8 x 8 block may be compiled using quadtree compilation, wherein the top left 4 x 4 block may be compiled, then the top right 4 x 4 block may be compiled, then the bottom left 4 x 4 block may be compiled, and then the bottom right 4 x 4 block may be compiled. In some implementations, 8×8 blocks may be omitted for 16×16 blocks, and 16×16 blocks may be compiled using quadtree compilation, where the top-left 4×4 block may be compiled, and then other 4×4 blocks in the 16×16 blocks may be compiled in raster scan order.
Image or video coding may include compressing information included in an original or input frame by, for example, omitting some of the information in the original frame from the corresponding encoded frame. For example, coding may include reducing spectral redundancy, reducing spatial redundancy, reducing temporal redundancy, or a combination thereof.
Reducing spectral redundancy may include using a color model based on a luminance component (Y) and two chrominance components (U and V or Cb and Cr), which may be referred to as a YUV or YCbCr color model or color space. Using the YUV color model may include using a relatively large amount of information to represent a luminance component of a portion of a frame and using a relatively small amount of information to represent each corresponding chrominance component of the portion of the frame. For example, a portion of a frame may be represented by a high resolution luma component that may comprise a 16 x 16 block of pixels, and by two lower resolution chroma components in which each lower resolution chroma component represents a portion of the frame as an 8 x 8 block of pixels. The pixels may indicate values, e.g., in the range from 0 to 255, and may be stored or transmitted using, e.g., eight bits. Although the present disclosure is described with reference to YUV color models, any color model may be used.
Reducing spatial redundancy may include transforming the block into the frequency domain using, for example, a DCT or other transform type. For example, a unit of the encoder, such as transform unit 420 shown in fig. 4, may perform DCT using transform coefficient values based on spatial frequencies.
Reducing temporal redundancy may include using similarities between frames to encode frames using a relatively small amount of data based on one or more reference frames, which may be previously encoded, decoded, and reconstructed frames of a video stream. For example, a block or pixel of the current frame may be similar to a spatially corresponding block or pixel of the reference frame. In some implementations, the blocks or pixels of the current frame may be similar to the blocks or pixels of the reference frame at different spatial locations, and reducing temporal redundancy may include generating motion information indicative of spatial differences or translations between the locations of the blocks or pixels in the current frame and the corresponding locations of the blocks or pixels in the reference frame.
Reducing temporal redundancy may include identifying a portion of the reference frame corresponding to a current block or pixel of the current frame. For example, a reference frame or portion of a reference frame that may be stored in memory may be searched to identify a portion for generating a prediction for encoding a current block or pixel of a current frame with maximum efficiency. The search may identify a portion of the reference frame that minimizes a difference in pixel values between the current block and a prediction block generated based on the portion of the reference frame, and may be referred to as a motion search. In some implementations, the portion of the reference frame searched may be limited. For example, the portion of the reference frame searched, which may be referred to as a search region, may include a limited number of rows of the reference frame. In an example, identifying the portion of the reference frame used to generate the prediction may include calculating a cost function, such as a Sum of Absolute Differences (SAD) between pixels of the portion of the search area and pixels of the current block.
The spatial difference between the position of the portion of the reference frame used to generate the prediction in the reference frame and the current block in the current frame may beRepresented as motion vectors. The difference in pixel values between the prediction block and the current block may be referred to as difference data, residual data, prediction error, or residual block. In some implementations, generating a motion vector may be referred to as motion estimation, and pixels of the current block may be indicated as f based on a location using Cartesian coordinates x,y . Similarly, pixels of the search area of the reference frame may be indicated as r based on a location using Cartesian coordinates x,y . The Motion Vector (MV) of the current block may be determined based on, for example, SAD between a pixel of the current frame and a corresponding pixel of the reference frame.
Although described herein with reference to a matrix or cartesian representation of a frame for clarity, the frame may be stored, transmitted, processed, or any combination thereof in any data structure such that pixel values may be efficiently represented for a frame or image. For example, the frames may be stored, transmitted, processed, or any combination thereof in a two-dimensional data structure such as a matrix as shown, or in a one-dimensional data structure such as a vector array. In an embodiment, a representation of a frame, such as a two-dimensional representation as shown, may correspond to a physical location when the frame is rendered as an image. For example, a location in the top left corner of a block in the top left corner of a frame may correspond to a physical location in the top left corner of the frame rendered as an image.
Block-based coding efficiency may be improved by partitioning an input block into one or more prediction partitions, which may be rectangular partitions for predictive coding, including square partitions. In some implementations, video coding using predictive partitioning may include selecting a predictive partitioning scheme from among a plurality of candidate predictive partitioning schemes. For example, in some embodiments, the candidate prediction partition scheme for a 64×64 coding unit includes rectangular-sized prediction partitions ranging in size from 4×4 to 64×64, such as 4×4, 4×8, 8×4, 8×8, 8×16, 16×8, 16×16, 16×32, 32×16, 32×32, 32×64, 64×32, or 64×64. In some implementations, video coding using predictive partitioning includes full predictive partitioning search, which may include selecting a predictive partitioning scheme by encoding a coding unit using each available candidate predictive partitioning scheme and selecting an optimal scheme, such as a scheme that yields the smallest rate-distortion error.
Encoding a video frame may include identifying a prediction partition scheme for encoding a current block, such as block 610. In some implementations, identifying a prediction partition scheme may include determining whether to encode a block as a single prediction partition, which may be a maximum coding unit size of 64×64 as shown, or partition a block into multiple prediction partitions, which may correspond to sub-blocks, such as 32×32 block 620, 16×16 block 630, or 8×8 block 640 as shown, and may include determining whether to partition into one or more smaller prediction partitions. For example, a 64×64 block may be partitioned into four 32×32 prediction partitions. Three of the four 32×32 prediction partitions may be encoded as a 32×32 prediction partition, and the fourth 32×32 prediction partition may be further partitioned into four 16×16 prediction partitions. Three of the four 16×16 prediction partitions may be encoded as 16×16 prediction partitions, and the fourth 16×16 prediction partition may be further partitioned into four 8×8 prediction partitions, each of which may be encoded as an 8×8 prediction partition. In some implementations, identifying the predictive partition scheme may include using a predictive partition decision tree.
Image or video coding for a current block may include identifying an optimal predictive coding mode from among a plurality of candidate predictive coding modes, which may provide flexibility in processing video signals having various statistical properties and may improve compression efficiency. For example, the video compiler may evaluate each candidate predictive coding mode to identify an optimal predictive coding mode, which may be, for example, a predictive coding mode that minimizes an error metric, such as a rate-distortion cost, for the current block. In some implementations, the complexity of searching for candidate predictive coding modes is reduced by limiting the set of available candidate predictive coding modes based on similarity between the current block and the corresponding predictive block. The complexity of searching for each candidate predictive coding mode may be reduced by performing a directed refinement mode search. For example, metrics may be generated for a limited set of candidate block sizes, such as 16×16, 8×8, and 4×4, error metrics associated with each block size may be in descending order, and additional candidate block sizes, such as 4×8 and 8×4 block sizes, may be evaluated.
Block-based coding efficiency may be improved by partitioning a current residual block into one or more transform partitions, which may be rectangular partitions for transform coding, including square partitions. Image or video compilation using transform partitioning may include selecting a unified transform partitioning scheme. For example, a current residual block, such as block 610, may be a 64×64 block and may be transformed without using a 64×64 transform partition.
Although not explicitly shown in fig. 6, the residual block may be transform-partitioned using a unified or non-unified transform partition scheme. For example, the 64×64 residual block may be transform-partitioned using a unified transform partition scheme including four 32×32 transform blocks, using a unified transform partition scheme including sixteen 16×16 transform blocks, using a unified transform partition scheme including sixty-four 8×8 transform blocks, or using a unified transform partition scheme including 256 4×4 transform blocks.
Image or video coding using transform partitions may include using multi-form transform partition coding to identify multiple transform block sizes for residual blocks. In some implementations, the multi-form transform partition compilation includes recursively determining whether to transform the current block using the current block size transform or by partitioning the current block and multi-form transform partition compilation for each partition. For example, the left bottom block 610 shown in fig. 6 may be a 64×64 residual block, and the multi-form transform partition coding may include determining whether to code the current 64×64 residual block using a 64×64 transform or code the 64×64 residual block by partitioning the 64×64 residual block into partitions such as four 32×32 blocks 620 and multi-form transform partition coding each partition. Determining whether to transform the current block may be based on comparing a cost for encoding the current block using the current block size transform to a sum of a cost for encoding each partition using the partition size transform.
As initially described, the dependency of the transform type of one plane of color information (e.g., chroma or chroma information in a chroma block) on the transform type of another plane of color information (e.g., luma information in a luma or luma block) may reduce coding efficiency. This is especially true in cases where different transform types are used to encode and decode one plane of color information (e.g., color degree information).
The techniques described herein can alleviate or eliminate the problems associated with such reliance. Broadly, these techniques can be used to modify the transform type dependence of one color plane on another by allowing the transform type to be identified separately or by modifying the encoding process using one of the transform type dependent color planes such that the reconstructed color information (e.g., reconstructed chroma block) from the decoding process at the encoder is the same as the reconstructed color information of the decoder, regardless of how the chroma transform type is selected.
Techniques may be used that allow the transform types of chroma blocks to be separately identified, optionally supporting the dependence of the transform type of a chroma or chroma block, such as one or both of chroma blocks 670, 680, on the transform type of a luma or luma block, such as luma block 660. This may be achieved by using a chroma transform type pattern for encoding the chroma block. The chroma transform type mode may be one of a plurality of available chroma transform type modes that define how to determine the chroma transform type accordingly.
The plurality of available chroma transform type modes may include at least two modes. One of the available plurality of chroma transform type modes may include the above-described mode in which a chroma block of a coded block uses a transform type of a corresponding luma block of the coded block. The plurality of chroma transform type modes available can more generally include at least two of the following modes: the chroma block of the coding block uses mode 1 of a default transform type, the chroma block of the coding block uses mode 2 of a transform type of a corresponding luma block of the coding block, the chroma block of the coding block uses one candidate transform type of the candidate transform type set regardless of the transform type of the corresponding luma block of the coding block, or the chroma block of the coding block uses mode 4 of a transform type depending on a prediction mode used for predicting the chroma block. The corresponding luminance block is a luminance block belonging to the same coding block as the chrominance block. The terms luma block and luma coding block and the terms chroma block and chroma coding block may be used interchangeably herein.
In this example, the default transform type may be a DCT or another transform type. The default transform type may be a transform type that does not require identification of separate signaling within the bitstream when used. The set of candidate transform types may be all available transform types, such as DCT, asymmetric Discrete Sine Transforms (ADSTs), and the like. The set of candidate transform types may be a subset of all available transform types, such as those for neighboring chroma blocks. In the case where a chroma transform type pattern is used at the encoder, one or more bits identifying the chroma transform type pattern may be included in the compressed bitstream so that the decoder can identify the pattern. The one or more bits (i.e., two bits if four modes are available) may be flags sent in the header at a sequence level, a frame level, a tile level, or a block (e.g., super block) level.
Each mode has its own advantages and disadvantages. Modes 1 and 4 are the simplest implementation at the encoder. However, they may not achieve the best coding efficiency because each mode eliminates all but one transform type as a choice of chroma blocks. Mode 3 allows the chroma block to select the optimal transform type that results in the best compression efficiency. To implement mode 3, in an example, a rate-distortion loop may be used at an encoder that transforms chroma blocks using each candidate transform type during the encoding process, reconstructs the chroma blocks, and determines distortion in the reconstructed chroma blocks. The rate-distortion errors for encoding using the candidate transform types may be compared to select a transform type that minimizes the rate-distortion errors. Note that mode 3 may require the transmission of one or more additional bits identifying the chroma transform type from the set of candidate transform types, such as identifying an index of the chroma transform type within the list of candidate transform types. This may be a flag sent in the header at the sequence level, frame level, tile level, or block (e.g., superblock) level. In some implementations, one or more bits identifying the chroma transform type may be sent in the bitstream only if the chroma transform type is a transform type other than the default transform type.
Mode 2 has been found to provide a relatively good tradeoff between complexity and compilation performance. However, mode 2 may be less useful for (e.g., hardware) encoders for the reasons previously described—that is, mode 2 may result in a different type of transform for encoding a chroma block than the type of transform used for decoding the chroma block. When the chroma block of a coded block uses the transform type of the corresponding luma block of the coded block, modifying the encoding process can solve this problem of possibly different transform types, either as a standard feature of the codec or as a result of the selection of mode 2, which signals the chroma transform type mode.
The encoding process may be modified using a variety of techniques to solve the problem of a transform type of a chroma block that may conflict with a transform type of a chroma block when the chroma block of the coded block is required to use the transform type of the corresponding luma block of the coded block. As mentioned above, such mismatch may occur when a luma block transforms its residual block during encoding using a non-default transform type (e.g., non-DCT), but later changes to the default transform type (e.g., no non-zero coefficients are present in the transformed block, such as after quantization is performed).
As noted previously, a frame is typically divided into non-overlapping blocks (e.g., super blocks) of the same size for the encoding process, such as block 610. At least some of these blocks may then be partitioned into coding units or blocks, e.g., separately predicted blocks as described with respect to fig. 6. The luminance coding block, i.e., the luminance information of the coding block, may be predicted as described above with respect to fig. 4. That is, a prediction block may be generated for the luma coding block, and a luma residual block may be generated as a difference between the luma coding block and the luma prediction block. The luminance residual block may then be transformed and encoded into the bitstream (e.g., after quantization). In some implementations, the luma residual block may be partitioned into multiple luma transform blocks that are separately transformed using the same or different transform types.
A corresponding chroma coding block containing the color degree information of the coding block is associated with a luma coding block. The transform type of the chroma coding block, when it depends on the transform type of the luma coding block, adopts a single transform type of the luma coding block when the resulting luma residual block is not partitioned for transformation. When the resulting luminance residual block is partitioned for transformation, any luminance transformation may be used. Desirably, the first luma transform is used, i.e. the transform type of the first luma transform block in the coding order of the luma transform blocks, such as the coding order described with respect to fig. 6.
In the case where the chroma transform type follows the first luma transform type within the coded block, one technique for solving the dependency problem is to force the use of a default transform type (e.g., DCT) for the first luma transform block within the coded block during coding, even though transform types other than the default transform type would result in better coding efficiency for the luma transform block. The chroma transform type will then be the default transform type such that the same transform type is used to encode and decode the chroma transform block even when the first luma transform block has no non-zero coefficients after the transform. Forcing the default transform type to be used can include setting the luma transform type of the first luma transform block to the default transform type based on the orientation of the block within the compiled block and without regard to other available transform types. Although less desirable, forcing the use of the default transform type can include determining an initial luma transform type for the first luma transform block as well as other luma transform blocks of the compiled block, and then changing it to the default transform type as a final luma transform type prior to transforming. The final luma transform type (i.e., the default transform) will then be used for the corresponding chroma coding block.
Another technique may be to use the luma transform type as the chroma transform type, even if the luma transform type is a transform type other than the default transform type, while selectively modifying the chroma transform block depending on quantized coefficients of the (e.g., first) luma transform block after the transform. When the coefficients are all zero (i.e., there are no non-zero coefficients), all coefficients of the chroma transform block may be forced to zero. This may be done, for example, by storing the luminance coefficients of the transformed luminance transform block, such as in the quantization unit 430 of the encoder 400, and setting the coefficients of the chrominance transform block after the transform (e.g., by quantization) to zero when none of the luminance coefficients have a non-zero value and the chrominance transform type is a transform type other than the default transform type. In the case where all quantized coefficients are zero, the chroma transform type is not different in its coding process. That is, the transform type in the encoding process during encoding at the encoder may be a transform type other than the default transform type, while the transform type in the decoding process at the decoder may be a default transform type process, but the reconstructed luma coded block is the same at each of the encoder and decoder.
Yet another technique is to use the stored luminance coefficients to solve the luminance transformation dependency problem. In particular, when the initial luma transform type, and thus the chroma transform type, is a transform type other than the default transform type, two transforms may be performed on the chroma coding block, for example, at transform unit 420. The chroma coding block may be transformed into a first transformed chroma block using an initial luma transform type and into a second transformed chroma block using a default transform type. If there are no non-zero luma coefficients (i.e., the quantized coefficients are all zero), the second transformed chroma transform block may be encoded into the bitstream (e.g., by quantization and entropy coding). In contrast, if non-zero luma coefficients are present, the first transformed chroma transform block may be encoded into the bitstream (e.g., by quantization and entropy coding).
The above techniques may be used separately or together within an image. For example, a default condition of a codec may require that all chroma coding blocks use the luma transform type of the corresponding block. In these cases, the encoder may implement one or more of the techniques described above that modify the encoding process to eliminate any mismatch between reconstructed luma blocks at the encoder and decoder. For example, one technique may be used for blocks, slices, some other portion of an image at an encoder, or the entire image. Another technique may be used for blocks, slices, or some other portion of the image at the encoder. One or more techniques may be used at the encoder for the current image, and when the current image is one of a series of images, such as frame 320 of video sequence 310, the same or one or more different techniques may be used at the encoder for another image or frame of the sequence.
As opposed to a default decision regarding the selection of the luma transform type, one or more luma transform type modes, such as one or more of modes 1-4 described above, may be explicitly used to make a decision regarding the selection of the luma transform type. This would involve signaling a luma transform type pattern within the bitstream for the image or portion of the image. One or more modes may be used at the encoder for the current image, and when the current image is one of a series of images, such as frame 320 of video sequence 310, the same or one or more different modes may be used at the encoder for another image or frame of the sequence.
In the case where one of the modes for an image or portion of an image is a mode requiring all chroma coding blocks to use the luma transform type of the corresponding block (i.e., mode 4 above), some embodiments of the encoder may optionally implement one or more of the above techniques that modify the encoding process to eliminate any mismatch between reconstructed luma blocks at the encoder and decoder.
Further details of these techniques are described below beginning with fig. 7, which is a flowchart of an example of a method 700 for encoding according to an embodiment of the present disclosure. Method 700 may be implemented in an encoder, such as encoder 400 shown in fig. 4. In some examples below, image data of an image is described. This also encompasses image data in individual frames of video data, which may be referred to as video data in some examples.
As shown in fig. 7, method 700 may include partitioning a current image to be encoded into a plurality of compiled blocks at 702. Examples of the coding block may include blocks corresponding to the residual blocks 610, 620, 6330, 640, 650 shown in fig. 6. Although not explicitly shown in fig. 7, method 700 may include obtaining a current image, which may be an input image such as video frame 330.
At 704, processing of the compilation blocks in a compilation order, such as in the compilation order described with respect to FIG. 6, is initiated. At 704, a luma prediction block is generated for a luma coded block that includes luma information for the coded block. The luma prediction block may be generated by predicting the luma coded block using prediction as described above with respect to the intra/inter prediction unit 410. At 706, a luma residual block is generated as a difference between the luma coded block and the luma prediction block.
At 708, a quantized luma block is generated after transforming the luma transform block using the luma transform type. For example, the luminance transform block may be transformed using a luminance transform type at the transform unit 420 of the encoder 400, and the transformed luminance block (i.e., transform coefficients of the transformed luminance block) may be quantized at the quantization unit 430 of the encoder 400. The luma transform type may be the initial transform type as the default transform type or another transform type from a set of available transform types, such as those described above with respect to fig. 4. In some implementations, the luma transform type may be selected to maximize compression of luma transform blocks or otherwise maximize coding efficiency (e.g., optimize rate/distortion errors). The luminance transform type may be determined by any technique such as testing different transform types within a rate-distortion loop. The luma transform type may be determined according to, for example, a set of rules that depend on characteristics of the luma transform block, such as determining the luma transform type based on what prediction mode is used for prediction, the size of the luma transform block, and so on. According to the above-described techniques for eliminating reconstruction errors in chroma coded blocks, luma transform types may be forced to default transform types in some implementations.
After transformation, such as at transform unit 420 of encoder 400, the generated quantized luma blocks are entropy encoded into a bitstream, such as compressed bitstream 404. Entropy encoding of the transformed luma block may occur at 410 at an entropy encoding unit of the encoder, such as at entropy encoding unit 440. These steps may be repeated as indicated by the arrows from 710 to 708. For example, in some implementations, the luminance transform block may be transformed in its entirety by the luminance transform type (e.g., as a separable one-dimensional transform). In other embodiments, the luma residual block may be partitioned into a plurality of luma transform blocks at 708 and 710 to be processed in a coding order of the plurality of luma transform blocks. For example, a respective luma transform type for each of the plurality of luma transform blocks may be determined for generating a respective quantized luma block at 708, and entropy encoding the quantized luma blocks at 710 then includes entropy encoding each of the quantized luma blocks.
As is clear from the present description, there may be only one luma transform type, or there may be multiple luma transform types associated with the luma coded block. In the case where there are a plurality of luma transform types, for those embodiments in which the chroma transform type is required to use the luma transform type, the luma transform type determined for the first luma transform block of the coding block in the coding order of the plurality of luma transform blocks may be considered as the luma transform type of the luma coding block.
In some embodiments where the chroma transform type is required to use the luma transform type, the luma transform type of the luma transform block may be determined as a default transform type or a transform type other than the default transform type without regard to its effect on the chroma transform type. Thereafter, when the luma transform type (e.g., initial luma transform type) is a transform type other than the default transform type, the luma transform type may be changed to the default transform type (e.g., final luma transform type) before transforming the luma transform block. This allows the chroma transform type to replace the original luma transform type with the final luma transform type for quantization at the encoder, as opposed to changing the luma transform type to the default transform type after transformation and quantization, thereby preventing mismatch between encoding processes during encoding and decoding of the chroma coding block or preventing re-encoding of the chroma block at the encoder after the transform type change.
In some implementations, and for some blocks, the luma transform type can be forced to a default transform type. This may reduce coding efficiency because the default transform type may be less efficient than the optimal transform type for the luma block. However, it eliminates any coding problem of the chroma block depending on the luma transform type. Because of the reduced efficiency of this technique, it may be more desirable to use this technique when the luma residual block is partitioned into luma transform blocks for transformation. Then, the luma transform type of the first luma transform block of the coding block in the coding order of the luma transform blocks may be determined as a default transform type. The chroma block can use this type of luma transform. Other luma transform blocks can use the same or different luma transform types, desirably but not necessarily the one that minimizes rate-distortion errors. In some embodiments, the use of a default transform type may occur even in cases where the transform type other than the default transform type does or would increase the compilation efficiency of the luma block.
At 712, processing begins for a chroma coding block that includes color degree information for the coding block. Although this method 700 is described with respect to one chroma coding block, as an example, there are two chroma coding blocks associated with a luma coding block as noted above with respect to fig. 6. Accordingly, the steps of method 700 associated with a chroma coding block may be applied to each chroma coding block accordingly. In general, the chroma coding blocks associated with the corresponding luma coding blocks use the same technique to determine the chroma transform type, and thus use the same chroma transform type, but this is not required.
At 712, a chroma prediction block is generated for the chroma coding block. The chroma prediction block may be generated by predicting a chroma coding block using prediction as described above with respect to the intra/inter prediction unit 410. At 714, a chroma residual block is generated as a difference between the chroma coding block and the chroma prediction block.
At 716, an initial chroma transform type is determined for a chroma residual block of the chroma coding block. In some embodiments, the initial chroma transform type is determined from a chroma transform type pattern such as one of the patterns described above. In some implementations, the initial chroma transform type is determined to be the luma transform type, whether with or without a chroma transform type mode. In some implementations, the chroma transform type may be selected to maximize compression of the chroma transform block or otherwise maximize coding efficiency (e.g., optimize rate/distortion errors). The chroma transform type may be determined by any technique such as testing different transform types within a rate-distortion loop. The chroma transform type may be determined according to, for example, a set of rules that depend on characteristics of the chroma transform block, such as determining the chroma transform type based on what prediction mode is used for prediction, the size of the luma transform block, and so on.
At 718, a quantized chroma block is generated after transforming the chroma residual block in the final chroma transform type. The initial chroma transform type may be a default transform type or a transform type other than the default transform type. When the initial chroma transform type is the default transform type, the final chroma transform type is the default transform type. When the initial luma transform type is a transform type other than the default transform type, the final luma transform type may be unchanged from the initial luma transform type when the luma transform type is not dependent on the luma transform type (e.g., one of modes 1, 3, or 4 is used). When the initial luma transform type is a transform type other than the default transform type, the final luma transform type may be the initial chroma transform type or the default transform type.
When the chroma transform type depends on the luma transform type, the final chroma transform type, the quantized coefficients of the quantized chroma block, or both may depend on the quantized coefficients of the quantized luma block. For example, according to the above technique, in response to the quantized luma block having no non-zero coefficients and the initial chroma transform type being a transform type other than the default transform type, all quantized coefficients in the quantized chroma block are set to zero prior to encoding the quantized chroma block. In this case, the initial chroma transform type is unchanged (the final chroma transform type is the initial chroma transform type) and is used to transform the luma residual block (e.g., at the transform unit 420 of the encoder 400). A quantization unit, such as quantization unit 430 of encoder 400, may store or otherwise access quantized coefficients of the quantized luma block, and when none of the quantized luma coefficients have a non-zero value, the transformed luma block (i.e., the transformed coefficients of the transformed luma block) is quantized to zero. If there is at least one non-zero quantized coefficient that quantizes the luma block, then the initial luma transform type is also unchanged (the final chroma transform type is the initial chroma transform type), but a quantization unit such as quantization unit 430 of encoder 400 quantizes the chroma residual block according to standard processing, using a quantizer or quantization parameter that may result in non-zero values for at least some coefficients that quantize the chroma block.
For other coded blocks of the current image, or for coded blocks of other frames of the video sequence in case the current image is other frames of the video sequence, another technique may be used in which the type of chroma transform depends on the type of luma transform also depending on the quantization coefficients of the quantized luma block. At 718, this can include transforming the chroma residual block using a default transform type to generate a first chroma transform block and transforming the chroma residual block using an initial chroma transform type to generate a second chroma transform block (e.g., where the initial chroma transform type is a transform type other than the default transform type). This can be performed at the transform unit 420 of the encoder 400. Thereafter, a first chroma transform block may be selected for use in generating the quantized luma block in response to the quantized luma block having no non-zero coefficients, and a second chroma transform block may be selected for use in generating the quantized luma block otherwise. As described above, this may be performed at a quantization unit, such as quantization unit 430 of encoder 400, after considering the coefficients of the quantized luma block that are stored or otherwise accessed by the quantization unit.
After the quantized chroma blocks are generated at 718, the quantized chroma blocks are entropy encoded into a bitstream at 720. The bitstream may be a compressed bitstream 404. Entropy encoding of the transformed chroma blocks may occur at 720 at an entropy encoding unit of the encoder, such as at entropy encoding unit 440.
These steps may be repeated for the compiled block of the current image, as indicated by the arrow from 720 to 704. In the case where the current image is part of a sequence of images, the method 700 may also be repeated for some or all of the compiled blocks of another image. As a result of the above processing, the chroma transform type of the chroma coding block may be different at the encoder and decoder for one or more coding blocks. Even in such a case, the chroma transform block when reconstructed is the same at both the encoder and decoder.
Fig. 8 is a flowchart of an example of a method 800 of decoding according to an embodiment of the present disclosure. The method 800 may be implemented in a decoder, such as the decoder 500 shown in fig. 5, or may be implemented in the reconstruction path of the encoder 400 shown in fig. 4. Method 800 may be similar to method 700 as shown in fig. 7, except as described herein or otherwise clear from the context.
At 802, a bitstream, such as compressed bitstream 502, is received at a decoder. The bit stream may be received via a wired or wireless electronic communication medium, such as network 220 shown in fig. 2, or read from an electronic data storage medium, such as memory 110 shown in fig. 1. The bitstream includes a plurality of encoded coding blocks of a current image partitioned into a plurality of coding blocks. The coded blocks may be encoded according to the method 700 described above. In an embodiment, at least one of the coded blocks is encoded as described in terms of the initial chroma transform type of the chroma residual block being determined as a change in the luma transform type, and the quantized chroma block is generated using the chroma residual block transformed in terms of the final chroma transform type, wherein the final chroma transform type is the initial chroma transform type or the default transform type when the initial chroma transform type is a transform type other than the default transform type, and the quantized coefficients of the quantized chroma block depend on the quantized coefficients of the quantized luma block.
At 804, processing of the luma transform block of the coded block begins by entropy decoding the quantized luma block. Entropy decoding may include entropy decoding (e.g., at entropy decoding unit 510) quantized transform coefficients of the quantized luma block. At 806, a dequantized luma block is generated (e.g., at dequantization unit 520) by dequantizing the quantized transform coefficients.
At 808, a luminance residual block is generated by transforming the dequantized luminance block using a luminance transform type. When there are no bits within the bitstream that identify the luma transform type, the luma transform type may be inferred as the default transform type. The luma transform type may be a transform type other than the default transform type. In some embodiments, the header is decoded from a bitstream that includes bits identifying the luma transform type. The bits may identify a transform type from the set of available transform types as a luma transform type. Transforming the dequantized luminance block may occur at an inverse transform unit, such as inverse transform unit 530 of fig. 5.
Steps 804, 806, and 808 may be repeated for each of a plurality of quantized luma blocks of a coded block encoded within the bitstream, wherein the luma residual block is partitioned for transformation into a plurality of luma transform blocks during encoding. In such an embodiment, a luminance residual block is generated at 808 by combining multiple luminance transform blocks and then dequantizing and inverse transforming them.
At 810, a luma prediction block is generated for a luma coded block. Generating the luma prediction block at 811 may be accomplished using the same prediction mode used to generate the luma prediction block in method 700. This prediction may be performed by an intra/inter prediction unit of a decoder, such as intra/inter prediction unit 540 of decoder 500. A luma coded block may be generated or reconstructed at 812 by adding the luma prediction block to the luma residual block.
At 814, the quantized chroma blocks of the coded blocks encoded within the bitstream are entropy decoded. Entropy decoding the quantized chroma block at 814 can include entropy decoding the quantized transform coefficients at entropy decoding unit 510. Thereafter, at 816, the quantized transform coefficients of the quantized luma block are dequantized (e.g., at dequantization unit 520).
At 818, a chroma transform type of the dequantized chroma block is determined. For at least one of the compiled blocks, the final chroma transform type may be determined as the luma transform type. This may be a default setting for the decoder. In some implementations, determining the chroma transform type can include decoding one or more bits from the bitstream that identify a chroma transform type pattern, wherein the chroma transform type pattern is one of a plurality of available chroma transform type patterns that correspondingly define how to determine the chroma transform type for the at least one chroma transform block. This chroma transform type pattern may then be used to determine the final chroma transform type. For example, mode 2 specifies that the chroma transform type is a luma transform type. In the case where the chroma transform type pattern is a pattern in which the chroma coding block uses one of the candidate transform types in the candidate transform type set regardless of the transform type of the corresponding luma coding block, determining the chroma transform type can also include decoding one or more additional bits from the bitstream that identify the chroma transform type. For example, where one or more additional bits may identify an index within a list of available transform types known to both the encoder and decoder.
At 820, a chroma residual block is generated by transforming the dequantized chroma block using a chroma transform type at an inverse transform unit, such as inverse transform unit 530. Because the chroma residual block of the chroma coding block including the color degree information of the coding block is not partitioned in the example of fig. 7, there is no further chroma coding block associated with the coding block to be decoded.
At 822, a chroma prediction block is generated for the chroma coding block. Generating the chroma prediction block at 820 may be accomplished using the same prediction mode used to generate the chroma prediction block in method 700. This prediction may be performed by an intra/inter prediction unit of the decoder, such as intra/inter prediction unit 540. A chroma coding block may be generated or reconstructed at 824 by adding the chroma prediction block to the chroma residual block.
At 826, the coded block may be reconstructed (e.g., at the reconstruction unit 550) by combining the luma coded block and the chroma coded block.
The method 800 may be repeated for some or all of the coded blocks of the current image or coded blocks of another image in the sequence of which the current image is part.
As used herein, unless explicitly described herein or otherwise clear from the context, the term "set" indicates a distinguishable set or grouping of zero or more different elements or members that may be represented as a one-dimensional array or vector.
The word "example," "embodiment," or "aspect" and variations thereof are used herein to mean serving as an example, instance, or illustration. Any aspect or design so described is not necessarily to be construed as preferred or advantageous over other aspects or designs. Rather, the use of these words is intended to present concepts in a concrete fashion. Furthermore, the use of the terms "an embodiment" or "aspects" throughout are not intended to mean the same embodiment or embodiment unless described as such.
As used herein, the term "or" is intended to mean an inclusive "or" rather than an exclusive "or". That is, unless specified otherwise, or clear from context, "X includes a or B" is intended to mean any natural inclusive permutation. That is, if X includes A; x comprises B; or X includes both a and B, then "X includes a or B" is satisfied under any of the foregoing examples. In addition, the articles "a" and "an" as used in the present application and the appended claims should generally be construed to mean "one or more" unless specified otherwise or clear from context to be directed to a singular form. As used herein, the terms "determine," "identify," "generate," or any variation thereof, include use of one or more of the devices shown in fig. 1 to select, ascertain, calculate, find, receive, determine, establish, obtain, or otherwise identify or determine in any manner.
Moreover, although the figures and descriptions herein may include sequences or series of steps or stages for simplicity of illustration, the elements of the methods disclosed herein can occur in a variety of orders and/or concurrently. Additionally, elements of the methods disclosed herein may occur with other elements not explicitly presented and described herein. Furthermore, one or more elements of the methods described herein may be omitted from embodiments of the methods according to the disclosed subject matter.
The sending computing and communication device 100A and/or the receiving computing and communication device 100B implementations (as well as algorithms, methods, instructions, etc. stored thereon and/or executed thereby) can be implemented in hardware, software, or any combination thereof. The hardware can include, for example, a computer, an Intellectual Property (IP) core, an Application Specific Integrated Circuit (ASIC), a programmable logic array, an optical processor, a programmable logic controller, microcode, a microcontroller, a server, a microprocessor, a digital signal processor, or any other suitable circuit. In the claims, the term "processor" should be understood to encompass any of the foregoing hardware, alone or in combination. The terms "signal" and "data" are used interchangeably. Furthermore, it is not necessarily necessary to implement portions of the transmitting computing and communication device 100A and the receiving computing and communication device 100B in the same manner.
Furthermore, in one embodiment, for example, the sending computing and communication device 100A or the receiving computing and communication device 100B can be implemented using a computer program that, when executed, performs any of the corresponding methods, algorithms, and/or instructions described herein. Additionally, or alternatively, for example, a special purpose computer/processor can be utilized that can contain specialized hardware for performing any of the methods, algorithms, or instructions described herein.
The sending computing and communication device 100A and the receiving computing and communication device 100B can be implemented, for example, on computers in a real-time video system. Alternatively, the sending computing and communication device 100A can be implemented on a server and the receiving computing and communication device 100B can be implemented on a device separate from the server, such as a handheld communication device. In this example, the sending computing and communication device 100A can use the encoder 400 to encode content into an encoded video signal and send the encoded video signal to the communication device. Further, the communication device can then use the decoder 500 to decode the encoded video signal. Alternatively, the communication device can decode content stored locally on the communication device, such as content that is not transmitted by the sending computing and communication device 100A. Other suitable transmit computing and communication device 100A and receive computing and communication device 100B implementations are available. For example, the receiving computing and communication device 100B may be a generally stationary personal computer rather than a portable communication device, and/or a device including the encoder 400 may also include the decoder 500.
Furthermore, all or part of the embodiments can take the form of a computer program product accessible from a tangible computer-usable or computer-readable medium, for example. A computer-usable or computer-readable medium may be any apparatus that can, for example, tangibly contain, store, communicate, or transport the program for use by or in connection with any processor. The medium may be, for example, an electronic, magnetic, optical, electromagnetic, or semiconductor device. Other suitable media are also available.
It will be appreciated that aspects may be implemented in any convenient form. For example, aspects may be implemented by a suitable computer program, which may be carried on a suitable carrier medium, which may be a tangible carrier medium (e.g. a magnetic disk) or an intangible carrier medium (e.g. a communication signal). Aspects may also be implemented using suitable means which may take the form of a programmable computer executing a computer program arranged to perform the methods and/or techniques disclosed herein. The aspects can be combined such that features described in the context of one aspect can be implemented in another aspect.
Further embodiments are summarized in the following examples:
example 1: a method, the method comprising: partitioning a current image to be encoded into a plurality of coding blocks; and for a compiled block of the plurality of compiled blocks of the current image: generating a luminance prediction block for a luminance coding block including luminance information of the coding block; generating a luma residual block as a difference between the luma coded block and the luma prediction block; generating a quantized luminance block after transforming the luminance residual block using a luminance transform type; entropy encoding the quantized luma block into a bitstream; generating a chroma prediction block for a chroma coding block including chroma information of the coding block; generating a chroma residual block as a difference between the chroma coding block and the chroma prediction block; determining a chroma transform type for a chroma coding block in accordance with a chroma transform type pattern of a plurality of available chroma transform type patterns that correspondingly define how the chroma transform type is determined, wherein the available plurality of chroma transform type patterns includes at least two of the following patterns: the chroma coding block uses a default transform type mode; the chroma coding block uses a pattern of transform types of the corresponding luma coding block; the chroma coding block uses a mode of one candidate transform type of the candidate transform type set regardless of the transform type of the corresponding luma coding block; or a chroma coding block uses a mode that depends on a transform type of a prediction mode used to predict the chroma coding block; generating a quantized chroma block using the chroma residual block transformed by the chroma transform type; entropy encoding the quantized chroma blocks into the bitstream; and transmitting one or more bits in the bitstream identifying the chroma transform type pattern.
Example 2: the method of example 1, wherein the chroma transform type pattern is a pattern of chroma coding blocks using one candidate transform type from a set of candidate transform types, the method comprising: one or more bits identifying the chroma transform type within the set of candidate transform types are transmitted in the bitstream.
Example 3: the method of example 2, wherein the luma transform type comprises in addition to the default transform type, the method comprising: one or more bits are transmitted in the bitstream identifying the luma transform type within the set of candidate transform types.
Example 4: the method of example 2, wherein the luma transform type comprises a transform type other than the default transform type, the method comprising: one or more bits identifying the chroma transform type within a second set of candidate transform types are transmitted in the bitstream.
Example 5: the method of example 1, wherein: the chroma transform type pattern is the pattern in which a chroma coding block uses a transform type of a corresponding luma coding block for a transform; and determining the chroma transform type comprises determining an initial chroma transform type for the block of chroma residuals as the luma transform type, the method comprising: transforming the block of chroma residual using a final chroma transform type; and generating the quantized chroma block includes generating the quantized chroma block using the chroma residual block transformed in the final chroma transform type, wherein when the initial chroma transform type is a transform type other than the default transform type, the final chroma transform type is the initial chroma transform type or the default transform type, and a quantization coefficient of the quantized chroma block depends on a quantization coefficient of the quantized luma block.
Example 6: the method of example 5, comprising: in response to the quantized luma block having no non-zero coefficients and the initial chroma transform type being the transform type other than the default transform type, all quantized coefficients in the quantized chroma block are set to zero prior to entropy encoding the quantized chroma block.
Example 7: the method of example 1, wherein the luma transform type is a transform type other than the default transform type, the method comprising: transforming the chroma residual block using the default transform type to generate a first chroma transform block; transforming the chroma residual block using the luma transform type to generate a second chroma transform block; and selecting the first chroma transform block for use in generating the quantized luma block in response to the quantized luma block having no non-zero coefficients, and otherwise selecting the second chroma transform block for use in generating the quantized luma block.
Example 8: a method, the method comprising: receiving a bitstream including encoded coding blocks of a current image partitioned into a plurality of coding blocks; and for a coding block of the plurality of coding blocks including a luma coding block and a chroma coding block, the luma coding block including luma information of the coding block and the chroma coding block including chroma information of the coding block: entropy decoding a quantized luma block from the bitstream; generating a dequantized luminance block by dequantizing the quantized luminance block; generating a luminance residual block by transforming the dequantized luminance block using a luminance transform type; generating a luminance prediction block for the luminance coding block; generating the luma coding block by adding the luma prediction block to the luma residual block; entropy decoding a quantized chroma block from the bitstream; generating a dequantized chroma block by dequantizing the quantized chroma block; decoding one or more bits from the bitstream identifying a chroma transform type pattern, wherein the chroma transform type pattern is one of a plurality of available chroma transform type patterns that respectively define how a chroma transform type is determined for at least one chroma transform block, wherein the plurality of available chroma transform type patterns includes at least two of: the chroma coding block uses a default transform type mode; the chroma coding block uses the corresponding transform type of the luma coding block for the decoded mode; the chroma coding block uses a mode of one candidate transform type of the candidate transform type set regardless of the transform type of the corresponding luma coding block; or a chroma coding block uses a mode that depends on a transform type of a prediction mode used to predict the chroma coding block; determining a chroma transform type for the dequantized chroma block based on the chroma type transform mode; generating a chroma residual block by transforming the dequantized chroma block using the chroma transform type; generating a chroma prediction block for the chroma coding block; generating the chroma coding block by adding the chroma prediction block to the chroma residual block; and reconstructing the coded block by combining the luma coded block and the chroma coded block.
Example 9: the method of example 8, wherein the chroma transform type pattern is a pattern of chroma coding blocks using one candidate transform type from a set of candidate transform types, the method comprising: one or more additional bits identifying the chroma transform type of the chroma coded block are decoded from the bitstream.
Example 10: the method of example 8, wherein: the chroma transform type mode is a mode in which a chroma coding block uses a transform type of a corresponding luma coding block; the luma transform type includes transform types other than the default transform type; and all quantized coefficients of the quantized chrominance block are zero.
Example 11: the method of example 8, wherein: the chroma transform type mode is a mode in which a chroma coding block uses a transform type of a corresponding luma coding block for decoding; the chroma coding block is encoded by: determining an initial chroma transform type of the chroma residual block as the luma transform type; transforming the block of chroma residual using a final chroma transform type; and generating the quantized chroma block using the chroma residual block transformed by the final chroma transform type; wherein when the initial chroma transform type is a transform type other than the default transform type, the final chroma transform type is the initial chroma transform type or the default transform type, and the quantization coefficients of the quantized chroma block depend on the quantization coefficients of the quantized luma block; and determining the chroma transform type for the dequantized chroma block includes determining the chroma transform type as the luma transform type.
Example 12: the method of example 11, wherein the chroma coding block is encoded by: in response to the quantized luma block having no non-zero coefficients and the initial chroma transform type being the transform type other than the default transform type, all quantized coefficients in the quantized chroma block are set to zero prior to entropy encoding the quantized chroma block.
Example 13: the method of example 8, wherein: the chroma transform type mode is a mode in which a chroma coding block uses a transform type of a corresponding luma coding block for decoding; the luma transform type is a transform type other than the default transform type, and the chroma coding block is encoded by: transforming the chroma residual block using the default transform type to generate a first chroma transform block; transforming the chroma residual block using the luma transform type to generate a second chroma transform block; and selecting the first chroma transform block for use in generating the quantized luma block in response to the quantized luma block having no non-zero coefficients, and otherwise selecting the second chroma transform block for use in generating the quantized luma block.
Example 14: the method of example 8, wherein: at least some luma residual blocks of the plurality of coded blocks are partitioned for transformation by a corresponding luma transformation type; the chroma transform type mode is a mode in which a chroma coding block uses a transform type of a corresponding luma coding block for decoding; and a luma transform type of each of the partitioned luma residual blocks that is first positioned in an encoding order of the partitioned luma residual blocks is the default transform type.
Example 15: an apparatus, the apparatus comprising: a processor configured to perform the method of any one of examples 1-14.
The above embodiments have been described in order to make the easy understanding of the present application non-limiting. On the contrary, the application is intended to cover various modifications and equivalent arrangements included within the scope of the appended claims, which scope is to be accorded the broadest interpretation so as to encompass all such modifications and equivalent structures as is permitted under the law.
Claims (15)
1. A method, the method comprising:
partitioning a current image to be encoded into a plurality of coding blocks; and
for a coding block of the plurality of coding blocks of the current image:
Generating a luminance prediction block for a luminance coding block including luminance information of the coding block;
generating a luma residual block as a difference between the luma coded block and the luma prediction block;
generating a quantized luminance block after transforming the luminance residual block using a luminance transform type;
entropy encoding the quantized luma block into a bitstream;
generating a chroma prediction block for a chroma coding block including chroma information of the coding block;
generating a chroma residual block as a difference between the chroma coded block and the chroma prediction block;
determining an initial chroma transform type of the chroma residual block as the luma transform type;
generating a quantized chroma block using the chroma residual block transformed in a final chroma transform type, wherein when the initial chroma transform type is a transform type other than a default transform type, the final chroma transform type is the initial chroma transform type or the default transform type, and a quantization coefficient of the quantized chroma block depends on a quantization coefficient of the quantized luma block; and
the quantized chroma blocks are entropy encoded into the bitstream.
2. The method according to claim 1, comprising:
in response to the quantized luma block having no non-zero coefficients and the initial chroma transform type being the transform type other than the default transform type, all quantized coefficients in the quantized chroma block are set to zero prior to entropy encoding the quantized chroma block.
3. The method according to claim 1, comprising:
transforming the chroma residual block using the default transform type to generate a first chroma transform block;
transforming the chroma residual block using the initial chroma transform type to generate a second chroma transform block; and
the first chroma transform block is selected for use in generating the quantized luma block in response to the quantized luma block having no non-zero coefficients, and the second chroma transform block is selected for use in generating the quantized luma block otherwise.
4. The method of claim 1, wherein the luma transform type comprises the transform type other than the default transform type, the method comprising:
the luma transform type is changed to the default transform type prior to transforming the luma residual block.
5. The method according to claim 1, comprising:
for other coded blocks of the plurality of coded blocks of the current image:
generating a luminance prediction block for a luminance coding block including luminance information of the coding block;
generating a luma residual block as a difference between the luma coded block and the luma prediction block;
generating a chroma prediction block for a chroma coding block including chroma information of the coding block;
generating a chroma residual block as a difference between the chroma coded block and the chroma prediction block;
partitioning the luminance residual block into a plurality of luminance transform blocks;
determining a respective luma transform type for each of the plurality of luma transform blocks, comprising: determining that the luma transform type of a first luma transform block of the coded blocks in a coding order of the plurality of luma transform blocks is the default transform type in a case that a transform type other than the default transform type would improve coding efficiency of the first luma transform block;
determining a chroma transform type as the luma transform type of the first luma transform block;
quantizing each of the plurality of luma transform blocks after transforming to generate a respective quantized luma transform block;
Generating a quantized chroma block using the chroma residual block transformed by the chroma transform type;
entropy encoding each of the quantized luma transform blocks into the bitstream; and
the quantized chroma blocks are entropy encoded into the bitstream.
6. The method of claim 1, wherein the current image is a frame of a video sequence, the method comprising, for other frames of the video sequence:
partitioning the other frames into a plurality of compiled blocks; and
for a coding block of the plurality of coding blocks of the current image:
generating a luminance prediction block for a luminance coding block including luminance information of the coding block;
generating a luma residual block as a difference between the luma coded block and the luma prediction block;
generating a chroma prediction block for a chroma coding block including chroma information of the coding block;
generating a chroma residual block as a difference between the chroma coded block and the chroma prediction block;
partitioning the luminance residual block into a plurality of luminance transform blocks;
determining a respective luma transform type for each of the plurality of luma transform blocks, comprising: determining that the luma transform type of a first luma transform block of the coded blocks in a coding order of the plurality of luma transform blocks is a transform type other than a default transform type;
Changing the luminance transform type of the first luminance transform block to the default transform type prior to transforming the first luminance transform block;
after changing the luma transform type, determining a chroma transform type as the luma transform type of the first luma transform block;
quantizing each of the plurality of luma transform blocks after transforming to generate a respective quantized luma transform block;
generating a quantized chroma block using the chroma residual block transformed by the chroma transform type;
entropy encoding each of the quantized luma transform blocks into the bitstream; and
the quantized chroma blocks are entropy encoded into the bitstream.
7. The method of claim 1, wherein determining the initial chroma transform type of the block of chroma residual as the luma transform type corresponds to a chroma transform type mode of an available plurality of chroma transform type modes that correspondingly define how the chroma transform type is determined, the method comprising:
one or more bits identifying the chroma transform type pattern are transmitted in the bitstream.
8. The method of claim 1, wherein the current image is a frame of a video sequence, the method comprising, for other frames of the video sequence:
Partitioning the other frames into a plurality of coding blocks, wherein each coding block comprises a brightness coding block and a chromaticity coding block, the brightness coding block comprises brightness information of the coding block, and the chromaticity coding block comprises chromaticity information of the coding block;
determining a chroma transform type for at least one chroma coding block in accordance with a chroma transform type pattern of a plurality of available chroma transform type patterns that correspondingly define how the chroma transform type is determined,
wherein the plurality of chroma transform type modes includes at least two of:
the chroma coding block uses the default transform type pattern;
the chroma coding block uses a pattern of transform types of the corresponding luma coding block;
the chroma coding block uses one candidate transform type of the set of candidate transform types regardless of the mode of the transform type of the corresponding luma coding block; or alternatively
A chroma coding block uses a mode that depends on a transform type of a prediction mode used to predict the chroma coding block;
one or more bits identifying the chroma transform type pattern are transmitted in the bitstream.
9. The method of claim 8, wherein the chroma transform type pattern is a pattern of chroma coding blocks using one of a set of candidate transform types, the method comprising:
One or more bits identifying the chroma transform type within the set of candidate transform types are transmitted in the bitstream.
10. A method, comprising:
receiving a bitstream comprising encoded coding blocks of a current image partitioned into a plurality of coding blocks, the coding blocks of the plurality of coding blocks being encoded by:
generating a luminance prediction block for a luminance coding block including luminance information of the coding block;
generating a luma residual block as a difference between the luma coded block and the luma prediction block;
generating a quantized luminance block after transforming the luminance residual block using a luminance transform type;
entropy encoding the quantized luma block into a bitstream;
generating a chroma prediction block for a chroma coding block including chroma information of the coding block;
generating a chroma residual block as a difference between the chroma coded block and the chroma prediction block;
determining an initial chroma transform type of the chroma residual block as the luma transform type;
generating a quantized chroma block using the chroma residual block transformed in a final chroma transform type, wherein when the initial chroma transform type is a transform type other than a default transform type, the final chroma transform type is the initial chroma transform type or the default transform type, and a quantization coefficient of the quantized chroma block depends on a quantization coefficient of the quantized luma block; and
Entropy encoding the quantized chroma blocks into the bitstream;
entropy decoding the quantized luminance block;
generating a dequantized luminance block by dequantizing the quantized luminance block;
generating the luminance residual block by transforming the dequantized luminance block using the luminance transform type;
generating a luminance prediction block for the luminance coding block;
generating the luma coding block by adding the luma prediction block to the luma residual block;
entropy decoding the quantized chrominance blocks;
generating a dequantized chroma block by dequantizing the quantized chroma block;
determining a chroma transform type of the dequantized chroma block as the luma transform type;
generating the chroma residual block by transforming the dequantized chroma block using the chroma transform type;
generating a chroma prediction block for the chroma coding block;
generating the chroma coding block by adding the chroma prediction block to the chroma residual block; and
the coded block is reconstructed by combining the luma coded block and the chroma coded block.
11. The method of claim 10, comprising:
One or more bits identifying a chroma transform type pattern are decoded from the bitstream, wherein the chroma transform type pattern is one of a plurality of available chroma transform type patterns that respectively define how the chroma transform type is determined for at least one chroma transform block.
12. The method of claim 11, wherein the plurality of chroma transform type modes comprises at least two of:
the chroma coding block uses the default transform type pattern;
the chroma coding block uses the corresponding transform type of the luma coding block for the transformed mode;
the chroma coding block uses one candidate transform type of the set of candidate transform types regardless of the mode of the transform type of the corresponding luma coding block; or alternatively
The chroma coding block uses a mode that depends on the type of transform used to predict the prediction mode of the chroma coding block.
13. The method of claim 11, wherein at least some of the plurality of coding blocks of the current image are encoded using a chroma transform type pattern in which a chroma coding block uses one candidate transform type of a set of candidate transform types regardless of a transform type of a corresponding luma coding block, wherein the method comprises:
One or more additional bits identifying the chroma transform type of other chroma coded blocks of the current frame are decoded from the bitstream.
14. The method of claim 10, wherein the luma transform type comprises the transform type other than the default transform type and all quantization coefficients of the quantized chroma block are zero.
15. An apparatus, comprising:
a processor configured to perform the method of any one of claims 1 to 14.
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
PCT/US2021/014955 WO2022159115A1 (en) | 2021-01-25 | 2021-01-25 | Chroma transform type determination |
Publications (1)
Publication Number | Publication Date |
---|---|
CN116783890A true CN116783890A (en) | 2023-09-19 |
Family
ID=74595467
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN202180091033.XA Pending CN116783890A (en) | 2021-01-25 | 2021-01-25 | Chroma transform type determination |
Country Status (4)
Country | Link |
---|---|
US (1) | US20240089433A1 (en) |
EP (1) | EP4252419A1 (en) |
CN (1) | CN116783890A (en) |
WO (1) | WO2022159115A1 (en) |
Family Cites Families (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
KR102636267B1 (en) * | 2018-08-16 | 2024-02-14 | 베이징 바이트댄스 네트워크 테크놀로지 컴퍼니, 리미티드 | Coding according to coefficients of transformation matrix selection |
-
2021
- 2021-01-25 EP EP21705395.8A patent/EP4252419A1/en active Pending
- 2021-01-25 CN CN202180091033.XA patent/CN116783890A/en active Pending
- 2021-01-25 WO PCT/US2021/014955 patent/WO2022159115A1/en active Application Filing
- 2021-01-25 US US18/273,666 patent/US20240089433A1/en active Pending
Also Published As
Publication number | Publication date |
---|---|
WO2022159115A1 (en) | 2022-07-28 |
US20240089433A1 (en) | 2024-03-14 |
EP4252419A1 (en) | 2023-10-04 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US11601644B2 (en) | Image and video coding using machine learning prediction coding models | |
CN107027033B (en) | Video coding and decoding method for copying by using patch | |
CN110741645B (en) | Blockiness reduction | |
US20190313123A1 (en) | Context adaptive scan order for entropy coding | |
US11765377B2 (en) | Alpha channel prediction | |
US20230308679A1 (en) | Motion prediction coding with coframe motion vectors | |
US11153588B2 (en) | Dual deblocking filter thresholds | |
US11849113B2 (en) | Quantization constrained neural image coding | |
CN107079156B (en) | Method for alternate block constrained decision mode coding | |
US10951921B2 (en) | Adjustable per-symbol entropy coding probability updating for image and video coding | |
US20240089433A1 (en) | Chroma Transform Type Determination | |
US11012714B1 (en) | Image coding using lexicographic coding order with floating block-partitioning | |
US20230291925A1 (en) | Inter-Intra Prediction With Implicit Models | |
WO2024005777A1 (en) | Circular-shift transformation for image and video coding |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
SE01 | Entry into force of request for substantive examination |