CN114143559B - Efficient context model calculation design in transform coefficient coding - Google Patents
Efficient context model calculation design in transform coefficient coding Download PDFInfo
- Publication number
- CN114143559B CN114143559B CN202111353194.XA CN202111353194A CN114143559B CN 114143559 B CN114143559 B CN 114143559B CN 202111353194 A CN202111353194 A CN 202111353194A CN 114143559 B CN114143559 B CN 114143559B
- Authority
- CN
- China
- Prior art keywords
- value
- scan order
- diagonal
- values
- transform
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active
Links
- 238000013461 design Methods 0.000 title abstract description 7
- 238000012821 model calculation Methods 0.000 title abstract description 5
- 238000000034 method Methods 0.000 claims abstract description 210
- 239000000872 buffer Substances 0.000 claims abstract description 159
- 230000001186 cumulative effect Effects 0.000 claims description 23
- 238000009826 distribution Methods 0.000 claims description 22
- 238000009825 accumulation Methods 0.000 claims description 9
- 230000002441 reversible effect Effects 0.000 abstract description 32
- 238000012545 processing Methods 0.000 abstract description 15
- 230000008569 process Effects 0.000 description 175
- 230000000875 corresponding effect Effects 0.000 description 91
- 230000015654 memory Effects 0.000 description 42
- 238000010586 diagram Methods 0.000 description 41
- 230000006835 compression Effects 0.000 description 12
- 238000007906 compression Methods 0.000 description 12
- 238000004891 communication Methods 0.000 description 11
- 238000013139 quantization Methods 0.000 description 11
- 230000006870 function Effects 0.000 description 8
- 230000009466 transformation Effects 0.000 description 8
- 208000037170 Delayed Emergence from Anesthesia Diseases 0.000 description 6
- 239000013598 vector Substances 0.000 description 6
- 230000001174 ascending effect Effects 0.000 description 3
- 230000008901 benefit Effects 0.000 description 3
- 230000008859 change Effects 0.000 description 3
- 239000003550 marker Substances 0.000 description 3
- 230000003287 optical effect Effects 0.000 description 3
- 238000012360 testing method Methods 0.000 description 3
- 230000005540 biological transmission Effects 0.000 description 2
- 238000004364 calculation method Methods 0.000 description 2
- 238000004590 computer program Methods 0.000 description 2
- 230000002596 correlated effect Effects 0.000 description 2
- 238000001914 filtration Methods 0.000 description 2
- 238000013507 mapping Methods 0.000 description 2
- 239000011159 matrix material Substances 0.000 description 2
- 238000012986 modification Methods 0.000 description 2
- 230000004048 modification Effects 0.000 description 2
- 230000002123 temporal effect Effects 0.000 description 2
- 230000015572 biosynthetic process Effects 0.000 description 1
- 230000001413 cellular effect Effects 0.000 description 1
- 238000006243 chemical reaction Methods 0.000 description 1
- 239000003086 colorant Substances 0.000 description 1
- 238000010276 construction Methods 0.000 description 1
- 238000000354 decomposition reaction Methods 0.000 description 1
- 230000006837 decompression Effects 0.000 description 1
- 238000010790 dilution Methods 0.000 description 1
- 239000012895 dilution Substances 0.000 description 1
- 239000004973 liquid crystal related substance Substances 0.000 description 1
- 238000012423 maintenance Methods 0.000 description 1
- 230000009467 reduction Effects 0.000 description 1
- 239000013074 reference sample Substances 0.000 description 1
- 230000004044 response Effects 0.000 description 1
- 239000004065 semiconductor Substances 0.000 description 1
- 239000000243 solution Substances 0.000 description 1
- 238000000638 solvent extraction Methods 0.000 description 1
- 238000012546 transfer Methods 0.000 description 1
- 230000001131 transforming effect Effects 0.000 description 1
Classifications
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/169—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding
- H04N19/18—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding the unit being a set of transform coefficients
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/102—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or selection affected or controlled by the adaptive coding
- H04N19/13—Adaptive entropy coding, e.g. adaptive variable length coding [AVLC] or context adaptive binary arithmetic coding [CABAC]
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/90—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using coding techniques not provided for in groups H04N19/10-H04N19/85, e.g. fractals
- H04N19/91—Entropy coding, e.g. variable length coding [VLC] or arithmetic coding
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/102—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or selection affected or controlled by the adaptive coding
- H04N19/124—Quantisation
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/102—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or selection affected or controlled by the adaptive coding
- H04N19/129—Scanning of coding units, e.g. zig-zag scan of transform coefficients or flexible macroblock ordering [FMO]
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/42—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals characterised by implementation details or hardware specially adapted for video compression or decompression, e.g. dedicated software implementation
- H04N19/423—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals characterised by implementation details or hardware specially adapted for video compression or decompression, e.g. dedicated software implementation characterised by memory arrangements
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/50—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding
- H04N19/503—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding involving temporal prediction
- H04N19/51—Motion estimation or motion compensation
- H04N19/513—Processing of motion vectors
- H04N19/517—Processing of motion vectors by encoding
- H04N19/52—Processing of motion vectors by encoding by predictive encoding
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/60—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using transform coding
- H04N19/61—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using transform coding in combination with predictive coding
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/70—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals characterised by syntax aspects related to video coding, e.g. related to compression standards
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/80—Details of filtering operations specially adapted for video compression, e.g. for pixel interpolation
- H04N19/82—Details of filtering operations specially adapted for video compression, e.g. for pixel interpolation involving filtering within a prediction loop
Abstract
The present application relates to efficient context model calculation design in transform coefficient coding. Encoding transform blocks using a level graph is disclosed. A method comprising: determining a lower plane of the value; processing the lower plane in reverse scan order; and selecting a template for entropy coding the values of the lower plane. The method also includes: for the current value of the lower plane, selecting two or more line buffers based on the template anti-diagonal, each of the two or more line buffers corresponding to a respective scan order anti-diagonal; determining a context using two or more line buffers; and entropy encoding the current value using the context. Each value is a corresponding "reach" value of the transform coefficient. The reverse scan order accesses the values of the lower plane along the scan order reverse diagonal. The template indicates scan positions of the coded values of the lower plane, which are arranged along the template anti-diagonal in the template.
Description
Description of the division
The present application belongs to the divisional application of Chinese patent application No.201980010677.4 whose application date is 2019, 1 month and 30 days.
Technical Field
The present disclosure relates to efficient context model calculation design in transform coefficient coding.
Background
Digital video streams may use a sequence of frames or still images to represent video. Digital video can be used for a variety of applications including, for example, video conferencing, high definition video entertainment, video advertising, or user-generated video sharing. Digital video streams can contain large amounts of data and consume large amounts of computing or communication resources of computing devices for processing, transmission, or storage of video data. Various methods have been proposed, including compression and other coding techniques, to reduce the amount of data in a video stream.
Disclosure of Invention
One aspect of the disclosed implementations is an apparatus for encoding a transform block of transform coefficients, the apparatus comprising a memory and a processor. The memory includes instructions executable by the processor to identify a lower plane of values, process the lower plane in backward or reverse scan order, select a template for entropy coding the values of the lower plane, and, for a current value of the lower plane, select two or more line buffers based on a template anti-diagonal, each of the two or more line buffers corresponding to a respective scan order anti-diagonal, determine a context using the two or more line buffers, and entropy code the current value using the context in the compressed bitstream. Each value of the lower plane is a corresponding "reach" value of the transform coefficient. The reverse scan order accesses the values of the lower plane along the scan order reverse diagonal. The template indicates, for the value to be coded, the scan position of the value of the lower plane that has been coded. The scan positions are arranged in the templates in at least two template anti-diagonals.
Another aspect of the disclosed implementations is an apparatus for decoding a transform block of transform coefficients, the apparatus comprising a memory and a processor. The memory includes instructions executable by the processor to select a template for entropy decoding values of a lower plane, decode the lower plane in reverse scan order, and, for a current value of the lower plane, select two or more line buffers based on a template anti-diagonal, each of the two or more line buffers corresponding to a respective scan order anti-diagonal, determine a context using the two or more line buffers, and entropy decode the current value using the context in the compressed bitstream. The template indicates, for the value to be decoded, a scanning position of the decoded value of the lower plane, the scanning position being arranged in the template in at least two template anti-diagonals. Each value of the lower plane is a corresponding "reach" value of the transform coefficient. The reverse scan order decodes the values of the lower plane along the scan order reverse diagonal.
Another aspect is a method for encoding a transform block of transform coefficients. The method comprises the following steps: determining a lower plane of the value; processing the lower plane in reverse scan order; and selecting a template for entropy coding the values of the lower plane. The method also includes: for the current value of the lower plane, selecting two or more line buffers based on the template anti-diagonal, each of the two or more line buffers corresponding to a respective scan order anti-diagonal; determining a context using two or more line buffers; and entropy encoding the current value using the context in the compressed bitstream. Each value of the lower plane is a corresponding "reach" value of the transform coefficient. The reverse scan order accesses the values of the lower plane along the scan order reverse diagonal. The template indicates, for the value to be coded, a scanning position of the coded value of the lower plane, the scanning position being arranged in the template in at least two template anti-diagonals.
These and other aspects of the disclosure are disclosed in the following detailed description of the embodiments, the appended claims and the accompanying drawings.
Drawings
The description herein makes reference to the accompanying drawings wherein like reference numerals refer to like parts throughout the several views.
Fig. 1 is a schematic diagram of a video encoding and decoding system.
Fig. 2 is a block diagram of an example of a computing device capable of implementing a sending station or a receiving station.
Fig. 3 is a diagram of a video stream to be encoded and subsequently decoded.
Fig. 4 is a block diagram of an encoder according to an implementation of the present disclosure.
Fig. 5 is a block diagram of a decoder according to an implementation of the present disclosure.
Fig. 6 is a flow chart of a process for encoding transform blocks in an encoded video bitstream using a level map according to an implementation of the present disclosure.
Fig. 7 is a diagram illustrating various stages of transform coefficient coding using a level map according to an embodiment of the present disclosure.
Fig. 8 is a diagram of previously coded neighbors in a non-zero diagram according to an embodiment of the disclosure.
Fig. 9 is a flowchart of a process for coding transform blocks using a level graph according to an embodiment of the present disclosure.
10A-B are diagrams of examples of templates for determining coding contexts, according to embodiments of the present disclosure.
FIG. 11 is a flowchart of a process for coding transform blocks using a level graph according to an embodiment of the present disclosure.
FIG. 12 is an example of a diagram of using templates to determine context according to embodiments of the present disclosure.
Fig. 13 is a diagram of an example of a scan order along anti-diagonal alignment values according to an implementation of the present disclosure.
FIG. 14 is a flow chart of a process for cache management for context selection according to an embodiment of the present disclosure.
Fig. 15 is a flowchart of a process for using a moving window for context selection according to an embodiment of the present disclosure.
Fig. 16 is a flowchart of a process for coding a transform block of transform coefficients according to an embodiment of the present disclosure.
Detailed Description
As mentioned above, compression schemes related to coding a video stream may include decomposing an image into blocks and generating a digital video output bitstream (i.e., an encoded bitstream) using one or more techniques to limit information included in the output bitstream. The received bit stream can be decoded to recreate the block and source images from the limited information. Encoding a video stream or a portion thereof, such as a frame or block, can include using temporal or spatial similarities in the video stream to improve coding efficiency. For example, a current block of the video stream may be encoded based on identifying differences (residuals) between previously encoded pixel values and pixel values in the current block or between a combination of previously encoded pixel values and pixel values in the current block.
Encoding using spatial similarity can be referred to as intra prediction. The intra pre-test map predicts pixel values of a block of the video frame using pixels around the block; that is, pixels in the same frame as the block but outside the block are used. The prediction block resulting from intra prediction is referred to herein as an intra predictor. Intra prediction can be performed along prediction directions, where each direction can correspond to an intra prediction mode. The intra prediction mode can be signaled to the decoder by the encoder.
Coding using temporal similarity can be referred to as inter prediction. The inter-frame pre-test map predicts pixel values of a block using one or more possibly shifted blocks from one or more temporally close frames (i.e., reference frames). Temporally proximate frames are frames that occur in the video stream earlier or later in time than the frames of the block being encoded. The prediction blocks generated by inter prediction are referred to herein as inter predictors.
Inter prediction is performed using motion vectors. The motion vector used to generate the prediction block refers to a frame other than the current frame, i.e., a reference frame. The reference frame can be located before or after the current frame in the sequence of the video stream. Some codecs use up to eight reference frames, which can be stored in a frame buffer. The motion vector can refer to (i.e., use) one of the reference frames of the frame buffer. Thus, one or more reference frames can be available to code the current frame.
As mentioned above, a current block of a video stream may be encoded based on identifying differences (residuals) between previously encoded pixel values and pixel values in the current block. In this way, only the residual and the parameters used to generate the residual need to be added to the encoded bitstream. The residual may be encoded using a lossy quantization step.
The residual block may be in the pixel domain. The residual block can be transformed into the frequency domain, resulting in a transformed block of transform coefficients. The transform coefficients can be quantized to produce quantized transform blocks of quantized transform coefficients. The quantized coefficients can be entropy encoded and added to the encoded bitstream. The decoder is capable of receiving the encoded bitstream and entropy decoding the quantized transform coefficients to reconstruct the original video frame.
Entropy coding is a technique for "lossless" coding that relies on a probabilistic model that models the distribution of values that occur in the encoded video bitstream. Entropy coding can reduce the number of bits required to represent video data to near theoretical minima by using a probabilistic model based on a measured or estimated distribution of values. In practice, the actual reduction in the number of bits required to represent video data may be a function of the accuracy of the probability model, the number of bits over which the encoding is performed, and the accuracy of the computation for performing fixed point arithmetic of the encoding.
In an encoded video bitstream, many bits are used in one of two cases: content prediction (e.g., inter mode/motion vector coding, intra prediction mode coding, etc.) or residual coding (e.g., transform coefficients).
The encoder may use various techniques to reduce the amount of bits spent on transform coefficient coding. For example, a level map as described further below can be used to code the transform coefficients. In this context, for brevity and unless otherwise clear from the context, transform coefficients refer to quantized transform coefficients, and transform blocks refer to quantized transform coefficients.
The values of the transform coefficients can be partitioned into two planes: a lower plane and an upper plane. The maximum level is associated with the lower plane. The lower plane indicates a value of "until whether the coefficient is less than or equal to the maximum level" for the transform coefficient. For example, if the maximum level is 2, the lower plane indicates whether the coefficient is 0, 1, 2, or greater than 2. Thus, "until the coefficient is less than or equal to 2" means that the lower plane indicates that the value of the coefficient is 0, 1, 2, or more than 2. Any coefficient whose value is greater than 2 (e.g., the maximum level) can be represented in the lower plane by a value indicating "greater than 2" (i.e., 3 or more). The upper plane corresponds to a coefficient value of 3 or more in this example. Thus, each of the values of the lower plane may be one of four values, namely 0, 1, 2 or "greater than 2". In one example, coefficients greater than 2 can be represented by a value of 3 in the lower plane.
In general, the lower plane (i.e., the value of the lower plane) occurs much more frequently than the upper plane. This is because for each value of the upper plane there is a necessary corresponding value in the lower plane. However, some of the values of the lower plane may not have corresponding values in the upper plane. For example, a transform coefficient of value 7 will have a corresponding value in the lower plane (e.g., value 3 because 7 is greater than 2) and a value in the lower plane (e.g., 5). However, a transform coefficient of value 2 does not have the corresponding value in the above diagram. Therefore, the compression performance (i.e., compression speed) of the lower plane may have a significant influence on the overall compression performance.
As described above, entropy coding a sequence of symbols is typically achieved by: the probability model is used to determine the probability p of the sequence, and binary arithmetic coding is then used to map the sequence to binary codewords at the encoder and to decode the sequence from the binary codewords at the decoder. The length of the codeword (i.e. the number of bits) is given by-log (p). The efficiency of entropy coding may be directly related to the probability model. Throughout this document, unless otherwise specified, log represents a logarithmic function based on two (2).
As used herein, a model may be lossless (entropy) coding, or may be a parameter in lossless (entropy) coding. The model may be any parameter or method that affects the probability estimation for entropy coding.
The purpose of context modeling is to obtain probability distributions for subsequent entropy coding engines, such as arithmetic coding, huffman coding, and other variable length to variable length coding engines. To achieve good compression performance, a large number of context models may be required. For example, some video coding systems can include hundreds or even thousands of context models that are used solely for transform coefficient coding. Each context model can correspond to a probability distribution.
As already mentioned, the residual of the video block is transformed into a transformed block of transform coefficients. The transform blocks are in the frequency domain and one or more transform blocks may be generated for the video block. The transform coefficients are quantized and entropy coded into an encoded video bitstream. The decoder reconstructs the block using the coded transform coefficients and the reference frame. Entropy coding of transform coefficients involves selecting a context model (also referred to as a probabilistic context model or probability model) that provides an estimate of a conditional probability for coding binary symbols of the binarized transform coefficients.
The available context models in the codec may be obtained as a list, an array, a file, or some other suitable data structure. The list of context models can be ordered. That is, a respective context index can be associated with each context model. Thus, selecting a context model can involve determining a context index. The context index is then used to select (e.g., retrieve, access, etc.) the corresponding context model.
Coding transform coefficients of a transform block, such as coding values of a lower plane corresponding to the transform block, can include accessing each value of the lower plane, determining a context index for the value of the lower plane, retrieving a context model associated with the context index, and entropy coding the value using the context model.
The values of the lower plane are accessed (e.g., processed) along the scan order. The scan order can also be referred to as a processing order. Accessing the values of the lower plane along the scan order can include generating a one-dimensional array. Determining the context index for the current transform coefficient of the transform block can include accessing other values in the one-dimensional array. These other values are values corresponding to other transform coefficients adjacent to the current transform coefficient in the two-dimensional transform block. While these other transform coefficients may be adjacent to the current block of transform coefficients in the two-dimensional block, the corresponding values may not be adjacent values in the one-dimensional array. The arrangement of the values of the lower plane in the array of dimensions depends on the scanning order.
As further explained below with respect to fig. 12, accessing respective other values of each transform coefficient can impose some computational hurdles, particularly for decoder speed.
Implementations of the present disclosure can produce improved compression performance by arranging and accessing the values of the lower plane required to determine the context index in such a way as to optimize memory access. The values of the lower plane can be arranged in one or more line buffers along an anti-diagonal line of the scan order such that determining the context index for the values of the lower plane accesses consecutive locations in the two or more line buffers. A scan order along anti-diagonal line alignment values and a method for accessing values from a line buffer are described.
By integrating the scan order (e.g., processing order) of the values of the lower plane and the calculation method of the context index, access to non-contiguous locations of the line buffer can be reduced and parallel calculation can be utilized. Thus, implementations of the present disclosure can have reduced computation.
Efficient context model calculation design in transform coefficient coding is described herein first with reference to a system in which teachings can be incorporated.
Fig. 1 is a simplified diagram of a video encoding and decoding system 100. The sending station 102 may be, for example, a computer having an internal configuration of hardware, such as the computer described with respect to fig. 2. However, other suitable implementations of the sending station 102 are possible. For example, the processing of the sending station 102 can be distributed among multiple devices.
The network 104 can connect the sending station 102 and the receiving station 106 for encoding and decoding video streams. Specifically, the video stream can be encoded in the transmitting station 102 and the encoded video stream can be decoded in the receiving station 106. The network 104 may be, for example, the internet. Network 104 may also be a Local Area Network (LAN), wide Area Network (WAN), virtual Private Network (VPN), cellular telephone network, or any other means of transferring video streams from transmitting station 102 to receiving station 106 in this example.
In one example, the receiving station 106 may be a computer having an internal configuration of hardware, such as the computer depicted in fig. 2. However, other suitable implementations of the receiving station 106 are possible. For example, the processing of the receiving station 106 can be distributed among a plurality of devices.
Other implementations of the video encoding and decoding system 100 are possible. For example, one implementation can omit network 104. In another implementation, the video stream can be encoded and then stored for transmission at a later time to the receiving station 106 or any other device having memory. In one implementation, the receiving station 106 receives the encoded video stream (e.g., via the network 104, a computer bus, and/or some communication path) and stores the video stream for later decoding. In one example implementation, real-time transport protocol (RTP) is used to transmit encoded video over network 104. In another implementation, transport protocols other than RTP may be used, such as, for example, a hypertext transfer protocol (HTTP) based video streaming protocol.
For example, when used in a video conferencing system, the sending station 102 and/or the receiving station 106 may include the capability to both encode and decode video streams as described below. For example, the receiving station 106 may be a video conference participant that receives the encoded video bitstream from a video conference server (e.g., the sending station 102) to decode and view, and further encodes and sends its own video bitstream to the video conference server for decoding and viewing by other participants.
Fig. 2 is a block diagram of an example of a computing device 200 capable of implementing a sending station or a receiving station. For example, computing device 200 can implement one or both of transmitting station 102 and receiving station 106 of fig. 1. Computing device 200 may take the form of a computing system including multiple computing devices, or a single computing device, such as a mobile phone, tablet computer, laptop computer, notebook computer, desktop computer, or the like.
The CPU 202 in the computing device 200 may be a central processing unit. Alternatively, CPU 202 may be any other type of device, or devices, now existing or hereafter developed, capable of manipulating or processing information. Although the disclosed implementations can be practiced with a single processor (e.g., CPU 202) as shown, speed and efficiency advantages can be realized by using more than one processor.
In implementations, the memory 204 in the computing device 200 may be a Read Only Memory (ROM) device or a Random Access Memory (RAM) device. Any other suitable type of storage device can be used as memory 204. The memory 204 can include code and data 206 that is accessed by the CPU 202 using the bus 212. The memory 204 can further include an operating system 208 and an application 210, the application 210 including at least one program that allows the CPU 202 to perform the methods described herein. For example, the application 210 can include application 1 through application N, which further include video coding applications that perform the methods described herein. The computing device 200 can also include secondary storage 214, which secondary storage 214 can be, for example, a memory card for use with the mobile computing device 200. Because video communication sessions may contain a large amount of information, they can be stored in whole or in part in secondary storage 214 and loaded into memory 204 for processing as needed.
Computing device 200 can also include one or more output devices, such as a display 218. In one example, the display 218 may be a touch sensitive display that combines the display with touch sensitive elements operable to sense touch inputs. A display 218 can be coupled to the CPU 202 via the bus 212. Other output devices can be provided in addition to the display 218 or as an alternative to the display 218 that allow a user to program the computing device 200 or otherwise use the computing device 200. When the output device is or includes a display, the display can be implemented in various ways, including by a Liquid Crystal Display (LCD); cathode Ray Tube (CRT) displays; or a Light Emitting Diode (LED) display, such as an Organic LED (OLED) display.
The computing device 200 can also include or be in communication with an image sensing device 220, such as a camera or any other image sensing device 220, existing or hereafter developed, capable of sensing images, such as images of a user operating the computing device 200. The image sensing device 220 can be positioned such that it is oriented toward a user operating the computing device 200. In one example, the position and optical axis of the image sensing device 220 can be configured such that the field of view includes an area directly adjacent to the display 218 and visible to the display 218.
The computing device 200 can also include or be in communication with a sound sensing device 222, such as a microphone or any other sound sensing device now existing or hereafter developed that is capable of sensing sound in the vicinity of the computing device 200. The sound sensing device 222 can be positioned such that it is oriented toward a user operating the computing device 200, and can be configured to receive sounds, such as speech or other utterances, made by the user while the user is operating the computing device 200.
Although fig. 2 depicts the CPU 202 and memory 204 of the computing device 200 as being integrated into a single unit, other configurations can be utilized. The operation of the CPU 202 can be distributed across multiple machines (each machine having one or more processors) that can be coupled directly or across a local area network or other network. The memory 204 can be distributed over multiple machines, such as network-based memory or memory in multiple machines performing the operations of the computing device 200. Although depicted as a single bus, the bus 212 of the computing device 200 can be comprised of multiple buses. In addition, secondary storage 214 can be directly coupled to other components of computing device 200 or can be accessed via a network and can include a single integrated unit (such as a memory card) or multiple units (such as multiple memory cards). Computing device 200 may be implemented in a wide variety of configurations.
Fig. 3 is a diagram of an example of a video stream 300 to be encoded and subsequently decoded. Video stream 300 includes video sequence 302. At the next level, the video sequence 302 includes a plurality of adjacent frames 304. Although three frames are described as adjacent frames 304, the video sequence 302 can include any number of adjacent frames 304. The adjacent frames 304 can then be further subdivided into individual frames, e.g., frames 306. At the next level, the frame 306 can be divided into a series of segments 308 or planes. For example, segment 308 may be a subset of frames that allow parallel processing. Segment 308 may also be a subset of frames that are capable of dividing video data into separate colors. For example, a frame 306 of color video data can include a luminance plane and two chrominance planes. Segment 308 may be sampled at different resolutions.
Whether or not frame 306 is divided into segments 308, frame 306 may be further subdivided into blocks 310, which blocks 310 can contain data corresponding to, for example, 16 x 16 pixels in frame 306. The block 310 can also be arranged to include data from one or more segments 308 of pixel data. The block 310 may also have any other suitable size, such as 4×4 pixels, 8×8 pixels, 16×8 pixels, 8×16 pixels, 16×16 pixels, or greater.
Fig. 4 is a block diagram of an encoder 400 in accordance with implementations of the present disclosure. As described above, the encoder 400 can be implemented in the sending station 102, for example, by providing a computer software program stored in a memory, such as the memory 204. The computer software program can include machine instructions that, when executed by a processor, such as CPU 202, cause sending station 102 to encode video data in the manner described herein. Encoder 400 can also be implemented as dedicated hardware included in transmitting station 102, for example. The encoder 400 has the following stages to perform various functions in the forward path (shown by the solid line connection) to produce an encoded or compressed bitstream 420 using the video stream 300 as input: an intra/inter prediction stage 402, a transform stage 404, a quantization stage 406, and an entropy coding stage 408. Encoder 400 may also include a reconstruction path (shown by dashed connecting lines) to reconstruct the frames for encoding of future blocks. In fig. 4, the encoder 400 has the following stages to perform various functions in the reconstruction path: a dequantization stage 410, an inverse transformation stage 412, a reconstruction stage 414, and a loop filtering stage 416. Other structural variations of encoder 400 can be used to encode video stream 300.
When video stream 300 is presented for encoding, frames 306 can be processed in units of blocks. At the intra/inter prediction stage 402, the block can be encoded using intra prediction (also referred to as intra prediction) or inter prediction (also referred to as inter prediction) or a combination of both. In any case, a prediction block can be formed. In the case of intra prediction, all or a portion of the prediction block may be formed from samples in the current frame that have been previously encoded and reconstructed. In the case of inter prediction, all or a portion of the prediction block may be formed from samples in one or more previously constructed reference frames determined using motion vectors.
Next, still referring to fig. 4, the prediction block can be subtracted from the current block at an intra/inter prediction stage 402 to produce a residual block (also referred to as a residual). The transform stage 404 uses a block-based transform to transform the residual into transform coefficients in, for example, the frequency domain. Such block-based transforms include, for example, discrete Cosine Transforms (DCTs) and Asymmetric Discrete Sine Transforms (ADSTs). Other block-based transforms are possible. In addition, combinations of different transforms may be applied to a single residual. In one example of applying the transform, the DCT transforms the residual block into a frequency domain where the transform coefficient values are based on spatial frequencies. The lowest frequency (DC) coefficient is at the top left of the matrix, while the highest frequency coefficient is at the bottom right of the matrix. It is noted that the size of the prediction block and thus the residual block generated may be different from the size of the transform block. For example, the prediction block may be partitioned into smaller blocks to which separate transforms are applied.
The quantization stage 406 uses the quantizer values or quantization levels to convert the transform coefficients into discrete quantization values, which are referred to as quantized transform coefficients. For example, the transform coefficients may be divided by the quantizer values and truncated. The quantized transform coefficients are then entropy encoded by the entropy encoding stage 408. Entropy coding may be performed using any number of techniques, including token trees and binary trees. The entropy encoded coefficients are then output to the compressed bitstream 420 along with other information for decoding the block, which may include, for example, the type of prediction used, the type of transform, the motion vectors, and the quantizer values. The information used to decode the blocks may be entropy coded into blocks, frames, slices, and/or segment headers within compressed bitstream 420. The compressed bitstream 420 can also be referred to as an encoded video stream or an encoded video bitstream, and these terms will be used interchangeably herein.
The reconstruction path (shown by the dashed connection line) in fig. 4 can be used to ensure that both encoder 400 and decoder 500 (described below) use the same reference frames and blocks to decode compressed bit stream 420. The reconstruction path performs functions discussed in more detail below that are similar to the functions performed during the decoding process, including dequantizing quantized transform coefficients at dequantization stage 410 and inverse transforming the dequantized transform coefficients at inverse transform stage 412 to produce a derivative residual block (also referred to as a derivative residual). At the reconstruction stage 414, the prediction block predicted at the intra/inter prediction stage 402 can be added to the derivative residual to create a reconstructed block. A loop filter stage 416 can be applied to reconstructed blocks to reduce distortion, such as block artifacts.
Other variations of encoder 400 can be used to encode compressed bit stream 420. For example, the non-transform based encoder 400 can directly quantize the residual signal without a transform stage 404 for certain blocks or frames. In another implementation, encoder 400 enables quantization stage 406 and dequantization stage 410 to be combined into a single stage.
Fig. 5 is a block diagram of a decoder 500 in accordance with an implementation of the present disclosure. The decoder 500 can be implemented in the receiving station 106, for example by providing a computer software program stored in the memory 204. The computer software program can include machine instructions that, when executed by a processor, such as CPU 202, cause receiving station 106 to decode video data in the following manner. The decoder 500 can also be implemented in hardware included in, for example, the transmitting station 102 or the receiving station 106.
Similar to the reconstruction path of encoder 400 discussed above, decoder 500 in one example includes the following stages to perform various functions to produce output video stream 516 from compressed bitstream 420: an entropy decoding stage 502, a dequantization stage 504, an inverse transform stage 506, an intra/inter prediction stage 508, a reconstruction stage 510, a loop filter stage 512, and a post-filter stage 514. Other structural variations of decoder 500 can be used to decode compressed bit stream 420.
When the compressed bitstream 420 is presented for decoding, data elements within the compressed bitstream 420 can be decoded by the entropy decoding stage 502 to generate a set of quantized transform coefficients. Dequantization stage 504 dequantizes the quantized transform coefficients (e.g., by multiplying the quantized transform coefficients by a quantizer value), and inverse transform stage 506 inverse transforms the dequantized transform coefficients using the selected transform type to produce a derivative residual that may be the same as the derivative residual created by inverse transform stage 412 in encoder 400. Using header information decoded from the compressed bitstream 420, the decoder 500 can use the intra/inter prediction stage 508 to create the same prediction block as created in the encoder 400, e.g., at the intra/inter prediction stage 402. At the reconstruction stage 510, the prediction block can be added to the derivative residual to create a reconstructed block. A loop filter stage 512 can be applied to reconstructed blocks to reduce block artifacts. Other filtering can be applied to the reconstructed block. In one example, post-filter stage 514 is applied to reconstructed blocks to reduce block distortion and the result is output as output video stream 516. The output video stream 516 can also be referred to as a decoded video stream, and these terms will be used interchangeably herein.
Other variations of decoder 500 can be used to decode compressed bit stream 420. For example, decoder 500 can generate output video stream 516 without post-filter stage 514. In some implementations of decoder 500, post-filter stage 514 is applied after loop filter stage 512. Loop filter stage 512 can include an optional deblocking filter stage. Additionally or alternatively, encoder 400 includes an optional deblocking filter stage in loop filter stage 416.
Some codecs may use the level map to code (i.e., encoded by an encoder or decoded by a decoder) the transform block. That is, some codecs may use a level map to code transform coefficients of a transform block. In level map coding, a transform block is decomposed into a plurality of level maps such that the level maps decompose (i.e., reduce) the coding of each transform coefficient value into a series of binary decisions, each binary decision corresponding to a magnitude level (i.e., map level). The decomposition can be accomplished using a multi-round process. Thus, the transform coefficients of the transform block are decomposed into a series of level binary numbers and residuals according to the following equation:
wherein the method comprises the steps of
residue[r][c]＝absolute(coefficient[r][c])-T-1
In the above equation, coefficient [ r ][c]Is the transform coefficient of the transform block at the position (row=r, column=c), T is the maximum level k Is a level map corresponding to the map level k, residual is a coefficient residual map, and sign is a symbol map of transform coefficients. These terms are further described below with respect to fig. 7. The transform coefficients of the transform block can be coded from the level, e.g. by the decoder, using the same equation k The graph, residual graph, and symbol graph sign are reconstructed.
The zero wheel can be used to determine a non-zero map (also referred to as a level 0 map) indicating which transform coefficients of the transform block are zero and which are non-zero. The level graphs (i.e., level 1 graph, level 2 graph,.+ -., level T graph) corresponding to the wheel 1 to the maximum (i.e., threshold) level T are generated in ascending order from level 1 to the maximum level T. The level map of level k (referred to as level k map) indicates which transform coefficients of the transform block have absolute values greater than or equal to k. The level graph is a binary graph. And finally, generating a coefficient residual diagram through a wheel. If the transform block contains transform coefficient values that are higher than the maximum level T, the coefficient residual map indicates the extent (i.e., residual) to which these coefficients are greater than the maximum level T.
When generating (i.e., coding) a level k graph, processing is required to be performed only with a level equal to 1 (i.e., level k-1 [r][c]The position (r, c) of the level (k-1) map corresponding to the position (r, c) of the level (k-1) is determined to be smaller than k, and therefore, it is not necessary to process them for the level k map. This reduces processing complexity and reduces the amount of binary coding operations.
Since the level map contains binary values, the upper and left neighbors of the value to be encoded are binary values. A context model based on binary values of any number of previously coded neighbors can be determined. The context model can fully utilize information from all of these neighbors. The previously coded neighbors may be neighbors in the same level graph or in a previous level graph, e.g., an immediately preceding level graph. The immediately preceding graph of the level k (e.g., level 2) graph is a level (k-1) (e.g., level 1) graph. The context according to the present disclosure may be less complex, resulting in an efficient model for coding the level graph.
When encoding the level k map, the fully coded level (k-1) map and the partially coded level k map can be used as context information for context modeling. Implementations of the present disclosure can reduce the cardinality of a reference sample set as compared to transform coefficient coding for other video systems that code coefficient values one at a time before moving to the next transform coefficient. This is because, as described further herein, the information from the level (k-1) graph and the partially coded level k graph is binary information. The binary information enables the use of complex spatially adjacent templates for contextual modeling of the binary information. Such spatially adjacent templates are able to better capture the statistics of transform blocks, especially those with larger transform block sizes.
Fig. 6 is a flow chart of a process 600 for encoding transform blocks in an encoded video bitstream using a level map according to an implementation of the present disclosure. Process 600 can be implemented in an encoder, such as encoder 400. The encoded video bitstream may be the compressed bitstream 420 of fig. 4.
The process 600 can be implemented, for example, as a software program that can be executed by a computing device such as the sending station 102. The software program can include machine readable instructions that can be stored in a memory, such as memory 204 or secondary storage 214, and can be executed by a processor, such as CPU 202, to cause the computing device to perform process 600. In at least some implementations, the process 600 can be performed in whole or in part by the entropy encoding stage 408 of the encoder 400.
Process 600 can be implemented using dedicated hardware or firmware. Some computing devices can have multiple memories, multiple processors, or both. The steps or operations of process 600 can be distributed using different processors, memory, or both. The use of the term "processor" or "memory" in the singular encompasses a computing device having one processor or one memory as well as a device having multiple processors or multiple memories that can be used in the execution of some or all of the described steps.
Process 600 is now described with reference to fig. 7. Fig. 7 is a diagram illustrating various stages of transform coefficient coding using a level graph in accordance with an implementation of the present disclosure. More specifically, fig. 7 illustrates the various stages as a coefficient coding tree 700. Fig. 7 includes a zig-zag forward scan order 702, a transform block 704, a non-zero map 706, a level 1 map 707, a level 2 map 709, an end of block (EOB) map 726, a symbol map 732, and a coefficient residual map 734. The scanning order may also be referred to as the scanning direction.
Process 600 can receive a transform block, such as transform block 704 of fig. 7. The transform block can be received from a quantization step of an encoder, such as quantization stage 406 of encoder 400 of fig. 4. The transform block 704 includes zero transform coefficients and non-zero transform coefficients. Some of the non-zero coefficients may be negative values.
At 602, a non-zero map is encoded. The non-zero map indicates the locations of transform blocks containing non-zero transform coefficients. The non-zero map can also be referred to as a level 0 map.
The non-zero graph 706 of fig. 6 illustrates a non-zero graph. The non-zero map can be generated by traversing the transform block 704 in a scan order, such as the zig-zag forward scan order 702 of fig. 7, and using the binary values to indicate in the non-zero map 706 whether the corresponding transform coefficients are zero or non-zero. In the non-zero map 706, non-zero transform coefficients of the transform block 704 are indicated with a binary value of 1 (one), while zero transform coefficients are indicated with a binary value of 0 (zero). However, the indication can be reversed (i.e., zero is used to indicate non-zero transform coefficients and one (1) is used to indicate zero transform coefficients).
In one implementation, zero transform coefficients that exceed the last non-zero transform coefficient (i.e., occur after the last non-zero transform coefficient) based on the scan order of the transform block are not indicated in the non-zero map. For example, transform block 704 is scanned using zig-zag forward scan order 702, with the last non-zero transform coefficient 708 corresponding to scan position 11 being the last indicated transform coefficient at the last non-zero coefficient 710 in non-zero map 706. The transform coefficients corresponding to scan positions 12-15 of the zig-zag forward scan order 702 are not indicated in the non-zero graph 706.
At 604, process 600 encodes a corresponding lower range level graph. Each lower range graph has graph levels up to the highest level. The lower range level map indicates which values of the non-zero transform coefficients are equal to the map level of the lower range map and which values of the non-zero transform coefficients are greater than the map level.
For each graph level k, up to a maximum level T, for the lower range level graph level k Encoding is performed. Each lower range level graph indicates which values of the transform block are equal to the graph level of the lower range level graph and which values of the transform block are greater than the graph level. Thus, process 600 decomposes the coding of the transform coefficients into a series of binary decisions, each corresponding to an amplitude level, using multiple rounds (i.e., each round corresponds to level k=1, 2,..and T). The binary decision on coefficients at the rows and columns (r, c) in the level k down-conversion block can be defined by the following equation:
level k [r][c]=1 if the solution (coefficient [ r ]][c])>k
=0 if the absolute (coeffient [ r ] [ c ]) is not more than k
For example, for k=1 (i.e., for level 1 graph 707), process 600 determines for each transform coefficient of transform block 704 whether the absolute value of the transform coefficient is greater than k (i.e., 1) or less than or equal to k. For transform coefficient 720 (i.e., at r=0, c=0), process 600 sets the corresponding value 722 of level 1 graph 707 to 1 because the absolute value of-7 (i.e., | -7|=7) is greater than 1. For the last non-zero transform coefficient 708 (i.e., at r=2, c=2), because the absolute value of-1 (i.e., | -1|=1) is equal to k (i.e., 1), the process 600 sets the corresponding value 716 of the level 1 graph 707 to 0. The last non-zero transform coefficient in the transform block (e.g., the last non-zero transform coefficient 708) can be referred to as the highest AC coefficient.
In one implementation, to generate the lower plane, process 600 can scan the previous level graph backward or vice versa starting from the last 1 value of the previous level graph. For the level k graph, the previous level graph is a level (k-1) graph corresponding to the previous graph level (k-1). That is, for k=2, the previous level diagram is a level 1 diagram. For k=1, the previous level graph is a level 0 graph (i.e., a non-zero graph). For level 1 graph 707, the scan of non-zero graph 706 begins with the last non-zero coefficient 710. For level 2 graph 709, the scan of level 1 graph 707 begins with the last non-zero coefficient 724. In generating the level k map, process 600 need only process transform coefficients corresponding to 1 values in level (k-1). The process 600 need not process transform coefficients corresponding to non-1 values because those values have been determined to be equal to k-1 (i.e., zero values of the level (k-1) map) or less than k-1 (i.e., blank values of the level (k-1) map).
In one implementation, the maximum level T may be fixed. For example, the maximum level T can be provided to the process 600 as a configuration, can be hard coded in a program implementing the process 600, or can be set statistically or adaptively based on previously coded transform blocks or other blocks of the encoded video bitstream. Alternatively, the maximum level T is determined by process 600. That is, process 600 is able to test different values for maximum level T (i.e., t=1, 2, 3, 4.) and determine which value provides the best compression performance. The value of the maximum level T that yields the best compression can be encoded in a video bitstream that can be decoded and used by a decoder, such as decoder 500 of fig. 5. The maximum level T of 2 or 3 has been determined to provide acceptable compression as compared to other values of the maximum level T.
At 606, process 600 encodes the coefficient residual map. Each residual coefficient of the coefficient residual map corresponds to a corresponding (i.e., co-located) non-zero transform coefficient of the transform block having an absolute value exceeding a maximum level. Residual coefficients of transform coefficients at the position (r, c) of the transform block can be calculated using equation (1):
residue[r][c]＝absobute(coefficient[r][c])-T-1 (1)
Fig. 7 illustrates a coefficient residual map 734. In the example of fig. 7, the maximum level T is equal to two (2). Accordingly, the coefficient residual map 734 contains residuals of transform coefficients of the transform block 704 that are greater than 2 in absolute value. The residual coefficient is the degree to which the absolute value of the transform coefficient exceeds the maximum level T. The absolute values of the two values of the transform block 704 are greater than the value of the maximum level T (i.e., 2), i.e., the transform coefficient 720 (i.e., | -7|= 7>2) and the transform coefficient 739 (i.e., |4|= 4>2). Coefficient residual map 734 includes residual 736 and residual 738, respectively. Using equation (1), residual 736 is set to 5 (i.e., absolute (-7) -3=4) and residual 738 is set to 1 (i.e., absolute (4) -3=1).
The residual coefficients of the coefficient residual map 734 can be encoded in the encoded video bitstream using binary coding. A statistical probability distribution of residual coefficients of the fitted coefficient residual map can be used. The probability distribution may be a geometric distribution, a laplace distribution, a pareto distribution, or any other distribution.
Encoding residual coefficients in a video bitstream provides several benefits, such as over video coding systems that encode transform coefficients. Since each residual coefficient is smaller in magnitude than its corresponding transform coefficient, fewer bits are required to encode the residual coefficient. Additionally, since there are fewer residual coefficients to encode (e.g., 2 in the coefficient residual map 734 of fig. 7) than there are non-zero transform coefficients (e.g., 7 in the transform block 704 of fig. 7), additional compression can be generated.
In one implementation of process 600, the symbol map can also be encoded. The symbol map indicates which transform coefficients of the transform block have positive values and which transform coefficients have negative values. No transform coefficients indicated as zero in the symbol diagram are required. The symbol diagram 732 of fig. 7 illustrates an example of a symbol diagram of the transform block 704. In this symbol diagram, negative transform coefficients are indicated with-1 and positive transform coefficients are indicated with 1. In some implementations, the sign of the positive coefficient may be indicated with 0 and the sign of the negative coefficient may be indicated with 1.
In one implementation of process 600, encoding the non-zero map at 602 can also include generating an EOB map of the transform block and interleaving the non-zero map and the EOB map in the encoded video bitstream.
The EOB map indicates whether the non-zero transform coefficients of the transform block are the last non-zero coefficients relative to a given scan order. If the non-zero coefficient is not the last non-zero coefficient in the transform block, it can be indicated in the EOB map with a binary value of 0 (zero). On the other hand, if the non-zero coefficient is the last non-zero coefficient in the transform block, it can be indicated in the EOB map with a binary value of 1 (one).
For example, when the transform coefficient 720 of the transform block 704 is followed by another non-zero transform coefficient (e.g., transform coefficient-1 corresponding to scan position 2), the transform coefficient 720 is not the last non-zero transform coefficient, which is indicated with an EOB value 728 of zero. On the other hand, when the transform coefficient corresponding to scan position 11 (i.e., the last non-zero transform coefficient 708) is the last non-zero coefficient of the transform block 704, it is indicated with an EOB value 730 of 1 (one).
The process 600 is able to interleave values from the non-zero map 706 and EOB map 726 in the encoded bitstream by traversing the non-zero map and EOB map in the same scan order. The process 600 can use a zig-zag forward scanning order 702 or any arbitrary scanning order. For each location (r, c), the values at that row and column of the non-zero map 706 (i.e., nz_map [ r ] [ c ]) are first coded. If the value nz_map [ r ] [ c ] is 1, then the corresponding value from EOB map 726 (i.e., EOB _map [ r ] [ c ]) is next coded to indicate whether the position (r, c) of transform block 704 contains the last non-zero transform coefficient. The process 600 ends the coding of the non-zero map (e.g., the non-zero map 706) when eob _map [ r ] [ c ] is equal to 1 or when the last position in the transformed block (e.g., scan position 15 of the zig-zag forward scan order 702) is reached. That is, when a 1 value from the non-zero map 706 is encoded, that value is followed by another syntax element (i.e., a value to be encoded in the encoded video bitstream) from the corresponding (i.e., co-located) EOB map 726 value to indicate whether the 1 value is the last 1 value of the non-zero map 706.
In one implementation, encoding the non-zero map at 602 can also include determining a coding context for the values of the non-zero map (i.e., the values to be coded). The coding context of the value to be coded at the current position (r, c) can be based on previously coded non-zero neighbor values of the value to be coded in the non-zero graph. The coding context can also be based on the position of the value to be coded within the non-zero graph.
As mentioned above, the context information can be determined based on the number of non-zero previously coded neighbors of the current location, and the context information can be calculated using the sum:
non_zero_map_sum(r，c)＝∑(r′c′)env(r，c)nz_map(r′，c′) (2)
in equation (2), non_zero_map_sum (r, c) is the number of non-zero previously coded neighbors of the value to be coded of the non-zero block at position (r, c), nb (r, c) is the set of previously coded neighbors of the value to be coded at position (r, c) of the non-zero map, and nz_map (r ', c') is the value at position (r ', c') in the non-zero map. Equation (1) is further described with reference to fig. 8.
Fig. 8 is a diagram of previously coded neighbors in a non-zero graph 800 according to an implementation of the present disclosure. Fig. 8 includes a value to be encoded, a current value 802, an unavailable context neighbor 806 (i.e., a neighboring value for which context information is not available), and a coding context neighbor, such as coding context neighbor 808. Ten coding context neighbors are illustrated. Which values are included in the neighbor set depends on the scan order. For example, using the zig-zag forward scan order 702 of fig. 7, the neighbor set illustrated in fig. 8 includes coding context neighbors 804, which include neighbors above and to the left of the current value 802. For the current value 802, non_zero_map_sum (2, 2) =5. This value (i.e., 5) can be used as context information to determine a probability model for coding the current value 802 of the non-zero graph 800.
As indicated above, the coding context can also be based on the position of the value to be coded within the non-zero map or equivalently in the transform block. The locations of the transform blocks can be grouped into context groups. For example, four context groups can be set: a first group corresponding to DC coefficients (i.e., r=0 and c=0), a second group corresponding to the top row other than AC coefficients (i.e., r=0 and c > 0), a third group corresponding to the leftmost column other than AC coefficients (i.e., r > 0 and c=0), and a fourth group corresponding to all other coefficients (i.e., r > 0 and c > 0). Thus, the current value 802 corresponds to the fourth context group.
In one implementation, encoding the non-zero graph at 602 can also include determining a coding context for each value of the EOB graph. The process 600 can determine a context model for the values to be encoded of the EOB map based on the locations of the values to be encoded relative to the frequency information of the transform block. That is, the position of the transform coefficients in the transform block can be used as a context for determining a context model for encoding the corresponding (i.e., co-located) values to be encoded of the EOB map. The transform block can be partitioned into regions such that each region corresponds to a context. Partitioning can be based on the following rationale: the likelihood that the EOB is located at the DC position of the transform block is very low, but the likelihood increases away from the DC coefficient.
In some implementations, the lower range level map may be a binary map having a size corresponding to the size of the transform block and the upper indicated map level k. When the corresponding value in the preceding level map (i.e., level map k-1 described below) is one (1) and the corresponding transform coefficient is greater than map level k of the lower range level map, the position of the lower range level map can be set to one (1). When the corresponding value in the preceding-level map has a value and the corresponding transform coefficient is equal to the map level k of the lower-range-level map, the position of the lower-range-level map can be set to a zero value. When the corresponding value in the previous level graph has a zero value, the position of the lower range level graph may have no value.
In one implementation of process 600, encoding the lower range level map of levels at 604 can also include: a level map coding context is determined for values of the lower range level map based on a scan order of the lower range level map. As indicated above, encoding the values of the lower range level map k corresponds to encoding the binary values, i.e. the corresponding (i.e. co-located) transform coefficients of the transform block, equal to k or higher than k. Encoding binary values yields a simple context. Thus, a plurality of neighboring values of a value can be used as a context for determining a context model for the value.
As indicated otherwise above, the scanning of the lower range level graph can be performed in reverse scan order. Thus, when encoding a value, adjacent values below and to the right of the value to be encoded (e.g., if the scan order is the zig-zag forward scan order of fig. 7 or 702) will have already been encoded. Therefore, the first adjacent value (e.g., lower and right adjacent values) in the lower range level graph can be used as a context. Additionally, the second neighbor values (e.g., top and left neighbor values) in the immediately preceding level (k-1) graph can also be used as context. For k >2, the previous level graph of the lower range level k graph is the lower range level (k-1) graph; and the previous level graph of the level 1 graph is a non-zero graph.
As described above, coding of transform coefficients is a multi-pass process. In the first pass, a non-zero map 706 describing the position of the non-zero coefficients in the transform block is coded following the forward scan order. In a subsequent pass, the values of the non-zero coefficients following the reverse scan order (i.e., from the position of the highest AC coefficient to the position of the DC coefficient) are coded. Coding the non-zero map 706 can be accomplished using the following steps:
1. i=0 is initialized, where i represents the scan position, and i=0 corresponds to the DC position (e.g., transform coefficient 720).
2. A binary non-zero flag nz i indicating whether the quantized transform coefficient at scan position i is zero is coded. For example, when the quantized transform coefficient is zero (i.e., the value in the non-zero map 706 at scan position i is zero), the zero value (nz [ i ] =0) can be coded; otherwise (the value in the non-zero plot 706 at scan position i is 1), a value (nz [ i ] =1) is coded. In another example, the quantized transform coefficient is non-zero, the zero value (nz [ i ] =0) can be coded; otherwise, a value (nz [ i ] =1) is coded.
3. If nz [ i ] indicates that the transform coefficients at scan position i are non-zero (e.g., nz [ i ] =1), a binary flag indicating whether all coefficients at scan positions higher than i are all zero is coded. That is, when 1 value of the non-zero graph 706 is encoded, then values at the same scan position in the EOB graph 726 are then encoded.
4. I is set to the next scanning position (i=i+1).
5. Steps 2-4 are repeated until EOB is met (i.e., until EOB value 730 is coded).
6. Nz [ j ] =0 is set for all j > EOB. That is, all transform coefficients after the EOB value 730 are set to 0.
During a quantization process such as that described with respect to quantization stage 406 of fig. 4, for transform coefficients of a transform block, a Rate Distortion Optimized Quantization (RDOQ) process determines (e.g., calculates, selects, etc.) respective quantized transform coefficients from a rate distortion cost of each of the quantized transform coefficients.
For example, RDOQ may initially provide quantized transform coefficients Q (x) in response to receiving transform coefficient values x. The quantized transform coefficients Q (x) may be obtained first by minimizing distortion (e.g., loss of video quality). However, when RDOQ considers the rate (e.g., number of bits) at which quantized transform coefficients Q (x) are coded in addition to distortion, RDOQ may obtain another quantized transform coefficient Q' (x) that provides a better overall rate distortion cost. This process can continue until the best quantized transform coefficient is obtained for the transform coefficient value x. Thus, the quantized coefficient values of the transform coefficients may change during the coding process of the transform coefficients and/or the transform block comprising the transform coefficients.
As described above, encoding the non-zero graph 706 uses a forward scan order, while encoding the subsequent level graph uses a reverse scan order. Thus, different scan orders are used for the first and second (or subsequent) passes of the encoding: one forward and one backward, it may be difficult to estimate the rate cost of changing the transform coefficient values.
More specifically, in the first pass in which the scan order is forward (from DC coefficient to highest AC coefficient), the change in quantized coefficient values at scan position i may affect the rate cost of coding coefficients at scan position j immediately following scan position i (i.e., j > i); whereas in the second pass, where the scan order is backward or reverse (from the highest AC coefficient to the DC coefficient), the change in quantized coefficients at scan position i may affect the rate cost of coding coefficients at scan position j '(i.e., j' < i) prior to scan position i.
Therefore, in order to estimate the cost of coding the coefficients at scan position i, information from the transform coefficients at scan position j > i and the transform coefficients at scan position j' < i is required to create bi-directional dependencies. This bi-directional dependency can significantly complicate the RDOQ process.
To avoid bi-directional dependencies, instead of interleaving EOB indications (i.e., EOB values of EOB map 726) after non-zero values of non-zero map 706, implementations in accordance with the present disclosure can first code EOB symbols and continue processing non-zero map 706 in reverse scan order. Thus, the reverse scan order can be used for all passes that code the transform block using the level graph. By using the reverse scan order in all passes, only information from the transform coefficients at scan position j (i.e., j > i) immediately following scan position i of the current transform coefficient is needed to estimate the rate cost of coding the coefficients at scan position i. Thus, the complexity is reduced, which in turn results in a more efficient implementation of RDOQ. Thus, the coding of transform blocks using the level map can be achieved using the following steps:
1. And coding the EOB.
2. Nz [ j ] =0 is set for all j > EOB, and nz [ EOB ] =1 is set. If EOB < 1, the process is terminated.
3. Initializing i=eob-1.
4. Nz [ i ] indicating whether the quantized transform coefficient at scan position i is zero (nz [ i ] =0) or non-zero (nz [ i ] =1) is coded.
5. Setting i=i-1.
6. Repeating the steps 3-5 until i= -1.
In the above steps, EOB is as described with respect to fig. 6 and 7. That is, the EOB indicates the position of the last non-zero coefficient of the transform block. However, other semantics of EOB are possible. For example, in one implementation, the EOB can indicate a position immediately after the last non-zero coefficient of the transform block. Accordingly, and with reference to fig. 7 for illustration, the EOB will indicate a scan position 12 (rather than a scan position 11 as described with respect to fig. 6-7).
When EOB indicates a position immediately after the last non-zero coefficient, then the above steps can be given by:
1. and coding the EOB.
2. Nz [ j ] =0 is set for all j+.o EOB, and nz [ EOB-1] =1 is set. If EOB is less than or equal to 1, the process is terminated.
3. Initializing i=eob-2.
4. Nz [ i ] indicating whether the quantized transform coefficient at scan position i is zero (nz [ i ] =0) or non-zero (nz [ i ] =1) is coded.
5. Setting i=i-1.
6. Repeating the steps 3-5 until i= -1.
Fig. 9 is a flow diagram of a process 900 for coding transform blocks using a level graph according to an implementation of the present disclosure. Process 900 can be implemented by an encoder, such as encoder 400 of fig. 4. When implemented by an encoder, coding refers to encoding in an encoded bitstream, such as compressed bitstream 420 of fig. 4. For example, the process 900 can be performed in whole or in part by the entropy encoding stage 408 of the encoder 400. Process 900 can be performed by a decoder, such as decoder 500 of fig. 5. When implemented by a decoder, coding refers to decoding from an encoded bitstream, such as compressed bitstream 420 of fig. 5. For example, the process 900 can be performed in whole or in part by the entropy decoding stage 502 of the decoder 500, and the encoded video bitstream can be the compressed bitstream 420 of fig. 5.
For example, an implementation of process 900 can be performed by storing instructions in a memory, such as memory 204 of receiving station 106, for execution by a processor, such as CPU 202.
Process 900 can be implemented using dedicated hardware or firmware. Some computing devices can have multiple memories, multiple processors, or both. The steps or operations of process 900 can be distributed using different processors, memory, or both. For simplicity of explanation, the process 900 is depicted and described as a series of steps or operations. However, in accordance with the teachings of the present disclosure, various orders and/or concurrences may be employed. Additionally, steps in accordance with the present disclosure may occur with other steps not presented and described herein. Moreover, not all illustrated steps or operations may be used to implement a method in accordance with the disclosed subject matter.
At 902, the process 900 codes an EOB indicator of a transform block. In one implementation, the scanning location of the EOB can be coded. For example, and referring to fig. 7, scan position 11 corresponding to the last non-zero transform coefficient 708 can be coded. In another example, scan positions 12 corresponding to coefficients immediately following the last non-zero transform coefficient 708 in the forward scan order are encoded. In one implementation, the EOB indicator can be coded using a context model.
At 904, the process 900 codes the non-zero map in reverse scan order starting from the last non-zero coefficient of the transform block. The non-zero map indicates which transform coefficients of the transform block have zero values and which transform coefficients of the transform block have non-zero values. Process 900 codes a non-zero graph similar to non-zero graph 706 of fig. 7. The process 900 codes a binary value indicating whether the quantized transform coefficient at a scan position of the scan order is zero or non-zero. For example, for scan position i, if the quantized transform coefficient at scan position i is zero, process 900 can code the zero; otherwise, 1 is coded.
At 906, process 900 codes the respective lower range level graph having the respective graph level up to a maximum level T. The lower range level map with map levels indicates that the transform coefficients of the transform block are equal in absolute value to the corresponding map levels and which transform coefficients of the transform block are greater in absolute value than the corresponding map levels. When implemented by a decoder, process 900 decodes values from the encoded video bitstream to reconstruct a lower range level k map encoded as described with respect to 604 of process 600.
For example, to reconstruct the level 1 graph, process 900 begins with the highest non-zero transform coefficients traversed backward to determine which transform coefficients are equal to 1 and which are greater than 1. That is, using the reconstructed non-zero map of non-zero map 706 of fig. 7, and starting from the last non-zero coefficient 710 and traversing back to value 740, process 900 reconstructs level 1 map 707 of fig. 7. For each 1 value of the reconstructed non-zero map, process 900 decodes the value from the encoded video bitstream and reconstructs the level 1 map 707. The values decoded by process 900 are zero and one (1) values.
To reconstruct the level 2 graph, process 900 uses the same procedure used to generate the level 1 graph, except that process 900 uses the reconstructed level 1 graph instead of traversing the reconstructed non-zero graph. The process 900 repeats all steps until the maximum number of levels of the level graph is reconstructed.
In one implementation, the maximum level T can be provided to the process 900 via configuration. In another implementation, the maximum level T can be signaled by the encoder in the encoded video bitstream. Thus, process 900 decodes the maximum level T from the encoded video bitstream.
At 908, process 900 codes a coefficient residual map. Each residual coefficient of the coefficient residual map corresponds to a corresponding transform coefficient of the transform block having an absolute value exceeding a maximum level. When implemented by a decoder, process 900 reconstructs, for example, coefficient residual map 734 of fig. 7. For each one (1) value of the level T map, process 900 decodes the corresponding residual value from the encoded bitstream to reconstruct coefficient residual map 734 of fig. 7.
In some implementations, the process 900 can include coding the symbol graph at 910. The symbol diagram may be a symbol diagram such as described with respect to symbol diagram 732 of fig. 7. The symbol map indicates which transform coefficients of the transform block have positive values and which transform coefficients have negative values.
For transform blocks of size nxn, it may be necessary to context code nxn-1 binary bits (binary symbols) in the worst case to determine EOB locations. For example, when n=32, at worst, a total of 1023 binary bits may be context coded (i.e., coded using a context model) to determine EOB locations.
Some implementations can use a set of scan positions to reduce the number of contextually encoded binary bits required to encode EOB positions. Thus, encoding the scan position corresponding to the EOB position can include encoding an index of a scan position group including the scan position and encoding an offset within the scan position group, the offset corresponding to a position of the scan position within the scan position group.
In an implementation of the level map, the value eob=0 can be reserved for indicating that all transform coefficients of the block are zero. That is, when eob=0, then the block is an all-zero block.
In one example of such an implementation, the scan locations can be partitioned (e.g., grouped) into 11 scan location groups: 1. 2, [3,4], [5-8], [9-16], [17-32], [33-64], [65-128], [129-256], [257-512], [513-1024]. That is, the group with index 0 includes scan only position 1; the group with index 1 includes scan only position 2; the group with index 4 includes scan positions 9-16; and so on. For example, assuming that the scan position 50 corresponding to EOB is to be encoded, then index 6 of the scan position group [33-64] including scan position 50 is encoded and offset 17 (i.e., 50-33=17) within the scan position group [33-64] is encoded.
In one implementation, an index of a group including coded scan locations corresponding to an EOB is context coded (i.e., coded with arithmetic coding using a context model), and offsets within the group of scan locations can be coded in bypass mode. Bypass mode, which may also be referred to as literal mode, means that the context model is not used to code the value to be coded. For example, the bypass mode can be used when offset values within the range are equally possible. To code offset 17, five (5) bits are required. Thus, in this example, the number of binary bits used for context coding of EOB is at most 10 corresponding to the group index {0,1,..10 }.
In one implementation, the index of the group including the encoded scan positions corresponding to the EOB is context-encoded (i.e., encoded using a context model) and also enables context-encoding of at least some of the most significant bits of the offsets within the group of scan positions. That is, the offset value can be considered to include prefix bits (i.e., most significant bits) and suffix bits (i.e., least significant bits). The prefix bits can be context coded and the suffix bits can be coded using bypass mode. Any number of bits of the offset value can be considered the most significant bits. For example, the offset value 17 corresponds to the binary string 10001. If the first 2 bits are considered the most significant bits, then bit 10 is context coded and bit 001 is bypass coded (i.e., coded using bypass mode). If the first 3 bits are considered the most significant bits, then bit 100 is context coded and bit 01 is bypass coded.
The scan positions can be grouped into groups of scan positions in any number of ways. In one implementation, and as illustrated by the above groups, each group can include a number of scan positions to the power of 2. The power of 2 may be the index scan position group minus 1 (i.e., index-1). For example, the set of scan positions at index 5 (i.e., set [17-32]]) Comprises 2 of 5-1 (＝2 4 =16) scan positions. Therefore, in order to code the offset within the scan position group with index inx, only (inx-1) bits are required. For example, one (1) bit is required to encode a group with index 2 (group [3,4]) Two (2) bits are needed to code the offset in (1) with index 3 (group 9-16]) And so on.
In one implementation, the number of scan positions in each set of scan positions can be limited to a maximum predetermined number (i.e., an upper limit). For example, the group size can be limited to not more than 16. Thus, the above group can be modified as follows: 1. 2, [3,4], [5-8], [9-16], [17-32], [33-48], [49-64], …, [1009-1024]. Therefore, no more than 4 bits are required to code the offset. To code EOB locations of 50 using the modified set, arithmetic coding can be used with the context model to code index 7 corresponding to scan location set [49-64 ]. Offset 1 (=50-49) can be coded in the bypass mode by using 4 bits, i.e., 0001.
In some implementations, the value eob=0 is not reserved for indicating that all transform coefficients of the block are zero. In such implementations, the set of scan positions can start at 0 and end at 1023, such as 0, 1, [2,3], [4-7], [8-15], [16-31], [32-63], [64-127], [128-255], [256-511], [512-1023].
As described above, the values of the non-zero map 706 include binary values. The binary value indicates whether the transform coefficient at a given position of the transform block is zero or non-zero. Thus, the value of the non-zero map can be considered as a non-zero flag. Binary values enable the use of complex spatially adjacent templates for context modeling. Such spatially adjacent templates are able to better capture the statistics of transform blocks, especially those with larger transform block sizes. Thus, the coding of the non-zero flags (and the coding of the transform coefficients) can be improved by fully utilizing the information of the neighboring non-zero flags when determining the context for selecting the context model.
The template captures the coding history of non-zero marks (i.e., the values of the non-zero graph) coded before the current non-zero mark. For the current scan position, the template can define (e.g., specify, select, set, or in any way define) the scan position to be used to determine the non-zero map values for the context used to code the current value. Equivalently, templates can be defined in terms of Cartesian coordinates of non-zero values to be used in determining context within a non-zero graph.
10A-10B are diagrams of an example 1000 of a template for determining a coding context according to implementations of the disclosure. In fig. 10A-10B, the values masked using pattern 1004 (i.e., circles representing the values of the non-zero graph) are the values to be coded; while the values obscured with pattern 1002 are the values for which context information is available, because these values are encoded prior to the value 1032 to be encoded (e.g., they are context neighbors). In the example of fig. 10A-10B, the value to be coded 1032 depicts the current value of the non-zero graph to be coded. The examples of fig. 10A-10B are non-limiting examples. Templates having other shapes and/or sizes are also possible.
In one example, the number of non-zero values corresponding to the template locations can be used as a context for coding the current value. For example, a value corresponding to the template position can be added and the sum can be used as a context. In some cases, the template neighbor (location) may not be available, such as, for example, if the context location is outside the boundary of the block. In one example, the unavailable value can be assumed to be zero (0). In another example, the unavailable value can be assumed to be one (1).
The codec can use a variety of transform types. For example, the transform type may be the transform type used by the transform stage 404 of fig. 4 to generate the transform block. For example, the transform type (i.e., inverse transform type) may be the transform type to be used by the dequantization stage 504 of fig. 5. The available transform types can include one-dimensional discrete cosine transform (1D DCT) or an approximation thereof, one-dimensional discrete sine transform DST (1D DST) or an approximation thereof, two-dimensional DCT (2D DCT) or an approximation thereof, two-dimensional DST (2D DST) or an approximation thereof, and identity transform. Other transformation types may be available. In one example, a one-dimensional transform (1D DCT or 1D DST) can be applied in one dimension (e.g., row or column) while an identity transform is applied in another dimension.
In the case of using a 1D transform (e.g., a 1D DCT, a 1D DST) (e.g., applying a 1D DCT to a column (or row) of transform blocks), the quantized coefficients can be coded using a row-by-row (i.e., raster) scan order or a column-by-column scan order. In the case of using a 2D transform (e.g., a 2D DCT), the quantized coefficients may be coded using a different scan order. As indicated above, different templates can be used to derive a context for coding the non-zero flags of the non-zero graph based on the type of transform used. Thus, in one implementation, the templates can be selected based on the type of transform used to generate the transform block. As indicated above, examples of transform types include: 1D DCT applied to rows (or columns) and identity transform applied to columns (or rows); 1D DST applied to a row (or column) and identity transformation applied to a column (or row); 1D DCT applied to rows (or columns) and 1D DST applied to columns (or rows); 2D DCT; and 2D DST. Other combinations of transforms can include transform types.
As indicated above with respect to fig. 9, the non-zero map can be coded in reverse scan order starting from the last non-zero coefficient of the transform block (i.e., starting from the highest AC transform coefficient). Thus, the coding history of the current value of the non-zero graph (i.e., the current non-zero marker) includes values to the right and below the current value in a two-dimensional non-zero legend such as non-zero graph 706.
When a 1D vertical transform type is applied, the value to be coded 1032 is more correlated with vertical neighbor values than horizontal neighbor values. Thus, the template 1010 can be used with a 1D transform (e.g., 1D DCT) applied to the columns. Assuming that the value 1032 to be coded is at a position (x, y) of a non-zero map, the template 1010 includes values at seven positions (x+1, y), (x+2, y), (x+3, y), (x+4, y), (x, y+1), (x+1, y+1), and (x+1, y+2).
When a 1D horizontal transform type is applied, the value to be coded 1032 is more correlated with horizontal neighbor values than with vertical neighbor values. Thus, the template 1020 can be used with a 1D transform (e.g., 1D DCT) applied to the rows. Assuming that the value 1032 to be coded is at position (x, y) of the non-zero map, the template 1020 includes values at seven positions (x+1, y), (x, y+1) (x+1, y+1), (x, y+2), (x+1, y+2), (x, y+3), and (x, y+4).
The template 1030 can be used when applying 2D transform types (e.g., 2D DCT, 2D STT). Assuming that the value 1032 to be coded is at a position (x, y) of a non-zero map, the template 1030 includes values at seven positions (x+1, y), (x+2, y), (x, y+1), (x+1, y+1), (x+2, y+1), (x, y+2), and (x+1, y+2).
In some examples of templates, non-zero values scanned immediately prior to the value 1032 to be coded are not included in the template. That is, if the value to be coded 1032 is at scan position i, no non-zero value at scan position (i-1) is included in the template. Even if the non-zero map is coded in reverse scan order, the scan order of the reverse scan order may depend on the transform type. The scan order of the reverse scan order is the order in which the non-zero values of the non-zero map are accessed from the highest AC value to the DC value. In one example, a vertical scan order can be used when using a 1D horizontal transform type. Thus, the scanning order proceeds in a column-by-column order (e.g., from bottom to top). In one example, a horizontal scan order can be used when using a 1D vertical transform type. Thus, the scanning order proceeds in a row-by-row order (e.g., right to left).
The template 1040 is another example of a template that can be used when a 1D transform type is applied to a column. In the template 1040, non-zero values scanned immediately prior to the value 1032 to be coded are not included in the template. Assuming that the value 1032 to be coded is at a position (x, y) of a non-zero map, the template 1040 includes values at seven positions (x+1, y), (x+2, y), (x+3, y), (x+4, y), (x+1, y+1), and (x+1, y+2).
Template 1050 is another example of a template that can be used when applying a 1D transform type to a line. In the template 1050, no non-zero values are included in the template that are scanned immediately prior to the value 1032 to be coded. Assuming that the value 1032 to be coded is at a position (x, y) of a non-zero map, the template 1040 includes values at seven positions (x, y+1), (x+1, y+1), (x, y+2), (x+1, y+2), (x, y+3), (x+1, y+3), and (x, y+4).
Template 1060 is an example of a template that can be used when using 2D transforms (e.g., 2D DCT, 2D DST). Assuming that the value 1032 to be coded is at a position (x, y) of a non-zero map, the template 1040 includes values at seven positions (x+1, y), (x+2, y), (x+3, y), (x, y+1), (x+1, y+1), (x, y+2), and (x, y+3).
Each of templates 1010-1060 includes seven (7) positions. However, the templates can include more or fewer locations and/or can have other shapes. For example, the template 1070 is another example of a template that can be used when a 2D transform type is used. The template 1070 includes eight (8) positions. Assuming that the value 1032 to be coded is at a position (x, y) of the non-zero map, the template 1040 includes values at eight positions (x+1, y), (x+2, y), (x+3, y), (x, y+1), (x+1, y+1), (x, y+2), (x+1, y+2), and (x, y+3).
In other examples, the template can include five (5) positions. For example, template 1088 of FIG. 10B including locations (x+1, y), (x, y+1), (x+2, y), (x, y+2), (x+1, y+1) can be used for the 2D transform type. For example, templates 1080, 1082, 1083 can be used for vertical 1D transform types. Template 1080 includes positions (x+1, y), (x+2, y), (x+3, y), (x+4, y), and (x, y+1). Template 1082 includes positions (x+1, y), (x+2, y), (x+3, y), (x+4, y), and (x+1, y+1). Template 1083 includes positions (x, y+1), (x, y+2), (x, y+3), (x+1, y), (x+1, y+1). For example, templates 1084, 1086, and 1087 can be used for horizontal 1D transform types. Template 1084 includes positions (x+1, y), (x+2, y), (x+3, y), (x, y+1), (x+1, y+1). Template 1086 includes positions (x, y+1), (x, y+2), (x, y+3), (x, y+4), and (x+1, y+1). Template 1087 includes positions (x, y+1), (x, y+2), (x, y+3), (x, y+4), and (x+1, y). In some implementations, positions (x+1, y) and (x, y+1) can be replaced with positions (x+1, y+2) and (x+2, y+1), respectively.
In some implementations, the coding of the level k graph (where k > 0) can also use different templates (e.g., the templates described above) depending on the type of transformation. For example, as described above, one template may be used for a 2D transform type, one template may be used for a vertical 1D transform type, and another template may be used for a horizontal 1D transform type.
In some implementations, the context used to code the non-zero marker may depend on the location of the non-zero marker (i.e., the scan location or the block location). Thus, in some implementations, the transformation type-related templates described above can be combined with the locations of the non-zero flags to determine context. To avoid using too many contexts, this may lead to so-called context dilution problems, enabling classification of locations into areas. For example, the classification may depend on the type of transformation.
The level graphs are coded in turn as described above with respect to fig. 7. That is, the non-zero map 706 is encoded, then the level 1 map is encoded, then the level 2 map is encoded, and then the coefficient residual map 734 is encoded. However, in some implementations, a different coding structure can be used.
As described above with respect to fig. 10A-10B, the coding of the level k graph (where k > 0) can also use different templates (e.g., templates as described above) depending on the type of transformation. That is, the templates described above can be used to determine a context for coding whether the coefficients at (x, y) are greater than 1 (e.g., using the corresponding values of level 1 graphs, such as level 1 graph 707 of fig. 7) or greater than 2 (e.g., using the corresponding values of level 2 graphs, such as level 2 graph 709 of fig. 7).
Thus, each coefficient can be coded until it is greater than a maximum level. In the example of fig. 7, the maximum level is 2. Thus, each coefficient can be coded until it is greater than 2 (using the corresponding value of the level graph) before proceeding to the coding of the next coefficient. In one implementation, coefficient values greater than 2 (i.e., coefficient values greater than the maximum level) can be represented by a value of 3 (i.e., maximum level +1). Thus, coding a coefficient "until the coefficient is greater than a maximum level (e.g., 2)" (i.e., coding an "reached" value) can refer to coding values 0, 1, 2, and..times, (maximum level +1) (e.g., 3) that correspond to coefficients having values equal to 0, equal to 1, equal to 2, and greater than 2, respectively and with a maximum level of 2. For brevity, and as mentioned above, the value resulting from coding a coefficient "until whether the coefficient is greater than a maximum level" is referred to herein as an "arrival" value.
The "arrival" values of the coefficients of the transform block can be collectively referred to as a "lower plane" or a first plane. Coefficient residual map, such as coefficient residual map 734 of fig. 7, is also referred to herein as the "upper plane" or second plane.
Fig. 11 is a flow diagram of a process 1100 for coding transform blocks using a level diagram according to an implementation of the present disclosure. Unlike process 900, which encodes the level graphs in turn (i.e., each graph is encoded before proceeding to encode the next graph), process 1100 uses templates for each non-zero coefficient and encodes whether the coefficient is 0, 1, 2, or greater than 2 (represented by a value of 3) with a maximum level of 2 (i.e., t=2). That is, the process 1100 codes the "arrival" value of the lower plane of coefficients in scan order before proceeding to the next coefficient. Process 1100 can include blocks similar to those of process 900. Descriptions of similar blocks (e.g., 902, 908, and 910) are omitted. Some implementations of process 1100 can include block 910 prior to block 908.
Process 1100 can be implemented by an encoder, such as encoder 400 of fig. 4. When implemented by an encoder, coding refers to encoding in an encoded bitstream, such as compressed bitstream 420 of fig. 4. For example, the process 1100 can be performed in whole or in part by the entropy encoding stage 408 of the encoder 400. Process 1100 can be performed by a decoder, such as decoder 500 of fig. 5. When implemented by a decoder, coding refers to decoding from an encoded bitstream, such as compressed bitstream 420 of fig. 5. For example, the process 1100 can be performed in whole or in part by the entropy decoding stage 502 of the decoder 500, and the encoded video bitstream can be the compressed bitstream 420 of fig. 5.
For example, an implementation of process 1100 can be performed by storing instructions in a memory, such as memory 204 of receiving station 106, for execution by a processor, such as CPU 202.
Process 1100 can be implemented using dedicated hardware or firmware. Some computing devices can have multiple memories, multiple processors, or both. The steps or operations of process 1100 can be distributed using different processors, memory, or both. For simplicity of explanation, the process 1100 is depicted and described as a series of steps or operations. However, in accordance with the teachings of the present disclosure, various orders and/or concurrences may be employed. Additionally, steps in accordance with the present disclosure may occur with other steps not presented and described herein. Moreover, not all illustrated steps or operations may be used to implement a method in accordance with the disclosed subject matter.
At 1102, process 1100 determines whether there are more non-zero coefficients to code. If so, process 1100 proceeds to 1104 to code the current quantized transform coefficients at (x, y); otherwise, process 1100 proceeds to 908, followed by 910. At 1104, process 1100 selects a template for coding the current quantized transform coefficient. As used in this disclosure, "selecting" is intended to identify, construct, determine, specify, generate, or otherwise select in any manner. The template may be a template as described with respect to fig. 10A-10B. In one example, the same template is used to code all coefficients of the transform block. Thus, a template can be selected once for process 1100 and executed prior to block 1102.
At 1106, process 1100 uses the templates to determine the context. The process 1100 can use templates to determine context in any number of ways. Each template position corresponds to a lower plane value (e.g., 0, 1,..once., t+1). The combination of values can be used to determine a context. For example, a sum of these values can be used. For example, a weighted sum can be used to determine the context. The weight assigned to a location can be set based on the distance to the "origin". In one example, the origin may be the location (x, y) of the current transform coefficient that is determining the context. Examples of distances include a scan position distance (e.g., the difference between the scan position of the current coefficient and the position of the template) or a Cartesian distance. However, other ways of setting the weights may be available. In yet another example, a nonlinear function can be used. For example, the maximum or minimum in the template can be used to determine the context. In yet another example, the sum can be used in combination with the maximum to determine the context. Other methods and/or values or combinations of methods and/or values can be used to determine context from the templates.
It is now given to determine the context using the sum (i.e., addition) of the values at the locations of the template. It should be appreciated that the following can be used with any method for determining a context using templates.
Process 1100 can add (sum) values corresponding to locations of the template. When templates are used to derive a context for coding coefficients, each of the positions of the templates can have one of the values 0, 1, 2, or 3 (i.e., when t=2). Thus, if the template includes N positions, the maximum sum may be 3*N. For example, if a template including 5 positions is selected at 1104, the maximum sum may be 15 (= 3*5); if a template comprising 7 positions is selected, the maximum sum may be 21 (= 3*7).
In one implementation, where the values of the locations of the templates are determined using a level graph as described with respect to fig. 7, the values at the same locations in the non-zero and level k graphs can be added or counted. For example, assuming that the position of the last non-zero transform coefficient 708 is the position of the template, the value of the template at that position can be determined as the sum of the value at 710 of the non-zero map 706 (i.e., 1) and the value at 716 of the level 1 map 707 (i.e., 0). Thus, the value is 1. In addition, assuming that the position of the transform coefficient 739 is the position of the template, the value of the template at that position can be determined as the sum of values at the corresponding positions of the non-zero map 706, the level 1 map 707, and the level 2 map 709. Thus, the value is 3. Thus, the context index can be determined using a sum of values corresponding to locations of the templates, where each value of the templates is determined by summing the respective values of at least some of the level graphs.
In another implementation, a level graph including zero graphs and as described with respect to fig. 7 is not generated. Alternatively, a lower plane one-dimensional array level can be used to indicate whether the transform coefficient is one of 0,1,..and t+1. In view of the fact that the lower plane is a two-dimensional structure corresponding to the transform block, a one-dimensional array level of the lower plane is generated as a result of the scan order. The lower plane one-dimensional array level is referred to as a lower plane array.
Given a scan position i, level [ i ] = {0,1,... The lower plane array level can include values of all transform coefficients of the transform block. Alternatively, the lower plane array can include values of coefficients up to EOB coefficients. That is, the lower plane array level can include the value of each transform coefficient up to and including the last non-zero coefficient of the transform block.
In the case of an encoder, the lower plane array level can be generated a priori before encoding the lower plane array values in the bitstream. Alternatively, the lower plane array level can be generated when the coefficients are encoded. For example, the following steps can be used to generate the lower plane array: 1) for scan positions, a corresponding "reach" value is determined, 2) the "reach" value is coded, and 3) the "reach" value is stored/placed at the scan position in the lower plane level. Steps 2 and 3 can be reversed. In the case of a decoder, the lower plane array level can be filled with values when decoding the values from the bitstream.
The sum for determining the context index can be calculated by adding the corresponding values of the lower plane array level. For example, assume that the template includes a scan position l 1 、l 2 、l 3 、l 4 And l 5 Corresponding 5 positions, then the sum can be determined to be sum = level 1]+level[l2]+level[l3]+level[l4]+level[l5]。
Using the sum, the process 1100 can determine a context index (e.g., variable ctx). The context index can be determined using an operation similar to the operation ((count+1) > 1) described above. However, instead of using "count", a "sum" is used. Thus, process 1100 uses ((and +1) > 1) to determine the context index.
The context index ctx may be out of range. For example, assuming that the sum is 15, the transform CLASS is TX_CLASS_2D, and (x, y) is (1, 2), then the context index is ((sum +1) > 1) +6= ((15+1) > 1) +6=14. However, the number of available contexts for tx_class_2d using the above example is 11. Thus, the context index is out of range. Equivalently, the sum itself of the context indices that produce the out-of-range may be considered out-of-range. If the context index is out of range, the process 1100 can set the context index to a predetermined number. Thus, process 1100 can determine the context index using a formula such as min (((and +1) > 1), a predetermined number). Therefore, the upper limit of the value ((and +1) > 1) is a predetermined number. In one example, the predetermined number may be 4. In one example, the predetermined number may depend on the transform class type. The predetermined number can be selected in any other way.
The context index ctx can be used to select a context for coding the current transform coefficient; more specifically, for coding the "reach" value of the current transform coefficient. At 1108, process 1100 uses the context to code the coefficients.
The implementation of process 1100 for coding transform coefficients of a transform block using a lower plane array level can be summarized using the following procedure:
steps 1-10 can be repeated for each transform coefficient until the last non-zero coefficient of the transform block. For the transform coefficients at scan position i, steps 2-9 code the "reach" value. That is, steps 2-9 code "whether the transform coefficients up to the transform block are greater than the maximum level of the level map". For example, assuming a maximum level t=2 and i < eob-1, if level [ i ] =3, steps 2-9 code bit 111; if level [ i ] =0, steps 2-9 code bit 0; whereas if level i=2, steps 2-9 code bit 110. Steps 11-14 code sign bits (e.g., values of the sign diagram 732 of fig. 7) of the non-zero transform coefficients until the last non-zero coefficient. For each non-zero coefficient that is greater than the maximum level T (i.e., level i > T), steps 15-17 code the residual of the transform coefficients. That is, steps 15-17 code the values from the upper plane. The values of the residuals may be as described with respect to coefficient residual map 734. The coding of the sign bits and residuals may be reversed.
Blocks 1102-1108 of fig. 11 correspond to coding the lower plane and block 908 corresponds to coding the upper plane described above.
The coding structure described in fig. 11 is used for coding transform coefficients (i.e., quantized transform coefficients), as compared to the coding structure described with respect to fig. 9, a better throughput can be obtained. Better throughput may mean that the coding structure of the usage process 1100 can decode the transform block faster than the coding structure of the usage process 900.
FIG. 12 is an example of a diagram 1200 of using templates to determine context according to implementations of the disclosure. The diagram 1200 uses templates as described with respect to fig. 10A-10B to determine a context index for the value 1032 to be coded. The template used in diagram 1200 is template 1088 of fig. 10B. However, other templates can be used, such as template 1070. The value to be encoded may be the value to be encoded 1032 of fig. 10A-10B. In fig. 10B, the neighbors of the value 1032 to be coded are shown as having actual values. In fig. 12, for ease of reference, the neighbors of the value 1032 to be coded are numbers (i.e., 1-5).
As described with respect to fig. 11, the coding proceeds in reverse scan order and a lower plane array level can be created. In the case of an encoder, "coding" refers to encoding, and "to-be-coded" values refer to values to be added to a compressed bitstream, such as compressed bitstream 420 of fig. 4. In the case of a decoder, "coding" refers to decoding, and "to-be-coded" values refer to values to be read or decoded from a compressed bitstream, such as compressed bitstream 420 of fig. 5. The values of the lower plane array level are arranged according to the scan order.
The scan order determines a mapping from the scan order position (i.e., position) of the one-dimensional lower plane array level to the Cartesian position or lower plane of the transform block; equivalently, the scan order determines a mapping from the Cartesian position to the scan order position.
As described above, the value to be coded of the template for the lower plane indicates the scan position of the coding level of the lower plane. Equivalently, a template can indicate Cartesian coordinates when there is a one-to-one correspondence between scan positions and Cartesian coordinates for a given scan order. The coordinates may be absolute coordinates using a DC coefficient as an origin. Alternatively, the coordinates may be relative coordinates (e.g., defined as vertical and horizontal offsets from the value to be coded). The neighbors specified by the template are arranged along the template anti-diagonal. For example, and referring again to template 1088 of fig. 12, neighbors 1 and 3 are arranged along template anti-diagonal 1202; and neighbors 2, 4 and 5 are arranged along the template anti-diagonal 1204. Thus, and depending on the number of adjacent positions of the templates, the scan positions indicated by the templates are arranged in the templates in at least two template anti-diagonals. For example, while the scan positions indicated by templates 1088 are arranged along two template anti-diagonals, the scan positions indicated by templates 1070 of fig. 10A are arranged along three template anti-diagonals.
An illustration of the use of template 1088 in a different scanning order is now presented. The illustration uses 4 x 4 blocks; however, the present disclosure is not limited to any block size. The 4 x 4 lower plane 1216 is processed using the inverse vertical scan order 1208, with the value of the one-dimensional lower plane at scan position 1210 (i.e., scan position 14 in the scan order) corresponding to the lower plane value corresponding to the transform coefficient at the Cartesian position (1, 0) of the transform block. Assuming scan position 1210 is the value 1032 to be encoded and template 1088 is superimposed over reverse vertical scan order 1208, adjacent positions 1-5 of template 1088 correspond to scan positions 10, 6, 13, 9, and 12, respectively. The adjacent scanning positions are 6, 9, 10, 12 and 13 in ascending order. As can be seen, the scan positions are not continuous. That is, the scanning positions are not sequential.
As another example, using the reverse horizontal scan order 1212, the same cartesian position (1, 0) corresponds to scan position 11 (scan position 11 in the scan order). Assuming scan position 1214 is the value 1032 to be encoded and template 1088 is superimposed over reverse horizontal scan order 1212, then adjacent positions 1-5 of template 1088 correspond to scan positions 10, 9, 7, 6, and 3, respectively. In ascending order, adjacent scan positions are 3, 6, 7, 9, and 10. Again, the scanning positions of adjacent positions are not consecutive (i.e., sequential).
The lower plane array 1206 illustrates a hypothetical ordering of values of a lower plane (not shown) according to a hypothetical scan order. As can be seen in the lower plane array 1206, the example of the reverse vertical scan order 1208, and the example of the reverse horizontal scan order 1212, adjacent values 1-5 of the values 1032 to be coded using the template 1088 are sparsely (i.e., discontinuously) located in the one-dimensional lower plane array level. Thus, using five neighbors of template 1088 to derive the context model requires access to sparse points in the one-dimensional array.
Note that for almost all computing platforms, including x86, ARM, and hardware implemented codecs, the two-dimensional array transform coefficients are stored in a 1-D array (also referred to as a line buffer). The lower plane array can also be stored in a line buffer. Because accessing non-contiguous (i.e., non-contiguous) data from the line buffer degrades data cache performance, using scan orders and/or techniques in which adjacent values are located continuously in the line buffer can improve coding performance.
Fig. 13 is a diagram of an example 1300 of a scan order along anti-diagonal alignment values according to an implementation of the present disclosure. Example 1300 includes block 1302. Block 1302 may be a transform block from which lower plane values can be determined. That is, the lower plane block is not generated, but the value of the lower plane block is inferred from the transform coefficients. Alternatively, block 1302 can represent a lower plane. That is, the lower plane can be generated from the transform coefficients and stored in memory. For simplicity of illustration, block 1302 is assumed to be a two-dimensional lower plane.
Block 1302 is shown as an 8 x 8 block. However, the present disclosure is not limited to any particular block size. As indicated above, the lower plane will include the values of the transform coefficients at the same cartesian position of the transform block at the cartesian position. However, for illustration purposes, the cells of block 1302 show the scan locations of the respective cells, rather than the particular values at the cells. As indicated above, the lower plane, such as block 1302, can be generated as a value encoded in the bitstream. Thus, block 1302 may not be completely filled with values. For example, if the current scan position is x, block 1302 may include only values for scan positions that are lower (or lower and include) than scan position x.
The scan order of example 1300 can be referred to as an anti-diagonally aligned scan order. Using anti-diagonal aligned scan orders, the codec can advantageously process all values in one scan order anti-diagonal (to determine the context index) using efficient parallel computation, thereby improving cache performance.
Four scan order anti-diagonals are indicated in example 1300. The scan order anti-diagonal 1304 includes scan positions 54-57; the scan order anti-diagonal 1306 includes scan positions 49-53; the scan order anti-diagonal 1308 includes scan positions 43-48; and scan order anti-diagonal 1310 includes scan positions 36-42.
Each scan order anti-diagonal is a line such that the levels having the same value col + row in block 1302 are considered to be on the same scan order anti-diagonal. For example, the scan order anti-diagonal 1304 includes a value having col+row=3. Thus, scan order anti-diagonal 1304 includes data corresponding to scan position 54 (corresponding to the value at block 1302 position (0, 3)), scan position 55 (corresponding to the value at block 1302 position (1, 2)), scan position 56 (corresponding to the value at block 1302 position (2, 1)), and scan position 57 (corresponding to the value at block 1302 position (3, 0)).
As mentioned above, templates of neighboring locations can be used to determine a context for coding values at particular scan locations of block 1302. Template 1088 of fig. 10B is again used for illustration purposes. As mentioned further above, a combination of values of neighboring locations can be used to determine a context index (i.e., ctx) for selecting a context model. For purposes of illustration, both used and combined (i.e., added) herein.
Superimposing template 1088 on each of the scan positions of scan order anti-diagonal 1306 indicates that template anti-diagonal 1202 of fig. 12 coincides with scan order anti-diagonal 1308 and template anti-diagonal 1204 of fig. 12 coincides with scan order anti-diagonal 1310. Thus, the encoded values (e.g., of scan positions 49-53) of the current scan order anti-diagonal (e.g., scan order anti-diagonal 1306) use the value of the first scan order anti-diagonal encoded immediately before the current scan order anti-diagonal (e.g., scan order anti-diagonal 1308) and the value of the second scan order anti-diagonal encoded immediately before the first scan order anti-diagonal (e.g., scan order anti-diagonal 1310). The scan order anti-diagonal 1310 is said to be "older" than the scan order anti-diagonal 1308 because its value is coded first.
Hereinafter, the notation(i.e., the number with the wave number thereon) refers to "the value of the lower plane at the scanning position X". For example, a->Refers to the value of the lower plane (i.e., block 1302) at scan position 31. That is, and referring to the lower plane array level of FIG. 11, +.> Additionally, the notation O (X) refers to a context index of a context to be used for coding a value at a scan position X. O (X) is calculated using an operation such as an addition operation with adjacent values identified in the template.
Referring to block 1302, the context indices for the contexts used to code the values at scan locations 50, 51 and 52 are respectively Andif a value is not available, as indicated above with respect to 10A-10B, it can be assumed to be zero. Thus, the context index for the context used to code the value at scan position 11 isBecause scan location 1312 is not available (i.e., scan location 1312 is outside the bounds of the transformed block of block 1302).
As can be seen from O (5), O (51) and O (52), the values of the context model used to determine two consecutive positions in the scan order anti-diagonal overlap. For example, a value from scan order anti-diagonal 1308 (e.g., ) And two values from scan order anti-diagonal 1310 (e.g., ++>And->) Is re-used to determine the context indices O (50) and O (51); while a value from scan order anti-diagonal 1308 (e.g.)>) And two values from scan order anti-diagonal 1310 (e.g., ++>And->) Is re-used to determine the context indices O (51) and O (52). This pattern is repeated for all values of the scan order anti-diagonal.
To reiterate, two consecutive scan positions (e.g., scan positions 50 and 51) along the same scan order anti-diagonal (e.g., scan order anti-diagonal 1306) share a previously coded value (e.g.,and->) For computing a context index. The shared value is along a previously coded scan order anti-diagonal (e.g., scan order anti-diagonal 1308, 1310) corresponding to the template anti-diagonal (e.g., template anti-diagonal 1202, 1204).
Additionally, note that the value of each previously coded scan order anti-diagonal required to code the current value to be coded is continuous along the corresponding scan order anti-diagonal. For example, to determine the context index O (50), the required valueAnd->Is continuous along the scan order anti-diagonal 1308 and the required value +. >And->Is continuous along the scan order anti-diagonal 1310. Thus, by storing the value of each scan order anti-diagonal in a separate line buffer, determining the context index can be performed by accessing successive locations in each line buffer, thereby improving coding performance.
The minimum number of line buffers depends on the number of template anti-diagonals. For example, since the stencil 1088 includes two stencil anti-diagonals (i.e., the stencil anti-diagonals 1202, 1204), two line buffers need to be maintained. For example, if the template 1070 of FIG. 10A is used, three line buffers need to be maintained.
For transform blocks of size n×n (where M > N), each line buffer can include up to N values. Thus, for block 1302 (which is 8 x 8 in size), and using template 1088, each of the two line buffers of size 8 can be used. The line buffer LB1 can correspond to the scan order anti-diagonal 1310. The line buffer LB2 can correspond to the scan order anti-diagonal 1308.
The total number of scan order anti-diagonals for a lower plane of size N is 2N-1. For example, block 1302 includes 2*8-1=15 scan order anti-diagonals. In one implementation, each scan order anti-diagonal can have an index L, where l=0, 1,..2N-2. The number of values NUM (L) in the scan order anti-diagonal L can be given by:
For example, the scan order anti-diagonal 1314 has an index l=0, and includes a value of (l+1) = (0+1) =1. The index of the scan order anti-diagonal 1310 is l=8. Thus, scan order anti-diagonal 1310 includes (2*8-8-1) =7 values.
Since some of the scan order anti-diagonals may not include N values, some positions of the corresponding line buffers can be assumed to be zero. The number of positions of the line buffer assumed to be zero is equal to (N-NUM (L)). For example, since the index of the scan order anti-diagonal 1308 is l=9, the corresponding line includes 2 (i.e., 8-NUM (9) =8- (2*8-9-1) =8-6=2) positions assumed to be zero.
In one implementation, the assumed zero position of the line buffer can be assumed to be the head of the line buffer. In another implementation, the location assumed to be zero can be at the tail of the line buffer.
In one implementation, the values in the line buffers can be arranged with reference to edges of the transform block. For example, the bottom edge can be used as a reference. That is, the value of the scan order anti-diagonal line closer to the reference edge (e.g., bottom edge) is stored to the front of the line buffer. In such a case, if the scanning order anti-diagonal line accesses the position from the top of the block toward the bottom of the block, the scanning positions of the scanning order anti-diagonal line are arranged in the corresponding line buffers in the reverse order of the traversal order; whereas if the scan order anti-diagonal accesses a location from the bottom of the block toward the top of the block, the scan locations of the scan order anti-diagonal are arranged in traversal order in the corresponding line buffers.
Therefore, the line buffer LB1 can be arranged as And the line buffer LB2 can be arranged +.> The value of the current scan order anti-diagonal can also be arranged in the line buffer CURR LB. Thus, CURR_LB can be associated with scan order anti-diagonal 1306. In the opposite scanning orderAfter all values of the anti-diagonal 1306 are encoded, CURR_LB can be arranged asThus, the value at scan position x can be found at index y in CURR_LB. For example, it can be found in CURR_LB [3 ]]Find the value at scan location 49, which can be found at CURR_LB [7 ]]Find the value at scan location 53 and so on.
The context index O (x) that calculates the context to be used to code the value at scan location x, where scan location x corresponds to location y in curr_lb, can be performed using the following formula:
O(CURR_LB[y])＝(LB2[y-1]+LB2[y])+(LB1[y-2]+LB1[y-1]+LB1[y])
that is, determining the context index for the value at scan position y uses: 1) Values at scan positions (y-1) and (y) of the line buffer corresponding to the most recently coded scan order anti-diagonal and 2) values at scan positions (y-2), (y-1) and (y) of the line buffer corresponding to the oldest coded scan order anti-diagonal. Thus, only consecutive locations in each line buffer are accessed. While one arrangement and indexing scheme of values in a line buffer is described, one skilled in the art will appreciate that other arrangements and indexing schemes are possible.
As indicated above, and when template 1088 is used, the context model of the values of the scan order anti-diagonals depends on the first two scan order anti-diagonals. Thus, the cached data (i.e., the values of the lower plane) for context reference modeling can be located to two scan order anti-diagonals, each of size N, instead of, for example, being spread over the entire nxn transform block.
FIG. 14 is a flow diagram of a process 1400 for cache management for context selection according to an implementation of the present disclosure. The process 1400 can be implemented, for example, as a software program that can be executed by a computing device, such as the sending station 102 or the receiving station 106. The software program can include machine-readable instructions that can be stored in a memory, such as memory 204 or secondary storage 214, and when executed by a processor, such as CPU 202, can cause the computing device to perform process 1400. The process 1400 may be implemented in whole or in part in the entropy encoding stage 408 of the encoder 400 and/or the entropy decoding stage 502 of the decoder 500. Process 1400 can be implemented using dedicated hardware or firmware. Multiple processors, memories, or both may be used.
Process 1400 can be used when coding (i.e., encoding or decoding) a transform block. The transform block may be of size n×n. Process 1400 can be used with a transform block coding process that uses a lower plane and an upper graph to code a transform block. In particular, process 1400 can be used in coding a lower plane. The lower plane and upper view can be as described above.
At 1402, process 1400 maintains a line buffer for scanning the sequential anti-diagonal line. Maintenance can refer to generating, calculating, storing, determining, distributing, or maintaining in any other manner. The number of line buffers maintained by process 1400 may depend on the number of template anti-diagonals. For example, process 1400 can maintain a respective line buffer for each of the template anti-diagonals. For example, if the template used is a template such as template 1088 of fig. 10B, process 1400 can maintain two line buffers: LB1 and LB2 as described above. Each of the line buffers may have a size of N. In describing process 1400, template 1088 is used. However, templates of different sizes or having more than two template diagonals can be used.
At 1404, process 1400 stores the first coded anti-diagonal coefficient level in LB 1. The anti-diagonal coefficient level may be a value of the scan order anti-diagonal as described with respect to fig. 13. For example, as described above, process 1400 stores the values of scan order inverse diagonal 1310 in LB 1.
At 1406, process 1400 stores the second coded anti-diagonal coefficient level in LB2. For example, as described above, process 1400 stores the values of scan order anti-diagonal 1308 in LB2.
At 1408, process 1400 calculates the context index for each coefficient level in the third inverse diagonal with reference to LB1 and LB2. For example, the third inverse diagonal may be the scan order inverse diagonal 1306. Process 1400 is described above with reference to LB1 and LB2. The first line buffer LB1 can correspond to a first scan order anti-diagonal (e.g., scan order anti-diagonal 1310) that is farther than a second scan order anti-diagonal (e.g., scan order anti-diagonal 1308) to a third anti-diagonal (i.e., the current scan order anti-diagonal being coded, such as scan order anti-diagonal 1306).
At 1410, process 1400 determines if there are more scan order anti-diagonals to code. Alternatively, process 1400 determines 1410 whether there are any in-mode plane values to code or transform coefficients to code. If so, process 1400 proceeds to 1412; otherwise, process 1400 ends.
At 1412, process 1400 replaces LB1 with the third inverse diagonal. When all coefficient levels of the third inverse diagonal are coded, the value stored in LB1 is no longer needed. That is, the value stored in LB1 is not used to determine a context index for encoding any other value after encoding the third inverse diagonal.
However, the value of the third inverse diagonal and the value of the second inverse diagonal are used in determining the context for the next inverse diagonal. For example, after encoding the values of the scan order off-diagonal 1306, the codec proceeds to encode the values of the next scan order off-diagonal, scan order off-diagonal 1304. The values of the scan order anti-diagonals 1306, 1308 are used in coding the values of the scan order anti-diagonals 1304. Thus, process 1400 reserves LB2 and replaces LB1 with scan order anti-diagonal 1306. That is, process 1400 replaces the oldest coded scan order anti-diagonal with the last coded scan order anti-diagonal.
Process 1400 repeats the above steps. However, in repeating the steps, LB1 and LB2 are interchanged. That is, before encoding the new scan order anti-diagonal, process 1400 replaces the oldest line buffer (one of LB1 and LB2 that was encoded first) with the last encoded (i.e., most recently encoded) scan order anti-diagonal. Process 1400 is repeated until all scan order anti-diagonals for the lower plane are coded.
As described above with respect to O (50) and O (51), the context model that determines the position in the anti-diagonal of the scan order overlaps with its nearest neighbor. Implementations of the present disclosure can utilize such a repeating pattern to more efficiently calculate a context index through the use of a moving window.
Fig. 15 is a flow diagram of a process 1500 for using a moving window for context selection in accordance with an implementation of the present disclosure. The process 1500 can take advantage of the hardware capabilities of the codec to improve coding performance. The process 1500 interleaves the data of the two line buffers into one target buffer. The value of the target buffer is used to implement the moving window as described with respect to the accumulation sum.
At 1502, process 1500 stores a first coded anti-diagonal coefficient level in a first line buffer LB1 and a second coded anti-diagonal coefficient level in a second line buffer LB 2. The line buffers LB1 and LB2 can be as described above with respect to process 1400.
At 1504, the process 1500 interleaves the values of the first line buffer LB1 and the second line buffer LB2 into the destination buffer dest_buf. For example, assume that as described above Andthen the target buffer More generally, if lb1= [ B2, B4, B6, B8.]And lb2= [ B1, B3, B5, B7, ].]Then dest_buf= [ B1, B2, B3, B4, B5, B6, B7, B8.]。
Some hardware platforms such as x86 and ARM support direct interleaving operations between two buffers (e.g., via operation unpacklo, unpackhi). Such operations are typically able to take two line buffers (e.g., LB1 and LB 2) as inputs, interleave the data of the two line buffers, and write the results into a target buffer (e.g., DEST BUF). Thus, a codec implemented on such a platform can be executed via hardware instructions, thereby obtaining the dest_buf.
At 1506, process 1500 calculates the cumulative sum. In one implementation, the accumulation SUM can be stored in an accumulation SUM group CUM_SUM. The cumulative sum is obtained by the target buffer. The number of accumulated sums can be equal to the total number of values in the target buffer plus 1. The first cumulative sum value is zero and each subsequent cumulative sum value is added to the subsequent value from the target buffer. Thus, the value of the cumulative SUM array CUM_SUM can be calculated using the following formula:
CUM_SUM [ i+1] = CUM_SUM [ i ] + DEST_BUF [ i+1], wherein CUM_SUM [0] = 0.
Using the above formula, the accumulation and the set can include the following values:
CUM_SUMI0]＝0
CUM_SUM[1]＝0+B1
CUM_SUM[2]＝0+B1+B2
CUM_SUM[3]＝0+B1+B2+B3
CUM_SUM[4]＝0+B1+B2+B3+B4
...
CUM_SUM[9]＝0+B1+B2+B3+B4+...+B9
at 1508, process 1500 uses the cumulative sum to determine the context index. The calculated context index can be used to determine a context. The context index of the value at index i of the current scan order anti-diagonal can be calculated using the following formula:
context index [ i ] = CUM_SUM [ i+4] -CUM_SUM [ (i+4) -5]
Fig. 16 is a flow diagram of a process 1600 for coding a transform block of transform coefficients according to an implementation of the present disclosure. The process 1600 can be implemented, for example, as a software program that can be executed by a computing device, such as the sending station 102 or the receiving station 106. The software program can include machine-readable instructions that can be stored in a memory, such as memory 204 or secondary storage 214, and when executed by a processor, such as CPU 202, can cause the computing device to perform process 1600. The process 1600 may be implemented in whole or in part in the entropy encoding stage 408 of the encoder 400 and/or the entropy decoding stage 502 of the decoder 500. Process 1600 can be implemented using dedicated hardware or firmware. Multiple processors, memories, or both may be used.
At 1602, process 1600 identifies a lower plane. The lower plane can be as described above with respect to fig. 11-13. That is, the values of the lower plane code the "reach" values of some of the transform coefficients of the transform block. In one implementation, the lower plane includes values of transform coefficients of the transform block up to the last non-zero coefficient.
In the case of an encoder, the creation, formation, generation, selection, construction, determination, specification, generation, or otherwise identified in any manner. In the case of an encoder, the values of the lower plane will be encoded in an encoded bitstream, such as compressed bitstream 420 of fig. 4. In the case of a decoder, the identification can be indicative of the transform block that will decode the lower plane value.
At 1604, the process 1600 processes the lower plane according to a scan order. The scan may be an anti-diagonal aligned scan sequence as described above. The scan order may be the scan order of example 1300, as described with respect to fig. 13.
At 1606, process 1600 selects a template for entropy coding values of the lower plane. For the value to be coded of the lower plane, the template indicates the scan position of the value of the lower plane that has been coded. The scan positions are arranged in the templates in at least two template anti-diagonals. For example, the template may be template 1088 as described with respect to fig. 12. Thus, the template anti-diagonals may be template anti-diagonals 1202, 1204.
At 1608, the process 1600 determines if there are more values of the lower plane to code. If so, the process proceeds to 1610; otherwise, the process terminates at 1614.
At 1610, the process selects two or more line buffers based on the template anti-diagonal. As used in this disclosure, "selecting" is intended to create, form, generate, identify, construct, determine, specify, generate, or otherwise select in any manner. Each of the two or more line buffers corresponds to a respective scan order anti-diagonal. For example, as described with respect to fig. 13, in coding the values of the scan order anti-diagonal 13-6, the first line buffer LB1 corresponding to the scan order anti-diagonal 1310 is used and the second line buffer LB2 corresponding to the scan order anti-diagonal 1308 is selected.
At 1612, process 1600 uses two or more line buffers to determine a context. As described above with respect to fig. 10A-10B and fig. 13, process 1600 uses adjacent values identified by the templates to determine the context index. The context index is determined using a combination of values. In one implementation, the combination is a sum of values. Using the context index, the context is identified, retrieved, accessed, etc. for use in coding the current value.
At 1614, process 1600 uses the determined context to code the value. After 1614, process 1600 continues back to 1608 to determine if additional values are to be coded. When there are no more values at 1608, process 1600 ends.
Process 1600 can additionally include operations for coding an upper plane including residual coefficients. The maximum level can be associated with a lower plane, and each residual coefficient of the upper plane corresponds to a respective non-zero transform coefficient of the transform block having an absolute value exceeding the maximum level.
In the example of process 1600, the template includes five scan positions arranged along two template anti-diagonals. For example, the template may be template 1088 of fig. 12. The first template anti-diagonal (e.g., template anti-diagonal 1202) includes at least two of the five scan positions and the second template anti-diagonal (e.g., template anti-diagonal 1204) includes at least three scan positions. Each of the at least three scanning positions is different from each of the at least two scanning positions.
In the example of process 1600, the template includes seven scan positions arranged along three template anti-diagonals. For example, the template may be template 1070 of fig. 10A. The first template anti-diagonal includes at least two of the seven scan positions, the second template anti-diagonal includes at least three of the seven scan positions, and the third template anti-diagonal includes at least four of the seven scan positions. Each of the at least two scan positions, the at least three scan positions, and the at least four scan positions are different scan positions.
In yet another example, the process 1600 additionally includes: a first line buffer and a second line buffer are maintained for encoding values of the current scan order anti-diagonal. The first line buffer and the second line buffer may be as described with respect to fig. 14. Thus, the first line buffer can correspond to a first scan order anti-diagonal line that is scanned using an inverse scan order immediately before a current anti-diagonal line; and the second line buffer corresponds to a second scan order anti-diagonal line scanned using the reverse scan order immediately before the first anti-diagonal line. As described with respect to fig. 14, process 1600 also includes: the second line buffer is replaced with the first line buffer and the first line buffer is replaced with a line buffer corresponding to the current anti-diagonal for coding coefficients of a scan order anti-diagonal immediately following the current scan order anti-diagonal.
In yet another example, the process 1600 can include interleaving the first line buffer and the second line buffer in the target buffer. The destination buffer can be used to determine a context for coding the current value. The destination buffer may be as described with respect to fig. 15.
In an implementation of process 1600, determining a context for encoding a current value using a target buffer may include: calculating a respective accumulation sum for each location of the target buffer; and determining a context using a difference between the first cumulative sum and the second cumulative sum. The first and second accumulation volumes can be selected based on the location of the current value.
For simplicity of explanation, the processes 600, 900, 1100, 1400, 1500, and 1600 are each depicted and described as a series of blocks, steps, or operations. However, blocks, steps, or operations in accordance with the present disclosure can occur in various orders and/or concurrently. Additionally, other steps or operations not presented and described herein may be used. Furthermore, not all illustrated steps or operations may be required to implement techniques in accordance with the disclosed subject matter.
The above-described aspects of encoding and decoding illustrate some encoding and decoding techniques. However, it should be understood that "encoding" and "decoding" as those terms are used in the claims may mean compression, decompression, transformation, or any other processing or variation of data.
The word "example" or "implementation" is used herein to mean serving as an example, instance, or illustration. Any aspect or design described herein as "example" or "implementation" is not necessarily to be construed as preferred or advantageous over other aspects or designs. Rather, use of the word "example" or "implementation" is intended to present concepts in a concrete fashion. As used in this application, the term "or" is intended to mean an inclusive "or" rather than an exclusive "or". That is, unless specified otherwise or clearly indicated by context, "X includes a or B" is intended to mean any of its natural inclusive permutations. That is, if X includes A; x comprises B; or X includes both a and B, then "X includes a or B" is satisfied under any of the foregoing examples. Furthermore, the articles "a" and "an" as used in this application and the appended claims should generally be construed to mean "one or more" unless specified otherwise or clear from context to be directed to a singular form. Furthermore, unless otherwise described, the use of the terms "implementation" or "one implementation" throughout is not intended to refer to the same embodiment or implementation.
The implementations of the sending station 102 and/or the receiving station 106 (and the algorithms, methods, instructions, etc., stored thereon and/or thereby executed by the encoder 400 and decoder 500) can be implemented in hardware, software, or any combination thereof. The hardware can include, for example, a computer, an Intellectual Property (IP) core, an Application Specific Integrated Circuit (ASIC), a programmable logic array, an optical processor, a programmable logic controller, microcode, a microcontroller, a server, a microprocessor, a digital signal processor, or any other suitable circuit. In the claims, the term "processor" should be understood to include any of the foregoing hardware, alone or in combination. The terms "signal" and "data" are used interchangeably. In addition, the various portions of the sending station 102 and the receiving station 106 do not necessarily have to be implemented in the same manner.
Additionally, in one aspect, the sending station 102 or receiving station 106 can be implemented using, for example, a general-purpose computer or general-purpose processor with a computer program that, when executed, performs any of the corresponding methods, algorithms, and/or instructions described herein. Additionally or alternatively, for example, a special purpose computer/processor can be utilized that can contain other hardware for performing any of the methods, algorithms, or instructions described herein.
For example, the sending station 102 and the receiving station 106 can be implemented on computers in a video conferencing system. Alternatively, the sending station 102 can be implemented on a server and the receiving station 106 can be implemented on a device separate from the server, such as a handheld communication device. In this example, the sending station 102 can encode content into an encoded video signal using the encoder 400 and send the encoded video signal to a communication device. Further, the communication device can then use the decoder 500 to decode the encoded video signal. Alternatively, the communication device can decode content locally stored on the communication device, such as content that is not transmitted by the transmitting station 102. Other implementations of the sending station 102 and the receiving station 106 are available. For example, the receiving station 106 may be a generally stationary personal computer rather than a portable communication device, and/or a device including the encoder 400 may also include the decoder 500.
Additionally, all or part of the implementations of the present disclosure can take the form of a computer program product accessible from a tangible computer-usable or computer-readable medium, for example. A computer-usable or computer-readable medium may be any apparatus that can, for example, tangibly contain, store, communicate, or transport the program for use by or in connection with any processor. The medium may be, for example, an electronic, magnetic, optical, electromagnetic, or semiconductor device. Other suitable media are also useful.
The above embodiments, implementations and aspects have been described in order to allow the disclosure to be easily understood and not to be limiting. On the contrary, the disclosure is intended to cover various modifications and equivalent arrangements included within the scope of the appended claims, which scope is to be accorded the broadest interpretation as permitted under the law so as to encompass all such modifications and equivalent structures.
Claims (20)
1. An apparatus for encoding a transform block of transform coefficients, the apparatus comprising:
a processor configured to:
maintaining a first line buffer and a second line buffer for encoding a plurality of current values related to the transform coefficients,
wherein the plurality of current values are arranged along a current scan order anti-diagonal of the scan order,
wherein the first line buffer includes a first value of a first scan order anti-diagonal that is scanned immediately before the current scan order anti-diagonal, an
Wherein the second line buffer includes a second value of a second scan order anti-diagonal that is scanned immediately before the first scan order anti-diagonal;
interleaving the first value of the first line buffer and the second value of the second line buffer in a target buffer;
Selecting a probability distribution that codes one of the plurality of current values using the target buffer;
entropy encoding the current value using the probability distribution in a compressed bitstream; and
one of the second line buffer or the first line buffer is replaced with the current scan order anti-diagonal for coding values of an immediately following scan order anti-diagonal of the current scan order anti-diagonal.
2. The apparatus of claim 1, wherein interleaving the first value of the first line buffer and the second value of the second line buffer in the target buffer comprises:
the first value and the second value are interleaved in the target buffer using hardware instructions.
3. The apparatus of claim 2, wherein the hardware instruction is one of unpackhi or unpacklo.
4. The apparatus of claim 2, wherein the processor is further configured to:
a corresponding accumulation sum is calculated for at least some locations of the target buffer.
5. The apparatus of claim 4, wherein calculating a respective cumulative sum for the at least some locations of the target buffer comprises:
A target buffer value at one of the at least some locations of the target buffer is added to an accumulated sum corresponding to an immediately preceding location of the target buffer.
6. The apparatus of claim 5, wherein determining the probability distribution that codes the current value of the current scan order anti-diagonal using the target buffer comprises:
calculating a difference between a first cumulative sum corresponding to a first location of the target buffer and a second cumulative sum corresponding to a second location of the target buffer, wherein the first cumulative sum and the second cumulative sum are selected based on the location of the current value; and
the probability distribution is determined using the differences.
7. The apparatus of claim 6, wherein a distance between the first location of the target buffer and the second location of the target buffer is related to a number of scan locations of values of a template that have been coded, wherein the template indicates scan locations for values to be coded, the scan locations being arranged in at least two anti-diagonal lines in the template.
8. A device for decoding a transform block, the device comprising:
a processor configured to:
storing a first value of a first scan order diagonal line scanned immediately before a current scan order diagonal line of the transform block in a first line buffer;
storing a second value of a second scan order diagonal line scanned immediately before the first scan order diagonal line in a second line buffer;
interleaving the first value of the first line buffer and the second value of the second line buffer in a target buffer;
selecting a probability distribution encoding a current value of the current scan order diagonal using the target buffer;
entropy decoding the current value from the compressed bitstream using the probability distribution; and
one of the second line buffer or the first line buffer is replaced with a current value of the current scan order diagonal for coding values of an immediately subsequent scan order diagonal to the current scan order diagonal.
9. The apparatus of claim 8, wherein interleaving the first value of the first line buffer and the second value of the second line buffer in the target buffer comprises:
The first value and the second value are interleaved in the target buffer using hardware instructions.
10. The apparatus of claim 9, wherein the hardware instruction is one of unpackhi or unpacklo.
11. The apparatus of claim 9, wherein the processor is further configured to:
a corresponding accumulation sum is calculated for at least some locations of the target buffer.
12. The apparatus of claim 11, wherein calculating a respective cumulative sum for the at least some locations of the target buffer comprises:
a target buffer value at one of the at least some locations of the target buffer is added to an accumulated sum corresponding to an immediately preceding location of the target buffer.
13. The apparatus of claim 12, wherein determining the probability distribution that codes the current value of the current scan order diagonal using the target buffer comprises:
calculating a difference between a first cumulative sum corresponding to a first location of the target buffer and a second cumulative sum corresponding to a second location of the target buffer, wherein the first cumulative sum and the second cumulative sum are selected based on the location of the current value; and
The probability distribution is determined using the differences.
14. The apparatus of claim 13, wherein a distance between the first location of the target buffer and the second location of the target buffer is related to a number of scan locations of values of a template that have been coded, wherein the template indicates scan locations for values to be coded, the scan locations being arranged in at least two anti-diagonal lines in the template.
15. A method for decoding a transform block, comprising:
storing a first value of a first scan order diagonal line scanned immediately before a current scan order diagonal line of the transform block in a first line buffer;
storing a second value of a second scan order diagonal line scanned immediately before the first scan order diagonal line in a second line buffer;
interleaving the first value of the first line buffer and the second value of the second line buffer in a target buffer;
selecting a probability distribution encoding a current value of the current scan order diagonal using the target buffer;
entropy decoding the current value from the compressed bitstream using the probability distribution; and
One of the second line buffer or the first line buffer is replaced with a current value of the current scan order diagonal for coding values of an immediately subsequent scan order diagonal to the current scan order diagonal.
16. The method of claim 15, wherein interleaving the first value of the first line buffer and the second value of the second line buffer in the target buffer comprises:
the first value and the second value are interleaved in the target buffer using hardware instructions.
17. The method of claim 16, wherein the hardware instruction is one of unpackhi or unpacklo.
18. The method of claim 16, further comprising:
a corresponding accumulation sum is calculated for at least some locations of the target buffer.
19. The method of claim 18, wherein calculating a respective cumulative sum for the at least some locations of the target buffer comprises:
a target buffer value at one of the at least some locations of the target buffer is added to an accumulated sum corresponding to an immediately preceding location of the target buffer.
20. The method of claim 19, wherein determining the probability distribution that codes the current value of the current scan order diagonal using the target buffer comprises:
calculating a difference between a first cumulative sum corresponding to a first location of the target buffer and a second cumulative sum corresponding to a second location of the target buffer, wherein the first cumulative sum and the second cumulative sum are selected based on the location of the current value; and
the probability distribution is determined using the differences.
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
CN202111353194.XA CN114143559B (en) | 2018-01-30 | 2019-01-30 | Efficient context model calculation design in transform coefficient coding |
Applications Claiming Priority (5)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US15/883,323 US10506242B2 (en) | 2018-01-30 | 2018-01-30 | Efficient context model computation design in transform coefficient coding |
US15/883,323 | 2018-01-30 | ||
CN201980010677.4A CN111758254B (en) | 2018-01-30 | 2019-01-30 | Efficient context model computational design in transform coefficient coding |
PCT/US2019/015930 WO2019152570A1 (en) | 2018-01-30 | 2019-01-30 | Efficient context model computation design in transform coefficient coding |
CN202111353194.XA CN114143559B (en) | 2018-01-30 | 2019-01-30 | Efficient context model calculation design in transform coefficient coding |
Related Parent Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN201980010677.4A Division CN111758254B (en) | 2018-01-30 | 2019-01-30 | Efficient context model computational design in transform coefficient coding |
Publications (2)
Publication Number | Publication Date |
---|---|
CN114143559A CN114143559A (en) | 2022-03-04 |
CN114143559B true CN114143559B (en) | 2024-01-05 |
Family
ID=65441091
Family Applications (2)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN202111353194.XA Active CN114143559B (en) | 2018-01-30 | 2019-01-30 | Efficient context model calculation design in transform coefficient coding |
CN201980010677.4A Active CN111758254B (en) | 2018-01-30 | 2019-01-30 | Efficient context model computational design in transform coefficient coding |
Family Applications After (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN201980010677.4A Active CN111758254B (en) | 2018-01-30 | 2019-01-30 | Efficient context model computational design in transform coefficient coding |
Country Status (4)
Country | Link |
---|---|
US (1) | US10506242B2 (en) |
EP (1) | EP3732882A1 (en) |
CN (2) | CN114143559B (en) |
WO (1) | WO2019152570A1 (en) |
Families Citing this family (7)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US10754763B2 (en) * | 2018-07-09 | 2020-08-25 | International Business Machines Corporation | Bypassing user-selected functions during test case generation |
US11113846B2 (en) | 2018-08-31 | 2021-09-07 | Hulu, LLC | Coefficient context modeling in video coding |
WO2020141856A1 (en) * | 2019-01-02 | 2020-07-09 | 엘지전자 주식회사 | Image decoding method and device using residual information in image coding system |
US11202100B2 (en) * | 2019-03-11 | 2021-12-14 | Qualcomm Incorporated | Coefficient coding for transform skip mode |
CN114071140B (en) * | 2019-12-03 | 2022-12-23 | 杭州海康威视数字技术股份有限公司 | Decoding method, encoding method, device, equipment and machine readable storage medium |
US11765370B2 (en) | 2021-07-27 | 2023-09-19 | Mediatek Inc. | Video residual decoding apparatus using neighbor storage device with smaller storage size to store neighbor data for context selection and associated method |
WO2024026332A1 (en) * | 2022-07-28 | 2024-02-01 | Apple Inc. | Coefficient-based transform and mode signaling |
Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
WO2008080516A1 (en) * | 2006-12-27 | 2008-07-10 | Fraunhofer-Gesellschaft zur Förderung der angewandten Forschung e.V. | Device and method for encoding a block of transformation coefficients |
WO2013003798A1 (en) * | 2011-06-29 | 2013-01-03 | Qualcomm Incorporated | Contexts for coefficient level coding in video compression |
CN103597838A (en) * | 2011-04-15 | 2014-02-19 | 黑莓有限公司 | Methods and devices for coding and decoding the position of the last significant coefficient |
CN107211137A (en) * | 2015-01-19 | 2017-09-26 | 谷歌公司 | Efficient context reply in arithmetic code |
Family Cites Families (21)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6549666B1 (en) * | 1994-09-21 | 2003-04-15 | Ricoh Company, Ltd | Reversible embedded wavelet system implementation |
US8692695B2 (en) * | 2000-10-03 | 2014-04-08 | Realtime Data, Llc | Methods for encoding and decoding data |
US7941433B2 (en) * | 2006-01-20 | 2011-05-10 | Glenbrook Associates, Inc. | System and method for managing context-rich database |
KR101495724B1 (en) * | 2010-02-02 | 2015-02-25 | 삼성전자주식회사 | Method and apparatus for video encoding based on scanning order of hierarchical data units, and method and apparatus for video decoding based on the same |
US9154801B2 (en) | 2010-09-30 | 2015-10-06 | Texas Instruments Incorporated | Method and apparatus for diagonal scan and simplified coding of transform coefficients |
US9313514B2 (en) * | 2010-10-01 | 2016-04-12 | Sharp Kabushiki Kaisha | Methods and systems for entropy coder initialization |
CN104811706B (en) * | 2011-01-06 | 2017-10-27 | 三星电子株式会社 | The coding method of video and the coding/decoding method and device of device and video |
US9066097B2 (en) * | 2011-02-01 | 2015-06-23 | Sony Corporation | Method to optimize the transforms and/or predictions in a video codec |
US9338449B2 (en) | 2011-03-08 | 2016-05-10 | Qualcomm Incorporated | Harmonized scan order for coding transform coefficients in video coding |
US9247266B2 (en) * | 2011-04-18 | 2016-01-26 | Texas Instruments Incorporated | Temporal motion data candidate derivation in video coding |
US9762918B2 (en) * | 2011-05-27 | 2017-09-12 | Hfi Innovation Inc. | Method and apparatus for line buffer reduction for video processing |
US10070126B2 (en) * | 2011-06-28 | 2018-09-04 | Hfi Innovation Inc. | Method and apparatus of intra mode coding |
US20130003858A1 (en) * | 2011-06-30 | 2013-01-03 | Vivienne Sze | Simplified Context Selection For Entropy Coding of Transform Coefficient Syntax Elements |
US9800870B2 (en) * | 2011-09-16 | 2017-10-24 | Qualcomm Incorporated | Line buffer reduction for short distance intra-prediction |
US9866829B2 (en) | 2012-01-22 | 2018-01-09 | Qualcomm Incorporated | Coding of syntax elements that correspond to coefficients of a coefficient block in video coding |
US9264706B2 (en) * | 2012-04-11 | 2016-02-16 | Qualcomm Incorporated | Bypass bins for reference index coding in video coding |
CN105282558B (en) * | 2014-07-18 | 2018-06-15 | 清华大学 | Pixel prediction method, coding method, coding/decoding method and its device in frame |
CN105120293B (en) * | 2015-08-26 | 2018-07-06 | 中国航空工业集团公司洛阳电光设备研究所 | Image collaboration coding/decoding method and device based on CPU and GPU |
JP2018032949A (en) * | 2016-08-23 | 2018-03-01 | キヤノン株式会社 | Motion vector detector and control method thereof |
US10715827B2 (en) * | 2017-01-06 | 2020-07-14 | Mediatek Inc. | Multi-hypotheses merge mode |
CN106993190B (en) * | 2017-03-31 | 2019-06-21 | 武汉斗鱼网络科技有限公司 | Software-hardware synergism coding method and system |
-
2018
- 2018-01-30 US US15/883,323 patent/US10506242B2/en active Active
-
2019
- 2019-01-30 WO PCT/US2019/015930 patent/WO2019152570A1/en unknown
- 2019-01-30 EP EP19705646.8A patent/EP3732882A1/en active Pending
- 2019-01-30 CN CN202111353194.XA patent/CN114143559B/en active Active
- 2019-01-30 CN CN201980010677.4A patent/CN111758254B/en active Active
Patent Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
WO2008080516A1 (en) * | 2006-12-27 | 2008-07-10 | Fraunhofer-Gesellschaft zur Förderung der angewandten Forschung e.V. | Device and method for encoding a block of transformation coefficients |
CN103597838A (en) * | 2011-04-15 | 2014-02-19 | 黑莓有限公司 | Methods and devices for coding and decoding the position of the last significant coefficient |
WO2013003798A1 (en) * | 2011-06-29 | 2013-01-03 | Qualcomm Incorporated | Contexts for coefficient level coding in video compression |
CN107211137A (en) * | 2015-01-19 | 2017-09-26 | 谷歌公司 | Efficient context reply in arithmetic code |
Non-Patent Citations (3)
Title |
---|
H.264/HEVC视频解码的VLSI结构及实现研究;沈沙;《中国优秀博士学位论文全文数据库信息科技》(第1期);全文 * |
Tarp Filtering of Block-Transform Coefficients for Embedded Image Coding;V.P. Shah et al.;《2006 IEEE International Conference on Acoustics Speech and Signal Processing Proceedings》;全文 * |
低码率视频编码中基于对角线抽样的混合DCT算法;陈志波 等;《 计算机工程与应用 》(第1期);全文 * |
Also Published As
Publication number | Publication date |
---|---|
CN111758254A (en) | 2020-10-09 |
US20190238865A1 (en) | 2019-08-01 |
CN114143559A (en) | 2022-03-04 |
EP3732882A1 (en) | 2020-11-04 |
WO2019152570A9 (en) | 2020-07-30 |
CN111758254B (en) | 2021-11-16 |
WO2019152570A1 (en) | 2019-08-08 |
US10506242B2 (en) | 2019-12-10 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
CN114143559B (en) | Efficient context model calculation design in transform coefficient coding | |
CN115604472B (en) | Method and apparatus for coding blocks of video data | |
CN110710217B (en) | Method and apparatus for coding last significant coefficient flag | |
US10735767B2 (en) | Transform coefficient coding using level maps | |
US20200351502A1 (en) | Adaptation of scan order for entropy coding | |
US20220377376A1 (en) | Efficient context model computation design in transform coefficient coding | |
CN116389741A (en) | Method for encoding a current block of image or video data | |
CN110710208B (en) | Embedding information about EOB location | |
CN110710219B (en) | Method and apparatus for context derivation for coefficient coding |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
SE01 | Entry into force of request for substantive examination | ||
GR01 | Patent grant | ||
GR01 | Patent grant |