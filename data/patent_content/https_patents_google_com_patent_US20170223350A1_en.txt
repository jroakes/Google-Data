US20170223350A1 - Dynamic reference motion vector coding mode - Google Patents
Dynamic reference motion vector coding mode Download PDFInfo
- Publication number
- US20170223350A1 US20170223350A1 US15/373,518 US201615373518A US2017223350A1 US 20170223350 A1 US20170223350 A1 US 20170223350A1 US 201615373518 A US201615373518 A US 201615373518A US 2017223350 A1 US2017223350 A1 US 2017223350A1
- Authority
- US
- United States
- Prior art keywords
- motion vector
- frame
- block
- current block
- inter
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Granted
Links
Images
Classifications
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/102—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or selection affected or controlled by the adaptive coding
- H04N19/103—Selection of coding mode or of prediction mode
- H04N19/105—Selection of the reference unit for prediction within a chosen coding or prediction mode, e.g. adaptive choice of position and number of pixels used for prediction
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/102—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or selection affected or controlled by the adaptive coding
- H04N19/103—Selection of coding mode or of prediction mode
- H04N19/109—Selection of coding mode or of prediction mode among a plurality of temporal predictive coding modes
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/134—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or criterion affecting or controlling the adaptive coding
- H04N19/136—Incoming video signal characteristics or properties
- H04N19/137—Motion inside a coding unit, e.g. average field, frame or block difference
- H04N19/139—Analysis of motion vectors, e.g. their magnitude, direction, variance or reliability
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/134—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or criterion affecting or controlling the adaptive coding
- H04N19/157—Assigned coding mode, i.e. the coding mode being predefined or preselected to be further used for selection of another element or parameter
- H04N19/159—Prediction type, e.g. intra-frame, inter-frame or bidirectional frame prediction
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/169—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding
- H04N19/17—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding the unit being an image region, e.g. an object
- H04N19/176—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding the unit being an image region, e.g. an object the region being a block, e.g. a macroblock
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/50—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding
- H04N19/503—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding involving temporal prediction
- H04N19/51—Motion estimation or motion compensation
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/50—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding
- H04N19/503—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding involving temporal prediction
- H04N19/51—Motion estimation or motion compensation
- H04N19/513—Processing of motion vectors
- H04N19/517—Processing of motion vectors by encoding
- H04N19/52—Processing of motion vectors by encoding by predictive encoding
Definitions
- Digital video streams may represent video using a sequence of frames or still images.
- Digital video can be used for various applications including, for example, video conferencing, high definition video entertainment, video advertisements, or sharing of user-generated videos.
- a digital video stream can contain a large amount of data and consume a significant amount of computing or communication resources of a computing device for processing, transmission or storage of the video data.
- Various approaches have been proposed to reduce the amount of data in video streams, including compression and other encoding techniques.
- This disclosure relates generally to encoding and decoding video data and more particularly relates to video coding using reference motion vectors.
- a method for decoding a video stream includes identifying, for a current block, a reference frame used to encode the current block within a current frame, creating a reference motion vector candidate list for the reference frame using reference blocks, ranking each motion vector within the reference motion vector candidate list by a distance from the current block to a reference block providing the motion vector, and by a popularity value of the motion vector that indicates a level of use of the motion vector by the reference block that indicates a level of use of the motion vector by the reference blocks, assigning the motion vectors to a plurality of inter-prediction modes based on the ranking, selecting an inter-prediction mode for decoding the current block, and decoding the current block using the inter-prediction mode.
- the reference blocks can including spatially adjacent blocks of the current frame, a collocated block within a previous frame, and spatially adjacent blocks of the collocated block within the previous frame, or other reference blocks.
- An apparatus for decoding a video stream includes a processor and a memory.
- the memory is storing instructions that cause the processor to perform the method above.
- a method for encoding a video stream include identifying, for each of a plurality of reference frames, candidate motion vectors for encoding a current block within a current frame using reference blocks, ranking the candidate motion vectors within a reference motion vector candidate list for a reference frame by a distance from the current block of a respective reference block providing a respective candidate motion vector, and by a popularity value of the motion vector that indicates a level of use of the motion vector by the reference blocks, assigning the motion vectors to a plurality of inter-prediction modes based on the ranking, selecting an inter-prediction mode for encoding the current block, and encoding the current block using the inter-prediction mode.
- FIG. 1 is a schematic of a video encoding and decoding system.
- FIG. 2 is a block diagram of an example of a computing device that can implement a transmitting station or a receiving station.
- FIG. 3 is a diagram of a video stream to be encoded and subsequently decoded.
- FIG. 4 is a block diagram of a video compression system according to an aspect of the teachings herein.
- FIG. 5 is a block diagram of a video decompression system according to another aspect of the teachings herein.
- FIG. 6 is a flowchart diagram of a process for encoding a video stream using reference motion vectors in accordance with an implementation of this disclosure.
- FIG. 7 is a diagram of a sequence of frames used to explain the identification of candidate motion vectors within the process of FIG. 6 .
- FIG. 8 is a flowchart diagram of a process for decoding an encoded video stream using reference motion vectors in accordance with implementations of this disclosure.
- Compression schemes related to coding video streams may include breaking each image into blocks and generating a digital video output bitstream using one or more techniques to limit the information included in the output.
- a received bitstream can be decoded to re-create the blocks and the source images from the limited information.
- Encoding a video stream, or a portion thereof, such as a frame or a block can include using temporal and spatial similarities in the video stream to improve coding efficiency.
- a current block of a video stream may be encoded based on a previously encoded block in the video stream by predicting motion and color information for the current block based on the previously encoded block and identifying a difference (residual) between the predicted values and the current block. In this way, only the residual and parameters used to generate it need be added to the bitstream instead of including the entirety of the current block.
- This technique may be referred to as inter prediction.
- One of the parameters in inter prediction is a motion vector that represents the spatial displacement of the previously coded block relative to the current block.
- the motion vector can be identified using a method of motion estimation, such as a motion search.
- motion search a portion of a reference frame can be translated to a succession of locations to form a prediction block that can be subtracted from a portion of a current frame to form a series of residuals.
- the X and Y translations corresponding to the location having the smallest residual can be selected as the motion vector.
- Bits representing the motion vector can be included in the encoded bitstream to permit a decoder to reproduce the prediction block and decode the portion of the encoded video bitstream associated with the motion vector.
- a motion vector can be differentially encoded using a reference motion vector, i.e., only the difference between the motion vector and the reference motion vector is encoded.
- the reference motion vector can be selected from previously used motion vectors in the video stream, for example, the last non-zero motion vector from neighboring blocks. Selecting a previously used motion vector to encode a current motion vector can further reduce the number of bits included in the encoded video bitstream and thereby reduce transmission and storage bandwidth requirements.
- Motion vector referencing modes allow a coding block to infer motion information from previously coded neighboring blocks.
- the reference motion vector candidate list can be constructed according to the distance between the reference block and the current block being encoded. However, ranking solely according to the block distance ignores that a motion vector may be used by multiple blocks. How many pixels in a reference area are using the motion vector may indicate the likelihood that the motion vector is an effective motion vector for the current block.
- neighboring blocks may be used to construct a reference motion vector candidate list.
- previously coded blocks are used. When coding in raster scan order, this limits the neighboring blocks to those to the left and above the current block to the extent they are available.
- the collocated block from the previous frame also called the last frame
- the collocated block is a block located in the last frame having the same pixel location as the current block, so potentially useful motion information from the right and bottom of the current block is still omitted.
- the reference motion vector candidate list there may be a fixed number of motion vector referencing modes, such as two.
- the use of a fixed number of reference modes can be inefficient. For example, if the reference motion vector candidate list has less than the fixed number of motion vectors, zero motion vectors may be need to pad the modes without a motion vector. In other cases, the reference motion vector candidate list may have more than the fixed number of motion vectors.
- the omitted motion vectors may be better candidates than those kept—that is, an omitted motion vector may result in a better rate and/or less distortion in coding the current block.
- compression performance may be improved by employing an efficient reference motion vector ranking system, followed by a dynamic motion vector referencing mode that fully accounts for the available motion vector candidate list.
- reference motion vector candidates for blocks with a single reference frame may be ranked according to both relative distance from the current block and the coverage area (e.g., the use of the motion vector).
- the candidate motion vectors from reference blocks that share the same reference frame combination may be ranked with a higher priority. Ranked below this are, optionally, combinations of motion vectors from neighboring blocks with a single reference frame.
- motion information associated with blocks below and to the right of the collocated block may be considered so as to capture those directions of movement.
- the dynamic motion vector referencing mode may use a number of modes that is dependent on the size of reference motion vector candidate list so that the chance of losing potentially valuable reference information is reduced.
- a reference motion vector may be selected from candidate motion vectors based on the distance between the reference block and the current block and the popularity of the reference motion vector.
- the distance between the reference block and the current block can be based on the spatial displacement between the pixels in the previously coded block and corresponding collocated pixels in the current block, measured in the unit of pixels.
- the popularity of the motion vector can be based on the amount of previously coded pixels that use the motion vector. The more previously coded pixels that use the motion vector, the higher the probability of the motion vector.
- the popularity value is the number of previously coded pixels that use the motion vector.
- the popularity value is a percentage of previously coded pixels within an area that use the motion vector.
- a candidate motion vector used in a reference block near the current block may closely resemble the actual motion vector for the current block. Additionally, a candidate motion vector that is used by the most amount of pixels in a reference block near the current block would further resemble the actual motion vector for the current block. For this reason, the motion vector of the candidate motion vectors with the highest popularity used in a nearby reference block may be selected as the reference motion vector for the actual motion vector of the current block. Fewer bits can be used to code the actual motion vector by coding the small difference in motion vectors, thus improving the overall coding efficiency. Other ways in which the selected motion vector may be used are discussed hereinafter.
- the candidate motion vectors may be limited to spatial-temporal neighboring motion vectors. That is, the pool of candidate motion vectors may be selected from regions neighboring regions of the current block. In some video coding schemes, particularly those where video frames are encoded out of order, it is desirable to include in the pool of candidate motion vectors motion information from video frames in the distant past or future. Encoding video frames can out of order may occur, for example, in the coding of so-called “alternate reference frames” that are not temporally neighboring to the frames coded immediately before or after them.
- An alternate reference frame may be a synthesized frame that does not occur in the input video stream or is a duplicate frame to one in the input video stream that is used for prediction and is generally not displayed following decoding.
- Such a frame can resemble a video frame in the non-adjacent future.
- Another example in which out of order encoding may occur is through the use of a so-called “golden reference frame,” which is a reconstructed video frame that may or may not be neighboring to a current video frame and is stored in memory for use as a reference frame until replaced, e.g., by a new golden reference frame.
- alternate reference frames and golden reference frames may be used to infer motion vector candidates for a block of a frame of video data.
- alternate reference frames and golden reference frames also called alternate frames and golden frames
- alternate frames and golden frames may be used to infer motion vector candidates for a block of a frame of video data.
- Other details are described herein after first describing an environment in which the disclosure may be implemented.
- FIG. 1 is a schematic of a video encoding and decoding system 100 .
- a transmitting station 102 can be, for example, a computer having an internal configuration of hardware such as that described in FIG. 2 .
- the processing of the transmitting station 102 can be distributed among multiple devices.
- a network 104 can connect the transmitting station 102 and a receiving station 106 for encoding and decoding of the video stream.
- the video stream can be encoded in the transmitting station 102 and the encoded video stream can be decoded in the receiving station 106 .
- the network 104 can be, for example, the Internet.
- the network 104 can also be a local area network (LAN), wide area network (WAN), virtual private network (VPN), cellular telephone network or any other means of transferring the video stream from the transmitting station 102 to, in this example, the receiving station 106 .
- LAN local area network
- WAN wide area network
- VPN virtual private network
- the receiving station 106 in one example, can be a computer having an internal configuration of hardware such as that described in FIG. 2 . However, other implementations of the receiving station 106 are possible. For example, the processing of the receiving station 106 can be distributed among multiple devices.
- an implementation can omit the network 104 .
- a video stream can be encoded and then stored for transmission at a later time to the receiving station 106 or any other device having memory.
- the receiving station 106 receives (e.g., via the network 104 , a computer bus, and/or some communication pathway) the encoded video stream and stores the video stream for later decoding.
- a real-time transport protocol RTP
- a transport protocol other than RTP may be used, e.g., a Hypertext Transfer Protocol (HTTP)-based video streaming protocol.
- HTTP Hypertext Transfer Protocol
- the transmitting station 102 and/or the receiving station 106 may include the ability to both encode and decode a video stream as described below.
- the receiving station 106 could be a video conference participant who receives an encoded video bitstream from a video conference server (e.g., the transmitting station 102 ) to decode and view and further encodes and transmits its own video bitstream to the video conference server for decoding and viewing by other participants.
- FIG. 2 is a block diagram of an example of a computing device 200 that can implement a transmitting station or a receiving station.
- the computing device 200 can implement one or both of the transmitting station 102 and the receiving station 106 of FIG. 1 .
- the computing device 200 can be in the form of a computing system including multiple computing devices, or in the form of a single computing device, for example, a mobile phone, a tablet computer, a laptop computer, a notebook computer, a desktop computer, and the like.
- a CPU 202 in the computing device 200 can be a central processing unit.
- the CPU 202 can be any other type of device, or multiple devices, capable of manipulating or processing information now-existing or hereafter developed.
- the disclosed implementations can be practiced with a single processor as shown, e.g., the CPU 202 , advantages in speed and efficiency can be achieved using more than one processor.
- a memory 204 in the computing device 200 can be a read only memory (ROM) device or a random access memory (RAM) device in an implementation. Any other suitable type of storage device can be used as the memory 204 .
- the memory 204 can include code and data 206 that is accessed by the CPU 202 using a bus 212 .
- the memory 204 can further include an operating system 208 and application programs 210 , the application programs 210 including at least one program that permits the CPU 202 to perform the methods described here.
- the application programs 210 can include applications 1 through N, which further include a video coding application that performs the methods described here.
- the computing device 200 can also include additional memory in the form of a secondary storage 214 , which can, for example, be a memory card used with a mobile computing device. Because the video communication sessions may contain a significant amount of information, they can be stored in whole or in part in the secondary storage 214 and loaded into the memory 204 as needed for processing.
- a secondary storage 214 can, for example, be a memory card used with a mobile computing device. Because the video communication sessions may contain a significant amount of information, they can be stored in whole or in part in the secondary storage 214 and loaded into the memory 204 as needed for processing.
- the computing device 200 can also include one or more output devices, such as a display 218 .
- the display 218 may be, in one example, a touch sensitive display that combines a display with a touch sensitive element that is operable to sense touch inputs.
- the display 218 can be coupled to the CPU 202 via the bus 212 .
- Other output devices that permit a user to program or otherwise use the computing device 200 can be provided in addition to or as an alternative to the display 218 .
- the output device is or includes a display
- the display can be implemented in various ways, including by a liquid crystal display (LCD), a cathode-ray tube (CRT) display or light emitting diode (LED) display, such as an organic LED (OLED) display.
- LCD liquid crystal display
- CRT cathode-ray tube
- LED light emitting diode
- OLED organic LED
- the computing device 200 can also include or be in communication with an image-sensing device 220 , for example a camera, or any other image-sensing device 220 now existing or hereafter developed that can sense an image such as the image of a user operating the computing device 200 .
- the image-sensing device 220 can be positioned such that it is directed toward the user operating the computing device 200 .
- the position and optical axis of the image-sensing device 220 can be configured such that the field of vision includes an area that is directly adjacent to the display 218 and from which the display 218 is visible.
- the computing device 200 can also include or be in communication with a sound-sensing device 222 , for example a microphone, or any other sound-sensing device now existing or hereafter developed that can sense sounds near the computing device 200 .
- the sound-sensing device 222 can be positioned such that it is directed toward the user operating the computing device 200 and can be configured to receive sounds, for example, speech or other utterances, made by the user while the user operates the computing device 200 .
- FIG. 2 depicts the CPU 202 and the memory 204 of the computing device 200 as being integrated into a single unit, other configurations can be utilized.
- the operations of the CPU 202 can be distributed across multiple machines (each machine having one or more of processors) that can be coupled directly or across a local area or other network.
- the memory 204 can be distributed across multiple machines such as a network-based memory or memory in multiple machines performing the operations of the computing device 200 .
- the bus 212 of the computing device 200 can be composed of multiple buses.
- the secondary storage 214 can be directly coupled to the other components of the computing device 200 or can be accessed via a network and can comprise a single integrated unit such as a memory card or multiple units such as multiple memory cards.
- the computing device 200 can thus be implemented in a wide variety of configurations.
- FIG. 3 is a diagram of an example of a video stream 300 to be encoded and subsequently decoded.
- the video stream 300 includes a video sequence 302 .
- the video sequence 302 includes a number of adjacent frames 304 . While three frames are depicted as the adjacent frames 304 , the video sequence 302 can include any number of adjacent frames 304 .
- the adjacent frames 304 can then be further subdivided into individual frames, e.g., a frame 306 .
- the frame 306 can be divided into a series of planes or segments 308 .
- the segments (or planes) 308 can be subsets of frames that permit parallel processing, for example.
- the segments 308 can also be subsets of frames that can separate the video data into separate colors.
- the frame 306 of color video data can include a luminance plane and two chrominance planes.
- the segments 308 may be sampled at different resolutions.
- the frame 306 may be further subdivided into blocks 310 , which can contain data corresponding to, for example, 16 ⁇ 16 pixels in frame 306 .
- the blocks 310 can also be arranged to include data from one or more planes of pixel data.
- the blocks 310 can also be of any other suitable size such as 4 ⁇ 4 pixels, 8 ⁇ 8 pixels, 16 ⁇ 8 pixels, 8 ⁇ 16 pixels, 16 ⁇ 16 pixels or larger. Unless otherwise noted, the terms block and macroblock are used interchangeably herein.
- FIG. 4 is a block diagram of an encoder 400 in accordance with an implementation.
- the encoder 400 can be implemented, as described above, in the transmitting station 102 such as by providing a computer software program stored in memory, for example, the memory 204 .
- the computer software program can include machine instructions that, when executed by a processor such as the CPU 202 , cause the transmitting station 102 to encode video data in the manner described in FIG. 4 and in FIG. 6 , below.
- the encoder 400 can also be implemented as specialized hardware included in, for example, the transmitting station 102 .
- the encoder 400 has the following stages to perform the various functions in a forward path (shown by the solid connection lines) to produce an encoded or compressed bitstream 420 using the video stream 300 as input: an intra/inter prediction stage 402 , a transform stage 404 , a quantization stage 406 , and an entropy encoding stage 408 .
- the encoder 400 may also include a reconstruction path (shown by the dotted connection lines) to reconstruct a frame for encoding of future blocks.
- the encoder 400 has the following stages to perform the various functions in the reconstruction path: a dequantization stage 410 , an inverse transform stage 412 , a reconstruction stage 414 , and a loop filtering stage 416 .
- Other structural variations of the encoder 400 can be used to encode the video stream 300 .
- each frame 306 can be processed in units of blocks.
- each block can be encoded using intra-frame prediction (also called intra-prediction) or inter-frame prediction (also called inter-prediction), or a combination both.
- intra-prediction also called intra-prediction
- inter-frame prediction also called inter-prediction
- a prediction block can be formed.
- intra-prediction all or a part of a prediction block may be formed from samples in the current frame that have been previously encoded and reconstructed.
- inter-prediction all or part of a prediction block may be formed from samples in one or more previously constructed reference frames determined using motion vectors.
- the prediction block can be subtracted from the current block at the intra/inter prediction stage 402 to produce a residual block (also called a residual).
- the transform stage 404 transforms the residual into transform coefficients in, for example, the frequency domain using block-based transforms.
- block-based transforms include, for example, the Discrete Cosine Transform (DCT) and the Asymmetric Discrete Sine Transform (ADST).
- DCT Discrete Cosine Transform
- ADST Asymmetric Discrete Sine Transform
- combinations of different transforms may be applied to a single residual.
- the DCT transforms the residual block into the frequency domain where the transform coefficient values are based on spatial frequency.
- the lowest frequency (DC) coefficient at the top-left of the matrix and the highest frequency coefficient at the bottom-right of the matrix may be different from the size of the transform block.
- the prediction block may be split into smaller blocks to which separate transforms are applied.
- the quantization stage 406 converts the transform coefficients into discrete quantum values, which are referred to as quantized transform coefficients, using a quantizer value or a quantization level. For example, the transform coefficients may be divided by the quantizer value and truncated.
- the quantized transform coefficients are then entropy encoded by the entropy encoding stage 408 . Entropy coding may be performed using any number of techniques, including token and binary trees.
- the entropy-encoded coefficients, together with other information used to decode the block, which may include for example the type of prediction used, transform type, motion vectors and quantizer value, are then output to the compressed bitstream 420 .
- the information needed to decode the block may be entropy coded into block, frame, slice and/or section headers within the compressed bitstream 420 .
- the compressed bitstream 420 can also be referred to as an encoded video stream or encoded video bitstream, and the terms will be used interchangeably herein.
- the reconstruction path in FIG. 4 can be used to ensure that both the encoder 400 and a decoder 500 (described below) use the same reference frames and blocks to decode the compressed bitstream 420 .
- the reconstruction path performs functions that are similar to functions that take place during the decoding process that are discussed in more detail below, including dequantizing the quantized transform coefficients at the dequantization stage 410 and inverse transforming the dequantized transform coefficients at the inverse transform stage 412 to produce a derivative residual block (also called a derivative residual).
- the prediction block that was predicted at the intra/inter prediction stage 402 can be added to the derivative residual to create a reconstructed block.
- the loop filtering stage 416 can be applied to the reconstructed block to reduce distortion such as blocking artifacts.
- encoder 400 can be used to encode the compressed bitstream 420 .
- a non-transform based encoder 400 can quantize the residual signal directly without the transform stage 404 for certain blocks or frames.
- an encoder 400 can have the quantization stage 406 and the dequantization stage 410 combined into a single stage.
- FIG. 5 is a block diagram of a decoder 500 in accordance with another implementation.
- the decoder 500 can be implemented in the receiving station 106 , for example, by providing a computer software program stored in the memory 204 .
- the computer software program can include machine instructions that, when executed by a processor such as the CPU 202 , cause the receiving station 106 to decode video data in the manner described in FIG. 5 and in FIG. 8 below.
- the decoder 500 can also be implemented in hardware included in, for example, the transmitting station 102 or the receiving station 106 .
- the decoder 500 similar to the reconstruction path of the encoder 400 discussed above, includes in one example the following stages to perform various functions to produce an output video stream 516 from the compressed bitstream 420 : an entropy decoding stage 502 , a dequantization stage 504 , an inverse transform stage 506 , an intra/inter-prediction stage 508 , a reconstruction stage 510 , a loop filtering stage 512 and a deblocking filtering stage 514 .
- Other structural variations of the decoder 500 can be used to decode the compressed bitstream 420 .
- the data elements within the compressed bitstream 420 can be decoded by the entropy decoding stage 502 to produce a set of quantized transform coefficients.
- the dequantization stage 504 dequantizes the quantized transform coefficients (e.g., by multiplying the quantized transform coefficients by the quantizer value), and the inverse transform stage 506 inverse transforms the dequantized transform coefficients using the selected transform type to produce a derivative residual that can be identical to that created by the inverse transform stage 412 in the encoder 400 .
- the decoder 500 can use the intra/inter-prediction stage 508 to create the same prediction block as was created in the encoder 400 , e.g., at the intra/inter prediction stage 402 .
- the prediction block can be added to the derivative residual to create a reconstructed block.
- the loop filtering stage 512 can be applied to the reconstructed block to reduce blocking artifacts. Other filtering can be applied to the reconstructed block.
- the deblocking filtering stage 514 is applied to the reconstructed block to reduce blocking distortion, and the result is output as an output video stream 516 .
- the output video stream 516 can also be referred to as a decoded video stream, and the terms will be used interchangeably herein.
- decoder 500 can be used to decode the compressed bitstream 420 .
- the decoder 500 can produce the output video stream 516 without the deblocking filtering stage 514 .
- a block may be encoded or decoded by motion vector prediction a dynamic reference motion vector coding mode.
- a dynamic reference motion vector coding mode One implementation of using the dynamic reference motion vector coding mode for encoding and decoding is next discussed.
- FIG. 6 is a flow diagram showing a process 600 for encoding a video stream using reference motion vectors in accordance with an implementation of this disclosure.
- Process 600 can be implemented in an encoder such as encoder 400 and can be implemented, for example, as a software program that can be executed by computing devices such as transmitting station 102 or receiving station 106 .
- the software program can include machine-readable instructions that can be stored in a memory such as memory 204 or 214 , and that can be executed by a processor, such as CPU 202 , to cause the computing device to perform process 600 .
- the process 600 can be implemented using specialized hardware or firmware. Some computing devices can have multiple memories, multiple processors, or both. The steps or operations of the process 600 can be distributed using different processors, memories, or both. Use of the terms “processor” or “memory” in the singular encompasses computing devices that have one processor or one memory as well as devices that have multiple processors or multiple memories that can each be used in the performance of some or all of the recited steps.
- process 600 is depicted and described as a series of steps or operations. However, the teachings in accordance with this disclosure can occur in various orders and/or concurrently. Additionally, steps in accordance with this disclosure may occur with other steps not presented and described herein. Furthermore, not all illustrated steps or operations may be required to implement a method in accordance with the disclosed subject matter.
- the process 600 assumes that a stream of video data having multiple frames, each having multiple blocks, is being encoded using a video encoder such as encoder 400 executing on a computing device such as transmitting station 102 .
- the video data or stream can be received by the computing device in any number of ways, such as by receiving the video data over a network, over a cable, or by reading the video data from a primary memory or other storage device, including a disk drive or removable media such as a CompactFlash (CF) card, Secure Digital (SD) card, or any other device capable of communicating video data.
- video data can be received from a video camera connected to the computing device operating the encoder. At least some of the blocks within frames are encoded using inter prediction as described in more detail below.
- the process 600 identifies candidate motion vectors from previously coded blocks in the video stream.
- the process 600 analyzes the motion activity of previously coded blocks to produce a list of ranked candidate motion vectors, employing an efficient reference motion vector ranking system, and provides a dynamic motion referencing mode that fully accounts for the available motion vector candidate list, which allows the number of the reference motion vector modes to be dynamically extended or shortened and improves the efficacy of entropy coding.
- the pool of the candidate motion vectors can be dynamically extended or shortened according to the neighboring reference block condition, i.e., how the list of candidate motion vectors is created.
- the previously coded blocks in the video stream can include any block encoded using inter-prediction before the current block, such as a block from a previously coded frame or a block from the same frame as the current block that has been encoded before the current block.
- the previously coded blocks can include a block above, to the left, or to the above-left of the current block in the same frame.
- the previously coded blocks can also include, for example, a block from the immediately previous frame (i.e., last frame), a block from the golden frame (described at intra/inter prediction stage 402 ), a block from any other reference frame, or any combination thereof.
- the candidate motion vectors are obtained from previously coded blocks that correspond in some way to the current block based on the theory that such blocks, due to the proximity of their pixels to the current block, are likely to have similar motion characteristics to the current block.
- Blocks may be predicted from a single reference frame or compound, such as two, reference frames.
- the process 600 identifies candidate motion vectors from the nearest spatial neighboring blocks that are associated with the reference frame.
- the candidate motion vectors may include the motion vector reference blocks within a reference coverage area, such as the motion vector(s) from a boundary area (e.g., a block) above the current block, the motion vector(s) from a boundary area (e.g., a block) to the left of the current block, the motion vector from a top-right corner of the current block, and the motion vector(s) from a collocated block in the previous frame.
- motion vectors associated with blocks below and to the right of the collocated block are considered.
- FIG. 7 is a diagram of a sequence of frames used to explain the identification of candidate motion vectors of 602 within the process 600 of FIG. 6 .
- the current block B being encoded is located within current Frame N.
- Frame N- 1 is the preceding frame, also called a temporally adjacent frame, which may be the reconstructed frame stored in a so-called last reference frame buffer that is available for coding blocks of Frame N.
- block R 3 is the collocated block to the current block B, and it is located at the same pixel location (usually measured from the top-left pixel) and has the same pixel dimensions in the x- and y- planes (i.e., the same pixel coordinates) within Frame N- 1 as the current block B has within Frame N. Stated another way, the block R 3 spatially corresponds to the current block B.
- the motion vector candidate buffer is associated with the reference frame. Given the reference frame index, a search for motion vectors associated with the same reference frame may be performed through the reference blocks shown in FIG. 7 for inclusion in the candidate list.
- the blocks B and R 3 are of an arbitrary block size.
- the blocks B and R 3 may each be 32z32 pixels.
- each frame may be partitioned into blocks for coding. Those blocks may be further partitioned into smaller blocks for coding purposes. For this reason, any block or region adjacent to the current block B may have been partitioned into smaller blocks that are predicted by different motion vectors. Therefore, the search for motion vectors may be take this into consideration by assessing the motion information for the smallest possible prediction block size within a frame.
- the search for motion vectors in the current frame is done using motion information from a top row boundary region, also called block R 0 , a left column boundary region, also called block R 1 , and the top-right corner, also call block R 2 .
- the blocks R 0 and R 1 are regions whose size (dimensions) is related to the size of the current block B.
- the blocks R 0 and R 1 are of the same size as the current block B, but they may be half the size of the current block B or otherwise relate to the size of the current block B.
- each sub-block of pixels, e.g., having the smallest prediction block size within blocks R 0 and R 1 can be scanned through for candidate motion vectors.
- the smallest prediction block size may be 8 ⁇ 8 or 4 ⁇ 4.
- the block R 2 is desirably the smallest prediction block size to minimize searching and because more distant blocks are likely to provide less relevant information.
- the block R 2 would only have one motion vector (or two in combined prediction) if the block R 2 is the smallest prediction block size.
- the block R 2 may be larger in size in an implementation.
- the search for motion vectors in the last frame is done using motion information from the collocated block R 3 , and the additional reference blocks R 4 , R 5 , R 6 , and R 7 adjacent to the bottom row (blocks R 6 , R 7 ), the right column (R 4 ), or both (R 5 ). That is, they each proximate to (e.g., in contact with) a corner of the collocated block.
- the collocated block R 3 has the same size as the current block.
- Each sub-block of the smallest prediction block size within the collocated block R 3 may be scanned or searched for candidate motion vectors.
- the additional reference blocks R 4 , R 5 , R 6 , and R 7 respectively have the smallest prediction block size regardless of the size of the current block B, but this is not required.
- the process 600 may determine, for each candidate motion vector, a distance between the previously coded block associated with the candidate motion vector and the current block.
- the motion vectors from the nearest row and column boundaries and the top-right corner to the current block are in contact with the current block and may be considered to be more relevant and so are ranked higher than those further away.
- the distance may be used to group the motion vectors into categories. For example, and with reference to FIG.
- any motion vectors from the sub-blocks of the reference blocks R 0 and R 1 , and a motion vector from the reference block R 2 , if any, may be considered as category 1 candidate motion vectors, while the remaining candidate motion vectors from the blocks R 3 through R 7 and from any other sub-blocks of the reference blocks R 0 and R 1 are considered to be category 2 candidate motion vectors.
- category 1 candidate motion vectors would assume a higher priority than category 2 candidate motion vectors.
- the distance may additionally or alternatively include calculating a straight line distance between the centers of the current block and each of the reference blocks and/or sub-blocks of the reference blocks.
- the distance between the reference block and the current block can be based on the spatial displacement between the pixels in the previously coded block and the collocated pixels in the current block, measured in the unit of pixels.
- a collocated block may be ranked higher than reference blocks in a current frame (e.g., because the difference/displacement is zero), even when popularity values are considered.
- Other ways of grouping and/or ranking the motion vectors based on distance are possible.
- each category the motion vectors may be ranked according to the number of pixels within the search areas (e.g., the previously coded pixels of at least some of the reference blocks) that are using each motion vector.
- the process 600 may determine a popularity value based on the previously coded pixel values associated with the particular candidate motion vector at 606 . The larger the number of previously coded pixel values associated with the candidate motion vector, the higher the popularity value of the candidate motion vector.
- the popularity value may be a raw number of pixels or a percentage of the total number of pixels within all or some of the reference blocks, for example.
- the current block B and the collocated block R 3 each comprise 32 ⁇ 32 pixels
- the reference block R 0 and the reference block R 1 respectively comprise 32 ⁇ 16 and 16 ⁇ 32 pixels
- the reference blocks R 2 and R 4 -R 7 each comprise 8 ⁇ 8 pixels, which also corresponds to the smallest prediction block size.
- there could be up to nine motion vector candidates associated with a reference frame and assigned to category 1 four each from the 8 ⁇ 8 sub-blocks of reference blocks R 0 and R 1 adjacent to the current block B and one from the 8 ⁇ 8 reference block R 2 .
- motion vectors There could be up to twenty-eight motion vectors associated with the reference frame and assigned to category 2 , four each from the remaining 8 ⁇ 8 sub-blocks of the reference blocks R 0 and R 1 , sixteen from the collocate block R 3 , and one each from the additional four 8 ⁇ 8 reference blocks R 4 -R 7 .
- motion vectors are often re-used.
- Each of the unique motion vectors within a category from all of those identified is attributed with a popularity value corresponding to each of the groups of 8 ⁇ 8 pixels (that is, 64 pixels) using that motion vector.
- the motion vector does not have to be identical to another. Ranges can be used so as to provide a motion vector candidate list demonstrating sufficient variation to useful.
- a motion vector may be omitted within a category if it does not vary enough from a motion vector candidate already in a category, such as by 10% or some other variable.
- motion vectors are ranked by category and then ranked within the categories, but this is not required.
- the motion vector candidates may be grouped together for ranking based on the popularity value.
- the reference motion vector candidate list may be constructed as described for each unique reference frame associated with a previously coded block or sub-block. For example, three reference frames may be available for each frame as described above—a last frame, an alternative (or alternate or alt) reference frame, and a golden reference frame. In this case, separate reference motion vector candidate list may be constructed using those previously coded blocks or sub-blocks having motion vectors pointing each of the last frame, the alt reference frame, and the golden reference frame. The last frame is updated for each frame, and the alt reference frame and golden reference frame may be updated less frequently.
- motion vector scaling is performed when constructing a reference motion vector candidate list.
- Motion vector scaling may be done as part of the determination of a popularity value at 606 , or may be done at other points in the process 600 .
- Motion vector scaling adjusts the magnitude of a motion vector to account for the temporal differences between reference frames relative to the frame under consideration within the sequence of frames within the video stream. For example, and again with reference to FIG. 7 , the reference block R 2 uses the last frame, which is Frame N- 1 , for inter-prediction, while the reference block R 4 uses the last frame, which is the frame preceding Frame N- 1 (or Frame N- 2 , not shown), for inter-prediction.
- the temporal difference between the frame in which each block R 2 and R 4 is located (Frame N and Frame N- 1 , respectively) and the corresponding reference frame (Frame N- 1 and Frame N- 2 , respectively) is one frame, so no scaling is indicated.
- the reference blocks R 2 and R 4 both use the golden reference frame, the temporal differences between Frame N and the golden reference frame and the between the Frame N- 1 and the golden reference frame are different if the golden reference frame is unchanged.
- a candidate motion vector can be generated by scaling up the magnitude of the motion vector associated with the shorter temporal difference or scaling down the magnitude of the motion vector associated with the longer temporal differences so that the motion vectors share a common basis.
- the factor used for scaling can be based on a ratio formed by the temporal differences.
- Motion vector scaling may also be used in implementations where only one reference motion vector candidate list is prepared for all reference frames, instead of separate lists for each reference frame. Reference frames may be located either before or after the current frame in the video sequence. In some implementations, motion vector scaling is omitted.
- a block may be predicted from two or more reference frames, where the pixel values are combinations of the pixels values from prediction blocks within each frame generated by respective motion vectors.
- the list is constructed by first looking for neighboring blocks that share the same compound reference frames (i.e., the same combination of reference frames) for their reference motion vectors. A higher priority is assigned to candidate motion vectors from neighboring reference blocks that share the combination of reference frames as that under consideration for the current block.
- the motion vectors may also be ranked from highest to lowest popularity value.
- the list may be appended with combinations of reference motion vectors of single reference frames that are identified and ranked as described above. For example, if a compound reference mode that uses the last frame and the alt reference frame is under consideration, the reference blocks are searched for motion vectors referencing either the last frame or the alt reference frame, which are then ranked based on a popularity value as discussed.
- the determination of the popularity values at 608 includes ranking the motion vectors using the popularity values. It can also include assigning the motion vectors to inter-coding (or inter-prediction) modes based on the ranking.
- the most popular motion vector may be selected for an inter-prediction mode that includes differential coding of a new motion vector. This may be referred to as a NEWMV mode.
- the remaining motion vectors may be assigned to other reference vector motion modes.
- a REFMV mode is a dynamic reference motion vector coding mode that includes at least two modes where an existing motion vector is re-used. In an example, these two inter-prediction modes are a NEARESTMV mode and a NEARMV mode.
- next motion vector in the ranking after the one assigned to the NEWMV mode i.e., the motion vector with the second highest popularity value
- the next motion vector after that i.e., the motion vector with the third highest popularity value
- Another available inter-prediction mode may be a ZEROMV mode, which means that no motion exists.
- an inter-prediction mode is selected for the current block. This may include testing each of the inter-prediction modes and selecting the inter-prediction mode that results in the most efficient coding of the current block.
- the process 600 may be part of a rate-distortion loop used to select the inter-prediction mode for the current block to be encoded.
- an actual motion vector for inter prediction of the current block may be determined through a motion search according to any number of motion searching techniques.
- one use of the reference motion vector may include using the reference motion vector assigned to the NEWMV mode or one of the other identified candidate motion vectors as a starting parameter for the motion search algorithm based on the reasoning that the actual motion vector is likely to be close to highly ranked motion vectors for the reference frame.
- Combinations of reference frames in a compound prediction mode may be similarly searched using motion vectors from the candidate list, particularly those having the highest rank for each of the reference frames.
- Motion searches may alternatively be performed without using motion vectors from the candidate lists. Whether or not a reference motion vector is used in the motion search, various inter-prediction modes may be tested. In one implementation, an exhaustive motion search that attempts each of the available inter-prediction modes using single or compound modes (i.e., using each of the three reference frames and combinations of reference frames).
- a bit cost (also called a rate) of encoding the current block using the inter-prediction mode, including the bits required to signal the inter-prediction mode, the reference frame(s), the residual block generated from the current block, and, if required, one or more motion vector(s) or motion vector differential(s), and the resulting error in the pixel values between the original values and the reconstructed values (also called a distortion) are calculated.
- the inter-prediction mode and reference frame(s) resulting in the lowest rate-distortion value also called a ratio
- the inter-prediction modes used for adjacent blocks in the frames may be tested first, and then only certain inter-prediction modes may be tested to see if an improved rate-distortion ratio results. Further, motion searching is applicable to inter-prediction.
- the rate-distortion loop may include tests for various intra-prediction modes, or a separate rate-distortion loop may be used to select the most efficient intra-prediction mode from available intra-prediction modes. Then, the most efficient inter-prediction mode and the most efficient intra-prediction mode are compared to select the prediction mode for the block.
- the current block is encoded at 610 using the inter-prediction mode.
- the predicted block is generated using the actual motion vector(s) from the motion search and the selected reference frame(s).
- the residual between the current block and the predicted block is generated and encoded as described with reference to FIG. 4 .
- the motion vector(s) assigned to the NEWMV mode by the ranking can be used to differentially encode the actual motion vector(s).
- a difference value or residual can be calculated by subtracting a reference motion vector from a motion vector used to encode the current block.
- the difference value can be encoded and included in the video stream.
- bits indicating the reference frame(s) and that the NEWMV mode was used may be indicated in the block header and/or in a frame or slice header.
- the motion search results in a motion vector equal to or within a range of values about one of the reference motion vectors assigned to reference motion vector modes.
- the REFMV inter-prediction mode is indicated. If the motion vector resulting from the search is equal to or within a range of values about the reference motion vector assigned to the NEARMV mode in this example, the predicted block is generated using the reference motion vector assigned to the NEARMV mode and the selected reference frame. Then, the residual between the current block and the predicted block is generated and encoded as described with reference to FIG. 4 .
- bits indicating the reference frame and that the REFMV mode and particularly the NEARMV mode was used may be indicated in the block header and/or in a frame or slice header.
- the remaining inter-prediction modes may similarly be used to encode the current block, if selected at 608 , or to encode other blocks of the frames within a video sequence.
- the process 600 of FIG. 6 may be repeated as needed.
- encoding the current block may include entropy coding.
- Entropy coding the inter-prediction modes may be modified to take into account the new dynamic reference motion vector modes. Assuming three inter-prediction modes corresponding to a new motion vector, a zero motion vector, and a dynamic reference motion vector mode, respectively the NEWMV mode, the ZEROMV mode, and REFMV mode in this example, entropy coding starts with the NEWMV mode.
- the probability model may be selected according to two contexts: 1) how many reference motion vectors are found; and 2) if neighboring block(s) with a matched reference frame is found, how likely they are to be coded in the NEWMV mode.
- the probability model may be selected according to two contexts: 1) if the collocated block in the last (or previous) frame using a zero motion vector, or close to a zero motion vector (i.e., less than one full pixel in both row and column components); and 2) whether (and possibly how many of) the spatial neighboring blocks within the current frame are using zero motion vectors, or close to zero motion vectors.
- next coding mode is not the ZEROMV mode (i.e., is the dynamic reference motion vector mode indicated by the REFMV mode)
- ZEROMV mode i.e., is the dynamic reference motion vector mode indicated by the REFMV mode
- the associated context is how many reference motion vectors are checked into the candidate list and, when applicable, their weighting coefficients used in compound prediction.
- FIG. 8 is a flowchart diagram of a process 800 for decoding an encoded video stream using reference motion vectors in accordance with implementations of this disclosure.
- the process 800 can be implemented, for example, as a software program that may be executed by computing devices such as transmitting station 102 or receiving station 106 .
- the software program can include machine-readable instructions that may be stored in a memory such as memory 204 or 214 , and that, when executed by a processor, such as CPU 202 , may cause the computing device to perform the process 800 .
- the process 800 can be implemented using specialized hardware or firmware. As explained above, some computing devices may have multiple memories or processors, and the operations described in the process 800 can be distributed using multiple processors, memories, or both.
- process 800 is depicted and described as a series of steps or operations. However, the steps or operations in accordance with this disclosure can occur in various orders and/or concurrently. Additionally, other steps or operations not presented and described herein may be used. Furthermore, not all illustrated steps or operations may be required to implement a method in accordance with the disclosed subject matter.
- the decoder determines whether the current block was encoded using single or compound prediction.
- This information can be communicated by reading and decoding bits from an encoded video bitstream that indicate the one or more than one motion vectors was used to encode the current block.
- the encoded bitstream (or encoded video data) may be received by a decoder of a computing device in any number of ways, such as by receiving the video data over a network, over a cable, or by reading the video data from a primary memory or other storage device, including a disk drive or removable media such as a DVD, CompactFlash (CF) card, Secure Digital (SD) card, or any other device capable of communicating a video stream.
- This information can be included in a header associated with a current block or a frame header, for example. This explanation assumes that the current block is inter-predicted. Otherwise, no reference frame is encoded into the bitstream in association with the current block, and the current block was intra-predicted.
- the candidate motion vectors can be ranked in a similar manner as described with reference to the process 600 of FIG. 6 . That is, the encoder and decoder can share rules regarding the generation of reference motion vector candidate lists so that the decoder, receiving header information related to which inter-prediction mode was used to encode the current block (e.g., NEWMV, NEARESTMV, NEARMV, etc.), is able to identify the same reference motion vector(s) used by the encoder.
- the candidate motion vectors can be identified from previously coded blocks at 804 in a like manner as they are identified at 602 in the process 600 . While the process 600 may identify the candidate motion vectors for ranking using all available reference frames and combinations of reference frames in order to select the inter-prediction mode, the process 800 only needs to rank those candidate motion vectors for the reference frame(s) actually to encode the block.
- ranking the candidate motion vectors includes determining, for each candidate motion vector, the distance between the previously coded block that is the source of the motion vector and the current block at 806 . This involves the same operations as those described above with respect to the determination at 604 in the process 600 .
- the result of this operation is a list of candidate motion vectors grouped by the distance in an embodiment.
- determining a respective popularity value for the candidate motion vectors from previously coded blocks at 804 is performed the same as the determination at 606 in the process 600 .
- the result of this operation is a ranked list of candidate motion vectors for the single reference frame or the combined reference frames used in the prediction of the current block.
- the highest ranked (e.g., most probable) motion vector is assigned to a NEWMV mode, and the next two motion vectors in the ranking are assigned respectively to the NEARESTMV and NEARMV reference motion vector modes of the dynamic reference motion vector (REFMV) mode. Any further reference motion vectors are assigned in sequence thereafter.
- the inter-prediction mode that was used to encode the current block is identified.
- the inter-prediction mode is identified by decoding bits included within the bitstream that identify the inter-prediction mode.
- the inter-prediction mode may be the new motion vector mode, the zero motion vector mode, or the dynamic reference motion vector mode. If the inter-prediction mode is the dynamic reference motion vector mode, the particular reference motion vector mode used can be similarly determined, e.g., from bits included within header(s) in the bitstream.
- the inter-prediction mode identified at 810 is used to decode the current block at 812 , such as through the decoding process described with reference to FIG. 5 .
- the reference motion vector can be used to decode the motion vector used to predict the current block.
- the inter-prediction mode may indicate the motion vector by reference to the list. Regardless of the source of the one or more motion vectors, the prediction block is generated using the motion vector(s) and is added to the residual for the current block decoded from the bitstream.
- the process 800 may be repeated for each block that is encoded using inter-prediction to generate a reconstructed block.
- the frame is reconstructed using the reconstructed blocks and those reconstructed using intra-prediction.
- an output video stream such as the output video stream 516 shown in FIG. 5 , can be reconstructed.
- encoding and decoding illustrate some encoding and decoding techniques. However, it is to be understood that encoding and decoding, as those terms are used in the claims, could mean compression, decompression, transformation, or any other processing or change of data.
- example is used herein to mean serving as an example, instance, or illustration. Any aspect or design described herein as using one or more of these words is not necessarily to be construed as preferred or advantageous over other aspects or designs. Rather, use of the word “example,” “aspect,” or “implementation” is intended to present concepts in a concrete fashion.
- the term “or” is intended to mean an inclusive “or” rather than an exclusive “or”. That is, unless specified otherwise, or clear from context, “X includes A or B” is intended to mean any of the natural inclusive permutations.
- Implementations of transmitting station 102 and/or receiving station 106 can be realized in hardware, software, or any combination thereof.
- the hardware can include, for example, computers, intellectual property (IP) cores, application-specific integrated circuits (ASICs), programmable logic arrays, optical processors, programmable logic controllers, microcode, microcontrollers, servers, microprocessors, digital signal processors or any other suitable circuit.
- IP intellectual property
- ASICs application-specific integrated circuits
- programmable logic arrays optical processors
- programmable logic controllers programmable logic controllers
- microcode microcontrollers
- servers microprocessors, digital signal processors or any other suitable circuit.
- signal processors should be understood as encompassing any of the foregoing hardware, either singly or in combination.
- signals and “data” are used interchangeably. Further, portions of transmitting station 102 and receiving station 106 do not necessarily have to be implemented in the same manner.
- transmitting station 102 or receiving station 106 can be implemented using a general purpose computer or general purpose processor with a computer program that, when executed, carries out any of the respective methods, algorithms and/or instructions described herein.
- a special purpose computer/processor can be utilized which can contain other hardware for carrying out any of the methods, algorithms, or instructions described herein.
- Transmitting station 102 and receiving station 106 can, for example, be implemented on computers in a video conferencing system.
- transmitting station 102 can be implemented on a server and receiving station 106 can be implemented on a device separate from the server, such as a hand-held communications device.
- transmitting station 102 can encode content using an encoder 400 into an encoded video signal and transmit the encoded video signal to the communications device.
- the communications device can then decode the encoded video signal using a decoder 500 .
- the communications device can decode content stored locally on the communications device, for example, content that was not transmitted by transmitting station 102 .
- Other transmitting station 102 and receiving station 106 implementation schemes are available.
- receiving station 106 can be a generally stationary personal computer rather than a portable communications device and/or a device including an encoder 400 may also include a decoder 500 .
- implementations of the present disclosure can take the form of a computer program product accessible from, for example, a tangible computer-usable or computer-readable medium.
- a computer-usable or computer-readable medium can be any device that can, for example, tangibly contain, store, communicate, or transport the program for use by or in connection with any processor.
- the medium can be, for example, an electronic, magnetic, optical, electromagnetic, or a semiconductor device. Other suitable mediums are also available.
Abstract
Description
- This application claims priority to U.S. Provisional Application No. 62/288,553, filed Jan. 29, 2016, and to U.S. Provisional Application No. 62/330,491, filed May 2, 2016, each of which is incorporated herein in its entirety by reference.
- Digital video streams may represent video using a sequence of frames or still images. Digital video can be used for various applications including, for example, video conferencing, high definition video entertainment, video advertisements, or sharing of user-generated videos. A digital video stream can contain a large amount of data and consume a significant amount of computing or communication resources of a computing device for processing, transmission or storage of the video data. Various approaches have been proposed to reduce the amount of data in video streams, including compression and other encoding techniques.
- This disclosure relates generally to encoding and decoding video data and more particularly relates to video coding using reference motion vectors.
- A method for decoding a video stream according to one implementation of this disclosure includes identifying, for a current block, a reference frame used to encode the current block within a current frame, creating a reference motion vector candidate list for the reference frame using reference blocks, ranking each motion vector within the reference motion vector candidate list by a distance from the current block to a reference block providing the motion vector, and by a popularity value of the motion vector that indicates a level of use of the motion vector by the reference block that indicates a level of use of the motion vector by the reference blocks, assigning the motion vectors to a plurality of inter-prediction modes based on the ranking, selecting an inter-prediction mode for decoding the current block, and decoding the current block using the inter-prediction mode. The reference blocks can including spatially adjacent blocks of the current frame, a collocated block within a previous frame, and spatially adjacent blocks of the collocated block within the previous frame, or other reference blocks.
- An apparatus for decoding a video stream according to one implementation of this disclosure includes a processor and a memory. The memory is storing instructions that cause the processor to perform the method above.
- A method for encoding a video stream according to one implementation of this disclosure include identifying, for each of a plurality of reference frames, candidate motion vectors for encoding a current block within a current frame using reference blocks, ranking the candidate motion vectors within a reference motion vector candidate list for a reference frame by a distance from the current block of a respective reference block providing a respective candidate motion vector, and by a popularity value of the motion vector that indicates a level of use of the motion vector by the reference blocks, assigning the motion vectors to a plurality of inter-prediction modes based on the ranking, selecting an inter-prediction mode for encoding the current block, and encoding the current block using the inter-prediction mode.
- Variations in these and other aspects of the disclosure will be described in additional detail hereafter.
- The description herein makes reference to the accompanying drawings described below wherein like reference numerals refer to like parts throughout the several views.
-
FIG. 1 is a schematic of a video encoding and decoding system. -
FIG. 2 is a block diagram of an example of a computing device that can implement a transmitting station or a receiving station. -
FIG. 3 is a diagram of a video stream to be encoded and subsequently decoded. -
FIG. 4 is a block diagram of a video compression system according to an aspect of the teachings herein. -
FIG. 5 is a block diagram of a video decompression system according to another aspect of the teachings herein. -
FIG. 6 is a flowchart diagram of a process for encoding a video stream using reference motion vectors in accordance with an implementation of this disclosure. -
FIG. 7 is a diagram of a sequence of frames used to explain the identification of candidate motion vectors within the process ofFIG. 6 . -
FIG. 8 is a flowchart diagram of a process for decoding an encoded video stream using reference motion vectors in accordance with implementations of this disclosure. - Compression schemes related to coding video streams may include breaking each image into blocks and generating a digital video output bitstream using one or more techniques to limit the information included in the output. A received bitstream can be decoded to re-create the blocks and the source images from the limited information. Encoding a video stream, or a portion thereof, such as a frame or a block, can include using temporal and spatial similarities in the video stream to improve coding efficiency. For example, a current block of a video stream may be encoded based on a previously encoded block in the video stream by predicting motion and color information for the current block based on the previously encoded block and identifying a difference (residual) between the predicted values and the current block. In this way, only the residual and parameters used to generate it need be added to the bitstream instead of including the entirety of the current block. This technique may be referred to as inter prediction.
- One of the parameters in inter prediction is a motion vector that represents the spatial displacement of the previously coded block relative to the current block. The motion vector can be identified using a method of motion estimation, such as a motion search. In motion search, a portion of a reference frame can be translated to a succession of locations to form a prediction block that can be subtracted from a portion of a current frame to form a series of residuals. The X and Y translations corresponding to the location having the smallest residual can be selected as the motion vector. Bits representing the motion vector can be included in the encoded bitstream to permit a decoder to reproduce the prediction block and decode the portion of the encoded video bitstream associated with the motion vector.
- For video compression schemes, the number of bits used to encode the motion vectors can be significant, especially for video streams encoded at lower data rates or higher compression ratios. To improve the encoding efficiency, a motion vector can be differentially encoded using a reference motion vector, i.e., only the difference between the motion vector and the reference motion vector is encoded. In some instances, the reference motion vector can be selected from previously used motion vectors in the video stream, for example, the last non-zero motion vector from neighboring blocks. Selecting a previously used motion vector to encode a current motion vector can further reduce the number of bits included in the encoded video bitstream and thereby reduce transmission and storage bandwidth requirements. Motion vector referencing modes allow a coding block to infer motion information from previously coded neighboring blocks.
- The reference motion vector candidate list can be constructed according to the distance between the reference block and the current block being encoded. However, ranking solely according to the block distance ignores that a motion vector may be used by multiple blocks. How many pixels in a reference area are using the motion vector may indicate the likelihood that the motion vector is an effective motion vector for the current block.
- As mentioned, neighboring blocks may be used to construct a reference motion vector candidate list. In order that the encoder and decoder are using the same information, previously coded blocks are used. When coding in raster scan order, this limits the neighboring blocks to those to the left and above the current block to the extent they are available. The collocated block from the previous frame (also called the last frame) can also be considered. However, the collocated block is a block located in the last frame having the same pixel location as the current block, so potentially useful motion information from the right and bottom of the current block is still omitted.
- Regardless of how the reference motion vector candidate list is constructed, there may be a fixed number of motion vector referencing modes, such as two. The use of a fixed number of reference modes can be inefficient. For example, if the reference motion vector candidate list has less than the fixed number of motion vectors, zero motion vectors may be need to pad the modes without a motion vector. In other cases, the reference motion vector candidate list may have more than the fixed number of motion vectors. The omitted motion vectors may be better candidates than those kept—that is, an omitted motion vector may result in a better rate and/or less distortion in coding the current block.
- In implementations of this disclosure, compression performance may be improved by employing an efficient reference motion vector ranking system, followed by a dynamic motion vector referencing mode that fully accounts for the available motion vector candidate list. In the ranking system, for example, reference motion vector candidates for blocks with a single reference frame may be ranked according to both relative distance from the current block and the coverage area (e.g., the use of the motion vector). For blocks with compound (e.g., two) reference frames, the candidate motion vectors from reference blocks that share the same reference frame combination may be ranked with a higher priority. Ranked below this are, optionally, combinations of motion vectors from neighboring blocks with a single reference frame. In the determination of motion vector candidates, motion information associated with blocks below and to the right of the collocated block may be considered so as to capture those directions of movement. Finally, the dynamic motion vector referencing mode may use a number of modes that is dependent on the size of reference motion vector candidate list so that the chance of losing potentially valuable reference information is reduced.
- A reference motion vector may be selected from candidate motion vectors based on the distance between the reference block and the current block and the popularity of the reference motion vector. For example, the distance between the reference block and the current block can be based on the spatial displacement between the pixels in the previously coded block and corresponding collocated pixels in the current block, measured in the unit of pixels. For example, the popularity of the motion vector can be based on the amount of previously coded pixels that use the motion vector. The more previously coded pixels that use the motion vector, the higher the probability of the motion vector. In one example, the popularity value is the number of previously coded pixels that use the motion vector. In another example, the popularity value is a percentage of previously coded pixels within an area that use the motion vector.
- Due to the proximity of the current block to pixels in the reference block, it is likely in many cases that the current block has similar motion characteristics to those pixels. Thus, a candidate motion vector used in a reference block near the current block may closely resemble the actual motion vector for the current block. Additionally, a candidate motion vector that is used by the most amount of pixels in a reference block near the current block would further resemble the actual motion vector for the current block. For this reason, the motion vector of the candidate motion vectors with the highest popularity used in a nearby reference block may be selected as the reference motion vector for the actual motion vector of the current block. Fewer bits can be used to code the actual motion vector by coding the small difference in motion vectors, thus improving the overall coding efficiency. Other ways in which the selected motion vector may be used are discussed hereinafter.
- The candidate motion vectors may be limited to spatial-temporal neighboring motion vectors. That is, the pool of candidate motion vectors may be selected from regions neighboring regions of the current block. In some video coding schemes, particularly those where video frames are encoded out of order, it is desirable to include in the pool of candidate motion vectors motion information from video frames in the distant past or future. Encoding video frames can out of order may occur, for example, in the coding of so-called “alternate reference frames” that are not temporally neighboring to the frames coded immediately before or after them. An alternate reference frame may be a synthesized frame that does not occur in the input video stream or is a duplicate frame to one in the input video stream that is used for prediction and is generally not displayed following decoding. Such a frame can resemble a video frame in the non-adjacent future. Another example in which out of order encoding may occur is through the use of a so-called “golden reference frame,” which is a reconstructed video frame that may or may not be neighboring to a current video frame and is stored in memory for use as a reference frame until replaced, e.g., by a new golden reference frame.
- Herein, alternate reference frames and golden reference frames (also called alternate frames and golden frames), in addition to adjacent video frames, may be used to infer motion vector candidates for a block of a frame of video data. Other details are described herein after first describing an environment in which the disclosure may be implemented.
-
FIG. 1 is a schematic of a video encoding anddecoding system 100. A transmittingstation 102 can be, for example, a computer having an internal configuration of hardware such as that described inFIG. 2 . However, other implementations of the transmittingstation 102 are possible. For example, the processing of the transmittingstation 102 can be distributed among multiple devices. - A
network 104 can connect the transmittingstation 102 and a receivingstation 106 for encoding and decoding of the video stream. Specifically, the video stream can be encoded in the transmittingstation 102 and the encoded video stream can be decoded in the receivingstation 106. Thenetwork 104 can be, for example, the Internet. Thenetwork 104 can also be a local area network (LAN), wide area network (WAN), virtual private network (VPN), cellular telephone network or any other means of transferring the video stream from the transmittingstation 102 to, in this example, the receivingstation 106. - The receiving
station 106, in one example, can be a computer having an internal configuration of hardware such as that described inFIG. 2 . However, other implementations of the receivingstation 106 are possible. For example, the processing of the receivingstation 106 can be distributed among multiple devices. - Other implementations of the video encoding and
decoding system 100 are possible. For example, an implementation can omit thenetwork 104. In another implementation, a video stream can be encoded and then stored for transmission at a later time to the receivingstation 106 or any other device having memory. In one implementation, the receivingstation 106 receives (e.g., via thenetwork 104, a computer bus, and/or some communication pathway) the encoded video stream and stores the video stream for later decoding. In an example implementation, a real-time transport protocol (RTP) is used for transmission of the encoded video over thenetwork 104. In another implementation, a transport protocol other than RTP may be used, e.g., a Hypertext Transfer Protocol (HTTP)-based video streaming protocol. - When used in a video conferencing system, for example, the transmitting
station 102 and/or the receivingstation 106 may include the ability to both encode and decode a video stream as described below. For example, the receivingstation 106 could be a video conference participant who receives an encoded video bitstream from a video conference server (e.g., the transmitting station 102) to decode and view and further encodes and transmits its own video bitstream to the video conference server for decoding and viewing by other participants. -
FIG. 2 is a block diagram of an example of acomputing device 200 that can implement a transmitting station or a receiving station. For example, thecomputing device 200 can implement one or both of the transmittingstation 102 and the receivingstation 106 ofFIG. 1 . Thecomputing device 200 can be in the form of a computing system including multiple computing devices, or in the form of a single computing device, for example, a mobile phone, a tablet computer, a laptop computer, a notebook computer, a desktop computer, and the like. - A
CPU 202 in thecomputing device 200 can be a central processing unit. Alternatively, theCPU 202 can be any other type of device, or multiple devices, capable of manipulating or processing information now-existing or hereafter developed. Although the disclosed implementations can be practiced with a single processor as shown, e.g., theCPU 202, advantages in speed and efficiency can be achieved using more than one processor. - A
memory 204 in thecomputing device 200 can be a read only memory (ROM) device or a random access memory (RAM) device in an implementation. Any other suitable type of storage device can be used as thememory 204. Thememory 204 can include code anddata 206 that is accessed by theCPU 202 using abus 212. Thememory 204 can further include anoperating system 208 andapplication programs 210, theapplication programs 210 including at least one program that permits theCPU 202 to perform the methods described here. For example, theapplication programs 210 can includeapplications 1 through N, which further include a video coding application that performs the methods described here. Thecomputing device 200 can also include additional memory in the form of asecondary storage 214, which can, for example, be a memory card used with a mobile computing device. Because the video communication sessions may contain a significant amount of information, they can be stored in whole or in part in thesecondary storage 214 and loaded into thememory 204 as needed for processing. - The
computing device 200 can also include one or more output devices, such as adisplay 218. Thedisplay 218 may be, in one example, a touch sensitive display that combines a display with a touch sensitive element that is operable to sense touch inputs. Thedisplay 218 can be coupled to theCPU 202 via thebus 212. Other output devices that permit a user to program or otherwise use thecomputing device 200 can be provided in addition to or as an alternative to thedisplay 218. When the output device is or includes a display, the display can be implemented in various ways, including by a liquid crystal display (LCD), a cathode-ray tube (CRT) display or light emitting diode (LED) display, such as an organic LED (OLED) display. - The
computing device 200 can also include or be in communication with an image-sensingdevice 220, for example a camera, or any other image-sensingdevice 220 now existing or hereafter developed that can sense an image such as the image of a user operating thecomputing device 200. The image-sensingdevice 220 can be positioned such that it is directed toward the user operating thecomputing device 200. In an example, the position and optical axis of the image-sensingdevice 220 can be configured such that the field of vision includes an area that is directly adjacent to thedisplay 218 and from which thedisplay 218 is visible. - The
computing device 200 can also include or be in communication with a sound-sensing device 222, for example a microphone, or any other sound-sensing device now existing or hereafter developed that can sense sounds near thecomputing device 200. The sound-sensing device 222 can be positioned such that it is directed toward the user operating thecomputing device 200 and can be configured to receive sounds, for example, speech or other utterances, made by the user while the user operates thecomputing device 200. - Although
FIG. 2 depicts theCPU 202 and thememory 204 of thecomputing device 200 as being integrated into a single unit, other configurations can be utilized. The operations of theCPU 202 can be distributed across multiple machines (each machine having one or more of processors) that can be coupled directly or across a local area or other network. Thememory 204 can be distributed across multiple machines such as a network-based memory or memory in multiple machines performing the operations of thecomputing device 200. Although depicted here as a single bus, thebus 212 of thecomputing device 200 can be composed of multiple buses. Further, thesecondary storage 214 can be directly coupled to the other components of thecomputing device 200 or can be accessed via a network and can comprise a single integrated unit such as a memory card or multiple units such as multiple memory cards. Thecomputing device 200 can thus be implemented in a wide variety of configurations. -
FIG. 3 is a diagram of an example of avideo stream 300 to be encoded and subsequently decoded. Thevideo stream 300 includes avideo sequence 302. At the next level, thevideo sequence 302 includes a number ofadjacent frames 304. While three frames are depicted as theadjacent frames 304, thevideo sequence 302 can include any number ofadjacent frames 304. Theadjacent frames 304 can then be further subdivided into individual frames, e.g., aframe 306. At the next level, theframe 306 can be divided into a series of planes orsegments 308. The segments (or planes) 308 can be subsets of frames that permit parallel processing, for example. Thesegments 308 can also be subsets of frames that can separate the video data into separate colors. For example, theframe 306 of color video data can include a luminance plane and two chrominance planes. Thesegments 308 may be sampled at different resolutions. - Whether or not the
frame 306 is divided into thesegments 308, theframe 306 may be further subdivided intoblocks 310, which can contain data corresponding to, for example, 16×16 pixels inframe 306. Theblocks 310 can also be arranged to include data from one or more planes of pixel data. Theblocks 310 can also be of any other suitable size such as 4×4 pixels, 8×8 pixels, 16×8 pixels, 8×16 pixels, 16×16 pixels or larger. Unless otherwise noted, the terms block and macroblock are used interchangeably herein. -
FIG. 4 is a block diagram of anencoder 400 in accordance with an implementation. Theencoder 400 can be implemented, as described above, in the transmittingstation 102 such as by providing a computer software program stored in memory, for example, thememory 204. The computer software program can include machine instructions that, when executed by a processor such as theCPU 202, cause the transmittingstation 102 to encode video data in the manner described inFIG. 4 and inFIG. 6 , below. Theencoder 400 can also be implemented as specialized hardware included in, for example, the transmittingstation 102. Theencoder 400 has the following stages to perform the various functions in a forward path (shown by the solid connection lines) to produce an encoded orcompressed bitstream 420 using thevideo stream 300 as input: an intra/inter prediction stage 402, atransform stage 404, aquantization stage 406, and anentropy encoding stage 408. Theencoder 400 may also include a reconstruction path (shown by the dotted connection lines) to reconstruct a frame for encoding of future blocks. InFIG. 4 , theencoder 400 has the following stages to perform the various functions in the reconstruction path: adequantization stage 410, aninverse transform stage 412, areconstruction stage 414, and aloop filtering stage 416. Other structural variations of theencoder 400 can be used to encode thevideo stream 300. - When the
video stream 300 is presented for encoding, eachframe 306 can be processed in units of blocks. At the intra/inter prediction stage 402, each block can be encoded using intra-frame prediction (also called intra-prediction) or inter-frame prediction (also called inter-prediction), or a combination both. In any case, a prediction block can be formed. In the case of intra-prediction, all or a part of a prediction block may be formed from samples in the current frame that have been previously encoded and reconstructed. In the case of inter-prediction, all or part of a prediction block may be formed from samples in one or more previously constructed reference frames determined using motion vectors. - Next, still referring to
FIG. 4 , the prediction block can be subtracted from the current block at the intra/inter prediction stage 402 to produce a residual block (also called a residual). Thetransform stage 404 transforms the residual into transform coefficients in, for example, the frequency domain using block-based transforms. Such block-based transforms include, for example, the Discrete Cosine Transform (DCT) and the Asymmetric Discrete Sine Transform (ADST). Other block-based transforms are possible. Further, combinations of different transforms may be applied to a single residual. In one example of application of a transform, the DCT transforms the residual block into the frequency domain where the transform coefficient values are based on spatial frequency. The lowest frequency (DC) coefficient at the top-left of the matrix and the highest frequency coefficient at the bottom-right of the matrix. It is worth noting that the size of a prediction block, and hence the resulting residual block, may be different from the size of the transform block. For example, the prediction block may be split into smaller blocks to which separate transforms are applied. - The
quantization stage 406 converts the transform coefficients into discrete quantum values, which are referred to as quantized transform coefficients, using a quantizer value or a quantization level. For example, the transform coefficients may be divided by the quantizer value and truncated. The quantized transform coefficients are then entropy encoded by theentropy encoding stage 408. Entropy coding may be performed using any number of techniques, including token and binary trees. The entropy-encoded coefficients, together with other information used to decode the block, which may include for example the type of prediction used, transform type, motion vectors and quantizer value, are then output to thecompressed bitstream 420. The information needed to decode the block may be entropy coded into block, frame, slice and/or section headers within thecompressed bitstream 420. Thecompressed bitstream 420 can also be referred to as an encoded video stream or encoded video bitstream, and the terms will be used interchangeably herein. - The reconstruction path in
FIG. 4 (shown by the dotted connection lines) can be used to ensure that both theencoder 400 and a decoder 500 (described below) use the same reference frames and blocks to decode thecompressed bitstream 420. The reconstruction path performs functions that are similar to functions that take place during the decoding process that are discussed in more detail below, including dequantizing the quantized transform coefficients at thedequantization stage 410 and inverse transforming the dequantized transform coefficients at theinverse transform stage 412 to produce a derivative residual block (also called a derivative residual). At thereconstruction stage 414, the prediction block that was predicted at the intra/inter prediction stage 402 can be added to the derivative residual to create a reconstructed block. Theloop filtering stage 416 can be applied to the reconstructed block to reduce distortion such as blocking artifacts. - Other variations of the
encoder 400 can be used to encode thecompressed bitstream 420. For example, a non-transform basedencoder 400 can quantize the residual signal directly without thetransform stage 404 for certain blocks or frames. In another implementation, anencoder 400 can have thequantization stage 406 and thedequantization stage 410 combined into a single stage. -
FIG. 5 is a block diagram of adecoder 500 in accordance with another implementation. Thedecoder 500 can be implemented in the receivingstation 106, for example, by providing a computer software program stored in thememory 204. The computer software program can include machine instructions that, when executed by a processor such as theCPU 202, cause the receivingstation 106 to decode video data in the manner described inFIG. 5 and inFIG. 8 below. Thedecoder 500 can also be implemented in hardware included in, for example, the transmittingstation 102 or the receivingstation 106. - The
decoder 500, similar to the reconstruction path of theencoder 400 discussed above, includes in one example the following stages to perform various functions to produce anoutput video stream 516 from the compressed bitstream 420: anentropy decoding stage 502, adequantization stage 504, aninverse transform stage 506, an intra/inter-prediction stage 508, areconstruction stage 510, aloop filtering stage 512 and adeblocking filtering stage 514. Other structural variations of thedecoder 500 can be used to decode thecompressed bitstream 420. - When the
compressed bitstream 420 is presented for decoding, the data elements within thecompressed bitstream 420 can be decoded by theentropy decoding stage 502 to produce a set of quantized transform coefficients. Thedequantization stage 504 dequantizes the quantized transform coefficients (e.g., by multiplying the quantized transform coefficients by the quantizer value), and theinverse transform stage 506 inverse transforms the dequantized transform coefficients using the selected transform type to produce a derivative residual that can be identical to that created by theinverse transform stage 412 in theencoder 400. Using header information decoded from thecompressed bitstream 420, thedecoder 500 can use the intra/inter-prediction stage 508 to create the same prediction block as was created in theencoder 400, e.g., at the intra/inter prediction stage 402. At thereconstruction stage 510, the prediction block can be added to the derivative residual to create a reconstructed block. Theloop filtering stage 512 can be applied to the reconstructed block to reduce blocking artifacts. Other filtering can be applied to the reconstructed block. In this example, thedeblocking filtering stage 514 is applied to the reconstructed block to reduce blocking distortion, and the result is output as anoutput video stream 516. Theoutput video stream 516 can also be referred to as a decoded video stream, and the terms will be used interchangeably herein. - Other variations of the
decoder 500 can be used to decode thecompressed bitstream 420. For example, thedecoder 500 can produce theoutput video stream 516 without thedeblocking filtering stage 514. - As mentioned briefly above, a block may be encoded or decoded by motion vector prediction a dynamic reference motion vector coding mode. One implementation of using the dynamic reference motion vector coding mode for encoding and decoding is next discussed.
-
FIG. 6 is a flow diagram showing aprocess 600 for encoding a video stream using reference motion vectors in accordance with an implementation of this disclosure.Process 600 can be implemented in an encoder such asencoder 400 and can be implemented, for example, as a software program that can be executed by computing devices such as transmittingstation 102 or receivingstation 106. For example, the software program can include machine-readable instructions that can be stored in a memory such asmemory CPU 202, to cause the computing device to performprocess 600. - The
process 600 can be implemented using specialized hardware or firmware. Some computing devices can have multiple memories, multiple processors, or both. The steps or operations of theprocess 600 can be distributed using different processors, memories, or both. Use of the terms “processor” or “memory” in the singular encompasses computing devices that have one processor or one memory as well as devices that have multiple processors or multiple memories that can each be used in the performance of some or all of the recited steps. For simplicity of explanation,process 600 is depicted and described as a series of steps or operations. However, the teachings in accordance with this disclosure can occur in various orders and/or concurrently. Additionally, steps in accordance with this disclosure may occur with other steps not presented and described herein. Furthermore, not all illustrated steps or operations may be required to implement a method in accordance with the disclosed subject matter. - The
process 600 assumes that a stream of video data having multiple frames, each having multiple blocks, is being encoded using a video encoder such asencoder 400 executing on a computing device such as transmittingstation 102. The video data or stream can be received by the computing device in any number of ways, such as by receiving the video data over a network, over a cable, or by reading the video data from a primary memory or other storage device, including a disk drive or removable media such as a CompactFlash (CF) card, Secure Digital (SD) card, or any other device capable of communicating video data. In some implementations, video data can be received from a video camera connected to the computing device operating the encoder. At least some of the blocks within frames are encoded using inter prediction as described in more detail below. - At 602, the
process 600 identifies candidate motion vectors from previously coded blocks in the video stream. Theprocess 600 analyzes the motion activity of previously coded blocks to produce a list of ranked candidate motion vectors, employing an efficient reference motion vector ranking system, and provides a dynamic motion referencing mode that fully accounts for the available motion vector candidate list, which allows the number of the reference motion vector modes to be dynamically extended or shortened and improves the efficacy of entropy coding. The pool of the candidate motion vectors can be dynamically extended or shortened according to the neighboring reference block condition, i.e., how the list of candidate motion vectors is created. The previously coded blocks in the video stream can include any block encoded using inter-prediction before the current block, such as a block from a previously coded frame or a block from the same frame as the current block that has been encoded before the current block. For example, in some encoding/decoding (codec) schemes such as ones that code in raster scan order, the previously coded blocks can include a block above, to the left, or to the above-left of the current block in the same frame. The previously coded blocks can also include, for example, a block from the immediately previous frame (i.e., last frame), a block from the golden frame (described at intra/inter prediction stage 402), a block from any other reference frame, or any combination thereof. Desirably, however, the candidate motion vectors are obtained from previously coded blocks that correspond in some way to the current block based on the theory that such blocks, due to the proximity of their pixels to the current block, are likely to have similar motion characteristics to the current block. - Blocks may be predicted from a single reference frame or compound, such as two, reference frames. For blocks with a single reference frame, the
process 600 identifies candidate motion vectors from the nearest spatial neighboring blocks that are associated with the reference frame. The candidate motion vectors may include the motion vector reference blocks within a reference coverage area, such as the motion vector(s) from a boundary area (e.g., a block) above the current block, the motion vector(s) from a boundary area (e.g., a block) to the left of the current block, the motion vector from a top-right corner of the current block, and the motion vector(s) from a collocated block in the previous frame. In certain implementations, motion vectors associated with blocks below and to the right of the collocated block are considered. - This initial step of constructing a reference motion vector candidate list is described with reference to
FIG. 7 . That is,FIG. 7 is a diagram of a sequence of frames used to explain the identification of candidate motion vectors of 602 within theprocess 600 ofFIG. 6 . The current block B being encoded is located within current Frame N. Frame N-1 is the preceding frame, also called a temporally adjacent frame, which may be the reconstructed frame stored in a so-called last reference frame buffer that is available for coding blocks of Frame N. In this case, block R3 is the collocated block to the current block B, and it is located at the same pixel location (usually measured from the top-left pixel) and has the same pixel dimensions in the x- and y- planes (i.e., the same pixel coordinates) within Frame N-1 as the current block B has within Frame N. Stated another way, the block R3 spatially corresponds to the current block B. In a single reference mode, i.e., where the current block B is being inter-predicted using a single reference frame, the motion vector candidate buffer is associated with the reference frame. Given the reference frame index, a search for motion vectors associated with the same reference frame may be performed through the reference blocks shown inFIG. 7 for inclusion in the candidate list. - The blocks B and R3 are of an arbitrary block size. For example, the blocks B and R3 may each be 32z32 pixels. As mentioned above, each frame may be partitioned into blocks for coding. Those blocks may be further partitioned into smaller blocks for coding purposes. For this reason, any block or region adjacent to the current block B may have been partitioned into smaller blocks that are predicted by different motion vectors. Therefore, the search for motion vectors may be take this into consideration by assessing the motion information for the smallest possible prediction block size within a frame. In the example shown, the search for motion vectors in the current frame is done using motion information from a top row boundary region, also called block R0, a left column boundary region, also called block R1, and the top-right corner, also call block R2. The blocks R0 and R1 are regions whose size (dimensions) is related to the size of the current block B. In some cases, the blocks R0 and R1 are of the same size as the current block B, but they may be half the size of the current block B or otherwise relate to the size of the current block B. In any case, each sub-block of pixels, e.g., having the smallest prediction block size within blocks R0 and R1 can be scanned through for candidate motion vectors. For example, the smallest prediction block size may be 8×8 or 4×4. The block R2 is desirably the smallest prediction block size to minimize searching and because more distant blocks are likely to provide less relevant information. The block R2 would only have one motion vector (or two in combined prediction) if the block R2 is the smallest prediction block size. The block R2 may be larger in size in an implementation.
- The search for motion vectors in the last frame is done using motion information from the collocated block R3, and the additional reference blocks R4, R5, R6, and R7 adjacent to the bottom row (blocks R6, R7), the right column (R4), or both (R5). That is, they each proximate to (e.g., in contact with) a corner of the collocated block. As mentioned, the collocated block R3 has the same size as the current block. Each sub-block of the smallest prediction block size within the collocated block R3 may be scanned or searched for candidate motion vectors. In the example shown, the additional reference blocks R4, R5, R6, and R7 respectively have the smallest prediction block size regardless of the size of the current block B, but this is not required.
- Returning now to
FIG. 6 , once the reference motion vectors are obtained at 602 they can be ranked according to the distance from the corresponding reference block and its overlapped length with the current block at 604. Stated another way, theprocess 600 may determine, for each candidate motion vector, a distance between the previously coded block associated with the candidate motion vector and the current block. The motion vectors from the nearest row and column boundaries and the top-right corner to the current block are in contact with the current block and may be considered to be more relevant and so are ranked higher than those further away. The distance may be used to group the motion vectors into categories. For example, and with reference toFIG. 7 , any motion vectors from the sub-blocks of the reference blocks R0 and R1, and a motion vector from the reference block R2, if any, may be considered ascategory 1 candidate motion vectors, while the remaining candidate motion vectors from the blocks R3 through R7 and from any other sub-blocks of the reference blocks R0 and R1 are considered to be category 2 candidate motion vectors. In this case,category 1 candidate motion vectors would assume a higher priority than category 2 candidate motion vectors. The distance may additionally or alternatively include calculating a straight line distance between the centers of the current block and each of the reference blocks and/or sub-blocks of the reference blocks. The distance between the reference block and the current block can be based on the spatial displacement between the pixels in the previously coded block and the collocated pixels in the current block, measured in the unit of pixels. In these latter examples, a collocated block may be ranked higher than reference blocks in a current frame (e.g., because the difference/displacement is zero), even when popularity values are considered. Other ways of grouping and/or ranking the motion vectors based on distance are possible. - When the motion vectors are grouped by category, within each category the motion vectors may be ranked according to the number of pixels within the search areas (e.g., the previously coded pixels of at least some of the reference blocks) that are using each motion vector. For example, the
process 600 may determine a popularity value based on the previously coded pixel values associated with the particular candidate motion vector at 606. The larger the number of previously coded pixel values associated with the candidate motion vector, the higher the popularity value of the candidate motion vector. The popularity value may be a raw number of pixels or a percentage of the total number of pixels within all or some of the reference blocks, for example. - This can be described with reference to the example of
FIG. 7 assuming that the current block B and the collocated block R3, each comprise 32×32 pixels, the reference block R0 and the reference block R1 respectively comprise 32×16 and 16×32 pixels, and the reference blocks R2 and R4-R7 each comprise 8×8 pixels, which also corresponds to the smallest prediction block size. In this case, there could be up to nine motion vector candidates associated with a reference frame and assigned tocategory 1, four each from the 8×8 sub-blocks of reference blocks R0 and R1 adjacent to the current block B and one from the 8×8 reference block R2. There could be up to twenty-eight motion vectors associated with the reference frame and assigned to category 2, four each from the remaining 8×8 sub-blocks of the reference blocks R0 and R1, sixteen from the collocate block R3, and one each from the additional four 8×8 reference blocks R4-R7. In actuality, motion vectors are often re-used. Each of the unique motion vectors within a category from all of those identified is attributed with a popularity value corresponding to each of the groups of 8×8 pixels (that is, 64 pixels) using that motion vector. In assessing whether a motion vector that is identified at 602 is unique, the motion vector does not have to be identical to another. Ranges can be used so as to provide a motion vector candidate list demonstrating sufficient variation to useful. That is, a motion vector may be omitted within a category if it does not vary enough from a motion vector candidate already in a category, such as by 10% or some other variable. In this implementation, motion vectors are ranked by category and then ranked within the categories, but this is not required. The motion vector candidates may be grouped together for ranking based on the popularity value. - The reference motion vector candidate list may be constructed as described for each unique reference frame associated with a previously coded block or sub-block. For example, three reference frames may be available for each frame as described above—a last frame, an alternative (or alternate or alt) reference frame, and a golden reference frame. In this case, separate reference motion vector candidate list may be constructed using those previously coded blocks or sub-blocks having motion vectors pointing each of the last frame, the alt reference frame, and the golden reference frame. The last frame is updated for each frame, and the alt reference frame and golden reference frame may be updated less frequently.
- In some implementations, motion vector scaling is performed when constructing a reference motion vector candidate list. Motion vector scaling may be done as part of the determination of a popularity value at 606, or may be done at other points in the
process 600. Motion vector scaling adjusts the magnitude of a motion vector to account for the temporal differences between reference frames relative to the frame under consideration within the sequence of frames within the video stream. For example, and again with reference toFIG. 7 , the reference block R2 uses the last frame, which is Frame N-1, for inter-prediction, while the reference block R4 uses the last frame, which is the frame preceding Frame N-1 (or Frame N-2, not shown), for inter-prediction. The temporal difference between the frame in which each block R2 and R4 is located (Frame N and Frame N-1, respectively) and the corresponding reference frame (Frame N-1 and Frame N-2, respectively) is one frame, so no scaling is indicated. In contrast, if the reference blocks R2 and R4 both use the golden reference frame, the temporal differences between Frame N and the golden reference frame and the between the Frame N-1 and the golden reference frame are different if the golden reference frame is unchanged. A candidate motion vector can be generated by scaling up the magnitude of the motion vector associated with the shorter temporal difference or scaling down the magnitude of the motion vector associated with the longer temporal differences so that the motion vectors share a common basis. The factor used for scaling can be based on a ratio formed by the temporal differences. - Motion vector scaling may also be used in implementations where only one reference motion vector candidate list is prepared for all reference frames, instead of separate lists for each reference frame. Reference frames may be located either before or after the current frame in the video sequence. In some implementations, motion vector scaling is omitted.
- Thus far, candidate list construction for a single reference mode where one reference frame (and thus typically one motion vector associated with the one reference frame) is used for inter-prediction. In some cases, however, a block may be predicted from two or more reference frames, where the pixel values are combinations of the pixels values from prediction blocks within each frame generated by respective motion vectors. When considering a compound reference mode for prediction of the current block, the list is constructed by first looking for neighboring blocks that share the same compound reference frames (i.e., the same combination of reference frames) for their reference motion vectors. A higher priority is assigned to candidate motion vectors from neighboring reference blocks that share the combination of reference frames as that under consideration for the current block. The motion vectors may also be ranked from highest to lowest popularity value. If the resulting candidate list has a length shorter than a defined number, such as two, the list may be appended with combinations of reference motion vectors of single reference frames that are identified and ranked as described above. For example, if a compound reference mode that uses the last frame and the alt reference frame is under consideration, the reference blocks are searched for motion vectors referencing either the last frame or the alt reference frame, which are then ranked based on a popularity value as discussed.
- Referring again to
FIG. 6 , and as explained above, the determination of the popularity values at 608 includes ranking the motion vectors using the popularity values. It can also include assigning the motion vectors to inter-coding (or inter-prediction) modes based on the ranking. The most popular motion vector may be selected for an inter-prediction mode that includes differential coding of a new motion vector. This may be referred to as a NEWMV mode. Then, according to the ranking results, the remaining motion vectors may be assigned to other reference vector motion modes. In some implementations, a REFMV mode is a dynamic reference motion vector coding mode that includes at least two modes where an existing motion vector is re-used. In an example, these two inter-prediction modes are a NEARESTMV mode and a NEARMV mode. The next motion vector in the ranking after the one assigned to the NEWMV mode (i.e., the motion vector with the second highest popularity value) is assigned to the NEARESTMV mode, and the next motion vector after that (i.e., the motion vector with the third highest popularity value) is assigned to the NEARMV mode. If the candidate reference motion vector list for a particular reference frame is longer than two, the number of reference motion vector modes may be extended to accommodate the remaining entries in the list. Another available inter-prediction mode may be a ZEROMV mode, which means that no motion exists. - At 608, an inter-prediction mode is selected for the current block. This may include testing each of the inter-prediction modes and selecting the inter-prediction mode that results in the most efficient coding of the current block. For example, the
process 600 may be part of a rate-distortion loop used to select the inter-prediction mode for the current block to be encoded. As part of the rate-distortion loop, an actual motion vector for inter prediction of the current block may be determined through a motion search according to any number of motion searching techniques. For each reference frame, one use of the reference motion vector may include using the reference motion vector assigned to the NEWMV mode or one of the other identified candidate motion vectors as a starting parameter for the motion search algorithm based on the reasoning that the actual motion vector is likely to be close to highly ranked motion vectors for the reference frame. Combinations of reference frames in a compound prediction mode may be similarly searched using motion vectors from the candidate list, particularly those having the highest rank for each of the reference frames. - Motion searches may alternatively be performed without using motion vectors from the candidate lists. Whether or not a reference motion vector is used in the motion search, various inter-prediction modes may be tested. In one implementation, an exhaustive motion search that attempts each of the available inter-prediction modes using single or compound modes (i.e., using each of the three reference frames and combinations of reference frames). For each proposed motion vector and for each tested inter-prediction mode, a bit cost (also called a rate) of encoding the current block using the inter-prediction mode, including the bits required to signal the inter-prediction mode, the reference frame(s), the residual block generated from the current block, and, if required, one or more motion vector(s) or motion vector differential(s), and the resulting error in the pixel values between the original values and the reconstructed values (also called a distortion) are calculated. The inter-prediction mode and reference frame(s) resulting in the lowest rate-distortion value (also called a ratio) may be selected as the inter-prediction mode for the current block at 608.
- An exhaustive search does not need to be performed. Various techniques may be used to reduce the computational burden. For example, the inter-prediction modes used for adjacent blocks in the frames may be tested first, and then only certain inter-prediction modes may be tested to see if an improved rate-distortion ratio results. Further, motion searching is applicable to inter-prediction. The rate-distortion loop may include tests for various intra-prediction modes, or a separate rate-distortion loop may be used to select the most efficient intra-prediction mode from available intra-prediction modes. Then, the most efficient inter-prediction mode and the most efficient intra-prediction mode are compared to select the prediction mode for the block.
- Assuming here that the inter-prediction mode selected at 608 is better than the available intra-prediction modes, the current block is encoded at 610 using the inter-prediction mode. For example, if the NEWMV mode is used to encode the current block, the predicted block is generated using the actual motion vector(s) from the motion search and the selected reference frame(s). Then, the residual between the current block and the predicted block is generated and encoded as described with reference to
FIG. 4 . The motion vector(s) assigned to the NEWMV mode by the ranking can be used to differentially encode the actual motion vector(s). For example, a difference value or residual can be calculated by subtracting a reference motion vector from a motion vector used to encode the current block. The difference value can be encoded and included in the video stream. In addition, bits indicating the reference frame(s) and that the NEWMV mode was used may be indicated in the block header and/or in a frame or slice header. - In another example with a single reference frame, the motion search results in a motion vector equal to or within a range of values about one of the reference motion vectors assigned to reference motion vector modes. In this case the REFMV inter-prediction mode is indicated. If the motion vector resulting from the search is equal to or within a range of values about the reference motion vector assigned to the NEARMV mode in this example, the predicted block is generated using the reference motion vector assigned to the NEARMV mode and the selected reference frame. Then, the residual between the current block and the predicted block is generated and encoded as described with reference to
FIG. 4 . In addition, bits indicating the reference frame and that the REFMV mode and particularly the NEARMV mode was used may be indicated in the block header and/or in a frame or slice header. - The remaining inter-prediction modes may similarly be used to encode the current block, if selected at 608, or to encode other blocks of the frames within a video sequence. The
process 600 ofFIG. 6 may be repeated as needed. - As mentioned with respect to operation of the
encoder 400 ofFIG. 4 , encoding the current block may include entropy coding. Entropy coding the inter-prediction modes may be modified to take into account the new dynamic reference motion vector modes. Assuming three inter-prediction modes corresponding to a new motion vector, a zero motion vector, and a dynamic reference motion vector mode, respectively the NEWMV mode, the ZEROMV mode, and REFMV mode in this example, entropy coding starts with the NEWMV mode. That is, assuming the current block is encoded using the NEWMV mode, the probability model may be selected according to two contexts: 1) how many reference motion vectors are found; and 2) if neighboring block(s) with a matched reference frame is found, how likely they are to be coded in the NEWMV mode. - If the next coding mode is not the NEWMV mode, coding continues if the next coding mode is the ZEROMV mode. In this case, the probability model may be selected according to two contexts: 1) if the collocated block in the last (or previous) frame using a zero motion vector, or close to a zero motion vector (i.e., less than one full pixel in both row and column components); and 2) whether (and possibly how many of) the spatial neighboring blocks within the current frame are using zero motion vectors, or close to zero motion vectors.
- If instead the next coding mode is not the ZEROMV mode (i.e., is the dynamic reference motion vector mode indicated by the REFMV mode), a decision is made between the reference motion vectors as discussed above. The associated context is how many reference motion vectors are checked into the candidate list and, when applicable, their weighting coefficients used in compound prediction.
-
FIG. 8 is a flowchart diagram of aprocess 800 for decoding an encoded video stream using reference motion vectors in accordance with implementations of this disclosure. Theprocess 800 can be implemented, for example, as a software program that may be executed by computing devices such as transmittingstation 102 or receivingstation 106. For example, the software program can include machine-readable instructions that may be stored in a memory such asmemory CPU 202, may cause the computing device to perform theprocess 800. Theprocess 800 can be implemented using specialized hardware or firmware. As explained above, some computing devices may have multiple memories or processors, and the operations described in theprocess 800 can be distributed using multiple processors, memories, or both. - For simplicity of explanation, the
process 800 is depicted and described as a series of steps or operations. However, the steps or operations in accordance with this disclosure can occur in various orders and/or concurrently. Additionally, other steps or operations not presented and described herein may be used. Furthermore, not all illustrated steps or operations may be required to implement a method in accordance with the disclosed subject matter. - At 802, the decoder determines whether the current block was encoded using single or compound prediction. This information can be communicated by reading and decoding bits from an encoded video bitstream that indicate the one or more than one motion vectors was used to encode the current block. The encoded bitstream (or encoded video data) may be received by a decoder of a computing device in any number of ways, such as by receiving the video data over a network, over a cable, or by reading the video data from a primary memory or other storage device, including a disk drive or removable media such as a DVD, CompactFlash (CF) card, Secure Digital (SD) card, or any other device capable of communicating a video stream. This information can be included in a header associated with a current block or a frame header, for example. This explanation assumes that the current block is inter-predicted. Otherwise, no reference frame is encoded into the bitstream in association with the current block, and the current block was intra-predicted.
- Knowing the reference frame(s), the candidate motion vectors can be ranked in a similar manner as described with reference to the
process 600 ofFIG. 6 . That is, the encoder and decoder can share rules regarding the generation of reference motion vector candidate lists so that the decoder, receiving header information related to which inter-prediction mode was used to encode the current block (e.g., NEWMV, NEARESTMV, NEARMV, etc.), is able to identify the same reference motion vector(s) used by the encoder. First, the candidate motion vectors can be identified from previously coded blocks at 804 in a like manner as they are identified at 602 in theprocess 600. While theprocess 600 may identify the candidate motion vectors for ranking using all available reference frames and combinations of reference frames in order to select the inter-prediction mode, theprocess 800 only needs to rank those candidate motion vectors for the reference frame(s) actually to encode the block. - After the candidate motion vectors are identified at 804, they are ranked at 806 and 808. More specifically, ranking the candidate motion vectors includes determining, for each candidate motion vector, the distance between the previously coded block that is the source of the motion vector and the current block at 806. This involves the same operations as those described above with respect to the determination at 604 in the
process 600. The result of this operation is a list of candidate motion vectors grouped by the distance in an embodiment. Then, determining a respective popularity value for the candidate motion vectors from previously coded blocks at 804 is performed the same as the determination at 606 in theprocess 600. The result of this operation is a ranked list of candidate motion vectors for the single reference frame or the combined reference frames used in the prediction of the current block. In one implementation, the highest ranked (e.g., most probable) motion vector is assigned to a NEWMV mode, and the next two motion vectors in the ranking are assigned respectively to the NEARESTMV and NEARMV reference motion vector modes of the dynamic reference motion vector (REFMV) mode. Any further reference motion vectors are assigned in sequence thereafter. - At 810, the inter-prediction mode that was used to encode the current block is identified. In one implementation, the inter-prediction mode is identified by decoding bits included within the bitstream that identify the inter-prediction mode. For example, the inter-prediction mode may be the new motion vector mode, the zero motion vector mode, or the dynamic reference motion vector mode. If the inter-prediction mode is the dynamic reference motion vector mode, the particular reference motion vector mode used can be similarly determined, e.g., from bits included within header(s) in the bitstream.
- At 812, the inter-prediction mode identified at 810 is used to decode the current block at 812, such as through the decoding process described with reference to
FIG. 5 . When the inter-prediction mode involves a differentially-encoded motion vector, for example, the reference motion vector can be used to decode the motion vector used to predict the current block. Alternatively, the inter-prediction mode may indicate the motion vector by reference to the list. Regardless of the source of the one or more motion vectors, the prediction block is generated using the motion vector(s) and is added to the residual for the current block decoded from the bitstream. - The
process 800 may be repeated for each block that is encoded using inter-prediction to generate a reconstructed block. The frame is reconstructed using the reconstructed blocks and those reconstructed using intra-prediction. By decoding a plurality of frames, an output video stream, such as theoutput video stream 516 shown inFIG. 5 , can be reconstructed. - Use of the syntax within the bitstream for the REFMV mode suggests that the effective motion vector comes from referencing neighboring blocks' coding information. Given the reference frame, a list of such possible reference motion vector candidates are ranked according to their relative distance to the current block and their relative use. This technique generalizes the REFMV modes (NEARESTMV and NEARMV, for example) and improves the efficiency of entropy coding. Further, the additional motion vector candidates can result in further compression gains.
- The aspects of encoding and decoding described above illustrate some encoding and decoding techniques. However, it is to be understood that encoding and decoding, as those terms are used in the claims, could mean compression, decompression, transformation, or any other processing or change of data.
- The word “example,” “aspect,” or “implementation” is used herein to mean serving as an example, instance, or illustration. Any aspect or design described herein as using one or more of these words is not necessarily to be construed as preferred or advantageous over other aspects or designs. Rather, use of the word “example,” “aspect,” or “implementation” is intended to present concepts in a concrete fashion. As used in this application, the term “or” is intended to mean an inclusive “or” rather than an exclusive “or”. That is, unless specified otherwise, or clear from context, “X includes A or B” is intended to mean any of the natural inclusive permutations. That is, if X includes A; X includes B; or X includes both A and B, then “X includes A or B” is satisfied under any of the foregoing instances. In addition, the articles “a” and “an” as used in this application and the appended claims should generally be construed to mean “one or more” unless specified otherwise or clear from context to be directed to a singular form. Moreover, use of the term “an implementation” or “one implementation” throughout is not intended to mean the same embodiment, aspect or implementation unless described as such.
- Implementations of transmitting
station 102 and/or receiving station 106 (and the algorithms, methods, instructions, etc., stored thereon and/or executed thereby, including byencoder 400 and decoder 500) can be realized in hardware, software, or any combination thereof. The hardware can include, for example, computers, intellectual property (IP) cores, application-specific integrated circuits (ASICs), programmable logic arrays, optical processors, programmable logic controllers, microcode, microcontrollers, servers, microprocessors, digital signal processors or any other suitable circuit. In the claims, the term “processor” should be understood as encompassing any of the foregoing hardware, either singly or in combination. The terms “signal” and “data” are used interchangeably. Further, portions of transmittingstation 102 and receivingstation 106 do not necessarily have to be implemented in the same manner. - Further, in one aspect, for example, transmitting
station 102 or receivingstation 106 can be implemented using a general purpose computer or general purpose processor with a computer program that, when executed, carries out any of the respective methods, algorithms and/or instructions described herein. In addition or alternatively, for example, a special purpose computer/processor can be utilized which can contain other hardware for carrying out any of the methods, algorithms, or instructions described herein. - Transmitting
station 102 and receivingstation 106 can, for example, be implemented on computers in a video conferencing system. Alternatively, transmittingstation 102 can be implemented on a server and receivingstation 106 can be implemented on a device separate from the server, such as a hand-held communications device. In this instance, transmittingstation 102 can encode content using anencoder 400 into an encoded video signal and transmit the encoded video signal to the communications device. In turn, the communications device can then decode the encoded video signal using adecoder 500. Alternatively, the communications device can decode content stored locally on the communications device, for example, content that was not transmitted by transmittingstation 102. Other transmittingstation 102 and receivingstation 106 implementation schemes are available. For example, receivingstation 106 can be a generally stationary personal computer rather than a portable communications device and/or a device including anencoder 400 may also include adecoder 500. - Further, all or a portion of implementations of the present disclosure can take the form of a computer program product accessible from, for example, a tangible computer-usable or computer-readable medium. A computer-usable or computer-readable medium can be any device that can, for example, tangibly contain, store, communicate, or transport the program for use by or in connection with any processor. The medium can be, for example, an electronic, magnetic, optical, electromagnetic, or a semiconductor device. Other suitable mediums are also available.
- The above-described embodiments, implementations and aspects have been described in order to allow easy understanding of the present disclosure and do not limit the present disclosure. On the contrary, the disclosure is intended to cover various modifications and equivalent arrangements included within the scope of the appended claims, which scope is to be accorded the broadest interpretation so as to encompass all such modifications and equivalent structure as is permitted under the law.
Claims (20)
Priority Applications (6)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US15/373,518 US10462457B2 (en) | 2016-01-29 | 2016-12-09 | Dynamic reference motion vector coding mode |
GB1621809.1A GB2547754B (en) | 2016-01-29 | 2016-12-21 | Dynamic reference motion vector coding mode |
DE202016008160.9U DE202016008160U1 (en) | 2016-01-29 | 2016-12-23 | Dynamic coding mode for reference motion vectors |
PCT/US2016/068472 WO2017131908A1 (en) | 2016-01-29 | 2016-12-23 | Dynamic reference motion vector coding mode |
DE102016125593.9A DE102016125593B4 (en) | 2016-01-29 | 2016-12-23 | Dynamic reference motion vector encoding mode |
CN201611226103.5A CN107027038B (en) | 2016-01-29 | 2016-12-27 | Dynamic reference motion vector coding mode |
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201662288553P | 2016-01-29 | 2016-01-29 | |
US201662330491P | 2016-05-02 | 2016-05-02 | |
US15/373,518 US10462457B2 (en) | 2016-01-29 | 2016-12-09 | Dynamic reference motion vector coding mode |
Publications (2)
Publication Number | Publication Date |
---|---|
US20170223350A1 true US20170223350A1 (en) | 2017-08-03 |
US10462457B2 US10462457B2 (en) | 2019-10-29 |
Family
ID=59387248
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US15/373,518 Active 2037-05-12 US10462457B2 (en) | 2016-01-29 | 2016-12-09 | Dynamic reference motion vector coding mode |
Country Status (1)
Country | Link |
---|---|
US (1) | US10462457B2 (en) |
Cited By (14)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20180070100A1 (en) * | 2016-09-06 | 2018-03-08 | Qualcomm Incorporated | Geometry-based priority for the construction of candidate lists |
CN109587479A (en) * | 2017-09-29 | 2019-04-05 | 华为技术有限公司 | Inter-frame prediction method, device and the codec of video image |
US10448013B2 (en) * | 2016-12-22 | 2019-10-15 | Google Llc | Multi-layer-multi-reference prediction using adaptive temporal filtering |
WO2020098677A1 (en) * | 2018-11-13 | 2020-05-22 | Beijing Bytedance Network Technology Co., Ltd. | History based motion candidate list construction for intra block copy |
CN112004096A (en) * | 2020-07-20 | 2020-11-27 | 浙江大华技术股份有限公司 | Angle mode inter-frame prediction method, encoder and storage medium |
CN112369028A (en) * | 2018-07-06 | 2021-02-12 | 三菱电机株式会社 | Bi-prediction with adaptive weights |
CN112565753A (en) * | 2020-12-06 | 2021-03-26 | 浙江大华技术股份有限公司 | Method and apparatus for determining motion vector difference, storage medium, and electronic apparatus |
JP2021513304A (en) * | 2018-02-06 | 2021-05-20 | テンセント・アメリカ・エルエルシー | Methods and equipment for video coding / decoding in merge mode |
CN113170108A (en) * | 2018-11-27 | 2021-07-23 | Op方案有限责任公司 | Adaptive block update for unavailable reference frames using explicit and implicit signaling |
US11197018B2 (en) * | 2017-06-30 | 2021-12-07 | Huawei Technologies Co., Ltd. | Inter-frame prediction method and apparatus |
US11558633B2 (en) * | 2017-11-01 | 2023-01-17 | Vid Scale, Inc. | Sub-block motion derivation and decoder-side motion vector refinement for merge mode |
US20230156182A1 (en) * | 2021-11-17 | 2023-05-18 | Tencent America LLC | Joint signaling method for motion vector difference |
WO2023091253A1 (en) * | 2021-11-18 | 2023-05-25 | Tencent America LLC | Mvd scaling for joint mvd coding |
WO2023239992A1 (en) * | 2022-06-07 | 2023-12-14 | Tencent America LLC | Systems and methods for motion vector predictor list improvements |
Families Citing this family (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US10798402B2 (en) * | 2017-10-24 | 2020-10-06 | Google Llc | Same frame motion estimation and compensation |
Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5329309A (en) * | 1990-11-15 | 1994-07-12 | Sony United Kingdom Limited | Method of integrating format material and an interlace scan format signal |
US5600377A (en) * | 1992-11-10 | 1997-02-04 | Sony Corporation | Apparatus and method for motion compensating video signals to produce interpolated video signals |
US20130208795A1 (en) * | 2012-02-09 | 2013-08-15 | Google Inc. | Encoding motion vectors for video compression |
US20140133570A1 (en) * | 2011-06-27 | 2014-05-15 | Samsung Electronics Co., Ltd. | Method and apparatus for encoding motion information, and method and apparatus for decoding same |
Family Cites Families (45)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
DE4030703A1 (en) | 1990-09-28 | 1992-04-02 | Bosch Gmbh Robert | METHOD FOR ESTIMATING MOTION IN A TAKEN IMAGE |
US5384865A (en) | 1992-06-01 | 1995-01-24 | Eastman Kodak Company | Adaptive, hybrid median filter for temporal noise suppression |
KR100268311B1 (en) | 1993-06-04 | 2000-10-16 | 윌리암 제이. 버크 | System and method for electronic image stabilization |
FI94306C (en) | 1993-07-15 | 1995-08-10 | Nokia Technology Gmbh | Method for determining motion vectors of small TV image segments |
GB2307133A (en) | 1995-11-13 | 1997-05-14 | Secr Defence | Video camera image stabilisation system |
GB2308262B (en) | 1995-12-16 | 1999-08-04 | Paul Gordon Wilkins | Method for analysing the content of a video signal |
US5801778A (en) | 1996-05-23 | 1998-09-01 | C-Cube Microsystems, Inc. | Video encoding with multi-stage projection motion estimation |
IT1296807B1 (en) | 1997-03-14 | 1999-08-02 | Alsthom Cge Alcatel | METHOD FOR ESTIMATING THE MOVEMENT IN SEQUENCES OF BLOCK-CODED IMAGES IN PARTICULAR FOR THE PROCESSING OF THE VIDEO SIGNAL |
US6741655B1 (en) | 1997-05-05 | 2004-05-25 | The Trustees Of Columbia University In The City Of New York | Algorithms and system for object-oriented content-based video search |
JP2001507552A (en) | 1997-10-29 | 2001-06-05 | コーニンクレッカ フィリップス エレクトロニクス エヌ ヴィ | Motion vector prediction and detection of hidden / exposed image parts |
US6072904A (en) | 1997-12-31 | 2000-06-06 | Philips Electronics North America Corp. | Fast image retrieval using multi-scale edge representation of images |
JP3540142B2 (en) | 1998-01-30 | 2004-07-07 | 株式会社東芝 | Motion vector detection circuit and motion vector detection method |
WO2000011863A1 (en) | 1998-08-21 | 2000-03-02 | Koninklijke Philips Electronics N.V. | Problem area location in an image signal |
US6466624B1 (en) | 1998-10-28 | 2002-10-15 | Pixonics, Llc | Video decoder with bit stream based enhancements |
US6891566B2 (en) | 2000-03-14 | 2005-05-10 | Joseph Robert Marchese | Digital video system using networked cameras |
GB2365244A (en) | 2000-07-27 | 2002-02-13 | Snell & Wilcox Ltd | Image stabilisation |
JP3659157B2 (en) | 2000-10-17 | 2005-06-15 | 日本電気株式会社 | Image compression method for weighting video content |
US20030012281A1 (en) | 2001-07-09 | 2003-01-16 | Samsung Electronics Co., Ltd. | Motion estimation apparatus and method for scanning an reference macroblock window in a search area |
US7027654B1 (en) | 2001-08-16 | 2006-04-11 | On2 Technologies | Video compression system |
EP1294194B8 (en) | 2001-09-10 | 2010-08-04 | Texas Instruments Incorporated | Apparatus and method for motion vector estimation |
US7050502B2 (en) | 2001-09-18 | 2006-05-23 | Matsushita Electric Industrial Co., Ltd. | Method and apparatus for motion vector detection and medium storing method program directed to the same |
US7085401B2 (en) | 2001-10-31 | 2006-08-01 | Infowrap Systems Ltd. | Automatic object extraction |
GB0229096D0 (en) | 2002-12-13 | 2003-01-15 | Qinetiq Ltd | Image stabilisation system and method |
WO2004082294A1 (en) | 2003-03-14 | 2004-09-23 | Koninklijke Philips Electronics N.V. | Method for motion vector determination |
US7324596B2 (en) | 2003-07-15 | 2008-01-29 | Lsi Logic Corporation | Low complexity block size decision for variable block size motion estimation |
US20050013498A1 (en) | 2003-07-18 | 2005-01-20 | Microsoft Corporation | Coding of motion vector information |
JP4198608B2 (en) | 2004-01-15 | 2008-12-17 | 株式会社東芝 | Interpolated image generation method and apparatus |
US8111752B2 (en) | 2004-06-27 | 2012-02-07 | Apple Inc. | Encoding mode pruning during video encoding |
US7953152B1 (en) | 2004-06-28 | 2011-05-31 | Google Inc. | Video compression and encoding method |
AR049593A1 (en) | 2004-07-20 | 2006-08-16 | Qualcomm Inc | METHOD AND APPARATUS FOR PREDICTING THE MOTION VECTOR IN TEMPORARY VIDEO COMPRESSION. |
US20060062481A1 (en) | 2004-09-21 | 2006-03-23 | Markus Suvanto | Apparatuses, computer program product and method for bit rate control of digital image encoder |
GB0423578D0 (en) | 2004-10-22 | 2004-11-24 | Greenparrotpictures Ltd | Dominant motion estimation for image sequence processing |
GB0500174D0 (en) | 2005-01-06 | 2005-02-16 | Kokaram Anil | Method for estimating motion and occlusion |
JP4266939B2 (en) | 2005-02-10 | 2009-05-27 | 株式会社ソニー・コンピュータエンタテインメント | Drawing processing apparatus and drawing data compression method |
US7680355B2 (en) | 2005-05-02 | 2010-03-16 | Intel Corporation | Detection of artifacts resulting from image signal decompression |
US20080002772A1 (en) | 2006-06-28 | 2008-01-03 | Hong Kong Applied Science and Technology Research Institute Company Limited | Motion vector estimation method |
US7809212B2 (en) | 2006-12-20 | 2010-10-05 | Hantro Products Oy | Digital mosaic image construction |
US8127233B2 (en) | 2007-09-24 | 2012-02-28 | Microsoft Corporation | Remote user interface updates using difference and motion encoding |
US8761261B1 (en) | 2008-07-29 | 2014-06-24 | Marvell International Ltd. | Encoding using motion vectors |
JP4564564B2 (en) | 2008-12-22 | 2010-10-20 | 株式会社東芝 | Moving picture reproducing apparatus, moving picture reproducing method, and moving picture reproducing program |
WO2011095259A1 (en) | 2010-02-05 | 2011-08-11 | Telefonaktiebolaget L M Ericsson (Publ) | Selecting predicted motion vector candidates |
EP2375744A1 (en) | 2010-04-12 | 2011-10-12 | Panasonic Corporation | Complexity reduction for 1/8-pel interpolation |
US9510009B2 (en) | 2010-05-20 | 2016-11-29 | Thomson Licensing | Methods and apparatus for adaptive motion vector candidate ordering for video encoding and decoding |
US8611415B1 (en) | 2010-11-15 | 2013-12-17 | Google Inc. | System and method for coding using improved motion estimation |
US10554965B2 (en) | 2014-08-18 | 2020-02-04 | Google Llc | Motion-compensated partitioning |
-
2016
- 2016-12-09 US US15/373,518 patent/US10462457B2/en active Active
Patent Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5329309A (en) * | 1990-11-15 | 1994-07-12 | Sony United Kingdom Limited | Method of integrating format material and an interlace scan format signal |
US5600377A (en) * | 1992-11-10 | 1997-02-04 | Sony Corporation | Apparatus and method for motion compensating video signals to produce interpolated video signals |
US20140133570A1 (en) * | 2011-06-27 | 2014-05-15 | Samsung Electronics Co., Ltd. | Method and apparatus for encoding motion information, and method and apparatus for decoding same |
US20130208795A1 (en) * | 2012-02-09 | 2013-08-15 | Google Inc. | Encoding motion vectors for video compression |
Cited By (20)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20180070100A1 (en) * | 2016-09-06 | 2018-03-08 | Qualcomm Incorporated | Geometry-based priority for the construction of candidate lists |
US10721489B2 (en) * | 2016-09-06 | 2020-07-21 | Qualcomm Incorporated | Geometry-based priority for the construction of candidate lists |
US10448013B2 (en) * | 2016-12-22 | 2019-10-15 | Google Llc | Multi-layer-multi-reference prediction using adaptive temporal filtering |
US11197018B2 (en) * | 2017-06-30 | 2021-12-07 | Huawei Technologies Co., Ltd. | Inter-frame prediction method and apparatus |
CN109587479A (en) * | 2017-09-29 | 2019-04-05 | 华为技术有限公司 | Inter-frame prediction method, device and the codec of video image |
US11558633B2 (en) * | 2017-11-01 | 2023-01-17 | Vid Scale, Inc. | Sub-block motion derivation and decoder-side motion vector refinement for merge mode |
JP2021513304A (en) * | 2018-02-06 | 2021-05-20 | テンセント・アメリカ・エルエルシー | Methods and equipment for video coding / decoding in merge mode |
JP7101818B2 (en) | 2018-02-06 | 2022-07-15 | テンセント・アメリカ・エルエルシー | Methods and equipment for video coding / decoding in merge mode |
CN112369028A (en) * | 2018-07-06 | 2021-02-12 | 三菱电机株式会社 | Bi-prediction with adaptive weights |
US11563972B2 (en) * | 2018-11-13 | 2023-01-24 | Beijing Bytedance Network Technology Co., Ltd. | Construction method for a spatial motion candidate list |
US11128882B2 (en) | 2018-11-13 | 2021-09-21 | Beijing Bytedance Network Technology Co., Ltd. | History based motion candidate list construction for intra block copy |
WO2020098694A1 (en) * | 2018-11-13 | 2020-05-22 | Beijing Bytedance Network Technology Co., Ltd. | Construction method for a spatial motion candidate list |
WO2020098677A1 (en) * | 2018-11-13 | 2020-05-22 | Beijing Bytedance Network Technology Co., Ltd. | History based motion candidate list construction for intra block copy |
CN113170108A (en) * | 2018-11-27 | 2021-07-23 | Op方案有限责任公司 | Adaptive block update for unavailable reference frames using explicit and implicit signaling |
CN112004096A (en) * | 2020-07-20 | 2020-11-27 | 浙江大华技术股份有限公司 | Angle mode inter-frame prediction method, encoder and storage medium |
CN112565753A (en) * | 2020-12-06 | 2021-03-26 | 浙江大华技术股份有限公司 | Method and apparatus for determining motion vector difference, storage medium, and electronic apparatus |
US20230156182A1 (en) * | 2021-11-17 | 2023-05-18 | Tencent America LLC | Joint signaling method for motion vector difference |
US11800092B2 (en) * | 2021-11-17 | 2023-10-24 | Tencent America LLC | Joint signaling method for motion vector difference |
WO2023091253A1 (en) * | 2021-11-18 | 2023-05-25 | Tencent America LLC | Mvd scaling for joint mvd coding |
WO2023239992A1 (en) * | 2022-06-07 | 2023-12-14 | Tencent America LLC | Systems and methods for motion vector predictor list improvements |
Also Published As
Publication number | Publication date |
---|---|
US10462457B2 (en) | 2019-10-29 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US10462457B2 (en) | Dynamic reference motion vector coding mode | |
US10142652B2 (en) | Entropy coding motion vector residuals obtained using reference motion vectors | |
CN107027038B (en) | Dynamic reference motion vector coding mode | |
US10555000B2 (en) | Multi-level compound prediction | |
US10484707B1 (en) | Dynamic reference motion vector coding mode | |
AU2016398050B2 (en) | Motion vector reference selection through reference frame buffer tracking | |
US10116957B2 (en) | Dual filter type for motion compensated prediction in video coding | |
US10506240B2 (en) | Smart reordering in recursive block partitioning for advanced intra prediction in video coding | |
US10582212B2 (en) | Warped reference motion vectors for video compression | |
US10951894B2 (en) | Transform block-level scan order selection for video coding | |
US10419777B2 (en) | Non-causal overlapped block prediction in variable block size video coding | |
WO2019036080A1 (en) | Constrained motion field estimation for inter prediction | |
US10462482B2 (en) | Multi-reference compound prediction of a block using a mask mode | |
US20180184086A1 (en) | Multi-layer-multi-reference prediction using adaptive temporal filtering | |
GB2547754A (en) | Dynamic reference motion vector coding mode | |
WO2023287418A1 (en) | Reference motion vector candidate bank |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:XU, YAOWU;HAN, JINGNING;REEL/FRAME:040607/0977Effective date: 20161208 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044129/0001Effective date: 20170929 |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: FINAL REJECTION MAILED |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: RESPONSE AFTER FINAL ACTION FORWARDED TO EXAMINER |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: DOCKETED NEW CASE - READY FOR EXAMINATION |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: NOTICE OF ALLOWANCE MAILED -- APPLICATION RECEIVED IN OFFICE OF PUBLICATIONS |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: PUBLICATIONS -- ISSUE FEE PAYMENT VERIFIED |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 4TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1551); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 4 |