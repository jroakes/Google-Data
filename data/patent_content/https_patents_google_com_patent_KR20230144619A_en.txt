KR20230144619A - Secure serial peripheral interface communication - Google Patents
Secure serial peripheral interface communication Download PDFInfo
- Publication number
- KR20230144619A KR20230144619A KR1020237031002A KR20237031002A KR20230144619A KR 20230144619 A KR20230144619 A KR 20230144619A KR 1020237031002 A KR1020237031002 A KR 1020237031002A KR 20237031002 A KR20237031002 A KR 20237031002A KR 20230144619 A KR20230144619 A KR 20230144619A
- Authority
- KR
- South Korea
- Prior art keywords
- spi
- command
- host
- secure
- interconnect
- Prior art date
Links
- 238000004891 communication Methods 0.000 title claims abstract description 182
- 230000002093 peripheral effect Effects 0.000 title claims abstract description 102
- 230000015654 memory Effects 0.000 claims description 86
- 238000000034 method Methods 0.000 claims description 69
- 238000005192 partition Methods 0.000 claims description 18
- 230000004044 response Effects 0.000 claims description 18
- 230000008859 change Effects 0.000 claims description 12
- 238000012544 monitoring process Methods 0.000 claims description 6
- 238000012795 verification Methods 0.000 claims description 4
- 238000001914 filtration Methods 0.000 description 26
- 238000012545 processing Methods 0.000 description 16
- 230000006870 function Effects 0.000 description 14
- 238000002347 injection Methods 0.000 description 13
- 239000007924 injection Substances 0.000 description 13
- 230000006399 behavior Effects 0.000 description 6
- 239000004744 fabric Substances 0.000 description 6
- 230000008569 process Effects 0.000 description 5
- 230000009471 action Effects 0.000 description 4
- 230000009977 dual effect Effects 0.000 description 4
- 239000013598 vector Substances 0.000 description 4
- XUIMIQQOPSSXEZ-UHFFFAOYSA-N Silicon Chemical compound [Si] XUIMIQQOPSSXEZ-UHFFFAOYSA-N 0.000 description 3
- 230000004913 activation Effects 0.000 description 3
- 238000010586 diagram Methods 0.000 description 3
- 238000005516 engineering process Methods 0.000 description 3
- 230000007246 mechanism Effects 0.000 description 3
- 230000000644 propagated effect Effects 0.000 description 3
- 230000001902 propagating effect Effects 0.000 description 3
- 230000011664 signaling Effects 0.000 description 3
- 229910052710 silicon Inorganic materials 0.000 description 3
- 239000010703 silicon Substances 0.000 description 3
- 238000012546 transfer Methods 0.000 description 3
- 238000011144 upstream manufacturing Methods 0.000 description 3
- 230000005540 biological transmission Effects 0.000 description 2
- 238000013500 data storage Methods 0.000 description 2
- 239000000835 fiber Substances 0.000 description 2
- 238000013507 mapping Methods 0.000 description 2
- 239000004065 semiconductor Substances 0.000 description 2
- 230000007704 transition Effects 0.000 description 2
- 230000003213 activating effect Effects 0.000 description 1
- 238000013459 approach Methods 0.000 description 1
- 238000013473 artificial intelligence Methods 0.000 description 1
- 230000008901 benefit Effects 0.000 description 1
- 229910002056 binary alloy Inorganic materials 0.000 description 1
- 239000011449 brick Substances 0.000 description 1
- 230000001413 cellular effect Effects 0.000 description 1
- 239000003795 chemical substances by application Substances 0.000 description 1
- 239000002131 composite material Substances 0.000 description 1
- 238000012790 confirmation Methods 0.000 description 1
- 238000000794 confocal Raman spectroscopy Methods 0.000 description 1
- 238000011500 cytoreductive surgery Methods 0.000 description 1
- 230000001419 dependent effect Effects 0.000 description 1
- 230000000694 effects Effects 0.000 description 1
- 230000007717 exclusion Effects 0.000 description 1
- 230000036541 health Effects 0.000 description 1
- 230000008676 import Effects 0.000 description 1
- 230000003993 interaction Effects 0.000 description 1
- 230000009191 jumping Effects 0.000 description 1
- 238000004519 manufacturing process Methods 0.000 description 1
- 239000000463 material Substances 0.000 description 1
- 238000010295 mobile communication Methods 0.000 description 1
- 238000012806 monitoring device Methods 0.000 description 1
- 230000003287 optical effect Effects 0.000 description 1
- 230000010076 replication Effects 0.000 description 1
- 238000012552 review Methods 0.000 description 1
- 238000000638 solvent extraction Methods 0.000 description 1
- 230000005236 sound signal Effects 0.000 description 1
- 230000003068 static effect Effects 0.000 description 1
- 239000000758 substrate Substances 0.000 description 1
- 230000001360 synchronised effect Effects 0.000 description 1
- 238000012360 testing method Methods 0.000 description 1
- 230000001052 transient effect Effects 0.000 description 1
- 230000000007 visual effect Effects 0.000 description 1
- 230000003313 weakening effect Effects 0.000 description 1
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/70—Protecting specific internal or peripheral components, in which the protection of a component leads to protection of the entire computer
- G06F21/82—Protecting input, output or interconnection devices
- G06F21/85—Protecting input, output or interconnection devices interconnection devices, e.g. bus-connected or in-line devices
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F13/00—Interconnection of, or transfer of information or other signals between, memories, input/output devices or central processing units
- G06F13/38—Information transfer, e.g. on bus
- G06F13/42—Bus transfer protocol, e.g. handshake; Synchronisation
- G06F13/4282—Bus transfer protocol, e.g. handshake; Synchronisation on a serial bus, e.g. I2C bus, SPI bus
- G06F13/4291—Bus transfer protocol, e.g. handshake; Synchronisation on a serial bus, e.g. I2C bus, SPI bus using a clocked protocol
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/50—Monitoring users, programs or devices to maintain the integrity of platforms, e.g. of processors, firmware or operating systems
- G06F21/57—Certifying or maintaining trusted computer platforms, e.g. secure boots or power-downs, version controls, system software checks, secure updates or assessing vulnerabilities
- G06F21/575—Secure boot
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L12/00—Data switching networks
- H04L12/28—Data switching networks characterised by path configuration, e.g. LAN [Local Area Networks] or WAN [Wide Area Networks]
- H04L12/40—Bus networks
- H04L12/40006—Architecture of a communication node
- H04L12/40026—Details regarding a bus guardian
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L12/00—Data switching networks
- H04L12/28—Data switching networks characterised by path configuration, e.g. LAN [Local Area Networks] or WAN [Wide Area Networks]
- H04L12/40—Bus networks
- H04L12/40052—High-speed IEEE 1394 serial bus
- H04L12/40104—Security; Encryption; Content protection
Abstract
이 문서에서는 보안 직렬 주변 장치 인터페이스(SPI) 통신의 양태를 공개한다. 일부 양태에서, 보안 SPI 통신 모듈은 SPI 인터커넥트를 통해 호스트에 연결된 주변 블록으로 호스트에 의해 전송된 통신들을 모니터링한다. 모듈은 호스트에 의해 송신된 통신들의 각 명령들을 주변 블록이 실행하도록 승인되지 않은 명령들을 나타내는 정보와 비교한다. 비교에 기초하여, 모듈은 각 명령들 중 하나가 주변 블록이 실행하도록 승인되지 않은 명령들 중 하나인지 결정한다. 그런 다음 모듈은 주변 블록이 해당 통신 명령의 적어도 일부를 수신하는 것을 방지한다. 이렇게 하면 모듈은 주변 블록의 보안을 손상시킬 수 있는, 승인되지 않은 명령들을 주변 블록이 실행하는 것을 방지할 수 있다.This document discloses aspects of secure serial peripheral interface (SPI) communication. In some aspects, the secure SPI communications module monitors communications sent by the host to a peripheral block connected to the host via an SPI interconnect. The module compares each command in communications sent by the host with information indicating commands that the surrounding block is not authorized to execute. Based on the comparison, the module determines whether one of each instruction is one of the instructions that the surrounding block is not authorized to execute. The module then prevents surrounding blocks from receiving at least part of that communication command. This way, the module can prevent neighboring blocks from executing unauthorized instructions that could compromise the security of the surrounding blocks.
Description
사회의 전산화가 계속 증가하고 민감한 사용자 정보를 저장하고 차량 운전, 사용자 인증 수행, 디지털 화폐 거래 완료 등 사용자를 위한 다양한 작업을 수행하기 위해 개인 컴퓨팅 디바이스에 대한 의존도가 높아짐에 따라, 세계는 컴퓨팅 디바이스의 민감한 정보에 대한 비용이 많이 드는 다양한 공격에 점점 더 취약해지고 있다.As the computerization of society continues to increase and the world becomes increasingly dependent on personal computing devices to store sensitive user information and perform a variety of tasks for users, such as driving vehicles, performing user authentication, and completing digital currency transactions, the world is increasingly faced with a growing number of computing devices. Sensitive information is becoming increasingly vulnerable to a variety of costly attacks.
최근 결함 기반(fault-based) 암호 분석 방법은 결함 주입 공격과 관련된 잠재적으로 보안을 위협하는 방법을 식별했다. 결함 주입 공격은 공격자가 소프트웨어 주입과 달리 물리적으로 컴퓨팅 시스템에 결함을 주입하여 전자 구성요소의 동작을 의도적으로 변경하는 것을 포함한다. 결과적으로 결함 주입 공격은 많은 낮은 수준의 시스템 보안 기능을 우회하고, 악의적인 의도를 달성하기 위해 컴퓨팅 시스템 동작을 변경하고/하거나 민감한 정보를 추출할 수 있다. 결함 주입 공격에는 전압 글리칭, 클록 글리칭, 레이저 주입, 전자기 주입 등이 포함될 수 있다. 어떤 경우에는 이러한 공격으로 인해 다양한 위치에 결함 주입이 발생하여 전자 시스템 보안이 손상되거나 약화될 수 있다. 따라서 결함 주입 공격은 컴퓨팅 시스템 내에서 전송되는 명령이나 데이터를 변경할 수 있으며 잠재적으로 시스템의 실행 흐름을 변경하여 키 누출, 권한 상승 또는 의도하지 않은 코드 실행과 같은 다운스트림 문제를 일으킬 수 있다.Recently, fault-based cryptanalysis methods have identified potentially security-threatening methods associated with fault injection attacks. Fault injection attacks involve an attacker intentionally altering the behavior of electronic components by physically injecting a fault into a computing system, as opposed to software injection. As a result, fault injection attacks can bypass many low-level system security features, alter computing system behavior and/or extract sensitive information to achieve malicious intent. Fault injection attacks can include voltage glitching, clock glitching, laser injection, electromagnetic injection, etc. In some cases, these attacks can cause flaw injection in various locations, compromising or weakening the security of electronic systems. Therefore, fault injection attacks can change the commands or data transmitted within a computing system, potentially altering the execution flow of the system, causing downstream problems such as key leakage, privilege escalation, or unintended code execution.
본 문서는 보안 직렬 주변 장치 인터페이스(serial peripheral interface)(SPI) 통신을 위한 장치 및 기술을 설명한다. 일부 양태에서, 보안 SPI 통신 모듈은 호스트 또는 다른 버스 컨트롤러에 의해 SPI 인터커넥트를 통해 호스트에 연결된 주변 블록(peripheral block)으로 전송되는 통신들을 모니터링한다. 보안 SPI 통신 모듈은 호스트에 의해 송신된 통신들의 각 명령들을 주변 블록이 실행하도록 승인되지 않은 명령들을 나타내는 정보와 비교한다. 비교 결과에 기초하여, 보안 SPI 통신 모듈은 각 명령들 중 하나가 주변 블록이 실행하도록 승인되지 않은 명령들 중 하나라고 결정한다. 그러면 보안 SPI 통신 모듈은 주변 블록이 통신의 각 명령의 적어도 일부를 수신하는 것을 방지한다. 이를 통해 모듈은 상태 레지스터 변경, 보호 체계 비활성화, 민감한 정보 액세스 등을 통해 주변 블록의 보안을 손상시킬 수 있는, 승인되지 않은 명령들을 주변 블록이 실행하는 것을 방지할 수 있다.This document describes devices and technologies for secure serial peripheral interface (SPI) communications. In some aspects, a secure SPI communications module monitors communications transmitted by a host or other bus controller to a peripheral block connected to the host via an SPI interconnect. The secure SPI communication module compares each command in communications transmitted by the host with information indicating commands that neighboring blocks are not authorized to execute. Based on the comparison results, the secure SPI communication module determines that one of the commands is one of the commands that the surrounding block is not authorized to execute. The secure SPI communication module then prevents neighboring blocks from receiving at least part of each command in the communication. This allows the module to prevent neighboring blocks from executing unauthorized instructions that could compromise the security of neighboring blocks by changing state registers, disabling protection schemes, or accessing sensitive information.
이 요약은 보안 SPI 통신을 구현하기 위한 단순화된 개념을 소개하기 위해 제공되며, 이는 아래의 상세한 설명에서 더 설명되고 도면에 예시되어 있다. 이 요약은 청구된 주제의 필수 특징을 식별하기 위한 것이 아니며 청구된 주제의 범위를 결정하는 데 사용하기 위한 것도 아니다.This summary is provided to introduce simplified concepts for implementing secure SPI communications, which are further explained in the detailed description below and illustrated in the figures. This summary is not intended to identify essential features of the claimed subject matter or to be used in determining the scope of the claimed subject matter.
보안 SPI 통신의 하나 이상의 양태의 세부사항은 도면을 참조하여 본 개시 전체에 걸쳐 설명된다. 설명과 그림에서 서로 다른 경우에 동일한 참조 번호를 사용하는 것은 동일하거나 유사한 요소를 나타낸다.
도 1은 보안 SPI 통신의 양태를 구현할 수 있는 장치를 포함하는 예시적인 운영 환경을 도시한다.
도 2는 보안 SPI 통신의 양태를 구현할 수 있는 프로세서 및 다중 회로 구성요소를 포함하는 예시적인 시스템을 도시한다.
도 3은 하나 이상의 양태에 따라 SPI 명령 필터링을 구현하는 시스템 구성요소의 예시적인 구성을 도시한다.
도 4는 보안 SPI 통신의 양태를 구현하기 위한 클록 게이팅 및 명령 필터링 기능을 포함하는 예시적인 시스템을 도시한다.
도 5는 보안 SPI 통신의 양태가 구현될 수 있는 SPI 통신 시그널링의 예시적인 타이밍도를 도시한다.
도 6은 하나 이상의 양태에 따른 보안 SPI 통신을 위한 예시적인 방법을 도시한다.
도 7은 하나 이상의 양태에 따라 SPI 통신의 명령을 필터링하는 예시적인 방법을 도시한다.
도 8은 하나 이상의 양태에 따라 대체 바이너리 이미지 액세스를 가능하게 하기 위해 명령 주소를 조작하는 예시적인 방법을 도시한다; 그리고
도 9는 보안 SPI 통신의 양태를 구현할 수 있는 예시적인 시스템 온 칩을 도시한다.Details of one or more aspects of secure SPI communication are described throughout this disclosure with reference to the drawings. The use of the same reference number in different instances in the description and figures refers to identical or similar elements.
1 illustrates an example operating environment including a device capable of implementing aspects of secure SPI communications.
2 illustrates an example system including a processor and multiple circuit components that can implement aspects of secure SPI communications.
3 illustrates an example configuration of system components that implement SPI command filtering in accordance with one or more aspects.
4 illustrates an example system including clock gating and command filtering functions to implement aspects of secure SPI communications.
5 illustrates an example timing diagram of SPI communication signaling in which aspects of secure SPI communication may be implemented.
6 illustrates an example method for secure SPI communication in accordance with one or more aspects.
7 illustrates an example method of filtering commands in SPI communication according to one or more aspects.
8 illustrates an example method of manipulating an instruction address to enable alternative binary image access in accordance with one or more aspects; and
9 illustrates an example system-on-chip that can implement aspects of secure SPI communication.
컴퓨팅 시스템은 종종 결함, 공격 및 기타 잠재적으로 손상을 주는 이벤트에 대한 보호 조치를 제공하기 위해 보안 회로(security circuitry) 및 소프트웨어를 갖춘 집적 회로(integrated circuit)를 포함한다. 오늘날의 컴퓨팅 환경에서 악의적인 행위자는 다양한 공격 벡터를 사용하여 다양한 수준에서 컴퓨팅 디바이스를 공격할 수 있다. 예를 들어 결함 주입 공격은 이러한 보안 패러다임 중 상당수가 제공하는 보호 기능을 저하시킨다. 결함 주입 공격은 시스템 보안 기능을 우회하고, 악의적인 의도를 달성하기 위해 시스템 동작을 변경하거나, 기밀 정보를 알아낼 수 있다. 결함 주입 공격을 사용하여 공격자는 글리치(예: 시스템에 갑작스럽고 일시적으로 주입된 결함)를 사용하여 전자 구성요소(예: 중앙 프로세싱 유닛)의 프로그래밍된 동작을 간접적으로 또는 직접적으로 변경할 수 있다. 이러한 공격은 때때로 컴퓨팅 디바이스를 "벽돌"로 만들 수 있지만, 다른 경우에는 정밀하고 표적화된 공격으로 인해 보안 위협이 발생할 수 있다. 예를 들어 결함 주입 공격을 통해 공격자는 프로그램의 제어 흐름을 손상시킬 수 있으며, 이로 인해 "return to libc" 유형의 공격과 같이 잘못된 함수가 호출될 수 있다. 어떤 경우에는 이러한 공격으로 인해 컴퓨팅 디바이스가 민감한 데이터를 노출하거나 확인되지 않은 코드를 실행할 수 있다. 따라서 결함 주입 공격은 컴퓨팅 시스템 내에서 전송되는 명령이나 데이터를 변경할 수 있으며 잠재적으로 시스템의 실행 흐름을 변경하여 키 누출, 권한 상승 또는 의도하지 않은 코드 실행과 같은 다운스트림 문제를 일으킬 수 있다.Computing systems often include integrated circuits equipped with security circuitry and software to provide protection against faults, attacks, and other potentially damaging events. In today's computing environment, malicious actors can attack computing devices at various levels using a variety of attack vectors. For example, fault injection attacks degrade the protection provided by many of these security paradigms. Fault injection attacks can bypass system security features, change system behavior to achieve malicious intent, or reveal confidential information. Using fault injection attacks, an attacker can indirectly or directly change the programmed behavior of an electronic component (e.g. a central processing unit) using a glitch (e.g. a fault suddenly and temporarily injected into the system). These attacks can sometimes “brick” computing devices, but in other cases, precise, targeted attacks can pose security threats. For example, a fault injection attack could allow an attacker to corrupt the control flow of a program, which could cause the wrong function to be called, such as a "return to libc" type of attack. In some cases, these attacks can cause computing devices to expose sensitive data or execute unverified code. Therefore, fault injection attacks can change the commands or data transmitted within a computing system, potentially altering the execution flow of the system, causing downstream problems such as key leakage, privilege escalation, or unintended code execution.
그러나 이러한 공격을 해결하기 위한 선행 기술은 일반적으로 공격자가 명령을 변경하고 시스템 보안을 구성하는 것을 방지하는 데 약하고 비효율적이다. 예를 들어, 이전의 일부 방식에서 디바이스는 명령을 취소하려는 시도로 연산코드(opcode)의 마지막 비트를 변경할 수 있다. 그러나 이러한 유형의 체계는 명령이 주변 장치에 의해 계속 사용되는 경우 효과적이지 않거나 두 명령이 인접해 있는 경우(예: 1비트씩 꺼짐) 적용되지 않을 수 있다. 이전의 다른 체계에서는 여러 명령을 단일 명령 연산코드로 매핑하는 명령 테이블을 유지했다. 테이블 에이전트는 명령의 각 비트를 수신하는 동안 명령 테이블을 탐색하고 상이한 연산코드를 다운스트림 주변 장치에 보낸다. 이러한 매핑 테이블은 특정 명령을 테이블에 비효율적으로 매핑하는 것과 관련된 이슈들로 인해 어려움을 겪었으며, 이는 시스템 설계자의 기본 설정(preference)에 따라 필터링하거나 필터링할 수 없었다. 따라서 앞선 기술은 제한이나 필터링 없이 시스템을 통해 전파될 수 있는 다양한 명령에 취약하여 승인되지 않거나 또는 허용되지 않는 명령의 실행과 관련된 시스템 불안정성을 초래했다.However, prior art to address these attacks is generally weak and ineffective in preventing attackers from changing commands and configuring system security. For example, in some of the previous approaches, the device may change the last bit of the opcode in an attempt to cancel the command. However, this type of scheme may not be effective if the command is continuously used by a peripheral device, or may not apply if two commands are adjacent (e.g., turning off 1 bit). Other previous systems maintained an instruction table that maps multiple instructions to a single instruction opcode. The table agent searches the command table while receiving each bit of the command and sends different opcodes to downstream peripherals. These mapping tables suffered from issues related to inefficient mapping of specific commands to tables, which could be filtered or not according to the system designer's preferences. Therefore, prior technologies are vulnerable to a variety of commands that can propagate through the system without restriction or filtering, resulting in system instability related to the execution of unauthorized or impermissible commands.
이전의 보안 기술과 대조적으로, 본 개시는 보안 SPI 통신의 양태들을 설명한다. 양태에서, 보안 SPI 통신 모듈은 호스트 또는 다른 버스 컨트롤러에 의해 SPI 인터커넥트를 통해 호스트에 연결된 주변 블록으로 전송되는 통신들을 모니터링한다. 보안 SPI 통신 모듈은 호스트가 송신한 통신들의 각 명령들을 주변 블록이 실행하도록 승인되지 않거나 허용되지 않는 명령들을 나타내는 정보(예: 제외 명령 목록)와 비교한다. 비교 결과, 보안 SPI 통신 모듈은 각 명령들 중 하나가 주변 블록이 실행하도록 승인되지 않은 명령들 중 하나라고 결정한다. 결정에 응답하여, 보안 SPI 통신 모듈은 주변 블록이 통신의 각 명령 중 적어도 일부를 수신하는 것을 방지하기 위해 SPI 인터커넥트의 칩 선택 라인 및/또는 클록 라인의 상태를 변경한다. 이를 통해 모듈은 상태 레지스터 변경, 보호 체계 비활성화, 민감한 정보 액세스 등을 통해 주변 블록의 보안을 손상시킬 수 있는, 승인되지 않은 명령들을 주변 블록이 실행하는 것을 방지할 수 있다.In contrast to previous secure techniques, this disclosure describes aspects of secure SPI communication. In an aspect, a secure SPI communications module monitors communications transmitted by a host or other bus controller to a peripheral block connected to the host via an SPI interconnect. The secure SPI communication module compares each command in communications sent by the host with information (e.g., list of excluded commands) indicating commands that neighboring blocks are not authorized or permitted to execute. As a result of the comparison, the secure SPI communication module determines that one of each command is one of the commands that the surrounding block is not authorized to execute. In response to the determination, the secure SPI communication module changes the state of the chip select line and/or clock line of the SPI interconnect to prevent peripheral blocks from receiving at least some of the respective commands in the communication. This allows the module to prevent neighboring blocks from executing unauthorized instructions that could compromise the security of neighboring blocks by changing state registers, disabling protection schemes, or accessing sensitive information.
따라서, 이전 기술과 달리, 여기에 설명된 보안 SPI 통신의 양태들은 플래시 메모리 디바이스 또는 칩과 같은, SPI 주변 구성요소의 기본 동작, 예상 동작 또는 보호 메커니즘을 활용함으로써 SPI 주변 구성요소를 보호할 수 있다. 검토해 보면, 플래시 메모리 디바이스는 일반적으로 쓰기 보호 핀 또는 입력(예: Write_Protect 핀)을 사용하여 플래시 메모리 디바이스의 상태 레지스터를 보호할 수 있다. 그러나 이러한 대부분의 플래시 메모리 디바이스는 쿼드 읽기 명령을 활성화하거나 함께 사용하면 이 전용 쓰기 보호 핀이 비활성화된다. 따라서, 본 명세서에 설명된 보안 SPI 통신의 양태들은 선택적 명령 필터링 및/또는 선택적 데이터 필터링을 구현함으로써 쓰기 보호 복제를 통해 플래시 메모리 디바이스 보호를 제공한다.Accordingly, unlike previous techniques, aspects of secure SPI communication described herein can protect SPI peripheral components by leveraging the default operation, expected operation, or protection mechanisms of the SPI peripheral component, such as a flash memory device or chip. . For review, flash memory devices typically use a write-protect pin or input (such as the Write_Protect pin) to protect the flash memory device's status register. However, most of these flash memory devices disable this dedicated write protection pin when enabled or used with quad read commands. Accordingly, aspects of secure SPI communication described herein provide flash memory device protection through write-protected replication by implementing selective command filtering and/or selective data filtering.
일반적으로, SPI 플래시 디바이스 또는 기타 주변 장치의 상태 레지스터에는 블록 보호, 섹터 보호, 상위/하위 범위 보호 등과 같이 메모리의 다양한 섹션을 보호하거나 잠그도록 구성가능한 특정 보호 비트가 포함된다. 즉, 상태 레지스터의 이러한 보호 비트 중 하나 이상을 설정하는 것은 플래시 메모리 디바이스의 다양한 보호 체계에 따라 사전 정의된 메모리 영역의 조작을 보호하거나 방지하는 것으로 해석된다. 따라서, 플래시 메모리 디바이스의 보호 체계 또는 보호 정의는 상태 레지스터에 대한 액세스가 활성화되는 특정 명령을 사용해야만 변경될 수 있다. 이전 기술에 따라 모든 명령을 필터링하는 대신 보안 SPI 통신 양태에서는, 상태 레지스터에 액세스하고 플래시 메모리 디바이스의 보호 상태(예: 쓰기 상태 레지스터 및 이와 유사한 것)를 변경하는 데 유용한 선택적 명령 세트를 보호할 수 있다. 따라서 보안 SPI 통신의 설명된 앙태에서 호스트 또는 다른 버스 마스터가 보호 상태를 변경하기 위해 이러한 보호 명령을 발행하는 것을 방지하는 경우, 명령 발행자는 보호 상태를 변경할 수 없다. 이렇게 하면 호스트나 다른 버스 마스터가 플래시 메모리 디바이스의 내용을 프로그래밍하거나 지울 수 없다. 여러 양태에서, 읽기 명령은 여전히 정상적으로 포워딩되며, 원하는 경우 내부 메일박스를 유지하기 위해 특정 영역을 분할할 수 있다.Typically, the status register of an SPI flash device or other peripheral device contains specific protection bits that are configurable to protect or lock various sections of the memory, such as block protection, sector protection, upper/lower range protection, etc. In other words, setting one or more of these protection bits in the status register is interpreted as protecting or preventing manipulation of a predefined memory area according to the various protection schemes of the flash memory device. Therefore, the protection scheme or protection definition of a flash memory device can only be changed using a specific instruction that activates access to the status register. Instead of filtering all commands as per previous techniques, the secure SPI communication aspect allows you to secure a select set of commands that are useful for accessing status registers and changing the protected state of a flash memory device (e.g. write status register and similar). there is. Therefore, if the described aspect of secure SPI communication prevents a host or other bus master from issuing such a protection command to change the protection state, the command issuer cannot change the protection state. This prevents the host or other bus masters from programming or erasing the contents of the flash memory device. In many aspects, read commands are still forwarded normally, and specific areas can be partitioned to maintain internal mailboxes if desired.
쓰기 상태 레지스터와 관련하여, 보안 SPI 통신의 양태에서는 쓰기 상태 레지스터 명령을 사이드 이펙트(side-effect)가 없는 값(예: 읽기 명령)으로 필터링하는 대신 쓰기 상태 레지스터 명령의 데이터를 다운스트림 SPI 플래시 디바이스로 필터링할 수 있다. 따라서 보안 SPI 통신 모듈은 조작 없이 모든 명령 바이트를 호스트로부터 SPI 플래시 디바이스로 전달되도록 허용할 수 있다. 보안 SPI 통신 모듈이 명령 바이트를 쓰기 상태 레지스터 명령으로 결정하거나 식별하는 경우(SPI 플래시 디바이스 또는 공급업체는 쓰기 상태 액세스를 식별하는 데 유용한 프로그래밍가능 목록을 제공할 수 있음), 프로그래밍된 명령 값은 보안 SPI 통신 모듈에 의해 제어될 수 있다.Regarding the write status register, an aspect of secure SPI communication involves filtering the write status register commands to values that do not have side-effects (e.g., read commands), and instead sending data from the write status register command to the downstream SPI flash device. You can filter by . Therefore, the secure SPI communication module can allow all command bytes to be passed from the host to the SPI flash device without any manipulation. If the secure SPI communication module determines or identifies a command byte as a write status register command (your SPI flash device or vendor may provide a programmable list useful for identifying write status accesses), the programmed command value is a secure Can be controlled by SPI communication module.
일부 양태에서, SPI 디바이스 프로그램 값은 선택 레지스터 및 값 레지스터를 통해 유지될 수 있다. 일반적으로 선택 레지스터는 특정 데이터 비트가 호스트에서 통과되도록 허용되는지 또는 보안 SPI 통신 모듈 또는 SPI 디바이스 컨트롤러에서 강제되는지 여부를 제어한다. 값 레지스터는 선택 비트가 설정되었다고 가정할 때 강제 값이 무엇인지 제어할 수 있다. 예를 들어, 선택 레지스터와 값 레지스터가 "0011_0000(0x30)"으로 설정된 선택 레지스터와 "xx01_xxxx"로 설정된 값 레지스터로 프로그래밍되었다고 가정한다. 이는 쓰기 상태 명령이 검출되면 비트 4와 5(4번째 및 5번째 비트 포지션)가 "1"과 "0"으로 강제 설정되고 명령의 나머지 비트는 통과되도록 허용됨을 의미한다. 쓰기 상태 명령은 칩 공급업체에 따라 다를 수 있으므로 쓰기 상태를 나타내는 항목을 프로그래밍하거나 구성할 수 있지만, 단 2~4개의 항목만 필요할 수 있다.In some aspects, SPI device program values may be maintained through select registers and value registers. Typically, a select register controls whether certain data bits are allowed to pass by the host or are forced by a secure SPI communication module or SPI device controller. The value register can control what the force value is, assuming the select bit is set. For example, assume that the select register and value register are programmed with the select register set to "0011_0000(0x30)" and the value register set to "xx01_xxxx". This means that when a write status command is detected, bits 4 and 5 (4th and 5th bit positions) are forced to "1" and "0" and the remaining bits of the command are allowed to pass. Write status commands can vary depending on the chip vendor, so you can program or configure the entries that represent the write status, but only two to four entries may be needed.
쓰기 상태 명령 외에도 보안 SPI 통신은 주변 장치의 보호 비트 상태에 영향을 미칠 수 있는 호스트 또는 버스 마스터가 발행한 다른 명령을 변경하거나 보호할 수 있으며, 여기에는 리셋 명령 또는 기타 공급 업체 특정 명령이 포함될 수 있다. 이를 위해 보안 SPI 통신의 양태에서는 시스템의 대상 주변 장치에서 명령을 수신, 캡처 또는 프로세싱하기 전에 명령을 침묵시키거나 변경하는 선택적 필터링을 구현할 수 있다. 본 개시 전체에 걸쳐 설명된 바와 같이, 보안 SPI 통신 모듈 또는 SPI 명령 필터는 명령의 마지막 비트가 완전히 캡처되기 전에 SPI 플래시 디바이스와 같은 주변 장치의 칩 선택 라인 또는 신호(CSb)를 디어설팅(deasserting)할 수 있다. 양태에서, 보안 SPI 통신 모듈은 명령이 필터링되어야 함을 8번째 클록 사이클(예를 들어, 캡처 전)에서 검출할 수 있다. 그런 다음 보안 SPI 통신 모듈은 칩 선택 라인을 조기에 디어설팅하여 마지막 비트(예: 8번째 비트) 명령 비트가 주변 장치에 의해 캡처되지 않도록 한다. 대안적으로 또는 추가적으로, 보안 SPI 통신 모듈은 주변 장치가 필터링할 명령의 8번째 비트를 캡처하는 것을 방지하기 위해 7번째 비트 또는 클록 사이클 후에 SPI 클록 라인을 주변 장치에 게이팅하거나 유지할 수 있다. 일부 경우에, 이러한 동작은 타이밍에 민감하며, 보안 SPI 통신 모듈은 SPI 클록 주기의 절반 이내에 제어 신호(예: 게이팅 및 필터)를 생성하는 등의 작업을 수행할 수 있다. 예를 들어, 25MHz~100MHz SPI 클록의 경우, 보안 SPI 통신 모듈은 제어 신호를 생성하거나, 칩 선택 라인을 토글하거나, 10~50나노초 내에 SPI 클록을 게이팅하여 설명된 명령 필터링을 완료할 수 있다.In addition to write status commands, secure SPI communications can change or protect other commands issued by the host or bus master that can affect the state of protection bits in peripheral devices, which may include reset commands or other vendor-specific commands. there is. To this end, aspects of secure SPI communication can implement selective filtering to silence or alter commands before they are received, captured, or processed by target peripherals in the system. As described throughout this disclosure, a secure SPI communication module or SPI command filter deasserts the chip select line or signal (CSb) of a peripheral device, such as an SPI flash device, before the last bit of the command is fully captured. can do. In an aspect, the secure SPI communication module may detect on the eighth clock cycle (e.g., before capture) that the command should be filtered. The secure SPI communication module then deasserts the chip select line early to ensure that the last bit (e.g. the 8th bit) command bit is not captured by peripherals. Alternatively or additionally, the secure SPI communication module may gate or hold the SPI clock line to a peripheral device after the 7th bit or clock cycle to prevent the peripheral device from capturing the 8th bit of the command to be filtered. In some cases, these operations are timing sensitive, and a secure SPI communication module may perform tasks such as generating control signals (e.g. gating and filters) within half an SPI clock cycle. For example, for a 25MHz to 100MHz SPI clock, a secure SPI communication module can generate a control signal, toggle a chip select line, or gate the SPI clock within 10 to 50 nanoseconds to complete the command filtering described.
보안 SPI 통신의 양태에서, 명령 필터는 유연성을 제공하기 위해 하나 이상의 방식으로 선택적 명령 필터링을 구현하도록 구성가능하거나 프로그래밍가능할 수 있다. 경우에 따라, 256개의 가능한 명령으로 구성된 명령 공간의 각 명령은 명령 공간에 대한 8개의 레지스터를 통해 1비트 활성화를 갖는다. 보안 SPI 통신 모듈은 수신된 명령 또는 수신된 명령의 일부를 사용하여 테이블에 인덱싱하여 명령이 통과되도록 허용되는지 또는 허용되지 않는지(예: 필터링됨) 여부를 결정할 수 있다. 예를 들어, 활성화 비트 제어는 명령이 주변 장치로 다운스트림을 전달하도록 허용되는지 또는 필터링되는지 여부를 나타내거나 제어한다. 일부 구현예에서, 1의 활성화 비트 값 "1"은 명령이 통과하도록 허용되었음을 나타내고 0의 활성화 비트 값 "0"은 명령이 보안 SPI 통신 모듈 또는 명령 필터에 의해 필터링됨을 나타낸다. 필터링 동작에 앞서 호스트의 소프트웨어나 펌웨어에서 필터링 테이블을 구성하거나 프로그래밍할 수 있다.In aspects of secure SPI communication, command filters may be configurable or programmable to implement selective command filtering in one or more ways to provide flexibility. In some cases, each instruction in an instruction space of 256 possible instructions has a 1-bit enable through 8 registers for the instruction space. The secure SPI communication module can use the received command, or part of a received command, to index into a table to determine whether the command is allowed or not allowed to pass (e.g., filtered). For example, the enable bit control indicates or controls whether a command is allowed to pass downstream to a peripheral device or is filtered. In some implementations, an enable bit value of “1” of 1 indicates that the command is allowed to pass and an enable bit value of “0” of 0 indicates that the command is filtered by a secure SPI communication module or command filter. The filtering table can be configured or programmed in the host's software or firmware prior to the filtering operation.
명령 필터링을 구현하는 보안 SPI 통신 모듈을 사용하면, 보안 SPI 통신 모듈은 SPI 플래시 디바이스의 상태 레지스터 조작을 가능하게 하는 명령을 간단히 필터링하거나 차단할 수 있으므로 SPI 플래시 디바이스의 상태 보호가 필요하지 않을 수 있다. 따라서, 선택적 또는 감소된 복잡성 명령 필터링 및/또는 상태 레지스터 명령 데이터 필터링을 갖는 이점은 더 적은 수의 명령 또는 명령어가 필터링된다는 것이다. 즉, 필터링해야 하는 명령어 세트(예: 쓰기-상태-레지스터와 관련된 명령)가 줄어들고, 남은 시간 동안 보안 SPI 통신 모듈을 통해 시스템의 호스트가 SPI 플래시 디바이스와 직접 통신할 수 있다. 이로 인해 펌웨어 또는 보안 SPI 통신 모듈의 개입이 줄어들게 되며, 펌웨어는 모든 명령 페이로드를 캡처하고 해당 페이로드가 SPI 플래시 디바이스에 다운스트림을 전달해야 하는지 여부를 결정할 필요가 없다. 대안적으로 또는 추가적으로, 호스트 또는 시스템 소프트웨어는 명령 또는 데이터 필터링에 대해 설명된 양태의 임의의 조합을 구현하도록 보안 SPI 통신 모듈을 구성할 수 있다. 예를 들어, 보안 SPI 통신 모듈은 명령 필터링만 구현하고, 기본적으로 명령 필터링을 허용하거나 및/또는 허용하지 않고, 상태 보호를 통해 명령 필터링을 허용하지 않고, 상태 보호를 통해 명령 필터링을 허용하는 등을 구현하도록 구성될 수 있다. 여기에 설명된 이러한 양태와 다른 양태는 호스트 또는 시스템 소프트웨어가 보안 SPI 통신 모듈을 설정하거나 구성하여 명령 필터링 및/또는 A/B 파티션 액세스를 구현한 후에 SPI 플래시 디바이스(예: SPI 플래시 칩)의 보호 설정이 임의로 변경될 수 없도록 보장할 수 있다. 따라서, 다운스트림 SPI 플래시 디바이스가 내부 보호 메커니즘에 따라 작동하는 한, 이러한 양태를 통해 보안 SPI 통신을 이전 기술보다 덜 복잡하고 효율적으로 구현할 수 있다.Using a secure SPI communication module that implements command filtering, state protection of the SPI flash device may not be necessary because the secure SPI communication module can simply filter or block commands that enable manipulation of the state register of the SPI flash device. Accordingly, an advantage of having selective or reduced complexity instruction filtering and/or status register instruction data filtering is that fewer instructions or instructions are filtered. This means that the set of instructions that need to be filtered out (e.g., instructions related to write-status-registers) is reduced, and the remaining time the host in the system can communicate directly with the SPI flash device via the secure SPI communication module. This reduces the involvement of the firmware or secure SPI communication module; the firmware does not need to capture all command payloads and determine whether those payloads should be passed downstream to the SPI flash device. Alternatively or additionally, host or system software may configure the secure SPI communication module to implement any combination of the aspects described for command or data filtering. For example, a secure SPI communication module may implement only command filtering, allow and/or disallow command filtering by default, do not allow command filtering via state protection, allow command filtering via state protection, etc. It can be configured to implement. These and other aspects described herein provide protection of an SPI flash device (e.g., SPI flash chip) after host or system software sets up or configures a secure SPI communication module to implement command filtering and/or A/B partition access. It can be ensured that settings cannot be arbitrarily changed. Therefore, as long as the downstream SPI flash device operates according to the internal protection mechanism, this aspect allows secure SPI communication to be implemented with less complexity and efficiency than previous technologies.
다양한 양태에서, 보안 SPI 통신 모듈은 호스트와 SPI 플래시 디바이스는 물론 임의 개수의 다른 시스템 주변 블록 또는 구성요소를 포함하는 시스템의 SPI 인터커넥트에 연결된다. 보안 SPI 통신 모듈은 호스트 플랫폼에서 SPI 플래시 디바이스까지의 SPI 트랜잭션을 스누핑하거나 모니터링하고 권한이 없는 트래픽이 검출될 때 개입하는 것을 포함하는 명령 제어 체계를 구현할 수 있다. 명령 제어 체계는 유해한 읽기/쓰기 요청이나 자체 완성 명령(예: 칩 삭제)을 차단하기 위한 것이다. 이러한 자체 완성 명령에는 주소나 페이로드와 같은 다른 데이터가 뒤에 오지 않는 명령이 포함될 수 있다. 양태에서, 이 체계는 본 명세서에 설명된 바와 같이 SPI 명령 필터 및 SPI 클록 컨트롤러(예: 클록 게이팅 셀)를 사용할 수 있다. 일반적으로, 명령 필터는 명령 블록 목록이나 테이블에 기초하여 들어오는 명령을 차단하거나 허용된 명령 목록에 기초하여 승인된 명령만 통과하도록 허용할 수 있다. 명령 차단 목록 또는 허용 명령 목록은 사용되는 방법에 따라 소프트웨어로 구현되거나 하드웨어 회로로 구현될 수 있다. 양태에서, 명령을 차단하기 위해, 명령 필터는 명령 전파 동안 8번째 SPI 클록 에지 전이나 8번째 SPI 클록 에지에서 칩 선택 라인 또는 신호 라인을 변경한다.In various aspects, a secure SPI communication module is coupled to the SPI interconnect of a system that includes a host and SPI flash devices as well as any number of other system peripheral blocks or components. The secure SPI communications module may implement a command and control scheme that includes snooping or monitoring SPI transactions from the host platform to the SPI flash device and intervening when unauthorized traffic is detected. The command control scheme is intended to block harmful read/write requests or self-complete commands (e.g. chip erase). These self-complete instructions may include instructions that are not followed by any other data, such as an address or payload. In aspects, this scheme may use an SPI command filter and an SPI clock controller (e.g., clock gating cell) as described herein. In general, a command filter can block incoming commands based on a command block list or table, or allow only approved commands to pass through, based on a list of allowed commands. Depending on the method used, the command block list or allowed command list may be implemented in software or in hardware circuitry. In an aspect, to block a command, the command filter changes the chip select line or signal line before or at the 8th SPI clock edge during command propagation.
동시에, 명령 필터는 호스트 시스템이 칩 선택 신호를 릴리즈할 때까지 SPI 플래시 디바이스에 대한 SPI 클록 라인을 게이팅하거나 유지할 수 있다. SPI 칩 선택 라인과 SPI 클록은 동시에, 근접하게(예: 동일한 클록 비트 또는 사이클 내에서) 또는 부분적으로 겹치는 방식으로 토글될 수 있다. 양태에서, 보안 SPI 통신 모듈은 SPI 클록의 전파를 제어하기 위한 클록 게이팅 셀을 포함한다. 따라서, 클록 게이팅 셀은 호스트에서 발생하는 SPI 클록 신호를 칩 선택 라인 또는 신호의 글리치를 방지하는 데 효과적인 SPI 플래시 디바이스에 전파하지 못할 수 있다. 어떤 경우에는, SPI 클록 신호가 게이팅되지 않으면 칩 선택 라인에 글리치를 제거하기 위해 클록 펄스가 하나 더 필요할 수 있다. 즉, 클럭 신호 게이팅이 없으면 명령 필터는 권한이 없는 명령을 취소하기 위해 칩 선택 신호를 높이는 타이밍을 놓칠 수 있다. 따라서 SPI 클록 게이팅을 사용하면 보안 SPI 통신 모듈은 승인되지 않은 명령이 글리치 없이 SPI 플래시 디바이스에 완전히 전송되기 전에 칩 선택 라인 또는 신호를 디어설팅할 수 있으며, SPI 디바이스는 이를 실행하지 않고 불완전한 명령을 취소할 수 있다.At the same time, the command filter can gate or hold the SPI clock line for the SPI flash device until the host system releases the chip select signal. The SPI chip select line and SPI clock can be toggled simultaneously, closely (e.g., within the same clock bit or cycle), or in a partially overlapping manner. In an aspect, the secure SPI communication module includes a clock gating cell to control propagation of the SPI clock. Therefore, the clock gating cell may not be able to propagate the SPI clock signal originating from the host to the chip select line or SPI flash device, which is effective in preventing glitches in the signal. In some cases, if the SPI clock signal is not gated, one more clock pulse may be needed to eliminate the glitch on the chip select line. That is, without clock signal gating, the command filter may miss the timing of raising the chip select signal to cancel unauthorized commands. Therefore, SPI clock gating allows the secure SPI communication module to deassert the chip select line or signal before the unauthorized command is completely transmitted to the SPI flash device without a glitch, and the SPI device cancels the incomplete command without executing it. can do.
본 명세서에 설명된 보안 SPI 통신의 이러한 양태 및 다른 양태는 보안 모듈 또는 명령 필터의 다운스트림에서 메모리가 공격받을 수 없도록 보장할 수 있으며, 메모리에 대한 모든 읽기 또는 쓰기는 공격자가 변경할 수 없는 특정 주소에 바인딩되거나 제한된다. 다음 논의에서는 운영 환경, 예시적인 시스템 및 구성요소, 보안 SPI 통신의 예시적인 구현, 예시적인 방법, 운영 환경의 구성요소가 구현될 수 있는 시스템-온-칩(SoC)을 설명한다. 본 개시 내용의 맥락에서, 운영 환경은 단지 예로서 참조된다.These and other aspects of secure SPI communications described herein can ensure that memory cannot be attacked downstream of a security module or command filter, and that any reads or writes to memory must be addressed to a specific address that cannot be changed by the attacker. bound to or restricted to. The following discussion describes an operating environment, example systems and components, example implementations of secure SPI communications, example methods, and a system-on-chip (SoC) in which components of the operating environment may be implemented. In the context of this disclosure, the operating environment is referenced by way of example only.
예시적인 환경Exemplary environment
도 1은 보안 SPI 통신 및 연관된 통신 무결성 체계의 양태가 구현될 수 있는 장치(102)를 포함하는 예시적인 환경(100)을 도시한다. 장치(102)는 임의의 적합한 디바이스로서 구현될 수 있으며, 그 중 일부는 스마트폰(102-1), 태블릿 컴퓨터(102-2), 랩톱 컴퓨터(102-3), 게임 콘솔(102-4), 데스크톱 컴퓨터(102-5), 서버 컴퓨터(102-6), 웨어러블 컴퓨팅 디바이스(102-7)(예: 스마트 시계), 광대역 라우터(102-8)(예: 모바일 핫스팟)로 예시된다. 도시되지는 않았지만, 장치(102)는 모바일 스테이션(예: 고정 또는 모바일 STA), 모바일 통신 디바이스, 클라이언트 디바이스, 사용자 장비, 모바일 폰, 엔터테인먼트 디바이스, 모바일 게임 콘솔, 개인용 미디어 디바이스, 미디어 재생 디바이스, 건강 모니터링 디바이스, 드론, 카메라, 무선 인터넷 접속 및 브라우징이 가능한 인터넷 가전기기, IoT 디바이스 및/또는 기타 유형의 전자 디바이스 중 임의의 것으로 구현될 수도 있다. 장치(102)는 다른 기능을 제공할 수도 있고, 명확성 또는 시각적 간결성을 위해 도 1에서 생략된 구성요소 또는 인터페이스를 포함할 수도 있다. 1 depicts an example environment 100 that includes a device 102 in which aspects of secure SPI communications and associated communication integrity schemes may be implemented. Apparatus 102 may be implemented as any suitable device, some of which include smartphone 102-1, tablet computer 102-2, laptop computer 102-3, and game console 102-4. , a desktop computer 102-5, a server computer 102-6, a wearable computing device 102-7 (e.g., a smart watch), and a broadband router 102-8 (e.g., a mobile hotspot). Although not shown, device 102 may be a mobile station (e.g., fixed or mobile STA), mobile communication device, client device, user equipment, mobile phone, entertainment device, mobile gaming console, personal media device, media playback device, health It may be implemented as any of monitoring devices, drones, cameras, Internet appliances capable of wireless Internet access and browsing, IoT devices, and/or other types of electronic devices. Device 102 may provide other functionality and may include components or interfaces omitted from Figure 1 for clarity or visual brevity.
장치(102)는 메모리 매체 또는 저장 매체를 포함할 수 있는, 하나 이상의 프로세서들(106) 및 메모리 매체 또는 저장 매체를 포함할 수 있는 컴퓨터 판독가능 매체(CRM(108))를 활용하는 집적 회로(104)를 포함한다. 프로세서들(106)은 범용 프로세서(예를 들어, 멀티코어 중앙 프로세싱 유닛(CPU) 또는 애플리케이션 프로세서(AP)의), 애플리케이션-특정 집적 회로(ASIC), 그래픽 프로세싱 유닛(GPU), 또는 장치(102)의 다른 구성요소가 통합된 시스템 온 칩(SoC)으로서 구현될 수 있다. 보안 SPI 통신의 양태에서, 프로세서들(106) 중 하나 이상은 본 개시 전반에 걸쳐 설명된 바와 같은 무결성 기능을 포함할 수도 있다.Device 102 includes an integrated circuit (CRM) utilizing one or more processors 106, which may include a memory medium or storage medium, and a computer-readable medium (CRM 108), which may include a memory medium or storage medium. 104). Processors 106 may be a general-purpose processor (e.g., a multi-core central processing unit (CPU) or an application processor (AP)), an application-specific integrated circuit (ASIC), a graphics processing unit (GPU), or a device 102 ) can be implemented as a system-on-a-chip (SoC) with other components integrated. In an aspect of secure SPI communication, one or more of processors 106 may include integrity functionality as described throughout this disclosure.
CRM(108)은 읽기 전용 메모리(ROM), 프로그램 가능 ROM(PROM), 랜덤 액세스 메모리(RAM), 동적 RAM(DRAM), 정적 RAM(SRAM) 또는 플래시 메모리(예: SPI 플래시 디바이스 또는 칩)과 같은 임의의 적절한 유형의 메모리 매체 또는 저장 매체를 포함할 수 있다. 본 논의의 맥락에서, 장치(102)의 컴퓨터 판독가능 매체(108)는 일시적인 신호 또는 반송파를 포함하지 않는 적어도 하나의 하드웨어 기반 또는 물리적 저장 디바이스로서 구현된다. 장치(102)의 애플리케이션, 펌웨어, 및/또는 운영 시스템(미도시)은 본 명세서에 설명된 다양한 기능을 제공하기 위해 프로세서(106)에 의해 실행될 수 있는 프로세서 실행가능 명령어들로서 컴퓨터 판독가능 매체(108)에 구현될 수 있다. 컴퓨터 판독가능 매체(108)는 또한 장치(102)의 애플리케이션, 펌웨어 또는 운영 시스템을 통해 액세스가능한 사용자 데이터 또는 사용자 매체와 같은 디바이스 데이터(110)를 저장할 수 있다.CRM 108 may include read-only memory (ROM), programmable ROM (PROM), random access memory (RAM), dynamic RAM (DRAM), static RAM (SRAM), or flash memory (e.g., SPI flash device or chip). It may include any suitable type of memory medium or storage medium, such as: In the context of this discussion, computer-readable medium 108 of device 102 is implemented as at least one hardware-based or physical storage device that does not contain a transient signal or carrier wave. The applications, firmware, and/or operating system (not shown) of device 102 may be comprised of computer-readable media 108 as processor-executable instructions that can be executed by processor 106 to provide various functions described herein. ) can be implemented. Computer-readable medium 108 may also store device data 110, such as user data or user media, accessible through applications, firmware, or operating system of device 102.
이 예에서, 집적 회로(104)는 보안 회로(112)를 포함한다. 장치(102), 집적 회로(104), 또는 보안 회로(112)는 보안 암호화 프로세서를 구현할 수 있다. 보안 회로(112)는 하나 이상의 회로 구성요소(114), 예를 들어 회로 구성요소(114-1) 내지 회로 구성요소(114-n)를 사용하여 구현될 수 있다. 회로 구성요소(114)는 장치(102)의 기능을 활성화하기 위해 임의의 수의 동작을 수행하도록 구성될 수 있다. 회로 구성요소의 예에는 도 2에 설명된 바와 같은 프로세서 및 다중 기능 구성요소, 주변 장치, 및/또는 IP 블록이 포함된다. 보안 회로(112)는 예를 들어 보호된 엔클레이브(enclave), 신뢰할 수 있는 칩 플랫폼, 하드웨어 기반 신뢰 루트(RoT) 칩(예: 실리콘 RoT) 등으로 구현될 수 있다. 보안 회로(112)가 전자 디바이스에 통합되는 방법 또는 위치에 관계없이, 보안 회로(112)는 보안 SPI 통신과 관련하여 설명된 바와 같이 SPI 버스 또는 인터커넥트를 통해 발행된 공격 또는 악의적인 명령과 같은 다양한 유형의 공격에 대응하거나 저지할 수 있다.In this example, integrated circuit 104 includes security circuitry 112. Device 102, integrated circuit 104, or security circuitry 112 may implement a secure cryptographic processor. The security circuit 112 may be implemented using one or more circuit components 114, for example, circuit components 114-1 through 114-n. Circuit components 114 may be configured to perform any number of operations to activate the functionality of device 102. Examples of circuit components include processors and multi-function components, peripherals, and/or IP blocks as illustrated in FIG. 2. The security circuit 112 may be implemented, for example, as a protected enclave, a trusted chip platform, a hardware-based root of trust (RoT) chip (e.g., a silicon RoT), etc. Regardless of how or where security circuitry 112 is integrated into an electronic device, security circuitry 112 is capable of protecting against various threats, such as attacks or malicious commands issued over the SPI bus or interconnect, as described with respect to secure SPI communications. It can respond to or block certain types of attacks.
양태에서, 보안 회로(112)는 보안 회로(112), RoT 회로, 집적 회로(104) 및/또는 장치(102)의 각각의 기능을 제공하거나 구현하는 회로 구성요소(114-1 내지 114-n)를 포함한다. 보안 SPI 통신의 양태를 구현하기 위해, 회로 구성요소(114)는 보안 SPI 통신 모듈의 일부로서 구현될 수 있는 SPI 명령 필터(116) 및 SPI 클록 컨트롤러(118)를 포함한다. 양태에서, SPI 명령 필터(116)는 장치(102)의 호스트와 장치(102)의 플래시 메모리 모듈(예: CRM(108))에 의해 교환되는 통신들을 모니터링한다. 일반적으로 SPI 명령 필터(116)는 호스트가 송신한 통신들의 각 명령들을 플래시 메모리 모듈이 실행하도록 승인되지 않은 명령들을 나타내는 정보와 비교한다. 비교에 기초하여, SPI 명령 필터(116)는 각각의 명령들 중 하나가 플래시 메모리 모듈이 실행하도록 승인되지 않은 명령들(예: 쓰기 상태 레지스터 명령) 중 하나라고 결정한다. 결정에 응답하여, SPI 명령 필터(116)는 플래시 메모리 모듈의 칩 선택 라인을 디어설팅하거나 SPI 클록 컨트롤러(118)를 사용하여 플래시 메모리 모듈의 SPI 클록 라인을 게이팅하거나 정지할 수 있다. 그렇게 함으로써, SPI 명령 필터(116)는 플래시 메모리 모듈이 승인되지 않은 명령의 적어도 일부를 수신하거나 프로세싱하는 것을 방지할 수 있고, 이는 승인되지 않은 명령이 플래시 메모리 모듈의 보안을 구성하는 것을 방지할 수 있다. 대안적으로 또는 추가적으로, SPI 명령 필터(116) 또는 보안 SPI 통신 모듈은 플래시 메모리 모듈의 제1 파티션에 저장된 바이너리 이미지의 무결성을 검증할 수 있다. 무결성 검증이 실패하면, SPI 명령 필터(116)는 SPI 인터커넥트 트랜잭션의 주소를 변경하여 플래시 메모리 모듈의 제2 파티션으로부터 또 다른 바이너리 이미지가 로드되도록 하여 호스트가 검증되지 않고 손상되었을 가능성이 있는 바이너리 이미지를 제1 파티션으로부터 로드하는 것을 방지할 수 있다. 이는 보안 SPI 통신을 가능하게 하는 데 유용한 엔터티의 몇 가지 예일 뿐이며, 그 구현 및 사용은 다양하며 본 개시 전반에 걸쳐 설명된다.In an aspect, the security circuitry 112 includes circuit components 114-1 through 114-n that provide or implement the respective functions of the security circuitry 112, the RoT circuitry, the integrated circuit 104, and/or the device 102. ) includes. To implement aspects of secure SPI communication, circuit components 114 include an SPI command filter 116 and an SPI clock controller 118, which may be implemented as part of a secure SPI communication module. In an aspect, SPI command filter 116 monitors communications exchanged by a host of device 102 and a flash memory module (e.g., CRM 108) of device 102. In general, the SPI command filter 116 compares each command in communications sent by the host with information indicating commands that the flash memory module is not authorized to execute. Based on the comparison, SPI command filter 116 determines that one of the respective commands is one of the commands that the flash memory module is not authorized to execute (e.g., a write status register command). In response to the decision, SPI command filter 116 may deassert the chip select line of the flash memory module or use SPI clock controller 118 to gate or disable the SPI clock line of the flash memory module. By doing so, the SPI command filter 116 may prevent the flash memory module from receiving or processing at least some of the unauthorized commands, which may prevent the unauthorized commands from configuring the security of the flash memory module. there is. Alternatively or additionally, SPI command filter 116 or a secure SPI communication module may verify the integrity of the binary image stored in the first partition of the flash memory module. If integrity verification fails, SPI command filter 116 changes the address of the SPI interconnect transaction to cause another binary image to be loaded from the second partition of the flash memory module, thereby preventing the host from receiving an unverified and possibly corrupted binary image. Loading from the first partition can be prevented. These are just a few examples of entities useful for enabling secure SPI communications, the implementation and use of which may vary and are described throughout this disclosure.
도시된 바와 같이, 보안 회로(112)는 보안 회로의 구성요소, 주변 장치 및/또는 목적지를 호스트 또는 호스트 인터페이스와 연결시킬 수 있는 인터커넥트(120)에 연결된다. 인터커넥트(120)는 예를 들어 버스, 스위칭 패브릭, 링크, 통신 채널, 또는 다양한 회로 구성요소가 통신할 수 있게 하는 버스 네트워크를 사용하여 구현될 수 있다. 일부 양태에서, 인터커넥트는 직렬 주변 장치 인터페이스 통신 표준에 따라 구현되는 SPI 인터커넥트 또는 버스를 포함한다. 일부 구현예에서, SPI 인터커넥트는 칩 선택 라인, 클록 라인 및 4개의 I/O 라인(예: S[3:0] 또는 D[3:0])을 포함한다. 회로 요소들 각각은 인터커넥트(120)에 직접적으로 또는 간접적으로 연결될 수 있다. 인터커넥트(120)는 회로 구성요소가 다른 디바이스 또는 데이터 네트워크와 통신할 수 있도록 장치(102)의 데이터 포트 또는 인터페이스와의 통신을 가능하게 할 수 있다.As shown, secure circuitry 112 is coupled to an interconnect 120 that may couple components of the secure circuitry, peripheral devices and/or destinations with a host or host interface. Interconnect 120 may be implemented using, for example, a bus, switching fabric, link, communication channel, or bus network that allows various circuit components to communicate. In some aspects, the interconnect includes an SPI interconnect or bus implemented in accordance with the Serial Peripheral Interface communication standard. In some implementations, the SPI interconnect includes a chip select line, a clock line, and four I/O lines (e.g., S[3:0] or D[3:0]). Each of the circuit elements may be connected directly or indirectly to interconnect 120. Interconnect 120 may enable communication with a data port or interface on device 102 to allow circuit components to communicate with other devices or data networks.
장치(102)는 또한 디스플레이(122), 트랜시버들(124), 입력/출력 포트들(I/O 포트들(126)) 및/또는 센서들(128)을 포함할 수 있다. 디스플레이(122)는 프로세서들(106) 중 하나(예: 그래픽 프로세싱 유닛(GPU))와 동작가능하게 연결될 수 있고, 장치(102)의 운영 시스템 또는 애플리케이션의 각각의 인터페이스를 그래픽으로 표시하도록 구성될 수 있다. 트랜시버들(124)은 임의의 적절한 통신 프로토콜에 따라 유선 또는 무선 네트워크를 통해 데이터(예를 들어, 디바이스 데이터(110))의 유선 또는 무선 통신을 가능하게 하도록 구성될 수 있다. 장치(102)의 I/O 포트들(126)은 범용 직렬 버스(USB) 포트, 동축 케이블 포트, 및 전자 장치를 키보드, 마이크, 카메라 등 과 같은 다양한 구성요소, 주변 장치 또는 액세서리에 연결하는 데 유용한 기타 직렬 또는 병렬 커넥터(내부 커넥터 포함)를 포함할 수 있다.Device 102 may also include a display 122, transceivers 124, input/output ports (I/O ports 126), and/or sensors 128. Display 122 may be operably coupled to one of the processors 106 (e.g., a graphics processing unit (GPU)) and may be configured to graphically display a respective interface of an operating system or application of device 102. You can. Transceivers 124 may be configured to enable wired or wireless communication of data (e.g., device data 110) over a wired or wireless network according to any suitable communication protocol. I/O ports 126 of device 102 include universal serial bus (USB) ports, coaxial cable ports, and for connecting electronic devices to various components, peripherals, or accessories, such as keyboards, microphones, cameras, etc. Other useful serial or parallel connectors (including internal connectors) may be included.
장치(102)는 또한 장치(102)가 동작하는 환경의 다양한 특성, 변화, 자극 또는 특성을 장치(102)가 감지할 수 있게 하는 센서들(128)을 포함한다. 예를 들어, 센서들(128)은 다양한 모션 센서, 주변 광 센서, 음향 센서, 정전식 센서, 적외선 센서, 온도 센서, 레이더 센서 또는 자기 센서를 포함할 수 있다. 대안적으로 또는 추가적으로, 센서들(128)은 터치 감지, 제스처 감지 또는 근접 감지를 통해 장치(102)의 사용자와 인터렉션하거나 사용자로부터 입력을 수신할 수 있다.Device 102 also includes sensors 128 that enable device 102 to detect various characteristics, changes, stimuli, or characteristics of the environment in which device 102 operates. For example, sensors 128 may include various motion sensors, ambient light sensors, acoustic sensors, capacitive sensors, infrared sensors, temperature sensors, radar sensors, or magnetic sensors. Alternatively or additionally, sensors 128 may interact with or receive input from a user of device 102 through touch sensing, gesture sensing, or proximity sensing.
예시적인 회로 구성요소Exemplary Circuit Components
도 2는 보안 SPI 통신의 양태를 지원하기 위해 구현될 수 있는 프로세서 및 다중 회로 구성요소를 포함하는 예시적인 보안 회로(112)를 200으로 도시한다. 도시된 바와 같이, 보안 회로(112)는 인터커넥트(120)에 연결된 프로세서(106)를 포함한다. 프로세서(106), 다수의 메모리, 및 다수의 다른 회로 구성요소(114) 각각은 인터커넥트(120)에 직접적으로 또는 간접적으로 연결될 수 있다. 양태에서, 도 2의 구성요소는 신뢰 루트(root-of-trust) 및/또는 기타 보안 암호화 기능을 구현하는 보안 컴퓨팅 플랫폼 또는 보안 시스템 온 칩으로 구현될 수 있다. 대안적으로 또는 추가적으로, 도 2의 구성요소는 인터커넥트(120)에 의해 연결되는 시스템의 하나 이상의 IC, 주변 블록 또는 IP 블록으로 구현될 수 있으며, 이는 시스템의 구성요소 또는 IP 블록을 동작가능하게 연결하는 패브릭으로 구현될 수 있다.FIG. 2 depicts an example secure circuit 112 at 200 that includes a processor and multiple circuit components that can be implemented to support aspects of secure SPI communications. As shown, security circuitry 112 includes a processor 106 coupled to interconnect 120. Processor 106, multiple memories, and multiple other circuit components 114 may each be coupled directly or indirectly to interconnect 120. In aspects, the components of FIG. 2 may be implemented as a secure computing platform or secure system-on-a-chip that implements root-of-trust and/or other secure cryptographic functions. Alternatively or additionally, the components of FIG. 2 may be implemented with one or more ICs, peripheral blocks, or IP blocks of the system connected by interconnect 120, which operably connects the components or IP blocks of the system. It can be implemented as a fabric that
양태에서, 인터커넥트(120)는 보안 SPI 통신 모듈의 일부로서 구현될 수 있는 SPI 명령 필터(116) 및 SPI 클록 컨트롤러(118)를 포함하거나 이와 연결될 수 있다. 양태에서, SPI 명령 필터(116)는 시스템의 호스트와 시스템의 SPI 메모리 디바이스에 의해 교환되는 통신들을 모니터링한다. 일반적으로 SPI 명령 필터(116)는 호스트가 송신한 통신들의 각 명령들을 플래시 메모리 모듈이 실행하도록 승인되지 않은 명령들을 나타내는 정보와 비교한다. 비교에 기초하여, SPI 명령 필터(116)는 각각의 명령들 중 하나가 플래시 메모리 모듈이 실행하도록 승인되지 않은 명령들(예: 쓰기 상태 레지스터 명령) 중 하나라고 결정한다. 결정에 응답하여, SPI 명령 필터(116)는 플래시 메모리 모듈의 칩 선택 라인을 디어설팅하거나 SPI 클록 컨트롤러(118)를 사용하여 플래시 메모리 모듈의 SPI 클록 라인을 게이팅하거나 정지할 수 있다. 이는 SPI 명령 필터(116) 및 SPI 클록 컨트롤러(118)의 몇 가지 예일 뿐이며, 이들의 구현 및 사용은 다양하며 도 3-5 및 본 개시 전체를 참조하여 설명된다.In aspects, interconnect 120 may include or be coupled to an SPI command filter 116 and SPI clock controller 118, which may be implemented as part of a secure SPI communication module. In an aspect, SPI command filter 116 monitors communications exchanged by a host of the system and an SPI memory device of the system. In general, the SPI command filter 116 compares each command in communications sent by the host with information indicating commands that the flash memory module is not authorized to execute. Based on the comparison, SPI command filter 116 determines that one of the respective commands is one of the commands that the flash memory module is not authorized to execute (e.g., a write status register command). In response to the decision, SPI command filter 116 may deassert the chip select line of the flash memory module or use SPI clock controller 118 to gate or disable the SPI clock line of the flash memory module. These are just a few examples of SPI command filter 116 and SPI clock controller 118, the implementation and use of which may vary and are described with reference to Figures 3-5 and throughout this disclosure.
프로세서(106)는 인터커넥트(120)를 통해 회로 구성요소(114)와 연결될 수 있고/있거나 다른 구성요소 또는 인터페이스와 직접 연결될 수 있다. 도 2에 도시된 바와 같이, 시스템은 시스템의 호스트로서 기능할 수 있는 프로세서(106)와의 인터렉션을 가능하게 하는 인터커넥트(120)에 연결된 다중 회로 구성요소(114)를 포함할 수 있다. 이 예에서, 회로 구성요소(114)는 레지스터 파일(202) 및 다양한 메모리(204 내지 210)를 포함한다. 회로 구성요소(114)는 임의의 적절한 구성의 하나 이상의 메모리(예: CRM(108))를 포함할 수 있고 ROM(204), SRAM(206) 및 SPI 플래시 메모리(208)를 포함할 수 있다. 이 예에서, SPI 명령 필터(116) 및/또는 SPI 클록 컨트롤러(118)는 인터커넥트(120)와 SPI 플래시 메모리(208) 사이에 구현될 수 있다.Processor 106 may be coupled with circuit component 114 via interconnect 120 and/or directly connected to other components or interfaces. As shown in Figure 2, the system may include multiple circuit components 114 coupled to an interconnect 120 that enables interaction with a processor 106, which may function as a host of the system. In this example, circuit components 114 include a register file 202 and various memories 204-210. Circuit components 114 may include one or more memories (e.g., CRM 108) in any suitable configuration and may include ROM 204, SRAM 206, and SPI flash memory 208. In this example, SPI command filter 116 and/or SPI clock controller 118 may be implemented between interconnect 120 and SPI flash memory 208.
양태에서, SPI 플래시 메모리(208)는 시스템 또는 호스트의 정보를 저장하도록 구성된 제어 상태 레지스터(CSR)들 및 플래시 미디어를 포함한다. SPI 플래시 디바이스 또는 기타 메모리 주변 장치의 상태 레지스터에는 블록 보호, 섹터 보호, 상위/하위 범위 보호 등과 같이 다양한 메모리 섹션을 보호하거나 잠그도록 구성가능한 특정 보호 비트가 포함될 수 있다. 양태에서, SPI 명령 필터(116) 및 SPI 클록 컨트롤러(118)는 승인되지 않은 명령들이 SPI 플래시 메모리(208)에 의해 소비되는 것을 방지하고 SPI 플래시 메모리(208)의 CRS들의 설정을 변경하는 것을 방지할 수 있다. 쿼드 모드 액세스가 활성화된 경우와 같이, SPI 플래시 메모리(208)는 쓰기 방지 입력 노드를 포함하지 않거나 주변 블록의 쓰기 방지 입력 노드가 비활성화되는 경우도 있다. 도시되지는 않았지만, 회로 구성요소(114)는 다른 메모리(예: 일회성 프로그래밍가능 또는 DRAM 메모리) 및/또는 추가 직렬 주변 장치 인터페이스(SPI) 또는 USB 연결 메모리와 같은 다른 구성요소를 통해 연결된 메모리를 포함할 수 있다.In an aspect, SPI flash memory 208 includes flash media and control status registers (CSRs) configured to store information of a system or host. The status registers of an SPI flash device or other memory peripheral may contain specific protection bits that are configurable to protect or lock various memory sections, such as block protection, sector protection, upper/lower range protection, etc. In an aspect, SPI command filter 116 and SPI clock controller 118 prevent unauthorized commands from being consumed by SPI flash memory 208 and from changing the settings of CRSs of SPI flash memory 208. can do. In some cases, such as when quad mode access is enabled, the SPI flash memory 208 does not include a write-protect input node or the write-protect input nodes of surrounding blocks are disabled. Although not shown, circuit components 114 include other memory (e.g., one-time programmable or DRAM memory) and/or memory connected via other components, such as additional serial peripheral interface (SPI) or USB connected memory. can do.
도 2에 도시된 바와 같이, 회로 구성요소(114)는 또한 경보 핸들러(210), 고급 암호화 표준(AES) 유닛(AES 유닛(212)), 해시 기반 메시지 인증 코드(HMAC) 엔진(HMAC 엔진(214)) 및 직렬 주변 장치 인터페이스(SPI) 디바이스(SPI 디바이스(216))를 포함할 수 있다. 여기서, SPI 명령 필터(116) 및/또는 SPI 클록 컨트롤러(118)는 인터커넥트(120)와 SPI 디바이스(216) 사이에 구현될 수 있으며, 이는 SPI 디바이스(216)가 본 명세서에 설명된 승인되지 않은 명령들을 소비하는 것을 방지할 수 있음을 유의한다. 회로 구성요소(114)는 또한 범용 비동기 수신기/송신기(UART) 유닛(UART 유닛(218)), 범용 입력/출력(GPIO) 인터페이스(GPIO 인터페이스(220)), 핀 멀티플렉서(핀 mux(222)), 및 패드 컨트롤러(224)를 포함할 수 있다. 다중 회로 구성요소(114)는 다른 구성요소가 인증 토큰으로 사용하기 위해 높은 엔트로피 값을 획득할 수 있는 난수 생성기(RNG(226)) 및 타이머(228)(예: 감시 타이머)를 더 포함할 수 있다. 메모리 및 기타 구성요소(114)의 특정 예가 도 2에 도시되어 있지만, 보안 회로(112)의 주어진 구현은 프로세서, 컨트롤러, 메모리, 모듈 또는 그 복제물을 포함하는 주변 장치의 더 많거나, 더 적거나, 및/또는 상이한 인스턴스를 포함할 수 있다.As shown in Figure 2, circuit components 114 also include an alert handler 210, an Advanced Encryption Standard (AES) unit (AES unit 212), a Hash-based Message Authentication Code (HMAC) engine (HMAC engine ( 214) and a serial peripheral interface (SPI) device (SPI device 216). Here, an SPI command filter 116 and/or SPI clock controller 118 may be implemented between interconnect 120 and SPI device 216, which may prevent SPI device 216 from performing unauthorized actions as described herein. Note that you can prevent consuming instructions. Circuit components 114 also include a universal asynchronous receiver/transmitter (UART) unit (UART unit 218), a general purpose input/output (GPIO) interface (GPIO interface 220), and a pin multiplexer (pin mux 222). , and may include a pad controller 224. The multi-circuit component 114 may further include a random number generator (RNG 226) and a timer 228 (e.g., watchdog timer) that can obtain high entropy values for use by other components as authentication tokens. there is. Although specific examples of memory and other components 114 are shown in Figure 2, a given implementation of security circuitry 112 may include more, fewer, or peripheral devices, including processors, controllers, memory, modules, or duplicates thereof. , and/or may include different instances.
예시된 회로 구성요소는 하나 이상의 클록 신호에 기초하여 동기식으로 동작될 수 있다. 도 2에 도시되지는 않았지만, 보안 회로(112)는 클록 신호를 생성하기 위한 적어도 하나의 클록 생성기를 포함할 수 있거나, 하나 이상의 개별 구성요소를 서로 독립적으로, 다수의 구성요소를 공동으로, 또는 전체 IC 칩을 리셋하기 위한 리셋 회로를 포함할 수 있다. 대안적으로, 보안 회로(112)는 보안 회로(112) 외부의 소스로부터 적어도 하나의 클록 신호 또는 리셋 신호를 수신할 수 있으며, 소스는 별도의 칩 상에 있을 수도 있고 그렇지 않을 수도 있다. 하나 이상의 개별 구성요소(114)는 각각의 개별 클록 도메인에서 동작할 수 있다. 예를 들어, 회로 구성요소는 각 구성요소에 로컬인 클록에 동기화될 수 있다. 서로 다른 클럭 도메인의 구성요소는 서로 비동기식으로 동작하거나 통신할 수 있다.The illustrated circuit components may operate synchronously based on one or more clock signals. Although not shown in Figure 2, security circuit 112 may include at least one clock generator for generating a clock signal, or one or more individual components independently of one another, multiple components jointly, or It may include a reset circuit to reset the entire IC chip. Alternatively, security circuitry 112 may receive at least one clock signal or reset signal from a source external to security circuitry 112, which may or may not be on a separate chip. One or more individual components 114 may operate in each individual clock domain. For example, circuit components can be synchronized to a clock that is local to each component. Components in different clock domains can operate or communicate asynchronously with each other.
예시된 구성요소의 예시적인 구현이 아래에 설명된다. 프로세서(106)는 호스트 또는 버스 컨트롤러의 기능이 구현되는 보안 회로(112)에 대한 "메인", "중앙" 또는 "코어" 프로세서로 구현될 수 있다. 프로세서(106)는 단지 예로서, 다단계 파이프라인을 갖는 32비트, 순차(in-order) 축소 명령어 세트 컴퓨팅(reduced instruction set computing)(RISC) 코어로 구현될 수 있다. 예를 들어, RISC-V 기능을 통해 프로세서는 M(머신) 및 U(사용자) 모드를 구현할 수 있다. (예를 들어, 액티브 로우 리셋 핀의 디어설션(de-assertion)을 통해) 리셋 핀(도시되지 않음)을 활성화하면 프로세서(106)로 하여금 리셋을 종료하고 리셋 벡터에서 코드 실행을 시작하게 한다. 리셋 벡터는 ROM(204)에서 시작될 수 있으며, 이는 내장된 플래시 또는 시스템의 플래시 메모리로 점프하기 전에 코드를 검증한다. 즉, 코드는 리셋이 릴리즈되기 전에 e 플래시에 인스턴스화되었을 것으로 예상된다. 경우에 따라, 다양한 회로 구성요소 간의 상호 운용성을 지원하기 위해 보안 회로(112) 전체의 리셋은 호환성 사양에 따라 비동기식 액티브 로우로 만들어질 수 있다. 보안 대책으로서 경보 핸들러(210)에 의해 리셋이 생성될 수 있다; 워치독 타이머에 의해; 기타 등등. 리셋 신호는 메모리 중 하나 또는 다른 구성요소(114) 중 하나와 같은 다른 회로 구성요소로 송신될 수도 있다.Exemplary implementations of the illustrated components are described below. Processor 106 may be implemented as the “main,” “central,” or “core” processor for security circuitry 112 on which the functionality of a host or bus controller is implemented. Processor 106 may be implemented as a 32-bit, in-order reduced instruction set computing (RISC) core with a multi-stage pipeline, by way of example only. For example, RISC-V features allow a processor to implement M (machine) and U (user) modes. Activating a reset pin (not shown) (e.g., through de-assertion of an active low reset pin) causes processor 106 to exit reset and begin executing code at the reset vector. The reset vector may originate from ROM 204, which verifies the code before jumping to embedded flash or the system's flash memory. That is, the code is expected to have been instantiated in e-flash before the reset is released. In some cases, to support interoperability between various circuit components, a reset of the entire security circuit 112 may be made asynchronous active low according to compatibility specifications. As a security measure a reset may be generated by the alarm handler 210; by watchdog timer; Etc. The reset signal may also be sent to another circuit component, such as one of the memories or one of the other components 114.
프로세서(106)에는 디버그 모듈(230)(DM)과 인터럽트 컨트롤러(232)(ItC)가 연결되어 있으며, 이들 중 어느 하나로 적합하게 만들어질 수 있다. 디버그 모듈(230)은 프로세서(106)에 대한 디버그 액세스를 제공한다. IC의 특정 핀과 인터페이싱함으로써, 디버그 모듈(230)의 로직은 프로세서(106)가 디버그 모드에 들어갈 수 있게 하고, (예를 들어, 명령을 에뮬레이팅(emulating)함으로써) 디바이스 또는 메모리에 코드를 주입하는 기능을 제공한다. 인터럽트 컨트롤러(232)는 프로세서(106)에 근접하게 배치될 수 있다. 인터럽트 컨트롤러(232)는 보안 회로(112) 내로부터 인터럽트 소스의 벡터를 수용할 수 있다. 인터럽트 컨트롤러(232)는 또한 핸들링을 위해 인터럽트를 프로세서(106)에 포워딩하기 전에 인터럽트에 레벨링 및 우선순위를 할당할 수 있다.Coupled to the processor 106 is a debug module 230 (DM) and an interrupt controller 232 (ItC), either of which can be adapted to suit. Debug module 230 provides debug access to processor 106. By interfacing with specific pins of the IC, the logic of debug module 230 allows processor 106 to enter debug mode and inject code into the device or memory (e.g., by emulating instructions). Provides the function to Interrupt controller 232 may be placed proximate to processor 106. Interrupt controller 232 may accept a vector of interrupt sources from within security circuitry 112. Interrupt controller 232 may also assign a level and priority to the interrupt before forwarding it to processor 106 for handling.
프로세서(106)는 임의의 원하는 수준의 성능을 제공하거나 임의의 내부 회로 구성요소를 포함할 수 있다. 예를 들어, 프로세서(106)는 적어도 하나의 산술 논리 유닛(ALU)(예를 들어, 취해진 조건부 분기에 대한 지연시간 사이클을 제거하기 위해 분기 대상을 계산하기 위한 "추가" ALU를 포함함), 레지스터 파일, 제어 유닛, 입출력(I/O) 유닛, 다중 파이프라인 단계 등을 포함할 수 있다. 파이프라인 단계가 여러 개인 경우 파이프라인은 레지스터 라이트백(writeback)을 수행하여 로드 및 저장의 지연시간 사이클을 줄이고 요청 후 사이클마다 로드 또는 저장에 대한 응답을 사용할 수 있는 파이프라인 스톨(stall)을 방지할 수 있다. 프로세서(106)는 단일 사이클 곱셈기를 구현하거나 저장소에 대한 오류 응답에 대한 부정확한 예외를 생성할 수 있으며, 이는 프로세서가 응답을 기다리지 않고 저장소를 지나 계속 실행하도록 허용한다. 도시되지는 않았지만, 프로세서(106) 구체적으로, 또는 보안 회로(112)는 일반적으로, 명령어에 대한 단일 사이클 액세스 시간을 제공하기 위해 명령어 캐시를 포함할 수 있다.Processor 106 may provide any desired level of performance or may include any internal circuit components. For example, processor 106 may include at least one arithmetic logic unit (ALU) (e.g., an “extra” ALU for calculating branch targets to eliminate latency cycles for taken conditional branches); It may contain register files, control units, input/output (I/O) units, multiple pipeline stages, etc. When there are multiple pipeline stages, the pipeline performs register writebacks to reduce latency cycles of loads and stores and prevent pipeline stalls where a response to a load or store may be available every cycle after the request. can do. Processor 106 may implement a single cycle multiplier or generate an imprecise exception on an error response to the store, which allows the processor to continue execution past the store without waiting for a response. Although not shown, processor 106 specifically, or security circuitry 112 generally, may include an instruction cache to provide single cycle access time for instructions.
ALU는 수신된 데이터에 대해 산술 및 논리 연산을 수행하도록 구성될 수 있다. 도 3a 및 도 3b를 참조하여 추가로 설명되는, 레지스터 파일(예: 레지스터 파일(202))은 프로그램 또는 기능 프로세싱 중 빠른 데이터 액세스를 위해 구성된 고속 반일시적 메모리 역할을 하는, 프로세서 레지스터(예: 제어 레지스터)의 어레이일 수 있다. 레지스터 파일은 프로세서(106)의 ALU에 단단히 연결될 수 있다. 데이터에 대한 액세스를 더욱 용이하게 하기 위해, 레지스터 파일은 ALU 및/또는 실행 유닛이 단일 사이클에서 다수의 피연산자를 동시에 검색할 수 있도록 하는 다수의 읽기 포트 또는 다수의 쓰기 포트를 포함할 수 있다. 레지스터 파일은 데이터의 비트 읽기 및 쓰기를 가속화하기 위해 플립플롭으로 구성될 수 있다. 제어 유닛은 시스템(들) 전반에 걸쳐 데이터의 흐름을 제어하도록 구성될 수 있다. I/O 유닛은 디바이스 또는 보안 회로(112)의 다른 구성요소와 동작 가능하게 인터페이스되는 포트를 포함할 수 있다. 프로세서(106), 회로 구성요소(114), SPI 명령 필터(116), SPI 클록 컨트롤러(118), 또는 보안 SPI 통신 모듈의 추가적인 양태가 도 3-9 및 본 개시 전반에 걸쳐 설명된다.The ALU may be configured to perform arithmetic and logical operations on received data. A register file (e.g., register file 202), further described with reference to FIGS. 3A and 3B, is a processor register (e.g., control register) that serves as a high-speed semi-transitory memory configured for fast data access during program or function processing. It may be an array of registers). The register file may be tightly coupled to the ALU of processor 106. To further facilitate access to data, the register file may include multiple read ports or multiple write ports that allow the ALU and/or execution unit to retrieve multiple operands simultaneously in a single cycle. Register files can be configured with flip-flops to accelerate reading and writing bits of data. The control unit may be configured to control the flow of data throughout the system(s). I/O units may include ports that are operably interfaced with devices or other components of security circuitry 112. Additional aspects of the processor 106, circuit component 114, SPI command filter 116, SPI clock controller 118, or secure SPI communication module are described in Figures 3-9 and throughout this disclosure.
도 3은 하나 이상의 양태에 따라 SPI 명령 필터링을 구현하는 시스템 구성요소의 예시적인 구성을 300으로 도시한다. 도 3의 예시적인 인터포저(interposer) 및/또는 다른 구성요소는 본 개시 전반에 걸쳐 설명된 임의의 다른 구성요소, 아키텍처, 엔티티 또는 시스템과 연관되어 구현될 수 있다. 일반적으로, 보안 SPI 통신 모듈(302)(예를 들어, RoT 회로의 SPI 필터)은 인터포저(304) 상에 구현되거나 호스트 시스템(306)과 SPI 플래시 디바이스(308)와 같은 다운스트림 주변 장치 사이의 SPI 기반 인터커넥트와 동작가능하게 연관된다. 이 예에서, 보안 SPI 통신 모듈(302)은 SPI 명령 필터(116)(또는 SPI 명령 검출기) 및 SPI 클록 컨트롤러(118)의 인스턴스를 포함하며, 이들은 클록 게이팅 셀(미도시)을 포함하거나 구현될 수 있다.3 illustrates at 300 an example configuration of system components that implement SPI command filtering in accordance with one or more aspects. The example interposer and/or other components of FIG. 3 may be implemented in conjunction with any other component, architecture, entity, or system described throughout this disclosure. Typically, a secure SPI communication module 302 (e.g., an SPI filter in a RoT circuit) is implemented on the interposer 304 or between the host system 306 and a downstream peripheral, such as an SPI flash device 308. Operablely associated with an SPI-based interconnect of In this example, the secure SPI communication module 302 includes an instance of an SPI command filter 116 (or SPI command detector) and an SPI clock controller 118, which may include or be implemented with a clock gating cell (not shown). You can.
양태에서, 호스트 시스템(306)과 SPI 플래시 디바이스(308) 사이의 SPI 인터페이스는 SPI 클록 라인(310)(SCK 310), SPI 칩 선택 라인(312)(/CS 312) 및 직렬 데이터 라인(314)(S[3:0] 314)을 포함하지만, 보안 SPI 통신 양태에 따라 다른 인터커넥트 또는 패브릭 구성이 구현될 수도 있다. 일부 경우에, 인터포저(304)는 호스트 시스템(306)과 SPI 플래시 디바이스(308) 사이에 교환되는 통신들의 명령들을 모니터링하도록 구성된 실리콘 RoT 회로 또는 다른 보안 회로의 일부로 구현될 수 있다. 도 3에 도시된 바와 같이, 보안 SPI 통신 모듈(302) 또는 인터포저(304)는 SPI 명령 필터(116) 및 SPI 클록 컨트롤러(118)를 포함할 수 있다. 양태에서, SPI 명령 필터는 직렬 데이터 라인(314)에 액세스하여 SPI 인터페이스를 통해 SPI 플래시 디바이스(308)로 이동하는 명령 및 연산코드를 모니터링한다. SPI 명령 필터(116)는 논리 게이트(318) 또는 칩 선택 라인(312)에 연결된 논리 회로에 명령 필터링된 신호(316)(필터링된(316))를 제공하기 위한 출력을 포함할 수 있다. 일부 경우에, 논리 게이트(318)는 배타적 OR 게이트, OR 게이트, AND 게이트, 멀티플렉서, 논리 게이트의 조합, 또는 임의의 다른 적합한 논리를 포함한다. 일반적으로, 명령 필터링된 신호 라인의 상태를 변경함으로써, SPI 명령 필터는 SPI 플래시 디바이스(308)가 SPI 인터페이스의 데이터 라인(312)을 통해 통신되는 명령 또는 연산코드를 수신, 소비 또는 프로세싱하는 것을 방지하기 위해 칩 선택 라인(312)의 상태를 변경(예를 들어, 디어설트)할 수 있다. 대안적으로 또는 추가적으로, SPI 명령 필터(116)는 SPI 클록 컨트롤러(118)에 클록 활성화 신호(320)를 제공하기 위한 출력을 포함할 수 있다. 승인되지 않은 명령이 검출되면, SPI 명령 필터(116)는 클록 활성화 라인(320)의 상태를 변경하여 SPI 클록 컨트롤러(118)로 하여금 SPI 플래시 디바이스(308)에 전파되는 SPI 클록(310)을 게이팅하게 할 수 있다.In an aspect, the SPI interface between host system 306 and SPI flash device 308 includes SPI clock line 310 (SCK 310), SPI chip select line 312 (/CS 312), and serial data line 314. (S[3:0] 314), but other interconnect or fabric configurations may be implemented depending on the secure SPI communication aspect. In some cases, interposer 304 may be implemented as part of a silicon Root-of-Test circuit or other security circuitry configured to monitor commands in communications exchanged between host system 306 and SPI flash device 308. As shown in Figure 3, the secure SPI communication module 302 or interposer 304 may include an SPI command filter 116 and an SPI clock controller 118. In an aspect, the SPI command filter accesses the serial data line 314 to monitor commands and opcodes traveling through the SPI interface to the SPI flash device 308. SPI command filter 116 may include an output for providing a command filtered signal 316 (filtered 316) to logic gate 318 or a logic circuit coupled to chip select line 312. In some cases, logic gate 318 includes an exclusive OR gate, OR gate, AND gate, multiplexer, combination of logic gates, or any other suitable logic. Generally, by changing the state of the command filtered signal line, the SPI command filter prevents the SPI flash device 308 from receiving, consuming, or processing commands or opcodes communicated over the data line 312 of the SPI interface. To do this, the state of the chip select line 312 can be changed (eg, deassert). Alternatively or additionally, SPI command filter 116 may include an output to provide a clock enable signal 320 to SPI clock controller 118. When an unauthorized command is detected, SPI command filter 116 changes the state of clock enable line 320 to cause SPI clock controller 118 to gate the SPI clock 310 propagated to SPI flash device 308. You can do it.
도 3의 맥락에서, SPI 명령 필터(116)는 호스트 시스템(306)과 SPI 플래시 디바이스(308) 사이에 교환되는 통신들을 모니터링하거나 스누핑할 수 있다. SPI 명령 필터(116)는 호스트 시스템에 의해 송신된 통신들의 각 명령들 또는 연산코드들을 SPI 플래시 디바이스가 실행하도록 승인되거나 승인되지 않은 명령들을 나타내는 정보(예를 들어, 명령의 포함 또는 제외 테이블)와 비교할 수 있다. 통신 명령이 승인된 경우, SPI 명령 필터(116)는 명령 또는 연산코드가 SPI 플래시 디바이스(306)로 다운스트림을 패스할 수 있도록 한다. 대안적으로, SPI 명령 필터(116)는 명령 또는 연산코드가 연산코드 또는 명령의 8번째 비트와 같이 SPI 플래시 디바이스(308)에 의해 실행되도록 승인되지 않았다고 결정할 수 있다. 결정에 응답하여, SPI 명령 필터(116)는 논리 게이트(318)를 사용하여 칩 선택 라인(312)을 디어설팅하고 SPI 클록 컨트롤러(118)를 사용하여 SPI 클록 신호(310)를 SPI 플래시 디바이스에 게이팅한다. 일반적으로, 명령 또는 연산코드의 8번째 비트 또는 비트 이전에 다운스트림 SPI 플래시 디바이스에 대한 클록 선택 라인(312)이 디어설팅되면, SPI 플래시 디바이스(308)는 명령 또는 그 일부를 폐기할 것이다. 일부 경우에, SPI 명령 필터(116)가 칩 선택 라인(312)만을 토글하는 경우, 칩 선택 라인은 연산코드의 8번째 비트로부터의 조합 로직으로 인해 글리치가 발생하기 쉬울 수 있다. 일반적으로, 칩 선택 라인(312)의 제어는 8번째 연산코드가 SPI 플래시 디바이스(308)에 의해 이미 수신되었을 때 너무 늦을 수 있으므로 글리치가 발생하지 않도록 등록된(registered) 출력이어야 한다. 이러한 글리치 이슈를 해결하기 위해, SPI 명령 필터(116)는 SPI 클록(310)을 게이팅하여 글리치를 도입하지 않고 칩 선택 라인(312)을 제어하거나 토글할 수 있으며, 이는 SPI 플래시 디바이스(308)가 연산코드 또는 명령의 8번째 비트를 수신하거나 소비하는 것이 방지되는 것을 보장할 수 있다.In the context of FIG. 3, SPI command filter 116 may monitor or snoop on communications exchanged between host system 306 and SPI flash device 308. The SPI command filter 116 includes information (e.g., a table of inclusion or exclusion of commands) indicating commands that are or are not authorized for the SPI flash device to execute each command or opcode in communications transmitted by the host system. You can compare. If the communication command is approved, SPI command filter 116 allows the command or opcode to pass downstream to SPI flash device 306. Alternatively, SPI command filter 116 may determine that an instruction or opcode is not authorized for execution by SPI flash device 308, such as the 8th bit of the opcode or instruction. In response to the decision, SPI command filter 116 uses logic gate 318 to deassert chip select line 312 and uses SPI clock controller 118 to send SPI clock signal 310 to the SPI flash device. Gating. In general, if the clock select line 312 for a downstream SPI flash device is deasserted before the eighth bit or bits of the command or opcode, the SPI flash device 308 will discard the command or portion thereof. In some cases, if the SPI command filter 116 toggles only the chip select line 312, the chip select line may be prone to glitches due to the combinational logic from the 8th bit of the opcode. Typically, control of the chip select line 312 should be a registered output to avoid glitches as it may be too late when the 8th opcode has already been received by the SPI flash device 308. To address this glitch issue, the SPI command filter 116 can gate the SPI clock 310 to control or toggle the chip select line 312 without introducing a glitch, which allows the SPI flash device 308 to It can be ensured that receiving or consuming the 8th bit of an opcode or instruction is prevented.
도 4는 보안 SPI 통신의 양태를 구현하기 위한 클록 게이팅 및 명령 필터링 기능을 포함하는 예시적인 시스템을 400으로 도시한다. 도 3의 예시적인 신뢰 루트 회로 및/또는 다른 구성요소는 본 개시 전반에 걸쳐 설명된 임의의 다른 구성요소, 아키텍처, 엔티티 또는 시스템과 연관되어 구현될 수 있다. 예시적인 시스템(400)은 호스트 시스템(306)과 SPI 플래시 디바이스(308) 사이에 또는 이와 결합되는 신뢰 루트 회로(402)를 포함한다. 일반적으로, SPI 명령 필터(116) 및/또는 보안 SPI 통신 모듈(302)은 본 명세서에 설명된 보안 SPI 인터페이스의 양태를 구현할 수 있다. SPI 명령 필터(116)는 보안 직렬 주변 장치 인터페이스(SPI) 디바이스 패스스루 모듈(예를 들어, 보안 SPI 통신 모듈(302))로 구현될 수 있다. 예를 들어, 이 보안 SPI 디바이스 패스스루 모듈은 호스트 시스템에서 SPI 플래시 디바이스로의 SPI 트랜잭션을 스누핑하고 승인되지 않은 트래픽에 개입(intervening)하기 위한 기능을 포함할 수 있다. 이 모듈은 유해한 읽기/쓰기 요청을 차단하거나 호스트 시스템에 정품 바이너리 이미지가 반환되도록 보장하기 위해 구현될 수 있다.4 illustrates an example system at 400 that includes clock gating and command filtering functions for implementing aspects of secure SPI communications. The example root of trust circuit of FIG. 3 and/or other components may be implemented in conjunction with any other component, architecture, entity, or system described throughout this disclosure. The example system 400 includes a root of trust circuit 402 between or coupled to the host system 306 and the SPI flash device 308. In general, SPI command filter 116 and/or secure SPI communication module 302 may implement aspects of the secure SPI interface described herein. SPI command filter 116 may be implemented with a secure serial peripheral interface (SPI) device passthrough module (e.g., secure SPI communication module 302). For example, the secure SPI device passthrough module may include functionality for snooping on SPI transactions from the host system to the SPI flash device and intervening in unauthorized traffic. This module can be implemented to block harmful read/write requests or ensure that genuine binary images are returned to the host system.
이 예시적인 시스템에서, 신뢰 루트 회로(402)는 SPI 클록(310), SPI 칩 선택 라인(312) 및 직렬 데이터 라인(314)을 포함하는 SPI 버스(404)와 동작가능하게 연결되며, 이는 도 3을 참조하여 설명된 것과 유사하거나 상이하게 구현될 수 있다. 클록 게이트 셀(406)(클록 게이트(406))은 시스템 호스트 또는 클록 회로로부터 SPI 클록(310)을 수신하고 SPI 클록(310)을 SPI 플래시 디바이스(308)에 제공한다. 양태에서, SPI 명령 필터(116)는 SPI 플래시 디바이스(308)에 대한 칩 선택 비트(408)를 포함하는 SPI 버스(404)를 모니터링한다. 도 4에 도시된 바와 같이, SPI 명령 필터(116)는 SPI 플래시 디바이스(308)에 대한 칩 선택 비트(408)의 적용 또는 전파를 게이팅하는 게이팅 로직에 대한 칩 선택 비트 비활성화 신호(410)(CSb_disable(410))를 선택적으로 생성할 수 있다.In this example system, trust root circuit 402 is operably coupled with SPI bus 404, which includes SPI clock 310, SPI chip select line 312, and serial data line 314, as shown in FIG. It may be implemented similarly or differently from that described with reference to 3. Clock gate cell 406 (clock gate 406) receives SPI clock 310 from a system host or clock circuit and provides SPI clock 310 to SPI flash device 308. In an aspect, SPI command filter 116 monitors SPI bus 404 including chip select bit 408 for SPI flash device 308. 4, the SPI command filter 116 provides a chip select bit disable signal 410 (CSb_disable) to the gating logic that gates the application or propagation of the chip select bit 408 to the SPI flash device 308. (410)) can be selectively generated.
보안 SPI 통신의 양태에서, SPI 명령 또는 연산코드의 적어도 일부 비트(예를 들어, 8비트 중 7비트)는 SPI 클록(310)에 기초하여 SPI 플래시 디바이스(308)에 클록킹될 수 있다. 일부 경우에, SPI 명령 필터(116)는 SPI 명령 필터(116)가 명령의 8비트를 모두 수신할 때까지 명령이 승인되었는지 승인되지 않았는지 여부를 결정할 수 없다. SPI 명령 필터(116)는 명령의 8번째 비트에 대응하는 SPI 클록(310) 클록 펄스의 앞부분에서 명령의 8번째 비트를 결정하고, 명령의 승인 여부를 판단할 수 있다. 예를 들어, SPI 명령 필터는 완전한 명령 또는 연산코드를 SPI 플래시 디바이스(308)에 의한 실행이 승인된 명령들을 나타내는 정보의 테이블과 비교할 수 있다. 해당 명령이 승인되지 않았다고 결정하는 것에 응답하여, SPI 명령 필터(116)는 명령의 8번째 비트가 SP 플래시 디바이스(308)에 의해 등록되거나 소비되는 것을 방지하기 위해, SPI 플래시 디바이스(308)에 대한 SPI 클록 신호(310)를 일시 중지하거나 지연하기 위해 클록 게이트(406)의 클록 활성화 신호를 디어설팅한다. 대안적으로 또는 추가적으로, 명령이 승인되지 않았다고 결정하는 것에 응답하여, SPI 명령 필터(116)는 칩 선택 비트 비활성화 신호(410)를 게이팅 로직에 어설팅(asserting)할 수 있으며, 이에 의해 게이팅 로직이 SPI 칩 선택 신호(312)를 SPI 플래시 디바이스(308)에 대해 디어설팅하여 디바이스가 승인되지 않은 명령의 하나 이상의 비트를 소비하는 것을 방지한다. 그렇게 함으로써, SPI 명령 필터(116)는 승인되지 않은 명령이 SPI 플래시 디바이스 내에 도달하거나 등록되는 것을 방지할 수 있으며, 따라서 승인되지 않은 SPI 연산코드의 실행을 방지할 수 있다.In an aspect of secure SPI communication, at least some bits (e.g., 7 of 8 bits) of the SPI command or opcode may be clocked in SPI flash device 308 based on SPI clock 310. In some cases, SPI command filter 116 cannot determine whether a command is acknowledged or unauthorized until SPI command filter 116 receives all eight bits of the command. The SPI command filter 116 can determine the 8th bit of the command at the beginning of the clock pulse of the SPI clock 310 corresponding to the 8th bit of the command, and determine whether the command is approved. For example, an SPI instruction filter may compare a complete instruction or opcode to a table of information representing instructions authorized for execution by SPI flash device 308. In response to determining that the command is not authorized, the SPI command filter 116 configures the SPI flash device 308 to prevent the 8th bit of the command from being registered or consumed by the SP flash device 308. Deasserts the clock enable signal of clock gate 406 to pause or delay the SPI clock signal 310. Alternatively or additionally, in response to determining that the command is not authorized, SPI command filter 116 may assert chip select bit disable signal 410 to the gating logic, thereby causing the gating logic to Disassuring the SPI chip select signal 312 to the SPI flash device 308 prevents the device from consuming one or more bits of unauthorized commands. By doing so, SPI command filter 116 can prevent unauthorized commands from reaching or registering within the SPI flash device and thus prevent execution of unauthorized SPI opcodes.
일반적으로, SPI 명령 필터(116) 또는 보안 SPI 통신 모듈(302)은 허용되지 않는 모든 다운스트림 명령을 차단하고/하거나 A/B 파티션 또는 바이너리 이미지 체계를 지원하기 위해 읽기 명령에 대한 주소 필드를 스왑(swap)할 수 있다. 본 명세서에 설명된 바와 같이, SPI 명령 필터(116)는 들어오는 명령이 시스템의 소프트웨어 또는 하드웨어가 구성한 차단 목록(예: CSR 명령에 대한)에 있는 경우 들어오는 명령을 차단하도록 구성될 수 있다. SPI 명령 필터(116)가 명령을 차단할 때, 필터는 SPI 클록(310)의 8번째 비트 또는 사이클의 에지에서 칩 선택 라인 또는 칩 선택 비트를 변경하거나 토글할 수 있으며 호스트 시스템이 자신의 칩 선택 라인(예: SPI 명령 필터(116)의 업스트림)을 릴리즈할 때까지 SPI 클록(310)을 로우로 게이팅하거나 유지할 수 있다. 양태에서, SPI 명령 필터(116)는 클록 게이트 셀(406)을 사용하여 SPI 클록(310)을 부착된 SPI 플래시 디바이스(308)에 전파하지 않으며, 이는 칩 선택 라인의 글리칭을 줄이거나 방지하고 SPI 플래시 디바이스의 정상적인 동작을 보장할 수 있다. SPI 명령 필터(116)가 SPI 클록 라인(310)을 게이팅하지 않는 경우, 칩 선택 라인(312)은 임의의 글리치를 해결하기 위해 하나 이상의 클록 사이클이 필요할 수 있다. 일부 경우에, 이러한 타이밍 지연으로 인해 SPI 명령 필터(116)는 칩 소거 명령과 같은 자체 완성 명령을 취소하기 위해 칩 선택 라인을 올리거나 변경하는 올바른 타이밍을 놓치게 될 수 있다. 따라서, SPI 명령 필터(116)는 SPI 칩 선택 라인의 글리칭을 방지하고 칩 선택 라인 토글의 타이밍이 SPI 플래시 디바이스에 의해 자체 완성 명령이 소비되는 것을 방지하는 데 효과적인 것을 보장하기 위해 SPI 칩 선택 라인을 디어설팅하고 SPI 클록 라인을 게이팅할 수 있다. 또한, SPI 칩 선택 라인의 디어설션을 활성화하기 위해 칩 선택 라인을 제어하는 SPI 명령 필터의 맥락에서 SPI 통신에 관한 몇 가지 가정이 이루어질 수 있다. 이러한 가정에는 전송 동작 중에 SPI 칩 선택 라인을 디어설팅하더라도 플래시 디바이스의 I/O 품질이 저하되지 않으며, 칩 선택 라인이 8번째 SPI 클록 사이클 또는 비트 이전에 디어설팅되면 SPI 플래시 디바이스(308)는 명령의 의도된 동작에 대한 어떠한 가정도 하지 않고 명령이나 프로세스를 취소한다. 예를 들어, SPI 플래시 디바이스(308)는 SPI 플래시 디바이스 칩의 삭제를 준비하기 위해 일곱 번째 SPI 클록 사이클 또는 비트에서 충전 펌프를 충전하지 않을 수 있다. 호스트-SPI 디바이스 액세스의 맥락에서 설명되었지만, 여기에 설명된 양태는 SPI 플래시에 의해 발행된 승인되지 않은 페이로드 또는 데이터가 호스트 디바이스에 도달하는 것을 방지하기 위해 SPI 디바이스-호스트 액세스에도 적용될 수 있다.Typically, the SPI command filter 116 or secure SPI communication module 302 blocks all unauthorized downstream commands and/or swaps address fields for read commands to support A/B partitioning or binary image schemes. You can (swap). As described herein, SPI command filter 116 may be configured to block incoming commands if the incoming command is on a block list configured by the system's software or hardware (e.g., for CSR commands). When the SPI command filter 116 blocks a command, the filter may change or toggle the chip select line or chip select bit on the 8th bit of the SPI clock 310 or the edge of the cycle and allow the host system to block its chip select line. The SPI clock 310 can be gated low or held low until released (e.g., upstream of the SPI command filter 116). In an aspect, the SPI command filter 116 does not use the clock gate cell 406 to propagate the SPI clock 310 to the attached SPI flash device 308, which reduces or prevents glitching of the chip select line. Normal operation of the SPI flash device can be guaranteed. If SPI command filter 116 is not gating SPI clock line 310, chip select line 312 may require more than one clock cycle to resolve any glitches. In some cases, this timing delay may cause the SPI command filter 116 to miss the correct timing to raise or change the chip select line to cancel a self-complete command, such as a chip erase command. Therefore, the SPI command filter 116 prevents glitching of the SPI chip select line and ensures that the timing of the chip select line toggle is effective in preventing self-completion commands from being consumed by the SPI flash device. can be deasserted and gated on the SPI clock line. Additionally, some assumptions may be made regarding SPI communications in the context of the SPI command filter that controls the chip select line to enable deassertion of the SPI chip select line. These assumptions include that deasserting the SPI chip select line during a transfer operation will not degrade the I/O quality of the flash device, and that if the chip select line is deasserted before the eighth SPI clock cycle or bit, the SPI flash device 308 will Cancels a command or process without making any assumptions about its intended behavior. For example, SPI flash device 308 may not charge the charge pump on the seventh SPI clock cycle or bit to prepare for erasure of the SPI flash device chip. Although described in the context of host-SPI device access, aspects described herein may also apply to SPI device-host access to prevent unauthorized payload or data issued by SPI flash from reaching the host device.
보안 SPI 통신 모듈(302)은 또한 소프트웨어가 SPI 명령 이후 데이터의 처음 32 비트 동안 SPI 데이터 라인 0을 다운스트림 디바이스로 스왑하도록 이 모듈을 구성할 수 있는 주소 조작을 구현할 수 있다. 이는 예를 들어, Dual IO 및 Quad IO 명령을 제외한 읽기 명령에 대해 지원될 수 있다. 일반적으로, SPI 디바이스는 이 주소 조작 기능을 지원하기 위해 두 개의 프로그래밍가능한 CSR을 제공할 수 있다. 양태에서, 이들 레지스터들은 마스크 레지스터 및 다운스트림 디바이스로 송신하기 위한 데이터를 보유하거나 저장하는 데이터 레지스터를 포함한다. 마스크 레지스터는 스왑될 하나 이상의 주소 비트를 나타내기 위해 호스트 또는 보안 SPI 통신 모듈(302)에 의해 설정될 수 있다. 주소 비트 포지션에 대응하는 마스크 비트가 1인 경우, 다운스트림 디바이스로 전송되는 값은 호스트 시스템으로부터의 값이 아닌 데이터 레지스터의 값이 될 수 있다. 양태에서, 하나 또는 두 레지스터 모두 32비트 레지스터로 구현된다. SPI 플래시 디바이스의 4B 주소 모드가 활성화되지 않은 경우, 레지스터의 하위 24비트가 주소 조작에 사용될 수 있다. 이러한 주소 조작 기능의 사용법은 다양할 수 있으며, 그 중 하나의 목적은 A/B 바이너리 이미지에 대한 호스트 액세스를 제공하는 것이다. 양태에서, 신뢰 루트 회로(402) 또는 시스템의 다른 RoT 회로는 SPI 플래시 디바이스(308)에 의해 저장된 바이너리 이미지를 검증할 수 있다. 이 바이너리 이미지가 악의적인 공격이나 안정성 문제로 조작된 경우, RoT 회로의 논리는 호스트 시스템의 요청을 SPI 플래시 디바이스의 다른 파티션(예: 플래시의 나머지 절반 또는 분할 파티션)으로 리디렉션하도록 레지스터를 설정할 수 있다.The secure SPI communications module 302 may also implement address manipulation that allows software to configure the module to swap SPI data line 0 to a downstream device during the first 32 bits of data after an SPI command. This may be supported for read commands excluding Dual IO and Quad IO commands, for example. Typically, an SPI device can provide two programmable CSRs to support this address manipulation function. In an aspect, these registers include a mask register and a data register that holds or stores data for transmission to a downstream device. The mask register may be set by the host or secure SPI communication module 302 to indicate one or more address bits to be swapped. If the mask bit corresponding to the address bit position is 1, the value transmitted to the downstream device may be the value of the data register rather than the value from the host system. In an aspect, one or both registers are implemented as 32-bit registers. If the SPI flash device's 4B address mode is not enabled, the lower 24 bits of the register can be used for address manipulation. There can be a variety of uses for these address manipulation functions, one purpose of which is to provide host access to A/B binary images. In an aspect, root of trust circuitry 402 or other Root of Trust circuitry in the system may verify the binary image stored by SPI flash device 308. If this binary image is manipulated due to a malicious attack or stability issue, the logic in the RoT circuit can set registers to redirect requests from the host system to another partition of the SPI flash device (e.g., the other half of flash or a split partition). .
도 5는 보안 SPI 통신의 양태가 구현될 수 있는 SPI 통신 시그널링의 예시적인 타이밍도를 500으로 도시한다. 타이밍도(500)는 보안 SPI 통신의 하나 이상의 양태에 따른 신호의 각각의 타이밍 및 천이를 묘사한다. 본 명세서에 설명된 바와 같이, 다양한 SPI 인터커넥트 신호는 SPI 명령 필터(116) 및/또는 보안 SPI 통신 모듈에 의해 수신될 수 있으며, 이는 이후 이러한 신호를 SPI 플래시 디바이스와 같은 다운스트림 SPI 주변 장치로 전달, 게이팅 또는 전파할 수 있다. 이 예에서, SPI 칩 선택 신호(502)(CSb_in 502)는 SPI 칩 선택 라인을 통해 호스트 시스템(306)으로부터 보안 SPI 통신 모듈(302)로 이동할 수 있고, SPI 클록 신호(504)(SCK_in 504)는 호스트 시스템(306)으로부터 SPI 클록 라인을 통해 이동할 수 있으며, SPI I/O 라인(506)(IO[0]_i 506)은 SPI 인터커넥트의 직렬 데이터 라인을 통해 호스트 시스템(306)으로부터 보안 SPI 통신 모듈(302)로 이동할 수 있다. 양태에서, 필터 신호(508)(필터(508))는 승인되지 않은 명령이 SPI 명령 필터(116)에 의해 검출되거나 결정되는 때를 나타내는 신호 또는 인터럽트를 나타낼 수 있다. 승인되지 않은 명령을 검출 또는 결정하는 것에 응답하여, SPI 명령 필터(116)는 본 명세서에 기술된 양태에 따라 하나 이상의 다른 신호를 생성, 변경 또는 토글할 수 있다. 이 예에서, SPI 명령 필터는 명령 필터링된 신호(510)(필터링된(510))를 발생시키며, 이는 SPI 칩 선택 라인 로직 및/또는 SPI 클록과 연결된 클록 게이팅 셀로 전파될 수 있다. 여기서, SPI 클록 출력 신호(512)(SCK_out 512)는 SPI 플래시 디바이스의 클록 입력에 대한 클록 게이팅 셀의 출력을 나타낼 수 있고 칩 선택 출력 신호(514)(CSb_out 514)는 SPI 플래시 디바이스의 칩 선택 입력에 대한 칩 선택 라인 로직의 출력을 나타낼 수 있다. 5 illustrates at 500 an example timing diagram of SPI communication signaling in which aspects of secure SPI communication may be implemented. Timing diagram 500 depicts the respective timing and transitions of signals according to one or more aspects of secure SPI communication. As described herein, various SPI interconnect signals may be received by the SPI command filter 116 and/or a secure SPI communication module, which then passes these signals to a downstream SPI peripheral, such as an SPI flash device. , can be gating or propagating. In this example, the SPI chip select signal 502 (CSb_in 502) can travel from the host system 306 to the secure SPI communication module 302 via the SPI chip select line, and the SPI clock signal 504 (SCK_in 504) can travel from the host system 306 via the SPI clock line, and the SPI I/O line 506 (IO[0]_i 506) can travel from the host system 306 via the serial data line of the SPI interconnect for secure SPI communication. You can move to module 302. In an aspect, filter signal 508 (filter 508 ) may represent a signal or interrupt indicating when an unauthorized command is detected or determined by SPI command filter 116 . In response to detecting or determining an unauthorized command, SPI command filter 116 may generate, change, or toggle one or more other signals in accordance with aspects described herein. In this example, the SPI command filter generates a command filtered signal 510 (filtered 510), which may be propagated to SPI chip select line logic and/or a clock gating cell coupled to the SPI clock. Here, SPI clock output signal 512 (SCK_out 512) may represent the output of a clock gating cell for a clock input of an SPI flash device and chip select output signal 514 (CSb_out 514) may represent a chip select input of an SPI flash device. It can represent the output of the chip select line logic for .
일례로, 명령이 호스트 시스템(306)으로부터 SPI 디바이스(308)로 IO[0]_i(506) 신호로서 전송될 때, CSb_in 신호(502)는 호스트 시스템(306)의 SPI 인터페이스에 의해 어설팅되고 전송 기간 동안 어설팅 상태로 유지된다. CSb_in 신호(502)는 필터링된 신호(510)에 의해 래치(latch) 어설팅되고 SPI 플래시 디바이스(308)로 패스된다. 이러한 방식으로 칩 선택 신호(예: CSb_in 신호(502) 및 CSb_out 신호(514))를 래치하는 것은 클린 칩 선택 어설션(assertion) 및 필요한 경우 글리치 없이 후속 조작을 보장할 수 있다. 이러한 기능이 없고 칩 선택 라인에 글리치가 발생하면, SPI 플래시 디바이스는 알 수 없는 동작을 보일 수 있으며, 여기에는 SPI 플래시 디바이스(308)의 콘텐츠를 손상시키거나 손상시키는 리셋이 포함될 수 있다. 양태에서, 명령 또는 연산코드의 각각의 비트(예: 8비트)는 SCK_in(504) 신호인 SCK_out(512) 신호에 기초하여 SPI 디바이스(308)에 클록킹된다. 이 예에서, 명령 필터(116)는 명령의 8비트를 모두 수신할 때까지 명령이 승인되었는지 승인되지 않았는지 여부를 결정하지 않을 수 있다. 명령 필터(116)가 명령의 8번째 비트에 대응하는 SCK_in(502) 클록 펄스의 앞 부분의 516에서, 8번째 비트를 결정하고 해당 명령이 승인되지 않은 명령이라고 결정(예를 들어, 명령을 명령 차단 목록과 비교)하면, 명령 필터(116)는 명령 필터링을 구현한다. 이 예에서, SPI 명령 필터(116)는 518에서, 필터링된 명령 신호(510)를 어설팅하고, 이는 결국 CSb_out(514) 신호를 (SPI 플래시 핀의 극성 구성에 따라) 어설팅하거나 디어설팅할 수 있다. SPI 명령 필터(116)는 또한 클록 게이팅 셀의 클록 활성화를 디어설팅하여 SPI 플래시 디바이스에 대한 SCK_out(512) 신호를 일시 중지하거나 지연시킨다. 그렇게 함으로써, SPI 명령 필터(116)는 명령 또는 연산코드의 8번째 비트가 SPI 플래시 디바이스(308)에 의해 등록되거나 소비되는 것을 방지할 수 있다. 또한, 클록을 게이팅하고 칩 선택 신호를 디어설팅함으로써, SPI 명령 필터(116)는 칩 선택 라인의 글리칭을 피할 수 있으며, 이는 SPI 플래시 디바이스(308)가 올바르지 않거나 승인되지 않은 명령을 수신하거나 해석하는 것을 방지할 수 있다. 이 예에서는 명령이 호스트 시스템(306)에 의해 SPI 디바이스(308)로 송신되는 경우를 구현했지만, 동일한 로직을 사용하여 반대 응용도 구현될 수 있으며, 즉 SPI 디바이스(308)가 승이되지 않은 페이로드 또는 데이터를 호스트 시스템(306)에 송신한 경우, 구현은 이 예에서와 같이 호스트가 승인되지 않은 통신을 소비하는 것을 방지할 것이다.In one example, when a command is transmitted from host system 306 to SPI device 308 as the IO[0]_i 506 signal, CSb_in signal 502 is asserted by the SPI interface of host system 306 and It remains in asserting state for the duration of the transmission. CSb_in signal 502 is latched and asserted by filtered signal 510 and passed to SPI flash device 308. Latching chip select signals (e.g., CSb_in signal 502 and CSb_out signal 514) in this manner can ensure a clean chip select assertion and, if necessary, glitch-free subsequent operations. Without this capability and a glitch occurs on the chip select line, the SPI flash device may exhibit unknown behavior, which may include resets that corrupt or corrupt the contents of the SPI flash device 308. In an aspect, each bit (e.g., 8 bits) of the instruction or opcode is clocked in the SPI device 308 based on the SCK_in (504) signal and the SCK_out (512) signal. In this example, command filter 116 may not determine whether a command is acknowledged or not until all eight bits of the command are received. The command filter 116 determines the 8th bit at 516 in front of the SCK_in(502) clock pulse corresponding to the 8th bit of the command and determines that the command is an unauthorized command (e.g., Compared to the blacklist), command filter 116 implements command filtering. In this example, the SPI command filter 116 asserts the filtered command signal 510 at 518, which in turn may assert or de-assert the CSb_out 514 signal (depending on the polarity configuration of the SPI flash pin). You can. The SPI command filter 116 also deasserts the clock activation of the clock gating cell to pause or delay the SCK_out 512 signal to the SPI flash device. By doing so, SPI command filter 116 may prevent the eighth bit of the command or opcode from being registered or consumed by SPI flash device 308. Additionally, by gating the clock and deasserting the chip select signal, SPI command filter 116 can avoid glitching of the chip select line, which may cause SPI flash device 308 to receive or interpret incorrect or unauthorized commands. You can prevent it from happening. Although this example implements a case where a command is sent by the host system 306 to the SPI device 308, the opposite application can also be implemented using the same logic, i.e., the SPI device 308 receives a non-transmitted payload. Alternatively, if data is transmitted to the host system 306, the implementation will prevent the host from consuming unauthorized communication, as in this example.
예시적인 방법Exemplary method
방법(600 내지 800)은 수행될 수 있는 행동 또는 동작을 묘사하는 각각의 블록 세트로서 예시되지만, 각각의 블록에 의한 동작을 수행하기 위해 도시된 순서 또는 조합으로 반드시 제한되는 것은 아니다. 또한, 하나 이상의 동작 중 임의의 동작이 반복, 결합, 재구성 또는 연결되어 광범위한 추가 및/또는 대체 방법을 제공할 수 있다. 설명된 기술은 하나의 시스템이나 디바이스에서 동작하는 하나의 엔터티 또는 여러 엔터티의 성능으로 제한되지 않는다. 양태에서, 방법(600 내지 800)의 동작 또는 행동은 프로세서, 보안 회로 구성요소, 메모리, 보안 SPI 통신 모듈, SPI 명령 필터, SPI 클록 제어, 또는 보안 SPI 통신을 구현하도록 구성된 다른 엔티티에 의해 수행되거나 관리된다. 명확성을 위해, 방법은 도 1의 요소 및/또는 도 2-5 및 도 9를 참조하여 설명된 엔티티, 구성요소 또는 구성을 참조하여 설명된다.Methods 600-800 are illustrated as sets of blocks each depicting an action or operation that can be performed, but are not necessarily limited to the order or combinations shown for performing the operations by each block. Additionally, any of the one or more operations may be repeated, combined, reconfigured, or connected to provide a wide range of additional and/or alternative methods. The techniques described are not limited to the performance of one entity or multiple entities operating on one system or device. In aspects, the operations or actions of methods 600-800 are performed by a processor, secure circuit component, memory, secure SPI communication module, SPI command filter, SPI clock control, or other entity configured to implement secure SPI communication. managed. For clarity, the method is described with reference to elements of Figure 1 and/or entities, components or configurations described with reference to Figures 2-5 and 9.
도 6은 하나 이상의 양태에 따라 SPI 명령 필터(116) 또는 호스트 또는 SPI 인터커넥트와 동작가능하게 연관된 보안 SPI 통신 모듈에 의해 구현될 수 있는 보안 SPI 통신을 위한 예시적인 방법(들)(600)을 도시한다. 다양한 양태에서, SPI 명령 필터(116) 또는 보안 SPI 통신 모듈은 방법(600)의 동작을 구현하여 해당 명령이 승인되지 않거나 허용되지 않는 경우 다운스트림 명령이 하나 이상의 주변 블록(예를 들어, 플래시 메모리 디바이스)에 도달하는 것을 차단할 수 있다.6 illustrates example method(s) 600 for secure SPI communications that may be implemented by a SPI command filter 116 or a secure SPI communications module operably associated with a host or SPI interconnect, in accordance with one or more aspects. do. In various aspects, the SPI command filter 116 or a secure SPI communication module implements the operation of method 600 such that if the command is not authorized or permitted, the downstream command may be configured to block one or more peripheral blocks (e.g., flash memory). device) can be blocked.
602에서, SPI 명령 필터는 시스템의 호스트와 시스템의 주변 블록 사이에서 SPI 인터커넥트를 통해 교환되는 통신들을 모니터링한다. 예를 들어, SPI 명령 필터는 직렬 주변 장치 인터페이스 인터커넥트 또는 버스의 데이터 라인을 스누핑하거나 모니터링하여 SPI 인터커넥트를 통해 통신되는 SPI 통신들의 명령 또는 연산코드의 비트를 획득할 수 있다. 어떤 경우에는 명령들이 시스템 호스트에서 SPI 플래시 디바이스로 송신된다.At 602, an SPI command filter monitors communications exchanged over the SPI interconnect between a host in the system and peripheral blocks in the system. For example, an SPI command filter may snoop or monitor a data line of a serial peripheral interface interconnect or bus to obtain bits of commands or opcodes of SPI communications communicated over the SPI interconnect. In some cases, commands are sent from the system host to the SPI flash device.
604에서, SPI 명령 필터는 통신들의 각 명령들을 주변 블록이 실행하도록 승인되지 않은 명령을 나타내는 정보와 비교한다. 경우에 따라, SPI 명령 필터는 수신된 명령 또는 수신된 명령의 일부를 테이블에 색인화하여 명령이 통과하도록 허용되는지 또는 허용되지 않는지(예: 필터링) 여부를 결정한다. 예를 들어, 활성화 비트 제어는 명령이 주변 장치로 다운스트림 통과가 허용되는지 또는 필터링되는지 여부를 나타내거나 제어한다. 일부 구현예에서, 1의 활성화 비트 값 "1"은 명령이 통과하도록 허용되었음을 나타내고 0의 활성화 비트 값 "0"은 명령이 보안 SPI 통신 모듈 또는 명령 필터에 의해 필터링됨을 나타낸다.At 604, the SPI command filter compares each command in the communications with information indicating which commands the surrounding block is not authorized to execute. In some cases, an SPI command filter indexes a received command or part of a received command into a table to determine whether the command is allowed or not allowed to pass (i.e. filtered). For example, the enable bit control indicates or controls whether a command is allowed to pass downstream to a peripheral device or is filtered. In some implementations, an enable bit value of “1” of 1 indicates that the command is allowed to pass and an enable bit value of “0” of 0 indicates that the command is filtered by a secure SPI communication module or command filter.
606에서, SPI 명령 필터는 비교에 기초하여 각 명령들 중 하나가 주변 블록이 실행하도록 승인되지 않은 명령들 중 하나인지 결정한다. 즉, SPI 명령 필터는 SPI 인터커넥트에서 주변 블록으로 전파되는 허용되지 않거나 승인되지 않은 명령을 검출한다. SPI 명령 필터는 명령의 8번째 비트 또는 대응하는 연산코드와 같은 부분 또는 전체 명령에 기초하여 해당 명령이 승인되지 않았음을 결정할 수 있다.At 606, the SPI instruction filter determines, based on the comparison, whether one of each instruction is one of the instructions that the surrounding block is not authorized to execute. That is, the SPI command filter detects disallowed or unauthorized commands propagating from the SPI interconnect to surrounding blocks. The SPI command filter can determine that a command is not authorized based on part or the entire command, such as the 8th bit of the command or the corresponding opcode.
608에서, SPI 명령 필터는 주변 블록이 실행하도록 승인되지 않은 각 명령의 적어도 일부를 주변 블록이 수신하는 것을 방지한다. 양태에서, SPI 명령 필터는 주변 블록에 대한 SPI 인터커넥트의 칩 선택 라인 또는 클록 라인의 상태를 변경한다. 경우에 따라, SPI 명령 필터는 SPI 주변 장치에 클록을 게이팅한 다음 칩 선택 라인을 토글하며, 이는 SPI 명령 필터가 승인되지 않은 명령의 소비를 방지하기 위해 작동할 때 칩 선택 라인의 글리칭을 방지할 수 있다. 이는 주변 블록이 승인되지 않은 통신 명령의 적어도 일부를 수신, 소비 또는 프로세싱하는 것을 방지할 수 있다. 동작(608)으로부터, 방법(600)은 동작(602)으로 복귀하여 SPI 인터커넥트를 통해 주변 블록 또는 시스템의 다른 주변 블록으로 발행된 승인되지 않은 명령들에 대해 SPI 인터커넥트를 계속 모니터링하거나 스누핑할 수 있다.At 608, the SPI command filter prevents the peripheral block from receiving at least a portion of each instruction that the peripheral block is not authorized to execute. In an aspect, the SPI command filter changes the state of a chip select line or clock line of the SPI interconnect to a peripheral block. In some cases, the SPI command filter gates the clock to the SPI peripheral and then toggles the chip select line, which prevents glitching of the chip select line when the SPI command filter operates to prevent consumption of unauthorized commands. can do. This may prevent neighboring blocks from receiving, consuming, or processing at least some of unauthorized communication commands. From operation 608, method 600 may return to operation 602 to continue monitoring or snooping the SPI interconnect for unauthorized commands issued over the SPI interconnect to a peripheral block or other peripheral blocks in the system. .
도 7은 하나 이상의 양태에 따라 SPI 통신의 명령을 필터링하기 위한 예시적인 방법(700)을 도시한다. 다양한 양태에서, SPI 명령 필터(116) 또는 보안 SPI 통신 모듈은 방법(700)의 동작을 구현하여 해당 명령이 승인되지 않거나 허용되지 않는 경우 다운스트림 명령이 하나 이상의 주변 블록(예를 들어, 플래시 메모리 디바이스)에 도달하는 것을 차단할 수 있다.FIG. 7 illustrates an example method 700 for filtering commands in SPI communication according to one or more aspects. In various aspects, the SPI command filter 116 or a secure SPI communication module implements the operation of method 700 such that if the command is not authorized or permitted, the downstream command is blocked from one or more peripheral blocks (e.g., flash memory). device) can be blocked.
702에서, SPI 명령 필터는 SPI 인터커넥트를 통해 호스트와 주변 장치 사이에 교환되는 통신들의 각 명령들을 모니터링한다. 예를 들어, SPI 명령 필터는 직렬 주변 장치 인터페이스 인터커넥트 또는 버스의 데이터 라인을 스누핑하거나 모니터링하여 SPI 인터커넥트를 통해 통신되는 SPI 통신의 명령 또는 연산코드의 비트를 획득할 수 있다. 어떤 경우에는, 명령들이 시스템 호스트에서 SPI 플래시 디바이스로 송신된다.At 702, an SPI command filter monitors each command in communications exchanged between the host and peripheral device over the SPI interconnect. For example, an SPI command filter may snoop or monitor a data line of a serial peripheral interface interconnect or bus to obtain bits of commands or opcodes of SPI communications communicated over the SPI interconnect. In some cases, commands are sent from the system host to the SPI flash device.
704에서, SPI 명령 필터는 각 명령들을 주변 장치가 실행하거나 수신하도록 승인되지 않은 명령들의 테이블과 비교한다. 경우에 따라, SPI 명령 필터는 수신된 명령 또는 수신된 명령의 일부를 테이블에 색인화하여 명령이 통과하도록 허용되는지 또는 허용되지 않는지(예: 필터링) 여부를 결정한다. 예를 들어, 활성화 비트 제어는 명령이 주변 장치로 다운스트림을 전달하도록 허용되는지 또는 필터링되는지 여부를 나타내거나 제어한다. 일부 구현예에서, 1의 활성화 비트 값 "1"은 명령이 통과하도록 허용되었음을 나타내고 0의 활성화 비트 값 "0"은 명령이 보안 SPI 통신 모듈 또는 명령 필터에 의해 필터링됨을 나타낸다.At 704, the SPI command filter compares each command to a table of commands that the peripheral device is not authorized to execute or receive. In some cases, an SPI command filter indexes a received command or part of a received command into a table to determine whether the command is allowed or not allowed to pass (i.e. filtered). For example, the enable bit control indicates or controls whether a command is allowed to pass downstream to a peripheral device or is filtered. In some implementations, an enable bit value of “1” of 1 indicates that the command is allowed to pass and an enable bit value of “0” of 0 indicates that the command is filtered by a secure SPI communication module or command filter.
706에서, SPI 명령 필터는 각 명령이 주변 장치에 의해 실행되도록 승인되었는지 여부를 결정한다. 706으로부터, 각 명령이 실행을 위해 승인되었다는 확인에 응답하여, 방법은 SPI 명령 필터가 SPI 인터커넥트를 통해 각각의 명령을 포함하는 통신을 주변 장치에 전달하는 708로 진행된다.At 706, the SPI command filter determines whether each command is authorized for execution by the peripheral device. From 706, in response to confirmation that each command is authorized for execution, the method proceeds to 708 where the SPI command filter passes communication containing the respective command to the peripheral device via the SPI interconnect.
대안적으로, 각 명령이 실행을 위해 승인되지 않은 것으로 결정하는 것에 응답하여, 방법은 주변 장치가 승인되지 않은 명령의 적어도 일부를 수신하거나 프로세싱하는 것을 방지하기 위해 SPI 명령 필터가 대책 동작을 제정할 수 있는 710으로 진행한다. 그렇게 하기 위해, SPI 명령 필터는 710에서 SPI 클록 라인을 주변 장치에 게이팅한다. 이는 클록킹 비트, 천이 또는 신호가 주변 칩으로 전파되는 것을 방지할 수 있으며, 이로 인해 주변 장치가 명령의 적어도 일부를 소비하거나 프로세싱하는 것을 방지할 수 있다. 어떤 경우에는 SPI 명령 필터가 8번째 비트 명령이 주변 장치에 통신되는 8번째 비트 또는 클록 사이클에 또는 그 근처에서 SPI 클록 라인을 게이팅하여, 주변 장치로 하여금 승인되지 않은 명령을 폐기하게 할 수 있다.Alternatively, in response to determining that each command is unauthorized for execution, the method may cause the SPI command filter to enact countermeasure actions to prevent the peripheral device from receiving or processing at least a portion of the unauthorized command. Proceed to 710 as much as possible. To do so, the SPI command filter gates the SPI clock line at 710 to the peripheral. This may prevent clocking bits, transitions or signals from propagating to peripheral chips, thereby preventing peripheral devices from consuming or processing at least a portion of the instructions. In some cases, the SPI command filter may gate the SPI clock line at or near the 8th bit or clock cycle when the 8th bit command is communicated to the peripheral, causing the peripheral to discard unauthorized commands.
712에서, SPI 명령 필터는 SPI 칩 선택 라인을 주변 장치에 디어설팅한다. 어떤 경우에는 SPI 명령 필터가 8번째 비트 명령이 주변 장치에 통신되는 8번째 비트 또는 클록 사이클 또는 그 근처에서 SPI 칩 선택 라인을 디어설팅한다. 양태에서, SPI 클록이 게이팅 또는 일시 정지된 동안 SPI 칩 선택 라인을 디어설팅(또는 논리 극성에 따라 어설팅)하면 SPI 명령 필터가 SPI 칩 선택 라인 또는 SPI 주변 장치에 글리칭 없이 SPI 칩 선택 라인을 토글할 수 있다. 그렇게 함으로써, SPI 명령 필터는 주변 장치가 명령의 8번째 비트를 소비하거나 프로세싱하는 것을 방지할 수 있으며, 이로 인해 주변 장치로 하여금 승인되지 않은 명령이나 그 명령의 수신된 부분을 폐기하게 하거나 강제로 폐기할 수 있다. 일부 구현예에서, SPI 명령 필터는 칩 선택 라인을 디어설팅하고 동시에 또는 SCK 기간의 절반 미만(예: 25MHz ~ 100MHz SCK의 경우 10~50나노초)과 같은 짧은 시간 범위 내에 클록 신호를 게이팅할 수 있다. 이는 칩 선택 라인의 디어설션으로 인해 주변 장치에 글리칭이 발생하는 것을 방지하는 데 효과적일 수 있다. 714에서, SPI 명령 필터는 호스트가 업스트림 칩 선택 라인을 릴리즈할 때 SPI 클록 라인을 재개하며, 이는 SPI 인터커넥트의 지속적인 동작을 가능하게 할 수 있다.At 712, the SPI command filter deasserts the SPI chip select line to the peripheral device. In some cases, the SPI command filter deasserts the SPI chip select line at or near the 8th bit or clock cycle when the 8th bit command is communicated to the peripheral device. In an aspect, de-asserting the SPI chip select line (or asserting depending on logic polarity) while the SPI clock is gated or paused causes the SPI command filter to direct the SPI chip select line without glitching on the SPI chip select line or the SPI peripheral. You can toggle it. By doing so, the SPI command filter can prevent the peripheral device from consuming or processing the 8th bit of the command, which causes or forces the peripheral device to discard the unauthorized command or the received portion of the command. can do. In some implementations, the SPI command filter may de-assert the chip select line and gate the clock signal simultaneously or within a short time range, such as less than half the SCK period (e.g., 10 to 50 nanoseconds for a 25 MHz to 100 MHz SCK). . This can be effective in preventing glitching in peripheral devices due to deassertion of the chip select line. At 714, the SPI command filter resumes the SPI clock line when the host releases the upstream chip select line, which may enable continued operation of the SPI interconnect.
도 8은 하나 이상의 양태에 따라 대체 바이너리 이미지 액세스를 가능하게 하기 위해 명령 주소를 조작하는 예시적인 방법(800)을 도시한다. 다양한 양태에서, SPI 명령 필터(116) 또는 보안 SPI 통신 모듈은 방법(800)의 동작을 구현하여 플래시 메모리 디바이스의 A/B 모드 바이너리 이미지 또는 파티션 액세스를 활성화할 수 있다.8 illustrates an example method 800 of manipulating an instruction address to enable replacement binary image access in accordance with one or more aspects. In various aspects, SPI command filter 116 or a secure SPI communication module may implement the operations of method 800 to enable A/B mode binary image or partition access of a flash memory device.
802에서, 시스템의 보안 SPI 통신 모듈 또는 RoT 디바이스는 시스템의 호스트를 플래시 메모리 디바이스에 결합하는 SPI 인터커넥트를 통해 SPI 플래시 메모리 디바이스에 액세스한다. 플래시 메모리 디바이스는 호스트 시스템의 서로 다른 바이너리 이미지나 기타 정보가 저장되는 다중 파티션을 포함할 수 있다. 804에서, 보안 SPI 통신 모듈 또는 RoT 디바이스는 SPI 플래시 메모리 디바이스의 제1 파티션에 저장된 바이너리 이미지를 검증한다.At 802, the system's secure SPI communication module or Root of Trust device accesses the SPI flash memory device via an SPI interconnect that couples the system's host to the flash memory device. A flash memory device may contain multiple partitions where different binary images or other information from the host system are stored. At 804, the secure SPI communication module or RoT device verifies the binary image stored in the first partition of the SPI flash memory device.
선택적으로 806에서, 바이너리 이미지가 진짜인지 검증하는 것에 응답하여, 보안 SPI 통신 모듈 또는 RoT 디바이스는 시스템의 호스트가 SPI 플래시 메모리 디바이스로부터 바이너리 이미지를 로드할 수 있도록 허용한다. 선택적으로 808에서, 보안 SPI 통신 모듈은 SPI 플래시 메모리 디바이스의 제2 파티션에 액세스하기 위해 SPI 인터커넥트를 통과하는 명령의 하나 이상의 주소 비트를 조작한다. 810에서, 보안 SPI 통신 모듈은 시스템의 호스트가 SPI 플래시 메모리 디바이스의 제2 파티션으로부터 또 다른 바이너리 이미지를 로드할 수 있게 한다.Optionally, at 806, in response to verifying that the binary image is authentic, the secure SPI communication module or RoT device allows a host of the system to load the binary image from the SPI flash memory device. Optionally at 808, the secure SPI communication module manipulates one or more address bits of a command passing over the SPI interconnect to access a second partition of the SPI flash memory device. At 810, the secure SPI communication module allows a host of the system to load another binary image from a second partition of the SPI flash memory device.
예시적인 시스템 온 칩Exemplary System-on-Chip
도 9는 하나 이상의 양태에 따라 보안 SPI 통신을 구현할 수 있는 예시적인 시스템 온 칩(900)(SoC(900))의 다양한 구성요소를 도시한다. SoC(900)는 고정형, 모바일형, 독립형 또는 내장형 디바이스; 소비자, 컴퓨터, 휴대용, 사용자, 서버, 통신, 전화, 내비게이션, 게임, 오디오, 카메라, 메시징, 미디어 재생 및/또는 도 1을 참조하여 도시되거나 설명된 장치(102)와 같은 다른 유형의 SoC 지원 디바이스의 임의의 형태 중 단일 또는 다중 디바이스로 구현될 수 있다. 도시된 구성요소 중 하나 이상은 개별 구성요소, 모듈, IP 블록, 또는 SoC(900)의 적어도 하나의 집적 회로 상의 집적 구성요소로서 구현될 수 있다. 일반적으로, SoC(900)의 다양한 구성요소는 보안 SPI 통신의 하나 이상의 양태에 따라 구성요소 간의 통신을 지원하는 인터커넥트(120) 및/또는 하나 이상의 패브릭을 통해 결합된다.9 illustrates various components of an example system-on-a-chip 900 (SoC 900) that can implement secure SPI communications in accordance with one or more aspects. SoC 900 may be a fixed, mobile, stand-alone, or embedded device; Consumer, computer, portable, user, server, communications, phone, navigation, gaming, audio, camera, messaging, media playback, and/or other types of SoC-enabled devices, such as device 102 shown or described with reference to FIG. 1 It can be implemented as a single or multiple devices in any of the forms. One or more of the depicted components may be implemented as individual components, modules, IP blocks, or integrated components on at least one integrated circuit of SoC 900. Generally, the various components of SoC 900 are coupled through one or more fabrics and/or interconnects 120 that support communication between the components according to one or more aspects of secure SPI communication.
SoC(900)는 수신된 데이터, 전송된 데이터, 또는 위에서 식별된 기타 정보와 같은, 디바이스 데이터(110)의 유선 및/또는 무선 통신을 가능하게 하는 하나 이상의 통신 트랜시버(124)를 포함할 수 있다. 통신 트랜시버(124)의 예로는 근거리 통신(NFC) 트랜시버, 다양한 IEEE 802.15(Bluetooth™) 표준을 준수하는 무선 개인 영역 네트워크(PAN)(WPAN) 라디오, 다양한 IEEE 802.11(WiFiTM) 표준을 준수하는 무선 근거리 통신망(LAN)(WLAN) 라디오, 셀룰러 연결을 위한 무선 광역 네트워크(WAN)(WWAN) 라디오(예: 3세대 파트너십 프로젝트 준수(3GPP 준수)), 다양한 IEEE 802.16(WiMAXTM) 표준을 준수하는 무선 수도권 네트워크(MAN)(WMAN) 라디오, 적외선 데이터 협회(IrDA) 프로토콜을 준수하는 적외선(IR) 트랜시버, 및 유선 근거리 통신망 LAN 이더넷 트랜시버를 포함한다.SoC 900 may include one or more communication transceivers 124 that enable wired and/or wireless communication of device data 110, such as received data, transmitted data, or other information identified above. . Examples of communications transceivers 124 include near-field communications (NFC) transceivers, wireless personal area network (PAN) (WPAN) radios compliant with various IEEE 802.15 (Bluetooth™) standards, and wireless short-range devices compliant with various IEEE 802.11 (WiFiTM) standards. Local area network (WLAN) radios, wireless wide area network (WWAN) radios for cellular connectivity (e.g. 3rd Generation Partnership Project compliant (3GPP compliant)), wireless metropolitan area networks compliant with various IEEE 802.16 (WiMAXTM) standards. (MAN) (WMAN) radios, infrared (IR) transceivers compliant with the Infrared Data Association (IrDA) protocol, and wired local area network LAN Ethernet transceivers.
SoC(900)는 또한 임의의 유형의 데이터, 미디어 콘텐츠, 및/또는 사용자가 선택할 수 있는 입력, 메시지, 애플리케이션, 음악, 텔레비전 콘텐츠, 녹화된 비디오 콘텐츠 마이크나 카메라와 같은 센서를 포함하여 임의의 콘텐츠 및/또는 데이터 소스에서 수신된 기타 유형의 오디오, 비디오 및/또는 이미지 데이터 등과 같은 다른 입력이 전달될 수 있는 하나 이상의 데이터 입력/출력 포트(126)(I/O 포트(126))를 포함할 수 있다. 데이터 I/O 포트(126)는 USB 포트, 동축 케이블 포트, 광섬유 인터커넥트 또는 케이블링을 위한 광섬유 포트, 그리고 플래시 메모리, 광학 미디어 기록기/판독기(예: DVD, CD) 등이 있다. 이러한 데이터 I/O 포트(126)는 SoC를 구성요소, 주변 장치 또는 키보드, 마이크, 카메라 또는 기타 센서와 같은 액세서리에 연결하는 데 사용될 수 있다.SoC 900 may also display any type of data, media content, and/or user-selectable input, messages, applications, music, television content, recorded video content, including sensors such as microphones or cameras. and/or one or more data input/output ports 126 (I/O ports 126) through which other inputs may be passed, such as audio, video and/or image data of other types received from data sources, etc. You can. Data I/O ports 126 include USB ports, coaxial cable ports, fiber optic ports for fiber optic interconnects or cabling, and flash memory and optical media writers/readers (e.g. DVD, CD). These data I/O ports 126 may be used to connect the SoC to components, peripherals, or accessories such as keyboards, microphones, cameras, or other sensors.
이 예의 SoC(900)는 결합된 프로세서 및 메모리 시스템(예를 들어, SoC의 일부로 구현됨)을 포함할 수 있는, 적어도 하나의 프로세서(106)(예를 들어, 애플리케이션 프로세서, 마이크로프로세서, 디지털 신호 프로세서(DSP), 컨트롤러 등 중 임의의 하나 이상)를 포함하며, 이는 디바이스의 동작을 제어하기 위해 컴퓨터 실행가능 명령어들을 프로세싱(예를 들어, 실행)한다. 양태에서, 프로세서(106)는 SoC의 다른 구성요소 및/또는 주변 블록과 인터렉션하는 SoC(900)의 호스트 기능들을 구현하기 위해 컴퓨터 판독가능 명령어(예를 들어, 운영 시스템 또는 펌웨어)를 실행할 수 있다. 프로세서(106)는 애플리케이션 프로세서, 임베디드 컨트롤러, 마이크로 컨트롤러, 보안 프로세서, 인공 지능(AI) 가속기 등으로 구현될 수 있다. 일반적으로, 프로세서 또는 프로세싱 시스템은 적어도 부분적으로 하드웨어로 구현될 수 있으며, 이는 집적 회로 또는 온 칩 시스템의 구성요소, 디지털 시그널 프로세서(DSP), 주문형 집적 회로(ASIC), 필드 프로그래밍가능 게이트 어레이(FPGA), 복합 프로그래밍가능 로직 디바이스(CPLD), 및 실리콘 및/또는 기타 재료에서의 다른 구현을 포함할 수 있다.SoC 900 in this example includes at least one processor 106 (e.g., an application processor, a microprocessor, a digital signal processor, etc.), which may include a combined processor and memory system (e.g., implemented as part of the SoC). and any one or more of a processor (DSP), a controller, etc.), which processes (e.g., executes) computer-executable instructions to control the operation of the device. In an aspect, processor 106 may execute computer-readable instructions (e.g., operating system or firmware) to implement host functions of SoC 900 that interact with other components and/or peripheral blocks of the SoC. . The processor 106 may be implemented as an application processor, embedded controller, microcontroller, security processor, artificial intelligence (AI) accelerator, etc. In general, a processor or processing system may be implemented at least partially in hardware, including components of an integrated circuit or on-chip system, a digital signal processor (DSP), an application specific integrated circuit (ASIC), or a field programmable gate array (FPGA). ), complex programmable logic devices (CPLDs), and other implementations in silicon and/or other materials.
대안적으로 또는 추가적으로, SoC(900)는 소프트웨어, 하드웨어, 펌웨어, 또는 902(전자 회로(902)로서)에서 일반적으로 표시된 프로세싱 및 제어 회로와 관련하여 구현되는 고정 논리 회로를 포함할 수 있는 전자 회로 중 임의의 하나 또는 조합으로 구현될 수 있다. 이 전자 회로(902)는 컴퓨터 판독가능 매체에 저장된 프로세싱/컴퓨터 실행가능 명령어, 논리 회로 및/또는 하드웨어(예: FPGA) 등을 통해 실행가능 또는 하드웨어 기반 모듈(도 9에는 도시되지 않음)을 구현할 수 있다.Alternatively or additionally, SoC 900 may include software, hardware, firmware, or fixed logic circuitry implemented in conjunction with processing and control circuitry generally indicated in 902 (as electronic circuitry 902). It may be implemented as any one or combination of: This electronic circuit 902 may implement an executable or hardware-based module (not shown in FIG. 9), such as through processing/computer-executable instructions stored on a computer-readable medium, logic circuitry, and/or hardware (e.g., FPGA). You can.
양태에서, SoC(900)는 보안 SPI 시그널링 및/또는 통신의 다양한 양태를 가능하게 하기 위해 디바이스 내의 다양한 구성요소를 연결하는 시스템 버스, 링크, 채널, 인터커넥트, 크로스바, 데이터 전송 시스템 또는 기타 스위치 패브릭 중 하나 이상을 포함할 수 있는, 인터커넥트(120)를 포함한다. 시스템 버스 또는 인터커넥트에는 메모리 버스 또는 메모리 컨트롤러, SPI 버스, SPI 인터커넥트, 주변 장치 버스, 패리티 블록, CRC 블록, ECC 블록, TL-UL 패브릭, 범용 직렬 버스 및/또는 다양한 버스 아키텍처 중 하나를 활용하는 프로세서 또는 로컬 버스와 같은, 다양한 버스 구조 중 하나 또는 이들의 조합을 포함할 수 있다. In an aspect, SoC 900 may be one of a system bus, link, channel, interconnect, crossbar, data transfer system, or other switch fabric that connects various components within the device to enable various aspects of secure SPI signaling and/or communication. Includes interconnect 120, which may include one or more. System buses or interconnects include a memory bus or memory controller, SPI bus, SPI interconnect, peripheral bus, parity block, CRC block, ECC block, TL-UL fabric, universal serial bus, and/or processor utilizing one of various bus architectures. or it may include one or a combination of various bus structures, such as a local bus.
SoC(900)는 또한 데이터 저장을 가능하게 하는 하나 이상의 메모리 디바이스(904)를 포함하며, 그 예로는 랜덤 액세스 메모리(RAM), 비휘발성 메모리(예를 들어, 읽기 전용 메모리(ROM), 플래시 메모리, 삭제 가능한 프로그래밍가능 읽기 전용 메모리(EPROM) 및 전기적으로 삭제 가능한 프로그래밍가능 읽기 전용 메모리(EEPROM)) 및 디스크 스토리지 디바이스를 포함한다. 메모리 디바이스(904) 중 하나 이상은 본 명세서에 설명된 보안 SPI 통신의 양태를 구현하는 SPI 명령 필터(116) 및/또는 SPI 클럭 컨트롤러(118)에 연결된 SPI 인터커넥트를 통해 통신할 수 있다. 메모리 디바이스(들)(904)는 시스템의 상이한 논리적 스토리지 레벨뿐만 아니라 상이한 물리적 구성요소들에 걸쳐 분산될 수 있다. 메모리 디바이스(들)(904)는 디바이스 데이터(110), 다른 유형의 코드 및/또는 데이터, 및 다양한 디바이스 애플리케이션(906)(예를 들어, 소프트웨어 애플리케이션 또는 프로그램)을 저장하기 위한 데이터 스토리지 메커니즘을 제공한다. 예를 들어, 운영 시스템(908)은 메모리 디바이스(904) 내에서 소프트웨어 명령으로 유지되고 프로세서(106)에 의해 실행될 수 있다.SoC 900 also includes one or more memory devices 904 that enable data storage, such as random access memory (RAM), non-volatile memory (e.g., read only memory (ROM), flash memory) , erasable programmable read-only memory (EPROM) and electrically erasable programmable read-only memory (EEPROM)) and disk storage devices. One or more of the memory devices 904 may communicate via an SPI interconnect coupled to an SPI clock controller 118 and/or an SPI command filter 116 that implements aspects of secure SPI communication described herein. Memory device(s) 904 may be distributed across different physical components as well as different logical storage levels of the system. Memory device(s) 904 provide a data storage mechanism for storing device data 110, other types of code and/or data, and various device applications 906 (e.g., software applications or programs). do. For example, operating system 908 may be maintained as software instructions within memory device 904 and executed by processor 106.
일부 구현예에서, SoC(900)는 또한 오디오 데이터를 프로세싱하고/하거나 오디오 및 비디오 데이터를 오디오 시스템(912) 및/또는 디스플레이 시스템(914)(예를 들어, 비디오 버퍼 또는 스마트폰이나 카메라의 화면)으로 전달하는 오디오 및/또는 비디오 프로세싱 시스템(910)을 포함한다. 오디오 시스템(912) 및/또는 디스플레이 시스템(914)은 오디오, 비디오, 디스플레이 및/또는 이미지 데이터를 프로세싱, 디스플레이 및/또는 렌더링하는 임의의 디바이스를 포함할 수 있다. 디스플레이 데이터 및 오디오 신호는 RF(무선 주파수) 링크, S 비디오 링크, HDMI(고화질 멀티미디어 인터페이스), 컴포지트 비디오 링크, 구성요소 비디오 링크, DVI(디지털 비디오 인터페이스), 아날로그 오디오 연결, 비디오 버스 또는 미디어 데이터 포트(916)와 같은 기타 유사한 통신 링크를 통해 오디오 구성요소 및/또는 디스플레이 구성요소와 통신할 수 있다. 일부 구현예에서, 오디오 시스템(912) 및/또는 디스플레이 시스템(914)은 SoC(900)의 외부 또는 별도의 구성요소다. 대안적으로, 디스플레이 시스템(914)은 예를 들어 통합 터치 인터페이스의 일부와 같은 예시적인 SoC(900)의 통합 구성요소일 수 있다.In some implementations, SoC 900 may also process audio data and/or transfer audio and video data to audio system 912 and/or display system 914 (e.g., a video buffer or a screen of a smartphone or camera). ) includes an audio and/or video processing system 910 that delivers to. Audio system 912 and/or display system 914 may include any device that processes, displays, and/or renders audio, video, display, and/or image data. Display data and audio signals can be transmitted through a radio frequency (RF) link, S-video link, high-definition multimedia interface (HDMI), composite video link, component video link, digital video interface (DVI), analog audio connection, video bus, or media data port. Other similar communication links, such as 916, may communicate with the audio component and/or display component. In some implementations, audio system 912 and/or display system 914 are external or separate components of SoC 900. Alternatively, display system 914 may be an integrated component of example SoC 900, such as part of an integrated touch interface.
도 9의 SoC(900)는 도 1의 장치(102)의 예시적인 구현일 수 있고, 도 1 내지 도 8을 참조하여 설명된 보안 SPI 통신의 양태를 수행할 수 있는 디바이스 또는 시스템의 예시적인 구현일 수 있다. 따라서 SoC(900)는 별도의 회로 또는 IP 블록이거나 프로세서(106), 전자 회로(902) 또는 메모리 디바이스(904)와 같은 또 다른 IC 칩 또는 디바이스의 일부로 포함될 수 있는, 보안 회로(112)(예: RoT 디바이스), SPI 명령 필터(116) 및/또는 SPI 클록 컨트롤러(118)를 포함할 수 있다. 따라서, 예시된 구성요소 중 하나 이상은 동일한 반도체 기판, 반도체 패키지, IC 칩, SoC, 또는 단일 인쇄 회로 기판(PCB) 상에 집적될 수 있다.SoC 900 of FIG. 9 may be an example implementation of device 102 of FIG. 1 and is an example implementation of a device or system capable of performing aspects of secure SPI communications described with reference to FIGS. 1-8. It can be. Accordingly, SoC 900 includes security circuitry 112 (e.g., : RoT device), SPI command filter 116, and/or SPI clock controller 118. Accordingly, one or more of the illustrated components may be integrated on the same semiconductor substrate, semiconductor package, IC chip, SoC, or single printed circuit board (PCB).
도시된 바와 같이, SoC(900)의 보안 회로(112)는 SPI 명령 필터(116) 및 SPI 클록 컨트롤러(118)의 인스턴스로 구현되며, 이는 도 1-5에 설명된 바와 같은 구성요소를 포함하거나 구성될 수 있다(예를 들어, 보안 SPI 통신 모듈로서). 이와 같이, 보안 회로(112), SPI 명령 필터(116) 및 SPI 클록 컨트롤러(118)는 SoC(900)가 본 명세서에 설명된 보안 SPI 통신의 양태를 구현하도록 할 수 있다. 예를 들어, SPI 명령 필터(116)는 SoC(900)의 호스트와 SoC(900)의 플래시 메모리 모듈(예를 들어, 메모리 디바이스(904))에 의해 교환되는 통신을 모니터링할 수 있다. 양태에서, SPI 명령 필터(116)는 호스트에 의해 송신된 통신들의 각 명령들을 플래시 메모리 모듈이 실행하도록 승인되지 않은 명령들을 나타내는 정보와 비교한다. 비교에 기초하여, SPI 명령 필터(116)는 각 명령들 중 하나가 플래시 메모리 모듈이 실행하도록 승인되지 않은 명령들(예를 들어, 쓰기 상태 레지스터 명령) 중 하나라고 결정한다. 이러한 결정에 응답하여, SPI 명령 필터(116)는 플래시 메모리 모듈의 칩 선택 라인을 디어설팅하거나 SPI 클록 컨트롤러(118)를 사용하여 플래시 메모리 모듈의 SPI 클록 라인을 게이팅하거나 정지할 수 있다. 그렇게 함으로써, SPI 명령 필터(116)는 플래시 메모리 모듈이 승인되지 않은 명령의 적어도 일부를 수신하거나 프로세싱하는 것을 방지할 수 있고, 이는 승인되지 않은 명령이 플래시 메모리 모듈의 보안을 구성하는 것을 방지할 수 있다. 대안적으로 또는 추가적으로, SPI 명령 필터(116) 또는 보안 SPI 통신 모듈은 플래시 메모리 모듈의 제1 파티션에 저장된 바이너리 이미지의 무결성을 검증할 수 있다. 무결성 검증이 실패하면, SPI 명령 필터(116)는 SPI 인터커넥트 트랜잭션의 주소를 변경하여 또 다른 바이너리 이미지가 플래시 메모리 모듈의 제2 파티션으로부터 로드되도록 하여 호스트가 확인되지 않고 손상되었을 가능성이 있는 바이너리 이미지를 제1 파티션으로부터 로드하는 것을 방지할 수 있다. 따라서 본 명세서에 설명된 보안 SPI 통신의 개념은 도 9의 SoC(900)에 의해 또는 이와 함께 구현될 수 있다.As shown, the security circuitry 112 of SoC 900 is implemented as an instance of an SPI command filter 116 and an SPI clock controller 118, which includes components as described in FIGS. 1-5 or Can be configured (e.g., as a secure SPI communication module). As such, security circuitry 112, SPI command filter 116, and SPI clock controller 118 may enable SoC 900 to implement aspects of secure SPI communications described herein. For example, SPI command filter 116 may monitor communications exchanged by a host of SoC 900 and a flash memory module (e.g., memory device 904) of SoC 900. In an aspect, SPI command filter 116 compares each command in communications transmitted by the host to information indicating commands that the flash memory module is not authorized to execute. Based on the comparison, SPI command filter 116 determines that one of each command is one of the commands that the flash memory module is not authorized to execute (e.g., a write status register command). In response to this decision, SPI command filter 116 may deassert the chip select line of the flash memory module or use SPI clock controller 118 to gate or disable the SPI clock line of the flash memory module. By doing so, the SPI command filter 116 may prevent the flash memory module from receiving or processing at least some of the unauthorized commands, which may prevent the unauthorized commands from configuring the security of the flash memory module. there is. Alternatively or additionally, SPI command filter 116 or a secure SPI communication module may verify the integrity of the binary image stored in the first partition of the flash memory module. If the integrity verification fails, the SPI command filter 116 changes the address of the SPI interconnect transaction to cause another binary image to be loaded from the second partition of the flash memory module, leaving the host with an unverified and possibly corrupted binary image. Loading from the first partition can be prevented. Accordingly, the concept of secure SPI communication described herein may be implemented by or in conjunction with SoC 900 of FIG. 9.
문맥상 달리 지시하지 않는 한, 본 명세서에서 "또는"이라는 단어의 사용은 "또는"이라는 단어에 의해 연결된 하나 이상의 항목을 포함하거나 적용할 수 있는 용어를 사용하는 것으로 간주될 수 있다(예를 들어, "A 또는 B"라는 문구는 "A"만 허용하거나 "B"만 허용하거나 "A"와 "B"를 모두 허용하는 것으로 해석될 수 있다). 또한, 본 명세서에서 사용된 바와 같이, 항목 목록 "중 적어도 하나"를 지칭하는 문구는 단일 멤버를 포함하여 해당 항목들의 임의의 조합을 의미한다. 예를 들어, “a, b, 또는 c 중 적어도 하나”는 a, b, c, a-b, a-c, b-c 및 a-b-c뿐만 아니라 동일한 요소의 배수와의 임의의 조합(예: a-a, a-a-a, a-a-b, a-a-c, a-b-b, a-c-c, b-b, b-b-b, b-b-c, c-c 및 c-c-c 또는 기타 a, b 및 c의 다른 순서)도 포함할 수 있다. 또한, 첨부된 도면에 표시된 항목 및 본 명세서에 논의된 용어는 하나 이상의 항목 또는 용어를 나타낼 수 있으며, 따라서 본 설명에서 항목 및 용어의 단일 또는 복수 형태가 상호교환적으로 참조될 수 있다. 보안 SPI 통신의 양태가 특정 기능 및/또는 방법과 관련된 언어로 설명되었지만, 첨부된 청구범위의 주제는 설명된 특정 기능 또는 방법으로 반드시 제한되는 것은 아니다. 오히려 보안 SPI 통신을 위한 예시적인 구현으로서 구체적인 특징과 방법이 공개된다.Unless the context dictates otherwise, use of the word “or” herein may be considered to use a term that includes or is applicable to one or more items joined by the word “or” (e.g. , the phrase “A or B” can be interpreted to allow only “A”, only “B”, or both “A” and “B”). Additionally, as used herein, a phrase referring to “at least one of” a list of items means any combination of those items, including a single member. For example, “at least one of a, b, or c” means a, b, c, a-b, a-c, b-c, and a-b-c, as well as any combination of multiples of the same element, such as a-a, a-a-a, a-a-b, a-a-c , a-b-b, a-c-c, b-b, b-b-b, b-b-c, c-c and c-c-c or other sequences of a, b and c). Additionally, items shown in the accompanying drawings and terms discussed herein may refer to more than one item or term, and thus single or plural forms of items and terms may be referred to interchangeably in this description. Although aspects of secure SPI communication have been described in language relating to specific functions and/or methods, the subject matter of the appended claims is not necessarily limited to the specific functions or methods described. Rather, specific features and methods are disclosed as an example implementation for secure SPI communication.
다음에서는 보안 SPI 패스스루 모듈의 예시적인 구현이 정의되고 설명된다.In the following, an example implementation of a secure SPI passthrough module is defined and described.
module spi_passthroughmodule spi_passthrough
import spi_device_pkg::*; import spi_device_pkg::*;
((
input clk_i, // SPI input clk input clk_i, // SPI input clk
input rst_ni, // SPI reset input rst_ni, // SPI reset
input clk_out_i, // SPI output clk input clk_out_i, // SPI output clk
구성 명령 필터 정보는 256비트 레지스터로 제공될 수 있다. Config 명령이 DPSRAM에 저장된 경우 변경될 수 있다. 이것이 지원되는 경우 config 명령은 6번째 명령 사이클에서 유효하며 8비트만 제공된다.Configuration command filter information can be provided in 256-bit registers. Config commands may be changed if stored in DPSRAM. If this is supported, the config command is valid on the 6th command cycle and only 8 bits are provided.
input [255:0] cfg_cmd_filter_i, input [255:0] cfg_cmd_filter_i,
// address manipulation // address manipulation
input [31:0] cfg_addr_mask_i, input [31:0] cfg_addr_mask_i;
input [31:0] cfg_addr_value_i, input [31:0] cfg_addr_value_i;
Address mode:Address mode:
input cfg_addr_4b_en_i, input cfg_addr_4b_en_i,
input spi_mode_e spi_mode_i, input spi_mode_e spi_mode_i,
SPI in의 경우, 패스스루 모듈은 기존 spi_s2p 및 cmdparse를 재사용할 수 있다. 그러나 패스스루는 A/B 바이너리 체계를 지원하기 위해 자체 s2p 및 cmdparse를 구현한다.For SPI in, the passthrough module can reuse the existing spi_s2p and cmdparse. However, Passthrough implements its own s2p and cmdparse to support the A/B binary system.
input host_sck_i,input host_sck_i,
input host_csb_i,input host_csb_i,
input [3:0] host_s_i,input [3:0] host_s_i;
output logic [3:0] host_s_o, // clk_out_i domainoutput logic [3:0] host_s_o, // clk_out_i domain
output logic [3:0] host_s_en_o, // clk_out_i domainoutput logic [3:0] host_s_en_o, // clk_out_i domain
일부 구현 예에서, SPI에서 SPI_HOST로, 터미널에서 다운스트림 디바이스로 출력 passthrough_req_t passthrough_o, 입력 passthrough_rsp_t passthrough_i,In some implementations, output passthrough_req_t passthrough_o, input passthrough_rsp_t passthrough_i, from SPI to SPI_HOST, terminal to downstream device.
메일박스 인디케이터, 측면에서, 읽기 명령이 메일박스 주소에 속하고 메일박스 피처가 활성화된 경우, 'Read Command' 프로세스 모듈은 SPI 라인을 제어하기 위해 패스스루에 신호를 송신한다. 주소 단계(phase) 에서 이 신호가 어설팅되면, 패스스루는 CSb를 SPI 플래시 디바이스로 드롭하고 호스트의 CSb 디어설션을 기다린다. In terms of mailbox indicator, if the read command belongs to the mailbox address and the mailbox feature is activated, the 'Read Command' process module sends a signal to the passthrough to control the SPI line. When this signal is asserted in the address phase, passthrough drops the CSb to the SPI flash device and waits for the host to deassert the CSb.
input mailbox_hit_i, input mailbox_hit_i,
// event // event
// `cmd_filtered`: indicator of the incoming command filtered out // `cmd_filtered`: indicator of the incoming command filtered out
output event_cmd_filtered_o output event_cmd_filtered_o
););
보안 SPI 패스스루와 관련하여 일부 정의는 다음과 같이 정의된다:Some definitions related to secure SPI passthrough are defined as follows:
StateState
typedef enum logic [2:0] {typedef enum logic [2:0] {
Idle 상태에서, 들어오는 SPI를 SPI_HOST로 포워딩하고, 나중에는 SPI 플래시 디바이스로 포워딩한다.In Idle state, incoming SPI is forwarded to SPI_HOST and later to the SPI flash device.
StIdle,StIdle,
비트가 8번째 비트(정확히 7.5)에 도달하면 상태 머신은 들어오는 데이터를 체크하고 주어진 config, cmd_filter에 기초하여 명령을 차단할지 또는 다운스트림 디바이스로 계속 포워딩할지 결정할 수 있다.When the bit reaches the 8th bit (7.5 to be exact), the state machine can check the incoming data and decide whether to block the command or continue forwarding it to the downstream device based on the given config, cmd_filter.
StFilter,StFilter,
명령이 필터링된 경우, StWait에서 SPI_HOST Ip에 대한 이 SCK는 턴 오프되고 CSb가 디어설팅될 수 있다. SCK는 StFilter에서 턴 오프된다. 이 Wait 상태에서, 상태 머신은 호스트 시스템으로부터 CSb 디-어설션을 기다린다.If the command is filtered, this SCK for SPI_HOST IP in StWait is turned off and CSb can be deasserted. SCK is turned off at StFilter. In this Wait state, the state machine waits for a CSb de-assertion from the host system.
StWait,StWait,
출력 명령 핸들링 - 이는 대부분 SPI 플래시 모드로부터 중복된 코드이지만, 출력 활성화를 제어하기 위해 여기에 존재한다. 패스스루 모드에서, 명령이 허용되면, 데이터는 다운스트림 디바이스로부터 제공되지만 출력 상태(high-Z 또는 구동)에 대한 힌트는 제공하지 않는다. 따라서 패스스루 모듈은 업스트림 패드의 'oe'를 제어하기 위해 SPI 프로토콜을 따라야 한다. Read Command 모듈, Status 모듈, SFDP/JEDEC 모듈에 설명된 것과 동일한 프로토콜을 따른다. St가 StIdle 또는 StAddress로부터 StHighZ로 이동하면, 대기 타이머를 설정해야 한다. 대기 타이머가 만료되고 StHighZ는 CSb가 디어설팅될 때까지 dead-end인 StDriving으로 이동한다.Output command handling - This is mostly duplicated code from SPI flash mode, but is here to control output activation. In pass-through mode, if the command is accepted, data is provided from the downstream device, but no hint is provided as to the output state (high-Z or running). Therefore, the passthrough module must follow the SPI protocol to control the 'oe' of the upstream pad. It follows the same protocol as described in the Read Command module, Status module, and SFDP/JEDEC module. When St moves from StIdle or StAddress to StHighZ, a wait timer must be set. The wait timer expires and StHighZ moves to dead-end StDriving until CSb is deasserted.
StDriving, StDriving,
StHighZ, StHighZ,
양태에서, 주소 조작은 본 명세서에 설명된 바와 같이 구현될 수 있다. 예를 들어, SPI Passthrough의 특별한 피처 중 하나는 A/B 바이너리 이미지 지원이다. 로직은 특정 데이터 비트를 사전 구성된 값으로 스왑할 수 있다. 이 상태에서, 로직은 addr_mask 및 데이터를 확인하고 필요한 경우 라인을 스왑한다. 그 후, ST는 StDriving 또는 StHighZ로 이동한다. 주소가 메일박스 영역과 SW 지원 메일박스에 도달하면, ST는 현재 트랜잭션을 취소하고 StWait 상태로 이동한다.In aspects, address manipulation may be implemented as described herein. For example, one of the special features of SPI Passthrough is support for A/B binary images. Logic can swap specific data bits to preconfigured values. In this state, logic checks addr_mask and data and swaps lines if necessary. Afterwards, ST moves to StDriving or StHighZ. When the address reaches the mailbox area and SW support mailbox, the ST cancels the current transaction and moves to the StWait state.
StAddress StAddress
} passthrough_st_e; } passthrough_st_e;
passthrough_st_e st, st_d; passthrough_st_e st, st_d;
Example Command Types and various commandsExample Command Types and various commands
패스스루 모듈은 SPI 라인의 모든 비트를 엄격하게 따르지는 않지만 명령의 단계(phase)를 느슨하게 추적할 수 있다. SPI 플래시의 명령은 다음과 같이 분류될 수 있다:The passthrough module does not strictly follow every bit on the SPI line, but can loosely track the phase of the command. Commands in SPI flash can be classified as follows:
// - {Address, PayloadOut}: examples are ReadData // - {Address, PayloadOut}: examples are ReadData
// - {Address, Dummy, PayloadOut}: FastRead / Dual/ Quad commands have dummy // - {Address, Dummy, PayloadOut}: FastRead / Dual / Quad commands have dummy
// - {Dummy, PayloadOut}: Release Power-down / Manufacturer ID // - {Dummy, PayloadOut}: Release Power-down / Manufacturer ID
// - {PayloadOut}: Right after opcode, the device sends data to host // - {PayloadOut}: Right after opcode, the device sends data to host
// - {Address, PayloadIn}: Host sends address and payload back-to-back // - {Address, PayloadIn}: Host sends address and payload back-to-back
// - {PayloadIn}: Host sends payload without any address hint //-{PayloadIn}: Host sends payload without any address hint
// - None: The commands complete without any address payload(in/out) // - None: The commands complete without any address payload(in/out)
수신된 명령이 두 개 이상의 상태를 가지는 경우, 상태 머신이 정확한 타이밍에 다음 상태로 이동할 수 있도록 카운터 값이 설정된다. `cmd_type_t` 구조체는 명령에 대한 정보를 가진다. 명령의 실제 값은 컴파일 시간 파라미터이다. 로직이 8비트 opcode를 수신하면 파라미터를 이 구조체에 래치하고 트랜잭션을 통해 이를 참조한다.If the received command has more than one state, a counter value is set so that the state machine can move to the next state at the correct timing. The `cmd_type_t` structure contains information about the command. The actual value of the command is a compile-time parameter. When the logic receives an 8-bit opcode, it latches the parameters into this structure and references it through a transaction.
An example Address or anything host driving after opcode counterAn example Address or anything host driving after opcode counter
localparam int unsigned MaxAddrBit = 32; localparam int unsigned MaxAddrBit = 32;
localparam int unsigned AddrCntW = $clog2(MaxAddrBit); localparam int unsigned AddrCntW = $clog2(MaxAddrBit);
An example DummyAn example Dummy
localparam int unsigned MaxDummyBit = 8; localparam int unsigned MaxDummyBit = 8;
localparam int unsigned DummyCntW = $clog2(MaxDummyBit); localparam int unsigned DummyCntW = $clog2(MaxDummyBit);
typedef enum logic { typedef enum logical {
PayloadIn = 1'b 0, PayloadIn = 1'b 0;
PayloadOut = 1'b 1 PayloadOut = 1'b 1
} payload_dir_e; } payload_dir_e;
typedef struct packed { typedef struct packed {
Address ExistAddress Exist
logic addr_en; logic addr_en;
swap_en이 1인 경우, 로직은 incomind addr을 특정 비트에 대해 사전 구성된 값으로 교체한다.If swap_en is 1, the logic replaces incomind addr with the preconfigured value for that specific bit.
logic addr_swap_en;logic addr_swap_en;
1인 경우, `cfg_addr_4b_en_i` logic addr_4b_affected에 의해 영향을 받는다.If 1, it is affected by the `cfg_addr_4b_en_i` logic addr_4b_affected.
An example, when Dummy ExistAn example, when Dummy Exist
logic dummy_en;logic dummy_en;
Payload Direction: payload_en이 설정된 경우, 명령은 어느 방향이든 페이로드(payload)를 갖는다. `payload_dir`은 입력(0) 또는 출력(1)을 결정한다.Payload Direction: If payload_en is set, the command has payload in either direction. `payload_dir` determines input (0) or output (1).
logic [3:0] payload_en; logic [3:0] payload_en;
payload_dir_e payload_dir; payload_dir_e payload_dir;
양태에서, addr_size는 `addr_4b_affected`에 기초하여 결정된다. 1이고 `cfg_addr_4b_en_i`가 1인 경우, `addr_size`는 31이다. 다른 경우에는 23으로 설정된다.In an aspect, addr_size is determined based on `addr_4b_affected`. If 1 and `cfg_addr_4b_en_i` is 1, `addr_size` is 31. In other cases, it is set to 23.
logic [AddrCntW-1:0] addr_size;logic [AddrCntW-1:0] addr_size;
logic [DummyCntW-1:0] dummy_size;logic [DummyCntW-1:0] dummy_size;
} cmd_type_t; } cmd_type_t;
localparam cmd_type_t CmdInfoNone = '{ localparam cmd_type_t CmdInfoNone = '{
addr_en: 1'b 0, addr_en: 1'b 0;
addr_swap_en: 1'b 0, addr_swap_en: 1'b 0;
addr_4b_affected: 1'b 0, addr_4b_affected: 1'b 0;
dummy_en: 1'b 0, dummy_en: 1'b 0;
payload_en: 4'h 0, payload_en: 4'h 0;
payload_dir: PayloadIn, payload_dir: PayloadIn;
addr_size: '0, addr_size: '0,
dummy_size: '0 dummy_size: '0
}; };
localparam cmd_type_t CmdInfoPayloadIn = '{ localparam cmd_type_t CmdInfoPayloadIn = '{
addr_en: 1'b 0, addr_en: 1'b 0;
addr_swap_en: 1'b 0, addr_swap_en: 1'b 0;
addr_4b_affected: 1'b 0, addr_4b_affected: 1'b 0;
dummy_en: 1'b 0, dummy_en: 1'b 0;
payload_en: 4'h 1, payload_en: 4'h 1,
payload_dir: PayloadIn, payload_dir: PayloadIn;
addr_size: '0, addr_size: '0,
dummy_size: '0 dummy_size: '0
}; };
localparam cmd_type_t CmdInfoPayloadOut = '{ localparam cmd_type_t CmdInfoPayloadOut = '{
addr_en: 1'b 0, addr_en: 1'b 0;
addr_swap_en: 1'b 0, addr_swap_en: 1'b 0;
addr_4b_affected: 1'b 0, addr_4b_affected: 1'b 0;
dummy_en: 1'b 0, dummy_en: 1'b 0;
payload_en: 4'h 2, // S[1] payload_en: 4'h 2, // S[1]
payload_dir: PayloadOut, payload_dir: PayloadOut;
addr_size: '0, addr_size: '0,
dummy_size: '0 dummy_size: '0
}; };
localparam cmd_type_t CmdInfoAddrPayloadIn = '{ localparam cmd_type_t CmdInfoAddrPayloadIn = '{
addr_en: 1'b 1, addr_en: 1'b 1;
addr_swap_en: 1'b 0, addr_swap_en: 1'b 0;
addr_4b_affected: 1'b 1, addr_4b_affected: 1'b 1;
dummy_en: 1'b 0, dummy_en: 1'b 0;
payload_en: 4'h 1, // S[0] only payload_en: 4'h 1, // S[0] only
payload_dir: PayloadIn, // Host sends Data payload_dir: PayloadIn, // Host sends Data
addr_size: '0, // Logic decide addr_size: '0, // Logic decide
dummy_size: '0 dummy_size: '0
}; };
localparam cmd_type_t CmdInfoAddrPayloadInQuad = '{ localparam cmd_type_t CmdInfoAddrPayloadInQuad = '{
addr_en: 1'b 1, addr_en: 1'b 1;
addr_swap_en: 1'b 0, addr_swap_en: 1'b 0;
addr_4b_affected: 1'b 1, addr_4b_affected: 1'b 1;
dummy_en: 1'b 0, dummy_en: 1'b 0;
payload_en: 4'h F, // S[3:0] payload_en: 4'h F, // S[3:0]
payload_dir: PayloadIn, // Host sends Data payload_dir: PayloadIn, // Host sends Data
addr_size: '0, // Logic decide addr_size: '0, // Logic decide
dummy_size: '0 dummy_size: '0
}; };
localparam cmd_type_t CmdInfoAddrPayloadOut = '{ localparam cmd_type_t CmdInfoAddrPayloadOut = '{
addr_en: 1'b 1, addr_en: 1'b 1;
addr_swap_en: 1'b 1, addr_swap_en: 1'b 1;
addr_4b_affected: 1'b 1, addr_4b_affected: 1'b 1;
dummy_en: 1'b 0, dummy_en: 1'b 0;
payload_en: 4'h 2, // S[1] only payload_en: 4'h 2, // S[1] only
payload_dir: PayloadOut, // Flash device sends Data payload_dir: PayloadOut, // Flash device sends Data
addr_size: '0, // Logic decide addr_size: '0, // Logic decide
dummy_size: '0 dummy_size: '0
}; };
// Address + Dummy + Payload but Address is 3B always localparam cmd_type_t CmdInfoAddr3BDummyPayloadOut = '{ // Address + Dummy + Payload but Address is 3B always localparam cmd_type_t CmdInfoAddr3BDummyPayloadOut = '{
addr_en: 1'b 1, addr_en: 1'b 1;
addr_swap_en: 1'b 0, addr_swap_en: 1'b 0;
addr_4b_affected: 1'b 0, addr_4b_affected: 1'b 0;
dummy_en: 1'b 1, dummy_en: 1'b 1;
payload_en: 4'h 2, // S[1] only payload_en: 4'h 2, // S[1] only
payload_dir: PayloadOut, // Flash device sends Data payload_dir: PayloadOut, // Flash device sends Data
addr_size: '0, // Logic decide addr_size: '0, // Logic decide
dummy_size: 'h 7 dummy_size: 'h 7
}; };
localparam cmd_type_t CmdInfoAddrDummyPayloadOut = '{ localparam cmd_type_t CmdInfoAddrDummyPayloadOut = '{
addr_en: 1'b 1, addr_en: 1'b 1;
addr_swap_en: 1'b 1, addr_swap_en: 1'b 1;
addr_4b_affected: 1'b 1, addr_4b_affected: 1'b 1;
dummy_en: 1'b 1, dummy_en: 1'b 1;
payload_en: 4'h 2, // S[1] only payload_en: 4'h 2, // S[1] only
payload_dir: PayloadOut, // Flash device sends Data payload_dir: PayloadOut, // Flash device sends Data
addr_size: '0, // Logic decide addr_size: '0, // Logic decide
dummy_size: 'h 7 dummy_size: 'h 7
}; };
localparam cmd_type_t CmdInfoAddrDummyPayloadOutDual = '{ localparam cmd_type_t CmdInfoAddrDummyPayloadOutDual = '{
addr_en: 1'b 1, addr_en: 1'b 1;
addr_swap_en: 1'b 1, addr_swap_en: 1'b 1;
addr_4b_affected: 1'b 1, addr_4b_affected: 1'b 1;
dummy_en: 1'b 1, dummy_en: 1'b 1;
payload_en: 4'h 3, // S[1:0] only payload_en: 4'h 3, // S[1:0] only
payload_dir: PayloadOut, // Flash device sends Data payload_dir: PayloadOut, // Flash device sends Data
addr_size: '0, // Logic decide addr_size: '0, // Logic decide
dummy_size: 'h 7 dummy_size: 'h 7
}; };
localparam cmd_type_t CmdInfoAddrDummyPayloadOutQuad = '{ localparam cmd_type_t CmdInfoAddrDummyPayloadOutQuad = '{
addr_en: 1'b 1, addr_en: 1'b 1;
addr_swap_en: 1'b 1, addr_swap_en: 1'b 1;
addr_4b_affected: 1'b 1, addr_4b_affected: 1'b 1;
dummy_en: 1'b 1, dummy_en: 1'b 1;
payload_en: 4'h F, // S[3:0] payload_en: 4'h F, // S[3:0]
payload_dir: PayloadOut, // Flash device sends Data payload_dir: PayloadOut, // Flash device sends Data
addr_size: '0, // Logic decide addr_size: '0, // Logic decide
dummy_size: 'h 7 dummy_size: 'h 7
}; };
localparam cmd_type_t CmdInfoAddr = '{ localparam cmd_type_t CmdInfoAddr = '{
addr_en: 1'b 1, addr_en: 1'b 1;
addr_swap_en: 1'b 0, addr_swap_en: 1'b 0;
addr_4b_affected: 1'b 0, // TODO: ?? addr_4b_affected: 1'b 0, // TODO: ??
dummy_en: 1'b 0, dummy_en: 1'b 0;
payload_en: 4'h 0, payload_en: 4'h 0;
payload_dir: PayloadOut, // Flash device sends Data payload_dir: PayloadOut, // Flash device sends Data
addr_size: '0, // Logic decide addr_size: '0, // Logic decide
dummy_size: 'h 0 dummy_size: 'h 0
}; };
localparam cmd_type_t PassThroughCmdInfo [256] = '{ localparam cmd_type_t PassThroughCmdInfo [256] = '{
CmdInfoNone, // 8'h 00 CmdInfoNone, // 8'h 00
CmdInfoPayloadIn, // 8'h 01 Write Status 1 CmdInfoPayloadIn, // 8'h 01 Write Status 1
CmdInfoAddrPayloadIn, // 8'h 02 Page Program CmdInfoAddrPayloadIn, // 8'h 02 Page Program
CmdInfoAddrPayloadOut, // 8'h 03 Read Data CmdInfoAddrPayloadOut, // 8'h 03 Read Data
CmdInfoNone, // 8'h 04 Write Disable CmdInfoNone, // 8'h 04 Write Disable
CmdInfoPayloadOut, // 8'h 05 Read Status 1 CmdInfoPayloadOut, // 8'h 05 Read Status 1
CmdInfoNone, // 8'h 06 Write Enable CmdInfoNone, // 8'h 06 Write Enable
CmdInfoNone, // 8'h 07 CmdInfoNone, // 8'h 07
CmdInfoNone, // 8'h 08 CmdInfoNone, // 8'h 08
CmdInfoNone, // 8'h 09 CmdInfoNone, // 8'h 09
CmdInfoNone, // 8'h 0A CmdInfoNone, // 8'h 0A
CmdInfoAddrDummyPayloadOut, // 8'h 0B Fast Read CmdInfoAddrDummyPayloadOut, // 8'h 0B Fast Read
CmdInfoNone, // 8'h 0C CmdInfoNone, // 8'h 0C
CmdInfoNone, // 8'h 0D CmdInfoNone, // 8'h 0D
CmdInfoNone, // 8'h 0E CmdInfoNone, // 8'h 0E
CmdInfoNone, // 8'h 0F CmdInfoNone, // 8'h 0F
CmdInfoNone, // 8'h 10 CmdInfoNone, // 8'h 10
CmdInfoPayloadIn, // 8'h 11 Write Status 3 CmdInfoPayloadIn, // 8'h 11 Write Status 3
CmdInfoNone, // 8'h 12 CmdInfoNone, // 8'h 12
CmdInfoNone, // 8'h 13 CmdInfoNone, // 8'h 13
CmdInfoNone, // 8'h 14 CmdInfoNone, // 8'h 14
CmdInfoPayloadOut, // 8'h 15 Read Status 3 CmdInfoPayloadOut, // 8'h 15 Read Status 3
CmdInfoNone, // 8'h 16 CmdInfoNone, // 8'h 16
... ...
CmdInfoNone, // 8'h 1F CmdInfoNone, // 8'h 1F
CmdInfoAddr, // 8'h 20 Sector Erase (4kB) CmdInfoAddr, // 8'h 20 Sector Erase (4kB)
CmdInfoNone, // 8'h 21 CmdInfoNone, // 8'h 21
... ...
CmdInfoNone, // 8'h 30 CmdInfoNone, // 8'h 30
CmdInfoPayloadIn, // 8'h 31 Write Status 2 CmdInfoPayloadIn, // 8'h 31 Write Status 2
CmdInfoAddrPayloadInQuad, // 8'h 32 Quad Input Page Program CmdInfoAddrPayloadInQuad, // 8'h 32 Quad Input Page Program
CmdInfoNone, // 8'h 33 CmdInfoNone, // 8'h 33
CmdInfoNone, // 8'h 34 CmdInfoNone, // 8'h 34
CmdInfoPayloadOut, // 8'h 35 Read Status 2 CmdInfoPayloadOut, // 8'h 35 Read Status 2
CmdInfoAddr, // 8'h 36 Individual Block Lock CmdInfoAddr, // 8'h 36 Individual Block Lock
CmdInfoNone, // 8'h 37 CmdInfoNone, // 8'h 37
CmdInfoNone, // 8'h 38 Enter QPI (filtered) CmdInfoNone, // 8'h 38 Enter QPI (filtered)
CmdInfoAddr, // 8'h 39 Individual Blck Unlock CmdInfoAddr, // 8'h 39 Individual Blck Unlock
CmdInfoNone, // 8'h 3A CmdInfoNone, // 8'h 3A
CmdInfoAddrDummyPayloadOutDual, // 8'h 3B Fast Read Dual Out CmdInfoAddrDummyPayloadOutDual, // 8'h 3B Fast Read Dual Out
CmdInfoNone, // 8'h 3C CmdInfoNone, // 8'h 3C
CmdInfoAddrPayloadOut, // 8'h 3D Read Block Lock CmdInfoAddrPayloadOut, // 8'h 3D Read Block Lock
CmdInfoNone, // 8'h 3E CmdInfoNone, // 8'h 3E
CmdInfoNone, // 8'h 3F CmdInfoNone, // 8'h 3F
CmdInfoNone, // 8'h 40 CmdInfoNone, // 8'h 40
CmdInfoNone, // 8'h 41 CmdInfoNone, // 8'h 41
CmdInfoNone, // 8'h 42 TODO CmdInfoNone, // 8'h 42 TODO
CmdInfoNone, // 8'h 43 CmdInfoNone, // 8'h 43
CmdInfoNone, // 8'h 44 TODO CmdInfoNone, // 8'h 44 TODO
CmdInfoNone, // 8'h 45 CmdInfoNone, // 8'h 45
CmdInfoNone, // 8'h 46 CmdInfoNone, // 8'h 46
CmdInfoNone, // 8'h 47 CmdInfoNone, // 8'h 47
CmdInfoNone, // 8'h 48 TODO CmdInfoNone, // 8'h 48 TODO
CmdInfoNone, // 8'h 49 CmdInfoNone, // 8'h 49
CmdInfoNone, // 8'h 4A CmdInfoNone, // 8'h 4A
CmdInfoNone, // 8'h 4B Read Unique ID (TODO) CmdInfoNone, // 8'h 4B Read Unique ID (TODO)
CmdInfoNone, // 8'h 4C CmdInfoNone, // 8'h 4C
CmdInfoNone, // 8'h 4D CmdInfoNone, // 8'h 4D
CmdInfoNone, // 8'h 4E CmdInfoNone, // 8'h 4E
CmdInfoNone, // 8'h 4F CmdInfoNone, // 8'h 4F
CmdInfoNone, // 8'h 50 CmdInfoNone, // 8'h 50
CmdInfoNone, // 8'h 51 CmdInfoNone, // 8'h 51
CmdInfoAddr, // 8'h 52 Block Erase (32kB) CmdInfoAddr, // 8'h 52 Block Erase (32kB)
CmdInfoNone, // 8'h 53 CmdInfoNone, // 8'h 53
CmdInfoNone, // 8'h 54 CmdInfoNone, // 8'h 54
CmdInfoNone, // 8'h 55 CmdInfoNone, // 8'h 55
CmdInfoNone, // 8'h 56 CmdInfoNone, // 8'h 56
CmdInfoNone, // 8'h 57 CmdInfoNone, // 8'h 57
CmdInfoNone, // 8'h 58 CmdInfoNone, // 8'h 58
CmdInfoNone, // 8'h 59 CmdInfoNone, // 8'h 59
CmdInfoAddr3BDummyPayloadOut, // 8'h 5A Read SFDP CmdInfoAddr3BDummyPayloadOut, // 8'h 5A Read SFDP
CmdInfoNone, // 8'h 5B CmdInfoNone, // 8'h 5B
... ...
CmdInfoNone, // 8'h 6A CmdInfoNone, // 8'h 6A
CmdInfoAddrDummyPayloadOutQuad, // 8'h 6B Fast Read Quad Out CmdInfoAddrDummyPayloadOutQuad, // 8'h 6B Fast Read Quad Out
CmdInfoNone, // 8'h 6C CmdInfoNone, // 8'h 6C
... ...
CmdInfoNone, // 8'h 9E CmdInfoNone, // 8'h 9E
CmdInfoPayloadOut, // 8'h 9F JEDEC ID CmdInfoPayloadOut, // 8'h 9F JEDEC ID
CmdInfoNone, // 8'h A0 CmdInfoNone, // 8'h A0
... ...
CmdInfoNone, // 8'h D7 CmdInfoNone, // 8'h D7
CmdInfoAddr, // 8'h D8 Block Erase (64kB) CmdInfoAddr, // 8'h D8 Block Erase (64kB)
CmdInfoNone, // 8'h D9 CmdInfoNone, // 8'h D9
... ...
CmdInfoNone // 8'h FF CmdInfoNone // 8'h FF
}; };
An example of Not synthesizable in DCAn example of Not synthesizable in DC
localparam cmd_type_t PassThroughCmdInfoOld [256] = '{ localparam cmd_type_t PassThroughCmdInfoOld [256] = '{
// 8'h 00 // 8'h 00
'h 00: CmdInfoNone, 'h 00: CmdInfoNone,
// 8'h 01 Write Status 1 // 8'h 01 Write Status 1
'h 01: CmdInfoPayloadIn, 'h 01: CmdInfoPayloadIn,
// 8'h 15 Write Statur 2 // 8'h 15 Write Status 2
'h 31: CmdInfoPayloadIn, 'h 31: CmdInfoPayloadIn,
// 8'h 11 Write Status 3 // 8'h 11 Write Status 3
'h 11: CmdInfoPayloadIn, 'h 11: CmdInfoPayloadIn,
// 8'h 02 Page Program // 8'h 02 Page Program
'h 02: CmdInfoAddrPayloadIn, 'h 02: CmdInfoAddrPayloadIn,
// 8'h 32 Quad Input Page Program : Expect to be filtered // 8'h 32 Quad Input Page Program: Expect to be filtered
'h 32: CmdInfoAddrPayloadInQuad, 'h 32: CmdInfoAddrPayloadInQuad,
// 8'h 03 Read Data // 8'h 03 Read Data
'h 03: CmdInfoAddrPayloadOut, 'h 03: CmdInfoAddrPayloadOut,
// 8'h 04 Write Disable // 8'h 04 Write Disable
'h 04: CmdInfoNone, 'h 04: CmdInfoNone,
// 8'h 05 Read Status 1 // 8'h 05 Read Status 1
'h 05: CmdInfoPayloadOut, 'h 05: CmdInfoPayloadOut,
// 8'h 35 Read Status 2 // 8'h 35 Read Status 2
'h 35: CmdInfoPayloadOut, 'h 35: CmdInfoPayloadOut;
// 8'h 15 Read Status 3 // 8'h 15 Read Status 3
'h 15: CmdInfoPayloadOut, 'h 15: CmdInfoPayloadOut;
// 8'h 06 Write Enable // 8'h 06 Write Enable
'h 06: CmdInfoNone, 'h 06: CmdInfoNone,
// 8'h 0B Fast Read // 8'h 0B Fast Read
'h 0B: CmdInfoAddrDummyPayloadOut, 'h 0B: CmdInfoAddrDummyPayloadOut,
// 8'h 3B Fast Read Dual Output // 8'h 3B Fast Read Dual Output
'h 3B: CmdInfoAddrDummyPayloadOutDual, 'h 3B: CmdInfoAddrDummyPayloadOutDual;
// 8'h 6B Fast Read Quad Output // 8'h 6B Fast Read Quad Output
'h 6B: CmdInfoAddrDummyPayloadOutQuad, 'h 6B: CmdInfoAddrDummyPayloadOutQuad;
// 8'h 20 Sector Erase (4kB) // 8'h 20 Sector Erase (4kB)
'h 20: CmdInfoAddr, 'h 20: CmdInfoAddr;
// 8'h 52 Block Erase (32kB) // 8'h 52 Block Erase (32kB)
'h 52: CmdInfoAddr, 'h 52: CmdInfoAddr,
// 8'h D8 Block Erase (64kB) // 8'h D8 Block Erase (64kB)
'h D8: CmdInfoAddr, 'h D8: CmdInfoAddr;
// 8'h 36 Individual Block Lock // 8'h 36 Individual Block Lock
'h 36: CmdInfoAddr, 'h 36: CmdInfoAddr;
// 8'h 39 Individual Block Unlock // 8'h 39 Individual Block Unlock
'h 39: CmdInfoAddr, 'h 39: CmdInfoAddr;
// 8'h 3D Read Block Lock // 8'h 3D Read Block Lock
'h 3D: CmdInfoAddrPayloadOut, 'h 3D: CmdInfoAddrPayloadOut;
// 8'h 38 Enter QPI : Expect to be filtered // 8'h 38 Enter QPI: Expect to be filtered
'h 38: CmdInfoNone, 'h 38: CmdInfoNone;
// 8'h 42 Program Security Register // 8'h 42 Program Security Register
// 8'h 44 Erase Security Register // 8'h 44 Erase Security Register
// 8'h 48 Read Security Register // 8'h 48 Read Security Register
// 8'h 4B Read Unique ID // 8'h 4B Read Unique ID
// 8'h 5A Read SFDP // 8'h 5A Read SFDP
'h 5A: CmdInfoAddr3BDummyPayloadOut, 'h 5A: CmdInfoAddr3BDummyPayloadOut,
// 8'h 90 Manufacture/Device ID // 8'h 90 Manufacture/Device ID
// 8'h 9F JEDEC ID // 8'h 9F JEDEC ID
'h 9F: CmdInfoPayloadOut, 'h 9F: CmdInfoPayloadOut;
default: CmdInfoNone default: CmdInfoNone
}; };
*/ */
Example SignalsExample Signals
internal clockinternal clock
logic [3:0] host_s_en_inclk; logic [3:0] host_s_en_inclk;
logic [3:0] device_s_en_inclk; logic [3:0] device_s_en_inclk;
패스스루 모드가 활성화되었는지 여부를 나타낸다.Indicates whether passthrough mode is activated.
logic is_active; logicis_active;
assign is_active = (spi_mode_i == PassThrough); assign is_active = (spi_mode_i == PassThrough);
logic [7:0] opcode, opcode_d; logic [7:0] opcode, opcode_d;
8번째 비트에서 filter가 1이 되면, SCK 활성화 신호를 CG 셀로 낮추고, SCK의 8번째 posedge에서 csb_deassert는 1이 된다.When the filter becomes 1 in the 8th bit, the SCK activation signal is lowered to the CG cell, and csb_deassert becomes 1 in the 8th posedge of SCK.
logic filter; logic filter;
1이면, SCK가 다운스트림 SPI 플래시 디바이스로 전파된다.If 1, SCK is propagated to downstream SPI flash devices.
logic sck_gate_en; logic sck_gate_en;
다운스트림 디바이스 제어에 대한 CSb 1인 경우, CSb가 디어설팅된다. 이 신호는 글리치에 민감하다. 이 값은 SCK posedge에서 변경된다. 이는 CSb 출력을 직접 구동하지 않는다. 다운스트림으로의 CSb는 이것과 호스트 시스템으로부터의 CSb와 OR-ed된다.If CSb for downstream device control is 1, CSb is deasserted. This signal is sensitive to glitches. This value is changed in SCK posedge. It does not drive the CSb output directly. The CSb downstream is OR-ed with this CSb from the host system.
logic csb_deassert; logic csb_deassert;
Begin Counters - bitcnt to count up to dummyBegin Counters - bitcnt to count up to dummy
localparam int unsigned MaxBeat = 8+32+8; // Cmd + Addr + Dummy localparam int unsigned MaxBeat = 8+32+8; // Cmd + Addr + Dummy
localparam int unsigned BitCntW = $clog2(MaxBeat); localparam int unsigned BitCntW = $clog2(MaxBeat);
logic [BitCntW-1:0] bitcnt; logic [BitCntW-1:0] bitcnt;
Address or anything host driving after opcode counterAddress or anything host driving after opcode counter
logic [AddrCntW-1:0] addrcnt, addrcnt_outclk; logic [AddrCntW-1:0] addrcnt, addrcnt_outclk;
Dummy counterDummy counter
logic [DummyCntW-1:0] dummycnt, dummycnt_d; logic [DummyCntW-1:0] dummycnt, dummycnt_d;
END: Counters END: Counters
An example eventAn example event
assign event_cmd_filtered_o = filter; assign event_cmd_filtered_o = filter;
An example Mailbox hit.An example Mailbox hits.
logic mailbox_hit; logic mailbox_hit;
always_ff @(posedge clk_i or negedge rst_ni) begin always_ff @(posedge clk_i or negedge rst_ni) begin
if (!rst_ni) mailbox_hit <= 1'b 0; // reset by CSb if (!rst_ni) mailbox_hit <= 1'b 0; // reset by CSb
else if (mailbox_hit_i) mailbox_hit <= 1'b 1; // set by event else if (mailbox_hit_i) mailbox_hit <= 1'b 1; // set by event
end end
An example DatapathAn example Datapath
Opcode LatchOpcode Latch
assign opcode_d = {opcode[6:0], host_s_i[0]}; assign opcode_d = {opcode[6:0], host_s_i[0]};
always_ff @(posedge clk_i or negedge rst_ni) begin always_ff @(posedge clk_i or negedge rst_ni) begin
if (!rst_ni) begin if (!rst_ni) begin
opcode <= 8'h 00; opcode <= 8'h 00;
end else if (bitcnt < BitCntW'(8)) begin end else if (bitcnt < BitCntW'(8)) begin
opcode <= opcode_d; opcode <= opcode_d;
end end
end end
Command Filter: CSb controlCommand Filter: CSb control
always_ff @(posedge clk_i or negedge rst_ni) begin always_ff @(posedge clk_i or negedge rst_ni) begin
if (!rst_ni) csb_deassert <= 1'b 0; if (!rst_ni) csb_deassert <= 1'b 0;
else if (filter) csb_deassert <= 1'b 1; else if (filter) csb_deassert <= 1'b 1;
end end
sck_gate_en이 fliter 또는 csb_deassert의 반전인 이유를 알아보려면 위의 파형을 보자.Look at the waveform above to see why sck_gate_en is the inversion of fliter or csb_deassert.
assign sck_gate_en = ~(filter | csb_deassert); assign sck_gate_en = ~(filter | csb_deassert);
Bitcnt 카운터의 예인 Bitcnt는 최대 값에 도달할 때까지 증가한 다음 재설정을 기다린다.Bitcnt, an example of a Bitcnt counter, increments until it reaches its maximum value and then waits for it to reset.
always_ff @(posedge clk_i or negedge rst_ni) begin always_ff @(posedge clk_i or negedge rst_ni) begin
if (!rst_ni) begin if (!rst_ni) begin
bitcnt <= '0; bitcnt <= '0;
end else if (bitcnt != '1) begin end else if (bitcnt != '1) begin
bitcnt <= bitcnt + BitCntW'(1); bitcnt <= bitcnt + BitCntW'(1);
end end
end end
an example Latch only two bits at 7th cmd opcodean example Latch only two bits at 7th cmd opcode
logic cmd_7th; // 7th beat of transaction logic cmd_7th; // 7th beat of transaction
logic cmd_8th; // in 8th beat of transaction logic cmd_8th; // in 8th beat of transaction
logic [1:0] cmd_filter; logic [1:0] cmd_filter;
assign cmd_7th = (bitcnt == BitCntW'(6)); assign cmd_7th = (bitcnt == BitCntW'(6));
assign cmd_8th = (bitcnt == BitCntW'(7)); assign cmd_8th = (bitcnt == BitCntW'(7));
always_ff @(posedge clk_i or negedge rst_ni) begin always_ff @(posedge clk_i or negedge rst_ni) begin
if (!rst_ni) begin if (!rst_ni) begin
cmd_filter <= 2'b 00; cmd_filter <= 2'b 00;
end else if (cmd_7th) begin end else if (cmd_7th) begin
이 예의 7번째 비트에서 cmd_filter는 cfg_cmd_filter_i에서 2비트를 래치한다.At bit 7 in this example, cmd_filter latches 2 bits in cfg_cmd_filter_i.
이렇게 하면 마지막 필터 데이터 경로가 muxing 256에서 mux2로 줄어든다.This reduces the final filter data path from muxing 256 to mux2.
아래 구문이 작동하지 않으면, 다음으로 교체될 수 있다.If the syntax below does not work, it can be replaced with:
for (int unsigned i = 0 ; i < 128 ; i++) begin for (int unsigned i = 0 ; i < 128 ; i++) begin
it (i == opcode[6:0]) cmd_filter <= cfg_cmd_filter_i[2*i+:2]; it (i == opcode[6:0]) cmd_filter <= cfg_cmd_filter_i[2*i+:2];
end end
cmd_filter <= cfg_cmd_filter_i[{opcode_d[6:0],1'b0}+:2]; cmd_filter <= cfg_cmd_filter_i[{opcode_d[6:0],1'b0}+:2];
end end
end end
Example of Command Info LatchExample of Command Info Latch
cmd_type_t cmd_info, cmd_info_d; cmd_type_t cmd_info, cmd_info_d;
cmd_type_t [1:0] cmd_info_7th; cmd_type_t [1:0] cmd_info_7th;
logic cmd_info_latch; logic cmd_info_latch;
always_ff @(posedge clk_i or negedge rst_ni) begin always_ff @(posedge clk_i or negedge rst_ni) begin
if (!rst_ni) begin if (!rst_ni) begin
cmd_info_7th <= '0; cmd_info_7th <= '0;
end else if (cmd_7th) begin end else if (cmd_7th) begin
cmd_info_7th <= {PassThroughCmdInfo[{opcode_d[6:0],1'b1}], cmd_info_7th <= {PassThroughCmdInfo[{opcode_d[6:0],1'b1}],
PassThroughCmdInfo[{opcode_d[6:0],1'b0}]}; PassThroughCmdInfo[{opcode_d[6:0],1'b0}]};
end end
end end
always_ff @(posedge clk_i or negedge rst_ni) begin always_ff @(posedge clk_i or negedge rst_ni) begin
if (!rst_ni) begin if (!rst_ni) begin
cmd_info <= '0; cmd_info <= '0;
end else if (cmd_info_latch) begin end else if (cmd_info_latch) begin
7번째 비트가 도착할 때 두 개의 cmd_info만 래치하는 예이다. 그런 다음 cmd_info_d의 8번째 비트에서 두 개 중 하나를 선택하여 타이밍을 줄인다.This is an example of latching only two cmd_info when the 7th bit arrives. The timing is then reduced by selecting one of the two in the 8th bit of cmd_info_d.
cmd_info <= cmd_info_d; cmd_info <= cmd_info_d;
end end
end end
always_comb begin always_comb begin
cmd_info_d = '0; cmd_info_d = '0;
if (cmd_8th) begin if (cmd_8th) begin
7번째 비트가 도착할 때 두 개의 cmd_info만 래치하는 예이다. 그런 다음 cmd_info_d의 8번째 비트에서 두 개 중 하나를 선택하여 타이밍을 줄인다.This is an example of latching only two cmd_info when the 7th bit arrives. The timing is then reduced by selecting one of the two in the 8th bit of cmd_info_d.
cmd_info_d = cmd_info_7th[host_s_i[0]]; cmd_info_d = cmd_info_7th[host_s_i[0]];
an example of TODO: Addr size an example of TODO: Addr size
if (cmd_info_7th[host_s_i[0]].addr_4b_affected) begin if (cmd_info_7th[host_s_i[0]].addr_4b_affected) begin
cmd_info_d.addr_size = (cfg_addr_4b_en_i) cmd_info_d.addr_size = (cfg_addr_4b_en_i)
? AddrCntW'(31) : AddrCntW'(23); ? AddrCntW'(31) : AddrCntW'(23);
end end
An example of when dummy_size is set inside State MachineAn example of when dummy_size is set inside State Machine
end end
end end
an example Address swapan example Address swap
logic addr_set; logic addr_set;
logic addr_phase, addr_phase_outclk; logic addr_phase, addr_phase_outclk;
assign addr_phase = (st == StAddress); assign addr_phase = (st == StAddress);
always_ff @(posedge clk_i or negedge rst_ni) begin always_ff @(posedge clk_i or negedge rst_ni) begin
if (!rst_ni) begin if (!rst_ni) begin
addrcnt <= '0; addrcnt <= '0;
end else if (addr_set) begin end else if (addr_set) begin
// Waddr_set이 1이면 cmd_info는 아직 래치되지 않는다. // If waddr_set is 1, cmd_info is not latched yet.
addrcnt <= cmd_info_d.addr_size; addrcnt <= cmd_info_d.addr_size;
end else if (addrcnt != '0) begin end else if (addrcnt != '0) begin
addrcnt <= addrcnt - AddrCntW'(1); addrcnt <= addrcnt - AddrCntW'(1);
end end
end end
always_ff @(posedge clk_out_i or negedge rst_ni) begin always_ff @(posedge clk_out_i or negedge rst_ni) begin
if (!rst_ni) addrcnt_outclk <= '0; if (!rst_ni) addrcnt_outclk <= '0;
else addrcnt_outclk <= addrcnt; else addrcnt_outclk <= addrcnt;
end end
AddrCnt에 기초하여, 로직 스왑. Logic swap, based on AddrCnt.
TODO: Handle the DualIO, QuadIO casesTODO: Handle the DualIO, QuadIO cases
logic addr_swap; logic addr_swap;
assign addr_swap = cfg_addr_mask_i[addrcnt_outclk] assign addr_swap = cfg_addr_mask_i[addrcnt_outclk]
? cfg_addr_value_i[addrcnt_outclk] ? cfg_addr_value_i[addrcnt_outclk]
: host_s_i[0]; : host_s_i[0];
양태에서, 주소 스왑은 outclk 도메인에서 발생한다. 상태 머신은 inclk 도메인에서 동작한다. 상태는 mux 선택 신호를 생성한다. outclk 도메인에 래치된 신호는 mux를 활성화한다.In an aspect, the address swap occurs in the outclk domain. The state machine operates in the inclk domain. The state generates a mux select signal. A signal latched in the outclk domain activates the mux.
always_ff @(posedge clk_out_i or negedge rst_ni) begin always_ff @(posedge clk_out_i or negedge rst_ni) begin
if (!rst_ni) addr_phase_outclk <= 1'b 0; if (!rst_ni) addr_phase_outclk <= 1'b 0;
else addr_phase_outclk <= addr_phase; else addr_phase_outclk <= addr_phase;
end end
An example Dummy CounterAn example Dummy Counter
logic dummy_set; logic dummy_set;
always_ff @(posedge clk_i or negedge rst_ni) begin always_ff @(posedge clk_i or negedge rst_ni) begin
if (!rst_ni) dummycnt <= '0; if (!rst_ni) dummycnt <= '0;
else if (dummy_set) begin else if (dummy_set) begin
dummycnt <= dummycnt_d; dummycnt <= dummycnt_d;
end end
end end
패스스루 MUX의 예는 addr_phase_outclk가 outclk 도메인에 있으므로 addr_swap을 직접 사용할 수 있다. addr_swap 값은 addrcnt_outclk에 의해서도 결정된다.An example of a pass-through MUX is that addr_phase_outclk is in the outclk domain, so addr_swap can be used directly. The addr_swap value is also determined by addrcnt_outclk.
assign passthrough_o.s = (addr_phase_outclk) assign passthrough_o.s = (addr_phase_outclk)
? {host_s_i[3:1], addr_swap} : host_s_i; ? {host_s_i[3:1], addr_swap} : host_s_i;
logic [3:0] passthrough_s_en; logic [3:0] passthrough_s_en;
always_ff @(posedge clk_out_i or negedge rst_ni) begin always_ff @(posedge clk_out_i or negedge rst_ni) begin
if (!rst_ni) passthrough_s_en <= 4'h 1; // S[0] active by default if (!rst_ni) passthrough_s_en <= 4'h 1; // S[0] active by default
else passthrough_s_en <= device_s_en_inclk; else passthrough_s_en <= device_s_en_inclk;
end end
assign passthrough_o.s_en = passthrough_s_en; assign passthrough_o.s_en = passthrough_s_en;
assign host_s_o = passthrough_i.s; assign host_s_o = passthrough_i.s;
always_ff @(posedge clk_out_i or negedge rst_ni) begin always_ff @(posedge clk_out_i or negedge rst_ni) begin
if (!rst_ni) host_s_en_o <= '0; // input mode if (!rst_ni) host_s_en_o <= '0; // input mode
else host_s_en_o <= host_s_en_inclk; else host_s_en_o <= host_s_en_inclk;
end end
assign passthrough_o.sck_gate_en = sck_gate_en; assign passthrough_o.sck_gate_en = sck_gate_en;
assign passthrough_o.sck = host_sck_i; assign passthrough_o.sck = host_sck_i;
assign passthrough_o.sck_en = 1'b 1; assign passthrough_o.sck_en = 1'b 1;
CSb 전파의 예: csb_deassert 신호는 CSb에 글리치가 없는 상태로 만들기 위해 FF 또는 래치의 출력이어야 한다.Example of CSb propagation: The csb_deassert signal must be the output of FF or a latch to make CSb glitch-free.
assign passthrough_o.csb_en = 1'b 1; assign passthrough_o.csb_en = 1'b 1;
assign passthrough_o.csb = host_csb_i | csb_deassert ; assign passthrough_o.csb = host_csb_i | csb_deassert ;
passthrough_enpassthrough_en
assign passthrough_o.passthrough_en = is_active ; assign passthrough_o.passthrough_en = is_active ;
END: Passthrough Mux END: Passthrough Mux
An example State MachineAn example State Machine
always_ff @(posedge clk_i or negedge rst_ni) begin always_ff @(posedge clk_i or negedge rst_ni) begin
if (!rst_ni) begin if (!rst_ni) begin
st <= StIdle; st <= StIdle;
end else begin end else begin
st <= st_d; st <= st_d;
end end
end end
always_comb begin always_comb begin
st_d = st; st_d = st;
an example filteran example filter
filter = 1'b 0; filter = 1'b 0;
an example Command Cfg Latch an example Command Cfg Latch
cmd_info_latch = 1'b 0; cmd_info_latch = 1'b 0;
an example addr_set an example addr_set
addr_set = 1'b 0; addr_set = 1'b 0;
an example Dummyan example dummy
dummy_set = 1'b 0; dummy_set = 1'b 0;
dummycnt_d = '0; dummycnt_d = '0;
an example Output enable an example output enable
host_s_en_inclk = 4'h 0; host_s_en_inclk = 4'h 0;
device_s_en_inclk = 4'h 1; // S[0] MOSI active device_s_en_inclk = 4'h 1; // S[0] MOSI active
unique case (st) unique case
StIdle: begin StIdle: begin
if (!is_active) begin if (!is_active) begin
st_d = StIdle; st_d = StIdle;
end else if (cmd_8th && cmd_filter[host_s_i[0]]) begin end else if (cmd_8th && cmd_filter[host_s_i[0]]) begin
st_d = StFilter; st_d = StFilter;
filter = 1'b 1; filter = 1'b 1;
an example Send notification event to SWan example Send notification event to SW
end else if (cmd_8th) begin end else if (cmd_8th) begin
cmd_info_latch = 1'b 1; cmd_info_latch = 1'b 1;
여러 상태로 전환하는 예. 다음 상태는 주로 출력 활성화 신호를 제어하기 위한 것이다. 그러나 StAddress 상태는 Read Command 경우 주소 교환을 위한 SPI 라인을 제어한다.Example of transitioning to multiple states. The following states are mainly for controlling the output enable signal. However, the StAddress state controls the SPI line for address exchange in the case of Read Command.
// Order: addr_en , dummy_en, |payload_en // Order: addr_en , dummy_en, |payload_en
if (cmd_info_d.addr_en) begin if (cmd_info_d.addr_en) begin
st_d = StAddress; st_d = StAddress;
addr_set = 1'b 1; addr_set = 1'b 1;
end else if (cmd_info_d.dummy_en) begin end else if (cmd_info_d.dummy_en) begin
st_d = StHighZ; st_d = StHighZ;
dummy_set = 1'b 1; dummy_set = 1'b 1;
dummycnt_d = cmd_info_d.dummy_size; dummycnt_d = cmd_info_d.dummy_size;
end else if (cmd_info_d.payload_en != 0) begin end else if (cmd_info_d.payload_en != 0) begin
an example of Any input/output payloadan example of Any input/output payload
if (cmd_info_d.payload_dir == PayloadOut) begin if (cmd_info_d.payload_dir == PayloadOut) begin
st_d = StWait; st_d = StWait;
end else begin end else begin
st_d = StDriving; st_d = StDriving;
end end
end end
end end
end end
StFilter: begin StFilter: begin
명령이 필터링된다. 리셋(CSb)가 올 때까지 기다린다.Commands are filtered. Wait until reset (CSb) comes.
st_d = StFilter; st_d = StFilter;
host_s_en_inclk = 4'h 0; // explicit host_s_en_inclk = 4'h 0; // explicit
device_s_en_inclk = 4'h 0; device_s_en_inclk = 4'h 0;
end end
StWait: begin StWait: begin
Device Returns Data to hostDevice Returns Data to host
st_d = StWait; st_d = StWait;
output enable for hostoutput enable for host
host_s_en_inclk = cmd_info.payload_en; host_s_en_inclk = cmd_info.payload_en;
device_s_en_inclk = 4'h 0; device_s_en_inclk = 4'h 0;
end end
StDriving: begin StDriving: begin
Host sends Data to deviceHost sends Data to device
st_d = StDriving; st_d = StDriving;
Output enable for deviceOutput enable for device
host_s_en_inclk = 4'h 0; // explicit host_s_en_inclk = 4'h 0; // explicit
device_s_en_inclk = cmd_info.payload_en; device_s_en_inclk = cmd_info.payload_en;
end end
StHighZ: begin StHighZ: begin
host_s_en_inclk = 4'h 0; // explicit host_s_en_inclk = 4'h 0; // explicit
device_s_en_inclk = 4'h 0; // float device_s_en_inclk = 4'h 0; // float
if (dummycnt == '0) begin if (dummycnt == '0) begin
// Assume payload_en not 0 //Assume payload_en not 0
st_d = (cmd_info.payload_dir == PayloadOut) ? StWait : StDriving; st_d = (cmd_info.payload_dir == PayloadOut) ? StWait:StDriving;
end end
end end
StAddress: begin StAddress: begin
// based on state, addr_phase is set. So just check if counter reaches 0 // based on state, addr_phase is set. So just check if counter reaches 0
if (addrcnt == '0) begin if (addrcnt == '0) begin
if (mailbox_hit_i) begin if (mailbox_hit_i) begin
// In Address phase, mailbox region hits. Then Passthrough filters // In Address phase, mailbox region hits. Then Passthrough filters
// the command and deligates the control to ReadCmd submodule. // the command and delegates the control to ReadCmd submodule.
st_d = StFilter; st_d = StFilter;
filter = 1'b 1; filter = 1'b 1;
end else if (cmd_info.dummy_en) begin end else if (cmd_info.dummy_en) begin
st_d = StHighZ; st_d = StHighZ;
dummy_set = 1'b 1; dummy_set = 1'b 1;
dummycnt_d = cmd_info.dummy_size; dummycnt_d = cmd_info.dummy_size;
end else if (cmd_info.payload_en != 0) begin end else if (cmd_info.payload_en != 0) begin
st_d = (cmd_info.payload_dir == PayloadOut) ? StWait : StDriving; st_d = (cmd_info.payload_dir == PayloadOut) ? StWait:StDriving;
end else begin end else begin
// Addr completed command. goto wait state // Addr completed command. goto wait state
st_d = StWait; st_d = StWait;
end end
end end
end end
default: begin default: begin
st_d = StIdle; st_d = StIdle;
end end
endcase end case
end end
메일박스 히트가 주소 단계의 끝이 아닌 중간에 발생하는 경우와 같은 어설션의 예이다.This is an example of an assertion, such as when a mailbox hit occurs in the middle of the address step rather than at the end.
`ASSERT(MailboxHitConflictAddrCnt_A, mailbox_hit_i |-> (addrcnt != 0)) `ASSERT(MailboxHitConflictAddrCnt_A, mailbox_hit_i |-> (addrcnt != 0))
endmodule: spi_passthroughendmodule: spi_passthrough
추가적인 예시들Additional examples
보안 SPI 통신의 예는 다음과 같다.An example of secure SPI communication is as follows:
예 1: 보안 직렬 주변 장치 인터페이스 통신을 위한 시스템의 호스트와 연관된 보안 회로에 의해 구현되는 방법으로서, 상기 방법은: 직렬 주변 장치 인터페이스(SPI) 인터커넥트를 통해 호스트에 연결된 시스템의 주변 블록으로 호스트에 의해 전송된 통신들을 모니터링하는 단계; 호스트에 의해 송신된 통신들의 각 명령들을 주변 블록이 실행하도록 승인되지 않은 명령들을 나타내는 정보와 비교하는 단계; 상기 비교하는 단계에 기초하여, 각 명령들 중 하나가 주변 블록이 실행하도록 승인되지 않은 명령인지 결정하는 단계; 및 주변 블록이 실행하도록 승인되지 않은 각 명령의 적어도 일부를 주변 블록이 수신하는 것을 방지하는 단계를 포함한다.Example 1: A method implemented by secure circuitry associated with a host of a system for secure serial peripheral interface communication, said method comprising: a device connected by a host to a peripheral block of a system connected to the host via a serial peripheral interface (SPI) interconnect; monitoring transmitted communications; comparing each command in communications transmitted by the host with information indicating commands that the surrounding block is not authorized to execute; Based on the comparing step, determining whether one of each instruction is an instruction that the neighboring block is not authorized to execute; and preventing the peripheral block from receiving at least a portion of each instruction that the peripheral block is not authorized to execute.
예 2.1: 임의의 실시 예에 인용된 방법에 있어서, 상기 방지하는 단계는 주변 블록이 호스트에 의해 송신된 통신의 각 명령의 적어도 일부를 수신하는 것을 방지하기 위해 SPI 인터커넥트의 칩 선택 라인 또는 클록 라인의 상태를 변경하는 단계를 포함한다.Example 2.1: The method recited in any of the embodiments, wherein the preventing step includes a chip select line or clock line of the SPI interconnect to prevent peripheral blocks from receiving at least a portion of each command in the communication transmitted by the host. It includes the step of changing the state of .
예 2.2: 임의의 실시 예에 인용된 방법에 있어서, 상기 방지하는 단계는 주변 블록이 호스트에 의해 송신된 통신의 각 명령의 적어도 일부를 수신하는 것을 방지하기 위해 SPI 인터커넥트의 칩 선택 라인 또는 클록 라인의 상태를 변경하는 단계를 포함한다.Example 2.2: The method recited in any of the embodiments, wherein the preventing step includes: It includes the step of changing the state of .
예 3: 임의의 실시 예에 인용된 방법에 있어서, 통신의 각 명령은 8비트로 구성되며; 그리고 상기 변경하는 단계는 적어도 각 명령의 8번째 비트가 주변 블록에 의해 프로세싱되는 것을 방지하기 위해 각 명령의 8번째 비트가 SPI 인터커넥트를 통해 통신되는 8번째 클록 사이클 이전에 또는 8번째 클럭 사이클에서 칩 선택 라인을 디어설팅(deasserting)하는 단계를 포함한다.Example 3: In the method recited in any of the embodiments, each command of communication consists of 8 bits; And said changing step is performed at least before or at the 8th clock cycle when the 8th bit of each instruction is communicated over the SPI interconnect to prevent the 8th bit of each instruction from being processed by the surrounding blocks. and deasserting the selection line.
예 4: 임의의 실시 예에 인용된 방법에 있어서, 통신의 각 명령은 8비트로 구성되며; 그리고 상기 변경하는 단계는 적어도 각 명령의 8번째 비트가 주변 블록에 의해 프로세싱되는 것을 방지하기 위해 각 명령의 8번째 비트가 SPI 인터커넥트를 통해 통신되는 8번째 클록 사이클 이전에 또는 8번째 클럭 사이클에서 클록 라인을 게이팅(gating)하는 단계를 포함한다.Example 4: In the method recited in any of the embodiments, each command of communication consists of 8 bits; And said changing step is performed at least before or at the 8th clock cycle in which the 8th bit of each instruction is communicated over the SPI interconnect to prevent the 8th bit of each instruction from being processed by surrounding blocks. It includes the step of gating the line.
예 5: 임의의 실시 예에 인용된 방법에 있어서, 시스템의 주변 블록은 쓰기 방지 입력 노드를 포함하지 않거나 주변 블록의 쓰기 방지 입력 노드가 비활성화된다.Example 5: In the method recited in any of the embodiments, a peripheral block of the system does not include a write-protect input node or the write-protect input node of the peripheral block is disabled.
예 6: 임의의 실시 예에 인용된 방법에 있어서, 각 명령은 제1 통신의 제1 명령이고, 상기 방법은: 호스트에 의해 주변 블록으로 송신된 제2 통신의 제2 명령이 쓰기 상태 레지스터(write-status-register) 명령을 포함한다고 결정하는 단계; 및 상기 제2 통신이 주변 블록의 상태 레지스터를 변경하는 것을 방지하기 위해 상기 쓰기 상태 레지스터 명령을 변경하는 단계를 더 포함한다.Example 6: A method recited in any embodiment, wherein each command is a first command in a first communication, wherein: a second command in a second communication sent by the host to a peripheral block writes the write status register ( determining that it includes a write-status-register) command; and changing the write status register command to prevent the second communication from changing the status register of a neighboring block.
예 7: 임의의 실시 예에 인용된 방법에 있어서, 상기 쓰기 상태 레지스터 명령을 변경하는 단계는: 변경된 쓰기 상태 레지스터 명령을 제공하기 위해 상기 쓰기 상태 레지스터 명령의 비트 포지션들을 사전 정의된 비트 값들로 설정하는 단계; 및 상기 사전 정의된 비트 값들 및 상기 쓰기 상태 레지스터 명령의 다른 비트들을 포함하는 상기 변경된 쓰기 상태 레지스터 명령을 주변 블록에 전달하는 단계를 포함한다.Example 7: The method recited in any of the embodiments, wherein modifying the write status register command includes: setting bit positions of the write status register command to predefined bit values to provide a modified write status register command. steps; and transmitting the changed write status register command including the predefined bit values and other bits of the write status register command to a peripheral block.
예 8: 임의의 실시 예에 인용된 방법에 있어서, 상기 주변 블록이 실행하도록 승인되지 않은 명령들을 나타내는 정보는: 주변 블록이 실행하도록 승인되지 않은 명령들; 및 주변 블록이 실행하도록 승인된 명령들의 테이블을 포함한다.Example 8: The method recited in any embodiment, wherein information indicating instructions that the peripheral block is not authorized to execute includes: instructions that the peripheral block is not authorized to execute; and a table of instructions that the surrounding block is authorized to execute.
예 9: 임의의 실시 예에 인용된 방법에 있어서, 상기 통신들을 모니터링하는 단계 이전에, 주변 블록이 실행하도록 승인되지 않은 명령들 및 주변 블록이 실행하도록 승인된 명령들의 테이블을 구성하는 단계를 더 포함한다.Example 9: The method recited in any of the embodiments, further comprising, prior to monitoring the communications, constructing a table of instructions that the peripheral block is not authorized to execute and instructions that the peripheral block is authorized to execute. Includes.
예 10: 임의의 실시 예에 인용된 방법에 있어서, 호스트에 의해 송신된 통신들의 각 명령들을 상기 테이블의 정보와 비교하는 단계는: 각 명령들에 기초하여, 각 명령들이 주변 블록에 의한 실행이 승인되었는지 여부를 결정하기 위해 상기 테이블에 인덱싱하는 단계를 포함한다.Example 10: In the method recited in any embodiment, comparing each command in communications sent by a host with information in the table includes: Based on each command, execution of each command by a surrounding block is performed. and indexing into the table to determine whether it has been approved.
예 11: 임의의 실시 예에 인용된 방법에 있어서, 시스템의 주변 블록은 SPI 인터커넥트를 통해 호스트에 연결된 메모리 모듈을 포함하고, 메모리 모듈은 비휘발성 메모리 또는 플래시 메모리 중 하나를 포함한다.Example 11: The method recited in any of the embodiments, wherein the peripheral blocks of the system include a memory module coupled to the host via an SPI interconnect, and the memory module includes one of non-volatile memory or flash memory.
예 12: 임의의 실시 예에 인용된 방법에 있어서, SPI 인터커넥트를 통해 메모리 모듈로부터 호스트에 바이너리 이미지를 로드하려고 시도하기 전에 시스템의 메모리 모듈에 저장된 바이너리 이미지를 검증하는 단계를 더 포함한다.Example 12: The method recited in any of the embodiments further comprising verifying a binary image stored in a memory module of the system prior to attempting to load the binary image to the host from the memory module via the SPI interconnect.
예 13: 임의의 실시 예에 인용된 방법에 있어서, 바이너리 이미지의 검증 성공에 응답하여, 메모리 모듈로 하여금 SPI 인터페이스를 통해 바이너리 이미지를 호스트에 송신하게 하는 단계; 또는 바이너리 이미지의 검증 실패에 응답하여, 메모리 모듈이 SPI 인터페이스를 통해 바이너리 이미지를 호스트에 송신하는 것을 방지하는 단계를 더 포함한다.Example 13: The method recited in any of the embodiments, comprising: in response to successful verification of the binary image, causing the memory module to transmit the binary image to the host via the SPI interface; or in response to failure to verify the binary image, preventing the memory module from transmitting the binary image to the host through the SPI interface.
예 14: 임의의 실시 예에 인용된 방법에 있어서, 바이너리 이미지는 메모리 모듈의 제1 파티션에 저장된 제1 바이너리 이미지이고, 상기 방법은: 메모리 모듈로 하여금 제2 바이너리 이미지를 메모리 모듈의 제2 파티션으로부터 호스트에 송신하게 하도록 상기 제1 바이너리 이미지에 대한 읽기 명령의 주소를 조작하는 단계를 더 포함한다.Example 14: The method recited in any of the embodiments, wherein the binary image is a first binary image stored in a first partition of a memory module, the method comprising: causing the memory module to store a second binary image in a second partition of the memory module. and manipulating the address of a read command for the first binary image to be transmitted to the host.
예 15: 보안 직렬 주변 장치 인터페이스 통신을 위한 회로를 포함하는 집적 회로로서, 상기 회로는: 기능적 코어를 갖는 호스트; 적어도 하나의 주변 블록; 상기 호스트 및 상기 적어도 하나의 주변 블록을 연결하는 직렬 주변 장치 인터페이스(SPI) 인터커넥트; 및 상기 SPI 인터커넥트와 동작가능하게 결합되고, 제1항 내지 제14항 중 어느 한 항의 동작들을 수행하도록 구성되는 보안 SPI 통신 모듈을 포함한다.Example 15: An integrated circuit comprising circuitry for secure serial peripheral interface communication, the circuitry comprising: a host having a functional core; At least one surrounding block; a serial peripheral interface (SPI) interconnect connecting the host and the at least one peripheral block; and a secure SPI communication module operably coupled with the SPI interconnect and configured to perform the operations of any one of claims 1 to 14.
결론conclusion
보안 SPI 통신을 구현하기 위해 설명된 시스템 및 방법의 양태들이 특징 및/또는 방법에 특정한 언어로 설명되었지만, 첨부된 청구범위의 주제는 임의의 이전 예에 의해 인용된 바와 같이 설명된 특정 특징 또는 방법에 반드시 제한되지는 않는다. 오히려, 특정 특징 및 방법은 보안 SPI 통신의 예시적인 구현으로서 개시되고, 다른 동등한 특징 및 방법은 첨부된 청구범위의 범위 내에 있도록 의도된다. 또한, 보안 SPI 통신의 다양한 양태들이 설명되며, 각각의 설명된 양태는 독립적으로 또는 하나 이상의 다른 설명된 양태와 관련하여 구현될 수 있다는 것이 이해되어야 한다.Although aspects of the described systems and methods for implementing secure SPI communications have been described in language specific to the features and/or methods, the subject matter of the appended claims is directed to the specific features or methods described as recited by any preceding example. is not necessarily limited to. Rather, certain features and methods are disclosed as example implementations of secure SPI communications, and other equivalent features and methods are intended to be within the scope of the appended claims. Additionally, various aspects of secure SPI communication are described, and it should be understood that each described aspect may be implemented independently or in conjunction with one or more other described aspects.
Claims (15)
직렬 주변 장치 인터페이스(SPI) 인터커넥트를 통해 호스트에 연결된 시스템의 주변 블록으로 호스트에 의해 전송된 통신들을 모니터링하는 단계;
호스트에 의해 송신된 통신들의 각 명령들을 주변 블록이 실행하도록 승인되지 않은 명령들을 나타내는 정보와 비교하는 단계;
상기 비교하는 단계에 기초하여, 각 명령들 중 하나가 주변 블록이 실행하도록 승인되지 않은 명령인지 결정하는 단계; 및
주변 블록이 실행하도록 승인되지 않은 각 명령의 적어도 일부를 주변 블록이 수신하는 것을 방지하는 단계를 포함하는, 방법.A method implemented by security circuitry associated with a host of a system for secure serial peripheral interface communication, said method comprising:
monitoring communications transmitted by the host to a peripheral block of the system coupled to the host via a serial peripheral interface (SPI) interconnect;
comparing each command in communications transmitted by the host with information indicating commands that the surrounding block is not authorized to execute;
Based on the comparing step, determining whether one of each instruction is an instruction that the neighboring block is not authorized to execute; and
A method comprising preventing a peripheral block from receiving at least a portion of each instruction that the peripheral block is not authorized to execute.
상기 방지하는 단계는 주변 블록이 호스트에 의해 송신된 통신의 각 명령의 적어도 일부를 수신하는 것을 방지하기 위해 SPI 인터커넥트의 칩 선택 라인 또는 클록 라인의 상태를 변경하는 단계를 포함하는, 방법.According to paragraph 1,
Wherein the preventing step includes changing the state of a chip select line or clock line of the SPI interconnect to prevent a peripheral block from receiving at least a portion of each command in the communication transmitted by the host.
상기 방지하는 단계는 주변 블록이 호스트에 의해 송신된 통신의 각 명령의 적어도 일부를 수신하는 것을 방지하기 위해 SPI 인터커넥트의 칩 선택 라인 및 클록 라인의 상태를 변경하는 단계를 포함하는, 방법.According to paragraph 1,
Wherein the preventing step includes changing the state of a chip select line and a clock line of the SPI interconnect to prevent a peripheral block from receiving at least a portion of each command in the communication transmitted by the host.
통신의 각 명령은 8비트로 구성되며; 그리고
상기 변경하는 단계는 적어도 각 명령의 8번째 비트가 주변 블록에 의해 프로세싱되는 것을 방지하기 위해 각 명령의 8번째 비트가 SPI 인터커넥트를 통해 통신되는 8번째 클록 사이클 이전에 또는 8번째 클럭 사이클에서 칩 선택 라인을 디어설팅(deasserting)하는 단계를 포함하는, 방법.According to paragraph 2 or 3,
Each command in communication consists of 8 bits; and
The step of changing the chip select at least before or on the 8th clock cycle in which the 8th bit of each instruction is communicated over the SPI interconnect to prevent the 8th bit of each instruction from being processed by surrounding blocks. A method comprising deasserting a line.
통신의 각 명령은 8비트로 구성되며; 그리고
상기 변경하는 단계는 적어도 각 명령의 8번째 비트가 주변 블록에 의해 프로세싱되는 것을 방지하기 위해 각 명령의 8번째 비트가 SPI 인터커넥트를 통해 통신되는 8번째 클록 사이클 이전에 또는 8번째 클럭 사이클에서 클록 라인을 게이팅(gating)하는 단계를 포함하는, 방법.According to paragraph 2 or 3,
Each command in communication consists of 8 bits; and
The step of changing the clock line at least before or at the 8th clock cycle causes the 8th bit of each instruction to be communicated over the SPI interconnect to prevent the 8th bit of each instruction from being processed by surrounding blocks. A method comprising gating.
각 명령은 제1 통신의 제1 명령이고, 상기 방법은:
호스트에 의해 주변 블록으로 송신된 제2 통신의 제2 명령이 쓰기 상태 레지스터(write-status-register) 명령을 포함한다고 결정하는 단계; 및
상기 제2 통신이 주변 블록의 상태 레지스터를 변경하는 것을 방지하기 위해 상기 쓰기 상태 레지스터 명령을 변경하는 단계를 더 포함하는, 방법.According to any one of claims 1 to 5,
Each command is the first command of the first communication, and the method is:
determining that a second command in the second communication sent by the host to the peripheral block includes a write-status-register command; and
The method further comprising modifying the write status register command to prevent the second communication from modifying the status register of a peripheral block.
상기 쓰기 상태 레지스터 명령을 변경하는 단계는:
변경된 쓰기 상태 레지스터 명령을 제공하기 위해 상기 쓰기 상태 레지스터 명령의 비트 포지션들을 사전 정의된 비트 값들로 설정하는 단계; 및
상기 사전 정의된 비트 값들 및 상기 쓰기 상태 레지스터 명령의 다른 비트들을 포함하는 상기 변경된 쓰기 상태 레지스터 명령을 주변 블록에 전달하는 단계를 포함하는, 방법.According to clause 6,
The steps to change the write status register command are:
setting bit positions of the write status register command to predefined bit values to provide a modified write status register command; and
and passing the modified write status register command including the predefined bit values and other bits of the write status register command to a peripheral block.
상기 주변 블록이 실행하도록 승인되지 않은 명령들을 나타내는 정보는:
주변 블록이 실행하도록 승인되지 않은 명령들; 및
주변 블록이 실행하도록 승인된 명령들의 테이블을 포함하는, 방법.According to any one of claims 1 to 7,
Information indicating instructions that the peripheral block is not authorized to execute is:
Instructions that the surrounding block is not authorized to execute; and
A method comprising a table of instructions that a peripheral block is authorized to execute.
상기 통신들을 모니터링하는 단계 이전에, 상기 주변 블록이 실행하도록 승인되지 않은 명령들 및 주변 블록이 실행하도록 승인된 명령들의 테이블을 구성하는 단계를 더 포함하는, 방법.According to clause 8,
Prior to monitoring the communications, the method further comprises constructing a table of instructions that the peripheral block is not authorized to execute and instructions that the peripheral block is authorized to execute.
호스트에 의해 송신된 통신들의 각 명령들을 상기 테이블의 정보와 비교하는 단계는:
각 명령들에 기초하여, 각 명령들이 주변 블록에 의한 실행이 승인되었는지 여부를 결정하기 위해 상기 테이블에 인덱싱하는 단계를 포함하는, 방법.According to clause 8 or 9,
The steps of comparing each command in communications sent by the host with the information in the table are:
Based on each instruction, indexing into the table to determine whether each instruction is authorized for execution by a neighboring block.
시스템의 주변 블록은 SPI 인터커넥트를 통해 호스트에 연결된 메모리 모듈을 포함하고, 메모리 모듈은 비휘발성 메모리 또는 플래시 메모리 중 하나를 포함하며; 또는
시스템의 주변 블록이 쓰기 방지 입력 노드를 포함하지 않거나 주변 블록의 쓰기 방지 입력 노드가 비활성화되는, 방법.According to any one of claims 1 to 10,
A peripheral block of the system includes a memory module connected to the host via an SPI interconnect, the memory module including either non-volatile memory or flash memory; or
A method in which a peripheral block of the system does not contain a write-protect input node or the write-protect input node of the peripheral block is disabled.
SPI 인터커넥트를 통해 메모리 모듈로부터 호스트에 바이너리 이미지를 로드하려고 시도하기 전에 시스템의 메모리 모듈에 저장된 바이너리 이미지를 검증하는 단계를 더 포함하는, 방법.According to clause 11,
The method further comprising verifying a binary image stored in a memory module of the system prior to attempting to load the binary image from the memory module to the host via the SPI interconnect.
바이너리 이미지의 검증 성공에 응답하여, 메모리 모듈로 하여금 SPI 인터페이스를 통해 바이너리 이미지를 호스트에 송신하게 하는 단계; 또는
바이너리 이미지의 검증 실패에 응답하여, 메모리 모듈이 SPI 인터페이스를 통해 바이너리 이미지를 호스트에 송신하는 것을 방지하는 단계를 더 포함하는, 방법.According to clause 12,
In response to successful verification of the binary image, causing the memory module to transmit the binary image to the host through the SPI interface; or
In response to failure to verify the binary image, the method further includes preventing the memory module from sending the binary image to the host via the SPI interface.
바이너리 이미지는 메모리 모듈의 제1 파티션에 저장된 제1 바이너리 이미지이고, 상기 방법은:
메모리 모듈로 하여금 제2 바이너리 이미지를 메모리 모듈의 제2 파티션으로부터 호스트에 송신하게 하도록 상기 제1 바이너리 이미지에 대한 읽기 명령의 주소를 조작하는 단계를 더 포함하는, 방법.According to clause 13,
The binary image is a first binary image stored in the first partition of the memory module, and the method includes:
The method further comprising manipulating the address of a read command for the first binary image to cause the memory module to transmit a second binary image from a second partition of the memory module to the host.
기능적 코어를 갖는 호스트;
적어도 하나의 주변 블록;
상기 호스트 및 상기 적어도 하나의 주변 블록을 연결하는 직렬 주변 장치 인터페이스(SPI) 인터커넥트; 및
상기 SPI 인터커넥트와 동작가능하게 연결되고, 제1항 내지 제14항 중 어느 한 항의 동작들을 수행하도록 구성되는 보안 SPI 통신 모듈을 포함하는, 회로.An integrated circuit comprising circuitry for secure serial peripheral interface communication, said circuit comprising:
A host with a functional core;
At least one surrounding block;
a serial peripheral interface (SPI) interconnect connecting the host and the at least one peripheral block; and
A circuit comprising a secure SPI communication module operably coupled with the SPI interconnect and configured to perform the operations of any one of claims 1-14.
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US202163179043P | 2021-04-23 | 2021-04-23 | |
US63/179,043 | 2021-04-23 | ||
PCT/US2022/071842 WO2022226520A1 (en) | 2021-04-23 | 2022-04-21 | Secure serial peripheral interface communication |
Publications (1)
Publication Number | Publication Date |
---|---|
KR20230144619A true KR20230144619A (en) | 2023-10-16 |
Family
ID=81654707
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
KR1020237031002A KR20230144619A (en) | 2021-04-23 | 2022-04-21 | Secure serial peripheral interface communication |
Country Status (5)
Country | Link |
---|---|
EP (1) | EP4285265A1 (en) |
JP (1) | JP2024515238A (en) |
KR (1) | KR20230144619A (en) |
CN (1) | CN117043775A (en) |
WO (1) | WO2022226520A1 (en) |
Family Cites Families (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20160180095A1 (en) * | 2014-12-23 | 2016-06-23 | Nitin V. Sarangdhar | Measured boot capability |
US10776527B2 (en) * | 2015-06-08 | 2020-09-15 | Nuvoton Technology Corporation | Security monitoring of SPI flash |
US10877673B2 (en) * | 2017-12-15 | 2020-12-29 | Microchip Technology Incorporated | Transparently attached flash memory security |
-
2022
- 2022-04-21 CN CN202280020820.XA patent/CN117043775A/en active Pending
- 2022-04-21 JP JP2023557156A patent/JP2024515238A/en active Pending
- 2022-04-21 KR KR1020237031002A patent/KR20230144619A/en unknown
- 2022-04-21 EP EP22723941.5A patent/EP4285265A1/en active Pending
- 2022-04-21 WO PCT/US2022/071842 patent/WO2022226520A1/en active Application Filing
Also Published As
Publication number | Publication date |
---|---|
CN117043775A (en) | 2023-11-10 |
EP4285265A1 (en) | 2023-12-06 |
WO2022226520A1 (en) | 2022-10-27 |
JP2024515238A (en) | 2024-04-08 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US10289577B2 (en) | System, method and computer-accessible medium for low-overhead security wrapper for memory access control of embedded systems | |
US8549630B2 (en) | Trojan-resistant bus architecture and methods | |
Basak et al. | A flexible architecture for systematic implementation of SoC security policies | |
US10521600B2 (en) | Reconfigurable system-on-chip security architecture | |
Tsoutsos et al. | Fabrication attacks: Zero-overhead malicious modifications enabling modern microprocessor privilege escalation | |
CN108701191B (en) | Data processing device and method for verifying the integrity of a data processing device | |
Subramanyan et al. | Formal verification of taint-propagation security properties in a commercial SoC design | |
JP2006505798A (en) | Method and apparatus for security scanning test | |
CN113557515A (en) | Compatibility of peripheral devices with secure circuitry | |
Almeida et al. | Ransomware attack as hardware trojan: a feasibility and demonstration study | |
KR20230144619A (en) | Secure serial peripheral interface communication | |
Srivastava et al. | A novel approach of data content zeroization under memory attacks | |
US20230259603A1 (en) | Function Call Authentication for Program Flow Control | |
Stojilović et al. | A Visionary Look at the Security of Reconfigurable Cloud Computing | |
US20230177154A1 (en) | Sparse Encodings for Control Signals | |
KR20230145167A (en) | Security Chip - Wide Communication | |
KR20230146594A (en) | Read-only memory (ROM) security | |
IZZO | Global protection for transient attacks | |
Sreenath et al. | A Novel Approach towards Secure IO Transactions Implementation and Validation for Smart Phones | |
TW202240591A (en) | Read-only memory (rom) security | |
Chacon et al. | Coherence Attacks and Countermeasures in Interposer-Based Systems | |
Haider | Architectural Primitives for Secure Computation Platforms | |
Krieg et al. | Historical Overview | |
Akhil | INSERTION AND DETECTION OF HARDWARE TROJANS USING SIDE-CHANNEL ANALYSIS | |
Backer | Design-for-Introspection for Secure Systems-on-Chip |