US20130031423A1 - System and Method for Identifying Fault Prone Computer Code Files - Google Patents
System and Method for Identifying Fault Prone Computer Code Files Download PDFInfo
- Publication number
- US20130031423A1 US20130031423A1 US13/190,599 US201113190599A US2013031423A1 US 20130031423 A1 US20130031423 A1 US 20130031423A1 US 201113190599 A US201113190599 A US 201113190599A US 2013031423 A1 US2013031423 A1 US 2013031423A1
- Authority
- US
- United States
- Prior art keywords
- file
- codebase
- files
- metrics
- fault
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Granted
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/36—Preventing errors by testing or debugging software
- G06F11/3604—Software analysis for verifying properties of programs
- G06F11/3616—Software analysis for verifying properties of programs using software metrics
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/70—Software maintenance or management
- G06F8/77—Software metrics
Definitions
- the present disclosure relates generally to identifying fault prone computer code and more specifically to a system and a method configured analyze metrics associated with codebase code files to identify files that are most likely to cause faults when executed.
- Codebases are usually created by engineers, software developers, and other technicians who write individual code files describing the application's modules, methods, functions, etc. These files are included within the application's codebase.
- the codebase may be conceptually maintained in a tree structure maintained by a version control system. Within the code tree, a branch generally describes a version of an application module that was changed, but does not include any new features, while a trunk may include a module with new features. Teams of engineers design, develop and deploy software across distant locations. Multiple versions of software files are often deployed from these different locations while other developers work on updates to the same files. Errors or “bugs” may only be present in certain versions, therefore to locate and fix any bugs, particular versions of the software must be located and tested to determine which version(s) are causing the problem.
- bugs are not distributed linearly within a codebase, but rather, bugs occur in “bursts” where a single bug causes multiple, other bugs in a cascading effect throughout the code base.
- testing a percentage of the total amount of code within the codebase will not account for an equal percentage of the total number of bugs that are present in the codebase (i.e., scanning fifty percent of the total amount of code within the codebase will not account for fifty percent of the total bugs in the codebase).
- Some techniques to identify and analyze bugs within a codebase have focused on providing a Boolean indicator of whether a particular piece of the codebase was more or less likely to include a bug. For example, cache techniques may rank files within a codebase according to the number of lines of code within the file. Then, each of the ranked files and its closest relatives may receive a “hit” if it had been changed to fix a bug. Files that have been fixed most recently may remain in the cache, while those that have been changed less recently may be removed from the cache. These techniques allow a “hit or miss” identification of fault-prone files within a cache selection of the codebase.
- a computer-implemented method or a computer system or a computer-readable medium storing a set of instructions for execution on a processor operates to identify fault-prone code by determining, ranking, and analyzing metrics associated with codebase code files.
- Functions of the method or system or stored on a computer-readable medium may determine metrics corresponding to each file of a plurality of codebase files within a codebase for an application.
- the functions may also store the metrics corresponding to each codebase file in a record of a database table, rank order the plurality of codebase files according to at least one metric, and flag each codebase file having a ranking over a threshold value of the metric.
- the codebase file metrics may describe fault-inducing characteristics of the plurality of codebase files and include both a total number of previous faults and a total number of changes that are associated with each codebase file.
- the computer-implemented method or computer system or computer-readable medium storing a set of instructions for execution on a processor operates to detect a change to the plurality of codebase files and update the metrics corresponding to each file of the plurality of codebase files. Some embodiments may then continuously rank order the plurality of codebase files according to the updated metrics to account for fault-inducing changes to the codebase files.
- the metrics may further include one or more of a file ID, a change list ID, a number of lines of code within the file, a time the file was last edited, a change density, a total number of faults, a fault density, logical coupling relatives, and spatial relatives.
- the change density may include a number of times the file has been changed compared to the number of lines of code within the file and the fault density may include the total number of faults compared to the number of lines of code within the file.
- the logical coupling relatives may include a measurement of a number of times a file is changed in conjunction with a change action for another file in the codebase
- the spatial relatives may include a measurement of a number of times a file is changed in conjunction with a change action for another file in a same folder or package as the file.
- rank ordering the plurality of codebase files may include determining a weighted average of the metrics for each codebase file and ranking the plurality of codebase files according to the weighted average. Further, rank ordering may include a subset of the plurality of codebase files that are ranked according to at least one metric. The subset may include a folder, an extension, a feature, or a package of a codebase file.
- the system may include a processor and a memory that stores various structures and modules to identify fault-prone code.
- a version control module may be stored in the memory and have an API defining functions that are executable by the processor to store codebase files within a codebase and manage a change list for tracking changes to the codebase files.
- a database may be stored in the memory and include a plurality of records that each store a set of metrics corresponding to each codebase file stored in the codebase.
- a bug organizer module may be stored in the memory and have an API defining functions that are executable by the processor to determine the sets of metrics for each codebase file, store the sets of metrics in the records, and rank order the codebase files within a table of the database according to the sets of metrics.
- FIG. 1 is a high-level block diagram of a system for identifying fault prone files within an application codebase
- FIG. 2 is an exemplary block diagram of a codebase file
- FIG. 3 is one example of a database table used to identify fault-prone code
- FIG. 4 is another example of a database table used to identify fault-prone code
- FIG. 5 is an exemplary block diagram of a method for identifying fault-prone code
- FIG. 6 is high-level block diagram of a computing environment that implements a system for identifying fault prone files within an application codebase.
- a debugging system and method may identify files within a codebase that are most likely to include bugs by measuring and analyzing particular metrics that are associated with each file in the codebase.
- the file metrics may be associated with a version history of the codebase and include a plurality bug localities and heuristics as described below.
- FIG. 1 is a high-level bock diagram that illustrates a system 100 for analyzing code from a codebase 102 to identify files 103 and code that are most likely to include bugs.
- a version control API 104 may perform commit operations to store code files 103 within the codebase 102 or to re-save code files 103 that were edited from within the codebase 102 .
- the version control API 104 may also manage a version history 106 of the codebase 102 .
- the version history 106 may include a plurality of unique identifiers that are conceptually related to one another and describe a code tree 106 a for the application code stored in the codebase 102 .
- the version history 106 may also include a change list 107 for tracking all changes made to codebase files.
- the change list 107 includes a change list ID 107 a and comments 107 b for each codebase file 102 that is changed. For example, a developer may edit code within a file or group of files 102 and initiate a commit action with comments about the changes made using the version control API 104 . The API 104 may then assign a change list ID 107 a corresponding to the changed files 102 and comments 107 b . The version history 106 may also be updated in the code tree 106 a.
- the version control API 104 may also associate the change list ID 107 a , comments 107 b , and metrics with the code files when a developer, automatic code generator, or other entity or device performs the commit action or other action (e.g., an edit action, a bug counting action, etc.) with the code file 103 .
- a bug organizer API 108 may identify and extract codebase files from the codebase 102 that have one or more metrics associated with the files. The bug organizer API 108 may then organize the extracted codebase files into a database 110 according to the file metrics. The database 110 may then sort and order the extracted codebase files into an ordered set of codebase files 112 according to the metrics.
- a member of the ordered set 112 may be selected as a baseline file 114 that includes a value of the metrics such that those files having a value above 116 or below 118 the value of the baseline file 114 metrics are identified as most likely to include bugs.
- a quality assurance team may then focus their attention on only those codebase files that are most likely to include bugs.
- a bug tracking system 120 may also maintain a bug list 120 a having identifiers that reference one or more bugs that have been identified and/or fixed within the codebase files 103 . Where the bug list 120 a includes an identifier corresponding to a fixed bug, a change list ID 107 a may also correspond to the bug list 102 a.
- FIG. 2 is a block diagram of one embodiment of a codebase file 200 .
- the codebase file 200 may include two main components: code 202 and metrics 204 .
- the code 202 may include text and other instructions that may be compiled and executed on a computer.
- the code 202 includes text instructions in a high-level programming language such as Java®, C, or other languages.
- the code 202 is written in a programming language that facilitates the developer's task to create computer-executable procedures.
- Executing a commit action with a version control API 104 or other module may associate the metrics 204 with the code 202 and both the code 202 and metrics 204 may be stored in the codebase 102 as a codebase file 200 organized by the version history 106 .
- the metrics 204 may include any information that is useful to identify bug-prone codebase files.
- the metrics 204 include a file ID 210 , a change list ID 211 , a number of lines of code within the file 212 , a time the file was last edited 214 , a number of times the file has been changed 216 , a change density 218 (i.e., a number of times the file has been changed compared to the number of lines of code within the file), a total number of bugs found in the file 220 , a bug density 222 (i.e., a number of bugs found in the file compared to the number of lines of code within the file), logical coupling relatives 224 , and spatial relatives 226 .
- a version control API 104 may associate a change list ID 211 with the file 200 .
- the API 104 associates a unique change list ID with any file that is added to the codebase 102 in a commit action.
- the API 104 may execute a commit action to add several files to the codebase 102 that have been edited by a developer merely to add or remove features or to correct a fault.
- the version control API 104 may attach comments 107 b to each changed file or to a particular change list ID 211 that indicate whether the file or files associated with that change list ID were edited to add or remove features or to correct a fault.
- the lines of code 212 metric may indicate a file having more bugs because files with more lines of code tend to contain more bugs. While bugs are not evenly distributed throughout the codebase 102 , a file having a high the number of code lines may be a good indicator that the file will also contain bugs. Additionally, longer files may also be harder for a developer to understand and increase the likelihood of a fault within the file.
- the last edit time 214 metric may be selected as an indicator that a bug may have been introduced to the file because older files are more likely have had their bugs fixed than newer files. If a file has not been modified in a long time, then it is more likely that the file has stabilized and is not a source of bugs.
- the number of changes 216 metric may also be used to identify bug-prone code files because more changes increase the opportunities for introducing bugs to the file.
- the change density 218 metric may be selected to balance the effect of file length 212 against the number of changes 216 .
- a file may be changed many times because it is very large. However, a small file that is changed often may indicate a greater opportunity for bug introduction across a small number of code lines.
- the change density 218 may be a measure of the number of changes versus the number of lines of code 212 in the file.
- the total number of bugs found 220 metric may indicate that an associated file is bug prone.
- the metric 220 may be incremented whenever the file 200 is associated with a change that fixes a bug.
- the version control API 104 may associate a change list ID 107 a and comments 107 b with any file 200 that is edited.
- the bug organizer API 108 may search the comments 107 b for any word, phrase, or symbol that indicates the file 200 corresponding to the change list ID 107 a and comments 107 b was edited to fix a bug.
- the API 108 searches the comments 107 b for words such as bug, fix, repair, patch, error, fault, etc., that indicate that the comments 107 b are associated with a file 200 that has been changed to fix a bug.
- an identifier of the bug list 120 a may also correspond to a change list ID 107 a and, thus, contribute to the total number of bugs found 220 metric. In other words, a file 200 that, at least at one time, included a bug, is more likely to continue to have a bug.
- the bug density 222 metric accounts for the number of bugs in the file 200 against the number of code lines 212 in the same file 200 . For example, a file 200 including many thousands of lines of code 212 , but only three total bugs 220 may be much less bug prone than a file including only five lines of code 212 and two total bugs 220 .
- the bug density 222 may be a measure of the total number of bugs versus the number of lines of code 212 in the file.
- the logical coupling relatives 224 include a metric to assess how many times the file 200 was changed in conjunction with other files. For example, files that are changed at the same time often share resources or rely on each other in some way during execution. Therefore, a change in any file that relies on another file during execution may introduce bugs in that other file. Further, two files that are changed at the same time may also introduce bugs in those two files. In some embodiments, associating file IDs and a change list ID may indicate a number of files that were changed at the same time. The logical coupling relatives 224 may be ranked according to the smallest coupling distance. For example, a coupling distance between two files fileA and fileB is equal to:
- the spatial relatives 226 include a metric to assess the relatives of files that are in the same package or folder within the codebase 102 .
- a file within the same package or folder as another file may cause bugs in that other file.
- associating file ID, package IDs, folder IDs, extensions, etc., to a change list ID may indicate a number of files that were changed at the same time and within the same file, package, folder, etc.
- a spatial relative depends on the logical coupling distance as described above except that the compared files need to be in the same folder/package in the codebase 102 . In other words, calculating spatial relatives 226 requires that files have a small or “closest” coupling distance and the files need to be in the same folder/package.
- FIGS. 3 and 4 illustrate embodiments of data tables 300 and 400 that may be created from the codebase files 103 and include at least some of the metrics described above.
- the data tables 300 and 400 may include data related to all of the codebase files 103 to allow each file within the codebase to be ranked against all other codebase files 103 according to the metrics described above.
- the bug organizer API 108 may be trained on the code tree 106 a to identify each folder, extension, feature, etc., of the codebase 102 and organize the files according to the metrics described above into a database 110 including one or more data tables 300 and 400 .
- a file may be ranked based on any of the metrics 310 , 312 , 314 , 316 , 318 , 320 , 322 , 324 , 402 , and 404 or a weighted combination of the metrics to create an ordered results list 112 of the database tables 300 and 400 .
- various other tables may be created to rank subsets of the files 103 within the ordered list 112 among any or all of the other files.
- the bug organizer API 108 may identify the top 10% in a given folder, or the top 10% of a given extension, feature, etc., of the entire codebase 102 Also, the bug organizer API 108 may rank a file as a certain percentile above 116 or below 118 a baseline file 114 . Using a complete database 110 of the codebase 102 , the bug organizer API 108 may analyze the entire codebase 102 to allow building complex combinations of queries for the metrics 310 , 312 , 314 , 316 , 318 , 320 , 322 , 324 , 402 , and 404 or a weighted combination of the metrics.
- the data tables 300 and 400 may permit analysis and ranking of codebase files according to whether a file or subset of codebase files is more fault-prone than another file or files (e.g., a baseline file 114 ).
- Past bug identification and analysis techniques using only a cache of the codebase files did not allow fault risk analysis among files that were not in the cache.
- past cache-based systems for analyzing fault-prone code retained files in the cache that were considered fault prone, but these fault-prone files were not ranked one above another as more or less fault prone than other files in the codebase.
- the database system 100 employing the data tables 300 and 400 may permit the addition of other metrics to the analysis without completely retraining the bug organizer API 108 on the code tree 106 a as required in a cache-based system.
- a first data table 300 may be created by the bug organizer API 108 from the codebase files 103 and include at least some of the metrics described above.
- the table 300 includes data for each of the files within the codebase as a data table record 301 .
- the data may include the name of each file 310 selected from the codebase, a changelist ID 312 , a number of lines of code in the file 314 , a time of the last change to the file 316 , a total number of changes to the file 318 , a change density 320 , a total number of bugs in the file 322 , and a bug density 324 to name only a few possible types of data that may be stored in the table 300 .
- a second data table 400 may be created from the codebase files 103 and include at least some of the metrics described above.
- the table 400 is created by the bug organizer API 108 and includes a file ID 310 , a change list ID 312 , a logical coupling relative metric 402 , and a spatial relatives metric 404 .
- FIG. 5 illustrates an exemplary block diagram of a method 500 for analyzing a codebase 102 to identify fault-prone code.
- the method 500 uses the system 100 and its various components as described herein.
- the method 300 may include one or more blocks, modules, functions or routines in the form of computer-executable instructions that are stored in a tangible computer-readable medium and executed using a processor of a computing device (e.g., a computing device of a three-dimensional modeling system, as described herein).
- the method 500 may be included as part of any of modules of a computing environment for a system 100 for analyzing code from a codebase 102 to identify files 103 and code that are most likely to include bugs.
- the method 500 may be part of a bug organizer API 108 executing within a computing device of the system 100 .
- FIG. 5 is described with reference to FIGS. 1-4 for ease of explanation, but the method 500 can of course be utilized with other objects, APIs, user interfaces, etc., and implemented on the fault-prone code identification system 600 described below.
- the method 500 may store the metrics 204 and codebase files 103 of the codebase 102 and the various metrics in the bug analyzer database 110 .
- the bug organizer API 108 creates one or more tables (e.g., tables 300 and 400 ) and populates those tables with the metrics 204 portion of each file 200 within the database 110 .
- the method 500 may populate the database 110 using files 301 that include a last change time 316 that is more recent that a particular threshold. For example, files having a last changed time 216 of greater than one month, six months, or another period may indicate that the file is generally stable and bug-free.
- Block 502 may be configured by a user to select files having a last changed time 216 according to a user-defined threshold (e.g., one month, six months, etc.).
- the API 108 may also store both the code 202 and metrics 204 portions of each file 200 in the database 110 .
- the bug organizer API 108 may be trained on the code tree 106 a to identify each folder, extension, etc., of the codebase 102 and organize the files 103 according to the metrics described above.
- the API 108 may first cycle through the files 103 of various codebase directories to collect the metrics 204 for each file ID.
- the API 108 may also cycle through the change list 107 to determine the number of bugs 322 for each file.
- the API 108 may parse and analyze the codebase 102 and the change list IDs 107 a and comments 107 b for each codebase file to determine the total number of bugs for each file. For example, the API 108 may initiate a first loop to parse and analyze the codebase 102 . The API 108 may then parse the comments 107 b within each change list 107 that correspond to a change list ID 107 a .
- a file corresponding to a file ID 310 that is associated with a change list ID 312 and a change list comment 107 b including words that indicate a fixed bug (i.e., fix, bug, error, fault, glitch, issue, undocumented feature, challenge, design side effect, problem, etc.) will be a “hit” such that block 502 will increment the total number of bugs 322 corresponding to that file ID 310 .
- a fixed bug i.e., fix, bug, error, fault, glitch, issue, undocumented feature, challenge, design side effect, problem, etc.
- each file entry within the data tables 300 and 400 may be updated to include the metrics or more information for one or more files as determined by the API 108 from the change lists 107 and other data.
- the API 108 monitors the last change time 504 metric for files within the codebase 102 and executes block 504 if the last change time 316 metric is updated.
- the API 108 monitors other metrics or a combination of metrics to determine when the database 110 and tables 300 and 400 should be updated. Block 504 ensures that the method 500 continuously updates the database 110 and tables 300 and 400 so that the ranking described below is an accurate representation of the current codebase 102 .
- the method 600 is able to continuously rank the files in the database 110 and allows accounting for the introduction of fault-inducing code into the codebase files 103 as developers and other methods edit or add to the codebase 102 .
- a subset of the records 301 for analysis may be determined.
- a subset is determined as a query to the codebase 102 or the database 110 according to one or more criteria. For example, to analyze only C++ files, the bug organizer API 108 may initiate a query to the database 110 to select only those files 301 including a file ID 310 with a “.cpp” file extension. Additionally, the bug organizer API 108 may query a particular directory or sub-directory of the codebase 102 to retrieve a particular set of files 301 and populate the database 110 for later analysis. The API 108 may initiate a SQL-like string to create various subsets and determine a total number of files 301 within the subset.
- the files 301 may be ranked according to the metrics and averages of the metrics for the files retrieved from the database 110 .
- the files 301 may be rank ordered according one or more of the metrics 310 , 312 , 314 , 316 , 318 , 320 , 322 , 324 , 402 , and 404 or a weighted combination of the metrics. Additionally, each ranking may then be totaled and averaged to determine an average ranking 326 for each file 301 based on the metrics.
- the method 500 may also determine each ranking 326 according to various file characteristics such as determining a file's overall percentile within the database 110 or within a targeted folder of the codebase 102 .
- the method 500 may also retrieve any files from the database 110 that include a metric that is above a given percentile threshold.
- a baseline file 114 may be determined as including a metric ranking or an average ranking above or below which a file may be fault-prone and likely to include one or more bugs to be corrected.
- a ranking 326 may be used as a limit in a query to the database 110 to determine files that should be flagged for further analysis.
- the method may flag each file 301 that includes a particular metric or total average 326 above a threshold value.
- the block 510 may include a flag 230 for each file that includes an average ranking 326 or a ranking of a single metric 310 , 312 , 314 , 316 , 318 , 320 , 322 , 324 , 402 , and 404 , combination of metrics, or a weighted combination of the metrics above the baseline 114 .
- the flag 230 may be used by another API to indicate which files are likely to be fault-prone. The flagged files may then be reviewed to determine if the file includes a bug and, if so, fixed.
- FIG. 6 is a high-level block diagram that of an example computing environment for a fault-prone code identification system 600 having a computing device 601 that may be used to implement the method 500 for analyzing a codebase 102 to identify fault-prone code.
- the computing device 601 may include a personal computer, thin client, or other known type of computing device. As will be recognized by one skilled in the art, in light of the disclosure and teachings herein, other types of computing devices can be used that have different architectures.
- Processor systems similar or identical to the example fault-prone code identification system 600 may be used to implement and execute the example codebase 102 , version control API 104 , bug organizer API 108 , and bug analyzer database 110 of FIG. 1 , the exemplary codebase file 200 of FIG.
- example fault-prone code identification system 600 is described below as including a plurality of peripherals, interfaces, chips, memories, etc., one or more of those elements may be omitted from other example processor systems used to implement and execute the example fault-prone code identification system 600 . Also, other components may be added.
- the system 600 includes a processor 602 that is coupled to an interconnection bus 604 .
- the processor 602 includes a register set or register space 606 , which is depicted in FIG. 6 as being entirely on-chip, but which could alternatively be located entirely or partially off-chip and directly coupled to the processor 602 via dedicated electrical connections and/or via the interconnection bus 604 .
- the processor 602 may be any suitable processor, processing unit or microprocessor.
- the system 600 may be a multi-processor system and, thus, may include one or more additional processors that are identical or similar to the processor 600 and that are communicatively coupled to the interconnection bus 604 .
- the processor 602 of FIG. 6 is coupled to a chipset 608 , which includes a memory controller 610 and a peripheral input/output (I/O) controller 612 .
- a chipset typically provides I/O and memory management functions as well as a plurality of general purpose and/or special purpose registers, timers, etc. that are accessible or used by one or more processors coupled to the chipset 608 .
- the memory controller 610 performs functions that enable the processor 602 (or processors if there are multiple processors) to access a system memory 614 and a mass storage memory 616 .
- the system memory 614 may include any desired type of volatile and/or non-volatile memory such as, for example, static random access memory (SRAM), dynamic random access memory (DRAM), flash memory, read-only memory (ROM), etc.
- the mass storage memory 616 may include any desired type of mass storage device. For example, if the fault-prone code identification system 600 is used to implement a bug organizer module 618 having an API 619 and a version control module 620 (as described by the method 500 of FIG.
- the mass storage memory 616 may include a hard disk drive, an optical drive, a tape storage device, a solid-state memory (e.g., a flash memory, a RAM memory, etc.), a magnetic memory (e.g., a hard drive), or any other memory suitable for mass storage.
- a hard disk drive an optical drive
- a tape storage device e.g., a tape-to-media tape-to-media tape-to-state memory
- a solid-state memory e.g., a flash memory, a RAM memory, etc.
- a magnetic memory e.g., a hard drive
- the terms module, function, operation, procedure, routine, step, and method refer to computer program logic or computer executable instructions that provide the specified functionality to the computing device.
- a module, function, operation, procedure, routine, step, and method can be implemented in hardware, firmware, and/or software.
- program modules and routines are stored in mass storage memory 616 , loaded into system memory 614 , and executed by a processor 602 or can be provided from computer program products that are stored in tangible computer-readable storage mediums (e.g. RAM, hard disk, optical/magnetic media, etc.).
- Mass storage 616 may also include a database 621 storing a plurality of codebase files 103 , a version history 106 , a code tree 106 a , and change list 107 and a database interface module through which the bug organizer module 618 , the API 619 , the version control module 620 , etc., may access the parametric objects 100 .
- the peripheral I/O controller 610 performs functions that enable the processor 602 to communicate with peripheral input/output (I/O) devices 622 and 624 and a network interface 626 via a peripheral I/O bus 628 .
- the I/O devices 622 and 624 may be any desired type of I/O device such as, for example, a keyboard, a display (e.g., a liquid crystal display (LCD), a cathode ray tube (CRT) display, etc.), a navigation device (e.g., a mouse, a trackball, a capacitive touch pad, a joystick, etc.), etc.
- the I/O devices 622 and 624 may be used with the bug organizer module 618 and version control 620 to receive attributes and formulas and display user interfaces as described in relation to FIG. 5 , above.
- the network interface 628 may be, for example, an Ethernet device, an asynchronous transfer mode (ATM) device, an 802.11 wireless interface device, a DSL modem, a cable modem, a cellular modem, etc., that enables the fault-prone code identification system 600 to communicate with another computer system having at least the elements described in relation to the fault-prone code identification system 600 .
- ATM asynchronous transfer mode
- memory controller 612 and the I/O controller 610 are depicted in FIG. 6 as separate functional blocks within the chipset 608 , the functions performed by these blocks may be integrated within a single integrated circuit or may be implemented using two or more separate integrated circuits.
- the fault-prone code identification system 600 may also implement the bug organizer module 618 and version control module 620 on remote computing devices 630 and 632 .
- the remote computing devices 630 and 632 may communicate with the computing device 601 over an Ethernet link 634 .
- the computing device 601 may receive code base files 200 from a remote computing device 630 , 632 .
- the bug organizer module 618 and/or the version control module 620 may be retrieved by the computing device 601 from a cloud computing server 636 via the Internet 638 .
- the bug organizer module 618 and/or the version control module 620 may be programmatically linked with the computing device 601 .
- the bug organizer module 618 and/or the version control odule 620 may be a Java® applet executing within a Java® Virtual Machine (JVM) environment resident in the computing device 601 or the remote computing devices 630 , 632 .
- the bug organizer module 618 and/or the version control module 620 may also be “plug-ins” adapted to execute in a web-browser located on the computing devices 601 , 630 , and 632 .
- a user can easily identify fault-prone code within a codebase within various subsets of the codebase and continuously rank the files according to their likelihood of presently including a bug.
- the subset may be created “on the fly” at any point in the lifetime of the codebase to instantly analyze code and understand the distribution of errors throughout the codebase.
- quality control systems and personnel are able to prioritize the correction of the fault-prone code.
- identifying fault-prone code allows further analysis of the circumstances that lead to bugs and improvement of the metrics used to first identify the fault-prone code.
- the system 600 may include but is not limited to any combination of a LAN, a MAN, a WAN, a mobile, a wired or wireless network, a private network, or a virtual private network.
- a LAN local area network
- MAN metropolitan area network
- WAN wide area network
- mobile wide area network
- wired or wireless network a local area network
- private network a wide area network
- virtual private network a virtual private network
- Modules may constitute either software modules (e.g., code embodied on a machine-readable medium or in a transmission signal, wherein the code is executed by a processor) or hardware modules.
- a hardware module is tangible unit capable of performing certain operations and may be configured or arranged in a certain manner.
- one or more computer systems e.g., a standalone, client or server computer system
- one or more hardware modules of a computer system e.g., a processor or a group of processors
- software e.g., an application or application portion as a hardware module that operates to perform certain operations as described herein.
- a hardware module may be implemented mechanically or electronically.
- a hardware module may comprise dedicated circuitry or logic that is permanently configured (e.g., as a special-purpose processor, such as a field programmable gate array (FPGA) or an application-specific integrated circuit (ASIC)) to perform certain operations.
- a hardware module may also comprise programmable logic or circuitry (e.g., as encompassed within a general-purpose processor or other programmable processor) that is temporarily configured by software to perform certain operations. It will be appreciated that the decision to implement a hardware module mechanically, in dedicated and permanently configured circuitry, or in temporarily configured circuitry (e.g., configured by software may be driven by cost and time considerations.
- hardware module should be understood to encompass a tangible entity, be that an entity that is physically constructed, permanently configured (e.g., hardwired), or temporarily configured (e.g., programmed) to operate in a certain manner or to perform certain operations described herein.
- “hardware-implemented module” refers to a hardware module. Considering embodiments in which hardware modules are temporarily configured (e.g., programmed), each of the hardware modules need not be configured or instantiated at any one instance in time. For example, where the hardware modules comprise a general-purpose processor configured using software, the general-purpose processor may be configured as respective different hardware modules at different times. Software may accordingly configure a processor, for example, to constitute a particular hardware module at one instance of time and to constitute a different hardware module at a different instance of time.
- Hardware modules can provide information to, and receive information from, other hardware modules. Accordingly, the described hardware modules may be regarded as being communicatively coupled. Where multiple of such hardware modules exist contemporaneously, communications may be achieved through signal transmission (e.g., over appropriate circuits and buses) that connect the hardware modules. In embodiments in which multiple hardware modules are configured or instantiated at different times, communications between such hardware modules may be achieved, for example, through the storage and retrieval of information in memory structures to which the multiple hardware modules have access. For example, one hardware module may perform an operation and store the output of that operation in a memory device to which it is communicatively coupled. A further hardware module may then, at a later time, access the memory device to retrieve and process the stored output. Hardware modules may also initiate communications with input or output devices, and can operate on a resource (e.g., a collection of information).
- a resource e.g., a collection of information
- processors may be temporarily configured (e.g., by software) or permanently configured to perform the relevant operations. Whether temporarily or permanently configured, such processors may constitute processor-implemented modules that operate to perform one or more operations or functions.
- the modules referred to herein may, in some example embodiments, comprise processor-implemented modules.
- the methods or routines described herein may be at least partially processor-implemented. For example, at least some of the operations of a method may be performed by one or processors or processor-implemented hardware modules. The performance of certain of the operations may be distributed among the one or more processors, not only residing within a single machine, but deployed across a number of machines. In some example embodiments, the processor or processors may be located in a single location (e.g., within a home environment, an office environment or as a server farm), while in other embodiments the processors may be distributed across a number of locations.
- the one or more processors may also operate to support performance of the relevant operations in a “cloud computing” environment or as a “software as a service” (SaaS). For example, at least some of the operations may be performed by a group of computers (as examples of machines including processors), these operations being accessible via a network (e.g., the Internet) and via one or more appropriate interfaces (e.g., application program interfaces (APIs).)
- SaaS software as a service
- the performance of certain of the operations may be distributed among the one or more processors, not only residing within a single machine, but deployed across a number of machines.
- the one or more processors or processor-implemented modules may be located in a single geographic location (e.g., within a home environment, an office environment, or a server farm). In other example embodiments, the one or more processors or processor-implemented modules may be distributed across a number of geographic locations.
- any reference to “some embodiments” or “an embodiment” means that a particular element, feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment.
- the appearances of the phrase “in some embodiments” in various places in the specification are not necessarily all referring to the same embodiment.
- Coupled and “connected” along with their derivatives.
- some embodiments may be described using the term “coupled” to indicate that two or more elements are in direct physical or electrical contact.
- the term “coupled,” however, may also mean that two or more elements are not in direct contact with each other, but yet still co-operate or interact with each other.
- the embodiments are not limited in this context.
- the terms “comprises,” “comprising,” “includes,” “including,” “has,” “having” or any other variation thereof, are intended to cover a non-exclusive inclusion.
- a process, method, article, or apparatus that comprises a list of elements is not necessarily limited to only those elements but may include other elements not expressly listed or inherent to such process, method, article, or apparatus.
- “or” refers to an inclusive or and not to an exclusive or. For example, a condition A or B is satisfied by any one of the following: A is true (or present) and B is false (or not present), A is false (or not present) and B is true (or present), and both A and B are true (or present).
Abstract
Description
- The present disclosure relates generally to identifying fault prone computer code and more specifically to a system and a method configured analyze metrics associated with codebase code files to identify files that are most likely to cause faults when executed.
- The background description provided herein is for the purpose of generally presenting the context of the disclosure. Work of the presently named inventors, to the extent it is described in this background section, as well as aspects of the description that may not otherwise qualify as prior art at the time of filing, are neither expressly nor impliedly admitted as prior art against the present disclosure.
- Complex software applications often require massive collections of source code files organized within codebases. Codebases are usually created by engineers, software developers, and other technicians who write individual code files describing the application's modules, methods, functions, etc. These files are included within the application's codebase. To keep the files organized, the codebase may be conceptually maintained in a tree structure maintained by a version control system. Within the code tree, a branch generally describes a version of an application module that was changed, but does not include any new features, while a trunk may include a module with new features. Teams of engineers design, develop and deploy software across distant locations. Multiple versions of software files are often deployed from these different locations while other developers work on updates to the same files. Errors or “bugs” may only be present in certain versions, therefore to locate and fix any bugs, particular versions of the software must be located and tested to determine which version(s) are causing the problem.
- During the lifetime of an application, software developers commit or merge multiple file versions, patches, edits, etc., to the codebase. These commit operations tell the version control system that a group of changes will be made final and available to all users. That group of changes is typically maintained in a change list. Each group of changes in a single commit action includes a unique change list ID.
- Of course, whenever a software developer performs a commit action, he or she also possibly introduces bugs to the codebase. To counter the inevitable introduction of bugs, most software development teams are complimented by a quality assurance team to perform automated and manual testing of the files within the codebase. Ideally, quality assurance teams perform tests on the submitted files until the codebase reaches a confirmed level of code maturity and stability. However, because the complex development and execution relationships between the various files in the code tree, it is difficult to measure an exact level of quality assurance. For example, development of an application follows numerous paths along the code tree including various branches and trunks during the development cycle. Accounting for and writing tests for every possible code path in a complex application would consume a significant amount of resources and time. Further, it has been observed that bugs are not distributed linearly within a codebase, but rather, bugs occur in “bursts” where a single bug causes multiple, other bugs in a cascading effect throughout the code base. Thus, testing a percentage of the total amount of code within the codebase will not account for an equal percentage of the total number of bugs that are present in the codebase (i.e., scanning fifty percent of the total amount of code within the codebase will not account for fifty percent of the total bugs in the codebase).
- Some techniques to identify and analyze bugs within a codebase have focused on providing a Boolean indicator of whether a particular piece of the codebase was more or less likely to include a bug. For example, cache techniques may rank files within a codebase according to the number of lines of code within the file. Then, each of the ranked files and its closest relatives may receive a “hit” if it had been changed to fix a bug. Files that have been fixed most recently may remain in the cache, while those that have been changed less recently may be removed from the cache. These techniques allow a “hit or miss” identification of fault-prone files within a cache selection of the codebase.
- A computer-implemented method or a computer system or a computer-readable medium storing a set of instructions for execution on a processor operates to identify fault-prone code by determining, ranking, and analyzing metrics associated with codebase code files. Functions of the method or system or stored on a computer-readable medium may determine metrics corresponding to each file of a plurality of codebase files within a codebase for an application. The functions may also store the metrics corresponding to each codebase file in a record of a database table, rank order the plurality of codebase files according to at least one metric, and flag each codebase file having a ranking over a threshold value of the metric. The codebase file metrics may describe fault-inducing characteristics of the plurality of codebase files and include both a total number of previous faults and a total number of changes that are associated with each codebase file.
- In some embodiments, the computer-implemented method or computer system or computer-readable medium storing a set of instructions for execution on a processor operates to detect a change to the plurality of codebase files and update the metrics corresponding to each file of the plurality of codebase files. Some embodiments may then continuously rank order the plurality of codebase files according to the updated metrics to account for fault-inducing changes to the codebase files.
- The metrics may further include one or more of a file ID, a change list ID, a number of lines of code within the file, a time the file was last edited, a change density, a total number of faults, a fault density, logical coupling relatives, and spatial relatives. The change density may include a number of times the file has been changed compared to the number of lines of code within the file and the fault density may include the total number of faults compared to the number of lines of code within the file. The logical coupling relatives may include a measurement of a number of times a file is changed in conjunction with a change action for another file in the codebase, while the spatial relatives may include a measurement of a number of times a file is changed in conjunction with a change action for another file in a same folder or package as the file.
- In further embodiments, rank ordering the plurality of codebase files may include determining a weighted average of the metrics for each codebase file and ranking the plurality of codebase files according to the weighted average. Further, rank ordering may include a subset of the plurality of codebase files that are ranked according to at least one metric. The subset may include a folder, an extension, a feature, or a package of a codebase file.
- In still further embodiments, the system may include a processor and a memory that stores various structures and modules to identify fault-prone code. For example, a version control module may be stored in the memory and have an API defining functions that are executable by the processor to store codebase files within a codebase and manage a change list for tracking changes to the codebase files. Also, a database may be stored in the memory and include a plurality of records that each store a set of metrics corresponding to each codebase file stored in the codebase. A bug organizer module may be stored in the memory and have an API defining functions that are executable by the processor to determine the sets of metrics for each codebase file, store the sets of metrics in the records, and rank order the codebase files within a table of the database according to the sets of metrics.
- The features and advantages described in this summary and the following detailed description are not all-inclusive. Many additional features and advantages will be apparent to one of ordinary skill in the art in view of the drawings, specification, and claims hereof. Additionally, other embodiments may omit one or more (or all) of the features and advantages described in this summary.
-
FIG. 1 is a high-level block diagram of a system for identifying fault prone files within an application codebase; -
FIG. 2 is an exemplary block diagram of a codebase file; -
FIG. 3 is one example of a database table used to identify fault-prone code; -
FIG. 4 is another example of a database table used to identify fault-prone code; -
FIG. 5 is an exemplary block diagram of a method for identifying fault-prone code; and -
FIG. 6 is high-level block diagram of a computing environment that implements a system for identifying fault prone files within an application codebase. - Generally speaking, a debugging system and method may identify files within a codebase that are most likely to include bugs by measuring and analyzing particular metrics that are associated with each file in the codebase. The file metrics may be associated with a version history of the codebase and include a plurality bug localities and heuristics as described below.
-
FIG. 1 is a high-level bock diagram that illustrates asystem 100 for analyzing code from acodebase 102 to identifyfiles 103 and code that are most likely to include bugs. Generally, aversion control API 104 may perform commit operations to storecode files 103 within thecodebase 102 or to re-savecode files 103 that were edited from within thecodebase 102. Theversion control API 104 may also manage aversion history 106 of thecodebase 102. Theversion history 106 may include a plurality of unique identifiers that are conceptually related to one another and describe acode tree 106 a for the application code stored in thecodebase 102. Theversion history 106 may also include achange list 107 for tracking all changes made to codebase files. In some embodiments, thechange list 107 includes achange list ID 107 a and comments 107 b for eachcodebase file 102 that is changed. For example, a developer may edit code within a file or group offiles 102 and initiate a commit action with comments about the changes made using theversion control API 104. TheAPI 104 may then assign achange list ID 107 a corresponding to the changedfiles 102 andcomments 107 b. Theversion history 106 may also be updated in thecode tree 106 a. - The
version control API 104 may also associate thechange list ID 107 a, comments 107 b, and metrics with the code files when a developer, automatic code generator, or other entity or device performs the commit action or other action (e.g., an edit action, a bug counting action, etc.) with thecode file 103. Abug organizer API 108 may identify and extract codebase files from thecodebase 102 that have one or more metrics associated with the files. Thebug organizer API 108 may then organize the extracted codebase files into adatabase 110 according to the file metrics. Thedatabase 110 may then sort and order the extracted codebase files into an ordered set ofcodebase files 112 according to the metrics. A member of the ordered set 112 may be selected as abaseline file 114 that includes a value of the metrics such that those files having a value above 116 or below 118 the value of the baseline file 114 metrics are identified as most likely to include bugs. A quality assurance team may then focus their attention on only those codebase files that are most likely to include bugs. Abug tracking system 120 may also maintain abug list 120 a having identifiers that reference one or more bugs that have been identified and/or fixed within the codebase files 103. Where thebug list 120 a includes an identifier corresponding to a fixed bug, achange list ID 107 a may also correspond to the bug list 102 a. -
FIG. 2 is a block diagram of one embodiment of acodebase file 200. In some embodiments, thecodebase file 200 may include two main components:code 202 andmetrics 204. Thecode 202 may include text and other instructions that may be compiled and executed on a computer. In some embodiments, thecode 202 includes text instructions in a high-level programming language such as Java®, C, or other languages. Generally, thecode 202 is written in a programming language that facilitates the developer's task to create computer-executable procedures. Executing a commit action with aversion control API 104 or other module may associate themetrics 204 with thecode 202 and both thecode 202 andmetrics 204 may be stored in thecodebase 102 as acodebase file 200 organized by theversion history 106. - The
metrics 204 may include any information that is useful to identify bug-prone codebase files. In some embodiments, themetrics 204 include afile ID 210, achange list ID 211, a number of lines of code within thefile 212, a time the file was last edited 214, a number of times the file has been changed 216, a change density 218 (i.e., a number of times the file has been changed compared to the number of lines of code within the file), a total number of bugs found in thefile 220, a bug density 222 (i.e., a number of bugs found in the file compared to the number of lines of code within the file),logical coupling relatives 224, andspatial relatives 226. - A
version control API 104 may associate achange list ID 211 with thefile 200. In some embodiments, theAPI 104 associates a unique change list ID with any file that is added to thecodebase 102 in a commit action. For example, theAPI 104 may execute a commit action to add several files to thecodebase 102 that have been edited by a developer merely to add or remove features or to correct a fault. Theversion control API 104 may attachcomments 107 b to each changed file or to a particularchange list ID 211 that indicate whether the file or files associated with that change list ID were edited to add or remove features or to correct a fault. - The lines of
code 212 metric may indicate a file having more bugs because files with more lines of code tend to contain more bugs. While bugs are not evenly distributed throughout thecodebase 102, a file having a high the number of code lines may be a good indicator that the file will also contain bugs. Additionally, longer files may also be harder for a developer to understand and increase the likelihood of a fault within the file. - The
last edit time 214 metric may be selected as an indicator that a bug may have been introduced to the file because older files are more likely have had their bugs fixed than newer files. If a file has not been modified in a long time, then it is more likely that the file has stabilized and is not a source of bugs. - The number of
changes 216 metric may also be used to identify bug-prone code files because more changes increase the opportunities for introducing bugs to the file. - The
change density 218 metric may be selected to balance the effect offile length 212 against the number ofchanges 216. A file may be changed many times because it is very large. However, a small file that is changed often may indicate a greater opportunity for bug introduction across a small number of code lines. Thechange density 218 may be a measure of the number of changes versus the number of lines ofcode 212 in the file. - The total number of bugs found 220 metric may indicate that an associated file is bug prone. In some embodiments, the metric 220 may be incremented whenever the
file 200 is associated with a change that fixes a bug. For example, in a commit action, theversion control API 104 may associate achange list ID 107 a and comments 107 b with anyfile 200 that is edited. Thebug organizer API 108 may search thecomments 107 b for any word, phrase, or symbol that indicates thefile 200 corresponding to thechange list ID 107 a and comments 107 b was edited to fix a bug. In some embodiments, theAPI 108 searches thecomments 107 b for words such as bug, fix, repair, patch, error, fault, etc., that indicate that thecomments 107 b are associated with afile 200 that has been changed to fix a bug. Further, an identifier of thebug list 120 a may also correspond to achange list ID 107 a and, thus, contribute to the total number of bugs found 220 metric. In other words, afile 200 that, at least at one time, included a bug, is more likely to continue to have a bug. - The
bug density 222 metric accounts for the number of bugs in thefile 200 against the number ofcode lines 212 in thesame file 200. For example, afile 200 including many thousands of lines ofcode 212, but only threetotal bugs 220 may be much less bug prone than a file including only five lines ofcode 212 and twototal bugs 220. Thebug density 222 may be a measure of the total number of bugs versus the number of lines ofcode 212 in the file. - The
logical coupling relatives 224 include a metric to assess how many times thefile 200 was changed in conjunction with other files. For example, files that are changed at the same time often share resources or rely on each other in some way during execution. Therefore, a change in any file that relies on another file during execution may introduce bugs in that other file. Further, two files that are changed at the same time may also introduce bugs in those two files. In some embodiments, associating file IDs and a change list ID may indicate a number of files that were changed at the same time. Thelogical coupling relatives 224 may be ranked according to the smallest coupling distance. For example, a coupling distance between two files fileA and fileB is equal to: -
- Thus, files 103 that were never changed together have an infinite coupling distance, while two files that were changed together twenty times, for example, have a coupling distance of 1/20(=0.05). Smaller distances indicate that the
logical coupling 224 is stronger. After you pick a number of files with the smallest distance from fileA, for example, an average bug likelihood for that number of files may be added to the bug likelihood for fileA. How likely it is that a change in fileA will cause a bug may depends on how bug prone are the files that are logical coupling relatives to fileA. - When the bug likelihood is averaged for a number of the “closest” files to fileA, using a bug likelihood that comes from the number of “closest” files to calculate a logical coupling might cause endless recursions. For example, if the ten files logically coupled to fileA are {fileB, fileC, fileD, . . . , fileJ, fileK}, using the logical coupling metric to calculate the files' bug likelihood might result in the bug likelihood of fileA depending on the bug likelihood of fileB, and the bug likelihood of fileB depending on the bug likelihood of fileA (i.e., if fileA is logically coupled with fileB, fileB is also logically coupled with fileA). To avoid this computational issue, the bug likelihood that depends on logical coupling relatives of fileA should not be used when averaging the bug likelihood of the logical coupling relatives of fileA.
- The
spatial relatives 226 include a metric to assess the relatives of files that are in the same package or folder within thecodebase 102. Much likelogical coupling 224, a file within the same package or folder as another file may cause bugs in that other file. In some embodiments, associating file ID, package IDs, folder IDs, extensions, etc., to a change list ID may indicate a number of files that were changed at the same time and within the same file, package, folder, etc. A spatial relative depends on the logical coupling distance as described above except that the compared files need to be in the same folder/package in thecodebase 102. In other words, calculatingspatial relatives 226 requires that files have a small or “closest” coupling distance and the files need to be in the same folder/package. -
FIGS. 3 and 4 illustrate embodiments of data tables 300 and 400 that may be created from the codebase files 103 and include at least some of the metrics described above. The data tables 300 and 400 may include data related to all of the codebase files 103 to allow each file within the codebase to be ranked against all othercodebase files 103 according to the metrics described above. In some embodiments, thebug organizer API 108 may be trained on thecode tree 106 a to identify each folder, extension, feature, etc., of thecodebase 102 and organize the files according to the metrics described above into adatabase 110 including one or more data tables 300 and 400. Within the tables 300 and 400, a file may be ranked based on any of themetrics database 110 including all of the codebase files 103, various other tables may be created to rank subsets of thefiles 103 within the orderedlist 112 among any or all of the other files. For example, once trained on theentire codebase tree 106 a, thebug organizer API 108 may identify the top 10% in a given folder, or the top 10% of a given extension, feature, etc., of theentire codebase 102 Also, thebug organizer API 108 may rank a file as a certain percentile above 116 or below 118 abaseline file 114. Using acomplete database 110 of thecodebase 102, thebug organizer API 108 may analyze theentire codebase 102 to allow building complex combinations of queries for themetrics - Importantly, the data tables 300 and 400 may permit analysis and ranking of codebase files according to whether a file or subset of codebase files is more fault-prone than another file or files (e.g., a baseline file 114). Past bug identification and analysis techniques using only a cache of the codebase files did not allow fault risk analysis among files that were not in the cache. In other words, past cache-based systems for analyzing fault-prone code retained files in the cache that were considered fault prone, but these fault-prone files were not ranked one above another as more or less fault prone than other files in the codebase. The
database system 100 employing the data tables 300 and 400 may permit the addition of other metrics to the analysis without completely retraining thebug organizer API 108 on thecode tree 106 a as required in a cache-based system. - A first data table 300 may be created by the
bug organizer API 108 from the codebase files 103 and include at least some of the metrics described above. In some embodiments, the table 300 includes data for each of the files within the codebase as adata table record 301. The data may include the name of eachfile 310 selected from the codebase, achangelist ID 312, a number of lines of code in thefile 314, a time of the last change to thefile 316, a total number of changes to thefile 318, achange density 320, a total number of bugs in thefile 322, and abug density 324 to name only a few possible types of data that may be stored in the table 300. - A second data table 400 may be created from the codebase files 103 and include at least some of the metrics described above. In some embodiments, the table 400 is created by the
bug organizer API 108 and includes afile ID 310, achange list ID 312, a logical couplingrelative metric 402, and a spatial relatives metric 404. -
FIG. 5 illustrates an exemplary block diagram of amethod 500 for analyzing acodebase 102 to identify fault-prone code. In some embodiments, themethod 500 uses thesystem 100 and its various components as described herein. Themethod 300 may include one or more blocks, modules, functions or routines in the form of computer-executable instructions that are stored in a tangible computer-readable medium and executed using a processor of a computing device (e.g., a computing device of a three-dimensional modeling system, as described herein). Themethod 500 may be included as part of any of modules of a computing environment for asystem 100 for analyzing code from acodebase 102 to identifyfiles 103 and code that are most likely to include bugs. For example, themethod 500 may be part of abug organizer API 108 executing within a computing device of the system100.FIG. 5 is described with reference toFIGS. 1-4 for ease of explanation, but themethod 500 can of course be utilized with other objects, APIs, user interfaces, etc., and implemented on the fault-pronecode identification system 600 described below. - At
block 502, themethod 500 may store themetrics 204 andcodebase files 103 of thecodebase 102 and the various metrics in thebug analyzer database 110. In some embodiments, thebug organizer API 108 creates one or more tables (e.g., tables 300 and 400) and populates those tables with themetrics 204 portion of eachfile 200 within thedatabase 110. Themethod 500 may populate thedatabase 110 usingfiles 301 that include alast change time 316 that is more recent that a particular threshold. For example, files having a lastchanged time 216 of greater than one month, six months, or another period may indicate that the file is generally stable and bug-free.Block 502 may be configured by a user to select files having a lastchanged time 216 according to a user-defined threshold (e.g., one month, six months, etc.). TheAPI 108 may also store both thecode 202 andmetrics 204 portions of eachfile 200 in thedatabase 110. To populate the database tables 300 and 400, thebug organizer API 108 may be trained on thecode tree 106 a to identify each folder, extension, etc., of thecodebase 102 and organize thefiles 103 according to the metrics described above. TheAPI 108 may first cycle through thefiles 103 of various codebase directories to collect themetrics 204 for each file ID. TheAPI 108 may also cycle through thechange list 107 to determine the number ofbugs 322 for each file. In some embodiments, theAPI 108 may parse and analyze thecodebase 102 and thechange list IDs 107 a and comments 107 b for each codebase file to determine the total number of bugs for each file. For example, theAPI 108 may initiate a first loop to parse and analyze thecodebase 102. TheAPI 108 may then parse thecomments 107 b within eachchange list 107 that correspond to achange list ID 107 a. A file corresponding to afile ID 310 that is associated with achange list ID 312 and achange list comment 107 b including words that indicate a fixed bug (i.e., fix, bug, error, fault, glitch, issue, undocumented feature, challenge, design side effect, problem, etc.) will be a “hit” such thatblock 502 will increment the total number ofbugs 322 corresponding to thatfile ID 310. - At
block 504, each file entry within the data tables 300 and 400 may be updated to include the metrics or more information for one or more files as determined by theAPI 108 from the change lists 107 and other data. In some embodiments, theAPI 108 monitors thelast change time 504 metric for files within thecodebase 102 and executes block 504 if thelast change time 316 metric is updated. In other embodiments, theAPI 108 monitors other metrics or a combination of metrics to determine when thedatabase 110 and tables 300 and 400 should be updated.Block 504 ensures that themethod 500 continuously updates thedatabase 110 and tables 300 and 400 so that the ranking described below is an accurate representation of thecurrent codebase 102. By ensuring that thedatabase 110 includes an accurate representation of thecurrent codebase 102, themethod 600 is able to continuously rank the files in thedatabase 110 and allows accounting for the introduction of fault-inducing code into the codebase files 103 as developers and other methods edit or add to thecodebase 102. - At
block 506, a subset of therecords 301 for analysis may be determined. In some embodiments, a subset is determined as a query to thecodebase 102 or thedatabase 110 according to one or more criteria. For example, to analyze only C++ files, thebug organizer API 108 may initiate a query to thedatabase 110 to select only thosefiles 301 including afile ID 310 with a “.cpp” file extension. Additionally, thebug organizer API 108 may query a particular directory or sub-directory of thecodebase 102 to retrieve a particular set offiles 301 and populate thedatabase 110 for later analysis. TheAPI 108 may initiate a SQL-like string to create various subsets and determine a total number offiles 301 within the subset. - At
block 508, thefiles 301 may be ranked according to the metrics and averages of the metrics for the files retrieved from thedatabase 110. In some embodiments, thefiles 301 may be rank ordered according one or more of themetrics average ranking 326 for eachfile 301 based on the metrics. Themethod 500 may also determine each ranking 326 according to various file characteristics such as determining a file's overall percentile within thedatabase 110 or within a targeted folder of thecodebase 102. Also, themethod 500 may also retrieve any files from thedatabase 110 that include a metric that is above a given percentile threshold. In some embodiments, abaseline file 114 may be determined as including a metric ranking or an average ranking above or below which a file may be fault-prone and likely to include one or more bugs to be corrected. For example, aranking 326 may be used as a limit in a query to thedatabase 110 to determine files that should be flagged for further analysis. - At
block 510, the method may flag eachfile 301 that includes a particular metric or total average 326 above a threshold value. In some embodiments, theblock 510 may include aflag 230 for each file that includes anaverage ranking 326 or a ranking of asingle metric baseline 114. Theflag 230 may be used by another API to indicate which files are likely to be fault-prone. The flagged files may then be reviewed to determine if the file includes a bug and, if so, fixed. -
FIG. 6 is a high-level block diagram that of an example computing environment for a fault-pronecode identification system 600 having acomputing device 601 that may be used to implement themethod 500 for analyzing acodebase 102 to identify fault-prone code. Thecomputing device 601 may include a personal computer, thin client, or other known type of computing device. As will be recognized by one skilled in the art, in light of the disclosure and teachings herein, other types of computing devices can be used that have different architectures. Processor systems similar or identical to the example fault-pronecode identification system 600 may be used to implement and execute theexample codebase 102,version control API 104,bug organizer API 108, andbug analyzer database 110 ofFIG. 1 , theexemplary codebase file 200 ofFIG. 2 , the tables ofFIGS. 3 and 4 , and the method ofFIG. 5 . Although the example fault-pronecode identification system 600 is described below as including a plurality of peripherals, interfaces, chips, memories, etc., one or more of those elements may be omitted from other example processor systems used to implement and execute the example fault-pronecode identification system 600. Also, other components may be added. - As shown in
FIG. 6 , thesystem 600 includes aprocessor 602 that is coupled to aninterconnection bus 604. Theprocessor 602 includes a register set or registerspace 606, which is depicted inFIG. 6 as being entirely on-chip, but which could alternatively be located entirely or partially off-chip and directly coupled to theprocessor 602 via dedicated electrical connections and/or via theinterconnection bus 604. Theprocessor 602 may be any suitable processor, processing unit or microprocessor. Although not shown inFIG. 6 , thesystem 600 may be a multi-processor system and, thus, may include one or more additional processors that are identical or similar to theprocessor 600 and that are communicatively coupled to theinterconnection bus 604. - The
processor 602 ofFIG. 6 is coupled to achipset 608, which includes amemory controller 610 and a peripheral input/output (I/O)controller 612. As is well known, a chipset typically provides I/O and memory management functions as well as a plurality of general purpose and/or special purpose registers, timers, etc. that are accessible or used by one or more processors coupled to thechipset 608. Thememory controller 610 performs functions that enable the processor 602 (or processors if there are multiple processors) to access asystem memory 614 and amass storage memory 616. - The
system memory 614 may include any desired type of volatile and/or non-volatile memory such as, for example, static random access memory (SRAM), dynamic random access memory (DRAM), flash memory, read-only memory (ROM), etc. Themass storage memory 616 may include any desired type of mass storage device. For example, if the fault-pronecode identification system 600 is used to implement abug organizer module 618 having anAPI 619 and a version control module 620 (as described by themethod 500 ofFIG. 5 ), themass storage memory 616 may include a hard disk drive, an optical drive, a tape storage device, a solid-state memory (e.g., a flash memory, a RAM memory, etc.), a magnetic memory (e.g., a hard drive), or any other memory suitable for mass storage. As used herein, the terms module, function, operation, procedure, routine, step, and method refer to computer program logic or computer executable instructions that provide the specified functionality to the computing device. Thus, a module, function, operation, procedure, routine, step, and method can be implemented in hardware, firmware, and/or software. In one embodiment, program modules and routines (e.g., thebug organizer module 618, theAPI 619, and theversion control module 620 are stored inmass storage memory 616, loaded intosystem memory 614, and executed by aprocessor 602 or can be provided from computer program products that are stored in tangible computer-readable storage mediums (e.g. RAM, hard disk, optical/magnetic media, etc.).Mass storage 616 may also include adatabase 621 storing a plurality ofcodebase files 103, aversion history 106, acode tree 106 a, andchange list 107 and a database interface module through which thebug organizer module 618, theAPI 619, theversion control module 620, etc., may access the parametric objects 100. - The peripheral I/
O controller 610 performs functions that enable theprocessor 602 to communicate with peripheral input/output (I/O)devices network interface 626 via a peripheral I/O bus 628. The I/O devices O devices bug organizer module 618 andversion control 620 to receive attributes and formulas and display user interfaces as described in relation toFIG. 5 , above. The network interface 628 may be, for example, an Ethernet device, an asynchronous transfer mode (ATM) device, an 802.11 wireless interface device, a DSL modem, a cable modem, a cellular modem, etc., that enables the fault-pronecode identification system 600 to communicate with another computer system having at least the elements described in relation to the fault-pronecode identification system 600. - While the
memory controller 612 and the I/O controller 610 are depicted inFIG. 6 as separate functional blocks within thechipset 608, the functions performed by these blocks may be integrated within a single integrated circuit or may be implemented using two or more separate integrated circuits. - The fault-prone
code identification system 600 may also implement thebug organizer module 618 andversion control module 620 onremote computing devices remote computing devices computing device 601 over anEthernet link 634. For example, thecomputing device 601 may receive code base files 200 from aremote computing device bug organizer module 618 and/or theversion control module 620 may be retrieved by thecomputing device 601 from acloud computing server 636 via theInternet 638. When using thecloud computing server 636, thebug organizer module 618 and/or theversion control module 620 may be programmatically linked with thecomputing device 601. Thebug organizer module 618 and/or the version control odule 620 may be a Java® applet executing within a Java® Virtual Machine (JVM) environment resident in thecomputing device 601 or theremote computing devices bug organizer module 618 and/or theversion control module 620 may also be “plug-ins” adapted to execute in a web-browser located on thecomputing devices - Using the systems and procedures described above, a user can easily identify fault-prone code within a codebase within various subsets of the codebase and continuously rank the files according to their likelihood of presently including a bug. The subset may be created “on the fly” at any point in the lifetime of the codebase to instantly analyze code and understand the distribution of errors throughout the codebase. Furthermore, by providing a ranking of the likelihood that each file includes a bug, quality control systems and personnel are able to prioritize the correction of the fault-prone code. Likewise, identifying fault-prone code allows further analysis of the circumstances that lead to bugs and improvement of the metrics used to first identify the fault-prone code.
- Throughout this specification, plural instances may implement components, operations, or structures described as a single instance. Although individual operations of one or more methods are illustrated and described as separate operations, one or more of the individual operations may be performed concurrently, and nothing requires that the operations be performed in the order illustrated. Structures and functionality presented as separate components in example configurations may be implemented as a combined structure or component. Similarly, structures and functionality presented as a single component may be implemented as separate components. These and other variations, modifications, additions, and improvements fall within the scope of the subject matter herein.
- For example, the
system 600 may include but is not limited to any combination of a LAN, a MAN, a WAN, a mobile, a wired or wireless network, a private network, or a virtual private network. Moreover, while only tworemote computing devices FIG. 6 to simplify and clarify the description, it is understood that any number of client computers are supported and can be in communication within thesystem 600. - Additionally, certain embodiments are described herein as including logic or a number of components, modules, or mechanisms. Modules may constitute either software modules (e.g., code embodied on a machine-readable medium or in a transmission signal, wherein the code is executed by a processor) or hardware modules. A hardware module is tangible unit capable of performing certain operations and may be configured or arranged in a certain manner. In example embodiments, one or more computer systems (e.g., a standalone, client or server computer system) or one or more hardware modules of a computer system (e.g., a processor or a group of processors) may be configured by software (e.g., an application or application portion as a hardware module that operates to perform certain operations as described herein.
- In various embodiments, a hardware module may be implemented mechanically or electronically. For example, a hardware module may comprise dedicated circuitry or logic that is permanently configured (e.g., as a special-purpose processor, such as a field programmable gate array (FPGA) or an application-specific integrated circuit (ASIC)) to perform certain operations. A hardware module may also comprise programmable logic or circuitry (e.g., as encompassed within a general-purpose processor or other programmable processor) that is temporarily configured by software to perform certain operations. It will be appreciated that the decision to implement a hardware module mechanically, in dedicated and permanently configured circuitry, or in temporarily configured circuitry (e.g., configured by software may be driven by cost and time considerations.
- Accordingly, the term “hardware module” should be understood to encompass a tangible entity, be that an entity that is physically constructed, permanently configured (e.g., hardwired), or temporarily configured (e.g., programmed) to operate in a certain manner or to perform certain operations described herein. As used herein, “hardware-implemented module” refers to a hardware module. Considering embodiments in which hardware modules are temporarily configured (e.g., programmed), each of the hardware modules need not be configured or instantiated at any one instance in time. For example, where the hardware modules comprise a general-purpose processor configured using software, the general-purpose processor may be configured as respective different hardware modules at different times. Software may accordingly configure a processor, for example, to constitute a particular hardware module at one instance of time and to constitute a different hardware module at a different instance of time.
- Hardware modules can provide information to, and receive information from, other hardware modules. Accordingly, the described hardware modules may be regarded as being communicatively coupled. Where multiple of such hardware modules exist contemporaneously, communications may be achieved through signal transmission (e.g., over appropriate circuits and buses) that connect the hardware modules. In embodiments in which multiple hardware modules are configured or instantiated at different times, communications between such hardware modules may be achieved, for example, through the storage and retrieval of information in memory structures to which the multiple hardware modules have access. For example, one hardware module may perform an operation and store the output of that operation in a memory device to which it is communicatively coupled. A further hardware module may then, at a later time, access the memory device to retrieve and process the stored output. Hardware modules may also initiate communications with input or output devices, and can operate on a resource (e.g., a collection of information).
- The various operations of example methods described herein may be performed, at least partially, by one or more processors that are temporarily configured (e.g., by software) or permanently configured to perform the relevant operations. Whether temporarily or permanently configured, such processors may constitute processor-implemented modules that operate to perform one or more operations or functions. The modules referred to herein may, in some example embodiments, comprise processor-implemented modules.
- Similarly, the methods or routines described herein may be at least partially processor-implemented. For example, at least some of the operations of a method may be performed by one or processors or processor-implemented hardware modules. The performance of certain of the operations may be distributed among the one or more processors, not only residing within a single machine, but deployed across a number of machines. In some example embodiments, the processor or processors may be located in a single location (e.g., within a home environment, an office environment or as a server farm), while in other embodiments the processors may be distributed across a number of locations.
- The one or more processors may also operate to support performance of the relevant operations in a “cloud computing” environment or as a “software as a service” (SaaS). For example, at least some of the operations may be performed by a group of computers (as examples of machines including processors), these operations being accessible via a network (e.g., the Internet) and via one or more appropriate interfaces (e.g., application program interfaces (APIs).)
- The performance of certain of the operations may be distributed among the one or more processors, not only residing within a single machine, but deployed across a number of machines. In some example embodiments, the one or more processors or processor-implemented modules may be located in a single geographic location (e.g., within a home environment, an office environment, or a server farm). In other example embodiments, the one or more processors or processor-implemented modules may be distributed across a number of geographic locations.
- Some portions of this specification are presented in terms of algorithms or symbolic representations of operations on data stored as bits or binary digital signals within a machine memory (e.g., a computer memory). These algorithms or symbolic representations are examples of techniques used by those of ordinary skill in the data processing arts to convey the substance of their work to others skilled in the art. As used herein, an “algorithm” is a self-consistent sequence of operations or similar processing leading to a desired result. In this context, algorithms and operations involve physical manipulation of physical quantities. Typically, but not necessarily, such quantities may take the form of electrical, magnetic, or optical signals capable of being stored, accessed, transferred, combined, compared, or otherwise manipulated by a machine. It is convenient at times, principally for reasons of common usage, to refer to such signals using words such as “data,” “content,” “bits,” “values,” “elements,” “symbols,” “characters,” “terms,” “numbers,” “numerals,” or the like. These words, however, are merely convenient labels and are to be associated with appropriate physical quantities.
- Unless specifically stated otherwise, discussions herein using words such as “processing,” “computing,” “calculating,” “determining,” “presenting,” “displaying,” or the like may refer to actions or processes of a machine (e.g., a computer) that manipulates or transforms data represented as physical (e.g., electronic, magnetic, or optical) quantities within one or more memories (e.g., volatile memory, non-volatile memory, or a combination thereof), registers, or other machine components that receive, store, transmit, or display information.
- As used herein any reference to “some embodiments” or “an embodiment” means that a particular element, feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment. The appearances of the phrase “in some embodiments” in various places in the specification are not necessarily all referring to the same embodiment.
- Some embodiments may be described using the expression “coupled” and “connected” along with their derivatives. For example, some embodiments may be described using the term “coupled” to indicate that two or more elements are in direct physical or electrical contact. The term “coupled,” however, may also mean that two or more elements are not in direct contact with each other, but yet still co-operate or interact with each other. The embodiments are not limited in this context.
- As used herein, the terms “comprises,” “comprising,” “includes,” “including,” “has,” “having” or any other variation thereof, are intended to cover a non-exclusive inclusion. For example, a process, method, article, or apparatus that comprises a list of elements is not necessarily limited to only those elements but may include other elements not expressly listed or inherent to such process, method, article, or apparatus. Further, unless expressly stated to the contrary, “or” refers to an inclusive or and not to an exclusive or. For example, a condition A or B is satisfied by any one of the following: A is true (or present) and B is false (or not present), A is false (or not present) and B is true (or present), and both A and B are true (or present).
- In addition, use of the “a” or “an” are employed to describe elements and components of the embodiments herein. This is done merely for convenience and to give a general sense of the description. This description should be read to include one or at least one and the singular also includes the plural unless it is obvious that it is meant otherwise.
- Still further, the figures depict preferred embodiments of a map editor system for purposes of illustration only. One skilled in the art will readily recognize from the following discussion that alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles described herein
- Upon reading this disclosure, those of skill in the art will appreciate still additional alternative structural and functional designs for a system and a process for identifying terminal road segments through the disclosed principles herein. Thus, while particular embodiments and applications have been illustrated and described, it is to be understood that the disclosed embodiments are not limited to the precise construction and components disclosed herein. Various modifications, changes and variations, which will be apparent to those skilled in the art, may be made in the arrangement, operation and details of the method and apparatus disclosed herein without departing from the spirit and scope defined in the appended claims.
Claims (20)
Priority Applications (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/190,599 US9268665B2 (en) | 2011-07-26 | 2011-07-26 | System and method for identifying fault prone computer code files |
PCT/US2012/046949 WO2013016054A1 (en) | 2011-07-26 | 2012-07-16 | A system and method for identifying fault prone computer code files |
EP12816912.5A EP2737406B1 (en) | 2011-07-26 | 2012-07-16 | A system and method for identifying fault prone computer code files |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/190,599 US9268665B2 (en) | 2011-07-26 | 2011-07-26 | System and method for identifying fault prone computer code files |
Publications (2)
Publication Number | Publication Date |
---|---|
US20130031423A1 true US20130031423A1 (en) | 2013-01-31 |
US9268665B2 US9268665B2 (en) | 2016-02-23 |
Family
ID=47598282
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US13/190,599 Active 2032-12-14 US9268665B2 (en) | 2011-07-26 | 2011-07-26 | System and method for identifying fault prone computer code files |
Country Status (3)
Country | Link |
---|---|
US (1) | US9268665B2 (en) |
EP (1) | EP2737406B1 (en) |
WO (1) | WO2013016054A1 (en) |
Cited By (19)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20150074651A1 (en) * | 2013-09-10 | 2015-03-12 | International Business Machines Corporation | Directing verification towards bug-prone portions |
US9043759B1 (en) | 2011-01-27 | 2015-05-26 | Trimble Navigation Limited | System and method for generating software unit tests simultaneously with API documentation |
CN104794137A (en) * | 2014-01-22 | 2015-07-22 | 腾讯科技（深圳）有限公司 | Processing method for ranking records and querying method for ranking and related device and system |
EP2983084A1 (en) * | 2014-08-05 | 2016-02-10 | Alcatel Lucent | Device for ranking software code sections to be reviewed for errors |
US9280442B1 (en) | 2011-01-27 | 2016-03-08 | Trimble Navigation Limited | System and method for generating coverage reports for software unit tests |
US20160203071A1 (en) * | 2013-09-20 | 2016-07-14 | Drexel University | Design rule spaces and architecture root detection |
US20160275402A1 (en) * | 2013-10-31 | 2016-09-22 | Hewlett-Packard Development Company, L.P. | Determining model quality |
US20170220338A1 (en) * | 2012-08-29 | 2017-08-03 | Hewlett Packard Enterprise Development Lp | Identifying a defect density |
CN107480069A (en) * | 2017-08-23 | 2017-12-15 | 厦门大学 | A kind of Ration Assessing Software Dependability method under low demand operator scheme |
US20190163617A1 (en) * | 2017-11-29 | 2019-05-30 | Toyota Jidosha Kabushiki Kaisha | Software quality determination apparatus, software quality determination method, and software quality determination program |
US10430443B2 (en) | 2011-09-02 | 2019-10-01 | Compuverde Ab | Method for data maintenance |
US10452525B2 (en) | 2014-07-06 | 2019-10-22 | International Business Machines Corporation | Utilizing semantic clusters to predict software defects |
US10579615B2 (en) * | 2011-09-02 | 2020-03-03 | Compuverde Ab | Method for data retrieval from a distributed data storage system |
US10650022B2 (en) | 2008-10-24 | 2020-05-12 | Compuverde Ab | Distributed data storage |
US10733084B2 (en) | 2017-12-08 | 2020-08-04 | Google Llc | Early test breakage detection using presubmit runs |
US11068379B2 (en) | 2017-11-29 | 2021-07-20 | Toyota Jidosha Kabushiki Kaisha | Software quality determination apparatus, software quality determination method, and software quality determination program |
US11221908B1 (en) * | 2021-03-02 | 2022-01-11 | International Business Machines Corporation | Discovery of an inexplicit link between a change and an incident in a computing environment |
US11249889B2 (en) * | 2019-01-22 | 2022-02-15 | Salesforce.Com, Inc. | Anomaly feedback monitoring and detection system |
US11720347B1 (en) * | 2019-06-12 | 2023-08-08 | Express Scripts Strategic Development, Inc. | Systems and methods for providing stable deployments to mainframe environments |
Families Citing this family (7)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
WO2014176587A2 (en) | 2013-04-26 | 2014-10-30 | The Trustees Of Columbia University In The City Of New York | Systems and methods for mobile applications |
US10810009B2 (en) * | 2017-07-14 | 2020-10-20 | Microsoft Technology Licensing, Llc | Visualizations of software project and contributor activity |
US10853231B2 (en) * | 2018-12-11 | 2020-12-01 | Sap Se | Detection and correction of coding errors in software development |
US11662997B2 (en) * | 2020-02-20 | 2023-05-30 | Appsurify, Inc. | Systems and methods for software and developer management and evaluation |
CN112328475B (en) * | 2020-10-28 | 2021-11-30 | 南京航空航天大学 | Defect positioning method for multiple suspicious code files |
US11392375B1 (en) | 2021-02-18 | 2022-07-19 | Bank Of America Corporation | Optimizing software codebases using advanced code complexity metrics |
US11816476B2 (en) * | 2021-09-23 | 2023-11-14 | Fidelity Information Services, Llc | Systems and methods for risk awareness using machine learning techniques |
Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20090313605A1 (en) * | 2008-06-11 | 2009-12-17 | At&T Labs, Inc. | Tool for predicting fault-prone software files |
US20110022551A1 (en) * | 2008-01-08 | 2011-01-27 | Mark Dixon | Methods and systems for generating software quality index |
US20110161932A1 (en) * | 2007-04-26 | 2011-06-30 | Microsoft Corporation | Technologies for code failure proneness estimation |
US8225302B2 (en) * | 2003-02-13 | 2012-07-17 | Lawrence Taylor Waugh | System and method for managing source code and acquiring metrics in software development |
Family Cites Families (38)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5805795A (en) | 1996-01-05 | 1998-09-08 | Sun Microsystems, Inc. | Method and computer program product for generating a computer program product test that includes an optimized set of computer program product test cases, and method for selecting same |
US5754860A (en) | 1996-07-23 | 1998-05-19 | Digital Equipment Corporation | Method and apparatus for software testing using a differential testing technique to test compilers |
US6249882B1 (en) | 1998-06-15 | 2001-06-19 | Hewlett-Packard Company | Methods and systems for automated software testing |
US6895578B1 (en) | 1999-01-06 | 2005-05-17 | Parasoft Corporation | Modularizing a computer program for testing and debugging |
US6477683B1 (en) | 1999-02-05 | 2002-11-05 | Tensilica, Inc. | Automated processor generation system for designing a configurable processor and method for the same |
US7334216B2 (en) | 2000-04-04 | 2008-02-19 | Sosy, Inc. | Method and apparatus for automatic generation of information system user interfaces |
US6681383B1 (en) | 2000-04-04 | 2004-01-20 | Sosy, Inc. | Automatic software production system |
US7266808B2 (en) | 2001-08-10 | 2007-09-04 | Parasoft Corporation | Method and system for dynamically invoking and/or checking conditions of a computer test program |
US6934940B2 (en) | 2002-01-30 | 2005-08-23 | International Business Machines Corporation | Source code transformation-temporary object reduction |
US7055067B2 (en) | 2002-02-21 | 2006-05-30 | Siemens Medical Solutions Health Services Corporation | System for creating, storing, and using customizable software test procedures |
CN1679034A (en) | 2002-04-08 | 2005-10-05 | 托普科德公司 | System and method for soliciting proposals for software development services |
JP3779665B2 (en) | 2002-09-25 | 2006-05-31 | 富士通株式会社 | Test support program |
US7296264B2 (en) | 2003-07-18 | 2007-11-13 | Bea Systems, Inc. | System and method for performing code completion in an integrated development environment |
US7246134B1 (en) | 2004-03-04 | 2007-07-17 | Sun Microsystems, Inc. | System and methods for tag library generation |
WO2007068527A1 (en) | 2005-12-15 | 2007-06-21 | International Business Machines Corporation | Method and system for assisting a software developer in creating source code for a computer program |
EP1926021A1 (en) | 2006-11-27 | 2008-05-28 | Sysopen Digia Oyj | Software test case generation |
US7676695B2 (en) | 2007-06-05 | 2010-03-09 | Compuware Corporation | Resolution of computer operations problems using fault trend analysis |
US7681180B2 (en) | 2007-06-06 | 2010-03-16 | Microsoft Corporation | Parameterized test driven development |
US8028276B1 (en) | 2007-06-29 | 2011-09-27 | Oracle America, Inc. | Method and system for generating a test file |
US20090070746A1 (en) | 2007-09-07 | 2009-03-12 | Dinakar Dhurjati | Method for test suite reduction through system call coverage criterion |
US8132154B2 (en) | 2007-10-04 | 2012-03-06 | International Business Machines Corporation | Displaying comment statistics information |
US8365147B2 (en) | 2008-02-27 | 2013-01-29 | Accenture Global Services Limited | Test script transformation architecture |
US8448141B2 (en) * | 2008-03-31 | 2013-05-21 | International Business Machines Corporation | Evaluation of software based on change history |
US20090282136A1 (en) | 2008-05-08 | 2009-11-12 | Oracle International Corporation | Automatic Generation of Web Service client for Web Services Interoperability Testing |
US7814369B2 (en) | 2008-06-12 | 2010-10-12 | Honeywell International Inc. | System and method for detecting combinations of perfomance indicators associated with a root cause |
US8250427B2 (en) | 2008-06-18 | 2012-08-21 | Hewlett-Packard Development Company | Selecting erasure codes for a fault tolerant system |
US8191048B2 (en) | 2008-11-21 | 2012-05-29 | Oracle America, Inc. | Automated testing and qualification of software-based, network service products |
US8239823B2 (en) | 2009-03-20 | 2012-08-07 | Microsoft Corporation | Generating libraries for reflection without project compilation |
US8726254B2 (en) | 2009-06-20 | 2014-05-13 | Microsoft Corporation | Embedded annotation and program analysis |
US8578342B2 (en) | 2009-07-14 | 2013-11-05 | International Business Machines Corporation | Fault detection and localization in dynamic software applications requiring user inputs and persistent states |
US8370811B2 (en) | 2009-07-16 | 2013-02-05 | Accenture Global Services Limited | Modularizing and aspectizing graphical user interface directed test scripts |
US9378015B2 (en) * | 2009-08-11 | 2016-06-28 | Microsoft Technology Licensing, Llc | Predicting defects in code |
KR101132560B1 (en) | 2010-06-09 | 2012-04-03 | 강원대학교산학협력단 | System and method for automatic interface testing based on simulation for robot software components |
US8776010B2 (en) | 2010-10-27 | 2014-07-08 | Microsoft Corporation | Data type provider for a data store |
US8448146B2 (en) | 2011-03-31 | 2013-05-21 | Infosys Limited | Generation of functional tests for re-hosted applications |
US8842123B2 (en) | 2011-10-26 | 2014-09-23 | Google Inc. | Automatically testing a program executable on a graphics card |
EP2783284B1 (en) | 2011-11-22 | 2019-03-13 | Solano Labs, Inc. | System of distributed software quality improvement |
RU2012127578A (en) | 2012-07-02 | 2014-01-10 | ЭлЭсАй Корпорейшн | ANALYZER OF APPLICABILITY OF THE SOFTWARE MODULE FOR THE DEVELOPMENT AND TESTING OF THE SOFTWARE FOR MULTIPROCESSOR MEDIA |
-
2011
- 2011-07-26 US US13/190,599 patent/US9268665B2/en active Active
-
2012
- 2012-07-16 EP EP12816912.5A patent/EP2737406B1/en active Active
- 2012-07-16 WO PCT/US2012/046949 patent/WO2013016054A1/en active Application Filing
Patent Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8225302B2 (en) * | 2003-02-13 | 2012-07-17 | Lawrence Taylor Waugh | System and method for managing source code and acquiring metrics in software development |
US20110161932A1 (en) * | 2007-04-26 | 2011-06-30 | Microsoft Corporation | Technologies for code failure proneness estimation |
US20110022551A1 (en) * | 2008-01-08 | 2011-01-27 | Mark Dixon | Methods and systems for generating software quality index |
US20090313605A1 (en) * | 2008-06-11 | 2009-12-17 | At&T Labs, Inc. | Tool for predicting fault-prone software files |
Non-Patent Citations (3)
Title |
---|
Gall et al, "Detection of Logical Coupling Based on Product Release History", 1998, Software Maintenance * |
Hatton, "Reexamining the Fault Density - Component Size Connection", 1997, IEEE Software * |
Marinescu, "Detection Strategies: Metrics-Based Rules for Detecting Design Flaws", 2004, Proceedings of the 20th IEEE International Conference on Software Maintenance * |
Cited By (28)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US11468088B2 (en) | 2008-10-24 | 2022-10-11 | Pure Storage, Inc. | Selection of storage nodes for storage of data |
US10650022B2 (en) | 2008-10-24 | 2020-05-12 | Compuverde Ab | Distributed data storage |
US11907256B2 (en) | 2008-10-24 | 2024-02-20 | Pure Storage, Inc. | Query-based selection of storage nodes |
US9043759B1 (en) | 2011-01-27 | 2015-05-26 | Trimble Navigation Limited | System and method for generating software unit tests simultaneously with API documentation |
US9280442B1 (en) | 2011-01-27 | 2016-03-08 | Trimble Navigation Limited | System and method for generating coverage reports for software unit tests |
US11372897B1 (en) | 2011-09-02 | 2022-06-28 | Pure Storage, Inc. | Writing of data to a storage system that implements a virtual file structure on an unstructured storage layer |
US10769177B1 (en) | 2011-09-02 | 2020-09-08 | Pure Storage, Inc. | Virtual file structure for data storage system |
US10430443B2 (en) | 2011-09-02 | 2019-10-01 | Compuverde Ab | Method for data maintenance |
US10579615B2 (en) * | 2011-09-02 | 2020-03-03 | Compuverde Ab | Method for data retrieval from a distributed data storage system |
US10909110B1 (en) | 2011-09-02 | 2021-02-02 | Pure Storage, Inc. | Data retrieval from a distributed data storage system |
US20170220338A1 (en) * | 2012-08-29 | 2017-08-03 | Hewlett Packard Enterprise Development Lp | Identifying a defect density |
US10209984B2 (en) * | 2012-08-29 | 2019-02-19 | Entit Software Llc | Identifying a defect density |
US9389984B2 (en) * | 2013-09-10 | 2016-07-12 | International Business Machines Corporation | Directing verification towards bug-prone portions |
US20150074651A1 (en) * | 2013-09-10 | 2015-03-12 | International Business Machines Corporation | Directing verification towards bug-prone portions |
US20160203071A1 (en) * | 2013-09-20 | 2016-07-14 | Drexel University | Design rule spaces and architecture root detection |
US10204028B2 (en) * | 2013-09-20 | 2019-02-12 | Drexel University | Rule spaces and architecture root detection |
US20160275402A1 (en) * | 2013-10-31 | 2016-09-22 | Hewlett-Packard Development Company, L.P. | Determining model quality |
CN104794137A (en) * | 2014-01-22 | 2015-07-22 | 腾讯科技（深圳）有限公司 | Processing method for ranking records and querying method for ranking and related device and system |
US10452525B2 (en) | 2014-07-06 | 2019-10-22 | International Business Machines Corporation | Utilizing semantic clusters to predict software defects |
EP2983084A1 (en) * | 2014-08-05 | 2016-02-10 | Alcatel Lucent | Device for ranking software code sections to be reviewed for errors |
CN107480069A (en) * | 2017-08-23 | 2017-12-15 | 厦门大学 | A kind of Ration Assessing Software Dependability method under low demand operator scheme |
US10783067B2 (en) * | 2017-11-29 | 2020-09-22 | Toyota Jidosha Kabushiki Kaisha | Software quality determination apparatus, software quality determination method, and software quality determination program |
US11068379B2 (en) | 2017-11-29 | 2021-07-20 | Toyota Jidosha Kabushiki Kaisha | Software quality determination apparatus, software quality determination method, and software quality determination program |
US20190163617A1 (en) * | 2017-11-29 | 2019-05-30 | Toyota Jidosha Kabushiki Kaisha | Software quality determination apparatus, software quality determination method, and software quality determination program |
US10733084B2 (en) | 2017-12-08 | 2020-08-04 | Google Llc | Early test breakage detection using presubmit runs |
US11249889B2 (en) * | 2019-01-22 | 2022-02-15 | Salesforce.Com, Inc. | Anomaly feedback monitoring and detection system |
US11720347B1 (en) * | 2019-06-12 | 2023-08-08 | Express Scripts Strategic Development, Inc. | Systems and methods for providing stable deployments to mainframe environments |
US11221908B1 (en) * | 2021-03-02 | 2022-01-11 | International Business Machines Corporation | Discovery of an inexplicit link between a change and an incident in a computing environment |
Also Published As
Publication number | Publication date |
---|---|
US9268665B2 (en) | 2016-02-23 |
WO2013016054A1 (en) | 2013-01-31 |
EP2737406A4 (en) | 2016-05-11 |
EP2737406B1 (en) | 2019-01-16 |
EP2737406A1 (en) | 2014-06-04 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US9268665B2 (en) | System and method for identifying fault prone computer code files | |
Da Costa et al. | A framework for evaluating the results of the szz approach for identifying bug-introducing changes | |
US8352445B2 (en) | Development environment integration with version history tools | |
Schuler et al. | Covering and uncovering equivalent mutants | |
Ratol et al. | Detecting fragile comments | |
Kagdi et al. | Blending conceptual and evolutionary couplings to support change impact analysis in source code | |
CN105068921B (en) | Android based on App comparative analyses applies the evaluation method of shop confidence level | |
Ferenc et al. | An automatically created novel bug dataset and its validation in bug prediction | |
US8200655B2 (en) | Query-based generation of data records | |
US8972938B2 (en) | Determining functional design/requirements coverage of a computer code | |
US9886369B2 (en) | Dynamic data fabrication for database applications | |
Kirbas et al. | The relationship between evolutionary coupling and defects in large industrial software | |
Hora et al. | Assessing the threat of untracked changes in software evolution | |
Chen et al. | Understanding exception-related bugs in large-scale cloud systems | |
JP7076208B2 (en) | Application test | |
He et al. | A large-scale empirical study on Java library migrations: prevalence, trends, and rationales | |
Li et al. | Dynamic symbolic database application testing. | |
De La Mora et al. | An empirical study of metric-based comparisons of software libraries | |
US9195730B2 (en) | Verifying correctness of a database system via extended access paths | |
Kowalczyk et al. | Configurations in Android testing: they matter | |
Huang et al. | Characterizing and detecting configuration compatibility issues in android apps | |
Kim et al. | Are datasets for information retrieval-based bug localization techniques trustworthy? Impact analysis of bug types on IRBL | |
Vidoni | Understanding roxygen package documentation in R | |
Hindle et al. | Mining challenge 2010: Freebsd, gnome desktop and debian/ubuntu | |
Islam et al. | PyMigBench: A Benchmark for Python Library Migration |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:BARROW, FLINT;NICOLO, SIMONE;SIGNING DATES FROM 20110505 TO 20110622;REEL/FRAME:026647/0848 |
|
AS | Assignment |
Owner name: TRIMBLE NAVIGATION LIMITED, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:GOOGLE INC.;REEL/FRAME:029927/0702Effective date: 20120601 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 4TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1551); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 4 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 8TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1552); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 8 |