US20140241346A1 - Translating network forwarding plane models into target implementation using network primitives - Google Patents
Translating network forwarding plane models into target implementation using network primitives Download PDFInfo
- Publication number
- US20140241346A1 US20140241346A1 US13/775,994 US201313775994A US2014241346A1 US 20140241346 A1 US20140241346 A1 US 20140241346A1 US 201313775994 A US201313775994 A US 201313775994A US 2014241346 A1 US2014241346 A1 US 2014241346A1
- Authority
- US
- United States
- Prior art keywords
- network
- device model
- primitives
- submodel
- medium
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Abandoned
Links
Images
Classifications
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L45/00—Routing or path finding of packets in data switching networks
- H04L45/56—Routing software
Definitions
- information may be sent along a path from a source device to a destination device.
- the source device and the destination device may be, for example personal computers, servers such as email servers, web servers, or file servers, or other electronic devices capable of sending and/or receiving information via the network.
- the information may pass through one or more forwarding devices, such as routers or other electronic devices having the ability to forward the information to another device.
- the intermediate devices may receive the information and use functions, algorithms, data structures, and rules to determine where and how to forward the information so that the information moves towards its intended destination.
- These functions, algorithms, data structures, and rules form the “forwarding plane” of the network.
- the functions, algorithms, data structures, and rules of the forwarding plane may be implemented and/or enforced by one or more forwarding devices in the network.
- a forwarding device may receive a packet on an inbound interface, look up the destination address of the packet, and apply a rule which causes the forwarding device to look up the destination address in a particular routing table.
- the routing table may provide a list of “next destinations” which represent a device to which the packet should be sent.
- the next destination for a particular packet might be, for example, the final destination device or another intermediate forwarding device.
- the next destination may be identified by an address stored in the routing table.
- the next destinations stored in the routing table may be indexed by a final destination of the packet—thus, by looking up the final destination of the packet (e.g., as identified by a header of the packet), the next destination can be retrieved from the routing table.
- the forwarding device may then forward the packet on an outbound interface to the identified next destination.
- Certain aspects of the forwarding plane can affect the efficiency of the network. These aspects include the specific rules, algorithms, data structures, and functions employed, the manner in which the forwarding plane is implemented, and the location at which the forwarding plane is implemented and/or enforced.
- a routing controller in a communication network may be responsible for generating a device model for a target device using a universal language of network primitives.
- the target device may have forwarding capabilities. Exemplary embodiments allow the target device to determine how to forward the incoming data packets based on the intended behavior of the network.
- the target device may translate the desired behavior described using the universal language into implementation based on the capabilities of the target device. The translation may generate a mapping between the desired behaviors and the implementations thereof.
- the universal language is a target-independent description that is used to define the intent of the network, i.e. the intended forwarding behavior.
- the universal language may describe a requested capability (e.g., “find the longest prefix match of a subnet mask in a routing table”) without specifying how to implement the requested capability (e.g., without specifying a particular algorithm for performing a longest prefix match).
- the universal language may support multiple implementations of the specified functionality (e.g., a first algorithm for finding a longest prefix match, and a second algorithm for finding a longest prefix match).
- the device model may be generated using a target-independent universal language of network primitives.
- Network primitives are building blocks of the device model.
- the network primitives can be grouped to form submodels to create modularity within the device model.
- the network primitives and the submodels can be stored in libraries.
- the controller may send the device model to a target device.
- the target device may translate the device model to implementation.
- a non-transitory electronic device readable storage medium is provided.
- the storage medium further holds instructions that, when executed, cause one or more processors to receive a device model described in a target-independent format.
- the device model includes one or more network primitives.
- the device model describes an intended forwarding behavior for a target device.
- the storage medium also holds instructions that, when executed, cause one or more processors to translate the device model to the one or more capabilities of the target device, the target device having a forwarding capability.
- the translating includes mapping the one or more network primitives to the one or more capabilities of the target device.
- the storage medium further holds instructions that, when executed, cause one or more processors to configure the target device based on the translating and receive one or more input packets.
- the storage medium also holds instructions that, when executed, cause one or more processors to forward one or more input packets to one or more elements of the network based on the configuring.
- a non-transitory electronic device readable storage medium further holds instructions that, when executed, cause one or more processors to generate a device model in a target-independent format.
- the device model includes one or more network primitives.
- the device model describes an intended forwarding behavior for a target device.
- the storage medium also further holds instructions that, when executed, cause one or more processors to send the device model to the target device in the network for implementation, the target device having a forwarding capability.
- a system comprising a routing controller, a target device and a storage.
- the routing controller generates a device model described in a target-independent format.
- the device model includes one or more network primitives.
- the target device receives the device model.
- the device model describes an intended forwarding behavior for the target device.
- the target device has a forwarding or switching capability.
- the storage stores a plurality of network primitives.
- the device model is generated using the one or more network primitives retrieved from the storage.
- the target device is configured to map the intended forwarding behavior described in the device model to the implementation of the one or more capabilities of the target device.
- FIG. 1 depicts an exemplary network 100 including a routing controller and a target device according to an exemplary embodiment.
- FIG. 2 depicts an exemplary manner how elements of the exemplary network 100 interact according to an exemplary embodiment.
- FIG. 3 depicts an exemplary device model generated by a controller according to an exemplary embodiment.
- FIG. 4 is a flowchart describing exemplary steps performed by a controller in accordance with an exemplary embodiment.
- FIG. 5 is a flowchart describing exemplary steps performed by a target device in accordance with an exemplary embodiment.
- FIG. 6 depicts an exemplary electronic device suitable for use with exemplary embodiments described herein.
- FIG. 7 depicts an exemplary network implementation of processing performed according to an exemplary embodiment.
- exemplary embodiments allow abstracting of the forwarding plane of a software defined network.
- the abstraction of setting forwarding table entries loses too much information about the intents of the application developer.
- conventional techniques cannot leverage all the features of the forwarding device to deliver scalable and efficient end-to-end implementations.
- the present application aims at mapping high-level forwarding intents to low-level features of the forwarding device by translating a device model at the forwarding device.
- a routing controller in the network may be responsible for generating a device model using a universal language of network primitives.
- the device model may define the intent of the network, i.e. the intended forwarding behavior.
- the controller may send the device model to a target device.
- the target device translates the desired behavior described in the device model into an implementation based on the capabilities of the target device.
- the target device may include predetermined hardware or software logic for implementing the desired behavior defined in the device model. Accordingly, the target device may implement a requested capability defined in the device model without receiving instructions prescribing how to implement the requested capability.
- FIG. 1 depicts an exemplary network 100 including a routing controller 110 and a target device 120 according to an exemplary embodiment.
- the controller 110 may include a processor, a server or other device implemented in hardware, software or a combination thereof.
- the network 100 may be a communications network such as the Internet, an intranet, or a telephone network, among other possibilities.
- the network 100 may include one or more optical, electronic, or other transmission mediums.
- the controller 110 of the network 100 may be in communication with the target device 120 .
- the controller 110 may be connected to the target device 120 directly or indirectly.
- the network 100 is for explanatory purposes only, and a network suitable for use with the exemplary embodiments described herein may have other elements or capabilities.
- the controller may generate a plurality of device models according to various embodiments.
- the target device 120 may have forwarding functionality such that the target device 120 is capable of receiving incoming information on an inbound interface, processing the information to determine a next destination of the information, and forwarding the information to the next destination on an outbound interface.
- the controller 110 may generate a first device model 112 using a universal language.
- the device model 112 may define the intent of the network 100 (e.g., the intended forwarding behavior within the network 100 ) using the universal language.
- the device model 112 may describe a desired behavior of a node of the network 100 under certain conditions, such as upon the receipt of an incoming packet.
- the universal language is a target-independent language that can be interpreted by all recipient devices.
- the universal language may be formed of building blocks called “network primitives”.
- the device model 112 may include one or more network primitives 114 .
- a network primitive 114 is a basic unit of functionality to be implemented by elements of the network 100 .
- a network primitive 114 may be, for example, a description of a particular functionality to be used in the network 100 .
- a network primitive 114 may describe what actions elements of the network 100 are meant to perform, but typically will not include requirements for how those actions are to be carried out. Thus, a network primitive 114 may describe a desired outcome without providing implementation details for achieving the outcome.
- the implementation details may be left to the particular device implementing the network primitive 114 , or may be specified by an external device.
- the device model 112 may be constructed as a collection of one or more network primitives 114 . A same network primitive may appear multiple times in a given device model.
- a network primitive 114 related to queuing may specify that a recipient device of the device model 112 is to implement flat queuing, hierarchical queuing, buffer resource sharing, dynamic buffer sizing, tail drop queue management or weighted tail drop queue management.
- Scheduling primitives may specify that scheduling should be in a round robin fashion, as a weighted round robin, low latency queuing or strict priority queuing, weighted fair queuing, or class-based weighted fair queuing.
- Metering primitives may make use of one rate two color (1R2C) IP packet marking, 1R3C marking, or 2R3C marking. Numerous other networking primitives may also be utilized. The details of the implementations of these networking primitives may be unspecified and left up to the device that implements the primitives.
- network primitives can pass information between themselves.
- a network primitive may produce information for another network primitive to consume.
- the information that is exchanged between the primitives may be assigned a name.
- the named information may be referred as a handle. Naming the information allows the information to be referred to symbolically. Naming the information further improves the readability of the device model.
- the information may also be typed, i.e. one or more attributes, such as the size of the information, may be associated with the information.
- the network primitives may include core network primitives and control network primitives.
- the core network primitives may describe an independent thread of data path functionality.
- a core network primitive may describe packet forwarding.
- the core primitives may be used to build a device model for network elements including but not limited to a switch, router, load balancer, flow device.
- the core primitives may be used to represent fragmentation, reassembly, cryptographic processing, etc.
- the control network primitives may describe administrative functionality such as the interaction between the independent threads, event handling, exception handling, etc.
- Exemplary core network primitives may include the parse primitives, the table primitives, the logic primitive, the arithmetic primitive, the packet replicate primitive, the rewrite primitives, the meter primitive, the queue primitive, the scheduler primitive, the discard primitive, the counter primitive and the external primitive.
- the parse primitives may define the constraints and the information extracted from a packet header field of an input packet. According to various embodiments, the parse primitives may not be required to describe deep packet inspection on unstructured packet content.
- the parse primitives may include a parse header order sub-primitive that may be used to describe an acceptable parse graph.
- a header may be defined as a contiguous set of bytes from the input packet from which one or more pieces of information (fields) can be extracted in without performing a lookup operation for determining the next header.
- the parse header order primitive may take one or more arguments. For example, the header order primitive may take current parse anchor as an argument. The current parse anchor may determine where in the packet the parsing should start.
- the header order primitive may also take well known header name/ID as an argument. This argument represents a name or ID assigned to the header.
- the header handle ID argument may represent a handle assigned to the header for reference in the device model.
- the next parse anchor argument represents an anchor referring to the location of the payload of the header or sub header after the particular header has been parsed successfully.
- the header order primitive may also take header parse status handle as an argument.
- the argument defines the handle which refers to a Boolean and captures the parsing status. The argument is set to TRUE in case the header was present and was valid. Otherwise, the argument is set to FALSE.
- the header parse status may be an optional argument and can be skipped if the model writer has no interest in looking at the parse status.
- the table primitives include a table definition primitive that may provide the typing and other miscellaneous information about a data store, i.e. a table.
- the typing information and constraints associated with the data store allows the consumer of the device model, e.g. the target device, to verify that the forwarding plane instantiation meets the requirements.
- the typing information and constraints associated with the data store may also allow the forwarding plane to perform one or more optimizations in implementing the data store.
- the table definition primitive may take one or more arguments such as the table type indicating whether the table includes an array, a tree, a set or a list.
- the arguments may also include an argument indicating whether table sharing is enabled, the table size, the table size tolerance, the table key definition list, the mask associated with each key list, the table result definition and the table handle (table ID/name).
- the table primitives may also include the table operation sub-primitive that may describe the forwarding plane actions that are taken on the data store defined by the table definition primitive.
- the table match sub-primitive describes a match or a search operation on the table.
- the table insert sub-primitive describes the data store insert operation performed by the data plane.
- the logic primitive may allow the device model to express simple boolean logic or conditional operations that are used in forwarding the input packets.
- Logic operators may take handles as input and may produce output handles with the result of the logic operation.
- the logic primitives may support operations like integer comparisons including greater than operation, less than operation, equal to operation, Boolean logic operations like and operation, or operation, not operation, etc.
- the logic primitive may take one or more arguments including an ordered input handle that become the operands. The order and semantics of the operands are defined by the arithmetic operation.
- the logic primitive may also take output handle as an argument. The output handle may store the results of the operation performed by the logic primitive.
- Exemplary control network primitives may include the scope primitive, the event handler primitive, the semaphore primitive, the event primitive and the raise primitive. Some of these exemplary core primitives are discussed below.
- the Scope primitive may allow the device model writer to indicate an order of operations to be performed in a set of primitives.
- a scope primitive may be used in connection with the logic primitive to define an order of logic operations to be performed.
- the event handler primitive may bind an event to a collection of cooperative primitives representing some defined functionality.
- the collection of primitives with a defined functionality may be given a ‘name’.
- the event handler may bind a named event to a named collection of primitives.
- a semaphore primitive may allow the model writer to describe mutual exclusion, critical sections, etc. within the device model.
- the semaphore primitive may allow for more than one primitive collection to access a resource.
- the semaphore primitive may also be used to allow for multiple individual primitive collections to access different instances of a shared resource safely if available.
- a raise primitive may be used to raise an exception.
- the raise primitive may be used to define how processing should proceed when a certain exception condition is encountered.
- the raise primitive may have two modes: a first mode which asks that processing of the packet be stopped and exception be taken, and a second mode which allows the main processing to continue and the exception is also taken.
- One or more network primitives 114 may be grouped together to form a submodel 118 .
- the submodel 118 may represent a desired functionality within the device model 112 .
- Submodels promote modularity within a given device model. As discussed in greater detail below, a plurality of submodels may be stored in a submodel library. The controller 110 may retrieve the desired submodel from the submodel library and use the retrieved submodel in a device model. Similarly, if the controller 110 generates a new submodel by grouping one or more network primitives, the controller 110 may store the new submodel in the submodel library.
- One of ordinary skill in the art will appreciate that the use of submodels in a device model is optional. A device model may be generated without using any submodels. However, the submodels promote modularity and allow for a user-friendly visualization of the device model.
- the device model 112 generated by the controller 110 may specify all the routing/forwarding functionality within the network 100 .
- the controller 110 may generate a plurality of device models. For example, the controller 110 may generate a first device model 112 to be used under certain circumstances, such as periods of high or low network traffic or upon the receipt of certain types of packets.
- the controller 110 may generate a second device model 112 ′ formed of network primitives 114 ′ where the second device model 112 ′ may be used under other circumstances.
- a network administrator may cause the network 100 to exhibit different network forwarding behaviors.
- the controller 110 may send the generated device model 112 and/or 112 ′ to the target device 120 .
- the device model 112 and/or 112 ′ may represent a complete set of functionality required of the target device 120 .
- the target device 120 may interpret the information contained in the device model 112 and/or 112 ′ within constraints known to the target device 120 .
- the target device 120 may translate the intended behavior described in the device model 112 and/or 112 ′ into implementation.
- the target device 120 may include a translator 126 provided at a hardware abstraction layer (HAL) 122 of the target device 120 .
- HAL hardware abstraction layer
- the translator 126 may translate the target-independent device model 112 and/or 112 ′ into implementation on the target device 120 based on the capabilities of, for example, the application specific integrated circuit (ASIC) 124 of the target device 120 .
- the translator 126 may generate a mapping 128 between elements of the device model 112 and/or 112 ′ and the capabilities of the target device 120 , more specifically the ASIC 124 of the target device 120 .
- the mapping 128 may map one or more network elements of the device model 112 to an exemplary implementation such as queuing an incoming packet or discarding an incoming packet. Accordingly, high-level generic desired forwarding behaviors may be mapped to low-level ASIC features.
- the HAL 122 may continue to service the control messages from the controller 110 .
- the HAL 122 may continue to run the control messages through the mapping and send the control messages to the target device 120 .
- the HAL 122 may keep the local state to continue communicating with the target device 120 .
- FIG. 2 depicts how elements of the exemplary network 100 may interact according to an exemplary embodiment.
- the controller 202 provided in a network 200 may generate a device model 204 .
- the device model 204 may be formed of one or more network primitives.
- the network primitives may be stored in a network primitive library 206 .
- the controller 202 may access network primitive library 206 to retrieve one or more network primitives.
- the controller 202 may insert the retrieved one or more network primitives in the device model 204 .
- the network primitive library 206 may be extensible. That is, new network primitives may be added to the network primitive library 206 .
- one or more network primitives may be grouped to form a submodel.
- the generated submodels may be stored in a submodel library 208 .
- the submodel library 208 may also include submodels generated by other users or controllers in other networks.
- the submodel library 208 may be accessible by a plurality of controllers in a plurality of networks.
- the controller 202 may access the submodel library 208 to retrieve one or more submodels.
- the controller 202 may insert the retrieved one or more submodels in the device model 204 .
- the submodel library 208 is also extensible. That is, new submodels may be added to the submodel library 206 . For example, if the controller 202 generates a new submodel by grouping one or more network primitives, the controller 202 may add the new submodel to the submodel library 208 .
- the controller 202 may send the generated device model 204 to a target device 250 .
- the target device 250 translates the device model 202 into an implantation. More specifically, the translator 210 of the target device 250 may generate a mapping that maps the components of the device model 202 to the capabilities of the target device 250 .
- the intended behavior described in the device model 202 is passed to implementation 214 on the target device.
- the translator 210 located at the target device 250 , is familiar with the capabilities of the target device 250 . Thus, the translator 210 is best suited for translating the device model 202 into the implementation.
- FIG. 3 depicts an exemplary device model 300 generated by a controller according to an exemplary embodiment.
- the device model 300 is provided as a unified modeling language (UML) activity diagram. It is understood that UML activity diagram is used for illustrative purposed and that the device model 300 may be provided using other graphical and/or textual modeling languages.
- the device model 300 illustrates a representation of the network behavior for implementing a media access control (MAC) bridge.
- the device model 300 includes a plurality of network primitives 302 - 318 .
- the ASIC of the target device is given the specific behavior expected of the network for an efficient implementation by the target device.
- the device model 300 may also be expressed using textual code, such as a pseudo code.
- textual code such as a pseudo code.
- a portion of an exemplary pseudo code representing the device model 300 is provided below.
- the pseudo code is provided for exemplary purposes and should not be construed as limiting.
- the pseudo code may have an entry for the network primitives of the device model 300 .
- the portion of the pseudo code provided above has an entry for table definition network primitive 306 , the tableops_match network primitive 304 , the tableops_modify network primitive 308 and the tableops_insert network primitive 310 .
- the exemplary pseudo code provided above represents a partial implementation of a learning MAC bridge.
- a MAC table is defined. A first match is run on the MAC table when the virtual local area network (VLAN) ID (i.e. vlanid) and MAC destination address (i.e. macdestaddr) are known. The result of the first match is output as an output packet.
- VLAN virtual local area network
- MAC destination address i.e. macdestaddr
- a second match may run in parallel with the first match once the input port, VLAN and MAC source address are determined.
- the second match may run to ensure that the source MAC is associated with the source port. If it is determined that the source MAC is not associated with the source port, the second match may produce a flag. Setting the flag may cause the conditional to execute regardless of the state of the flag. Upon setting the flag and execution of the conditional, the source address that was not associated with the source port, becomes associated with the source port.
- the target device upon receiving the device model 300 in the graphical format or in the pseudo code format, translates the device model 300 into an implementation.
- the translation of the exemplary device model 300 in the implementation of a MAC bridge will allow communications between one or more end stations coupled to the target device in the network.
- the intended behavior represented in the device model 300 allows the interconnection of one or more end stations as if they were attached to a single local area network (LAN), even if the one or more end satiations are attached to separate LANs.
- the translation may be implemented as a set of mappings to the existing tables in a forwarding ASIC.
- the configuration of one or more registers on the ASIC may be modified to indicate that the tables should be treated in a manner consistent with the intended behavior.
- the translation may be adapted to accommodate the capabilities of a destination ASIC that is designed to perform complex tasks or to accommodate the capabilities of a destination software.
- the controller may send the device model to the target device for implementation.
- the controller may send the device model in the graphical format and/or in a textual format such as a pseudo code. Both the graphical format and the pseudo code include one or more network primitives generated in a target-independent universal language. The steps performed by the controller and the target device are discussed below.
- FIG. 4 is a flowchart describing exemplary steps performed by a controller in accordance with an exemplary embodiment.
- the controller may generate a device model in a target-independent format (step 402 ).
- the device model may describe the intended forwarding behavior for the target device.
- the intended forwarding behavior may be a high-level indication of the intent of the developer.
- the controller may send the generated device model to the target device for implementation (step 404 ).
- FIG. 5 is a flowchart describing exemplary steps performed by a target device in accordance with an exemplary embodiment.
- the target device receives the device model generated by the controller (step 502 ).
- the device model may be described in target-independent format.
- the target device may translate the device model into an implementation based on the capabilities of the target device (step 504 ).
- the target device may be configured based on the translating (step 506 ).
- the target device may forward the received input packets to one or more elements of the network based on the configuring (step 510 ).
- FIG. 6 depicts an example of an electronic device 600 that may be suitable for use with one or more acts disclosed herein.
- the electronic device 600 may take many forms, including but not limited to a computer, workstation, server, network computer, quantum computer, optical computer, Internet appliance, mobile device, a pager, a tablet computer, a smart sensor, application specific processing device, etc.
- the electronic device 600 is illustrative and may take other forms.
- an alternative implementation of the electronic device 600 may have fewer components, more components, or components that are in a configuration that differs from the configuration of FIG. 6 .
- the components of FIG. 6 and/or other figures described herein may be implemented using hardware based logic, software based logic and/or logic that is a combination of hardware and software based logic (e.g., hybrid logic); therefore, components illustrated in FIG. 6 and/or other figures are not limited to a specific type of logic.
- the processor 602 may include hardware based logic or a combination of hardware based logic and software to execute instructions on behalf of the electronic device 600 .
- the processor 602 may include logic that may interpret, execute, and/or otherwise process information contained in, for example, the memory 604 .
- the information may include computer-executable instructions and/or data that may implement one or more embodiments of the invention.
- the processor 602 may comprise a variety of homogeneous or heterogeneous hardware.
- the hardware may include, for example, some combination of one or more processors, microprocessors, field programmable gate arrays (FPGAs), application specific instruction set processors (ASIPs), application specific integrated circuits (ASICs), complex programmable logic devices (CPLDs), graphics processing units (GPUs), or other types of processing logic that may interpret, execute, manipulate, and/or otherwise process the information.
- the processor may include a single core or multiple cores 603 .
- the processor 602 may include a system-on-chip (SoC) or system-in-package (SiP).
- the electronic device 600 may include one or more tangible non-transitory computer-readable storage media for storing one or more computer-executable instructions or software that may implement one or more embodiments of the invention.
- the non-transitory computer-readable storage media may be, for example, the memory 604 or the storage 618 .
- the memory 604 may comprise a ternary content addressable memory (TCAM) and/or one or more of a RAM that may include RAM devices, a content addressable memory (CAM) or a ternary content addressable memory (TCAM) for storing the information.
- TCAM ternary content addressable memory
- CAM content addressable memory
- TCAM ternary content addressable memory
- the RAM devices may be volatile or non-volatile and may include, for example, one or more DRAM devices, flash memory devices, SRAM devices, zero-capacitor RAM (ZRAM) devices, twin transistor RAM (TTRAM) devices, read-only memory (ROM) devices, ferroelectric RAM (FeRAM) devices, magneto-resistive RAM (MRAM) devices, phase change memory RAM (PRAM) devices, or other types of RAM devices.
- DRAM dynamic random access memory
- SRAM zero-capacitor RAM
- ZRAM twin transistor RAM
- ROM read-only memory
- FeRAM ferroelectric RAM
- MRAM magneto-resistive RAM
- PRAM phase change memory RAM
- One or more computing devices 600 may include a virtual machine (VM) 605 for executing the instructions loaded in the memory 604 .
- VM virtual machine
- a virtual machine 605 may be provided to handle a process running on multiple processors so that the process may appear to be using only one computing resource rather than multiple computing resources. Virtualization may be employed in the electronic device 600 so that infrastructure and resources in the electronic device may be shared dynamically. Multiple VMs 605 may be resident on a single computing device 600 .
- a hardware accelerator 606 may be implemented in an ASIC, FPGA, or some other device.
- the hardware accelerator 606 may be used to reduce the general processing time of the electronic device 600 .
- the electronic device 600 may include a network interface 608 to interface to a Local Area Network (LAN), Wide Area Network (WAN) or the Internet through a variety of connections including, but not limited to, standard telephone lines, LAN or WAN links (e.g., T1, T3, 56 kb, X.25), broadband connections (e.g., integrated services digital network (ISDN), Frame Relay, asynchronous transfer mode (ATM), wireless connections (e.g., 802.11), high-speed interconnects (e.g., InfiniBand, gigabit Ethernet, Myrinet) or some combination of any or all of the above.
- LAN Local Area Network
- WAN Wide Area Network
- the Internet may include a network interface 608 to interface to a Local Area Network (LAN), Wide Area Network (WAN) or the Internet through a variety of connections including, but not limited to, standard telephone lines, LAN or WAN links (e.g., T1, T3, 56 kb, X.25), broadband connections (e.g., integrated services digital network
- the network interface 608 may include a built-in network adapter, network interface card, personal computer memory card international association (PCMCIA) network card, card bus network adapter, wireless network adapter, universal serial bus (USB) network adapter, modem or any other device suitable for interfacing the electronic device 600 to any type of network capable of communication and performing the operations described herein.
- PCMCIA personal computer memory card international association
- USB universal serial bus
- the electronic device 600 may include one or more input devices 610 , such as a keyboard, a multi-point touch interface, a pointing device (e.g., a mouse), a gyroscope, an accelerometer, a haptic device, a tactile device, a neural device, a microphone, or a camera that may be used to receive input from, for example, a user.
- input devices 610 such as a keyboard, a multi-point touch interface, a pointing device (e.g., a mouse), a gyroscope, an accelerometer, a haptic device, a tactile device, a neural device, a microphone, or a camera that may be used to receive input from, for example, a user.
- input devices 610 such as a keyboard, a multi-point touch interface, a pointing device (e.g., a mouse), a gyroscope, an accelerometer, a haptic device, a tactile device, a neural device, a
- the input devices 610 may allow a user to provide input that is registered on a visual display device 614 .
- a graphical user interface (GUI) 616 may be shown on the display device 614 .
- a storage device 618 may also be associated with the computer 600 .
- the storage device 618 may be accessible to the processor 602 via an I/O bus.
- the information may be executed, interpreted, manipulated, and/or otherwise processed by the processor 602 .
- the storage device 618 may include, for example, a storage device, such as a magnetic disk, optical disk (e.g., CD-ROM, DVD player), random-access memory (RAM) disk, tape unit, and/or flash drive.
- the information may be stored on one or more non-transient tangible computer-readable media contained in the storage device.
- This media may include, for example, magnetic discs, optical discs, magnetic tape, and/or memory devices (e.g., flash memory devices, static RAM (SRAM) devices, dynamic RAM (DRAM) devices, or other memory devices).
- memory devices e.g., flash memory devices, static RAM (SRAM) devices, dynamic RAM (DRAM) devices, or other memory devices.
- the information may include data and/or computer-executable instructions that may implement one or more embodiments of the invention.
- the storage device 618 may further store applications 624 , and the electronic device 600 can be running an operating system (OS) 626 .
- OS 626 may include the Microsoft® Windows® operating systems, the Unix and Linux operating systems, the MacOS® for Macintosh computers, an embedded operating system, such as the Symbian OS, a real-time operating system, an open source operating system, a proprietary operating system, operating systems for mobile electronic devices, or other operating system capable of running on the electronic device and performing the operations described herein.
- the operating system may be running in native mode or emulated mode.
- the storage device 618 may further include rules 628 which describe how messages should be forwarded in a communications network.
- the rules 628 may be used to forward messages or information received at the electronic device 628 .
- the electronic device 600 may serve as a forwarding device, switch, or router.
- the storage device 618 may store an implementation database 630 .
- the implementation database 630 may be a data structure, such as a table or matrix, which stores identifiers identifying predetermined functions that are implemented by the electronic device 630 .
- the implementation database may further store the implementation details of the predetermined functions.
- the storage device 618 may further include logic for implementing a communications protocol 640 .
- the communications protocol 640 may be a protocol which provides an interface for accessing and modifying the functionality of the forwarding plane of the electronic device 600 .
- Exemplary communications protocols 640 include, but are not limited to, the OpenFlow protocol (see, e.g., McKeown, Nick et al., “OpenFlow: Enabling Innovation in Campus Networks,” ACM SIGCOMM Computer Communication Review Archive, vol. 38 issue 2, pp. 69-74 (April 2008), the contents of which are incorporated herein by reference) or custom communications protocols.
- the electronic device 600 may serve as a remote controller, such as the controller 110 described above with respect to FIG. 1 .
- the communications protocol 640 may allow the details of the forwarding plane implemented by the electronic device 600 to be defined and/or modified. Accordingly, the communications protocol 640 allows a communications network to be made programmable.
- the communications protocol 640 may support the use of one or more device models 642 to implement the functionality of the forwarding plane.
- a device model 642 may represent the complete set of network routing functionality to be implemented by the electronic device 640 .
- the device model 642 may define the functionality and performance of the forwarding plane.
- the device model 642 may include one or more network primitives.
- a network primitive is a basic unit of functionality to be implemented by the electronic device 600 .
- a network primitive may be, for example, a description of a particular functionality to be used in the communications network.
- a network primitive may describe what actions the electronic device 600 is meant to perform, but typically will not include requirements for how those actions are to be carried out.
- a network primitive may describe a desired outcome without providing implementation details for achieving the outcome. The implementation details may be left to the particular device implementing the network primitive, or may be specified by an external device.
- a network primitive related to queuing may specify that the electronic device 600 (acting as a forwarding device) is to implement flat queuing, hierarchical queuing, buffer resource sharing, dynamic buffer sizing, tail drop queue management, weighted tail drop queue management, or queue high and low watermarks.
- Scheduling primitives may specify that scheduling should be in a round robin fashion, as a weighted round robin, low latency queuing or strict priority queuing, weighted fair queuing, or class-based weighted fair queuing.
- Metering primitives may make use of one rate two color (1R2C) IP packet marking, 1R3C marking, or 2R3C marking. Numerous other network primitives may also be utilized. The details of the implementations of these network primitives may be unspecified and left up to the device that implements the primitives.
- a device model 642 may be constructed as a collection of one or more network primitives.
- one device model 642 might specify that the electronic device 600 is to use flat queuing with round robin scheduling.
- One or more device models 642 may specify all the network routing/forwarding functionality of the electronic device 600 .
- a first device model 642 may be used under certain circumstances, such as periods of high or low network traffic or upon the receipt of certain types of packets, and that a second device model 642 may be used under other circumstances.
- a network administrator may cause the electronic device 600 to exhibit different network forwarding behaviors.
- the communications protocol 640 may reference a device model 642 and implement the functionality defined by the device model 642 using the functionality defined by the implementation database 630 .
- the communications protocol 640 may use default or generic implementations stored locally with the communications protocol 640 or provided from a remote location, such as a remote controller.
- One or more embodiments of the invention may be implemented using computer-executable instructions and/or data that may be embodied on one or more non-transitory tangible computer-readable mediums.
- the mediums may be, but are not limited to, a hard disk, a compact disc, a digital versatile disc, a flash memory card, a Programmable Read Only Memory (PROM), a Random Access Memory (RAM), a Read Only Memory (ROM), Magnetoresistive Random Access Memory (MRAM), a magnetic tape, or other computer-readable media.
- FIG. 7 depicts a network implementation that may implement one or more embodiments of the invention.
- a system 700 may include a computing device 600 , a network 712 , a service provider 713 , a target environment 714 , and a cluster 715 .
- the embodiment of FIG. 7 is exemplary, and other embodiments can include more devices, fewer devices, or devices in arrangements that differ from the arrangement of FIG. 7 .
- the network 712 may transport data from a source to a destination.
- Embodiments of the network 712 may use network devices, such as routers, switches, firewalls, and/or servers (not shown) and connections (e.g., links) to transport data.
- Data may refer to any type of machine-readable information having substantially any format that may be adapted for use in one or more networks and/or with one or more devices (e.g., the computing device 600 , the service provider 713 , etc.).
- Data may include digital information or analog information. Data may further be packetized and/or non-packetized.
- the network 712 may be a hardwired network using wired conductors and/or optical fibers and/or may be a wireless network using free-space optical, radio frequency (RF), and/or acoustic transmission paths.
- the network 712 may be a substantially open public network, such as the Internet.
- the network 712 may be a more restricted network, such as a corporate virtual network.
- the network 712 may include Internet, intranet, Local Area Network (LAN), Wide Area Network (WAN), Metropolitan Area Network (MAN), wireless network (e.g., using IEEE 802.11), or other type of network
- the network 712 may use middleware, such as Common Object Request Broker Architecture (CORBA) or Distributed Component Object Model (DCOM). Implementations of networks and/or devices operating on networks described herein are not limited to, for example, any particular data type, protocol, and/or architecture/configuration.
- CORBA Common Object Request Broker Architecture
- DCOM Distributed Component Object Model
- the service provider 713 may include a device that makes a service available to another device.
- the service provider 713 may include an entity (e.g., an individual, a corporation, an educational institution, a government agency, etc.) that provides one or more services to a destination using a server and/or other devices.
- Services may include instructions that are executed by a destination to perform an operation (e.g., an optimization operation).
- a service may include instructions that are executed on behalf of a destination to perform an operation on the destination's behalf.
- the server 714 may include a device that receives information over the network 712 .
- the server 714 may be a device that receives user input from the computer 600 .
- the cluster 715 may include a number of units of execution (UEs) 716 and may perform processing on behalf of the computer 500 and/or another device, such as the service provider 713 or server 714 .
- the cluster 715 may perform parallel processing on an operation received from the computer 600 .
- the cluster 715 may include UEs 716 that reside on a single device or chip or that reside on a number of devices or chips.
- the units of execution (UEs) 716 may include processing devices that perform operations on behalf of a device, such as a requesting device.
- a UE may be a microprocessor, field programmable gate array (FPGA), and/or another type of processing device.
- UE 716 may include code, such as code for an operating environment. For example, a UE may run a portion of an operating environment that pertains to parallel processing activities.
- the service provider 713 may operate the cluster 715 and may provide interactive optimization capabilities to the computer 500 on a subscription basis (e.g., via a web service).
- a hardware unit of execution may include a device (e.g., a hardware resource) that may perform and/or participate in parallel programming activities.
- a hardware unit of execution may perform and/or participate in parallel programming activities in response to a request and/or a task it has received (e.g., received directly or via a proxy).
- a hardware unit of execution may perform and/or participate in substantially any type of parallel programming (e.g., task, data, stream processing, etc.) using one or more devices.
- a hardware unit of execution may include a single processing device that includes multiple cores or a number of processors.
- a hardware unit of execution may also be a programmable device, such as a field programmable gate array (FPGA), an application specific integrated circuit (ASIC), a digital signal processor (DSP), or other programmable device.
- FPGA field programmable gate array
- ASIC application specific integrated circuit
- DSP digital signal processor
- Devices used in a hardware unit of execution may be arranged in many different configurations (or topologies), such as a grid, ring, star, or other configuration.
- a hardware unit of execution may support one or more threads (or processes) when performing processing operations.
- a software unit of execution may include a software resource (e.g., a technical computing environment) that may perform and/or participate in one or more parallel programming activities.
- a software unit of execution may perform and/or participate in one or more parallel programming activities in response to a receipt of a program and/or one or more portions of the program.
- a software unit of execution may perform and/or participate in different types of parallel programming using one or more hardware units of execution.
- a software unit of execution may support one or more threads and/or processes when performing processing operations.
- parallel programming may be understood to include multiple types of parallel programming, e.g. task parallel programming, data parallel programming, and stream parallel programming.
- Parallel programming may include various types of processing that may be distributed across multiple resources (e.g., software units of execution, hardware units of execution, processors, microprocessors, clusters, labs) and may be performed at the same time.
- parallel programming may include task parallel programming where a number of tasks may be processed at the same time on a number of software units of execution.
- task parallel programming a task may be processed independently of other tasks executing, for example, at the same time.
- Parallel programming may include data parallel programming, where data (e.g., a data set) may be parsed into a number of portions that may be executed in parallel using, for example, software units of execution.
- data parallel programming the software units of execution and/or the data portions may communicate with each other as processing progresses.
- Parallel programming may include stream parallel programming (sometimes referred to as pipeline parallel programming).
- Stream parallel programming may use a number of software units of execution arranged, for example, in series (e.g., a line) where a first software unit of execution may produce a first result that may be fed to a second software unit of execution that may produce a second result given the first result.
- Stream parallel programming may also include a state where task allocation may be expressed in a directed acyclic graph (DAG) or a cyclic graph.
- DAG directed acyclic graph
- Other parallel programming techniques may involve some combination of task, data, and/or stream parallel programming techniques alone or with other types of processing techniques to form hybrid-parallel programming techniques.
- one or more implementations consistent with principles of the invention may be implemented using one or more devices and/or configurations other than those illustrated in the Figures and described in the Specification without departing from the spirit of the invention.
- One or more devices and/or components may be added and/or removed from the implementations of the figures depending on specific deployments and/or applications.
- one or more disclosed implementations may not be limited to a specific combination of hardware.
- logic may perform one or more functions.
- This logic may include hardware, such as hardwired logic, an application-specific integrated circuit, a field programmable gate array, a microprocessor, software, or a combination of hardware and software.
- the article “a” is intended to include one or more items. Where only one item is intended, the term “a single” or similar language is used. Further, the phrase “based on,” as used herein is intended to mean “based, at least in part, on” unless explicitly stated otherwise.
- the term “user”, as used herein, is intended to be broadly interpreted to include, for example, an electronic device (e.g., a workstation) or a user of an electronic device, unless otherwise stated.
Abstract
A routing controller in a communication network may be responsible for generating a device model that defines intended forwarding behavior of the network. The device model may be generated using a target-independent universal language of network primitives. Network primitives are building blocks of the device model. The network primitives can be grouped to form submodels to create modularity within the device model. The network primitives and the submodels can be stored in libraries. The controller may send the device model to a target device. Upon receiving the device model from the controller, the target device may translate the device model to implementation.
Description
- In communication networks, such as telephone networks and data networks, including the Internet, information may be sent along a path from a source device to a destination device. The source device and the destination device may be, for example personal computers, servers such as email servers, web servers, or file servers, or other electronic devices capable of sending and/or receiving information via the network.
- The information may pass through one or more forwarding devices, such as routers or other electronic devices having the ability to forward the information to another device. The intermediate devices may receive the information and use functions, algorithms, data structures, and rules to determine where and how to forward the information so that the information moves towards its intended destination. These functions, algorithms, data structures, and rules form the “forwarding plane” of the network. The functions, algorithms, data structures, and rules of the forwarding plane may be implemented and/or enforced by one or more forwarding devices in the network.
- For example, a forwarding device may receive a packet on an inbound interface, look up the destination address of the packet, and apply a rule which causes the forwarding device to look up the destination address in a particular routing table. The routing table may provide a list of “next destinations” which represent a device to which the packet should be sent. The next destination for a particular packet might be, for example, the final destination device or another intermediate forwarding device. The next destination may be identified by an address stored in the routing table. The next destinations stored in the routing table may be indexed by a final destination of the packet—thus, by looking up the final destination of the packet (e.g., as identified by a header of the packet), the next destination can be retrieved from the routing table. The forwarding device may then forward the packet on an outbound interface to the identified next destination.
- Certain aspects of the forwarding plane can affect the efficiency of the network. These aspects include the specific rules, algorithms, data structures, and functions employed, the manner in which the forwarding plane is implemented, and the location at which the forwarding plane is implemented and/or enforced.
- A routing controller in a communication network may be responsible for generating a device model for a target device using a universal language of network primitives. The target device may have forwarding capabilities. Exemplary embodiments allow the target device to determine how to forward the incoming data packets based on the intended behavior of the network. The target device may translate the desired behavior described using the universal language into implementation based on the capabilities of the target device. The translation may generate a mapping between the desired behaviors and the implementations thereof.
- The universal language is a target-independent description that is used to define the intent of the network, i.e. the intended forwarding behavior. The universal language may describe a requested capability (e.g., “find the longest prefix match of a subnet mask in a routing table”) without specifying how to implement the requested capability (e.g., without specifying a particular algorithm for performing a longest prefix match). The universal language may support multiple implementations of the specified functionality (e.g., a first algorithm for finding a longest prefix match, and a second algorithm for finding a longest prefix match).
- According to exemplary embodiments, the device model may be generated using a target-independent universal language of network primitives. Network primitives are building blocks of the device model. The network primitives can be grouped to form submodels to create modularity within the device model. The network primitives and the submodels can be stored in libraries. The controller may send the device model to a target device. Upon receiving the device model from the controller, the target device may translate the device model to implementation.
- In some embodiments, a non-transitory electronic device readable storage medium is provided. The storage medium further holds instructions that, when executed, cause one or more processors to receive a device model described in a target-independent format. The device model includes one or more network primitives. The device model describes an intended forwarding behavior for a target device. The storage medium also holds instructions that, when executed, cause one or more processors to translate the device model to the one or more capabilities of the target device, the target device having a forwarding capability. The translating includes mapping the one or more network primitives to the one or more capabilities of the target device. The storage medium further holds instructions that, when executed, cause one or more processors to configure the target device based on the translating and receive one or more input packets. The storage medium also holds instructions that, when executed, cause one or more processors to forward one or more input packets to one or more elements of the network based on the configuring.
- According to various embodiments, a non-transitory electronic device readable storage medium is provided. The storage medium further holds instructions that, when executed, cause one or more processors to generate a device model in a target-independent format. The device model includes one or more network primitives. The device model describes an intended forwarding behavior for a target device. The storage medium also further holds instructions that, when executed, cause one or more processors to send the device model to the target device in the network for implementation, the target device having a forwarding capability.
- In some embodiments, a system is provided. The system comprises a routing controller, a target device and a storage. The routing controller generates a device model described in a target-independent format. The device model includes one or more network primitives. The target device receives the device model. The device model describes an intended forwarding behavior for the target device. The target device has a forwarding or switching capability. The storage stores a plurality of network primitives. The device model is generated using the one or more network primitives retrieved from the storage. The target device is configured to map the intended forwarding behavior described in the device model to the implementation of the one or more capabilities of the target device.
-
FIG. 1 depicts anexemplary network 100 including a routing controller and a target device according to an exemplary embodiment. -
FIG. 2 depicts an exemplary manner how elements of theexemplary network 100 interact according to an exemplary embodiment. -
FIG. 3 depicts an exemplary device model generated by a controller according to an exemplary embodiment. -
FIG. 4 is a flowchart describing exemplary steps performed by a controller in accordance with an exemplary embodiment. -
FIG. 5 is a flowchart describing exemplary steps performed by a target device in accordance with an exemplary embodiment. -
FIG. 6 depicts an exemplary electronic device suitable for use with exemplary embodiments described herein. -
FIG. 7 depicts an exemplary network implementation of processing performed according to an exemplary embodiment. - As described in more detail below, exemplary embodiments allow abstracting of the forwarding plane of a software defined network. Conventionally, the abstraction of setting forwarding table entries loses too much information about the intents of the application developer. Thus, conventional techniques cannot leverage all the features of the forwarding device to deliver scalable and efficient end-to-end implementations. The present application aims at mapping high-level forwarding intents to low-level features of the forwarding device by translating a device model at the forwarding device.
- A routing controller in the network may be responsible for generating a device model using a universal language of network primitives. The device model may define the intent of the network, i.e. the intended forwarding behavior.
- The controller may send the device model to a target device. The target device translates the desired behavior described in the device model into an implementation based on the capabilities of the target device. For example, the target device may include predetermined hardware or software logic for implementing the desired behavior defined in the device model. Accordingly, the target device may implement a requested capability defined in the device model without receiving instructions prescribing how to implement the requested capability.
-
FIG. 1 depicts anexemplary network 100 including arouting controller 110 and atarget device 120 according to an exemplary embodiment. Thecontroller 110 may include a processor, a server or other device implemented in hardware, software or a combination thereof. Thenetwork 100 may be a communications network such as the Internet, an intranet, or a telephone network, among other possibilities. Thenetwork 100 may include one or more optical, electronic, or other transmission mediums. - The
controller 110 of thenetwork 100 may be in communication with thetarget device 120. Thecontroller 110 may be connected to thetarget device 120 directly or indirectly. It is understood that thenetwork 100 is for explanatory purposes only, and a network suitable for use with the exemplary embodiments described herein may have other elements or capabilities. For example, the controller may generate a plurality of device models according to various embodiments. - According to an exemplary embodiment, the
target device 120 may have forwarding functionality such that thetarget device 120 is capable of receiving incoming information on an inbound interface, processing the information to determine a next destination of the information, and forwarding the information to the next destination on an outbound interface. - The
controller 110 may generate afirst device model 112 using a universal language. Thedevice model 112 may define the intent of the network 100 (e.g., the intended forwarding behavior within the network 100) using the universal language. For example, thedevice model 112 may describe a desired behavior of a node of thenetwork 100 under certain conditions, such as upon the receipt of an incoming packet. - As used herein, the universal language is a target-independent language that can be interpreted by all recipient devices. The universal language may be formed of building blocks called “network primitives”. The
device model 112 may include one ormore network primitives 114. A network primitive 114 is a basic unit of functionality to be implemented by elements of thenetwork 100. A network primitive 114 may be, for example, a description of a particular functionality to be used in thenetwork 100. A network primitive 114 may describe what actions elements of thenetwork 100 are meant to perform, but typically will not include requirements for how those actions are to be carried out. Thus, a network primitive 114 may describe a desired outcome without providing implementation details for achieving the outcome. The implementation details may be left to the particular device implementing the network primitive 114, or may be specified by an external device. Thedevice model 112 may be constructed as a collection of one ormore network primitives 114. A same network primitive may appear multiple times in a given device model. - According to various embodiments, a network primitive 114 related to queuing may specify that a recipient device of the
device model 112 is to implement flat queuing, hierarchical queuing, buffer resource sharing, dynamic buffer sizing, tail drop queue management or weighted tail drop queue management. Scheduling primitives may specify that scheduling should be in a round robin fashion, as a weighted round robin, low latency queuing or strict priority queuing, weighted fair queuing, or class-based weighted fair queuing. Metering primitives may make use of one rate two color (1R2C) IP packet marking, 1R3C marking, or 2R3C marking. Numerous other networking primitives may also be utilized. The details of the implementations of these networking primitives may be unspecified and left up to the device that implements the primitives. - According to various embodiments, network primitives can pass information between themselves. A network primitive may produce information for another network primitive to consume. The information that is exchanged between the primitives may be assigned a name. The named information may be referred as a handle. Naming the information allows the information to be referred to symbolically. Naming the information further improves the readability of the device model. The information may also be typed, i.e. one or more attributes, such as the size of the information, may be associated with the information.
- The network primitives may include core network primitives and control network primitives. The core network primitives may describe an independent thread of data path functionality. For example, a core network primitive may describe packet forwarding. The core primitives may be used to build a device model for network elements including but not limited to a switch, router, load balancer, flow device. The core primitives may be used to represent fragmentation, reassembly, cryptographic processing, etc. The control network primitives may describe administrative functionality such as the interaction between the independent threads, event handling, exception handling, etc.
- Exemplary core network primitives may include the parse primitives, the table primitives, the logic primitive, the arithmetic primitive, the packet replicate primitive, the rewrite primitives, the meter primitive, the queue primitive, the scheduler primitive, the discard primitive, the counter primitive and the external primitive. Some of these exemplary core primitives are discussed below.
- The parse primitives may define the constraints and the information extracted from a packet header field of an input packet. According to various embodiments, the parse primitives may not be required to describe deep packet inspection on unstructured packet content. The parse primitives may include a parse header order sub-primitive that may be used to describe an acceptable parse graph. A header may be defined as a contiguous set of bytes from the input packet from which one or more pieces of information (fields) can be extracted in without performing a lookup operation for determining the next header. The parse header order primitive may take one or more arguments. For example, the header order primitive may take current parse anchor as an argument. The current parse anchor may determine where in the packet the parsing should start. The header order primitive may also take well known header name/ID as an argument. This argument represents a name or ID assigned to the header. The header handle ID argument may represent a handle assigned to the header for reference in the device model. The next parse anchor argument represents an anchor referring to the location of the payload of the header or sub header after the particular header has been parsed successfully. The header order primitive may also take header parse status handle as an argument. The argument defines the handle which refers to a Boolean and captures the parsing status. The argument is set to TRUE in case the header was present and was valid. Otherwise, the argument is set to FALSE. The header parse status may be an optional argument and can be skipped if the model writer has no interest in looking at the parse status.
- The table primitives include a table definition primitive that may provide the typing and other miscellaneous information about a data store, i.e. a table. The typing information and constraints associated with the data store allows the consumer of the device model, e.g. the target device, to verify that the forwarding plane instantiation meets the requirements. The typing information and constraints associated with the data store may also allow the forwarding plane to perform one or more optimizations in implementing the data store. The table definition primitive may take one or more arguments such as the table type indicating whether the table includes an array, a tree, a set or a list. The arguments may also include an argument indicating whether table sharing is enabled, the table size, the table size tolerance, the table key definition list, the mask associated with each key list, the table result definition and the table handle (table ID/name).
- The table primitives may also include the table operation sub-primitive that may describe the forwarding plane actions that are taken on the data store defined by the table definition primitive. The table match sub-primitive describes a match or a search operation on the table. The table insert sub-primitive describes the data store insert operation performed by the data plane.
- The logic primitive may allow the device model to express simple boolean logic or conditional operations that are used in forwarding the input packets. Logic operators may take handles as input and may produce output handles with the result of the logic operation. The logic primitives may support operations like integer comparisons including greater than operation, less than operation, equal to operation, Boolean logic operations like and operation, or operation, not operation, etc. The logic primitive may take one or more arguments including an ordered input handle that become the operands. The order and semantics of the operands are defined by the arithmetic operation. The logic primitive may also take output handle as an argument. The output handle may store the results of the operation performed by the logic primitive.
- Exemplary control network primitives may include the scope primitive, the event handler primitive, the semaphore primitive, the event primitive and the raise primitive. Some of these exemplary core primitives are discussed below.
- The Scope primitive may allow the device model writer to indicate an order of operations to be performed in a set of primitives. For example, a scope primitive may be used in connection with the logic primitive to define an order of logic operations to be performed.
- The event handler primitive may bind an event to a collection of cooperative primitives representing some defined functionality. The collection of primitives with a defined functionality may be given a ‘name’. The event handler may bind a named event to a named collection of primitives.
- A semaphore primitive may allow the model writer to describe mutual exclusion, critical sections, etc. within the device model. The semaphore primitive may allow for more than one primitive collection to access a resource. The semaphore primitive may also be used to allow for multiple individual primitive collections to access different instances of a shared resource safely if available.
- A raise primitive may be used to raise an exception. The raise primitive may be used to define how processing should proceed when a certain exception condition is encountered. The raise primitive may have two modes: a first mode which asks that processing of the packet be stopped and exception be taken, and a second mode which allows the main processing to continue and the exception is also taken.
- One or
more network primitives 114 may be grouped together to form asubmodel 118. Thesubmodel 118 may represent a desired functionality within thedevice model 112. Submodels promote modularity within a given device model. As discussed in greater detail below, a plurality of submodels may be stored in a submodel library. Thecontroller 110 may retrieve the desired submodel from the submodel library and use the retrieved submodel in a device model. Similarly, if thecontroller 110 generates a new submodel by grouping one or more network primitives, thecontroller 110 may store the new submodel in the submodel library. One of ordinary skill in the art will appreciate that the use of submodels in a device model is optional. A device model may be generated without using any submodels. However, the submodels promote modularity and allow for a user-friendly visualization of the device model. - The
device model 112 generated by thecontroller 110 may specify all the routing/forwarding functionality within thenetwork 100. In some embodiments, thecontroller 110 may generate a plurality of device models. For example, thecontroller 110 may generate afirst device model 112 to be used under certain circumstances, such as periods of high or low network traffic or upon the receipt of certain types of packets. Thecontroller 110 may generate asecond device model 112′ formed ofnetwork primitives 114′ where thesecond device model 112′ may be used under other circumstances. By modifying thedevice model network 100 to exhibit different network forwarding behaviors. - The
controller 110 may send the generateddevice model 112 and/or 112′ to thetarget device 120. Thedevice model 112 and/or 112′ may represent a complete set of functionality required of thetarget device 120. Where applicable, thetarget device 120 may interpret the information contained in thedevice model 112 and/or 112′ within constraints known to thetarget device 120. Upon receiving thedevice model 112 and/or 112′, thetarget device 120 may translate the intended behavior described in thedevice model 112 and/or 112′ into implementation. Thetarget device 120 may include atranslator 126 provided at a hardware abstraction layer (HAL) 122 of thetarget device 120. Thetranslator 126 may translate the target-independent device model 112 and/or 112′ into implementation on thetarget device 120 based on the capabilities of, for example, the application specific integrated circuit (ASIC) 124 of thetarget device 120. Thetranslator 126 may generate amapping 128 between elements of thedevice model 112 and/or 112′ and the capabilities of thetarget device 120, more specifically theASIC 124 of thetarget device 120. For example, themapping 128 may map one or more network elements of thedevice model 112 to an exemplary implementation such as queuing an incoming packet or discarding an incoming packet. Accordingly, high-level generic desired forwarding behaviors may be mapped to low-level ASIC features. According to various embodiments, when an intended behavior is translated into an implementation and a mapping is created between the intended behavior and the target device, the HAL 122 may continue to service the control messages from thecontroller 110. The HAL 122 may continue to run the control messages through the mapping and send the control messages to thetarget device 120. The HAL 122 may keep the local state to continue communicating with thetarget device 120. -
FIG. 2 depicts how elements of theexemplary network 100 may interact according to an exemplary embodiment. Thecontroller 202 provided in anetwork 200 may generate adevice model 204. Thedevice model 204 may be formed of one or more network primitives. The network primitives may be stored in a networkprimitive library 206. Thecontroller 202 may access networkprimitive library 206 to retrieve one or more network primitives. Thecontroller 202 may insert the retrieved one or more network primitives in thedevice model 204. The networkprimitive library 206 may be extensible. That is, new network primitives may be added to the networkprimitive library 206. - According to various embodiments, one or more network primitives may be grouped to form a submodel. The generated submodels may be stored in a
submodel library 208. Thesubmodel library 208 may also include submodels generated by other users or controllers in other networks. Thesubmodel library 208 may be accessible by a plurality of controllers in a plurality of networks. Thecontroller 202 may access thesubmodel library 208 to retrieve one or more submodels. Thecontroller 202 may insert the retrieved one or more submodels in thedevice model 204. Similarly to the networkprimitive library 206, thesubmodel library 208 is also extensible. That is, new submodels may be added to thesubmodel library 206. For example, if thecontroller 202 generates a new submodel by grouping one or more network primitives, thecontroller 202 may add the new submodel to thesubmodel library 208. - The
controller 202 may send the generateddevice model 204 to atarget device 250. Upon receiving thedevice model 202, thetarget device 250 translates thedevice model 202 into an implantation. More specifically, thetranslator 210 of thetarget device 250 may generate a mapping that maps the components of thedevice model 202 to the capabilities of thetarget device 250. When the translation is complete, the intended behavior described in thedevice model 202 is passed toimplementation 214 on the target device. Thetranslator 210, located at thetarget device 250, is familiar with the capabilities of thetarget device 250. Thus, thetranslator 210 is best suited for translating thedevice model 202 into the implementation. -
FIG. 3 depicts anexemplary device model 300 generated by a controller according to an exemplary embodiment. Thedevice model 300 is provided as a unified modeling language (UML) activity diagram. It is understood that UML activity diagram is used for illustrative purposed and that thedevice model 300 may be provided using other graphical and/or textual modeling languages. Thedevice model 300 illustrates a representation of the network behavior for implementing a media access control (MAC) bridge. Thedevice model 300 includes a plurality of network primitives 302-318. When thedevice model 300 is sent to a target device, the ASIC of the target device is given the specific behavior expected of the network for an efficient implementation by the target device. - According to various embodiments, the
device model 300 may also be expressed using textual code, such as a pseudo code. A portion of an exemplary pseudo code representing thedevice model 300 is provided below. One of ordinary skill in the art will appreciate that the pseudo code is provided for exemplary purposes and should not be construed as limiting. -
{ ... primitive TABLEDEF(Name = “MACTable” /* Data Structure Name */, TableShared = TRUE, TableType = ExactMatch, SearchKey = { { /*Bridging Search Key */ (Vlan, 12), (MACAddress, 48) }, {/* Learning Search Key */ (PortID, 8), (VlanID, 12), (MACAddress, 48) } }, TableResult= {BridgingResult, LearningResult}, TableSize = MacTableSize); ... primitive TABLEOPS_MATCH(MatchName = BridgeForwardingMatch, TABLE=”MACTable”, consumes(VlanID, MACDestAddress), SearchKeyMap={(Vlan:VlanID),(MACAddress:MACDestAddress)}, produces(outPortID, DropPacket), ResultMap = {(BridgingResult.oPort: outPortID), (BridgingResult.drop: DropPacket)} ); ... primitive TABLEOPS_MATCH(MatchName = BridgeLearningMatch, TABLE=”MACTable”, consumes(PortID, VlanID, MACSrcAddress), SearchKeyMap={( (PortID: PortID), (Vlan:VlanID), (MACAddress:MACSrcAddress)}, produces(LearningHit), ResultMap = {(LearningResult.Hit: LearningHit) } ); ... if (LearningHit == TRUE && STPLearningEnabled == TRUE) { /* Conditional Logic Primitive */ ... /* Record Activity for the Src MAC address */ primitive TABLEOPS_MODIFY(MatchName = UpdateMACActivity, TABLE=”MACTable”, consumes(PortID, VlanID, MACSrcAddress, CurrentTimeStamp), SearchKeyMap={(PortID: PortID), (Vlan:VlanID), (MACAddress:MACSrcAddress)}, produces( ), ResultMap = {(LearningResult.LastSeen: CurrentTimeStamp) } ); ... } else if (LearningHit == FALSE && STPLearningEnabled == TRUE) { /* Logic */ ... /* Learn the Src MAC address */ primitive TABLEOPS_INSERT(MatchName = LearnMAC, TABLE=”MACTable”, consumes(PortID, VlanID, MACSrcAddress, CurrentTimeStamp), SearchKeyMap={ (PortID : PortID), (Vlan:VlanID), (MACAddress:MACSrcAddress)}, produces( ), ResultMap = {(LearningResult.LastSeen: CurrentTimeStamp), (BridgingResult.oPort: PortID), (BridgingResult.drop: FALSE)} ); ... } - As illustrated above, the pseudo code may have an entry for the network primitives of the
device model 300. For example, the portion of the pseudo code provided above has an entry for table definition network primitive 306, the tableops_match network primitive 304, the tableops_modify network primitive 308 and the tableops_insert network primitive 310. The exemplary pseudo code provided above represents a partial implementation of a learning MAC bridge. As illustrated above, a MAC table is defined. A first match is run on the MAC table when the virtual local area network (VLAN) ID (i.e. vlanid) and MAC destination address (i.e. macdestaddr) are known. The result of the first match is output as an output packet. A second match may run in parallel with the first match once the input port, VLAN and MAC source address are determined. The second match may run to ensure that the source MAC is associated with the source port. If it is determined that the source MAC is not associated with the source port, the second match may produce a flag. Setting the flag may cause the conditional to execute regardless of the state of the flag. Upon setting the flag and execution of the conditional, the source address that was not associated with the source port, becomes associated with the source port. - The target device, upon receiving the
device model 300 in the graphical format or in the pseudo code format, translates thedevice model 300 into an implementation. The translation of theexemplary device model 300 in the implementation of a MAC bridge will allow communications between one or more end stations coupled to the target device in the network. Specifically, the intended behavior represented in thedevice model 300 allows the interconnection of one or more end stations as if they were attached to a single local area network (LAN), even if the one or more end satiations are attached to separate LANs. The translation may be implemented as a set of mappings to the existing tables in a forwarding ASIC. The configuration of one or more registers on the ASIC may be modified to indicate that the tables should be treated in a manner consistent with the intended behavior. According to various embodiments, the translation may be adapted to accommodate the capabilities of a destination ASIC that is designed to perform complex tasks or to accommodate the capabilities of a destination software. - When the controller generates a device model, the controller may send the device model to the target device for implementation. The controller may send the device model in the graphical format and/or in a textual format such as a pseudo code. Both the graphical format and the pseudo code include one or more network primitives generated in a target-independent universal language. The steps performed by the controller and the target device are discussed below.
-
FIG. 4 is a flowchart describing exemplary steps performed by a controller in accordance with an exemplary embodiment. The controller may generate a device model in a target-independent format (step 402). The device model may describe the intended forwarding behavior for the target device. The intended forwarding behavior may be a high-level indication of the intent of the developer. The controller may send the generated device model to the target device for implementation (step 404). -
FIG. 5 is a flowchart describing exemplary steps performed by a target device in accordance with an exemplary embodiment. The target device receives the device model generated by the controller (step 502). The device model may be described in target-independent format. The target device may translate the device model into an implementation based on the capabilities of the target device (step 504). The target device may be configured based on the translating (step 506). When the target device receives one or more input packets (step 508), the target device may forward the received input packets to one or more elements of the network based on the configuring (step 510). - One or more of the above-described acts may be encoded as computer-executable instructions executable by processing logic. The computer-executable instructions may be stored on one or more non-transitory computer readable media. One or more of the above described acts may be performed in a suitably-programmed electronic device.
FIG. 6 depicts an example of anelectronic device 600 that may be suitable for use with one or more acts disclosed herein. - The
electronic device 600 may take many forms, including but not limited to a computer, workstation, server, network computer, quantum computer, optical computer, Internet appliance, mobile device, a pager, a tablet computer, a smart sensor, application specific processing device, etc. - The
electronic device 600 is illustrative and may take other forms. For example, an alternative implementation of theelectronic device 600 may have fewer components, more components, or components that are in a configuration that differs from the configuration ofFIG. 6 . The components ofFIG. 6 and/or other figures described herein may be implemented using hardware based logic, software based logic and/or logic that is a combination of hardware and software based logic (e.g., hybrid logic); therefore, components illustrated inFIG. 6 and/or other figures are not limited to a specific type of logic. - The
processor 602 may include hardware based logic or a combination of hardware based logic and software to execute instructions on behalf of theelectronic device 600. Theprocessor 602 may include logic that may interpret, execute, and/or otherwise process information contained in, for example, thememory 604. The information may include computer-executable instructions and/or data that may implement one or more embodiments of the invention. Theprocessor 602 may comprise a variety of homogeneous or heterogeneous hardware. The hardware may include, for example, some combination of one or more processors, microprocessors, field programmable gate arrays (FPGAs), application specific instruction set processors (ASIPs), application specific integrated circuits (ASICs), complex programmable logic devices (CPLDs), graphics processing units (GPUs), or other types of processing logic that may interpret, execute, manipulate, and/or otherwise process the information. The processor may include a single core ormultiple cores 603. Moreover, theprocessor 602 may include a system-on-chip (SoC) or system-in-package (SiP). - The
electronic device 600 may include one or more tangible non-transitory computer-readable storage media for storing one or more computer-executable instructions or software that may implement one or more embodiments of the invention. The non-transitory computer-readable storage media may be, for example, thememory 604 or thestorage 618. Thememory 604 may comprise a ternary content addressable memory (TCAM) and/or one or more of a RAM that may include RAM devices, a content addressable memory (CAM) or a ternary content addressable memory (TCAM) for storing the information. The RAM devices may be volatile or non-volatile and may include, for example, one or more DRAM devices, flash memory devices, SRAM devices, zero-capacitor RAM (ZRAM) devices, twin transistor RAM (TTRAM) devices, read-only memory (ROM) devices, ferroelectric RAM (FeRAM) devices, magneto-resistive RAM (MRAM) devices, phase change memory RAM (PRAM) devices, or other types of RAM devices. - One or
more computing devices 600 may include a virtual machine (VM) 605 for executing the instructions loaded in thememory 604. Avirtual machine 605 may be provided to handle a process running on multiple processors so that the process may appear to be using only one computing resource rather than multiple computing resources. Virtualization may be employed in theelectronic device 600 so that infrastructure and resources in the electronic device may be shared dynamically.Multiple VMs 605 may be resident on asingle computing device 600. - A
hardware accelerator 606, may be implemented in an ASIC, FPGA, or some other device. Thehardware accelerator 606 may be used to reduce the general processing time of theelectronic device 600. - The
electronic device 600 may include anetwork interface 608 to interface to a Local Area Network (LAN), Wide Area Network (WAN) or the Internet through a variety of connections including, but not limited to, standard telephone lines, LAN or WAN links (e.g., T1, T3, 56 kb, X.25), broadband connections (e.g., integrated services digital network (ISDN), Frame Relay, asynchronous transfer mode (ATM), wireless connections (e.g., 802.11), high-speed interconnects (e.g., InfiniBand, gigabit Ethernet, Myrinet) or some combination of any or all of the above. Thenetwork interface 608 may include a built-in network adapter, network interface card, personal computer memory card international association (PCMCIA) network card, card bus network adapter, wireless network adapter, universal serial bus (USB) network adapter, modem or any other device suitable for interfacing theelectronic device 600 to any type of network capable of communication and performing the operations described herein. - The
electronic device 600 may include one ormore input devices 610, such as a keyboard, a multi-point touch interface, a pointing device (e.g., a mouse), a gyroscope, an accelerometer, a haptic device, a tactile device, a neural device, a microphone, or a camera that may be used to receive input from, for example, a user. Note thatelectronic device 600 may include other suitable I/O peripherals. - The
input devices 610 may allow a user to provide input that is registered on avisual display device 614. A graphical user interface (GUI) 616 may be shown on thedisplay device 614. - A
storage device 618 may also be associated with thecomputer 600. Thestorage device 618 may be accessible to theprocessor 602 via an I/O bus. The information may be executed, interpreted, manipulated, and/or otherwise processed by theprocessor 602. Thestorage device 618 may include, for example, a storage device, such as a magnetic disk, optical disk (e.g., CD-ROM, DVD player), random-access memory (RAM) disk, tape unit, and/or flash drive. The information may be stored on one or more non-transient tangible computer-readable media contained in the storage device. This media may include, for example, magnetic discs, optical discs, magnetic tape, and/or memory devices (e.g., flash memory devices, static RAM (SRAM) devices, dynamic RAM (DRAM) devices, or other memory devices). The information may include data and/or computer-executable instructions that may implement one or more embodiments of the invention. - The
storage device 618 may further storeapplications 624, and theelectronic device 600 can be running an operating system (OS) 626. Examples ofOS 626 may include the Microsoft® Windows® operating systems, the Unix and Linux operating systems, the MacOS® for Macintosh computers, an embedded operating system, such as the Symbian OS, a real-time operating system, an open source operating system, a proprietary operating system, operating systems for mobile electronic devices, or other operating system capable of running on the electronic device and performing the operations described herein. The operating system may be running in native mode or emulated mode. - The
storage device 618 may further includerules 628 which describe how messages should be forwarded in a communications network. Therules 628 may be used to forward messages or information received at theelectronic device 628. Accordingly, theelectronic device 600 may serve as a forwarding device, switch, or router. - The
storage device 618 may store animplementation database 630. Theimplementation database 630 may be a data structure, such as a table or matrix, which stores identifiers identifying predetermined functions that are implemented by theelectronic device 630. The implementation database may further store the implementation details of the predetermined functions. - The
storage device 618 may further include logic for implementing acommunications protocol 640. Thecommunications protocol 640 may be a protocol which provides an interface for accessing and modifying the functionality of the forwarding plane of theelectronic device 600.Exemplary communications protocols 640 include, but are not limited to, the OpenFlow protocol (see, e.g., McKeown, Nick et al., “OpenFlow: Enabling Innovation in Campus Networks,” ACM SIGCOMM Computer Communication Review Archive, vol. 38 issue 2, pp. 69-74 (April 2008), the contents of which are incorporated herein by reference) or custom communications protocols. Thus, theelectronic device 600 may serve as a remote controller, such as thecontroller 110 described above with respect toFIG. 1 . - The
communications protocol 640 may allow the details of the forwarding plane implemented by theelectronic device 600 to be defined and/or modified. Accordingly, thecommunications protocol 640 allows a communications network to be made programmable. - The
communications protocol 640 may support the use of one ormore device models 642 to implement the functionality of the forwarding plane. Adevice model 642 may represent the complete set of network routing functionality to be implemented by theelectronic device 640. For example, thedevice model 642 may define the functionality and performance of the forwarding plane. - The
device model 642 may include one or more network primitives. A network primitive is a basic unit of functionality to be implemented by theelectronic device 600. A network primitive may be, for example, a description of a particular functionality to be used in the communications network. A network primitive may describe what actions theelectronic device 600 is meant to perform, but typically will not include requirements for how those actions are to be carried out. Thus, a network primitive may describe a desired outcome without providing implementation details for achieving the outcome. The implementation details may be left to the particular device implementing the network primitive, or may be specified by an external device. - For example, a network primitive related to queuing may specify that the electronic device 600 (acting as a forwarding device) is to implement flat queuing, hierarchical queuing, buffer resource sharing, dynamic buffer sizing, tail drop queue management, weighted tail drop queue management, or queue high and low watermarks. Scheduling primitives may specify that scheduling should be in a round robin fashion, as a weighted round robin, low latency queuing or strict priority queuing, weighted fair queuing, or class-based weighted fair queuing. Metering primitives may make use of one rate two color (1R2C) IP packet marking, 1R3C marking, or 2R3C marking. Numerous other network primitives may also be utilized. The details of the implementations of these network primitives may be unspecified and left up to the device that implements the primitives.
- A
device model 642 may be constructed as a collection of one or more network primitives. For example, onedevice model 642 might specify that theelectronic device 600 is to use flat queuing with round robin scheduling. - One or
more device models 642 may specify all the network routing/forwarding functionality of theelectronic device 600. For example, afirst device model 642 may be used under certain circumstances, such as periods of high or low network traffic or upon the receipt of certain types of packets, and that asecond device model 642 may be used under other circumstances. By modifying thedevice model 642, a network administrator may cause theelectronic device 600 to exhibit different network forwarding behaviors. - The
communications protocol 640 may reference adevice model 642 and implement the functionality defined by thedevice model 642 using the functionality defined by theimplementation database 630. Alternatively, thecommunications protocol 640 may use default or generic implementations stored locally with thecommunications protocol 640 or provided from a remote location, such as a remote controller. - One or more embodiments of the invention may be implemented using computer-executable instructions and/or data that may be embodied on one or more non-transitory tangible computer-readable mediums. The mediums may be, but are not limited to, a hard disk, a compact disc, a digital versatile disc, a flash memory card, a Programmable Read Only Memory (PROM), a Random Access Memory (RAM), a Read Only Memory (ROM), Magnetoresistive Random Access Memory (MRAM), a magnetic tape, or other computer-readable media.
-
FIG. 7 depicts a network implementation that may implement one or more embodiments of the invention. Asystem 700 may include acomputing device 600, anetwork 712, aservice provider 713, atarget environment 714, and acluster 715. The embodiment ofFIG. 7 is exemplary, and other embodiments can include more devices, fewer devices, or devices in arrangements that differ from the arrangement ofFIG. 7 . - The
network 712 may transport data from a source to a destination. Embodiments of thenetwork 712 may use network devices, such as routers, switches, firewalls, and/or servers (not shown) and connections (e.g., links) to transport data. Data may refer to any type of machine-readable information having substantially any format that may be adapted for use in one or more networks and/or with one or more devices (e.g., thecomputing device 600, theservice provider 713, etc.). Data may include digital information or analog information. Data may further be packetized and/or non-packetized. - The
network 712 may be a hardwired network using wired conductors and/or optical fibers and/or may be a wireless network using free-space optical, radio frequency (RF), and/or acoustic transmission paths. In one implementation, thenetwork 712 may be a substantially open public network, such as the Internet. In another implementation, thenetwork 712 may be a more restricted network, such as a corporate virtual network. Thenetwork 712 may include Internet, intranet, Local Area Network (LAN), Wide Area Network (WAN), Metropolitan Area Network (MAN), wireless network (e.g., using IEEE 802.11), or other type of network Thenetwork 712 may use middleware, such as Common Object Request Broker Architecture (CORBA) or Distributed Component Object Model (DCOM). Implementations of networks and/or devices operating on networks described herein are not limited to, for example, any particular data type, protocol, and/or architecture/configuration. - The
service provider 713 may include a device that makes a service available to another device. For example, theservice provider 713 may include an entity (e.g., an individual, a corporation, an educational institution, a government agency, etc.) that provides one or more services to a destination using a server and/or other devices. Services may include instructions that are executed by a destination to perform an operation (e.g., an optimization operation). Alternatively, a service may include instructions that are executed on behalf of a destination to perform an operation on the destination's behalf. - The
server 714 may include a device that receives information over thenetwork 712. For example, theserver 714 may be a device that receives user input from thecomputer 600. - The
cluster 715 may include a number of units of execution (UEs) 716 and may perform processing on behalf of the computer 500 and/or another device, such as theservice provider 713 orserver 714. For example, thecluster 715 may perform parallel processing on an operation received from thecomputer 600. Thecluster 715 may includeUEs 716 that reside on a single device or chip or that reside on a number of devices or chips. - The units of execution (UEs) 716 may include processing devices that perform operations on behalf of a device, such as a requesting device. A UE may be a microprocessor, field programmable gate array (FPGA), and/or another type of processing device.
UE 716 may include code, such as code for an operating environment. For example, a UE may run a portion of an operating environment that pertains to parallel processing activities. Theservice provider 713 may operate thecluster 715 and may provide interactive optimization capabilities to the computer 500 on a subscription basis (e.g., via a web service). - Units of Execution (UEs) may provide remote/distributed processing capabilities for the applications 724. A hardware unit of execution may include a device (e.g., a hardware resource) that may perform and/or participate in parallel programming activities. For example, a hardware unit of execution may perform and/or participate in parallel programming activities in response to a request and/or a task it has received (e.g., received directly or via a proxy). A hardware unit of execution may perform and/or participate in substantially any type of parallel programming (e.g., task, data, stream processing, etc.) using one or more devices. For example, a hardware unit of execution may include a single processing device that includes multiple cores or a number of processors. A hardware unit of execution may also be a programmable device, such as a field programmable gate array (FPGA), an application specific integrated circuit (ASIC), a digital signal processor (DSP), or other programmable device. Devices used in a hardware unit of execution may be arranged in many different configurations (or topologies), such as a grid, ring, star, or other configuration. A hardware unit of execution may support one or more threads (or processes) when performing processing operations.
- A software unit of execution may include a software resource (e.g., a technical computing environment) that may perform and/or participate in one or more parallel programming activities. A software unit of execution may perform and/or participate in one or more parallel programming activities in response to a receipt of a program and/or one or more portions of the program. A software unit of execution may perform and/or participate in different types of parallel programming using one or more hardware units of execution. A software unit of execution may support one or more threads and/or processes when performing processing operations.
- The term ‘parallel programming’ may be understood to include multiple types of parallel programming, e.g. task parallel programming, data parallel programming, and stream parallel programming. Parallel programming may include various types of processing that may be distributed across multiple resources (e.g., software units of execution, hardware units of execution, processors, microprocessors, clusters, labs) and may be performed at the same time.
- For example, parallel programming may include task parallel programming where a number of tasks may be processed at the same time on a number of software units of execution. In task parallel programming, a task may be processed independently of other tasks executing, for example, at the same time.
- Parallel programming may include data parallel programming, where data (e.g., a data set) may be parsed into a number of portions that may be executed in parallel using, for example, software units of execution. In data parallel programming, the software units of execution and/or the data portions may communicate with each other as processing progresses.
- Parallel programming may include stream parallel programming (sometimes referred to as pipeline parallel programming). Stream parallel programming may use a number of software units of execution arranged, for example, in series (e.g., a line) where a first software unit of execution may produce a first result that may be fed to a second software unit of execution that may produce a second result given the first result. Stream parallel programming may also include a state where task allocation may be expressed in a directed acyclic graph (DAG) or a cyclic graph.
- Other parallel programming techniques may involve some combination of task, data, and/or stream parallel programming techniques alone or with other types of processing techniques to form hybrid-parallel programming techniques.
- The foregoing description may provide illustration and description of various embodiments of the invention, but is not intended to be exhaustive or to limit the invention to the precise form disclosed. Modifications and variations may be possible in light of the above teachings or may be acquired from practice of the invention. For example, while a series of acts has been described above, the order of the acts may be modified in other implementations consistent with the principles of the invention. Further, non-dependent acts may be performed in parallel.
- In addition, one or more implementations consistent with principles of the invention may be implemented using one or more devices and/or configurations other than those illustrated in the Figures and described in the Specification without departing from the spirit of the invention. One or more devices and/or components may be added and/or removed from the implementations of the figures depending on specific deployments and/or applications. Also, one or more disclosed implementations may not be limited to a specific combination of hardware.
- Furthermore, certain portions of the invention may be implemented as logic that may perform one or more functions. This logic may include hardware, such as hardwired logic, an application-specific integrated circuit, a field programmable gate array, a microprocessor, software, or a combination of hardware and software.
- No element, act, or instruction used in the description of the invention should be construed critical or essential to the invention unless explicitly described as such.
- Also, as used herein, the article “a” is intended to include one or more items. Where only one item is intended, the term “a single” or similar language is used. Further, the phrase “based on,” as used herein is intended to mean “based, at least in part, on” unless explicitly stated otherwise. In addition, the term “user”, as used herein, is intended to be broadly interpreted to include, for example, an electronic device (e.g., a workstation) or a user of an electronic device, unless otherwise stated.
- It is intended that the invention not be limited to the particular embodiments disclosed above, but that the invention will include any and all particular embodiments and equivalents falling within the scope of the following appended claims.
Claims (20)
1. A non-transitory electronic device readable storage medium holding instructions that, when executed, cause one or more processors to:
receive a device model described in a target-independent format, where the device model:
includes one or more network primitives, and
describes an intended forwarding behavior for a target device;
translate the device model to the one or more capabilities of the target device, the target device having a forwarding capability, wherein the translating includes mapping the one or more network primitives to the one or more capabilities of the target device;
configure the target device based on the translating;
receive one or more input packets; and
forward one or more input packets to one or more elements of the network based on the configuring.
2. The medium of claim 1 , wherein a network primitive is a target device independent building block for the device model.
3. The medium of claim 1 , wherein the one or more network primitives are stored in a network primitive library.
4. The medium of claim 3 , wherein additional network primitives are added to the network primitive library.
5. The medium of claim 1 , wherein the device model includes a submodel formed by grouping one or more network primitives, the submodel defining a functionality.
6. The medium of claim 5 , wherein the submodel is stored in a submodel library.
7. The medium of claim 6 , wherein additional submodels are added to the submodel library.
8. The medium of claim 1 , wherein the device model includes two or more instances of a first network primitive.
9. The medium of claim 1 , the one or more network primitives include a core network primitive that describes an independent thread of data path functionality.
10. The medium of claim 1 , wherein the one or more network primitives include a control primitive that describe control flow functionality within the network.
11. The medium of claim 1 , further holding one or more instructions to:
parse the received device model.
12. A non-transitory electronic device readable storage medium holding instructions that, when executed, cause one or more processors to:
generate a device model in a target-independent format, where the device model:
includes one or more network primitives, and
describes an intended forwarding behavior for a target device; and
send the device model to the target device in the network for implementation, the target device having a forwarding capability.
13. The medium of claim 12 , further holding one or more instructions to:
retrieve the one or more network primitives from a network primitive library.
14. The medium of claim 12 , wherein the device model includes a submodel formed by grouping one or more network primitives, the submodel defining a functionality.
15. The medium of claim 14 , further holding one or more instructions to:
retrieve one or more submodels from a submodel library; and
insert the retrieved one or more submodels in the device model.
16. The medium of claim 12 , further holding one or more instructions to:
group a set of network primitives into a submodel;
replace the set of network primitives in the device model with the submodel;
store the submodel in a submodel library.
17. The medium of claim 12 , wherein the device model includes two or more instances of a first network primitive.
18. A system comprising:
a routing controller for generating a device model described in a target-independent format, wherein the device model includes one or more network primitives;
a target device for receiving the device model, wherein:
the device model describes an intended forwarding behavior for the target device,
the target device has a forwarding or switching capability; and
a storage for storing a plurality of network primitives, wherein the device model is generated using the one or more network primitives retrieved from the storage,
wherein the target device is configured to map the intended forwarding behavior described in the device model to the implementation of the one or more capabilities of the target device.
19. The system of claim 18 , wherein the target device is configured to:
receive one or more input packets, and
forward the one or more input packets to one or more elements of the network based on mapping.
20. The system of claim 18 , wherein the device model includes a submodel formed by grouping one or more network primitives, the submodel defining a functionality.
Priority Applications (4)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/775,994 US20140241346A1 (en) | 2013-02-25 | 2013-02-25 | Translating network forwarding plane models into target implementation using network primitives |
CN201480010333.0A CN105027505A (en) | 2013-02-25 | 2014-02-25 | Static translation of network forwarding plane models into target implementation in the hardware abstraction layer |
PCT/US2014/018421 WO2014131044A1 (en) | 2013-02-25 | 2014-02-25 | Static translation of network forwarding plane models into target implementation in the hardware abstraction layer |
EP14714814.2A EP2959636A1 (en) | 2013-02-25 | 2014-02-25 | Static translation of network forwarding plane models into target implementation in the hardware abstraction layer |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/775,994 US20140241346A1 (en) | 2013-02-25 | 2013-02-25 | Translating network forwarding plane models into target implementation using network primitives |
Publications (1)
Publication Number | Publication Date |
---|---|
US20140241346A1 true US20140241346A1 (en) | 2014-08-28 |
Family
ID=51388087
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US13/775,994 Abandoned US20140241346A1 (en) | 2013-02-25 | 2013-02-25 | Translating network forwarding plane models into target implementation using network primitives |
Country Status (1)
Country | Link |
---|---|
US (1) | US20140241346A1 (en) |
Cited By (7)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN105471726A (en) * | 2014-09-05 | 2016-04-06 | 华为技术有限公司 | Forwarding parameter passing method and equipment |
US9411613B1 (en) * | 2015-04-22 | 2016-08-09 | Ryft Systems, Inc. | Systems and methods for managing execution of specialized processors |
US9542244B2 (en) | 2015-04-22 | 2017-01-10 | Ryft Systems, Inc. | Systems and methods for performing primitive tasks using specialized processors |
US20170126551A1 (en) * | 2015-10-31 | 2017-05-04 | Nicira, Inc. | Representation of Match Conditions in Logical Pipeline Data |
US10355949B2 (en) | 2013-12-04 | 2019-07-16 | Radware, Ltd. | Behavioral network intelligence system and method thereof |
US10985990B2 (en) * | 2015-09-15 | 2021-04-20 | Huawei Technologies Co., Ltd. | Software defined topology (SDT) for user plane |
WO2023138234A1 (en) * | 2022-01-20 | 2023-07-27 | 北京邮电大学 | Model management method and apparatus, networking architecture, electronic device and storage medium |
-
2013
- 2013-02-25 US US13/775,994 patent/US20140241346A1/en not_active Abandoned
Non-Patent Citations (1)
Title |
---|
Dan Cohn ET AL "OF-Futures Primitive Set - Google Docs", Google Docs (http://goo.gl/6qwbg), 1 July 2011, XP055120456, page 3 - page 8, page 36 - page 37. * |
Cited By (13)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US10355949B2 (en) | 2013-12-04 | 2019-07-16 | Radware, Ltd. | Behavioral network intelligence system and method thereof |
US10374918B2 (en) | 2013-12-04 | 2019-08-06 | Radware, Ltd. | Method and system for configuring behavioral network intelligence system using network monitoring programming language |
CN105471726A (en) * | 2014-09-05 | 2016-04-06 | 华为技术有限公司 | Forwarding parameter passing method and equipment |
EP3190751A4 (en) * | 2014-09-05 | 2017-08-23 | Huawei Technologies Co., Ltd. | Method and device for delivering forwarding parameters |
US10320660B2 (en) | 2014-09-05 | 2019-06-11 | Huawei Technologies Co., Ltd. | Method and device for transmitting forwarding parameter |
US9411613B1 (en) * | 2015-04-22 | 2016-08-09 | Ryft Systems, Inc. | Systems and methods for managing execution of specialized processors |
US9542244B2 (en) | 2015-04-22 | 2017-01-10 | Ryft Systems, Inc. | Systems and methods for performing primitive tasks using specialized processors |
US10985990B2 (en) * | 2015-09-15 | 2021-04-20 | Huawei Technologies Co., Ltd. | Software defined topology (SDT) for user plane |
US20170126551A1 (en) * | 2015-10-31 | 2017-05-04 | Nicira, Inc. | Representation of Match Conditions in Logical Pipeline Data |
US10305725B2 (en) | 2015-10-31 | 2019-05-28 | Nicira, Inc. | Local controller agent for converting logical pipeline data |
US10476735B2 (en) * | 2015-10-31 | 2019-11-12 | Nicira, Inc. | Representation of match conditions in logical pipeline data |
US10200235B2 (en) | 2015-10-31 | 2019-02-05 | Nicira, Inc. | Distributed database structure for logical and physical network data |
WO2023138234A1 (en) * | 2022-01-20 | 2023-07-27 | 北京邮电大学 | Model management method and apparatus, networking architecture, electronic device and storage medium |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US20140241346A1 (en) | Translating network forwarding plane models into target implementation using network primitives | |
Firestone | {VFP}: A virtual switch platform for host {SDN} in the public cloud | |
Bifulco et al. | A survey on the programmable data plane: Abstractions, architectures, and open problems | |
CN110419200B (en) | Packet processor in virtual filtering platform | |
Panda et al. | {NetBricks}: Taking the V out of {NFV} | |
US10986041B2 (en) | Method and apparatus for virtual network functions and packet forwarding | |
US20140241347A1 (en) | Static translation of network forwarding plane models into target implementation in the hardware abstraction layer | |
Drutskoy et al. | Scalable network virtualization in software-defined networks | |
US8976708B1 (en) | Parameterized device models for openflow | |
US8094560B2 (en) | Multi-stage multi-core processing of network packets | |
Benvenuti | Understanding Linux network internals | |
US9118591B2 (en) | Distributed switch domain of heterogeneous components | |
Zhang et al. | HyperVDP: High-performance virtualization of the programmable data plane | |
US10909067B2 (en) | Multi-node zero-copy mechanism for packet data processing | |
US20190222504A1 (en) | Node representations of packet forwarding path elements | |
EP2959379B1 (en) | Implementing specifications related to a network forwarding plane of an electronic device having forwarding functionality | |
US10536375B2 (en) | Individual network device forwarding plane reset | |
WO2016026516A1 (en) | Software defined network controller and method for its creation | |
US11343190B2 (en) | TCAM-based load balancing on a switch | |
US9426033B2 (en) | Target mapping and implementation of abstract device model | |
US8929362B1 (en) | Capability negotiation for abstract candidate device model | |
US9716657B1 (en) | TCP connection resiliency in multipath networks | |
Abranches et al. | Getting back what was lost in the era of high-speed software packet processing | |
US11502911B2 (en) | Dynamic augmentation for functionally similar data models on network devices | |
US11252072B1 (en) | Graph-based rebinding of packet processors |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:YADAV, NAVINDRA;COHN, DANIEL TODD;REEL/FRAME:029993/0743Effective date: 20130214 |
|
STCB | Information on status: application discontinuation |
Free format text: ABANDONED -- FAILURE TO RESPOND TO AN OFFICE ACTION |