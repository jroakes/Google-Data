CN115428395A - Enhanced performance for secure multi-party computing - Google Patents
Enhanced performance for secure multi-party computing Download PDFInfo
- Publication number
- CN115428395A CN115428395A CN202280003612.9A CN202280003612A CN115428395A CN 115428395 A CN115428395 A CN 115428395A CN 202280003612 A CN202280003612 A CN 202280003612A CN 115428395 A CN115428395 A CN 115428395A
- Authority
- CN
- China
- Prior art keywords
- digital component
- digital
- selection
- value
- mpc2
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
Images
Classifications
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/08—Key distribution or management, e.g. generation, sharing or updating, of cryptographic keys or passwords
- H04L9/0816—Key establishment, i.e. cryptographic processes or cryptographic protocols whereby a shared secret becomes available to two or more parties, for subsequent use
- H04L9/085—Secret sharing or secret splitting, e.g. threshold schemes
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L2209/00—Additional information or applications relating to cryptographic mechanisms or cryptographic arrangements for secret or secure communication H04L9/00
- H04L2209/46—Secure multiparty computation, e.g. millionaire problem
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L2209/00—Additional information or applications relating to cryptographic mechanisms or cryptographic arrangements for secret or secure communication H04L9/00
- H04L2209/46—Secure multiparty computation, e.g. millionaire problem
- H04L2209/466—Electronic auction
Abstract
This document relates to selecting digital components using a secure MPC in a manner that protects the privacy of the user and protects the security of the data of each party involved in the selection process. In one aspect, a method includes receiving, by a first computing system of a secure MPC system, a digital component request and a nonce from a client device. The first computing system generates, based on the random number and a function, an array of shares comprising a bloom filter, the shares representing a user group identifier of a user group that includes a user of the client device as a member. For each of the plurality of user group identifiers, the first computing system cooperates with one or more second computing systems of the secure MPC system and uses the array to calculate a respective first secret share of the one or more user group membership condition parameters.
Description
Technical Field
This description relates to cryptography and data security.
Background
Secure multiparty computing (MPC) is a series of cryptographic protocols that prevent access to data by distributing the computation across multiple parties so that no single party can access the other party's data or intermediate computed values, but the output is only issued to the designated party. MPC computing systems typically use secret shares or other encrypted forms of data to perform computations and to protect the exchange of information between parties.
Disclosure of Invention
In general, one innovative aspect of the subject matter described in this specification can be embodied in methods that include: receiving, by a first computing system of a secure multi-party computing (MPC) system, a digital component request and a nonce from a client device; generating an array comprising shares of a bloom filter based on the random number and a function, the shares of the bloom filter representing a user group identifier of a user group that includes a user of the client device as a member; for each of a plurality of user group identifiers, cooperating with one or more second computing systems of the secure MPC system and using the array to compute a respective first secret share of one or more user group membership condition parameters representing whether the user of the client device is a member of a user group identified by the user group identifier; for each digital component of the plurality of digital components: identifying a given user group identifier corresponding to the numeric component; and calculating, by the first computing system in cooperation with each of the one or more second computing systems, a first secret share of a candidate parameter based at least on the respective first secret share of each user group membership condition parameter corresponding to a given user group identified by the given user group identifier and a second secret share of the user group membership condition parameter corresponding to the given user group identified by the given user group identifier held by each of the one or more second computers, wherein the candidate parameter indicates whether the digital component is a qualified candidate for the digital component request; generating a first secret share representing a selection result of the selected digital component based on the first secret share of the candidate parameter for each digital component and a selection value for each digital component; and sending the first secret share of the selection result to the client device. Other embodiments of this aspect include corresponding apparatuses, systems, and computer programs configured to perform aspects of the methods encoded on computer storage devices.
These and other embodiments can each optionally include one or more of the following features. In some aspects, calculating the first secret share of the user group membership condition parameter in cooperation with the one or more second computers of the second MPC system comprises calculating the first secret share of the user group membership condition parameter using one of a garbled circuit protocol or a Goldreich-Micali-Wigderson (GMW) protocol.
In some aspects, calculating the first secret share of the candidate parameter in cooperation with each of the one or more second computers comprises calculating the first secret share of the candidate parameter based on a respective secret share of the parameter for one or more additional conditions.
Some aspects include: receiving an additional random number to an additional bloom filter representing the set of blocked digital components; generating an additional array of shares representing the additional bloom filter; and cooperating with the one or more second computing systems and using the additional array to compute a first secret share of a blocking condition parameter that represents whether the digital component is blocked at the client device. The candidate parameter for the digital component is based on the blocking condition parameter.
In some aspects, the first secret share of the selection result comprises a result computed by performing a bitwise XOR operation between a secret share of the selection result and a second mask received from the client device. In some aspects, the first computing system includes a service pool including a set of processors and a load balancer to balance a computing load among the set of processors. The first computing system can include a log processor pool including a set of add-on processors that generate a snapshot based on updates to a log that includes data related to a completed digital component selection process and provide the snapshot to the service pool.
The subject matter described in this specification can be implemented in particular embodiments to realize one or more of the following advantages. Using a secure MPC process performed by two or more MPC servers operated by different parties to select a digital component based on a share of user information ensures that the MPC server or another party cannot access the user information in the clear without unauthorized collusion between MPC servers. In this way, user data privacy is protected as long as at least one MPC server is honest.
In the digital component selection process, the MPC server can select from among the qualified digital components that satisfy one or more qualifying conditions while preventing the parties from accessing the user information in the clear. Qualification conditions can include limitations and guidelines regarding how or how frequently digital components are distributed, as well as other factors. The conditions can include user group membership, frequency control, muting (e.g., user blocking), k-anonymity to prevent micro-targeting of users, and/or pacing (pacing) and budget constraints.
Since the selection of digital components is an online process that typically occurs while content is being loaded at a client device, it is important that the process be completed quickly, e.g., within a few milliseconds. The techniques described in this document improve the speed of selecting digital components by reducing the size of data transmitted between a client device and an MPC cluster, by reducing the computational resources required by the MPC cluster, and by reducing the number of round trip communications/computations performed by the servers of the MPC cluster and the size of data transmitted between the servers. The reduction in data size between the client device and the server also reduces network bandwidth consumption and battery consumption of the client device, for example, if the client device is a mobile device that operates on battery power.
A user's client device can generate a probabilistic data structure, e.g., a cuckoo filter or a bloom filter, representing a group of users that includes the user as a member, and can provide the probabilistic data structure or data representing the probabilistic data structure to a server of the MPC cluster. Using the probabilistic data structure in this manner protects user privacy and maintains data security by preventing access to the user's group membership, and reduces the size of the information provided to the MPC cluster because the probabilistic data structure is a compact representation of the data set. Data representing the probabilistic data structure can be generated and sent to the MPC server such that no party receiving only a portion of the data can access the user's user group membership without having other parts or cooperating with other MPC servers, e.g., using a secure MPC process. The reduction in data size reduces the amount of bandwidth consumed to transmit information, reduces latency in transmitting information, and reduces the amount of processing power and associated battery power required by battery-operated devices (e.g., mobile devices) to transmit information.
The MPC cluster can transmit a secret share identifying the result of the MPC cluster using the selected digital components of the secure MPC process selection. By sending secret shares of the result only for selected digital components, rather than information for all or a large set of digital components, latency and consumed bandwidth, processing power, and battery power in transmitting and receiving the result are similarly reduced. This also reduces potential leakage of confidential information for content platforms submitting select values of digital components to the MPC cluster by limiting the number of digital components providing information to the client device.
Reducing the latency of content presentation also reduces the number of errors that occur at the user device while waiting for such content to arrive. Since content typically needs to be provided and provided to mobile devices connected through a wireless network in milliseconds, reducing the latency of selecting and providing content is critical to preventing errors and reducing user frustration.
The secure MPC techniques described in this document are flexible and support different types of selection processes and/or additional selection process features such as floor (floor), tier (tier), and/or boost (boost). The secure MPC techniques described in this document enable such features while still protecting user privacy and data security. When layers are used, multiple selection processes can be performed in parallel to reduce latency in the selection of digital components, or sequentially to reduce unnecessary computations. Metrics that can be used to improve the efficiency of the digital component selection process can be aggregated and reported to appropriate parties in a manner that protects the privacy of the user.
The details of one or more embodiments of the subject matter described in this specification are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the subject matter will become apparent from the description, the drawings, and the claims.
Drawings
Fig. 1 is a block diagram of an environment in which an MPC cluster performs a secure MPC process to select digital components for distribution to client devices.
FIG. 2 illustrates an exemplary data flow within the environment of FIG. 1.
FIG. 3 is a diagram of an exemplary process for selecting digital components for distribution to client devices.
FIG. 4 is a diagram of an exemplary process for selecting digital components for distribution to client devices.
Fig. 5 is a diagram of an exemplary process for selecting digital components for distribution to client devices.
FIG. 6 is a diagram of an exemplary process for determining the highest other selection value of a digital component in a digital component selection process.
FIG. 7 is a flow diagram of an exemplary process for determining a difference between a first selection value of a real digital component selection process and a first selection value of a counter-fact digital component selection process.
FIG. 8 is a flow diagram of an exemplary process for determining whether a user is a member of a user group using a bloom filter sent with secret shares.
FIG. 9 is a block diagram of an exemplary MPC computing system.
FIG. 10 is a block diagram of an exemplary computer system.
Like reference numbers and designations in the various drawings indicate like elements.
Detailed Description
In general, this document describes systems and techniques for selecting digital components using a secure MPC in a manner that protects user privacy and protects the security of data for each party involved in the selection process. The enhancements to the selection process support multiple variations of the digital component selection process, providing flexibility to content publishers and content platforms that manage the selection of digital components while maintaining user privacy and data security. For example, the MPC cluster described in this document is capable of performing a secure digital component selection process that includes a layer, a selection value boosting, a first value selection process, a second value selection process, and/or a combination of one or more of these variations. The techniques described in this document allow for such flexibility, privacy protection, and data security while still providing the digital component within a short period of time, e.g., within milliseconds, after receiving the request, and while minimizing the size of data sent to and from the client device displaying the digital component.
The MPC cluster can also generate information, such as metrics, based on the completed selection process that can be used to further enhance future digital component selection processes. This information can be generated using a secure MPC such that user data as well as publisher and/or content platform data is not accessible without unauthorized collusion between servers and/or other parties of the MPC cluster. Information can be reported to the appropriate parties in encrypted form, e.g., as secret shares, so that only the recipient can access the information in the clear. To protect user privacy, in some embodiments, the intended recipient is able to access the information in clear text with differential privacy noise applied and/or in an aggregated form. Plaintext is text in a form that can be viewed or used without the need for a key or other decryption device or other decryption process, uncountable indicia, specially formatted, or written in code or data that includes a binary file.
In this document, some of the calculations performed by the MPC cluster on secret shares are shown as products or sums of secret share values. To increase the speed with which these calculations are performed, the multiplication can be performed in the secret shares using an AND operation, e.g., a bitwise AND, AND the addition can be performed in the secret shares using an XOR operation, e.g., a bitwise XOR. In some cases, when one plaintext integer is multiplied by a secret share representing zero or one in Z2 (i.e., the sum of the modulo-2 values of the two shares is zero or one), no multiplication or bitwise AND is required. Instead, each computing system can evaluate its share and return an integer if its share is one and zero if its share is zero.
Fig. 1 is a block diagram of an environment 100 in which an MPC cluster 130 performs a secure MPC process to select digital components for distribution to client devices 110. The MPC cluster 130 also generates information for the completed digital component selection process and provides this information to the appropriate parties.
The exemplary environment 100 includes a data communication network 105, such as a Local Area Network (LAN), a Wide Area Network (WAN), the Internet, a mobile network, or a combination thereof. The network 105 connects client devices 110, secure MPC cluster 130, publishers 140, websites 142, and content platforms, such as Supply Side Platform (SSP) 170 and Demand Side Platform (DSP) 150. The exemplary environment 100 can include many different client devices 110, secure MPC clusters 130, publishers 140, web sites 142, DSPs 150, and SSPs 170.
The website 142 includes one or more electronic resources 145. The resource 145 can be associated with a domain name and hosted by one or more servers. An exemplary website is a collection of web pages formatted in hypertext markup language (HTML) that can contain text, images, multimedia content, and programming elements such as scripts. Each website 142 is maintained by a content publisher 140, the content publisher 140 being an entity that controls, manages, and/or owns the website 142.
The resource 145 is any data that can be provided by the publisher 140 over the network 105 and that can be associated with a resource address. Resources include HTML pages, word processing documents, and Portable Document Format (PDF) documents, images, videos, and feed sources, to name a few. The resources 145 can include content such as words, phrases, pictures, etc., and can include embedded information (e.g., meta information and hyperlinks) and/or embedded instructions, such as scripts.
The client device 110 is an electronic device capable of communicating over the network 105. Exemplary client devices 110 include personal computers, mobile communication devices such as smart phones, and other devices capable of sending and receiving data over the network 105. Client device 110 can also include a digital assistant device that accepts audio input through a microphone and outputs audio output through a speaker. When the digital assistant detects a "hot word" or "hot phrase" that activates the microphone to accept audio input, the digital assistant can be placed in a listening mode (e.g., ready to accept audio input). The digital assistant device can also include a camera and/or a display to capture images and visually present information. The digital assistant can be implemented in different forms of hardware devices, including a wearable device (e.g., a watch or glasses), a smartphone, a speaker device, a tablet device, or another hardware device. The client device 110 can also include a digital media device, such as a streaming device that plugs into a television or other display to stream video to the television, a gaming system, or a virtual reality system.
The client device 110 typically includes an application 112, such as a Web browser and/or a native application, to facilitate sending and receiving data over the network 105. Native applications are applications developed for a particular platform or a particular device, e.g., for a mobile device having a particular operating system. The publisher 140 can develop and provide the native application to the client device 110, e.g., making it available for download. The Web browser can request the resource 145 from a Web server hosting the publisher's 140 website 142, for example, in response to a user of the client device 110 entering a resource address of the resource 145 or selecting a link referencing the resource address in an address bar of the Web browser. Similarly, the native application can request application content from a publisher's remote server.
Some resources, application pages, or other application content can include a number component slot for displaying a number component with the resource 145 or application page. As used throughout this document, the phrase "digital component" refers to a discrete unit of digital content or digital information (e.g., a video clip, an audio clip, a multimedia clip, an image, text, or another unit of content). The digital components can be stored electronically in the physical memory device as a single file or in a collection of files, and the digital components can take the form of video files, audio files, multimedia files, image files, or text files, and include advertising information such that the advertisement is one type of digital component. For example, the digital component may be content intended to supplement a web page, application content (e.g., an application page), or other resources displayed by the application 112. More specifically, the digital components may include digital content related to the resource content, for example, the digital components may relate to the same subject matter as the web page content, or to related subject matter. Thus, the provision of digital components can supplement and generally enhance web page or application content.
When application 112 loads a resource (or application content) that includes one or more slots for digital components, application 112 can request digital components for each slot. In some implementations, the digital component slot can include code, e.g., one or more scripts, that when processed by the application 112, cause the application 112 to request the digital component for display to a user of the client device 110. As described below, the application 112 can request digital components from the MPC cluster 130 and/or one or more SSPs 170.
Some publishers 140 use SSPs 170 to manage the process of obtaining digital components for digital component slots of their resources 145 and/or applications 112. The SSP 170 is a hardware and/or software implemented technology platform that automates the process of obtaining digital components for resources and/or applications. Each publisher 140 can have a corresponding SSP 170 or SSPs 170. Some publishers 140 may use the same SSP 170.
The digital component provider 160 can create (or otherwise publish) digital components that are displayed in the digital component slots of the publisher's resources 145 and applications 112. For example, the digital component provider 160 can create a digital component that includes content related to the digital component provider 160. In a particular example, a digital component of a product manufacturer can include content related to a product.
The digital component provider 160 can use the DSP 150 to manage the provisioning of its digital components for display in the digital component slots. DSP 150 is a technical platform implemented in hardware and/or software that automates the process of distributing digital components for display with resources and/or applications. The DSP 150 is capable of interacting with a plurality of SSPs 170 on behalf of a digital component provider 160 to provide digital components for display with resources 145 and/or applications 112 of a plurality of different publishers 140. In general, DSP 150 is capable of receiving a request for a digital component (e.g., from SSP 170), generating (or selecting) a selection value for one or more digital components created by one or more digital component providers 160 based on the request, and providing data related to the digital component (e.g., the digital component itself or code that enables the digital component to be downloaded) and a selection parameter to SSP 170. The selection value can indicate an amount that the digital component provider 160 is willing to provide to display with or interact with the digital component. The SSP 170 can then select a digital component for display at the client device 110 and provide the client device 110 with data that causes the client device 110 to display the digital component, e.g., by providing the digital component or code that enables downloading of the digital component. As described in more detail below, MPC cluster 130 can select digital components for client devices 110 to display in a manner that protects user privacy.
In some cases, it may be beneficial for a user to receive digital components related to web pages, application pages, or other electronic resources that the user has previously visited and/or interacted with. To distribute such digital components to users, users can be assigned to groups of users, for example, user interest groups of users interested in the same or similar topics, groups of similar users, or other group types involving similar user data. A user can be assigned to a group of users when the user accesses a particular resource or performs a particular action at the resource (e.g., interacts with a particular item displayed on a web page or adds an item to a virtual shopping cart). The user group can be generated and updated by the digital component provider 160. That is, each digital component provider 160 is able to assign a user to its group of users when the user accesses the electronic resources of the digital component provider 160. The user group can also be created and/or updated by the content platform (e.g., by DSP 150 and/or SSP 170).
To protect user privacy, for example, the user's group membership can be maintained at the user's client device 110 through one of the applications 112, the operating system of the client device 110, or another trusted program, rather than through the digital component provider, the content platform, or other party. In a particular example, a trusted program (e.g., a Web browser or operating system) can maintain a list of user group identifiers ("user group list") for users using the Web browser or another application (e.g., users logged into the browser, application, or client device 110). The user group list can include a user group identifier for each user group that includes the user as a member. The digital component provider 160 or the content platform that creates the user group can specify the user group identifier for its user group. The user group identifier of the user group can be a description of the group (e.g. a gardening group) or a code representing the group (e.g. a non-descriptive alphanumeric sequence). The user group list of the user can be stored in a secure store at the client device 110 and/or can be encrypted when stored to prevent others from accessing the list.
When the application 112 displays a resource (e.g., a web page), application content, or digital component associated with the digital component provider 160, the resource, application content, or digital component can request that the application 112 add one or more user group identifiers to the user group list. In response, the application 112 can add the one or more user group identifiers to the user group list and securely store the user group list. For example, a web page that a user selects to view more information about a particular item can add the user to a group of users related to the particular item.
In some embodiments, the MPC cluster 130 can use the user group membership of the user to select digital components that may be of interest to the user or that are otherwise beneficial to the user/user device. For example, such digital components or other content may include data that improves the user experience, improves the operation of the user device, or is beneficial to the user or client device 110 in some other way. However, the user group identifier of the user's user group list can be provided and used to select digital components in a manner that prevents the computing systems MPC1 and MPC2 of the MPC cluster 130 from accessing the user group identifier of the user in the clear, thereby protecting user privacy when using the user group membership data to select digital components. The MPC cluster 130 can also use other conditions to select digital components, as described in more detail below.
The secure MPC cluster 130 includes two computing systems MPC1 and MPC2 that perform secure MPC processes to select digital components for distribution to a user's client device based on the user's group membership, but do not access group membership or other user information or signals derived from such user information in the clear. Although the example MPC cluster 130 includes two computing systems, more computing systems can be used as long as the MPC cluster 130 includes more than one computing system. For example, MPC cluster 130 can include three computing systems, four computing systems, or another suitable number of computing systems. Using more computing systems in the MPC cluster 130 can provide more security, but can also increase the complexity of the MPC process. Each computing system can be a server or other suitable type of computer. An exemplary architecture of an MPC computing system is shown in fig. 9.
Computing systems MPC1 and MPC2 can be operated by different entities. In this manner, each entity may not have clear text access to the user's group membership, or other user information, or signals derived from such user information. For example, one of computing systems MPC1 or MPC2 can be operated by a different trusted party than the user, publisher 140, DSP 150, SSP 170, and digital component provider 160. For example, an industry group, government group, or browser developer may be able to maintain and operate one of computing systems MPC1 and MPC2. Other computing systems can be operated by a different one of the teams so that a different trusted party operates each computing system MPC1 and MPC2. Advantageously, different parties operating different computing systems MPC1 and MPC2 may not have the incentive to collude to compromise user privacy. In some embodiments, computing systems MPC1 and MPC2 are architecturally separate and are monitored so as not to communicate with each other outside of performing the secure MPC process described in this document.
Each computing system MPC1 and MPC2 is capable of storing digital components (e.g., creatives of digital components), select values of the digital components, and other information of the digital components. For example, computing systems MPC1 and MPC2 can cache selection values previously received from SSP 170 and/or DSP 150 as part of a previous digital component selection process or otherwise provided to computing systems MPC1 and MPC2, e.g., pre-provided for use in the digital component selection process. In this manner, the MPC cluster 130 is able to use the selection values to select digital components for distribution to the client devices 110 in response to future digital component requests received from the client devices 110. In this document, the digital components that are stored by the MPC cluster 130 for selection values and other information for the digital component selection process can be referred to as stored digital components. However, the digital components themselves are not necessarily stored by the MPC cluster 130. Instead, the MPC cluster 130 can store data for each stored digital component, e.g., code that references a network location from which the digital component can be downloaded. In some embodiments, the digital components themselves are stored and returned directly to the application 112 by the MPC cluster 130. Such an implementation reduces the need for the application 112 to extract the digital component and/or other information of the digital component in additional requests that may consume the battery and bandwidth of the device and may leak additional signals for tracking the device by a server hosting the digital component itself.
For each stored digital component, each computing system MPC1 and MPC2 is capable of storing a selection value or vector of values that can be used by the computing systems MPC1 and MPC2 to determine a selection value for the digital component. Each computing system MPC1 and MPC2 is also capable of storing condition data for each digital component, which condition data defines the condition(s) that the digital component must satisfy as a qualified candidate for a given digital component selection process. The stored digital components can have zero or more corresponding conditions.
One exemplary condition is that the user to which the selected digital component is to be provided is a member of a user group corresponding to the stored digital component. This condition can be referred to as a user group membership condition. In this example, computing systems MPC1 and MPC2 are capable of storing, for the stored digital components, a set of one or more user group identifiers corresponding to the digital components. These user group identifiers identify the user groups for which the stored digital components can be provided. That is, the stored digital components are only candidates for a digital component selection process that is performed to select a digital component to be provided to a user that is a member of at least one of the user groups identified by the set of one or more user group identifiers for the stored digital components.
Another exemplary condition for a stored digital component is an upper frequency limit condition that indicates that a digital component or a particular category of digital components can only be provided to the same user a maximum number of times in a given duration. Another exemplary condition of a digital component is a blocked digital component condition indicating that the digital component has been blocked, e.g., muted, by a user. For these example conditions, computing systems MPC1 and MPC2 are capable of receiving, from storage, for each of a plurality of users, a probabilistic data structure, e.g., a cuckoo filter or a bloom filter, that represents a digital component that cannot be provided to the user. For example, the probabilistic data structure can represent a universal identifier of a digital component that is blocked directly by a user or that is blocked by a user due to exceeding the frequency with which the digital component is displayed to the user during a given duration.
Computing systems MPC1 and MPC2 are capable of receiving the probabilistic data structure from a user's client device 110, e.g., to prevent computing systems MPC1 or MPC2 from receiving the probabilistic data structure in an encrypted form of the clear access identifier. For example, an application 112 running on the user's client device 110 can generate a bloom filter that represents an identifier for a blocked digital component that is blocked due to an upper frequency limit or blocked by the user. The application 112 can then provide data to each computing system MPC1 and MPC2 that enables the computing systems MPC1 and MPC2 to cooperatively query the bloom filters using a secure MPC process to determine whether a given digital component is blocked for a user. Computing systems MPC1 and MPC2 use the secure MPC process to compute a secret share of the blocked digital component condition. An exemplary process for generating and querying a bloom filter is described with reference to FIG. 8.
In some implementations, the identifier for the blocked digital component can be included in the same probabilistic data structure as the subscriber group identifier and queried using a different hash function. However, the target false positive rate for blocked digital components can be lower than the false positive rate for the subscriber group identifier. Thus, fewer hash functions than user group identifiers can be used to generate and query bloom filters for blocked digital components. To reduce the data size of the bloom filter for the blocked digital component, the user group identifier can be represented by a different bloom filter than the blocked digital component. This reduces latency in sending the bloom filter over the network, reduces bandwidth consumed by sending the bloom filter, and reduces battery power usage for sending the bloom filter.
Another exemplary condition for the stored digital components is a pacing condition that adjusts the pace of the distribution of the digital components over a duration of time. Computing systems MPC1 and MPC2 may be capable of storing data indicative of a total number of times that a digital component may be capable of being provided over a duration of time and/or a maximum budget for the digital component over the duration of time. Computing systems MPC1 and MPC2 can use this information to pace the frequency at which digital components can be candidates for the digital component selection process based on the conditions (e.g., all conditions for digital components that will have to be satisfied for the digital component to be a candidate). In some embodiments, computing systems MPC1 and MPC2 can implement feedback controllers, for example, proportional-integral-derivative (PID) controllers that use secret shares to adjust the cadence of stored digital components with a pacing condition.
In this example, the computing systems MPC1 and MPC2 are capable of storing set points for PID controllers of digital components and maintaining measured variables for PID controllers of digital components. Typically, a PID controller is a feedback controller that uses an error value, which is the difference between a target set point and a measured variable, to determine an output that drives the measured variable toward the set point. In the context of adjusting the pace at which digital components are distributed to client devices, the set points for activities can be impressions, interactions, conversions, and/or resource exhaustion rates (e.g., budget payout rates). Similarly, the measured variables can be impressions, interactions, conversions, and/or resource exhaustion rates for a given duration. The computing systems MPC1 and MPC2 are also capable of storing trim parameters for each PID controller. The set points, measured variables and trim parameters can be stored in secret shares (each computing system MPC1 and MPC2 stores a corresponding share of each parameter) or in clear text, depending on the target privacy/data security.
Another exemplary condition is a k-anonymous condition. The k-anonymity condition can include a k-anonymity rule that requires that the digital component be qualified (or will be selected) for distribution to at least k users in a given duration. The concept of k-anonymity ensures that data for a particular user is indistinguishable from a threshold number k of other users. The system can enforce K-anonymity rules, for example, by ensuring that particular digital components are distributed to client device 110 in response to requests for one or more digital components, and that the same digital components may have or have been displayed to a group of at least K users or by at least K applications 112 within a particular time period. In some embodiments, each of the k applications 112 to which the digital component may have or had been distributed must be for a different user. In this example, computing systems MPC1 and MPC2 are capable of storing a value k for a digital component and maintaining a number of users to whom the digital component may have been distributed.
Determining the number of users of the digital component that may have been displayed can include performing a de-facto digital component selection process in parallel with each actual digital component selection process. In this factual digital component selection process, all digital components can be candidates if they satisfy all conditions except the k-anonymous condition. If a digital component is selected for at least k users or applications 112 in the de-facto digital component selection process, the digital component will be displayed to k users if it is not for a k-anonymity condition. Once this occurs, digital components that satisfy the k-anonymity condition can be included in the actual digital component selection process (assuming other conditions of the digital components, if any, are satisfied) that does not include digital components that have an unsatisfied k-anonymity condition.
In some embodiments, each computing system MPC1 and MPC2 stores information for a digital component in a data structure that maps the digital component and its corresponding information to a set of context signals. For example, each digital component can be eligible for display in a presentation environment having resources and/or applications that include a set of context signals. The context signal can include, for example, a topic of the resource, keywords found in the resource, a resource locator for the resource, a geographic location of the client device 110, a spoken language setting of the application 112, a number of digital component slots of the resource, a type of digital component slot, and/or other suitable context signals. In addition, the digital component can have a plurality of corresponding selection values, one for each set of context signals. Using such a data structure enables computing systems MPC1 and MPC2 to identify digital components that are eligible for the digital component selection process. Computing systems MPC1 and MPC2 can then use the conditions to identify digital components from these qualified digital components that are actual qualified candidates for selection in the digital component selection process. The set of context signals used in determining whether a digital component is eligible can be in the form of a lookup key that enables computing systems MPC1 and MPC2 to use the context signals requested by the digital component to lookup the eligible digital component.
When a digital component is associated with a corresponding subscriber group identifier that identifies a qualified subscriber group for the digital component, a look-up table (LUT) can be used to store the information. The use of a LUT can provide some performance advantages, but other suitable data structures can also be used. The LUT maps the context signal or a lookup key derived from the context signal to a set of digital components, such that the set of digital components is eligible for display and/or selection of a value or vector for which is eligible, subject to other conditions described in this document. In this way, the computing systems MPC1 and MPC2 are able to store multiple selection values for each digital component, e.g., one selection value for each set of context signals.
In some implementations, the lookup key is a hash-based message authentication code (HMAC) of the context signal. For example, the lookup key can be an HMAC (URL, HMAC (language), where the parameter URL is the URL of the digital component and the resource for which the selection value qualifies, the parameter language is the specified spoken language of the application 112 for which the digital component and the selection value qualifies, and the parameter location is the geographic location for which the digital component and the selection value qualify. If the context signal of the numeric component request matches these parameters, the numeric component and the selection value mapped to the lookup key are eligible for a numeric component selection process for selecting a numeric component in response to the request. Other context signals can be used in addition to or instead of the URL, location, and language.
To reduce the amount of bandwidth and the amount of latency consumed by transmitting digital component requests over network 105, application 112 can use the same HMAC to compute the lookup key instead of sending context signals to computing systems MPC1 and MPC2. This also reduces the amount of battery consumed by client device 110 and the amount of data received by each computing system MP1 and MPC2.
In some embodiments, for example, a two-level LUT table is used when the digital component is conditioned on user group membership of the user. The first level can be keyed by a Request Key (UG _ Request _ Key). The UG Request Key can be a lookup Key in the form of a composite message based on a set of context signals, e.g., a set of context signals requested by a digital component (e.g., URL, location, language, etc.) or a set of context signals that the digital component qualifies for distribution. That is, the first level LUT can be keyed based on a set of context signals. The Key of the first level can be, for example, a hash of the UG _ Request _ Key using a hash function such as SHA 256. The key can be truncated to a specified number of bits, for example, 16 bytes, or another suitable number of bits. The value of each Key UG _ Request _ Key in the first level LUT can indicate a row of the second level LUT that includes data of the digital component that is eligible for a digital component Request of the context signal that includes the UG _ Request _ Key. An exemplary first stage LUT is shown in table 1 below.
Key(s) | Value of |
SHA256(UG_Request_Key) | Row\8230 |
… | Row \8230 |
TABLE 1
The second stage LUT can be keyed based on a combination of the subscriber group Request Key UG _ Request _ Key and the subscriber group identifier in the first stage LUT. In some embodiments, the second level LUT can be an array or other suitable data structure. Each row in the second level LUT can be used for a particular selection value (or vector of values) for a particular digital component. For example, the DSP 150 can submit different selection values for the same digital component, where each selection value is for a different set of context signals and/or a different user group identifier. Thus, the selection value of a digital component can vary based on the context and user group membership of the user who is performing the digital component selection process.
The DSP 150 or digital component provider 160 can associate-e.g., link or map-the digital components to a user group to which the DSP 150 or digital component provider wants to display the digital components. For example, DSP 150 may want to display fly-fishing related digital components to men who have shown interest in fly fishing. In this example, DSP 150 can provide data to MPC cluster 130 indicating that the numeric component corresponds to a user group identifier for a user group that includes men who have shown an interest in fly fishing.
In some embodiments, the Key of a row in the second level LUT can be a hash or code generated based on a combination of the user group Request Key UG _ Request _ Key and the user group identifier of the digital component of the row. For example, the key can be a combined HMAC, which can be represented as an HMAC SHA256 (UG _ Request _ Key, UG _ id). The subscriber group identifier ug _ id can be based on an internal subscriber group identifier sum for the subscriber group (e.g. congestion)With the DSP, SSP, or digital component provider of the user group) of the user group. For example, the user group identifier ug _ id can be a digital digest of the eTLD +1 for the owner domain of the user group and the owner's internal user group identifier. Tld + 1 is the valid top level field (tld) plus one level more than the common suffix. An exemplary eTLD +1 is "example.com", where ". Com" is the top-level domain. The ug id can be truncated to 16 bytes or another suitable data size.
Continuing with the previous fly fishing example, the second level lookup Key of a row comprising information of the digital components to be displayed to users in the male fly fishing group can be a combination of the user group Request Key UG _ Request _ Key and the user group identifier UG _ id of the male fly fishing group. Since the digital components can be presented in different contexts, the second level lookup table can include multiple rows for the digital components associated with the user group identifier UG _ id of the male fishing group, each row having a different user group Request Key UG _ Request _ Key and a different value.
The values for each row of the second level LUT can be selection values (or vectors of values) for the digital components and other data for the digital components, e.g., metadata identifying the digital components or network locations from which the digital components can be downloaded, etc. In some implementations, the row can contain the digital component itself ready to be presented by the application 112, for example, in a Web package format.
The value can be a digital component information element dc _ information _ element, which can be a byte array with a selection value and metadata. The byte array can have a particular format that applications 112 or trusted programs of client devices 110 and computing systems MPC1 and MPC2 can parse to obtain selection values and metadata. In some implementations, the digital component information element can include the digital component itself. An exemplary second-level LUT is shown in table 2 below. When a vector is used to determine the selection value, the selection value can be replaced by the vector in table 2.
Key with a key body | Value of |
HMAC(UG_Request_Key,UG_ID) | { selection value, metadata } |
… | … |
TABLE 2
The second level LUT maps the selection value to a particular digital component, a particular user group identifier UG _ id, and a particular set of context signals defined by the first level lookup Key UG _ Request _ Key. By doing so, the second level LUT indicates a particular context of the digital component slot for which the selected value of the digital component qualifies. This allows the DSP 150 or digital component provider 160 to specify different selection values for the same digital component for different contexts defined by the context signal and the user's group membership. When a digital component request is received indicating that the user to which the digital component is to be displayed is a member of a particular user group identified by a particular user group identifier ug id and that the digital component is to be displayed in a particular context defined by the context signal of the first level lookup key, any digital component in the second level LUT having a matching user group identifier and a matching selection value of the first level lookup key is a candidate for being selected for distribution in response to the request.
Further to the description throughout this document, a user may be provided with controls (e.g., user interface elements with which the user can interact) that allow the user to select as to whether and when the systems, programs, or features described herein may enable the collection of user information (e.g., information about the user's social network, social actions or activities, profession, the user's preferences, or the user's current location) and whether to send content or communications from a server to the user. In addition, certain data may be processed in one or more ways before it is stored or used, so that personally identifiable information is removed. For example, the identity of the user may be processed such that no personally identifiable information can be determined for the user, or the geographic location of the user for which location information is obtained may be generalized (such as to the city, zip code, or state level) such that a particular location of the user cannot be determined. Thus, the user may have control over what information is collected about the user, how the information is used, and what information is provided to the user.
FIG. 2 illustrates an exemplary data flow within the environment 100 of FIG. 1. The description includes two types of selection values: a selection value conditioned on sensitive user information, such as user group membership or other business sensitive information, or a selection value conditioned on a parameter whose change in value can allow an unscrupulous party to infer sensitive information, or a "conditional selection value"; and a selection value that is not conditioned on sensitive information, or an "unconditional selection value". To protect user privacy, the condition of the "conditional select value" is evaluated within MPC cluster 130, rather than SSP 170 or DSP 150, to determine whether the "conditional select value" is a candidate for the content selection process.
This architecture allows the MPC cluster 130 to protect user privacy and business confidential information, proving its trustworthiness to application providers, such as the provider of the application 112. In this example, the MPC cluster 130 relies on a secure two-party computing (2 PC) architecture that applies cryptographic techniques to ensure that if at least one of the two computing systems of the MPC cluster 130 is honest, there is no leakage of confidential user data or business confidential information. If the MPC cluster 130 includes more than two computing systems, the current MPC protocol can be extended or other MPC protocols can be used.
The MPC cluster 130 runs a secure 2PC protocol to evaluate and apply conditions for selecting candidate digital components, implements a selection process to select digital components based on selection values, and receives impression notifications to update parameters on which those conditions depend. All of these processes can be done using secret share techniques. The protocol is described in detail with reference to fig. 3.
In stage A, the application 112 sends a request for a digital component to the MPC cluster 130, for example, in cooperation with a triggering element from a content platform such as SSP 170. The application 112 can include multiple requests for digital components together as one combined request to extract multiple digital components. The MPC cluster 130 can then service each of the combined requests independently or make one or more selection decisions in its entirety. In this example, the request is for a single digital component and includes a request for a digital component selected based on the sensitive information or a digital component selected without the sensitive information. The MPC cluster 130 can respond to the request by selecting a particular digital component that corresponds to a particular selection value from among a set of selection values that each map to a corresponding particular digital component. These selection values can be selection values previously cached or otherwise stored at MPC cluster 130 and/or selection values generated by a platform such as DSP 150 or SSP 170, just-in-time (JIT) selection values. The JIT selection value is generated directly in response to need and improves efficiency and reduces waste because the selection value is only generated when the digital component is needed. For example, a JIT selection value can be generated when a digital component slot becomes available-as indicated by receipt of a request for a digital component. Thus, the MPC cluster 130 is able to select a digital component from a set of digital components that includes the stored digital components whose information is stored at the MPC cluster 130 and the digital component whose JIT selection value is received for the current digital component request.
In some implementations, two or more vectors can be used to determine the selection value of the digital component. The MPC cluster 130 can store, for a digital component, a first vector of values that can be used to determine a selection value for the digital component. The first value vector can be specific to one or more user groups, for example, when a digital component is selected for a user that is a member of the one or more user groups, can be used to determine a selection value for the digital component. Thus, the first value vector can also be referred to as a user group-based vector. The user group-based vector can include a plurality of elements spanning two or more dimensions, and each element can represent a particular feature of the digital component presentation opportunity. For example, the user group-based value vector can include elements for a geographic location or region, a spoken language, an age or age range, a particular URL of a Web page or other electronic resource, a particular product or service, whether a digital component slot is above or below a fold, a type of digital component slot, a size of a digital component slot, a number of digital component slots on an electronic resource, a time of day, a Web attribute identifier, and/or other suitable characteristics of a digital component presentation opportunity. In some embodiments, for example, embodiments employing neural networks, the user group-based value vector can be an embedding of the user group in some abstract vector space.
The value of each element can reflect an amount by which the selected value of the digital component is increased or decreased based on the current digital component presentation opportunity having a characteristic corresponding to the element. For example, if the DSP 150 wants to display digital components to users of atlanta rather than dallas, the value of the element for atlanta can be a positive value above the value one, while the value of the element for dallas can be a positive value below one, such as zero or a negative value. As described in more detail below, the values of the user group-based vector can be part of a vector dot product calculation to determine the selected values of the digital components.
The request contains information used in the digital component selection process, including potentially sensitive information, such as a user group identifier for the user group to which the application 112 is mapped or otherwise associated, and insensitive information, such as a context signal from the application 112 regarding the context of the digital component to be rendered and/or displayed. As described in further detail below, the design of system 110 improves protection against potentially sensitive or confidential user data.
The trigger element can be, for example, a tag that detects the presence of a digital component slot within an internet location accessed by the application 112. The trigger element can be placed at, for example, an internet location, and can notify application 112 of the presence of a digital component slot for which a digital component should be requested.
In stage B, MPC cluster 130 transmits a request for digital components based on insensitive information, such as context signals, to SSP 170. This request is referred to as a "context request". The context request can contain various context signals and non-sensitive user information collected directly by the internet location (e.g., content publisher) that triggered the request for the digital component. For example, the context signal can include analytics data, language settings, and other data that help the content publisher provide a good user experience. However, the context request provided to SSP 170 does not include sensitive information, such as a user group identifier.
In stage C, SSP 170 forwards the context request to one or more DSPs 150. In this particular example, for simplicity, SSP 170 forwards the context request to a single DSP 150. For example, SSP 170 can forward the context request to DSP 150. In this example, the DSP 150 has a digital component and a selection value mapped to the digital component, or can use a context signal to determine the selection value of the digital component.
In stage D, the one or more DSPs 150 return a selection value in response to a context request. For example, DSP 150 returns one or more select values that map to digital components in response to a context request. DSP 150 can return any number of select values in response to a context request. In some embodiments, DSP 150 can additionally return a selection value in response to a digital component request based on sensitive information, such as user group information. These selection values are "conditional selection values" because they are conditioned on sensitive information, and therefore conditioned on the MPC cluster 130 receiving a request that includes sensitive information that matches the sensitive information that the selection value is conditioned on. For each selection value provided by DSP 150, DSP 150 includes information such as a time-to-live (TTL) parameter, i.e., the maximum time span over which MPC cluster 130 can cache the selection value. This TTL parameter enables MPC cluster 130 to cache select values received from DSP 150. In some embodiments, without the TTL parameter, the MPC cluster 130 does not cache the received selection values, but will discard the selection values after they have been used in the selection process, e.g., in the selection process corresponding to the digital component requests transmitted in stages a, B, and C.
When the vector is used to determine the selection value, the DSP 150 can generate and return a second vector of values. The DSP 150 can generate a second vector of values based on context signals requested by the digital components transmitted in stages B and C. The second vector can be referred to as a context vector. The context vector can include identical elements corresponding to identical features of the user group-based vector. However, the DSP 150 can determine the value of the context vector for the current digital component request based on the context signal of the digital component request. Instead, the values of the user group-based vector of the DSP 150 are stored as the MPC cluster 130 and are determined in advance, for example, based on the user group(s) corresponding to the user group-based vector.
For each DSP 150 that provides a context vector, mpc cluster 130 can determine a selection value for each stored digital component of DSP 150 by determining the dot product of the user-group-based vector and the context vector provided by DSP 150. If DSP 150 has multiple user-group-based vectors stored by MPC cluster 130, e.g., each vector for a different digital component, MPC cluster 130 determines the dot product of the context vector and the user-group-based vector for each user-group-based vector.
In some implementations, the third vector can be used based on a user profile of the user for whom the digital component request was submitted. This vector can have the same dimensions and characteristics as the other vectors, but with values based on the user profile of the user.
For example, the value for the location element of austin in the user profile vector can have a positive value if the user is in austin, or a negative or zero value if the user is not in austin; if the publisher content currently displayed to the user is highly relevant to austin, then the value for the same location element in the context vector can have a positive value; if the digital component is related to Austin, the value of the same location element in the user group based vector for the digital component is positive. To calculate the dot product of three vectors, the system MPC is calculated 1 And MPC 2 First among the corresponding elementsElement-by-element multiplication, each corresponding element from each of the three vectors, and then summing the results. For example, assume that the three vectors are each V 1 ＝{v 1,1 ...v 1,n }、V 2 ＝{v 2,1 ...v 2,n V and 3 ＝{v 3,1 ...v 3,n the dot product among the three vectors will be
In stage E, SSP 170 applies the content selection rule to the digital component corresponding to the conditional selection value. As described above, these conditions can be based on user group identifiers, frequency control, blocked (e.g., muted) digital components, pacing, and/or k-anonymity.
In stage F, the MPC cluster 130 updates its cache with the received cache-enabled JIT select value (i.e., with a TTL value). In addition, the MPC cluster 130 applies selection rules, such as user group membership rules, frequency control, pacing rules, and rules to prevent a particular user from accurately casting onto all selection values received in stage E and onto previously cached selection values, to select valid candidates for the selection process. The rules can include, among other factors, restrictions and guidelines regarding the manner or frequency of distribution of the digital components. The rules include frequency control, muting, resource consumption, and pacing constraints. In some embodiments, JIT digital components with conditions evaluated by the MPC cluster 130 can be ignored for the current digital component selection process. For example, ignoring these digital components for the current selection process can provide performance benefits, such as reducing the latency of selecting and providing digital components. The MPC cluster 130 then runs a final selection process among all of the qualified candidates, selects a winning selection value, and then returns data for the digital component mapped to the winning selection value to the application 112 in response to the digital component request.
In stage G, the digital components mapped to the winning selection values are rendered by the application 112. The application 112 then provides an impression notification to the MPC cluster 130. The impression notification includes data that allows the MPC cluster 130 to update information related to updated parameters that allow the MPC cluster 130 to enforce selection rules for future digital component requests received, for example, in subsequent occurrences of stage a. In some implementations, the application 112 may send the impression notification G to the MPC cluster 130 by loading on top of the future component request a to reduce the number of network communications and battery/bandwidth consumption of the mobile devices, as well as the processing/computational cost of the MPC cluster 130.
FIG. 3 is a swim lane diagram of an exemplary process 300 for selecting digital components for distribution to a client device. The operations of process 300 can be implemented, for example, by client devices 110, computing systems MPC1 and MPC2 of MPC cluster 130, and DSP 150. The operations of process 300 can also be implemented as instructions stored on one or more computer-readable media, which may be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of process 300. Although the process 300 and the other processes below are described in terms of two computing system MPC clusters 130, MPC clusters having more than two computing systems can also be used to perform similar processes. Further, the operations of procedure 300 can be implemented by SSP 170.
The exemplary process 300 can include variations such as layers, promotions, a first value selection process (e.g., a first price auction), a second value selection process (e.g., a second price auction), and a reserve price. Each of these variations is described with reference to fig. 3 to 5.
Generally, the boost is the amount by which the selection value of the digital component is adjusted. For example, when a digital component is selected for display with one of the publisher's resources 145 or application content, the content publisher can instruct the SSP 170 to give a specified amount "x" of boost to a particular DSP 150. If the DSP 150 submits the selection value "y," the selection value used in the digital component selection process will be x + y. However, if a digital component is selected, the DSP 150 will only be required to provide an amount no greater than y during the first or second selection values. In process 300, MPC cluster 130 can apply a boost to the selection value based on information provided by SSP 170. For example, each SSP 170 can provide information that maps boosts to DSP 150 and publisher 140 pairs. That is, the information can indicate that the selection value for a particular DSP should be boosted a particular amount for the digital component selection process that is selecting a digital component for display with the content of a particular publisher. In some embodiments, the SSP/publisher is able to support finer-grained level promotion. For example, for each lookup key (e.g., for each set of context signals), the SSP/publisher can specify the promotion.
The main difference between the first value selection process and the second value selection process is the clearing amount of the selected digital component. The clearing amount is the amount that needs to be provided by DSP 150 to publisher 140 and/or SSP 170 to display the digital components. The same digital components will be selected using both processes. In a first value selection process, the DSP 150 will be required to provide the issuer 140 and/or SSP 170 with an amount equal to the selection value submitted by the DSP 150. In the second value selection process, DSP 150 would instead be required to provide an amount based on the next highest selected value. If a layer is used with the second select value process, the next highest value will be the next highest value in the same layer as the selected digital component. If no such candidate number component exists in the same layer, the next highest value can be the minimum value of the number component selection process.
The selection value reserve can indicate a minimum selection value that the publisher 140 is willing to accept to display the digital component. The publisher 140 can specify a selection value reserve price for various DSPs 150, for each category of digital component (e.g., one reserve price for a digital component associated with automobiles and another reserve price for a digital component associated with gardening), for each digital component provider 160, for each brand, for each page on the publisher's site, for each digital component slot, for a group of digital component slots, and/or for other types of digital component groups. In some embodiments, SSP 170 can set a reserve price on behalf of publisher 140 in advance, or for each digital component request of, for example, level A.
The MPC cluster 130 can store selection values and selection criteria for future digital component requests received from the client devices 110. For each digital component, the DSP 150 can also upload additional data, such as metadata, for the digital component. The additional information for the digital component can include one or more conditions (and parameters of the condition (s)) that must be satisfied in order to include the digital component in the digital component selection process. For example, the additional information can include one or more user group identifiers for user groups corresponding to the digital components.
The additional information for the digital component can include a context selection signal indicating a context for which the digital component is eligible, e.g., a location of the client device 110, a spoken language selected for the application 112, a URL of a resource that can render the digital component, and/or an excluded URL of a resource that cannot render the digital component. This additional information of the digital component can also identify the digital component, for example, using the unique identifier, a field from which the digital component can be obtained, and/or other suitable data for the digital component. The additional information can be included as metadata for the digital component.
In some embodiments, the MPC cluster 130 caches or otherwise stores selection values, selection criteria, and other information for digital components provided to the MPC cluster 130 for digital component requests. In this example, the context signals for the digital component and the selection value can include context signals included in the digital component request. As described above, the selection values and metadata can be stored in a two-level LUT.
In some embodiments, DSP 150 can provide a user group-based vector of values for the digital components rather than providing statically selected values for the digital components. In such an example, a user group-based value vector can be stored instead of selecting a value.
The client device 110 identifies a set of user group identifiers (306). The set of user group identifiers can be user group identifiers of user groups that include the user as a member. For example, the set of subscriber group identifiers can be subscriber group identifiers in a subscriber group list. The application 112 rendering the content or the trusted program can identify the set of user group identifiers, for example, by accessing the user group list from a secure store of the client device 110.
The client device 110 generates a probabilistic data structure (308). To securely and efficiently generate digital component requests based on sensitive information, the application 112 can use a probabilistic data structure, such as a cuckoo filter or a bloom filter. In this example, the probabilistic data structure is a cuckoo filter. An example of using a bloom filter is described with reference to fig. 8. Typically, a cuckoo filter includes an array of buckets, where each bucket is capable of holding b fingerprints. A fingerprint of an item is a bit string derived from a hash of the item. The cuckoo filter uses n hash functions, which allow items to be placed in n different buckets in any one of the b locations. Typically, cuckoo filters are identified by the number of fingerprints in each bucket and the number of buckets. For example, a (2, 4) cuckoo filter has 2 buckets, and each bucket in a cuckoo array is capable of storing up to 4 fingerprints. Thus, the total capacity of the cuckoo filter is 2 × 4 or 8 fingerprints.
Depending on the configuration of the cuckoo filter, items can be inserted into the cuckoo filter in one of N possible positions, e.g., N = 2. The application 112 determines all possible locations of the item to be inserted using N pseudo-random functions (PRFs) parameterized by the user group identifier or an identifier from a set of blocked identifiers and either of two random variables generated by the application 112. For example, assume that the two random variables generated by the application 112 are rand _ var1a and rand _ var1b. In some embodiments, the application 112 and the MPC cluster 130 agree on a PRF in advance, where PRF (x, y) e [0,2 ∈ PRF (x, y) ∈ k -1]Where k is the number of bits in each item in the bucket of the cuckoo filter.
Each position of the cuckoo filter can be occupied by a user group identifier or by a blocked identifier, or be empty. The blocked identifier is an identifier that the application 112 is blocking digital components, for example, based on frequency control, or an identifier that the user selects to block digital components of a group of users. The application 112 can generate a cuckoo filter table whose elements are PRF (ug _ id, rand _ var1 a), PRF (blocked _ uid, rand _ var1 b), and 0, where ug _ id is an identifier of the user group generated by applying HMAC to the label of the user group based on the domain of the content provider, blocked _ uid is an identifier from the blocked set of identifiers, and 0 represents an empty item. The procedure is repeated for all subscriber group identifiers. In some embodiments, the same probabilistic data structure, e.g., a cuckoo filter or a bloom filter, can store both the user group identifier and the blocked identifier. In other embodiments, the subscriber group identifier and the blocked identifier are stored in a dedicated probabilistic data structure.
The application 112 can generate the vector B based on a cuckoo filter table generated for the user group identifier and/or the blocked identifier. Each value B in the vector B i Can be represented as B i ＝(A i PRF (rand _ var2, i)) mod p, where a is the cuckoo filter table and i is the vector B and the index of the cuckoo filter table a. When the application 112 initiates a request for a digital component of a digital component slot, the application 112 transmits rand _ var1a, rand _ var1b and rand _ var2 as parameters of the request to the computing system MPC1. The application 112 also transmits the vectors B, rand _ var1a and rand _ var1B as parameters of the request to the computing system MPC2.PRF (rand _ var2, i) and B i Is Z owned by computing systems MPC1 and MPC2, respectively p In (A) i Two additive secret shares. Because neither computing system MPC1 or MPC2 has access to both secret shares, neither computing system is able to recreate the cuckoo filter table, thereby protecting user privacy.
The client device 110 transmits a digital component request including parameters for a cuckoo filter to the MPC cluster 130 (310). For example, the client device 110 can transmit a digital component request comprising rand _ var1a, rand _ var1b and rand _ var2 to the computing system MPC1. The client device 110 is also able to transmit to the computing system MPC 2a digital component request comprising the vectors B, rand _ var1a and rand _ var1B. The two digital component requests can also include context signals, such as a URL of the electronic resource, a number of digital component slots of the resource, a geographic location of the client device 110, and/or other suitable context signals that can be used to select a digital component, such as a lookup key.
Each DSP 150 can transmit its response to the SSP 170 (316). SSP 170 can transmit the response to MPC cluster 130 (318). In some embodiments, SSP 170 can apply one or more floor prices to the digital component selection process prior to transmitting the response to MPC cluster 130. The SSP 170 can apply the reserve price(s) based on the publisher 140 of the electronic resource for which the digital component is being selected. As described above, the publisher 140 can specify a floor price for the DSP 150, a category of digital components, a digital component provider 160, a brand, and/or other types of groups of digital components.
The SSP 170 can identify the reserve prices specified by the publisher 140 and apply them to the selection values received from the DSP 150. If the selection value is less than the corresponding reserve price, then SSP 170 can remove the selection value from the digital component selection process, for example, by not providing the selection value to MPC cluster 130. For example, assume that the publisher 140 has specified a reserve price of five units for a given digital component provider 160. If DSP 150 provides four units of selection values for the digital components of a given digital component provider 160, SSP 170 is able to filter the selection values from the digital component selection process.
As described above, DSP 150 is capable of providing selection values for stored digital components to be stored for future use in digital component processing. If these selection values do not satisfy the corresponding floor price(s), the digital components and their associated selection values are not stored at MPC cluster 130 because SSP 170 does not forward them to MPC cluster 130.
In some embodiments, MPC cluster 130 implements a reserve price instead of SSP 170, or MPC cluster 130 implements a reserve price in addition to SSP 170. When the MPC cluster 130 calculates the dot product of the vector when the vector is used to determine the selection values, the MPC cluster 130 can apply a floor price to these selection values. The MPC cluster 130, instead of the SSP 170, can also implement a floor price, for example, for static selection values.
The MPC cluster 130 performs a secure MPC process to select a digital component to be provided for display at the client device 110 (320). The selection can include identifying a set of digital components and their corresponding selection values that are eligible for the digital component selection process based on the context signal, e.g., using a lookup key, such as the first level lookup key described above with reference to fig. 1. This can also include identifying candidate digital components from the set of digital components as candidates for selection. The candidate digital components can include unconditional digital components for which the DSP 150 provides a selection value and conditional digital components that satisfy each condition of the digital components. Conditional digital components are only considered candidates for the digital component selection process when all conditions of the digital component are satisfied.
The MPC cluster 130 can select a digital component from the candidate digital components to provide to the client device 110 in response to the digital component request based on the selection value of the candidate digital components. For digital components having selection values determined using vectors, the MPC cluster 130 can determine the selection values of the digital components by determining a dot product of the vectors, e.g., a user group-based vector, a context vector, and optionally a user profile vector.
The MPC cluster 130 can also consider any layer or lifting of digital components when selecting digital components. As described above, the publisher 140 can establish layers and/or upgrades for the DSP 150 and/or the digital component provider 160. When the publisher 140 for which a digital component is being selected has established a promotion, the MPC cluster 130 (or SSP 170) can adjust the selection values of the digital components of the DSP 150 and/or digital component provider 160 using the corresponding promotion specified by the publisher 140. If a vector is used to determine the selection value, the MPC cluster 130 can adjust the selection value after determining the selection value by computing the dot product of the vector.
When layers are used, the MPC cluster 130 can perform the selection process for each layer, e.g., sequentially or in parallel from the highest priority layer to the lowest priority layer. The MPC cluster 130 can select a digital component including at least one candidate digital component that has the highest selection value in the highest priority layer. For example, if none of the digital components in the highest priority layer are candidates that, for example, satisfy all of the conditions under which they are included in the digital component selection process, the MPC cluster 130 selects a candidate from the next highest priority layer that includes the candidate.
The MPC cluster 130 can perform the selection process for each layer in parallel to increase the speed at which the selection process is performed. In this manner, if there are no candidates in the highest priority layer, the MPC cluster 130 has already begun and may have completed the selection process for each other layer, enabling the final digital component to be selected.
The MPC cluster 130 can perform the selection process in order from the highest priority layer to the lowest priority layer. If speed is less critical, this can reduce wasteful computations performed for lower priority layers if higher priority layers include candidate digital components. An exemplary process for selecting digital components using the secure MPC process is shown in fig. 4 and described below.
The MPC cluster 130 sends the secret share of the selection result to the client device 110 (322). In some embodiments, the MPC cluster 130 is also capable of sending a selection process identifier for the digital component selection process to the client device 110. The selection process identifier can uniquely identify the digital component selection process for which the selection result was generated. For example, computing systems MPC1 and MPC2 can each generate a respective selection process identifier SPID for each digital component request for which computing systems MPC1 and MPC2 perform a selection process to generate a selection result to provide to client device 110. In some embodiments, the selection process identifier SPID can be a random number or an opaque alphanumeric or numeric sequence.
The MPC cluster 130 can also store data for selection values as part of a selection process keyed or otherwise linked to SPIDs. For example, computing system MPC1 could store information including information having SPIDs generated for the selection process based on the information generated by computing system MPC1 1 A table or other data structure of data for selected values of the keys of (a). Similarly, computing system MPC2 could store information including information having a SPID generated for the selection process based on the information generated by computing system MPC2 2 A table or other data structure of data for the selected values of the keys of (a). This enables the MPC cluster 130 to update the process variables of the feedback controllers based on the data received from the client devices 110.
The selection result can be in the form of a byte array that includes information about the selected digital component. For example, the selection result can be a byte array that includes values of the digital components in the second LUT, e.g., selection values of the digital components and metadata of the digital components. Computing systems MPC1 and MPC2 can use a secure MPC process to determine a secret share of the selection result, as described in more detail below. Computing system MPC1 may be capable of transmitting a first secret share of the selection result to client device 110, and computing system MPC2 may be capable of transmitting a second secret share of the selection result to client device 110. To prevent computing systems MPC1 and MPC2 from knowing the selected digital components, computing systems MPC1 and MPC2 can be prevented from sharing the secret share of their selection results with each other.
In some embodiments, the client device 110 can request digital components from the MPC cluster 130 based on user group membership. The client device 110 can also request digital components from the SSP 170 based on the context signal. These context signals can include the same context signals described above, as well as optionally additional context signals, such as the number of digital component slots of a resource, the type of digital component slot, the type and/or format of digital components that can be displayed with the resource, and the like. The SSP 170 can select one or more digital components based on the context signal and the selection values of the digital components and provide one or more of the selected digital components (or data identifying the digital components) and the selection values for the digital component(s) to the client device 110. The client device 110 can then select a digital component to be displayed with the resource from a set of digital components that includes the digital component of the selection result received from the MPC cluster 130 and the digital component(s) selected by the SSP 170. If the resource includes multiple digital component slots, client device 110 can request the respective digital component of each slot from MPC cluster 130 and from SSP 170.
The client device 110 can transmit one or more event notifications to the MPC cluster 130 (328). For example, assuming that the digital components of the selection results received from the MPC cluster 130 are displayed by the application 112 of the client device 110, the application 112 can transmit an impression notification for the digital components in response to displaying the digital components. In another example, the application 112 can transmit a user interaction notification in response to detecting a user interaction, e.g., a selection/click of a digital component.
For user interaction notifications, the application 112 can generate a secret share of a click parameter clicked, which is a Boolean parameter that can have a value of one if the user interacts with the digital component or zero if the user does not interact with the digital component for a specified duration after the digital component is displayed. Thus, in this example, any value indicates that a digital component is displayed, but a value of one can indicate that a user is interacting with the digital component. Application 112 can send to computer system MPC 1a message including the SPID received from computer system MPC1 1 And a first secret share of the click parameter [ clicked 1 ]The first notification of (1). Similarly, application 112 can send to computer system MPC 2a message including the SPID received from computer system MPC2 2 And a second secret share of the click parameter [ clicked 2 ]The second notification of (2). In another example, the notification can be sent, for example, using a secret share similar to the click parameter,separately indicating whether the digital component is displayed at the client device 110.
The impression and user interaction notifications enable the MPC cluster 130 to update the process variables of the feedback controllers used to pace the distribution of the digital components. For example, if the process variable is an impression rate, the MPC cluster 130 can use the impression notification to update a count of impressions for the digital component (or activities that include the digital component). If the process variable is a user interaction rate, the MPC cluster 130 can use the click parameter to update the number of user interactions of the digital component (or activities that include the digital component). In a specific example, computing system MPC1 is able to use SPIDs 1 To obtain stored data for the selection process and the computing system MPC2 can use the SPID 2 To obtain stored data for the selection process. The MPC cluster 130 can then perform a secure MPC process to update the active process variables (e.g., impressions, interaction rates, conversion rates, and/or resource exhaustion rates) for the digital components displayed by the applications 112. Similarly, the MPC cluster 130 can use the notification to update the count used to determine whether the digital component satisfies the k-anonymity condition.
FIG. 4 is a swim lane diagram of an exemplary process 400 for selecting digital components for distribution to a client device. The operations of process 400 can be implemented, for example, by computing systems MPC1 and MPC2 of MPC cluster 130. The operations of process 400 can also be implemented as instructions stored on one or more computer-readable media, which may be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of process 400.
The process 400 can be used for a first value selection process, a second value selection process, and/or a selection process that includes a boost and/or a reserve price. Each of these variations is described below. Another exemplary process 500 shown in fig. 5 can be used for the selection process including layers. The process 500 can also support a first value selection process, a second value selection process, a boost, and/or a reserve price.
Computing systems MPC1 and MPC2 determine and/or identify a selection value for a digital component (402). Computing systems MPC1 and MPC2 are capable of determining the selection value in response to a digital component request received from client device 110. As described with reference to fig. 3, the computing system MPC1 is capable of receiving from the client device 110 a digital component request comprising data of a context signal and a probability data structure representing a user group identifier of a user of the client device 110. The data for the probabilistic data structure can include parameters rand _ var1a, rand _ var1b, and rand _ var2. Similarly, the computing system MPC2 is able to receive context signals and parameter vectors B, rand _ var1a and rand _ var1B from the client device 110. The context signal can be in the form of a lookup Key, such as the first level lookup Key (SHA 256 (UG _ Request _ Key)) described with reference to fig. 1.
The selection values can include the selection values of the stored digital components for which data is stored by each of computing systems MPC1 and MPC2 as well as the JIT selection values received from SSP 170 for the digital component selection process. For the case where vectors are used to determine the selection values, each computing system MPC1 and MPC2 is capable of determining the selection values by determining the dot products of the vectors for the digital components. The computing systems MPC1 and MPC2 may also be capable of applying any boost to the digital components for which the publisher 140 or SSP 170 has established a boost and/or implementing any reserve price established by the publisher 140 or SSP 170.
Computing system MPC1 identifies qualified digital components (404). Computing system MPC1 may be capable of identifying qualified digital components for digital component requests received from client devices 110, e.g., as described with reference to fig. 3. A qualified digital component is a digital component that is qualified for selection based on the context signal of the digital component request. For example, a qualified numeric component may be a numeric component having a set of context signals that match the context signal requested by the numeric component, e.g., a numeric component having a lookup key that matches the requested lookup key.
In embodiments using a two-level LUT, the computing system MPC1 is able to identify a qualified digital component using the first-level lookup key of the digital component request. Computing system MPC1 is able to access the first level LUT and use the first level lookup key to identify a row of the second level LUT that includes information for the digital components of the set of context signals represented by the first level lookup key that are eligible to be displayed, e.g., for which a selection value has been received. For example, as described above, each row of the second level LUT includes information for a digital component and a second level lookup key based on a set of context signals. Thus, the computing system MPC1 is able to use the first level lookup key to identify a row of the second level LUT having a set of context signals that matches the set of context signals defined by the first level lookup key received in the digital component request. These rows include information of the numeric components that are eligible to be displayed or have an eligible selection value for the context defined by the first level lookup key received in the numeric component request.
Computing system MPC2 identifies qualified digital components (406). Computing system MPC2 is capable of identifying a qualified digital component of the digital component request received from client device 110. Computing system MPC2 is capable of identifying qualified digital components in a similar manner as computing system MPC1. In embodiments where the MPC cluster 130 implements a reserve price, each MPC computing system MPC1 and MPC2 is capable of filtering from the qualified digital components any qualified digital components that have a selected value for their corresponding reserve price that is not met, e.g., is not met or exceeded.
For each qualified digital component, computing systems MPC1 and MPC2 determine whether the digital component and its selection value are candidates for selection for distribution to client device 110 in response to the digital component request (408). If the digital component is a conditional digital component, then the candidate digital component is a qualified digital component that satisfies all of the one or more conditions of the digital component. Each unconditional digital component that is qualified based on context is also a candidate digital component. Computing systems MPC1 and MPC2 are able to determine candidate digital components using secure MPC processes such that neither computing system MPC1 or MPC2 is able to identify candidate digital components in the clear.
For user group membership conditions, the computing systems MPC1 and MPC2 are capable of calculating a user group membership condition parameter ug check for each qualified digital component "i i Of the corresponding secret share. User group membership condition parameter ug check maintained by computing system MPC1 i Can be expressed as [ 2 ]ug_check i,1 ]And a user group membership condition parameter ug check maintained by the computing system MPC2 i Can be represented as [ ug check [ ] i,2 ]. Brackets are used to indicate secret shares of parameters.
For embodiments in which a cuckoo filter is used to represent user group membership for a user, computing system MPC1 cooperates with computing system MPC2 to compute [ ug check ] according to relation 1 below i,1 ]：
in relation 1, Π represents multiplication of a plurality of terms. Here, ug _ id (x) is a function for retrieving the user group identifier ug _ id associated with the selection value x, { F } 1 ,…F N Is a set of hash functions used to compute possible indices of entries within the cuckoo filter table a, and rand val1a is a random value received in the digital component request. [ M ] x,1 ]Is a number group [ M 1 ]The xth element of (1). = equality test between the plaintext integer and the secret share of the secret integer. The result of = is a secret share of a secret integer of 0 (not equal) or 1 (equal). Here, [ M ] i,1 ]Value of = [ PRF (rand _ val2a, i) ] 1 ]。
Similarly, computing system MPC2 and computing system MPC2 cooperate to compute [ ug _ check ] according to the following relation 2 i,2 ]：
here, [ M ] i,2 ]Value of (a) = B i 。
For digital components that are conditioned on the user group membership of the user for whom the digital component is being selected, the computing systems MPC1 and MPC2 are capable of calculating a user group membership condition parameter ug check i Secret share of [ ug _ check ] i,1 ]And [ ug _ check i,2 ]. The combination of the two secret shares can be a boolean value that indicates whether the user is a member of a user group corresponding to the digital component. For example, a value of one can indicate that the user is a member, while a value of zero can indicate that the user is not a member. For digital components that are not conditioned on user group membership of the user, computing systems MPC1 and MPC2 can use secret shares ug check i,1 ]And [ ug _ check i,2 ]Such that the combination has a value (e.g., one) indicating that the user is a member of the user group corresponding to the digital component.
In embodiments where bloom filters are used to represent user group memberships for a user, computing systems MPC1 and MPC2 can query the bloom filters, as described with reference to fig. 8. The result is that the computing system MPC1 has a first secret share of the user group membership condition parameter ug check for each hash function of the bloom filter i,1 ]. Similarly, computing system MPC2 has a second secret share of the user group membership condition parameter [ ug _ check ] for each hash function of the bloom filter i,2 ]. For digital components that satisfy the user group membership condition, the user group membership condition parameter for each hash value of the bloom Filter, i.e., ug check i It will need to have a boolean value of true or one. The secret share of each hash value can be included in the final calculation of the secret shares of the candidate parameters of the digital component.
Computing systems MPC1 and MPC2 can also cooperate to compute blocked digital component parameter blocked _ check for each digital component i conditioned on frequency control or muting i Corresponding secret share of [ blocked _ check ] i,1 ]And [ blocked _ check ] i,2 ]. The combination of the two secret shares can be a boolean value that indicates whether the digital component is based on frequency control (e.g., the digital component has not been provided to the user during a period of timeA threshold number of times over) and/or satisfy a blocked digital component condition based on whether the user chooses not to display the digital component to the user. For example, a boolean value of true or one can indicate that a digital component can be displayed to the user based on these factors, and a boolean value of false or zero can indicate that a digital component cannot be displayed to the user based on these factors.
To determine the secret shares of the blocked digital component parameters, the computing systems MPC1 and MPC2 can use the shares, e.g., arrays, of the bloom filters representing the identifiers of the blocked digital components. Application 112 can generate a bloom filter representing an identifier of the blocked digital component and send data representing the bloom filter to computing systems MPC1 and MPC2 as described with reference to fig. 8. Computing systems MPC1 and MPC2 can then query the bloom filters using an array representing the bloom filters to obtain secret shares block check i,1 ]And [ blocked _ check ] i,2 ]As described with reference to fig. 8.
Computing systems MPC1 and MPC2 can also cooperate to calculate a pacing control check parameter paging _ check for each digital component i being paced, e.g., using a feedback controller i Corresponding secret share of [ pairing _ check ] i,1 ]And [ packing _ check ] i,2 ]. The combination of the two secret shares can be a boolean value that indicates whether the digital component satisfies a cadence condition, e.g., based on the output of the feedback controller. For example, if a digital component is being provided too frequently relative to a target impression rate, the output of the feedback controller can indicate that the digital component is not eligible for the digital component selection process. A boolean value of true or one can indicate that the digital component satisfies the cadence condition, e.g., is not being throttled for the selection process, while a boolean value of false or zero can indicate that the digital component does not satisfy the cadence condition, e.g., is being throttled for the selection process.
To implement resource exhaustion (e.g., budgeting) and pacing rules, computing systems MPC1 and MPC2 can randomly prevent digital components from participating in the digital component selection process using probabilities and resource exhaustion conditions determined using a feedback controller. If activities involving digital componentsWithout any additional resources, the probability is set to one. Otherwise, if the activity is before the delivery schedule, the probability is set high (e.g., above zero and close to one) so that the computing systems MPC1 and MPC2 are more likely to prevent the digital component from doing the digital component selection process, e.g., by computing a secret share [ pairing _ check ] i,1 ]And [ packing _ check i,2 ]So that the pace control checks the parameter paging _ check i Has a value of zero. If the activity falls behind the delivery schedule, the probability is lower.
Computing systems MPC1 and MPC2 are able to periodically calculate a pacing selector parameter paging _ selector for each activity in the additive secret share using a feedback controller. Conceptually, the cadence selector parameter is the throttle probability amplified by a factor of maximum range.
For each digital component request and each digital component, the computing systems MPC1 and MPC2 compute uniformly distributed [0, max range]The secret number in (2). If the random number is less than or equal to the cadence selector parameter, paging _ selector, then computing systems MPC1 and MPC2 may compute the secret shares, for example, by computing the secret shares [ paging _ check ] i,1 ]And [ packing _ check ] i,2 ]To prevent the digital component from participating in the digital component selection process, so that the pacing control checking parameter paging _ check i Has a value of zero.
To protect the user privacy and confidential information of the participants in the digital component selection process, both the random number and the cadence selector parameter are in an additive secret share. The comparison between the two secret shares can be performed using a garbled circuit protocol. By limiting the two secret shares to six or seven bits, the comparison protocol can make one or two rounds of communication between computing systems MPC1 and MPC2.
To determine the pacing selector parameters for an activity, the computing system can calculate the amount of resources for each activity as resources _ used _ campaigns = ∑ (cleaning _ value x is _ dc _ the _ winner), where the sum spans all digital component selection processes including the active digital component, the parameter cleaning _ value is a clearing value of the digital component selection process, and is _ dc _ the _ winner is a winner parameter for the digital component in the digital component selection process. This calculation can be performed in secret shares such that each computing system MPC1 and MPC2 holds a secret share of the amount of resources used. The computing systems MP1 and MPC2 can then calculate the resource exhaustion parameter resources _ consumed for an activity by determining whether the amount of resource used, i.e. resources _ used _ campaigns, is larger than the total amount of resources allocated for the activity in the secret share.
Computing systems MPC1 and MPC2 are capable of calculating the cadence selector parameter, paging _ selector, for each activity as paging _ selector = resources _ consumed × maximum range + (1-resources _ consumed) × output, where the parameter output is the output of the feedback controller. This calculation can use one RPC between the computing systems MPC1 and MPC2 to calculate the multiplication in the secret share. However, the calculations can be performed periodically offline to prevent any increased latency.
The computing systems MPC1 and MPC2 are further able to cooperate to compute the k-anonymity check parameter kanonyrnity _ check for each digital component i that has to fulfill the k-anonymity condition i Corresponding secret share of [ kanonym _ check ] i，1 ]And [ kanonymittycheck ] i，2 ]In some embodiments, this can apply to all digital components. The combination of the two secret shares can be a boolean value that indicates whether the digital component satisfies the k-anonymity condition. For example, a value of one can indicate that the digital component satisfies k anonymity, while a value of zero can indicate that the digital component does not satisfy k anonymity and should be prevented from proceeding with the digital component selection process.
Computing systems MPC1 and MPC2 can periodically process the logs (as described with reference to fig. 9) to identify the digital component selection process for which the winner digital component has been shown (or may have been shown) by application 112, e.g., the corresponding selection process identifier has been received in the impression notification. During these selection processes, the computing systems MPC1 and MPC2 will count the number of impressions shown (or possibly shown) by the user's application 112 as impression _ show i = v (is _ dc _ the _ winner _ i). Here, i can represent a digital component or activity. The calculations are performed with secret shares such that each computing system MPC1 and MPC2 has an impression quantity impression _ show i The secret share of (c). The computing systems MPC1 and MPC2 can then determine whether the number of impressions exceeds the value k, for example by comparing the number of impressions with k on the secret share.
For each condition of each condition digital component (e.g., a digital component having at least one condition), each computing system MPC1 and MPC2 can store a corresponding secret share of the parameter for each condition of the digital component. In this manner, as long as at least one MPC computing system is honest, neither computing system MPC1 nor MPC2 will know the values of the parameters in the clear. Each digital component can be conditioned by zero or more conditions. For a given digital component selection process, some digital components can have different conditions and/or a different number of conditions than other digital components.
Although some exemplary conditions are provided above, other conditions can be used. In general, computing systems MPC1 and MPC2 are capable of calculating secret shares of condition parameters using secure MPC processes. The criteria and techniques used to determine the condition parameters can vary. In some embodiments, a secret share of a condition parameter can be received from another computing system, e.g., so that computing systems MPC1 and MPC2 do not compute the condition parameter.
Computing systems MPC1 and MPC2 can use the secret shares of the condition parameters to determine whether the condition digital component is a candidate for the digital component selection process. The computing systems MPC1 and MPC2 are able to compute the candidate parameter is _ dc _ a _ candidate for each conditional digital component i using the secret share of the conditional parameter(s) for the conditional digital component i i Is given. In general, if a conditional digital component is conditioned on each of the above conditions, the candidate parameters for the digital component i can be calculated using the following relation 3:
is_dc_a_candidate i ＝ug_check i AND blocked_check i AND pacing_check i AND kanonymity_check i
since the value of each condition parameter is in a secret share, the computing systems MPC1 and MPC2 may use round-trip Remote Procedure Calls (RPCs) at the secure MPC process co-operates to determine a corresponding secret share [ is _ dc _ a _ candidate ] for a candidate parameter of the digital component i using the secret shares of the condition parameters i,1 ]And [ is _ dc _ a _ candidate i,2 ]. The secret share [ is _ dc _ a _ candidate for the candidate parameter of the digital component i can be determined using any suitable secret share algorithm for determining a logical AND operation i,1 ]And [ is _ dc _ a _ candidate i,2 ]. The computing systems MPC1 and MPC2 are able to determine secret shares of the candidate parameters using only the secret shares of the condition parameters for those conditions. At the end of the secure MPC process, the computing system MPC1 saves a first secret share [ is _ dc _ a _ candidate ] of the candidate parameter for each conditional digital component i,1 ]While computing system MPC2 maintains a second secret contribution [ is _ dc _ a _ candidate ] of the candidate parameter for each conditional digital component i,2 ]。
In some embodiments, computing systems MPC1 and MPC2 use a garbled circuit protocol to evaluate relation 3 for each digital component. In this example, one of computing systems MPC1 or MPC2 is capable of constructing a garbled circuit. For this example, assume that computing system MPC1 constructs a garbled circuit. Computing system MPC1 knows its own secret shares and also knows only one possible bit pattern that the secret shares of computing system MPC2 must hold in order for the candidate parameters of the digital component to become true or one. With such properties, the computing system MPC1 only needs up to 50 gates to construct the garbled circuit, for example, if there are a total of about 50 boolean parameters in relation 3.
In relation 3, there is only one user group membership condition parameter ug check i . However, if a bloom filter is used to represent user group membership for a user, then the relation 3 can include a corresponding user group membership condition parameter, ug check, for each hash function of the bloom filter i . Similarly, if a bloom filter is used to represent blocked digital components, then relational 3 would include the corresponding blocked digital component parameter blocked _ check for each hash function of the bloom filter i . In relation 3, pacing is only enabled when the owner of the digital componentThere is a paging _ check at check i 。
Computing system MPC1 determines the order of the digital components based on the selection values (410). Similarly, computing system MPC2 determines the order of the digital components based on the selection values (412). The two orders should be identical because the inputs to the ordered process are identical on both computing systems MPC1 and MPC2. Each computing system MPC1 and MPC2 is capable of determining the order of the digital components. Each order can include candidate digital components that evaluate the candidacy in step 408 and other digital components. For example, the order can include all available digital components that are available for the digital component selection process, all qualified digital components for the digital component selection process (e.g., qualified based on a context signal), or, if used, all digital components in the second level LUT. The order can be from the digital component with the highest selection value to the digital component with the lowest selection value. In some embodiments, the selection value for the order can be a value that will be provided to the publisher 140 of the resource with which the selected digital component will be displayed, e.g., after any sharing with the DSP 150 and/or SSP 170 plus any applicable boosting.
Since the selection values are in plaintext, the computing systems MPC1 and MPC2 do not have to perform any round-trip calculations to determine the order of the digital components. Instead, each computing system MPC1 and MPC2 is capable of independently ordering the selection values. If the selection values are stored as secret shares at each computing system MPC1 and MPC2, where each computing system MPC1 and MPC2 has a respective secret share for each selection value, the computing systems MPC1 and MPC2 can perform a secure MPC process using round-trip computations to order the selection values. If there is a tie between two or more selection values, the computing systems MPC1 and MPC2 can deterministically break the tie using other metadata for the digital components corresponding to these selection values.
Computing systems MPC1 and MPC2 determine a secret share of the accumulated value for each candidate digital component (414). Conceptually, the accumulated value for a given digital component represents the total number of candidate digital components from the top of the order to the selected value for the given digital component, even if the given digital component is a candidate, the given digital component is not included. That is, the accumulated value represents the number of candidate digital components that are more eligible for selection than the given digital component. This concept is shown in table 3 below.
Ordered selection values | is_dc_a_candidate | Accumulated value (acc) | Is the accumulated value equal to 0? |
Highest point of the design | 0 | 0 | 1 |
Second highest | 1 | 0 | 1 |
Third highest | 0 | 1 | 0 |
The fourth highest | 1 | 1 | 0 |
… | … | … | … |
TABLE 3
In some implementations, the accumulated value for the given digital component represents a total number of candidate digital components from the top of the order to the given digital component, the given digital component being included if the given digital component is a candidate. In this example, the fourth column would indicate whether the accumulated value is equal to one instead of zero. For brevity, the remaining discussion will be in accordance with a first example in which the accumulated value for a given digital component represents the total number of candidate digital components from the top of the order to the given digital component that are not included even though the given digital component is a candidate.
Conceptually, in table 3, for each digital component with the candidate parameter is _ dc _ a _ candidate equal to one, the accumulated value (acc) is incremented as it progresses from the top of the order to the bottom of the order. The calculation of the accumulated value acc is performed in secret shares as described below. For example, the accumulated value acc for the digital component with the highest selection value is zero, since the candidate parameter is _ dc _ a _ candidate for the highest selection value is equal to zero. The accumulated value acc for the second highest digital component is also zero because the candidate parameter is _ dc _ a _ candidate for the second highest digital component is equal to one, but none of the selected values higher than the second highest digital component has a candidate parameter is _ dc _ a _ candidate equal to one. Moving down in order, based on the candidate parameter is _ dc _ a _ candidate for the second highest selection value having a value of one, the accumulated value acc of the candidate parameter is _ dc _ a _ candidate for the third highest selection digital component is incremented by a value of one. Since the candidate parameter is _ dc _ a _ candidate for the third highest digital component is zero, the accumulated value acc for the fourth digital component is not incremented and has a zero value like the third highest digital component.
Using table 3, the computing systems MPC1 and MPC2 will select the digital component corresponding to the selected value where the total candidate parameter is _ dc _ a _ candidate has a value of one and the accumulated value acc has a value of zero to distribute to the client device 110, as shown in the fourth column of table 3. This represents the digital component corresponding to the highest ranked selected value for which the candidate parameter is _ dc _ a _ candidate has a value of one. Since the candidate parameter is _ dc _ a _ candidate is in the secret share of the computing systems MPC1 and MPC2 to maintain user privacy and ensure that user data is not leaked, the computing systems MPC1 and MPC2 determine the secret share of the accumulated value acc for each digital component and use round-trip calculations to determine which digital component has an accumulated value acc equal to zero and a candidate parameter is _ dc _ a _ candidate equal to one.
In some embodiments, computing systems MPC1 and MPC2 are capable of determining the secret shares of the accumulated value acc for each digital component independently according to a secret share algorithm without any round trip computation. For example, the computing system MPC1 can determine a first share [ acc ] of the accumulated value acc for each digital component i by traversing all digital components in order from highest to lowest and summing the candidate parameters is _ dc _ a _ candidate of the digital component along the path i,1 ]As described above with reference to table 3. Similarly, the computing system MPC2 is able to determine a second share [ acc ] of the accumulated value acc for each digital component i by traversing all digital components in order from highest to lowest and summing the candidate parameters is _ dc _ a _ candidate of the digital component along the path i,2 ]。
Computing systems MPC1 and MPC2 determine, for each digital component, a secret share of the result that indicates whether the accumulated value has a specified value (416). The specified value can be a zero value as shown in columns 3 and 4 of table 3. As described above, the digital component whose accumulated value is zero and total candidate parameter is _ dc _ a _ candidate is one is the digital component having the highest selected value among the candidate digital components.
The computing systems MPC1 and MPC2 can participate in multiple rounds of computation, e.g., multiple RPCs, as part of the secure MPC process to compute the equation operation acc from the secret shares for each digital component i i =0. Equality operation for determining the accumulated value acc for the digital component i i Has a value of zero. At the end of the process, the computing system MPC1 has for each digital component iResults acc i =0, and the computing system MPC2 has a result acc for each digital component i =0 another secret share.
Computing systems MPC1 and MPC2 determine the winner parameter is _ dc _ the _ winner of each digital component i i The secret share of (418). The computing systems MPC1 and MPC2 are able to be based on the accumulated value acc for each digital component i i Secret share =0 and for each digital component i the parameter is _ dc _ a _ candidate for i To determine a winner parameter is _ dc _ the _ winner i . Winner parameter is _ dc _ the _ winner of each digital component i i Can be a boolean value that indicates whether the digital component i is the winner of the selection process, e.g., whether the digital component i is selected for distribution to the client device 110 in response to a digital component request.
In some embodiments, computing systems MPC1 and MPC2 are capable of executing secret share multiplication protocols to calculate winner parameters is _ dc _ the _ winner for each selected value from secret shares i ＝＝(is_dc_a_candidate i ×(acc i = 0)). This can include computing one RPC between systems MPC1 and MPC2 to multiply two secret shares. At the end of the MPC process, the computing system MPC1 has the value denoted as [ is _ dc _ the _ winner [ ] i，1 ]＝[is_dc_a_candidate i，1 ]x([acc i，1 ]= 1) result is _ dc _ the _ winner i A secret share of (a). Similarly, computing system MPC2 has a value denoted as [ is _ dc _ the _ winner [ ] i，2 ]＝[is_dc_a_candidate sv，2 ]x([acc i，2 ]= 0) result is _ dc _ the _ winner i Another secret share of (a). Note that for all digital components, at most one digital component has a winner parameter is _ dc _ the _ winner equal to 1 i Which is a digital component selected for distribution to the client device 110. All other digital components will be equal to zero.
For the first value selection process, computing systems MPC1 and MPC2 can perform a similar process to determine the winner parameter is _ dc _ the _ winner of each digital component i i . For example, metersThe computing systems MPC1 and MPC2 are capable of performing a secret share equality test to determine a first selection value parameter, maybe _ first _ sv i ＝(acc i = 0) secret share. First selection value parameter maybe _ first _ sv of digital component i i Can be a boolean value that indicates whether the selection value for the digital component is likely to be the highest among the candidate digital components. If the digital component corresponding to the selection value is actually a candidate digital component, the selection value will only be the highest selection value among the candidate digital components. Thus, the first selection value parameter maybe _ first _ sv of the digital component i i Indicating whether a digital component will have the highest selection value if it is in fact a candidate digital component. At the end of this equality test, the computing system MPC1 has a first selection-value parameter maybe _ first _ sv for the digital component i i Is given a first secret share of [ maybe _ first _ sv ] i，1 ]And the computing system MPC2 has a first selection value parameter maybe _ first _ sv for the digital component i i Second secret share of [ maybe _ first _ sv i，2 ]。
Computing systems MPC1 and MPC2 can then calculate a winner parameter is _ dc _ the _ winner for each digital component i from the secret shares using the following relation 4 i ：
is_dc_the_winner i ＝＝((is_dc_a_candidate i ＝TRUE)AND(maybe_first_sv i ＝TRUE))
Computing systems MPC1 and MPC2 determine a selection result (420). In some embodiments, the computing systems MPC1 and MPC2 are capable of calculating the selection result based on the winner parameter for the digital component and the digital component information element dc _ information _ element for the digital component. As described above, the digital component information element dc _ information _ element for the digital component can include a selection value for the digital component and other data for the digital component.
Conceptually, the computing systems MPC1 and MPC2 can calculate the selection result parameter "result" using the following relation 5:
result＝∑ i is_dc_the_winner i ×dc_information_element i
that is, computing systems MPC1 and MPC2 are able to determine the winner parameter is _ dc _ the _ winner across all digital components i And a digital component information element dc _ information _ element i The sum of the products of (a). In this example, the selection result would have the value zero if no candidate digital component is present, or the selection result would have a value equal to the digital component information element dc _ information _ element of the selected digital component having the winner parameter is _ dc _ the _ winner equal to one i . In another example, the digital component information element dc _ information _ element can be replaced with a selection value of the digital component in relation 5. In this example, the selection result would have a value of zero if no candidate digital component existed, or the selection result would have a value equal to the selection value of the selected digital component having a winner parameter is _ dc _ the _ winner equal to one i 。
To perform the calculation with secret shares, the computing system MPC1 obtains all digital components and will be able to calculate the digital component information element dc _ information _ element of the digital component in plaintext i Multiplying the winner parameter of the digital component is _ dc _ the _ winner i，1 ]The first secret share of (a). Computing system MPC1 can then determine the sum of these products and return the sum to the client device 110 that submitted the digital component request. That is, the computing system MPCI can determine the sum as the first secret share [ result ] of the result using the relationship 6 below 1 ]：
[result 1 ]＝∑ i ([is_dc_the_winner i ]×dc_information_element i )
The computing system MPC2 can perform a similar calculation using the following relation 7 to determine a second secret share [ result ] of the result 2 ]：
[result 2 ]＝∑ i ([is_dc_the_winner i ]×dc_information_element i )
The computing system MPC1 sends a first share [ result ] of the selection result to the client device 110 1 ](422). Similarly, theComputing system MPC2 sends a second share of the selection result [ result ] to client device 110 2 ](424). Application 112 can then use both secret shares [ result 1 ]And [ result 2 ]The selection result is reconstructed in the clear text, for example by determining the sum of the secret shares if an additive secret share algorithm is employed. If the selection result has a value of zero, the MPC cluster 130 does not identify a digital component for distribution to the client device 110. Otherwise, the selection result has a value equal to the digital component information element dc _ information _ element. The application 112 is able to parse the digital component information element dc _ information _ element to obtain a selection value and metadata for the digital component. The application 112 can then display the digital components or perform a selection process using the digital components and other digital components received from the SSP 170, as described above.
In some embodiments, the selected digital components are sent to client device 110 using a mask to prevent computing system MPC1 or MPC2 from being able to access the selected digital components in the clear and to reduce the latency of sending the digital components to client device 110. In this example, the application 112 can select a random number for each digital component request and send the random number with the digital component request. Application 112 can send the random number to one of computing systems MPC1 or MPC2. For the purposes of the example, it is assumed that the random number is sent to the computing system MPC2.
Both application 112 and computing system MPC2 are capable of independently computing a mask of the same size as the inventive largest digital component using the same algorithm and the same input. For example, the ith bit of the mask can be represented as PRF (nonce, i), where PRF represents a pseudo-random function. Both the application 112 and the computing system MPC2 are able to keep the random number and the mask strictly secret from the computing system MPC1.
To send the selected digital components to application 112, computing system MPC2 can send [ result [ -result ] 2 ]The bitwise XOR mask is sent to the computing system MPC1. Then, the computing system MPC1 will [ result [ ] 1 ]Bitwise XOR ([ result) 2 ]Bitwise XOR mask) as a result of the selection-e.g., as a request to a digital componentResponse of (d) -send to application 112.
For the second value selection process, the computing systems MPC1 and MPC2 are able to calculate a second selection value parameter maybe _ second _ sv for each digital component i The secret share of (c). The second selection value parameter for the digital component i can be a boolean value representing whether the selection value of the digital component may be the second highest selection value among the candidate digital components. If the digital component corresponding to the selection value is actually a candidate digital component, the selection value will only be the second highest selection value among the candidate digital components. Thus, the second selection value parameter maybe _ second _ sv for the digital component i i Indicating whether the digital component will have the second highest selection value if it is actually a candidate digital component. Computing systems MPC1 and MPC2 can perform secret share equality tests to determine the secret shares maybe _ second _ sv of the second selection value parameter i ＝(acc i ＝＝1)。
At the end of this equality test, the computing system MPC1 has a second choice-value parameter maybe _ second _ sv for the digital component i i Is first secret share [ maybe _ second _ sv i，1 ]And the computing system MPC2 has a second selection value parameter maybe _ second _ sv for the digital component i i Second secret share [ maybe _ second _ sv i，2 ]。
Computing systems MPC1 and MPC2 can then determine the is _ dc _ a _ candidate by determining the is _ dc _ a _ candidate for each digital component i i AND maybe_second_sv i The result is a true or a unity clothThe delta value determines the candidate digital component having the second highest selection value based on the secret share. That is, the computing systems MPC1 and MPC2 are able to determine which digital component is a candidate digital component and have the second selection value parameter maybe _ second _ sv with a boolean value of true or 1 i 。
Conceptually, the computing systems MPC1 and MPC2 can calculate the second highest selection value among the candidates using the following relation 8:
second_selection_value＝
∑ i (selectionvalue i x(is_dc_a_candidate i AND maybe_second_sv i ))
in relation 8, parameter "selectionvalue i "is the selection value (with any boost) for digital component i, and the parameter" second _ selection _ value "is the value of the second highest selection value among the candidate digital components. Using the relationship, the second selection value is the selection value of the digital component as a candidate and has a second selection value parameter for which the boolean value is true. The boolean value in this relation can be considered to be a value of one (true) or zero (false).
In secret shares, the computing systems MPC1 and MPC2 compute the result is _ dc _ a _ candidate with the secret share i AND maybe_second_sv i And the result is represented as Z 2 Two additive secret shares in space (e.g., plus then mod 2). Further, the selection value is in plaintext. Can be generated by using each bit in the selection value in plaintext with the 1-bit secret share is _ dc _ a _ candidate of the result held by each computing system MPC1 and MPC2 i AND maybe_second_sv i The bitwise logical AND operation between replaces the multiplication to simplify relation 8. In addition, the summation can be replaced with a bitwise XOR operation.
FIG. 5 is a swim lane diagram of an exemplary process 500 for selecting digital components for distribution to a client device. The operations of the process 500 can be implemented, for example, by the computing systems MPC1 and MPC2 of the MPC cluster 130. The operations of process 500 can also be implemented as instructions stored on one or more computer-readable media, which may be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of process 500. As described above, the process 500 can be used for a selection process that includes layers.
Computing systems MPC1 and MPC2 determine a selection value for the digital component (502). Computing systems MPC1 and MPC2 are capable of obtaining or determining a selection value in response to receiving a digital component request from client device 110. Computing system MPC1 identifies qualified digital components that are qualified for use in the digital component selection process (504). Computing system MPC2 also identifies qualified digital components that are eligible for use in the digital component selection process (506). For each qualified digital component, computing systems MPC1 and MPC2 determine whether the digital component is a candidate for the digital component selection process (508). Steps 502-508 can be the same as or similar to steps 402-408 of process 400 shown in fig. 4.
Computing system MPC1 groups digital components into layers (510). As described above, the publisher can build a layer for the DSP 150 and/or the digital component provider 160. The layers of the publisher can include a highest priority layer, a lowest priority layer, and optionally one or more layers between the highest priority layer and the lowest priority layer.
Computing system MPC1 is capable of determining the layer for each digital component based on DSP 150 or digital component providers 160, which DSP 150 or digital component providers 160 correspond to, for example, those that provide selected values or value vectors for the digital component. Computing system MPC1 may then group the digital components into their respective layers. Similarly, computing system MPC2 is capable of grouping digital components into their respective layers (512). For both computing systems MPC1 and MPC2, the set of digital components of the layers should be the same. In some embodiments, SSP 170 explicitly determines the tier and then encodes the tier into metadata for each selected value to be stored, e.g., cached in MPC cluster 130.
Computing systems MPC1 and MPC2 can then perform a separate selection process on each of the one or more layers to select digital components to provide in response to the digital component requests (513). In some embodiments, computing systems MPC1 and MPC2 perform the selection process on the layers in parallel. In some embodiments, computing systems MPC1 and MPC2 perform the selection process sequentially, starting with the highest priority layer and moving down layer-by-layer until the selection process is performed for all layers. In some embodiments, computing systems MPC1 and MPC2 may be stopped once a candidate is found in the layer, but this may risk leaking user sensitive information to computing systems MPC1 and MPC2. The steps in the dashed box are performed for each layer performing a separate selection process.
The computing system MPC1 orders the digital components grouped into layers by selection values (514). The selection values can be ordered first by layer priority and then by selection values within the same layer. Similarly, computing system MPC2 orders the digital components grouped into layers by selecting values (516). These steps 514 and 516 are similar to steps 410 and 412 of process 400 shown in fig. 4 for each layer. However, the order includes only the digital components included in the layer.
Computing systems MPC1 and MPC2 cooperate to determine an accumulated value acc for each digital component in a layer i Is determined (518). As described above, the accumulated value of a given digital component can represent the total number of candidate digital components from the top of the order to the selected value of the given digital component, and even if the given digital component is a candidate, the given digital component is not included. Computing systems MPC1 and MPC2 may be capable of determining the accumulated values for the digital components in the layers in a similar manner as described above with reference to step 414 of process 400 of fig. 4.
In some embodiments, computing systems MPC1 and MPC2 are capable of determining the secret shares of the accumulated value acc for each digital component independently without any round trip computation, depending on the secret share algorithm. For example, the computing system MPC1 can determine a first contribution [ acc ] of the accumulated value acc for each digital component i by traversing all digital components in the layer in order from highest to lowest and summing the candidate parameters is _ dc _ a _ candidate of the digital components along the path i,1 ]As described above with reference to table 3. Similarly, computing system MPC2 is able to compute the parameters of a candidate parameter of a digital component by traversing all digital components in a layer in order from highest to lowest and following that pathThe numbers is _ dc _ a _ candidate are summed to determine a second contribution [ acc ] of the accumulated value acc for each digital component i i,2 ]。
Computing systems MPC1 and MPC2 determine a secret share of the result that indicates whether the accumulated value is equal to the specified value for each candidate digital component in the layer (520). The specified value can be the value zero as shown in columns 3 and 4 of table 3. Within a layer, the digital component for which the accumulated value is zero and the total candidate parameter is _ dc _ a _ candidate has a boolean value of true or one is the digital component with the highest selected value among the candidate digital components in the layer, if any.
The computing systems MPC1 and MPC2 can participate in multiple rounds of computation, e.g., multiple RPCs, as part of the secure MPC process to compute the equation operation acc from the secret shares for each digital component i i =0. Equality operation for determining the accumulated value acc of a digital component i i Whether or not to have a value of zero. At the end of this process, the computing system MPC1 has a result acc for each digital component i in the layer i =0, and the computing system MPC2 has a result acc for each digital component in the layer i =0 another secret share.
Computing systems MPC1 and MPC2 determine a secret share of the winning parameter for each digital component in the layer (522). Computing systems MPC1 and MPC2 can be based on the accumulated value acc for each digital component i in a layer i Secret share and candidate parameter is _ dc _ a _ candidate for each digital component i in a layer =0 i To determine a winner parameter is _ dc _ the _ winner i . Winner parameter is _ dc _ the _ winner for each digital component i i Can be a boolean value that indicates whether the digital component i is the winner of the selection process for the layer, e.g., whether the digital component i is a candidate digital component and has the highest selection value among the candidate digital components in the layer. In some embodiments, computing systems MPC1 and MPC2 are capable of executing secret share multiplication protocols to calculate winner parameters is _ dc _ the _ winner for each selected value from secret shares i ＝(is_dc_a_candidate i ×(acc i ＝＝0))。
Computing systems MPC1 and MPC2 determine a selection result (524). Computing systems MPC1 and MPC2 are able to determine the winning parameter is _ dc _ the _ winner by including the winning parameter is _ dc _ the _ winner i Determines the selection result, the winning parameter is _ dc _ the _ winner i With a value (e.g., boolean true or 1) indicating that the digital component is the winner of the layer. The digital component is the winner of the entire digital component selection process. Computing systems MPC1 and MPC2 are able to use the accumulated values to determine the highest level with a winner parameter equal to true or one. For example, computing systems MPC1 and MPC2 are able to identify the highest layer in which the accumulated value of all digital components in that layer is not zero.
Computing system MPC1 provides the first secret share of the selection result to the client device 110 from which the digital component request was received (526). Computing system MPC2 provides the second secret share of the selection result to the client device 110 from which the digital component request was received (528).
In a second value selection process that includes a layer, the selection value for the digital component is only eligible to provide the second selection value for the selection process if the digital component is in the same layer as the selected digital component. To determine the second selection value, the computing systems MPC1 and MPC2 are able to calculate for each layer t a winning layer parameter maybe _ winning _ tier t The winning layer parameter maybe _ winning _ tier t Indicating whether the layer t includes a digital component selected for distribution to the client device 110. Conceptually, the computing systems MPC1 and MPC2 can calculate the winning layer parameter maybe _ winning _ tier for each layer t using the following relation 9 t ：
In relation 9, the parameter "T" represents all layers having higher priority than layer T. Thus, the winning layer parameter for a layer, maybe _ winning _ tier t Indicating whether any higher priority layer includes a candidate digital component. If not, then layer t is the winning layer if it includes at least one candidate number component.
The equality test between the sum and the value zero can also be calculated using RPC between the computing systems MPC1 and MPC2. Multiple RPCs for various computations may be grouped together into a smaller number of RPCs to reduce latency and network bandwidth consumption between computing systems MPC1 and MPC2.
The computing systems MPC1 and MPC2 can then be based on the candidate parameter is _ dc _ a _ candidate for a given digital component i A second selection value parameter maybe _ second _ sv for digital components i (which can be calculated as described above with reference to fig. 4) and a winning layer parameter maybe _ winning _ tier for layer t comprising a given digital component t To determine whether the second selection value is set by the selection value for the given digital component. For example, when is _ dc _ a _ candidate for a given digital component i AND maybe_second_sv i AND maybe_winning_tier t With a boolean value true or one, the second selection value is set by the selection value of the given digital component.
Computing systems MPC1 and MPC2 can then use the selection value for the given digital component to determine a second selection value. For example, the second selection value can be equal to the selection value for the given digital component or the selection value for the given digital component plus a specified amount.
The DSP 150 and the digital component provider 160 can generally benefit from knowing the highest other selection value of the digital component process so that they can optimize or improve the selection value they provide for the digital component in a similar selection process. For example, a DSP 150 whose digital component is selected may benefit from knowing how much higher its selected value is than the next highest value. Similarly, a DSP 150 whose digital components are not selected may benefit from knowing how much higher the selection value will need to be in order for the digital components to be selected. When the DSP 150 and/or the digital component provider 160 provides selection values based on this information, the DSP 150 is more likely to achieve its goal, e.g., to avoid waste due to excessively high selection values, or to avoid losing digital component presentation opportunities due to low selection values.
For a DSP 150 or digital component provider 160 whose digital component is selected, the highest other selection value is the second highest selection value. For all other selection values, the highest other selection value is the highest selection value. This is the same for both the first value selection process and the second value selection process.
FIG. 6 is a diagram of an exemplary process 600 for determining the highest other selection value of a digital component in a digital component selection process. The operations of the process 600 can be implemented, for example, by the computing systems MPC1 and MPC2 of the MPC cluster 130. The operations of process 600 can also be implemented as instructions stored on one or more computer-readable media, which may be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of process 600.
Computing systems MPC1 and MPC2 perform a digital component selection process to select a digital component for distribution to a client device (602). Computing systems MPC1 and MPC2 can cooperate to select digital components using a secure MPC process, as described above with reference to fig. 3-5.
Computing systems MPC1 and MPC2 determine a first selection value for the digital component selection process (604). The first selection value can be a selection value of a digital component selected for distribution to the client device 110. For example, the first selection value can be the highest selection value of the candidate digital component. If a layer is used, the first selection value can be the highest selection value of a candidate digital component in the highest priority layer that includes at least one candidate digital component.
Computing systems MPC1 and MPC2 can cooperate to determine the first selected value using a secure MPC process. Conceptually, computing systems MPC1 and MPC2 can determine the first selection value using the following relationship 10:
first selection value
＝∑(selection_value i x(is_dc_a_candidate i AND maybe_first_sv i ))
the sum can span all digital components included in the digital component selection process. Selection value (selection _ value) for each digital component i i ) Can be in the clear. As described above, computing systems MPC1 and MPC2 are capable of computing candidate parametersNumber is _ dc _ a _ candidate i And a first selection value parameter maybe _ first _ sv i Is given. The computing system MPC1 is capable of storing a candidate parameter is _ dc _ a _ candidate for each digital component i i Is _ dc _ a _ candidate of i,1 ]And a first selection value parameter maybe _ first _ sv i First share of [ maybe _ first _ sv ] i,1 ]. Similarly, the computing system MPC2 is able to store a candidate parameter is _ dc _ a _ candidate for each digital component i i Second fraction [ is _ dc _ a _ candidate [ ] i,2 ]And a first selection value parameter maybe _ first _ sv i Second share of [ maybe _ first _ sv i,2 ]。
Computing systems MPC1 and MPC2 determine a second selection value for the digital component selection process (606). The second selection value can be the next highest selection value after the selection value selected for distribution to the digital components of the client device 110. For example, the second selection value can be the second highest selection value of the candidate digital component. If a layer is used, the second selection value can be the second highest selection value of a candidate digital component in the highest priority layer that includes at least one candidate digital component.
Computing systems MPC1 and MPC2 can cooperate to determine the second selected value using a secure MPC process. Conceptually, the computing systems MPC1 and MPC2 can determine the second selection value using the following relation 11:
second selection value
＝∑(selection_value i x(is_dc_a_candidate i AND maybe_second_sv i ))
the sum can span all digital components included in the digital component selection process. As described above, the computing systems MPC1 and MPC2 are capable of computing the candidate parameter is _ dc _ a _ candidate i And a second selection value parameter maybe _ second _ sv i Is given. The computing system MPC1 is capable of storing a second selection value parameter, maybe _ second _ sv, for each digital component i i First share of [ maybe _ second _ sv i，1 ]. Similarly, the computing system MPC2 can store a second selection value parameter, maybe _ second _ sv, for each digital component i i Second share of [ maybe _ second _ sv i，2 ]。
In relations 10 and 11, boolean true and false values can be treated as ones and zeros, respectively. In secret shares, computing systems MPC1 AND MPC2 compute the result of the AND operation of both relations 10 AND 11 using the secret shares (e.g., using RPCs between the computing systems), AND represent the result as Z 2 Two additive secret shares in space (e.g., plus then mod 2). Thus, each computing system is capable of storing secret shares of the first selection value and the second selection value. For example, computing system MPC1 may store a first share of a first selected value and a first share of a second selected value. Similarly, the computing system MPC2 can store a second share of the first selected value and a second share of the second selected value. The sum of the two shares of the first selection value (e.g., plus then mod 2) is equal to the first selection value, and the sum of the two shares of the second selection value (e.g., plus then mod 2) is equal to the second selection value.
Can be selected by using a selection value (selection _ value) i ) Replaces the multiplication by a bitwise AND operation between each choice value in (b) AND the 1-bit secret share of the result of the AND operation between the candidate parameter AND the first choice value parameter (or the second choice value parameter) maintained by each computing system MPC1 AND MPC2 to simplify the relations 10 AND 11. Furthermore, the summation of relations 10 and 11 can be replaced by a bitwise XOR operation.
For each digital component, computing systems MPC1 and MPC2 calculate the highest other selection value (608). Computing systems MPC1 and MPC2 are able to use a two-step process in secret shares to compute the highest other selection values for the digital components. The computing systems MPC1 and MPC2 are able to calculate the winner parameter is _ dc _ the _ winner for the digital component i i . The computing systems MPC1 and MPC2 are able to use the candidate parameter is _ dc _ a _ candidate i And a first selection value parameter maybe _ first _ sv i To calculate the winner parameter is _ dc _ the _ winner i E.g. is _ dc _ the _ winner i ＝is_dc_a_candidate i AND maybe_first_sv i 。
Computing systems MPC1 and MPC2 can then calculate the highest thereof for digital component i using relational 12His selection value (HOSV) i )：
HOSV i ＝(is_dc_the_winner i ×second selection value)+((1-is_dc_the_winner i )Xfirst selection value)
Because the winner parameters, the first selection values, and the second selection values are maintained by the computing systems MPC1 and MPC2 in secret shares, the computing systems MPC1 and MPC2 cooperatively determine the highest other selection values using RPCs between the two computing systems MPC1 and MPC2.
At the end of the process, the computing system MPC1 stores a first share [ HOSV ] for the highest other selected value of the digital component i i,1 ]And computing system MPC2 stores a second share [ HOSV ] of the highest other selected value of digital component i i,2 ]。
Computing system MPC1 sends a first share of the highest other selected value for each digital component to, for example, DSP 150 or digital component 160 corresponding to the digital component (610). Similarly, computing system MPC2 sends a second share of the highest other selected value for each digital component to, for example, DSP 150 or digital component 160 corresponding to the digital component (612). In some embodiments, computing systems MPC1 and MPC2 provide shares to an aggregation service that aggregates information for each DSP 150 and/or each digital component provider 160.
The recipient of the two secret shares is able to combine the shares to derive the highest other selection value for the digital component in the digital component selection process. For example, if an additive secret share algorithm is used, the recipient can derive the highest other choice value by adding the two shares.
Computing systems MPC1 and MPC2 are able to send additional data with the highest other selection values. For example, the computing systems MPC1 and MPC2 can send context signals of the digital component selection process, e.g. the lookup key, which has the share of the highest other selection value. In this manner, the view of the selection values of the digital component selection process having the same or similar context can be calculated using the highest other selection values for the digital component selection process having the same or similar context.
In some embodiments, to improve performance, computing systems MPC1 and MPC2 are capable of asynchronously calculating the highest other selection values after providing the selection results of the digital component selection process to client device 110. This reduces the latency of transmitting and displaying the digital components. In some embodiments, when the load on computing systems MPC1 and MPC2 is below the baseline load, computing systems MPC1 and MPC2 are able to compute the highest other selection value.
For a selection process that includes a reserve price for a selected value, additional steps can be taken to accurately calculate the highest other selected value. The computing systems MPC1 and MPC2 are able to compute the highest other selection values as described with reference to fig. 6. The computing systems MPC1 and MPC2 can then adjust the highest other selection value to take into account the reserve price, e.g. such that no selection value is smaller than the applicable reserve price.
Let H denote the highest other choice value calculated and F denote the applicable reserve price. The final highest other selection value will be (H > F). Times.H + (1-H > F, which is equivalent to F + (H > F). Times.H-F).
To protect user privacy, H is in the form of a secret share. Each computing system MPC1 and MPC2 holds a secret share [ H ] respectively 1 ]And [ H 2 ]Of the above. The computing system MPC1 is able to compute the first share of the final highest other selected value of the secret shares using the relation 13:
[HOSV 1 ]＝F+([H 1 ]＞F)×([H 1 ]f) similarly, the computing system MPC2 can compute a second share of the final highest other selection value among the secret shares using the relation 14:
[HOSV 2 ]＝F+([H 2 ]＞F)×([H 2 ]-F) this process of calculating the highest other selected value for the digital component process including the base price can employ three or more rounds of RPC for the comparison test and one round for the multiplication.
When layers and/or boosting are used in the digital component selection process, a first selection value, e.g., a selection value for the selected digital component, may be lower than a highest selection value among the candidate digital components. For example, if a candidate digital component in the highest priority layer has a lower selection value than a candidate digital component in a lower priority layer, a candidate digital component in a higher priority layer may be selected despite having a lower selection value. Similarly, the digital component may receive an elevation that causes the selection value used in the digital component selection value to be higher than the un-elevated (or lower elevated) digital component, such that the publisher receives fewer digital components than it would have if the un-elevated digital component were selected. The MPC cluster 130 can determine the difference between the two values so that the publisher can analyze the opportunity cost associated with the tier and/or promotion.
Fig. 7 is a flow diagram of an exemplary process 700 for determining a difference between a first selection value of a real digital component selection process and a first selection value of a counter-fact digital component selection process. The operations of the process 700 can be implemented, for example, by the computing systems MPC1 and MPC2 of the MPC cluster 130. The operations of process 700 can also be implemented as instructions stored on one or more computer-readable media, which may be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of process 700.
Computing systems MPC1 and MPC2 perform a true digital component selection process (702). Computing systems MP1 and MPC2 are capable of performing a real digital component selection process to select a digital component to provide to client device 110 in response to a digital component request. The real digital component selection process can include layers for the digital components and/or lifts for one or more of the digital components included in the digital component selection process. For example, the real digital component process should be the same as or similar to the process of fig. 3-5.
Computing systems MPC1 and MPC2 perform a counterfactual digital component selection process (704). The steps of the factual digital component process can be similar to the steps of the real digital component selection process. However, in the de-facto digital component selection process, layers and/or lifts of the real digital component selection process are removed. If the real digital component selection process includes layers (e.g., as in process 400 of FIG. 4), then the factual digital component selection process has all digital components in a group (e.g., as in process 500 of FIG. 5). If the real digital component selection process includes lifting the selection values of one or more digital components, those lifts are removed in the counterfactual digital component selection process. That is, the selection value in the de-facto digital component selection process can be the received selection value rather than the boosted selection value.
Computing systems MPC1 and MPC2 determine a clearance value for the real digital component selection process (706). The tally value can be based on a selection value of the selected digital component. For example, the liquidation value can be an amount of the selection value that will actually be provided to the publisher for display of the selected digital component. If the selection value of the digital component is boosted, the amount of boost will only affect the order of the selection value when the accumulated value for each candidate digital component is determined in operation 414.
For the second value selection process, the tally value will be based on the next highest selected value after the selected value of the selected digital component. If a layer is used with the second select value process, the next highest value will be the next highest value in the same layer as the selected digital component. If no such candidate digital component exists in the same layer, the next highest value can be the minimum value used for the digital component selection process.
Computing systems MPC1 and MPC2 determine a tally value for the counter-factual digital component selection process (708). The tally value can be based on the number component selected in the factual number component selection process. For the second value selection process, the tally value will be based on the next highest selected value after the selected value of the selected digital component, similar to the tally value used for the true digital component selection process.
Computing systems MPC1 and MPC2 determine a difference between the two clearance values (710). The computing systems MPC1 and MPC are able to determine the difference by subtracting the clearance value for the counter-fact digital component selection process from the clearance value for the real digital component selection value.
Computing systems MPC1 and MPC2 provide the difference to the recipient (712). For example, one of the computing systems can provide the variance to a publisher of the resource or application content that displays the digital component after selection. In another example, one of the computing systems can provide the differences to an aggregation server that aggregates the differences of the publishers. In either example, the computing system can provide data indicating the difference, a context signal for the real digital component selection process, such as a lookup key, and data identifying the publisher (if sent to the aggregation server).
The aggregation server is capable of aggregating the differences reported for each publisher and providing data indicative of the cost of opportunity to use the tier and/or lift, for example in the form of an interactive user interface. In some embodiments, computing system MPC1 or MPC2 is also capable of providing the selection results to the aggregation server for each real digital component selection process. In this manner, the aggregation server can aggregate opportunity costs for each DSP 150 and/or digital component provider 160.
To reduce latency in providing selected digital components of the real digital component selection process to the client device 110, some or all of steps 704 through 712 of process 700 can be performed asynchronously, e.g., after providing the selection results to the client device 110.
FIG. 8 is a flow diagram of an exemplary process 800 for determining whether a user is a member of a user group using a bloom filter sent with secret shares. The operations of process 800 can be implemented, for example, by application 112 running on client device 110 and computing systems MPC1 and MPC2 of MPC cluster 130 of fig. 1. The operations of process 800 can also be implemented as instructions stored on one or more computer-readable media, which may be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of process 800.
Sending data representing a user's group membership using a bloom filter can reduce the amount of data being sent and protect user privacy because the data identifying the user group of the user is not sent in the clear. To prevent computing systems MPC1 and MPC2 from being able to access the user's group membership in clear text, application 112 can send a respective share, e.g., a secret share of a bloom filter, to each computing system 112 instead of sending a complete bloom filter to each computing system MPC1 and MPC2. However, this can require sending data equivalent to sending two bloom filters, one to each computing system MPC1 and MPC2. To prevent this and further reduce the amount of data sent from client device 110 across network 105 to computing systems MPC1 and MPC2, application 112 can send a first array generated using the random numbers and the original bloom filter created by application 112 to one of the computing systems, e.g., computing system MPC1, and send only the random numbers to the other computing system MPC2. In this manner, only one array is sent from the client device 110. Since the random number can be small, e.g., 16 bytes, this greatly reduces the amount of data sent from the client device 110, which reduces bandwidth consumption, latency, and battery consumption of the client device 110.
Although process 800 is described in terms of bloom filters representing user membership in a user group, a similar process can be used to generate a bloom filter for representing blocked digital components and query whether a digital component is blocked. In this example, the bloom filter would represent an identifier of the blocked digital component rather than an identifier of the user group.
The configuration of the bloom filters can be adapted for transmission and/or processing by the computing systems MPC1 and MPC2. The parameters of the bloom filter include the number of user groups that can be represented by the bloom filter, the expected false positive rate of the bloom filter, the number of hash functions used to generate the bloom filter and test whether elements are included in the bloom filter, and the size of the bloom filter.
By reducing the number of hash functions, the computational burden on computing systems MPC1 and MPC2 is reduced when querying whether a user is a member of a user group. However, if the size of the bloom filter is kept constant, this can increase the false alarm rate. If there is a target false positive rate, reducing the hash function may result in a larger bloom filter size, which can increase the amount of bandwidth consumed. Thus, the parameters of the bloom filter can be selected using a trade-off between bandwidth/battery consumption and the computational burden on the computing systems MPC1 and MPC2.
The application 112 and the computing systems MPC1 and MPC2 can agree on a pseudo-random function (PRF) in advance. The PRF can take two parameters and generate a PRF number in {0,1} (including 0 and 1).
A 1 [i]＝A[i]XOR PRF(nonce，i)
In relation 15, the XOR operation is a bitwise XOR operation.
Computing system MPC2 uses the random numbers to compute the second array a 2 (812). The computing system MPC2 is able to use the random number and the PRF to computeTwo arrays A 2 . For example, computing system MPC2 can use relational 16 to compute second array A 2 ：A 2 [i]= PRF (nonce, i) computing systems MPC1 and MPC2 use the first array a 1 And a second group A 2 To determine if the user is a member of one or more user groups (814). In general, a bloom filter can be queried by applying each hash function of the bloom filter to a subscriber group identifier to determine the elements of the bloom filter that correspond to the hash function and the subscriber group identifier. If for the user identifier, each element of the hash function has a value of one, this will indicate that the user is a member of the group. Of course, due to the nature of bloom filters, there can be some false positives.
Since neither computing systems MPC1 and MPC2 have access to the full bloom filter (but each has only a secret share of the bloom filter), computing systems MPC1 and MPC2 are able to use cryptographic protocols to determine from the user group identifier whether the user is a member of the user group identifier. Some exemplary cryptographic protocols that can be used include garbled circuits and the Goldreich-Micali-Wigderson (GMW) protocol.
In either algorithm, the input to the (conceptual) algorithm is the secret share of the bloom filter, i.e. the first array A 1 And a second group A 2 . The output is a secret share of a set of boolean messages, one for each digital component, i.e. whether the user is a member of the user group associated with the corresponding digital component.
In the GMW protocol, one of the MPC computing systems, e.g., computing system MPC1, creates a truth table, one line per possible bit pattern, for the secret share owned by computing system MPC2. The computing system MPC1 randomly selects its own secret share for the result, for example, and computes the secret share for the computing system MPC2 of each row based on its own secret share for the result and the secret shares of the possible computing systems MPC2 corresponding to the row. After building the truth table, the computing system MPC2 takes one and only one row from the table based on its own secret share using an oblivious transfer protocol. In this protocol, one computing system transmits one of a plurality of pieces of information to another computing system, but does not know which, if any, has been transmitted. The oblivious transfer protocol ensures that the process does not leak any information to either party.
The result of querying the bloom filter for a given user group identifier is a secret share of the user group membership condition parameter for each hash function. The secret share of the user group membership condition parameter can be used in a digital component selection process to determine whether a digital component corresponding to the user group is a candidate for use in the digital component selection process. For example, if 10 hash functions are used, the computing system MPC1 will have 10 first secret shares of the user group membership condition parameters for each user group identifier. Similarly, computing system MPC2 will have 10 second secret shares of the user group membership condition parameters for each user group identifier.
If the bloom filter represents an identifier for a blocked digital component, then the computing systems MPC1 and MPC2 can reconstruct the second array and query the bloom filter in a similar manner. The result of querying the bloom filter for a given numeric component is a blocked conditional parameter for each hash function. The secret shares of the blocked condition parameter can be used in the digital component selection process to determine whether the digital component is a candidate for use in the digital component selection process.
FIG. 9 is a block diagram of an exemplary MPC computing system 900. Any of the MPC computing systems described in this document can be implemented using MPC computing system 900. Alternatively, the MPC computing system can be implemented as one or more servers. However, the architecture and configuration of MPC computing system 900 provides a number of performance improvements over the use of a generic server arrangement.
The MPC computing system 900 includes a load balancer 910, a service pool 920, and a log processor pool 940. Computing system 900 also generates, updates, and otherwise maintains logs 930 and snapshots 950.
In some embodiments, MPC computing system 900 is deployed in various geographic regions to reduce the latency of selecting and providing digital components to client devices 110. For example, an MPC cluster having two or more MPC computing systems 900 can be deployed in each zone of a set of zones. If each MPC cluster includes two MPC computing systems, such as MPC1 and MPC2, each region can include a pair of MPC computing systems 900 operated by different parties. Each instance of MPC1 across all regions can be operated by a first party and each instance of MPC2 across all regions can be operated by a second party different from the first party.
An MPC cluster in an area can perform a digital component selection process on digital component requests generated by client devices 110 in the area. For example, instructions sent to a digital component slot, e.g., a tag, of a client device 110 in a particular area can include a reference to a network location of MPC computing system 900 in the particular area. In this manner, application 112 sends digital component requests and notifications to MPC computing system 900 in the appropriate area. In another example, domain Name Service (DNS) or load balancer 910 selects MPC computing system 900 that is closest in physical distance to client device 110.
MPC1 in an area can cooperate with MPC2 in the same area to select a digital component and update a log based on a received request. This reduces latency and consumed bandwidth in performing collaborative computations that require round trips between MPC computing systems 900 because the distance between MPC computing systems 900 is reduced. This also reduces the latency and bandwidth consumed for data transfers between client device 110 and MPC computing system 900, e.g., digital component requests, digital component responses, and impression notifications.
In some embodiments, the log processor pool 940 is enabled only in the appropriate subset of regions for creating and publishing snapshots to the MPC computing system 900 in other regions. For example, a first MPC computing system MPC1 can be present in each region operated by a first party. A subset of these first MPC computing systems are capable of creating snapshots for all of the first MPC computing systems and publishing the snapshots to other first MPC computing systems. Similarly, a second MPC computing system MPC2 can be present in each area operated by the second party. A subset of these second MPC computing systems is able to create snapshots for all of the second MPC computing systems and publish the snapshots to other second MPC computing systems. It is important that the first MPC computing system does not share logs or snapshots with the second MPC computing system, and vice versa, to protect user privacy. However, the first computing system and the second computing system do execute the secure MPC process to process the data in the log because at least some of the data is sensitive and/or confidential and should not be accessed in the clear by either computing system. To do so efficiently and without increased latency or bandwidth consumption, the subset of the first MPC computing system and the subset of the second MPC computing system can be in the same region.
The load balancer 910 receives requests from applications 112 running on the client device 110. These requests, which can be in the form of HTTP requests in some examples, can include digital component requests and notifications. The notification can include an impression notification that notifies MPC computing system 900 that the digital component was displayed at client device 110 and optionally whether the user interacted with the digital component. The impression notification can also include additional information, such as a selection process identifier that identifies a digital component selection process that displays the displayed digital component. For k-anonymous conditions, the impression notification can also include data identifying the winner of the actual digital component process and the winner of the counterfactual selection process, so that the MPC computing system 900 can update the impression count for each digital component.
The load balancer 910 can distribute requests to the processors of the service pool 920 in a manner that balances the load among the processors in the service pool 920. For example, the load balancer 910 can alternate between processors in order, or monitor the load of each processor and distribute requests based on the current load.
Service pool 920 includes multiple processors, each of which can be implemented as, for example, one or more microprocessors, one or more server-class computers, and/or one or more application-specific integrated circuits (ASICs). The processors of the service pool process incoming requests, which are typically latency sensitive. For example, the processor of the service pool 920 can cooperate with a processor of another MPC computing system 900 to perform a digital component selection process. The processors of the service pool 920 can also update the log 930 based on completed digital component processes and/or received notifications.
The processor of the service pool 920 can maintain a current database of digital components for storage. The database can include current values of parameters and/or conditions of the digital components. For example, for each stored digital component, the database can include selection value(s) or vector(s), secret shares for parameters of at least some of the conditions, e.g., conditions for enabling off-line computation, such as k-anonymity and cadence, residual budget, number of impressions (e.g., for k-anonymity conditions), and/or other data for digital components used in the digital component selection process described in this document.
In some embodiments, the database of the service pool is a snapshot. For example, each snapshot can have a version identifier that identifies the version of the snapshot. Both MPC systems should operate using the same version of the snapshot.
The logs 930 can include multiple types of logs that store various information related to the digital components stored by the MPC cluster. For example, log 930 can include a log for storing digital components and their corresponding data, e.g., selection values, selection value vectors, lookup keys, corresponding user group identifier(s), conditions, and/or other suitable information.
Log 930 can include a log of information requested by the digital component for completion. Such a log can include a selection process identifier for each digital component selection process, a liquidation value for the digital component selection process, and parameters for each digital component included in the digital component selection process. These parameters can include, for example, secret shares of candidate parameters, winning parameters, selection values, and/or accumulated values for the digital components.
The log 930 can include a log of parameters for determining whether conditions for the digital component are satisfied. For example, for each digital component, such logs can include the number of impressions, the number of selections, the number of conversions, the total budget, the remaining budget, and/or the number of times the digital component may have been presented (e.g., the number of times selected in the counterfactual selection process for k-anonymity). To protect user privacy and confidentiality of sensitive user data, in some embodiments, log 930 contains secret shares of the above information.
The log processor pool 940 can include a processor (e.g., a microprocessor, server, or ASIC) that processes the log 930 and generates a snapshot 950 based on the log. Each snapshot includes updates to a database maintained by a processor of the service pool 920. For example, if a digital component is selected and displayed at the client device 110, the snapshot can include an updated residual budget for the digital component and an updated impression quantity for the digital component. The log processor pool 940 can generate a snapshot based on the update data in the log 930 and publish the snapshot to the processors of the service pool 920. The processors of the log processor pool 900 may also be able to publish snapshots to other MPC computing systems operated by the same party, for example, if the log processor pool 940 is enabled only at some MPC computing systems 900.
To reduce the latency of responding to requests, the processors of the service pool 920 are able to process requests immediately after they are received. Less time sensitive processes can be processed by the processors of the log processor pool 940. For example, the service pool 920 can perform any process on the critical path that selects and provides digital components to the client device 110. The log processor pool 940 can execute any processes that are not on the critical path. However, updates to the database should occur quickly to ensure that the most up-to-date information is being used to select the digital component. Thus, using a different set of processors as provided by the architecture shown in fig. 9 enables both the digital component selection process and the update to the database to be performed very quickly.
FIG. 10 is a block diagram of an exemplary computer system 1000 that can be used to perform the operations described above. The system 1000 includes a processor 1010, a memory 1020, a storage device 1030, and an input/output device 1040. Each of the components 1010, 1020, 1030, and 1040 can be interconnected, for example, using a system bus 1050. Processor 1010 is capable of processing instructions for execution within system 1000. In some implementations, the processor 1010 is a single-threaded processor. In another implementation, the processor 1010 is a multi-threaded processor. The processor 1010 is capable of processing instructions stored in the memory 1020 or on the storage device 1030.
The storage device 1030 is capable of providing mass storage for the system 1000. In some implementations, the storage 1030 is a computer-readable medium. In various different implementations, the storage 1030 can include, for example, a hard disk device, an optical disk device, a storage device shared by multiple computing devices over a network (e.g., a cloud storage device), or some other mass storage device.
Input/output device 1040 provides input/output operations for system 1000. In some implementations, the input/output device 1040 can include one or more of a network interface device such as an ethernet card, a serial communication device such as an RS-232 port, and/or a wireless interface device such as an 802.11 card. In another embodiment, the input/output devices can include driver devices configured to receive input data and transmit output data to external devices 1060, such as keyboards, printers, and display devices. However, other implementations can also be used, such as mobile computing devices, mobile communication devices, set-top box television client devices, and so forth.
Although an exemplary computing system has been described in fig. 10, implementations of the subject matter and the functional operations described in this specification can be implemented in other types of digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them.
Embodiments of the subject matter and the operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions, encoded on computer storage medium(s) for execution by, or to control the operation of, data processing apparatus. Alternatively or additionally, program instructions can be encoded on an artificially generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. The computer storage medium can be or be included in the following: a computer-readable storage device, a computer-readable storage substrate, a random or serial access memory array or device, or a combination of one or more of them. Further, when the computer storage medium is not a propagated signal, the computer storage medium can be a source or destination of computer program instructions encoded in an artificially generated propagated signal. The computer storage medium can also be or be included in the following: one or more separate physical components or media (e.g., multiple CDs, disks, or other storage devices).
The operations described in this specification can be implemented as operations performed by data processing apparatus on data stored in one or more computer-readable storage devices or received from other sources.
The term "data processing apparatus" encompasses all types of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, a system on a chip, or a plurality or combination of the foregoing. The apparatus can comprise special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit). The apparatus can include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, a cross-platform runtime environment, a virtual machine, or a combination of one or more of them. The apparatus and execution environment are capable of implementing a variety of different computing model architectures, such as Web services, distributed computing, and grid computing architectures.
A computer program (also known as a program, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, object, or other unit suitable for use in a computing environment. The computer program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform actions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for performing actions in accordance with the instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. However, a computer need not have such a device. Moreover, the computer can be embedded in another device, e.g., a mobile telephone, a Personal Digital Assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., a Universal Serial Bus (USB) flash drive), to name a few. Devices suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example: semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other types of devices can also be used to provide for interaction with a user; for example, feedback provided to the user can be any form of sensory feedback, such as visual feedback, auditory feedback, or tactile feedback; also, input from the user can be received in any form, including acoustic, speech, or tactile input. In addition, the computer is able to interact with the user by sending and receiving documents to and from the device used by the user; for example, by sending a Web page to a Web browser on the user's client device in response to a request received from the Web browser.
Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back-end, middleware, or front-end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include: local area networks ("LANs") and wide area networks ("WANs"), the internet (e.g., the internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks).
The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other. In some embodiments, the server transmits data (e.g., HTML pages) to the client device (e.g., for the purpose of displaying data to and receiving user input from a user interacting with the client device). Data generated at the client device (e.g., a result of the user interaction) can be received at the server from the client device.
While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any inventions or of what may be claimed, but rather as descriptions of features specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Furthermore, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.
Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In some cases, multitasking and parallel processing may be advantageous. Moreover, the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
Thus, particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. In some cases, the actions recited in the claims can be performed in a different order and still achieve desirable results. In addition, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In some embodiments, multitasking and parallel processing may be advantageous.
Claims (10)
1. A computer-implemented method, comprising:
receiving, by a first computing system of a secure multi-party computing MPC system, a digital component request and a random number from a client device;
generating an array comprising shares of a bloom filter based on the random number and a function, the shares of the bloom filter representing a user group identifier of a user group that includes a user of the client device as a member;
for each of a plurality of user group identifiers, cooperating with one or more second computing systems of the secure MPC system and using the array to compute a respective first secret share of one or more user group membership condition parameters representing whether the user of the client device is a member of a user group identified by the user group identifier;
for each digital component of the plurality of digital components:
identifying a given user group identifier corresponding to the digital component; and
in cooperation with each of the one or more second computing systems, computing a first secret share of a candidate parameter based on at least a respective first secret share of each user group membership condition parameter corresponding to a given user group identified by the given user group identifier and a second secret share of the user group membership condition parameter corresponding to the given user group identified by the given user group identifier held by each of the one or more second computers, wherein the candidate parameter indicates whether the digital component is a qualified candidate for the digital component request;
generating a first secret share representing a selection result of the selected digital component based on the first secret share of the candidate parameter for each digital component and a selection value for each digital component; and
sending the first secret share of the selection result to the client device.
2. The computer-implemented method of claim 1, wherein calculating the first secret share of the user group membership condition parameter in cooperation with the one or more second computers of the second MPC system comprises calculating the first secret share of the user group membership condition parameter using one of a garbled circuit protocol or a Goldreich-Micali-Wigderson (GMW) protocol.
3. The computer-implemented method of any preceding claim, wherein computing the first secret share of the candidate parameter in cooperation with each of the one or more second computers comprises computing the first secret share of the candidate parameter based on respective secret shares of parameters for one or more additional conditions.
4. The computer-implemented method of any preceding claim, further comprising:
receiving an additional random number to an additional bloom filter representing the set of blocked digital components;
generating an additional array of shares representing the additional bloom filter; and
for one or more of the plurality of digital components, calculating, in cooperation with the one or more second computing systems and using the additional array, a first secret share of a blocking condition parameter representing whether the digital component is blocked at the client device, wherein the candidate parameter for the digital component is based on the blocking condition parameter.
5. The computer-implemented method of any preceding claim, wherein the first secret share of the selection result comprises a result computed by performing a bitwise XOR operation between a secret share of the selection result and a second mask received from the client device.
6. The computer-implemented method of any preceding claim, wherein the first computing system comprises a service pool comprising a set of processors and a load balancer to balance computing load among the set of processors.
7. The computer-implemented method of claim 6, wherein the first computing system comprises a log processor pool comprising a set of additional processors that generate a snapshot based on updates to a log comprising data related to a completed digital component selection process and provide the snapshot to the service pool.
8. A system, comprising:
one or more processors; and
one or more storage devices storing instructions that, when executed by the one or more processors, cause the one or more processors to perform the method of any preceding claim.
9. A computer-readable storage medium carrying instructions that, when executed by one or more processors, cause the one or more processors to perform the method of any one of claims 1-8.
10. A computer program product comprising instructions which, when executed by a computer, cause the computer to perform the steps of the method according to any one of claims 1 to 7.
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
IL281330A IL281330A (en) | 2021-03-08 | 2021-03-08 | Enhanced performance of secure multi-party computation |
IL281330 | 2021-03-08 | ||
PCT/US2022/019182 WO2022192152A1 (en) | 2021-03-08 | 2022-03-07 | Enhanced performance of secure multi-party computation |
Publications (1)
Publication Number | Publication Date |
---|---|
CN115428395A true CN115428395A (en) | 2022-12-02 |
Family
ID=80952162
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN202280003612.9A Pending CN115428395A (en) | 2021-03-08 | 2022-03-07 | Enhanced performance for secure multi-party computing |
Country Status (7)
Country | Link |
---|---|
US (1) | US20230155820A1 (en) |
EP (1) | EP4128653A1 (en) |
JP (1) | JP7471450B2 (en) |
KR (1) | KR20220155370A (en) |
CN (1) | CN115428395A (en) |
IL (1) | IL281330A (en) |
WO (1) | WO2022192152A1 (en) |
Family Cites Families (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
FR2984559B1 (en) | 2011-12-20 | 2015-10-23 | Morpho | IDENTIFICATION OF INDIVIDUALS BY SECURE CALCULATION |
US10721063B2 (en) | 2015-05-07 | 2020-07-21 | Nec Corporation | Secure computation data utilization system, method, apparatus and non-transitory medium |
US11553335B2 (en) | 2019-05-07 | 2023-01-10 | Qualcomm Incorporated | Secure multiparty computation for Internet of Things communications |
US11222129B2 (en) | 2019-06-24 | 2022-01-11 | International Business Machines Corporation | Entity resolution between multiple private data sources |
-
2021
- 2021-03-08 IL IL281330A patent/IL281330A/en unknown
-
2022
- 2022-03-07 KR KR1020227036224A patent/KR20220155370A/en unknown
- 2022-03-07 CN CN202280003612.9A patent/CN115428395A/en active Pending
- 2022-03-07 WO PCT/US2022/019182 patent/WO2022192152A1/en unknown
- 2022-03-07 JP JP2022564428A patent/JP7471450B2/en active Active
- 2022-03-07 US US17/916,871 patent/US20230155820A1/en active Pending
- 2022-03-07 EP EP22713143.0A patent/EP4128653A1/en active Pending
Also Published As
Publication number | Publication date |
---|---|
JP2023529783A (en) | 2023-07-12 |
JP7471450B2 (en) | 2024-04-19 |
KR20220155370A (en) | 2022-11-22 |
US20230155820A1 (en) | 2023-05-18 |
WO2022192152A1 (en) | 2022-09-15 |
EP4128653A1 (en) | 2023-02-08 |
IL281330A (en) | 2022-10-01 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
JP7471425B2 (en) | Feedback Controller Using Secret Sharing | |
JP2023067928A (en) | Using secure multi-party computation to improve content selection process integrity | |
US20230188329A1 (en) | Using secure multi-party computation and probabilistic data structures to protect access to information | |
KR20220140759A (en) | Processing of machine learning modeling data to improve classification accuracy | |
KR20230048126A (en) | Cryptographic Security Control Using Secure Multiparty Operations | |
JP7397212B2 (en) | Using secure MPC and vector computation to protect access to information in content delivery | |
JP7440667B2 (en) | Flexible content selection process using secure multiparty calculations | |
JP7425222B2 (en) | Privacy Preserving Measurements Using Secure Multiparty Computation | |
JP7471450B2 (en) | Improving the performance of secure multiparty computation | |
WO2024030200A1 (en) | Single request architecture for increasing efficiency of secure multi-party computations |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
SE01 | Entry into force of request for substantive examination |