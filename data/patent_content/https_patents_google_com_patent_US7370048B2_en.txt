US7370048B2 - File storage method and apparatus - Google Patents
File storage method and apparatus Download PDFInfo
- Publication number
- US7370048B2 US7370048B2 US11/140,382 US14038205A US7370048B2 US 7370048 B2 US7370048 B2 US 7370048B2 US 14038205 A US14038205 A US 14038205A US 7370048 B2 US7370048 B2 US 7370048B2
- Authority
- US
- United States
- Prior art keywords
- data record
- slot
- new
- advancement amount
- incremental advancement
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Fee Related, expires
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/22—Indexing; Data structures therefor; Storage structures
- G06F16/2228—Indexing structures
- G06F16/2255—Hash tables
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99931—Database or file accessing
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99931—Database or file accessing
- Y10S707/99937—Sorting
Definitions
- the present invention relates to data storage and retrieval systems and more particularly to a method and system for relocating records that hash to the same location in a data table and storing said relocated records in an optimal and efficient manner.
- Storing records in a data table is a common task. Applications are designed to retrieve banking records, credit records, employee records, student records or any other type of record using various search algorithms. Many common techniques employ search algorithms to search through the data table in order to place records in empty slots or “buckets”. Serial search algorithms and hashing algorithms are a few examples.
- a serial or linear search algorithm searches through the data table one slot at a time until an available slot is discovered. Thus, starting at the beginning of the table, each slot is examined until an empty slot is found. Of course, this may be very time consuming if the next available slot for a 1,000-location data table is 600 slots away, since 599 slots will have to be checked before an available slot is found.
- Hashing is a method that stores data in a data table such that storing, searching, retrieving, and inserting and deleting data can be done much faster than by traditional linear search methods. Hashing is very useful in scenarios where data record keys do not map directly into data table locations. As an example, if 100 student ID numbers all fall within a particular value range, e.g., 0 to 99, it would be simple to map each data record into a corresponding slot in the data table. Student ID Number 1 would be mapped into data slot number 1, etc. Thus, each data record, identified by a “key” value, is mapped directly to a corresponding slot, so retrieving the record at a later date would be immediate.
- a hash function can be created to store the 100 records in an array of a much smaller size in order to efficiently store, and later retrieve, each of the records.
- the student ID numbers each ID number is a “key” that identifies each record
- a hash function could be constructed to store each record in an array comprised of only 100 slots. Therefore, an array called data can store a record with a student ID number “x” at index data [x/100] (where only the quotient is used and not the remainder).
- information relating to a student with ID number 600 can be stored in array slot with index number 6, i.e. data [6].
- the result above represents the ideal situation where every key, when hashed, produces a unique index. This is known as perfect hashing and is very difficult to achieve unless the database designer has every record before them prior to creating the data table.
- the common scenario is when two or more records hash to the identical physical location, (i.e., the record's “home address”) in the data table. This is known as a “collision”. In the above example, a collision would occur if the student ID number is not 400, but is instead 399.
- Two or more records that hash to the identical home address represent what is known as a “chain”. A mechanism is needed to relocate records to available slots in the data table and to link pieces of the chain together.
- a method of measuring the effectiveness of these methods is to compare how many probes (a probe is a physical access of a location in the data table) is needed on average in order to retrieve each record once. For example, a chain of three records that are linked in a simple way so that each probe also identifies the exact location of the next record in the chain would require one probe for the first record, two probes for the second record (a “stop” at the first record before going to the second) and three probes for the third record. This provides an average of two probes (6 probes/3 records) to reach each record once.
- Another way to compare hashing methods is to examine the amount of extra storage that is required in the table in order to link the chains.
- the table below has seven locations (0-6).
- a third method of comparing hashing functions is to examine the ease of insertion of the new records into the data table.
- a method that relocates records in the chain away from their home addresses will cause those records to occupy positions in the table that can, in turn, be the home locations for other records. This can result in two or more chains being interlinked, which is referred to as “coalescing”. Coalescing can cause the number of probes to increase, since a search would not only have to traverse a chain of common “home” records, but also the records of another chain that are interspersed with the first chain. Methods for eliminating coalesced chains require that records which were previously inserted need to be moved every time two chains are about to coalesce.
- Double hashing methods utilize two hash functions.
- the first hash function produces the home address of the record to be inserted into the data table.
- the second hash function is used to create a variable increment, which is used to skip a number of positions in the data table in an attempt to find an empty slot.
- the data table is considered to be circular so that once the bottom of the table is reached, the count wraps around to the top of the table.
- the Linear Quotient method does not require any link fields but does allow chains to coalesce. On the average, this method requires a high number of probes.
- Computed Chaining method Another hashing technique commonly used is the Computed Chaining method. This method can use algorithm INC above, but applied to the key already stored at a location, and uses that increment to jump as many times as necessary to find an empty location in which to place the key. The multiplier of the increment is then stored in the table as a “number of offsets” field. That field normally requires six bits for a table size of approximately 1,000 records. However, this field can be limited to any number of bits by requiring more intermediate probes. Coalesced chains are resolved by moving keys that are in the way of the new key and that are not at their home addresses. However, this requires movement of all the records that followed the moved key in the chain.
- the present invention addresses the deficiencies of the art with respect to data storage and retrieval systems and provides a novel and non-obvious system and method for relocating records that hash to the same location in a data table and storing said relocated records in an optimal and efficient manner.
- the method provides a data storage mechanism using a first hash function to attempt to place a key representing a data record in a home address and a second hash function to place the key if a collision occurs due to the existence of a stored data record in the home address.
- Different incremental advancement quantities are calculated based on the result of the application of the second hash function to each of the new data record and the stored data record.
- the new data record is then placed in the data table depending on the fewest number of incremental advancement quantities needed to locate an unoccupied location in the data table.
- a method of storing data in a data table includes a plurality of data record storage slots.
- the method includes application of a first hash function on a new data record, where the first hash function is for placing the new data record in a home slot in the data table. If it is determined that the home slot already contains a stored data record, a second hash function is applied on each of the new data record and the stored data record to determine a new target slot. Application of each second hash function results in an increment advancement amount for the new data record and an incremental advancement amount for the stored data record. The new data record is then stored in the new target slot, the new target slot being determined based on one or both of the incremental advancement amount for the new data record and the incremental advancement amount for the stored data record.
- a system for storing a plurality of data records in a data table includes a plurality of data record storage slots.
- the system includes a computer having a database, a memory unit, and a processor.
- the database is adapted to store each of the plurality of data records in a corresponding data record storage slot and the memory is adapted for storing one or more hashing algorithms.
- the processor is adapted for applying the one or more hashing algorithms to the plurality of data records for placement of a new data record in a corresponding data record storage slot.
- the hashing algorithms include a first hashing algorithm for placing the a data record in a home data record storage slot, and a second hashing algorithm for determining a new target slot for the new data record if the new data record collides with a stored data record.
- Application of the second hash function results in an increment advancement amount for the new data record and an incremental advancement amount for the stored data record, where the new target slot is determined based on one or both of the incremental advancement amount for the new data record and the incremental advancement amount for the stored data record.
- a machine readable storage device having stored thereon a computer program for storing data in a data table, the data table including a plurality of data record storage slots.
- the computer program includes a set of instructions which when executed by a machine causes the machine to perform a method.
- the method includes applying a first hash function to a new data record, the first hash function for placing the new data record in a home slot in the data table. If it is determined that the home slot already contains a stored data record, a second hash function is applied to each of the new data record and the stored data record to determine a new target slot. Application of each second hash function results in an increment advancement amount for the new data record and an incremental advancement amount for the stored data record.
- the new data record is stored in the new target slot, where the new target slot is determined based on one or both of the incremental advancement amount for the new data record and the incremental advancement amount for the stored data record.
- FIG. 1 is a block diagram illustrating a computer database incorporating the present invention
- FIG. 2 is a flowchart illustrating the inventive method
- FIG. 3 is a data table in its initialized state
- FIG. 4 is the data table after insertion of an initial key utilizing the inventive method
- FIG. 5 is the data table illustrating a collision with a stored key and calculated incremental advancement quantities utilizing the inventive method
- FIG. 6 is the data table illustrating the placement of a key and the updating of the pseudo-link utilizing the inventive method
- FIG. 7 is the data table illustrating the placement of a key after determining which incremental advancement quantity has the fewest jumps to an unoccupied slot
- FIG. 8 is the data table illustrating the placement of a key and updating of the pseudo-link
- FIG. 9 is the data table illustrating a collision and incremental advancement of the key after determining which incremental advancement quantity has the fewest jumps to an unoccupied slot;
- FIG. 10 is the data table illustrating another collision and incremental advancement of the key
- FIG. 11 is the data table illustrating the insertion of the final key utilizing the invention method.
- FIG. 12 is the data table after insertion of all data records utilizing the invention method.
- the present invention advantageously provides a method and system for storing data in a data storage table of a computer that utilizes hashing functions that result in the optimal placement of data records in the data table while minimizing the number of insertion probes and facilitating the placement of keys associated with each data record.
- System 100 includes a general process computer 10 .
- Computer 10 can be a desktop or laptop computer, a personal digital assistant (“PDA”) or the like.
- Computer 10 includes hardware components as known in the art and as may be required to implement the functions of the present invention described herein.
- computer 10 may include a central processing unit 15 , a memory unit, such as volatile or non-volatile memory 20 , a data storage unit 25 and communication bus 30 .
- Input and output devices, such as monitor 35 , keyboard 40 , mouse, 45 and printer 50 are coupled to bus 30 .
- a remote data storage unit (not shown) may also be incorporated into system.
- the hardware components are controlled by an operating system and/or one or more application software programs.
- Computer 10 may also be part of a communication network such as the Internet.
- the present invention focuses on data storage unit 25 and methods for storing and retrieving data stored therein.
- Each data record is assigned a key, via step S 55 .
- the key can be any numerical value provided each data record is associated with a unique key.
- Data storage unit 25 includes one or more data tables, in which the data records are stored. An attempt is made to insert a key representing an initial data record into a slot in the data table, via step S 60 . If the slot is not already occupied by a key, the key representing the initial data record is inserted into the slot, via step S 70 . A first hash function is used to determine where the key is to be placed in the data table. The slot where the key now resides is referred to as that key's “home address”.
- the data table includes a multi-bit pseudo-link field associated with each slot.
- the link represents a code that directs one to the slot where the key that hashed to this home address has been relocated. If the pseudo-code indicates that there are no other data records that hash to the same slot in the data table (i.e., a pseudo-code of “00”), then incremental advancement quantities must be determined via a second hash function, at step S 75 . It is by these quantities (discussed below in greater detail) that the key is advanced in the hopes that an unoccupied slot in the data table will be found. If more than one slot is available, an incremental advancement quantity is determined by selection criteria.
- the link field may have to be updated, via step S 85 , to reflect the relocation of the incoming key. Referring to this link field at a later time assists in locating and retrieving specific data records.
- the data record is then stored in the available slot, via step S 87 .
- step S 68 If, after checking the pseudo-code, it is determined that there are other data records that hash to the same location, an incremental advancement amount based on the value of the pseudo-code is determined, at step S 68 . The key is advanced by the same increment until an unoccupied slot is found, via step S 69 . If it is determined that additional data records have to be inserted with the data table via step S 90 , the process is repeated until all data records have been inserted into the data table.
- FIGS. 3 through 12 illustrate the inventive method of the present invention by showing how a series of data records are placed within a data table.
- the invention provides a hashing function that places keys representing data records in data table slots in an efficient manner.
- a data table 95 is shown in FIG. 3 containing eleven slots.
- data table 95 may hold eleven separate data records, or keys that represent the data records.
- the present invention is not limited to the size of the data table or the number of records that are to be placed in the table.
- the size of data table 95 i.e., the number of slots in table 95 , is a prime number.
- nine data records are to be placed in table 95 , which contains 11 available slots.
- Data table 95 includes several fields.
- Slot number field 115 contains slots numbered, in this example, 0 through 10. Each slot has a corresponding key field 105 and pseudo-link field 110 .
- pseudo-link field 110 includes a two-bit “jump” link. However, two or more binary digits may be used depending upon the size of the data table.
- Nine keys, each representing a specific data record, are to be placed in table 95 .
- the keys may be numeric or alphanumeric and may represent any size data record.
- the data records are stored separately from the keys. Use of a pointer can direct a user from a key to its associated data record.
- data table 95 is initialized and has the appearance of the table depicted in FIG. 3 .
- key number 22 representing a data record
- a hash function is used to determine the placement of the key in order to find its “home” address.
- the present invention may invoke one of a number of different hash functions in order to place the key in its home address.
- data table 95 is checked to determine if any key has already been placed in slot 0 . Since this slot is unoccupied, key 22 is placed in this slot resulting in data table 95 as shown in FIG. 4 without the occurrence of a collision.
- the result is a collision since the application of the hash function for key number 13 provides the identical remainder, namely 2. Since key 13 is already located in slot 2 , a new location has to be found for key 24 .
- the present invention advantageously incorporates a double hashing mechanism, i.e.
- a first hash function that determines the key's home address
- a second hash function that is an incremental function used to define a “jump” scheme, which when used, enables a limited number of searches or “probes” before an unoccupied slot is located for placement therein of the incoming key.
- the pseudo-code or “jump” field 10 is first examined. If the field is represented by the entry “00” and a collision similar to the one described above has occurred, the second, or incremental hash function is invoked.
- a “00” entry in field 110 is illustrative of one of many different types of link codes that may be used in the present invention. In this example, an entry of “00” means there are presently no other data records in the chain. Of course, this field may need to be updated if other records hash to this slot.
- the incremental hash function uses a quotient method.
- the quotient of the key divided by the size of table 95 is calculated, and the remainder is discarded. Both keys are used, i.e., the key to be inserted into table 95 (key 24 ), as well as the key which caused the collision and already resides in the desired slot (key 13 ).
- the resulting quotient using each key is used as a separate incremental “jump”, as is the sum of the resulting quotients.
- a new “jump” amount is computed and is equal to the initial “jump” amount mod the size of the data table.
- the result for key 24 (the key to be inserted) is 2 (24/11 results in a quotient of 2, and a remainder of 2, which is discarded), and the result for key 13 (the key already residing in slot 2 ) is 1 (13/11 results in a quotient of 1, and remainder of 2, which is disregarded).
- the incremental hash function of the present invention results in three “jumps” from slot 2 ; a jump of 2 (the result of the hash function applied to key 24 ), a jump of 1 (the result of the hash function applied to key 13 ) and a jump of 3 (the sum of the individual results of the hash function applied to each key).
- slot 3 (slot 2 +an incremental jump of 1)
- slot 4 (slot 2 +an incremental jump of 2)
- slot 5 (slot 2 +an incremental jump of 3) are checked for availability. It should be noted that if any calculated increment or sum of increments equal zero, the number is preferably changed to an incremental advancement value of 1.
- an attempt to insert key 24 in slot 2 results in a collision because of the presence of key 13 in slot 2 (indicated by the circle around key 13 ).
- three alternate slots are checked for availability, slots 3 , 4 and 5 , indicated by the dotted lines. Because all three alternate slots are unoccupied, and each incremental advance results in only one jump before an unoccupied slot is found, key 24 may be placed in any of slots.
- the invention may determine placement pf the incoming record by one of any commonly known selection criteria.
- the increment calculated for the incoming record is used first, followed by the increment calculated for the stored key, followed by the increment associated with the sum of each increment.
- key 24 the “incoming” key, is placed in slot 4 and link 110 for slot 2 is updated to reflect the new location of key 24 .
- the invention may use different slot section criteria.
- the slot selected for insertion of the incoming key is based on the incremental jump associated with the stored key (i.e., a key in the slot initially determined to be the “home address” of the incoming key).
- the invention includes the following slot selection criteria when application of the incremental hash function results in two or more available slots in data table 95 :
- Pseudo-link field 110 is used to assist in locating data records. Referring to FIG. 6 , it can be seen that the pseudo-link 110 for slot 2 changed from “00” to “01”.
- the present invention applies binary link codes to table 95 in order to facilitate locating keys that may have been relocated due to collisions.
- a link field of “00” means that there are no other records in the chain, i.e., there were no collisions for that particular slot.
- a link field of “01” means that the key relocation increment was calculated using the incremental hash function described above for the key that is trying to be inserted into the slot.
- a link field of “10” means that the key relocation increment was calculated using the incremental hash function described above for the key that already exists in that position. Thus, if key 24 was ultimately placed in slot 3 , then link 110 for this slot would have been “10” since slot 3 is a jump of 1 from slot 2 , and 1 was the result of the incremental hash function for key 13 (the key that “already exists in that position”). Finally, a link 110 of “11” means that the increment was determined by adding the results of the hash functions as applied to each key. Thus, slot 2 would include a link of “11” if key 24 had been placed in slot 5 .
- the resulting data table 95 is shown in FIG. 7 .
- slot 3 is chosen based upon the increment (2) determined for the key already stored at table slot 1 because the increment associated with the incoming key, (3) leads to an occupied slot (slot 4 ).
- key 34 is placed in slot 3 , and pseudo-link 110 for slot 1 is updated to “10” as shown in FIG. 8 .
- any of the above-described selection criteria can be used to determine where an incoming key is to be placed when two or more slots are available.
- the selection criteria being used places an incoming key into a slot associated with the sum of each key corresponding increments (in this case, 5) first, key 34 would be placed in slot 6 .
- pseudo-link 110 at slot 0 is set to “11” using the link definitions defined above, to indicate that the data record for key 11 can be found to be in a slot “x” number of slots away from its intended home address (slot 0 ), where “x” is the sum of the increments calculated for each key.
- the result is data table 95 as it appears in FIG. 10 .
- the first step in the process is to check the pseudo-link field 110 for that slot.
- the link field for slot 0 has already been set at “11”. Therefore, the sum of the increments for each key must be used.
- Slot 5 is open and key 33 is placed there as shown in FIG. 11 .
- the final key, key number 48 hashes to a home address of slot 4 , which is already occupied by key 24 , thus creating a collision.
- Beginning in slot 4 using an increment of 4 would require a sequence of four jumps: slot 8 (occupied by key 8 ), slot 1 (occupied by key 23 ), slot 5 (occupied by key 33 ) and slot 9 (unoccupied).
- Using an increment of 2 would require a sequence of three jumps: slot 6 (occupied by key 11 ), slot 8 (occupied by key 8 ), and slot 10 (unoccupied).
- the data table 95 shown in FIG. 12 represents the final data table after all the data records have been stored and the final link 110 has been updated.
- the present invention can be realized in hardware, software, or a combination of hardware and software.
- An implementation of the method and system of the present invention can be realized in a centralized fashion in one computer system, or in a distributed fashion where different elements are spread across several interconnected computer systems. Any kind of computer system, or other apparatus adapted for carrying out the methods described herein, is suited to perform the functions described herein.
- a typical combination of hardware and software could be a general purpose computer system with a computer program that, when being loaded and executed, controls the computer system such that it carries out the methods described herein.
- the present invention can also be embedded in a computer program product, which comprises all the features enabling the implementation of the methods described herein, and which, when loaded in a computer system is able to carry out these methods.
- Computer program or application in the present context means any expression, in any language, code or notation, of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after either or both of the following a) conversion to another language, code or notation; b) reproduction in a different material form.
Abstract
Description
0 | 47 | |
1 | 23 | 3 |
2 | ||
3 | 52 | 0 |
4 | ||
5 | ||
6 | ||
-
- (a) First: incoming key increment; Second: stored key increment; Third: sum
- (b) First: incoming key increment; Second: sum; Third: stored key increment
- (c) First: stored key increment; Second: incoming key increment; Third: sum
- (d) First: stored key increment; Second: sum; Third: incoming key increment
- (e) First: sum; Second: incoming key increment; Third: stored key increment
- (f) First: sum; Second: stored key increment; Third: incoming key increment
Claims (8)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US11/140,382 US7370048B2 (en) | 2005-05-27 | 2005-05-27 | File storage method and apparatus |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US11/140,382 US7370048B2 (en) | 2005-05-27 | 2005-05-27 | File storage method and apparatus |
Publications (2)
Publication Number | Publication Date |
---|---|
US20060271539A1 US20060271539A1 (en) | 2006-11-30 |
US7370048B2 true US7370048B2 (en) | 2008-05-06 |
Family
ID=37464686
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US11/140,382 Expired - Fee Related US7370048B2 (en) | 2005-05-27 | 2005-05-27 | File storage method and apparatus |
Country Status (1)
Country | Link |
---|---|
US (1) | US7370048B2 (en) |
Cited By (21)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20090070354A1 (en) * | 2007-09-11 | 2009-03-12 | Kumar Hemachandra Chellapilla | Minimal perfect hash functions using double hashing |
US20130007008A1 (en) * | 2010-09-13 | 2013-01-03 | Tencent Technology (Shenzhen) Company Limited | Hash algorithm-based data storage method and system |
US20130086004A1 (en) * | 2011-10-03 | 2013-04-04 | H. Jonathan Chao | Updating a perfect hash data structure, such as a multi-dimensional perfect hash data structure, used for high-speed string matching |
US8745013B2 (en) | 2012-05-19 | 2014-06-03 | International Business Machines Corporation | Computer interface system |
US9081672B1 (en) | 2013-05-30 | 2015-07-14 | Richard Michael Nemes | Methods and apparatus for information storage and retrieval using a caching technique with external-chain hashing and dynamic resource-dependent data shedding |
US20150205727A1 (en) * | 2014-01-17 | 2015-07-23 | Netapp, Inc. | Set-associative hash table organization for efficient storage and retrieval of data in a storage system |
US9104678B1 (en) * | 2011-12-31 | 2015-08-11 | Richard Michael Nemes | Methods and apparatus for information storage and retrieval using a caching technique with probe-limited open-address hashing |
US9671960B2 (en) | 2014-09-12 | 2017-06-06 | Netapp, Inc. | Rate matching technique for balancing segment cleaning and I/O workload |
US9710317B2 (en) | 2015-03-30 | 2017-07-18 | Netapp, Inc. | Methods to identify, handle and recover from suspect SSDS in a clustered flash array |
US9720601B2 (en) | 2015-02-11 | 2017-08-01 | Netapp, Inc. | Load balancing technique for a storage array |
US9740566B2 (en) | 2015-07-31 | 2017-08-22 | Netapp, Inc. | Snapshot creation workflow |
US9762460B2 (en) | 2015-03-24 | 2017-09-12 | Netapp, Inc. | Providing continuous context for operational information of a storage system |
US9798728B2 (en) | 2014-07-24 | 2017-10-24 | Netapp, Inc. | System performing data deduplication using a dense tree data structure |
US9836229B2 (en) | 2014-11-18 | 2017-12-05 | Netapp, Inc. | N-way merge technique for updating volume metadata in a storage I/O stack |
US10133511B2 (en) | 2014-09-12 | 2018-11-20 | Netapp, Inc | Optimized segment cleaning technique |
US10911328B2 (en) | 2011-12-27 | 2021-02-02 | Netapp, Inc. | Quality of service policy based load adaption |
US10929022B2 (en) | 2016-04-25 | 2021-02-23 | Netapp. Inc. | Space savings reporting for storage system supporting snapshot and clones |
US10951488B2 (en) | 2011-12-27 | 2021-03-16 | Netapp, Inc. | Rule-based performance class access management for storage cluster performance guarantees |
US10997098B2 (en) | 2016-09-20 | 2021-05-04 | Netapp, Inc. | Quality of service policy sets |
US11379119B2 (en) | 2010-03-05 | 2022-07-05 | Netapp, Inc. | Writing data in a distributed data storage system |
US11386120B2 (en) | 2014-02-21 | 2022-07-12 | Netapp, Inc. | Data syncing in a distributed system |
Families Citing this family (10)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US7895211B2 (en) * | 2006-11-03 | 2011-02-22 | International Business Machines Corporation | Method and system for reinserting a chain in a hash table |
KR100943908B1 (en) | 2008-02-19 | 2010-02-24 | 엘지전자 주식회사 | Method For Transmitting and Receiving Control Information Through PDCCH |
CN102164353B (en) * | 2011-04-13 | 2013-08-28 | 青岛海信移动通信技术股份有限公司 | Multimedia message service (MMS) information resolution method and equipment |
US9117502B2 (en) * | 2013-02-06 | 2015-08-25 | Fixnetix Ltd. | System and method for memory management of unique alpha-numeric order identifiers subjected to hashing and truncation for mapping to limited memory space |
US20160103623A1 (en) * | 2014-10-14 | 2016-04-14 | Industry Academic Cooperation Foundation Of Yeungnam University | Method for controlled collision of hash algorithm based on nand flash memory |
US11249970B2 (en) * | 2016-05-05 | 2022-02-15 | Mastercard International Incorporated | Method and system for distributed data storage with eternal integrity guarantees |
US11782895B2 (en) * | 2020-09-07 | 2023-10-10 | Mellanox Technologies, Ltd. | Cuckoo hashing including accessing hash tables using affinity table |
US11917042B2 (en) | 2021-08-15 | 2024-02-27 | Mellanox Technologies, Ltd. | Optimizing header-based action selection |
US11929837B2 (en) | 2022-02-23 | 2024-03-12 | Mellanox Technologies, Ltd. | Rule compilation schemes for fast packet classification |
US11968285B2 (en) | 2022-02-24 | 2024-04-23 | Mellanox Technologies, Ltd. | Efficient memory utilization for cartesian products of rules |
Citations (29)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4290105A (en) * | 1979-04-02 | 1981-09-15 | American Newspaper Publishers Association | Method and apparatus for testing membership in a set through hash coding with allowable errors |
JPH0528290A (en) | 1991-07-18 | 1993-02-05 | Mitsubishi Electric Corp | Data driven type computer |
US5339398A (en) * | 1989-07-31 | 1994-08-16 | North American Philips Corporation | Memory architecture and method of data organization optimized for hashing |
US5390359A (en) * | 1992-03-20 | 1995-02-14 | International Business Machines Corporation | Storing and retrieving records in a computer system |
US5390173A (en) * | 1992-10-22 | 1995-02-14 | Digital Equipment Corporation | Packet format in hub for packet data communications system |
US5418947A (en) * | 1992-12-23 | 1995-05-23 | At&T Corp. | Locating information in an unsorted database utilizing a B-tree |
US5526363A (en) | 1995-05-16 | 1996-06-11 | Telco Systems, Inc. | Multicontext compression system with shared data structures |
US5809494A (en) * | 1995-11-16 | 1998-09-15 | Applied Language Technologies, Inc. | Method for rapidly and efficiently hashing records of large databases |
US5893120A (en) | 1997-01-02 | 1999-04-06 | Nemes; Richard Michael | Methods and apparatus for information storage and retrieval using a hashing technique with external chaining and on-the-fly removal of expired data |
US5987462A (en) * | 1996-04-26 | 1999-11-16 | Hitachi, Ltd. | Parallel data base record distribution method and parallel data base management system |
US6031935A (en) * | 1998-02-12 | 2000-02-29 | Kimmel; Zebadiah M. | Method and apparatus for segmenting images using constant-time deformable contours |
US6226629B1 (en) * | 1997-02-28 | 2001-05-01 | Compaq Computer Corporation | Method and apparatus determining and using hash functions and hash values |
US6442553B1 (en) * | 1994-10-31 | 2002-08-27 | Fujitsu Limited | Hash system and hash method for transforming records to be hashed |
US6449613B1 (en) * | 1999-12-23 | 2002-09-10 | Bull Hn Information Systems Inc. | Method and data processing system for hashing database record keys in a discontinuous hash table |
US20030018878A1 (en) * | 2001-07-19 | 2003-01-23 | Sean Matthew Dorward | Method and apparatus for archival data storage |
US20030028547A1 (en) * | 1999-06-30 | 2003-02-06 | Microsoft Corporation | Method and apparatus for finding nearest logical record in a hash table |
US6567817B1 (en) | 2000-09-08 | 2003-05-20 | Hewlett-Packard Development Company, L.P. | Cache management system using hashing |
US6625612B1 (en) * | 2000-06-14 | 2003-09-23 | Ezchip Technologies Ltd. | Deterministic search algorithm |
US6725223B2 (en) * | 2000-12-22 | 2004-04-20 | International Business Machines Corporation | Storage format for encoded vector indexes |
US20040220975A1 (en) | 2003-02-21 | 2004-11-04 | Hypertrust Nv | Additional hash functions in content-based addressing |
US20040230989A1 (en) * | 2003-05-16 | 2004-11-18 | Macey William H. | Method and apparatus for survey processing |
US20040267745A1 (en) * | 2001-11-13 | 2004-12-30 | Jan Hoogerbrugge | Entry locking for large data structures |
US6862602B2 (en) * | 1997-03-07 | 2005-03-01 | Apple Computer, Inc. | System and method for rapidly identifying the existence and location of an item in a file |
US20050229254A1 (en) * | 2004-04-08 | 2005-10-13 | Sumeet Singh | Detecting public network attacks using signatures and fast content analysis |
US20050251524A1 (en) * | 2004-05-06 | 2005-11-10 | Vikram Shukla | Method and apparatus for using a hash-partitioned index to access a table that is not partitioned or partitioned independently of the hash partitioned index |
US7058639B1 (en) * | 2002-04-08 | 2006-06-06 | Oracle International Corporation | Use of dynamic multi-level hash table for managing hierarchically structured information |
US20060143168A1 (en) * | 2004-12-29 | 2006-06-29 | Rossmann Albert P | Hash mapping with secondary table having linear probing |
US20060218176A1 (en) * | 2005-03-24 | 2006-09-28 | International Business Machines Corporation | System, method, and service for organizing data for fast retrieval |
US20060248079A1 (en) * | 2005-04-28 | 2006-11-02 | Freescale Semiconductor Incorporated | Method and apparatus for finding a perfect hash function and making minimal hash table for a given set of keys |
-
2005
- 2005-05-27 US US11/140,382 patent/US7370048B2/en not_active Expired - Fee Related
Patent Citations (29)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4290105A (en) * | 1979-04-02 | 1981-09-15 | American Newspaper Publishers Association | Method and apparatus for testing membership in a set through hash coding with allowable errors |
US5339398A (en) * | 1989-07-31 | 1994-08-16 | North American Philips Corporation | Memory architecture and method of data organization optimized for hashing |
JPH0528290A (en) | 1991-07-18 | 1993-02-05 | Mitsubishi Electric Corp | Data driven type computer |
US5390359A (en) * | 1992-03-20 | 1995-02-14 | International Business Machines Corporation | Storing and retrieving records in a computer system |
US5390173A (en) * | 1992-10-22 | 1995-02-14 | Digital Equipment Corporation | Packet format in hub for packet data communications system |
US5418947A (en) * | 1992-12-23 | 1995-05-23 | At&T Corp. | Locating information in an unsorted database utilizing a B-tree |
US6442553B1 (en) * | 1994-10-31 | 2002-08-27 | Fujitsu Limited | Hash system and hash method for transforming records to be hashed |
US5526363A (en) | 1995-05-16 | 1996-06-11 | Telco Systems, Inc. | Multicontext compression system with shared data structures |
US5809494A (en) * | 1995-11-16 | 1998-09-15 | Applied Language Technologies, Inc. | Method for rapidly and efficiently hashing records of large databases |
US5987462A (en) * | 1996-04-26 | 1999-11-16 | Hitachi, Ltd. | Parallel data base record distribution method and parallel data base management system |
US5893120A (en) | 1997-01-02 | 1999-04-06 | Nemes; Richard Michael | Methods and apparatus for information storage and retrieval using a hashing technique with external chaining and on-the-fly removal of expired data |
US6226629B1 (en) * | 1997-02-28 | 2001-05-01 | Compaq Computer Corporation | Method and apparatus determining and using hash functions and hash values |
US6862602B2 (en) * | 1997-03-07 | 2005-03-01 | Apple Computer, Inc. | System and method for rapidly identifying the existence and location of an item in a file |
US6031935A (en) * | 1998-02-12 | 2000-02-29 | Kimmel; Zebadiah M. | Method and apparatus for segmenting images using constant-time deformable contours |
US20030028547A1 (en) * | 1999-06-30 | 2003-02-06 | Microsoft Corporation | Method and apparatus for finding nearest logical record in a hash table |
US6449613B1 (en) * | 1999-12-23 | 2002-09-10 | Bull Hn Information Systems Inc. | Method and data processing system for hashing database record keys in a discontinuous hash table |
US6625612B1 (en) * | 2000-06-14 | 2003-09-23 | Ezchip Technologies Ltd. | Deterministic search algorithm |
US6567817B1 (en) | 2000-09-08 | 2003-05-20 | Hewlett-Packard Development Company, L.P. | Cache management system using hashing |
US6725223B2 (en) * | 2000-12-22 | 2004-04-20 | International Business Machines Corporation | Storage format for encoded vector indexes |
US20030018878A1 (en) * | 2001-07-19 | 2003-01-23 | Sean Matthew Dorward | Method and apparatus for archival data storage |
US20040267745A1 (en) * | 2001-11-13 | 2004-12-30 | Jan Hoogerbrugge | Entry locking for large data structures |
US7058639B1 (en) * | 2002-04-08 | 2006-06-06 | Oracle International Corporation | Use of dynamic multi-level hash table for managing hierarchically structured information |
US20040220975A1 (en) | 2003-02-21 | 2004-11-04 | Hypertrust Nv | Additional hash functions in content-based addressing |
US20040230989A1 (en) * | 2003-05-16 | 2004-11-18 | Macey William H. | Method and apparatus for survey processing |
US20050229254A1 (en) * | 2004-04-08 | 2005-10-13 | Sumeet Singh | Detecting public network attacks using signatures and fast content analysis |
US20050251524A1 (en) * | 2004-05-06 | 2005-11-10 | Vikram Shukla | Method and apparatus for using a hash-partitioned index to access a table that is not partitioned or partitioned independently of the hash partitioned index |
US20060143168A1 (en) * | 2004-12-29 | 2006-06-29 | Rossmann Albert P | Hash mapping with secondary table having linear probing |
US20060218176A1 (en) * | 2005-03-24 | 2006-09-28 | International Business Machines Corporation | System, method, and service for organizing data for fast retrieval |
US20060248079A1 (en) * | 2005-04-28 | 2006-11-02 | Freescale Semiconductor Incorporated | Method and apparatus for finding a perfect hash function and making minimal hash table for a given set of keys |
Non-Patent Citations (2)
Title |
---|
J. Ian Munro and Pedro Celis, "Techniques for collision resolution in hash tables with open addressing", Nov. 1986, IEEE Computer Soceity Press, Proceedings of 1986 ACM Fall joint computer conference ACM '86, 601-610. * |
Jeffrey Scott Vitter, "Implementations for coalesced hashing", Dec. 1982, ACM Press, vol. 25 Issue 12, 911-926. * |
Cited By (34)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8271500B2 (en) * | 2007-09-11 | 2012-09-18 | Microsoft Corporation | Minimal perfect hash functions using double hashing |
US20090070354A1 (en) * | 2007-09-11 | 2009-03-12 | Kumar Hemachandra Chellapilla | Minimal perfect hash functions using double hashing |
US11379119B2 (en) | 2010-03-05 | 2022-07-05 | Netapp, Inc. | Writing data in a distributed data storage system |
US9104676B2 (en) * | 2010-09-13 | 2015-08-11 | Tencent Technology (Shenzhen) Company Limited | Hash algorithm-based data storage method and system |
US20130007008A1 (en) * | 2010-09-13 | 2013-01-03 | Tencent Technology (Shenzhen) Company Limited | Hash algorithm-based data storage method and system |
US20130086004A1 (en) * | 2011-10-03 | 2013-04-04 | H. Jonathan Chao | Updating a perfect hash data structure, such as a multi-dimensional perfect hash data structure, used for high-speed string matching |
US8775393B2 (en) * | 2011-10-03 | 2014-07-08 | Polytechniq Institute of New York University | Updating a perfect hash data structure, such as a multi-dimensional perfect hash data structure, used for high-speed string matching |
US10911328B2 (en) | 2011-12-27 | 2021-02-02 | Netapp, Inc. | Quality of service policy based load adaption |
US11212196B2 (en) | 2011-12-27 | 2021-12-28 | Netapp, Inc. | Proportional quality of service based on client impact on an overload condition |
US10951488B2 (en) | 2011-12-27 | 2021-03-16 | Netapp, Inc. | Rule-based performance class access management for storage cluster performance guarantees |
US9104678B1 (en) * | 2011-12-31 | 2015-08-11 | Richard Michael Nemes | Methods and apparatus for information storage and retrieval using a caching technique with probe-limited open-address hashing |
US10204127B1 (en) * | 2011-12-31 | 2019-02-12 | Richard Michael Nemes | Methods and apparatus for information storage and retrieval using a caching technique with probe-limited open-address hashing |
US11468033B1 (en) | 2011-12-31 | 2022-10-11 | Richard Michael Nemes | Methods and apparatus for information storage and retrieval using a caching technique with probe-limited open-address hashing |
US8745013B2 (en) | 2012-05-19 | 2014-06-03 | International Business Machines Corporation | Computer interface system |
US9081672B1 (en) | 2013-05-30 | 2015-07-14 | Richard Michael Nemes | Methods and apparatus for information storage and retrieval using a caching technique with external-chain hashing and dynamic resource-dependent data shedding |
US9690699B1 (en) | 2013-05-30 | 2017-06-27 | Richard Michael Nemes | Methods and apparatus for information storage and retrieval using a caching technique with external-chain hashing and dynamic resource-dependent data shedding |
US9639278B2 (en) | 2014-01-17 | 2017-05-02 | Netapp, Inc. | Set-associative hash table organization for efficient storage and retrieval of data in a storage system |
US9256549B2 (en) * | 2014-01-17 | 2016-02-09 | Netapp, Inc. | Set-associative hash table organization for efficient storage and retrieval of data in a storage system |
US20150205727A1 (en) * | 2014-01-17 | 2015-07-23 | Netapp, Inc. | Set-associative hash table organization for efficient storage and retrieval of data in a storage system |
US11386120B2 (en) | 2014-02-21 | 2022-07-12 | Netapp, Inc. | Data syncing in a distributed system |
US9798728B2 (en) | 2014-07-24 | 2017-10-24 | Netapp, Inc. | System performing data deduplication using a dense tree data structure |
US10133511B2 (en) | 2014-09-12 | 2018-11-20 | Netapp, Inc | Optimized segment cleaning technique |
US10210082B2 (en) | 2014-09-12 | 2019-02-19 | Netapp, Inc. | Rate matching technique for balancing segment cleaning and I/O workload |
US9671960B2 (en) | 2014-09-12 | 2017-06-06 | Netapp, Inc. | Rate matching technique for balancing segment cleaning and I/O workload |
US10365838B2 (en) | 2014-11-18 | 2019-07-30 | Netapp, Inc. | N-way merge technique for updating volume metadata in a storage I/O stack |
US9836229B2 (en) | 2014-11-18 | 2017-12-05 | Netapp, Inc. | N-way merge technique for updating volume metadata in a storage I/O stack |
US9720601B2 (en) | 2015-02-11 | 2017-08-01 | Netapp, Inc. | Load balancing technique for a storage array |
US9762460B2 (en) | 2015-03-24 | 2017-09-12 | Netapp, Inc. | Providing continuous context for operational information of a storage system |
US9710317B2 (en) | 2015-03-30 | 2017-07-18 | Netapp, Inc. | Methods to identify, handle and recover from suspect SSDS in a clustered flash array |
US9740566B2 (en) | 2015-07-31 | 2017-08-22 | Netapp, Inc. | Snapshot creation workflow |
US10929022B2 (en) | 2016-04-25 | 2021-02-23 | Netapp. Inc. | Space savings reporting for storage system supporting snapshot and clones |
US10997098B2 (en) | 2016-09-20 | 2021-05-04 | Netapp, Inc. | Quality of service policy sets |
US11327910B2 (en) | 2016-09-20 | 2022-05-10 | Netapp, Inc. | Quality of service policy sets |
US11886363B2 (en) | 2016-09-20 | 2024-01-30 | Netapp, Inc. | Quality of service policy sets |
Also Published As
Publication number | Publication date |
---|---|
US20060271539A1 (en) | 2006-11-30 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US7370048B2 (en) | File storage method and apparatus | |
US7571299B2 (en) | Methods and arrangements for inserting values in hash tables | |
US5664184A (en) | Method and apparatus for implementing Q-trees | |
AU2005202721B2 (en) | Design of spreadsheet functions for working with tables of data | |
US7680791B2 (en) | Method for sorting data using common prefix bytes | |
US6434662B1 (en) | System and method for searching an associative memory utilizing first and second hash functions | |
US6678687B2 (en) | Method for creating an index and method for searching an index | |
EP0268373B1 (en) | Method and apparatus for determining a data base address | |
US20040133581A1 (en) | Database management system, data structure generating method for database management system, and storage medium therefor | |
US7499920B2 (en) | Multi-column multi-data type internationalized sort extension method for web applications | |
US7062499B2 (en) | Enhanced multiway radix tree and related methods | |
US7539689B2 (en) | Bundling database | |
Parmar et al. | Comparing linear search and binary search algorithms to search an element from a linear list implemented through static array, dynamic array and linked list | |
WO2006041886A2 (en) | System, method and computer program for successive approximation of query results | |
US5819254A (en) | Method of transferring data between relational database tables | |
US8306956B2 (en) | Method and apparatus for compressing a data set | |
CN106326475A (en) | High-efficiency static hash table implement method and system | |
Darragh et al. | Bonsai: a compact representation of trees | |
US6625592B1 (en) | System and method for hash scanning of shared memory interfaces | |
US7502790B2 (en) | Multi-column multi-data type internationalized sort extension for web applications | |
US8204882B2 (en) | Method for accessing a storage unit during the search for substrings, and a corresponding storage unit | |
US7487165B2 (en) | Computer implemented method for retrieving hit count data from a data base system and according computer program product | |
US6289349B1 (en) | Binary tree structure with end of path flags stored with path arc's | |
US7165067B1 (en) | Method, system, and program for character set matching | |
Musser | Rationale for adding hash tables to the c++ standard template library |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: INTERNATIONAL BUSINESS MACHINES CORPORATION, NEW YFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:LOEB, MITCHELL L.;REEL/FRAME:016422/0012Effective date: 20050526 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:INTERNATIONAL BUSINESS MACHINES CORPORATION;REEL/FRAME:026894/0001Effective date: 20110817 |
|
FPAY | Fee payment |
Year of fee payment: 4 |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044101/0610Effective date: 20170929 |
|
FEPP | Fee payment procedure |
Free format text: MAINTENANCE FEE REMINDER MAILED (ORIGINAL EVENT CODE: REM.); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
LAPS | Lapse for failure to pay maintenance fees |
Free format text: PATENT EXPIRED FOR FAILURE TO PAY MAINTENANCE FEES (ORIGINAL EVENT CODE: EXP.); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
STCH | Information on status: patent discontinuation |
Free format text: PATENT EXPIRED DUE TO NONPAYMENT OF MAINTENANCE FEES UNDER 37 CFR 1.362 |
|
FP | Lapsed due to failure to pay maintenance fee |
Effective date: 20200506 |