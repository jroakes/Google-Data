US9342553B1 - Identifying distinct combinations of values for entities based on information in an index - Google Patents
Identifying distinct combinations of values for entities based on information in an index Download PDFInfo
- Publication number
- US9342553B1 US9342553B1 US13/892,215 US201313892215A US9342553B1 US 9342553 B1 US9342553 B1 US 9342553B1 US 201313892215 A US201313892215 A US 201313892215A US 9342553 B1 US9342553 B1 US 9342553B1
- Authority
- US
- United States
- Prior art keywords
- index
- value combinations
- value
- query
- combinations
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active, expires
Links
- 230000004044 response Effects 0.000 claims abstract description 36
- 238000000034 method Methods 0.000 claims description 77
- 230000002730 additional effect Effects 0.000 claims description 3
- ORILYTVJVMAKLC-UHFFFAOYSA-N Adamantane Natural products C1C(C2)CC3CC1CC2C3 ORILYTVJVMAKLC-UHFFFAOYSA-N 0.000 description 75
- 238000004891 communication Methods 0.000 description 24
- 238000012545 processing Methods 0.000 description 19
- 230000008569 process Effects 0.000 description 18
- 238000010586 diagram Methods 0.000 description 11
- 239000007787 solid Substances 0.000 description 9
- 230000003287 optical effect Effects 0.000 description 5
- 238000012986 modification Methods 0.000 description 4
- 230000004048 modification Effects 0.000 description 4
- 238000013459 approach Methods 0.000 description 3
- 230000008901 benefit Effects 0.000 description 3
- 230000001419 dependent effect Effects 0.000 description 3
- 230000006870 function Effects 0.000 description 3
- 238000013500 data storage Methods 0.000 description 2
- 230000000717 retained effect Effects 0.000 description 2
- 230000000694 effects Effects 0.000 description 1
Images
Classifications
-
- G06F17/30424—
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/24—Querying
- G06F16/245—Query processing
Definitions
- Datastore server systems store large volumes of data and receive numerous queries from requestors (for example, clients and applications).
- the queries received by datastore server systems are often complex. Processing these queries (e.g., queries to identify distinct combinations of values for entities in a database) is often resource intensive due to the quantity of data required to process them.
- Efficiency of processing complex queries using a large quantity of data is improved by efficient data retrieval and data storage.
- One approach to improving efficiency of data retrieval and data storage involves organizing data in the form of sorted indexes generated from an underlying schemaless database.
- a method is performed at a server system having one or more processors and memory storing one or more programs for execution by the one or more processors so as to perform the method.
- the method includes receiving, from a requestor, a query for retrieving information corresponding to distinct value combinations of one or more properties for entities satisfying requestor-specified filter criteria.
- the method includes identifying a set of index portions including two or more index portions in accordance with the requestor-specified filter criteria, where index entries in the set of index portions are sorted in a predefined sort order in accordance with value combinations of the one or more properties.
- the method further includes identifying one or more distinct value combinations of the one or more properties for entities satisfying the requestor-specified filter criteria, where the identifying includes obtaining an initial value of a query cursor, and a respective value of the query cursor corresponds to a respective value combination for the one or more properties.
- the method further includes retrieving candidate value combinations, including, for each respective index portion in the set of index portions, retrieving a respective candidate value combination of the one or more properties that is equal or sequentially adjacent, in the respective index portion, to a current value of the query cursor.
- the method also includes, after retrieving candidate value combinations, comparing candidate value combinations, including comparing a plurality of the respective candidate value combinations so as to identify distinct value combinations, if any, from the plurality of respective candidate value combinations in accordance with the query.
- the method further includes updating the current value of the query cursor and repeating the operations of retrieving candidate value combinations and the comparing candidate value combinations one or more times for the set of index portions until at least a respective distinct value combination has been identified.
- the method further includes transmitting information corresponding to the respective distinct value combination to the requestor.
- a computer system (e.g., a client system or server system) includes one or more processors, memory, and one or more programs; the one or more programs are stored in the memory and configured to be executed by the one or more processors and the one or more programs include instructions for performing the operations of the method described above.
- a non-transitory computer readable storage medium has stored therein instructions which when executed by one or more processors, cause a computer system (e.g., a client system or server system) to perform the operations of the methods described above.
- FIG. 1 is a block diagram illustrating a distributed client-server system, in accordance with some embodiments.
- FIG. 2 is a block diagram illustrating a client system, in accordance with some embodiments.
- FIG. 3 is a block diagram illustrating an application server system, in accordance with some embodiments.
- FIG. 4 is a block diagram illustrating a datastore server system, in accordance with some embodiments.
- FIGS. 5A-5B are block diagrams illustrating index(es) including index portions for entities stored in an entity database at the datastore server system, in accordance with some embodiments.
- FIG. 5C is a block diagram illustrating a method for identifying distinct property values in index portions of indexes when a logical relationship between operands of the search query is a Boolean AND, in accordance with some embodiments.
- FIG. 5D is a block diagram illustrating a method for identifying distinct property values in index portions of indexes when a logical relationship between operands of the search query is a Boolean OR, in accordance with some embodiments.
- FIG. 6 includes a flow chart illustrating a method for receiving and processing a select distinct query at a datastore server system and returning search results, in accordance with some embodiments.
- FIGS. 7A-7H include a flow chart illustrating a method for responding to a select distinct query at a datastore server system, in accordance with some embodiments.
- first, second, etc. are optionally used herein to describe various elements, these elements should not be limited by these terms. These terms are only used to distinguish one element from another.
- a first entity could be termed a second entity, and, similarly, a second entity could be termed a first entity, without changing the meaning of the description, so long as all occurrences of the “first entity” are renamed consistently and all occurrences of the second entity are renamed consistently.
- the first entity and the second entity are both entities, but they are not the same entity.
- the term “if” is optionally construed to mean “when” or “upon” or “in response to determining” or “in accordance with a determination” or “in response to detecting,” that a stated condition precedent is true, depending on the context.
- the phrase “if it is determined [that a stated condition precedent is true]” or “if [a stated condition precedent is true]” or “when [a stated condition precedent is true]” is optionally construed to mean “upon determining” or “in response to determining” or “in accordance with a determination” or “upon detecting” or “in response to detecting” that the stated condition precedent is true, depending on the context.
- client application server and datastore server systems, which typically inter-operate in a distributed client-server system and corresponding methods of responding to a select distinct query.
- FIG. 1 includes a block diagram illustrating an example of a distributed client-server system 100 for sending and responding to requests based on an empirically-determined schema for a schemaless database.
- System 100 includes one or more Client System(s) 102 (also referred to herein as “Client 102 ”), an Application Server System 104 (also referred to herein as “App Server 104 ”), a Datastore Server System 106 (also referred to herein as “Datastore Server 106 ”) and a Communication Network 120 for connecting Clients 102 , App Server 104 and Datastore Server 106 to each other.
- Communication Network 120 optionally includes the Internet, one or more local area networks (LANs), one or more wide area networks (WANs), other types networks, or a combination of such networks.
- LANs local area networks
- WANs wide area networks
- Client 102 optionally includes Browser 110 and/or Client Application 112 .
- Browser 110 can be a general purpose Internet browser (sometimes called a Web browser) having a browser window used for displaying an application interface.
- a web application for submitting a data request is optionally implemented using hypertext markup language (HTML) or extensible markup language (XML) elements that are rendered by Browser 110 .
- a data request is, optionally, submitted via a standalone Client Application 112 .
- Client 102 relays the request to Datastore Server 106 via Communication Network 120 .
- Datastore Server 106 processes the data request and transfers results and, optionally, a set of display information back to Client 102 .
- Client Application 112 and/or Browser 110 use(s) the results and display information to render an updated application state at Client 102 .
- Datastore Server 106 includes Frontend Server 122 , Request Processor 124 , Query Engine 126 , Response Generator 128 , Index Generator 130 , Entity Database 140 , one or more Index(es) 142 .
- Index Generator 130 processes information about the entities that are stored in Entity Database 140 to produce Index(es) 142 for use by Query Engine 126 when performing a search query.
- Index Generator 130 retrieves information about entities from a remote source such as a remote database or web crawler that systematically retrieves information from a plurality of remote sources (e.g., websites). These operations are typically performed by Index Generator 130 prior to receiving the request at Datastore Server 106 .
- Index Generator 130 typically continues to update Index(es) 142 between requests or queries, and in some implementations or some circumstances, continues to update Index(es) 142 concurrently with the processing of requests or queries.
- Frontend Server 122 relays requests from Clients 102 to Request Processor 124 , which optionally processes a request by selecting an order to apply filters and sort orders specified in the request and transmits the processed request to Query Engine 126 .
- the Request Processor 124 processes the request so as to improve the performance characteristics of the request (e.g., by determining an order to apply filters that reduces the time to perform the request and/or reduces the maximum or total processor usage).
- Query Engine 126 identifies, in Index(es) 142 , indexes and index portions adapted for responding to the request and performs the request on the identified indexes and/or index portions to generate a response.
- Response Generator 128 generates a response based on the identified search results. Response Generator 128 also, optionally, determines display information for the response. The response and, optionally, display information is passed to Frontend Server 122 , which in turn passes the results to Client 102 via Communication Network 120 or to App Server 104 for display at Client 102 (e.g., via Browser 110 or Client Application 112 ).
- FIG. 2 is a block diagram illustrating a Client System 102 in accordance with some embodiments.
- Client 102 typically includes one or more processing units CPU(s) 202 , one or more communications interfaces such as Network Interface 204 , Memory 206 , User Interface 205 comprising a display device and a keyboard, mouse, touchpad, touchscreen or other input device, and one or more Communication Buses 208 for interconnecting these components.
- Communication Buses 208 optionally include circuitry (sometimes called a chipset) that interconnects and controls communications between system components.
- Memory 206 typically includes high-speed random access memory, such as DRAM, SRAM, DDR RAM or other random access solid state memory devices; and optionally includes non-volatile memory, such as one or more magnetic disk storage devices, optical disk storage devices, flash memory devices, or other non-volatile solid state storage devices. Memory 206 optionally includes one or more storage devices remotely located from the CPU(s) 202 . Memory 206 , or alternatively the non-volatile memory device(s) within Memory 206 , comprises a non-transitory computer readable storage medium. In some embodiments, Memory 206 or alternatively the non-transitory computer readable storage medium stores the following programs, modules and data structures, or a subset thereof:
- Memory 206 optionally stores a subset of the modules and data structures identified above. Furthermore, Memory 206 optionally stores additional modules and data structures not described above.
- FIG. 3 is a block diagram illustrating an Application Server System 104 (also referred to herein as “App Server 104 ”) in accordance with some embodiments.
- App Server 104 typically includes one or more processing units CPU(s) 302 , one or more communications interfaces such as Network Interface 304 , Memory 306 , and one or more Communication Buses 308 for interconnecting these components.
- Communication Buses 308 optionally include circuitry (sometimes called a chipset) that interconnects and controls communications between system components.
- Memory 306 includes high-speed random access memory, such as DRAM, SRAM, DDR RAM or other random access solid state memory devices; and optionally includes non-volatile memory, such as one or more magnetic disk storage devices, optical disk storage devices, flash memory devices, or other non-volatile solid state storage devices. Memory 306 optionally includes one or more storage devices remotely located from the CPU(s) 302 . Memory 306 , or alternatively the non-volatile memory device(s) within Memory 306 , comprises a non-transitory computer readable storage medium. In some embodiments, Memory 306 or alternatively the non-transitory computer readable storage medium stores the following programs, modules and data structures, or a subset thereof:
- Memory 306 optionally stores a subset of the modules and data structures identified above. Furthermore, Memory 306 optionally stores additional modules and data structures not described above.
- FIG. 3 shows an “Application Server System” 104
- FIG. 3 is intended more as functional description of the various features which are optionally present in a set of servers than as a structural schematic of the embodiments described herein.
- items shown separately could be combined and some items could be separated.
- some items shown separately in FIG. 3 could be implemented on single servers and single items could be implemented by one or more servers.
- the actual number of servers used to implement an Application Server System 104 and how features are allocated among them will vary from one implementation to another, and optionally depends in part on the amount of data traffic that the system must handle during peak usage periods as well as during average usage periods.
- FIG. 4 is a block diagram illustrating a Datastore Server System 106 in accordance with some embodiments.
- Datastore Server System 106 typically includes one or more processing units CPU(s) 402 , one or more communications interfaces such as Network Interface 404 , Memory 406 , and one or more Communication Buses 408 for interconnecting these components.
- Communication Buses 408 optionally include circuitry (sometimes called a chipset) that interconnects and controls communications between system components.
- Memory 406 includes high-speed random access memory, such as DRAM, SRAM, DDR RAM or other random access solid state memory devices; and optionally includes non-volatile memory, such as one or more magnetic disk storage devices, optical disk storage devices, flash memory devices, or other non-volatile solid state storage devices.
- Memory 406 optionally includes one or more storage devices remotely located from the CPU(s) 402 .
- Memory 406 or alternatively the non-volatile memory device(s) within Memory 406 , comprises a non-transitory computer readable storage medium.
- Memory 406 or alternatively the non-transitory computer readable storage medium stores the following programs, modules and data structures, or a subset thereof:
- Memory 406 optionally stores a subset of the modules and data structures identified above. Furthermore, Memory 406 optionally stores additional modules and data structures not described above.
- FIG. 4 shows a “Datastore Server System” 106
- FIG. 4 is intended more as functional description of the various features which are optionally present in a set of servers than as a structural schematic of the embodiments described herein.
- items shown separately could be combined and some items could be separated.
- some items shown separately in FIG. 4 could be implemented on single servers and single items could be implemented by one or more servers.
- the actual number of servers used to implement a Datastore Server 106 and how features are allocated among them will vary from one implementation to another, and optionally depends in part on the amount of data traffic that the system must handle during peak usage periods as well as during average usage periods.
- FIGS. 5A-5B illustrate examples of index(es) (e.g., Index-A 142 -A and Index-B 142 -B) generated from Entity Database 140 ( FIG. 1 and FIG. 4 ).
- Index-A 142 -A includes a plurality of index entries (rows) sorted in accordance with values of Property 504 , values of Properties 506 , 508 , and Key 502 , in that order (e.g., the rows in the indexes in FIGS. 5A and 5B are sorted in accordance with values in the columns from left to right).
- Index-B 142 -B includes a plurality of index entries (rows) sorted in accordance with values of Property 514 , values of Properties 516 , 518 , and Key 512 , in that order.
- Index-A 142 -A and Index-B 142 -B are obtained by sorting the index entries by values of their properties, and within portions of an index that correspond to a particular value of a property sorting the index entries by values of another property or key.
- Index-A 142 -A has index entries sorted by values of Property 504 .
- the index entries are further sorted by their values of Property 506 , and so on.
- index entries are sorted by value combinations, obtained from a concatenation of values of successive properties in the sort order.
- Index-A 142 -A and Index-B 142 -B are arranged (e.g., sorted according to values of properties according to a sort order) in Index Portions 501 and Index Portions 511 , respectively.
- Datastore Server 106 receives a query from a requestor (e.g., Client 102 or App Server 104 )
- Datastore Server 106 selects index portions from the respective indexes based on filter criteria specified in the query. For example, shown in FIGS.
- FIG. 5C illustrates, the execution of a requestor-specified ‘select distinct’ query (e.g., Query 520 - a ).
- Datastore Server 106 Based on the received query (in this example, Query 520 - a ), Datastore Server 106 identifies indexes sorted by the properties specified in the query (e.g., Property 504 , 506 in Index-A 142 -A and Property 514 , 516 in Index-B 142 -B, FIGS. 5A-5B ) and from the identified indexes, Datastore Server 106 (e.g., using Index Portion Identifier 424 of Query Engine 126 , FIG.
- index portions e.g., Index Portion 501 - c and Index Portion 511 - c
- Datastore Server 106 e.g., using one or more Filter Scanners 426 , FIG. 4
- the processing of the query depends on the logical relationship specified in the select distinct query. Two examples of processing a select distinct query are given with reference to different logical relationships in FIGS. 5C-5D below.
- Datastore Server 106 performs or executes the query in one or more iterations. In some of these embodiments, for a single iteration, Datastore Server 106 identifies candidate values from the two or more index portions used for execution of the query and then identifies a distinct candidate value combination for that iteration from the identified candidate value combinations.
- Datastore Server 106 in order to facilitate the process of iteratively traversing through and between two or more sorted index portions, Datastore Server 106 maintains and updates a ‘current value’ of a query cursor (as will be explained below with reference to the illustrative Query 520 - a and Query 520 - b ) as a common reference across the index portions used for the execution of the query.
- the current value of the query cursor used in these embodiments, keeps track of the most recent property value identified in a current index portion (most recently traversed), so as to enable Datastore Server 106 to traverse subsequent index portions starting at a property value determined in relation to the current value of the query cursor.
- the use of the current value of the query cursor as a starting point for traversing one or more index portions improves efficiency of query-execution by obviating the need to traverse segments of the one or more index portions that occur prior to the position corresponding to the current value of the query cursor.
- Datastore Server 106 in order to execute Query 520 - a , as shown in FIG. 5C , Datastore Server 106 starts with the first value (also referred to here as a ‘candidate value’) of Property 506 of an index entry in Index Portion 501 - c .
- the initial value of the query cursor is initialized to a predefined value that is a first value in the sort order (e.g., a ‘null character).
- Datastore Server 106 then proceeds ( 560 - a ) to Index Portion 511 - c to identify the first index entry with Property 516 having a property value (or candidate value) greater than or equal to the current value of the query cursor (e.g., ‘Adam’).
- Datastore Server 106 then traverses ( 560 - b ) Index Portion 511 - c to find the first index entry having a property (Property 516 ) value greater than and distinct from the current value of the query cursor (e.g., ‘Adam’).
- Datastore Server 106 increments the query cursor (e.g., by appending the null character to the current value of the query cursor) and then traverses Index Portion 511 - c to find the first index entry having a property value greater than or equal to the current value of the query cursor (e.g., Adam+null character).
- a property value e.g., ‘Adam’
- Datastore Server 106 increments the query cursor (e.g., by appending the null character to the current value of the query cursor) and then traverses Index Portion 511 - c to find the first index entry having a property value greater than or equal to the current value of the query cursor (e.g.,
- Datastore Server 106 then proceeds ( 560 - c ) to Index Portion 501 - c to look for the first index entry with Property 506 having a property value greater than or equal to the current value of the query cursor (e.g., ‘Bernie’).
- Datastore Server 106 then proceeds ( 560 - d ) to Index Portion 511 - c to identify the first entry with Property 516 having a property value greater than or equal to ‘Cathy’ (the current value of the query cursor).
- the execution of Query 520 - a using sorted index portions, as shown in FIG. 5C provides the advantage of improved efficiency of searching by way of skipping multiple index entries that are not valid matches.
- this is an indication that all values prior to the current value in the sort order have been determined to match or not match the search query, and thus an index scanner can skip directly to the first index entry that has a value greater than or equal to the query cursor value. In some circumstances this has the effect of skipping large numbers of index entries in the index portion.
- the index portion is distributed over a plurality of different physical storage devices (e.g., hard drives or solid state memory) and skipping large numbers of index entries includes skipping (i.e., not accessing) one or more of the physical storage devices, thereby saving the time, power and network resources that would be otherwise expended in accessing the skipped physical storage devices.
- the process for searching indexes described above also produces results that are sorted in the sort order (e.g., the names in Results 530 - a are sorted alphabetically).
- Index Portion 501 - c and Index Portion 511 - c do not need to have (and in the example in FIG. 5C , do not have) identical sets of properties for the above-described execution of the ‘select distinct’ query.
- Datastore Server 106 truncates the index entry by removing the values of properties that are not part of the “select distinct” criterion, in this case by removing values prior to and after the name property to generate candidate values so that the candidate values obtained from Index Portion 501 - c can be compared with the candidate values obtained from Index Portion 511 - c . Stated another way, for use in continued scanning of the selected index portions, the Datastore Server 106 (or its Filter Scanner) retains values of properties that are part of the “select distinct” criterion.
- the query specifies a “select distinct” criterion based solely on one property (in this example, Select Distinct ‘Name’).
- the ‘select distinct’ criterion includes two or more properties (e.g., Select Distinct ‘Name’ and ‘Hobby’)
- Datastore Server 106 instead of identifying single candidate values (corresponding to a single value of a single property in the ‘select distinct’ query) from each index portion, Datastore Server 106 identifies candidate value combinations (corresponding to combinations of values of the two or more properties in the ‘select distinct’ query).
- the same index portions (Index Portion 501 - c and Index Portion 511 - c ) used to demonstrate the execution of Query 520 - a ( FIG. 5C ) are used to illustrate the execution of Query 520 - b ( FIG. 5D ).
- a key distinction between the queries demonstrated in FIG. 5C and FIG. 5D is in the logical relationship between the filter criteria (AND vs. OR) specified by the respective queries.
- FIGS. 5C and 5D a difference in the logical relationship specified by the two different queries results in different query processing steps as well as a different set of search results (as demonstrated below).
- Datastore Server 106 e.g., using Index Portion Identifier 424 of Query Engine 126 , FIG.
- Datastore Server 106 identifies indexes sorted by the properties specified in the query (e.g., Property 504 , 506 in Index-A 142 -A and Property 514 , 516 in Index-B 142 -B, FIGS. 5A-5B ) and from the identified indexes, Datastore Server 106 identifies index portions (e.g., Index Portion 501 - c and Index Portion 511 - c ) to be used for the execution of the query. Datastore Server 106 (e.g., using Filter Scanner 426 of Query Engine 126 , FIG.
- index portions e.g., Index Portion 501 - c and Index Portion 511 - c
- Datastore Server 106 concurrently identifies property values or value combinations (referred to also as candidate values or candidate value combinations) from each index portion of the two or more index portions over which the query is to be executed and based on a comparison between the identified candidate values or candidate value combinations identifies a distinct value in accordance with the sort order (e.g., a lowest or minimum candidate value combination of the selected candidate value combinations).
- Datastore Server 106 maintains a current value of a query cursor corresponding to, for example, the lowest candidate value combination retrieved as a valid search result in the previous iteration (or the lowest candidate value combination+null character) and uses the current value of the query cursor as a starting point for identifying subsequent candidate value combinations.
- Datastore Server 106 identifies as first candidate value (value of Property 506 ) ‘Adam’ from Index Portion 501 - c and candidate value ‘Adam’ (value of Property 516 ) from Index Portion 511 - c .
- first candidate value value of Property 506
- candidate value value of Property 516
- Index Portion 511 - c index Portion 511 - c .
- Datastore Server 106 then proceeds to identify the first index entry with property value greater than (or sequentially adjacent to) the current value of the query cursor (e.g., ‘Adam’)—for example, subsequent or sequentially adjacent (in the sort order) and distinct candidate values of the ‘Name’ property—in both Index Portion 501 - c (Property 506 ) and in Index Portion 511 - c (Property 516 ). Accordingly, Datastore Server 106 identifies ‘Cathy’ from Index Portion 501 - c and ‘Bernie’ from Index Portion 511 - c as distinct candidate values.
- the query cursor e.g., ‘Adam’
- Datastore Server 106 Upon comparing ( 561 - b ) ‘Cathy’ and ‘Bernie’ (the two identified distinct candidate values form the two index portions), Datastore Server 106 selects ‘Bernie’ as the minimum of the two candidate values, identifies ‘Bernie’ as a valid search result, and updates the current value of the query cursor to ‘Bernie.’
- Datastore Server 106 then proceeds to identify the first index entry with property value greater than (e.g., sequentially adjacent to, in the increasing direction) the current value of the query cursor (e.g., ‘Bernie’) in both Index Portion 501 - c (Property 506 ) and in Index Portion 511 - c (Property 516 ). Datastore Server 106 then traverses Index Portion 511 - c (from which the previous candidate value, e.g., ‘Bernie’ was selected as a valid search result) and identifies ‘Brett’ as the next candidate value in Index Portion 511 - c greater than the current value of the query cursor.
- the previous candidate value e.g., ‘Bernie’ was selected as a valid search result
- the execution of Query 520 - b using sorted index portions therefore provides the advantage of improved efficiency of searching by way of skipping the steps of traversing each of the index portions at every iteration.
- Datastore Server 106 traverses Index Portion 511 - c (from which the previous candidate value, e.g., ‘Bernie’ was selected as a valid search result), but does not traverse Index Portion 501 - c .
- Datastore Server 106 identifies ‘Cathy’ from Index Portion 501 - c and ‘Brett’ from Index Portion 511 - c as candidate values.
- Datastore Server 106 compares ( 561 - c ) the candidate value from Index Portion 501 - c (Cathy′) with the candidate value from Index Portion 511 - c (Brett′) to identify the minimum of the two (e.g., ‘Brett’) as a distinct candidate value and a valid search result. Datastore Server 106 then updates the current value of the query cursor to ‘Brett.’
- Datastore Server 106 Continuing the traversing of Index Portion 511 - c (from which the previous candidate value, e.g., ‘Bernie’ was selected as a valid search result), as described above, Datastore Server 106 then identifies ‘Mike’ as the candidate value in Index Portion 511 - c greater than the current value of the query cursor (e.g., ‘Brett’). Datastore Server 106 then proceeds to identify the first index entry with property value greater than the current value of the query cursor (e.g., ‘Brett’) in both index portions. Datastore Server 106 identifies ‘Cathy’ from Index Portion 501 - c and ‘Mike’ from Index Portion 511 - c as candidate values.
- Datastore Server 106 compares ( 561 - d ) the candidate value from Index Portion 501 - c (‘Cathy’) with the candidate value from Index Portion 511 - c (‘Mike’) to identify the minimum of the two (e.g., ‘Cathy’) as a distinct candidate value and a valid search result. Datastore Server 106 then updates the current value of the query cursor to ‘Cathy.’
- Datastore Server 106 traverses Index Portion 501 - c (from which the previous candidate value, e.g., ‘Cathy’ was selected as a valid search result) and identifies ‘Karen’ as the next distinct value in Index Portion 501 - c greater than the current value of the query cursor (e.g., ‘Cathy’). As described above, Datastore Server 106 proceeds to identify the first index entry with property value greater than the current value of the query cursor (e.g., ‘Cathy’) in both index portions. Datastore Server 106 identifies ‘Karen’ from Index Portion 501 - c . Next, Datastore Server 106 identifies ‘Mike’ from Index Portion 511 - c as candidate values.
- Datastore Server 106 compares ( 561 - e ) the candidate value from Index Portion 501 - c (‘Karen’) with the candidate value from Index Portion 511 - c (‘Mike’) to identify the minimum of the two (e.g., ‘Karen’) as a valid search result. Datastore Server 106 then updates the current value of the query cursor to ‘Karen.’
- the above-described process of searching indexes also produces results that are sorted in the sort order (e.g., the names in Results 530 - b are sorted alphabetically) of the index portions used to process the query.
- FIG. 6 includes a flowchart representing a method 600 for receiving and processing requests from Client 102 or App Server 104 at Datastore Server 106 and returning responses to Client 102 or App Server 104 based on an empirically-determined schema, according to certain embodiments.
- Method 600 is, optionally, governed by instructions that are stored in a non-transitory computer readable storage medium and that are executed by one or more processors of one or more computer systems (e.g., Client 102 , App Server 104 or Datastore Server 106 ).
- Each of the operations shown in FIG. 6 typically corresponds to instructions stored in a computer memory or non-transitory computer readable storage medium (e.g., memory 206 of Client 102 in FIG. 2 , memory 306 of App Server 104 in FIG.
- the non-transitory computer readable storage medium optionally includes a magnetic or optical disk storage device, solid state storage devices such as Flash memory, or other non-volatile memory device or devices.
- the computer readable instructions stored on the computer readable storage medium optionally includes one or more of: source code, assembly language code, object code, or other instruction format that is executed or interpreted by one or more processors. In various embodiments, some operations in method 600 are optionally combined and/or the order of some operations are optionally changed from the order shown in FIG. 6 .
- a requestor (Client 102 or App Server 104 ) transmits ( 602 ) a ‘select distinct’ query to Datastore Server 106 .
- a requestor transmits ‘select distinct’ Query 520 - a or Query 520 - b to Datastore Server 106 .
- Datastore Server 106 receives ( 604 ) the ‘select distinct’ query.
- Datastore Server 106 identifies ( 608 ) distinct value combinations for the ‘select distinct’ query (including one or more of steps 610 - 628 ) in the identified index portions. For example, as shown in FIG. 5C , when the logical relationship between the filters is AND, Datastore Server 106 identifies ‘Adam’ and ‘Mike’ as distinct value combinations for the ‘select distinct’ query (e.g., Query 520 - a ). In contrast, as shown in FIG.
- Datastore Server 106 identifies ‘Adam,’ ‘Bernie,’ ‘Brett,’ ‘Cathy,’ ‘Karen,’ ‘Mike,’ and ‘Peter’ as distinct value combinations for the ‘select distinct’ query (e.g., Query 520 - b ).
- Datastore Server 106 obtains ( 610 ) initial query cursor value corresponding to a respective value combination. For example, as explained with reference to FIG. 5C , Datastore Server 106 obtains ‘Adam’ as an initial query cursor value corresponding to a first value combination obtained from Index Portion 501 - c . After obtaining the initial query cursor value, Datastore Server 106 retrieves ( 612 ) candidate value combinations (see Method 700 , step 726 ) based on the current query cursor value. Datastore Server 106 then compares ( 614 ) candidate value combinations (see Method 700 , step 742 ). As explained with reference to FIG.
- Datastore Server 106 retrieves candidate value ‘Cathy’ from Index Portion 501 - c and candidate value ‘Bernie’ from Index Portion 511 - c and compares ( 561 - b ) the two retrieved candidate values to determine the lower of the two values.
- Datastore Server 106 makes a determination as to whether to update the query cursor. Upon determining that the query cursor needs to be updated ( 616 ), Datastore Server 106 updates ( 618 ) the value of the query cursor (see Method 700 , step 750 ). Upon determining that the query cursor does not ( 620 ) need to be updated, Datastore Server 106 does not update the value of the query cursor. For example, when the logical relationship specified by the query (e.g., Query 520 - a ) is Boolean AND, and Datastore Server 106 identifies a candidate value combination in a first index portion, it makes a determination not to update the query cursor until it finds a match in the remaining index portions. However, as explained with reference to FIG.
- Datastore Server 106 when the logical relationship specified by the query (e.g., Query 520 - a ) is Boolean OR, and Datastore Server 106 identifies a lowest candidate value combination in an index portion, it makes a determination to update the query cursor in accordance with the lowest candidate value combination identified (e.g., by incrementing the query cursor by a null character or by advancing the query cursor to a next value in the sort order).
- Datastore Server 106 makes a determination as to whether the termination condition has been met. For example, if the requestor specifies an upper limit on the number of distinct candidate values to be retrieved, then Datastore Server 106 would make a determination as to whether the number of retrieved distinct candidate values has been reached. Also, as an example, during the execution of Query 520 - a ( FIG. 5C ) where the logical relationship between the operands is AND, when the end of one or more index portions is reached, Datastore Server 106 would make a determination that the termination condition has been met, as there will not be any additional distinct values that are matched in the index portion for which an end has been reached. Upon determining that the termination condition has not ( 622 ) been met, Datastore Server 106 repeats the retrieving (step 612 ), comparing (step 614 ) and, optionally, the updating (step 618 ) operations described above.
- Datastore Server 106 Upon determining that the termination condition has been met ( 624 ), Datastore Server 106 makes a determination as to whether at least one respective distinct value combination has been identified. In some embodiments, upon determining that at least one distinct value combination has not ( 626 ) been identified, Datastore Server 106 terminates query-processing (e.g., because no distinct value combinations have been identified and thus there are no results to report to the requestor), or returns a no-results response. Upon determining that at least one distinct value combination has ( 628 ) been identified, Datastore Server 106 transmits ( 630 ) a response including information corresponding to the respective distinct value combination to the requestor. For example, as shown in FIG.
- Datastore Server 106 transmits Results 530 - a (including distinct value combinations ‘Adam’ and ‘Mike’) to the requestor.
- Datastore Server 106 may transmit additional and/or alternative information corresponding to the respective distinct value combinations (e.g., an entity name, an entity last modification date, or the entire entity corresponding to a first entity identified as having the distinct value combination).
- the requestor receives ( 632 ) the response.
- App Server 104 forwards the response to Client 102 and/or performs additional processing using the response and forwards information corresponding to the response to Client 102 .
- FIGS. 7A-7H include a flowchart representing a method 700 for generating a response to an application request based on an empirically-determined schema, which in turn is generated from an index of entities, according to certain embodiments.
- Method 700 is, optionally, governed by instructions that are stored in a non-transitory computer readable storage medium and that are executed by one or more processors of one or more servers (e.g., Datastore Server 106 , FIG. 4 ).
- Each of the operations shown in FIGS. 7A-7H typically corresponds to instructions stored in a computer memory or non-transitory computer readable storage medium (e.g., memory 406 of Datastore Server 106 in FIG. 4 ).
- the non-transitory computer readable storage medium optionally includes a magnetic or optical disk storage device, solid state storage devices such as Flash memory, or other non-volatile memory device or devices.
- the computer readable instructions stored on the computer readable storage medium optionally include one or more of: source code, assembly language code, object code, or other instruction format that is executed or interpreted by one or more processors.
- some operations in method 700 are optionally combined and/or the order of some operations are optionally changed from the order shown in FIGS. 7A-7H .
- the requestor-specified filter criteria specify ( 704 ) a plurality of operands including a first operand associated with one or more filters, a second operand associated with one or more filters and a logical relationship between the plurality of operands.
- Datastore Server 106 identifies ( 706 ) a set of index portions including two or more index portions in accordance with the requestor-specified filter criteria. In some implementations, this is accomplished using Index Portion Identifier 424 of Query Engine 126 ( FIG. 4 ). Index entries in the set of index portions are sorted ( 708 ) in a predefined sort order in accordance with value combinations of the one or more properties. For example, as shown in FIGS.
- Index entries in Index Portion 501 - c and Index Portion 511 - c are sorted in a predefined sort order in accordance with value property ‘Name’ (Property 506 in Index A and Property 516 in Index B).
- Datastore Server 106 identifies ( 716 ) one or more distinct value combinations of the one or more properties for entities satisfying the requestor-specified filter criteria in the one or more index portions.
- identifying the distinct value combinations includes ( 718 ) sequentially identifying the distinct value combinations in the predefined sort order. For example, as shown in FIG. 5D , distinct value combinations identified as Results 530 - b are identified in alphabetical order (e.g., ‘Adam,’ ‘Bernie,’ ‘Brett,’ ‘Cathy,’ ‘Karen,’ ‘Mike,’ ‘Peter’).
- distinct value combinations correspond to values of a single property (e.g., for property ‘Name,’ [‘Adam’] and [‘Cathy’] are distinct value combinations)
- Datastore Server 106 Prior to retrieving candidate value combinations based on the one or more index portions, Datastore Server 106 obtains ( 724 ) an initial value of a query cursor.
- a respective value of the query cursor corresponds to a respective value combination for the one or more properties. For example, as explained with reference to FIG. 5C , Datastore Server 106 sets ‘Adam’ as an initial query cursor value corresponding to a first value combination obtained from Index Portion 501 - c .
- obtaining an initial value of a query cursor includes initializing the value of the query cursor (e.g., to a first value in the sort order such as a null character).
- obtaining an initial value of a query cursor includes retrieving an initial value of the query cursor from a previously stored value.
- Datastore Server 106 retrieves ( 726 ) candidate value combinations based on the current query cursor value. In some embodiments, for each respective index portion in the set of index portions, Datastore Server 106 retrieves a respective candidate value combination of the one or more properties that is equal or sequentially adjacent, in the respective index portion, to a current value of the query cursor. As explained above, in the example shown in FIG. 5C (where the logical relationship specified by Query 520 - a is a Boolean AND), Datastore Server 106 retrieves a candidate value of the property ‘Name’ that is greater than (sequentially adjacent to) or equal to, in the respective index portion, a current value of the query cursor.
- Datastore Server 106 retrieves a candidate value of the property ‘Name’ that is sequentially adjacent, in the respective index portion, to the current value of the query cursor.
- Datastore Server 106 retrieves the next candidate value (e.g., ‘Brett’) from Index Portion 511 - c (e.g., the index portion from which the last distinct value was selected) that is sequentially adjacent to (greater than) the current value (e.g., ‘Bernie’) of the query cursor.
- the next candidate value e.g., ‘Brett’
- Index Portion 511 - c e.g., the index portion from which the last distinct value was selected
- one or more of the respective candidate values are retrieved from a candidate value combination cache and are not requested from the index scanners. For example for an OR query, current minimum values of one or more of the index portions that were not selected in a prior iteration are retained and compared to newly retrieved minimum values of one or more of the index portions. In particular, in the example shown in FIG.
- ‘Cathy’ and ‘Bernie’ are identified as current minimum values for Index Portion 501 - c and Index Portion 511 - c , respectively; in a subsequent iteration, ‘Bernie’ is selected as a respective distinct value for the query and thus ‘Cathy’ is retained as a current minimum value for Index Portion 501 - c while ‘Bernie’ is replaced by ‘Brett’ as a current minimum value for Index Portion 511 - c.
- retrieving candidate value combinations includes ( 728 ) traversing at least one respective index portion in the set of index portions in the predefined sort order starting at the current value of the query cursor for the one or more properties. In some circumstances, traversing a respective index portion includes traversing a portion of the respective index portion. As explained with reference to FIG. 5D above, after identifying ‘Bernie’ as the distinct value, Datastore Server 106 traverses Index Portion 511 - c to retrieve the next candidate value (e.g., ‘Brett’) from Index Portion 511 - c.
- next candidate value e.g., ‘Brett’
- the set of index portions includes ( 730 ) a first index portion and a second index portion.
- the set of index portions includes Index Portion 501 - c and Index Portion 511 - c .
- Datastore Server 106 retrieves ( 732 ), from the first index portion, a first candidate value combination for the one or more properties that is equal or sequentially adjacent, in the first index portion, to the current value of the query cursor.
- Datastore Server 106 retrieves ( 734 ), from the second index portion, a second candidate value combination for the one or more properties that is equal or sequentially adjacent, in the second index portion, to the current value of the query cursor. For example, as shown in FIG.
- Datastore Server 106 traverses ( 560 - b ) Index Portion 511 - c , identifies and retrieves Bernie′ as a candidate value from Index Portion 511 - c and updates the current value of the query cursor to ‘Bernie.’ Datastore Server 106 then proceeds to Index Portion 501 - c and identifies and retrieves ‘Cathy’ as a candidate value from Index Portion 501 - c , as ‘Cathy” is the value in Index Portion 501 - c that is sequentially adjacent to the current value (‘Bernie’) of the query cursor.
- retrieving the respective candidate value combinations includes ( 736 ), for each respective index portion, retrieving ( 738 ) a respective index entry having a first section and a second section, where the first section includes a respective value for each of the one or more properties and the second section includes a respective value for each of one or more additional properties used to sort index entries within the respective index portion.
- retrieving the respective candidate value combinations includes ( 736 ), for each respective index portion, identifying ( 740 ) a combination of the respective values in the first section of the respective index entry as the candidate value combination for the respective index portion.
- an index entry has values corresponding to properties ‘Name,’ ‘Age,’ and ‘Hobby,’ and the index entry includes a first section corresponding to values of properties ‘Name’ and ‘Age’ and a second section corresponding to values of property ‘Hobby,’ then a candidate value combination includes a combination of the respective values in the first section (e.g., a combination of values of properties ‘Name’ and ‘Age’).
- the plurality of index portions includes two or more indexes that are sorted in different sort orders (e.g., include different ‘additional’ properties).
- the index portions used to perform the query have the same primary sort order (e.g., the first set of one or more properties by which index entries in the index portion are sorted) the index portions can be used for a ‘select distinct’ query.
- index portions that would be considered to be ‘incompatible’ for a query that required index portions to be sorted in the same sort order can be used to respond to a select distinct query by ignoring a postfix that includes values corresponding to incompatible ‘additional’ properties. For example, as shown in FIG.
- Index Portion 501 - c and Index Portion 511 - c have a common property ‘Name’ which corresponds to the property specified in the ‘select distinct’ query (e.g., Query 520 - a ). However, Index Portion 501 - c and Index Portion 511 - c do not share properties ‘Age’ (Property 508 , Index Portion 501 - c ) and ‘Eye Color’ (Property 518 , Index Portion 511 - c ).
- values of ‘Age’ and ‘Eye Color,’ which correspond to incompatible ‘additional’ properties are treated as postfixes that can be ignored, which allows Index Portion 501 - c and Index Portion 511 - c to be used together to execute the ‘select distinct’ query.
- the set of index portions includes ( 741 - a ) a first index portion and a second index portion.
- the set of index portions includes Index Portion 501 - c and Index Portion 511 - c .
- Datastore Server 106 retrieves ( 741 - b ) from the first index portion, a first batch of value combinations, where the first batch includes a plurality of consecutive value combinations from the first index portion.
- Index Portion 501 - c includes consecutive index entries with values of Property Name 506 corresponding to ‘Adam,’ ‘Adam,’ ‘Adam,’ ‘Adam,’ ‘Adam,’ ‘Cathy,’ ‘Cathy,’ ‘Cathy,’ ‘Karen,’ and ‘Karen,’ and if a batch size is defined (e.g., predetermined) as ten (e.g., each batch includes ten value combinations, see step 741 - g ), then Datastore Server 106 retrieves from Index Portion 501 - c , a first batch of value combinations including ‘Adam,’ ‘Adam,’ ‘Adam,’ ‘Adam,’ ‘Cathy,’ ‘Cathy,’ ‘Cathy,’ ‘Karen,’ and ‘
- the first set of one or more candidate value combinations includes ( 741 - d ) a plurality of candidate value combinations.
- the first batch of value combinations described above with reference to step 741 - b (e.g., the first batch of value combinations including ‘Adam,’ ‘Adam,’ ‘Adam,’ ‘Adam,’ ‘Adam,’ ‘Cathy,’ ‘Cathy’ ‘Karen,’ and ‘Karen,’)
- Datastore Server 106 identifies ( 741 - c ) a first set of one or more candidate value combinations, e.g., ‘Adam,’ ‘Cathy’ and ‘Karen.’
- Datastore Server 106 retrieves ( 741 - e ), from the second index portion, a second batch of value combinations, where the second batch includes a plurality of consecutive value combinations from the second index portion. For example, as described above with reference to step 741 - b , if Index Portion 511 - c includes consecutive index entries with values of Property Name 506 corresponding to ‘Adam,’ ‘Adam,’ ‘Adam,’ ‘Adam,’ ‘Adam,’ ‘Bernie,’ ‘Bernie,’ ‘Bernie,’ ‘Brett,’ and ‘Brett,’ and if the batch size is defined (e.g., predetermined) as ten (e.g., each batch includes ten value combinations, see again step 741 - g ), then Datastore Server 106 retrieves from Index Portion 511 - c , a second batch of value combinations including ‘Adam,’ ‘Adam,’ ‘Adam,’ ‘Adam,’ ‘Adam,’ ‘Bernie,’ ‘Bernie,
- Datastore Server 106 identifies ( 741 - f ) a first set of one or more candidate value combinations, e.g., ‘Adam,’ ‘Bernie,’ and ‘Brett.’
- the first batch of value combinations (see step 741 - b ) and the second batch of value combinations (see step 741 - e ) each include ( 741 - g ) N value combinations, where N is a predefined integer greater than one (e.g., 2 , 3 , 4 , 5 , 10 , 15 , 20 , 100 ).
- N is a predefined integer greater than one (e.g., 2 , 3 , 4 , 5 , 10 , 15 , 20 , 100 ).
- a batch retrieval operation will retrieve multiple different value combinations and thus the respective index will not have to be queried each time that a new value combination is needed for the respective index, thereby reducing the impact of network latency corresponding to data transit times between the requesting process and the respective index and reducing the processing load on the respective index.
- efficiency is gained by not retrieving all of the index entries that have the same value combination.
- a batch size can be selected that preserves the efficiency of skipping consecutive index entries in regions of the index portions that are homogenous (e.g., regions of sequential index entries larger than the batch size that have same value combination) while gaining the efficiency of retrieving multiple value combinations in regions of the index portions that are heterogeneous (e.g., regions of sequential index entries smaller than the batch size that include index entries with multiple different value combinations).
- Datastore Server 106 compares ( 742 ) candidate value combinations, including comparing a plurality of the respective candidate value combinations so as to identify distinct value combinations, if any, from the plurality of respective candidate value combinations in accordance with the query. For example, as shown in FIG.
- Datastore Server 106 compares ( 561 - a ) candidate values ‘Adam’ and ‘Adam’ to identify ‘Adam’ as a distinct candidate value; Datastore Server 106 then compares ( 561 - b ) candidate values ‘Cathy’ and ‘Bernie’ to identify ‘Bernie’ as a distinct candidate value; Datastore Server 106 next compares ( 561 - c ) candidate values ‘Cathy’ and ‘Brett’ to identify ‘Brett’ as a distinct candidate value, and so on.
- the comparison between the plurality of identified value combinations results in selecting none of the identified value combinations as distinct value combinations for the respective property. For example as shown in FIG. 5C , if the logical relationship specified by the query is Boolean AND, and if candidate values retrieved from the two index portions are not equal (e.g., candidate value ‘Bernie’ retrieved from Index Portion 511 - c and candidate value ‘Cathy’ retrieved from Index Portion 501 - c ), then neither of the candidate values is selected as a distinct candidate value.
- the comparing of candidate value combinations is performed ( 744 ) in accordance with a logical relationship between a plurality of operands specified in the requestor-specified filter criteria (e.g., the requestor-specified filter criteria described above with reference to operation 704 ). For example, if the logical relationship between two filters corresponding to two index portions is AND, then the same value combination must be found in both of the indexes to be selected as a distinct value combination. For example, as shown in FIG.
- the query (e.g., Query 520 - a ) specifies a Boolean AND logical relationship
- ‘Adam’ is retrieved as a distinct value combination since ‘Adam’ a value combination found in both index portions used for the execution of the query.
- ‘Bernie’ and ‘Cathy’ are not identified as distinct value combinations since they are present in one but not both index portions used for query-execution.
- the value combination must be found in at least one of the index portions to be selected as a distinct value combination, and if the value combination is found in both of the index portions, it is only selected as a distinct value combination once.
- the difference in the logical relationship causes Datastore Server 106 to identify ‘Bernie’ and ‘Cathy’ as distinct value combinations since they are present in at least one index portion used for query-execution.
- Datastore Server 106 compares ( 748 ) the first candidate value combination and the second candidate value combination so as to identify distinct value combinations, if any, from the first candidate value combination and the second candidate value combination in accordance with the query.
- Datastore Server 106 retrieves candidate values ‘Cathy’ and ‘Bernie’ from Index Portion 501 - c and Index Portion 511 - c , respectively, and compares ( 561 - b ) the retrieved candidate values ‘Cathy’ and ‘Bernie’ to identify ‘Bernie’ as a distinct candidate value.
- Datastore Server 106 retrieves candidate values ‘Adam’ and ‘Adam’ from Index Portion 501 - c and Index Portion 511 - c , respectively, and compares the retrieved candidate values ‘Adam’ and ‘Adam’ to identify ‘Adam’ as a distinct candidate value.
- Datastore Server 106 compares ( 749 - b ) one or more candidate value combinations from the first set of candidate value combinations with one or more candidate value combinations from the second set of candidate value combinations in accordance with the query.
- Datastore Server 106 compares one or more of ‘Adam,’ ‘Cathy’ and ‘Karen’ with one or more of ‘Adam,’ ‘Bernie,’ and ‘Brett’ in accordance with the query.
- the distinct value combination identified by comparing the first and second sets of candidate combinations would be ‘Adam.’
- ‘Adam’ is identified as a distinct value, it is discarded from both batches of candidate value combinations and the remaining candidate values are compared.
- ‘Bernie’ and ‘Brett’ are discarded as they do not match any candidate value combinations from Index Portion 501 - c , and after running out of candidate value combinations from Index Portion 511 - c , the process optionally iterates, as described below (e.g., Datastore Server 106 retrieves a new batch of candidate value combinations from Index Portion 511 - c starting at the first value combination greater than or equal to ‘Cathy,’ as ‘Cathy’ is the alphabetically lowest value combination in the batch from Index Portion 501 - c ).
- Datastore Server 106 avoids making at least one request to Index Portion 501 - c , because the batch of candidate value combinations included three candidate values (e.g., ‘Adam,’ ‘Cathy’ and ‘Karen’), so that Datastore Server 106 knows that ‘Cathy’ is the next value combination in Index Portion 501 - c that is greater than ‘Adam’ without requesting additional information from Index Portion 501 - c.
- three candidate values e.g., ‘Adam,’ ‘Cathy’ and ‘Karen’
- Datastore Server 106 updates ( 750 ) the current value of the query cursor.
- updating ( 752 ) the current value of the query cursor includes setting the current value of the query cursor based on one of the retrieved candidate value combinations. For example, when there is not a match, then Datastore Server 106 sets the current value of the query cursor to equal one of the retrieved candidate value combinations (e.g., an AND iteration failed to find a match for a candidate value in all of the index portions and is starting over with a next candidate value). In the example shown in FIG.
- Datastore Server 106 traverses ( 560 - b ) Index Portion 511 - c and identifies ‘Bernie’ as a candidate value, updates the current value of the query cursor to ‘Bernie’ and proceeds to Index Portion 501 - c to identify the next distinct value greater than or equal to the current value of the query cursor (e.g., ‘Bernie’).
- Datastore Server 106 fails to find ‘Bernie’ as a candidate value in Index Portion 501 - c , it sets the current value of the query cursor to ‘Cathy’ (the identified candidate value in Index Portion 501 - c ).
- Datastore Server 106 sets the current value of the query cursor to be nominally greater than the retrieved candidate value combination (e.g., for a successful AND/OR operation, Datastore Server 106 looks for a next value combination by searching using the identified value combination plus the null character).
- Datastore Server 106 when the comparing of candidate value combinations includes ( 754 ) comparing a first candidate value combination from a first index portion and a second candidate value combination from a second index portion (see step 748 ), Datastore Server 106 makes a determination as to whether the first candidate value combination is different from a predefined portion, corresponding to the one more properties, of the current value of the query cursor. In some implementations, Datastore Server 106 makes a determination as to whether the first candidate value combination is sequentially adjacent to rather than equal to a predefined portion, corresponding to the one more properties, of the current value of the query cursor.
- the current value of the query cursor has a plurality of portions, including a first portion corresponding to identified value combinations (e.g., candidate value combinations that correspond to the one or more properties for which the select distinct query was specified).
- the query cursor includes a second portion indicating inclusivity of the cursor (e.g., whether the cursor is updated when a matching value combination is retrieved from one of the index portions). For example, when the query cursor includes a portion indicating that the query cursor is inclusive (e.g., for a select distinct query with a logical relationship of AND between filters where at least two index portions have not yet been searched) the first portion of the current value of the query cursor is not updated if a match is found in a next index portion.
- the query cursor when the query cursor includes a portion indicating that the query cursor is exclusive (e.g., for a select distinct query with a logical relationship of AND between filters where a match has been found in all but one of the index portions, or for a select distinct query with a logical relationship of OR between filters) the first portion of the current value of the query cursor is updated if a match is found in a next index portion.
- Datastore Server 106 sets ( 758 ) the predefined portion of the current value of the query cursor to the first candidate value combination. For example, as shown in FIG.
- Datastore Server 106 when Datastore Server 106 identifies ‘Bernie’ as a candidate value from Index Portion 511 - c , Datastore Server 106 updates the current value of the query cursor to ‘Bernie’ and proceeds to Index Portion 501 - c to identify the next distinct value greater than or equal to the current value of the predefined portion of the query cursor (e.g., ‘Bernie’) in Index Portion 501 - c .
- Datastore Server 106 finds ‘Cathy’ as the next candidate value in Index Portion 501 - c , and makes a determination that ‘Cathy’ is different from the current value of the predefined portion of the query cursor (e.g., ‘Bernie’), Datastore Server 106 sets the current value of the predefined portion of the query cursor to ‘Cathy’ (the identified candidate value in Index Portion 501 - c ).
- Datastore Server 106 upon determining that the first candidate value combination is not ( 760 ) different from a predefined portion, corresponding to the one more properties, of the current value of the query cursor, Datastore Server 106 makes a determination as to whether there are more index portions to retrieve values from. In some implementations, upon determining that there are ( 762 ) more index portions to retrieve values from, Datastore Server 106 leaves ( 764 ) the predefined portion of the current value of the query cursor unchanged.
- Datastore Server 106 makes a determination that more index portions need to be searched, since, in this situation, the matching value combination must be found in all five index portions to be identified as a distinct value combination and a valid search result. Consequently, in this example, Datastore Server 106 will not update the current value of the query cursor until the matching value combination is found in all five of the index portions or the matching value combination is found not to exist in at least one of the index portions. In some implementations, upon determining that there are not ( 766 ) more index portions to retrieve values from, Datastore Server 106 increments ( 768 ) the predefined portion of the current value of the query cursor in accordance with the predefined sort order.
- Datastore Server 106 identifies ( 772 ) the first candidate value combination as the distinct value combination. For example, Datastore Server 106 identifies the first candidate value combination as the distinct value combination by determining that the first candidate value combination is the smallest value combination in a set of candidate value combinations where the indexes are sorted in an increasing sort order and the logical relationship is an OR. As illustrated in FIG.
- Datastore Server 106 retrieves candidate values ‘Cathy’ and ‘Bernie’ from Index Portion 501 - c and Index Portion 511 - c , respectively, and compares ( 561 - b ) the retrieved candidate values ‘Cathy’ and ‘Bernie’ to identify ‘Bernie’ as a distinct candidate value since ‘Bernie’ precedes ‘Cathy’ in the sort order (e.g., Bernie comes before Cathy in alphabetical order).
- Datastore Server 106 increments ( 774 ) the predefined portion of the current value of the query cursor in accordance with the predefined sort order.
- a value is ‘nominally’ greater than the first candidate value combination when the value is greater than the first candidate value combination by a small amount (e.g., an amount that is less than or equal to the smallest permitted step size between two subsequent value combinations).
- the current value of the query cursor is set to be the first candidate value combination plus the null character.
- Datastore Server 106 makes a determination as to whether a termination condition has been met. For example, Datastore Server 106 makes a determination as to whether at least a respective distinct value combination has been identified. Upon determining that a termination condition has not ( 776 ) been met, Datastore Server 106 repeats ( 778 ) the retrieving candidate value combinations and the comparing candidate value combinations one or more times for the set of index portions until at least a respective distinct value combination has been identified (or the termination condition is met). For example, Datastore Server 106 returns to operation 726 .
- Datastore Server 106 transmits ( 782 ) information corresponding to the respective distinct value combination to the requestor.
- the information corresponding to the respective distinct value combination includes ( 784 ) a representation of the respective distinct value combination (e.g., names of lawyers in California in the example shown in FIGS. 5C-5D ).
- retrieving the candidate value combinations includes ( 786 ), for a particular candidate value combination retrieved from a particular index entry, retrieving information specific to an entity corresponding to the particular index entry (e.g., retrieving an entity key or an age of the first lawyer with each distinct name in the example shown in FIGS.
- the particular candidate value combination is identified as the respective distinct value combination.
- the information corresponding to the respective distinct value combination includes information specific to the entity corresponding to the particular index entry from which the respective distinct value combination was retrieved (e.g., an entity name, an entity last modification date or the entire entity).
- the information corresponding to the respective distinct value combination includes the entity for each distinct value combination.
- the query may request Datastore Server 106 to return, for each distinct value of ‘Name’ in Index Portion 501 - c , the first entity when sorted by ‘Age.’
- the results would then correspond to entities with Keys 4 , 5 , 46 , 20 , 132 , and so on.
- a more specific example of retrieving information specific to entities corresponding to index entries identified while performing a select distinct query includes finding a name of the highest scoring player for each game in an online gaming site.
- the search query above would result in identifying a Username for the first index entry in an index portion sorted by game score (descending) for each unique game.
- FIGS. 7A-7H have been described is merely an example and is not intended to indicate that the described order is the only order in which the operations could be performed.
- One of ordinary skill in the art would recognize various ways to reorder the operations described herein. Additionally, it should be noted that details of other processes described herein with respect to method 600 (described herein with reference to FIG. 6 ) are also applicable in an analogous manner to method 700 described above with respect to FIGS. 7A-7H .
- the entities, index(es), index portion(s), queries, and responses described above with reference to method 700 optionally have one or more of the characteristics of the various entities, index(es), index portion(s), queries, and responses described herein with reference to method 600 .
- these details are not repeated here.
Abstract
Description
-
-
Operating System 210 that includes procedures for handling various basic system services and for performing hardware dependent tasks; - Network Communication Module (or instructions) 212 that is used for connecting
Client System 102 to other computers (e.g.,App Server 104 or Datastore Server 106) via Network Interface 204 (wired or wireless) and one or more Communication Networks 120 (FIG. 1 ), such as the Internet, other wide area networks, local area networks, metropolitan area networks, and so on; -
Web Browser 110 for loading web pages such as aWeb Page 214, which optionally includes code for executing a Client Application 112-a as an embedded application inWeb Page 214, where Client Application 112-a sends requests toDatastore Server 106 or toApp Server 104 and displays data received fromDatastore Server 106 or from App Server 104 (e.g., information corresponding to an empirically-determined schema for a schemaless entity database stored at Datastore Server 106); - dedicated Client Application 112-b (e.g., a stand-alone email client or a desktop search application) for sending requests to
Datastore Server 106 or toApp Server 104 and displaying data received fromDatastore Server 106 or from App Server 104 (e.g., information corresponding to an empirically-determined schema for a schemaless entity database stored at Datastore Server 106); and - optionally,
Data 216 such as cached data (e.g., recently accessed entities, responses to prior requests, etc.), and/or information about empirically-determined schema(s) received fromDatastore Server 106 orApp Server 104.
-
-
-
Operating System 310 that includes procedures for handling various basic system services and for performing hardware dependent tasks; - Network Communication Module (or instructions) 312 that is used for connecting
App Server 104 to other computers (e.g.,Client 102 or Datastore Server 106) via Network Interface 304 (wired or wireless), and one or more Communication Networks 120 (FIG. 1 ), such as the Internet, other wide area networks, local area networks, metropolitan area networks, and so on; -
Frontend Server 322 for coordinating communication betweenApp Server 104,Clients 102,Datastore Server 106 and any other computer systems with whichApp Server 104 communicates; -
Application 314 for processing requests fromClients 102 and relaying the requests toDatastore Server 106 corresponding to the client-specified requests, in some embodiments,Application 314 is a backend ofClient Application 112 atClient 102, thusClient 102 interacts primary withApplication 314, andApplication 314 makes specific data requests toDatastore Server 106 that enableDatastore Server 106 to respond to the client-specified requests fromClient 102; - optionally,
Data 316 such as cached data (e.g., recently accessed entities, responses to prior requests, etc.), and/or information about empirically-determined schema(s) received fromDatastore Server 106.
-
-
-
Operating System 410 that includes procedures for handling various basic system services and for performing hardware dependent tasks; - Network Communication Module (or instructions) 412 that is used for connecting
Datastore Server 106 to other computers (e.g.,Client 102 or App Server 104) via Network Interfaces 404 (wired or wireless) and one or more Communication Networks 120 (FIG. 1 ), such as the Internet, other wide area networks, local area networks, metropolitan area networks, and so on; -
Frontend Server 122 for coordinating communication betweenDatastore Server 106,Clients 102,App Server 104 and any other computer systems with whichDatastore Server 106 communicates; -
Request Processor 124 for converting a search query received fromClient 102 into a search query to be executed byQuery Engine 126; for multi-step search queries, the converting optionally includes revising the order and/or composition of the steps so as to improve the speed and/or efficiency of performing the search query (e.g., by reducing the number of index scans used to produce the result and/or performing steps that are likely to eliminate a large number of non-matching entities earlier in the search process); -
Query Engine 126 for performing the search query by identifying index portions and searching the index portions using the search query;-
Query Cursor Generator 420 for generating a query cursor that indicates a location in the index portions at whichQuery Engine 126 stopped searching (e.g., stopped retrieving identifiers for matching index entries), the query cursor is, optionally, sent along with results to serve as a ‘bookmark’ if the Client decides to resume the search at the stopping point; -
Query Cursor Translator 421 for receiving, along with a new search query, a query cursor generated in response to a prior search query, decomposing the query cursor and determining a corresponding new query cursor that indicates a location in index portions associated with the new search query corresponding to a stopping point in the index portions associated with the prior search query; -
Query Cursor Updater 422 for making a determination as to whether a query cursor needs to be updated and upon determining that the query cursor needs to be updated,Query Cursor Updater 422 updates the query cursor. -
Index Portion Identifier 424 for identifying index portions that are adapted for responding to a search query (e.g., index portions that match all of the filters of a search query and are sorted in same sort order, such as a sort order specified by the search query); - one or more Filter (Index)
Scanners 426 for scanning through an index or index portion to retrieve an identifier of one or more next matching results (e.g., matching index entries that are sequentially adjacent to or otherwise subsequent to the last matching index entry or query cursor position in the sort order) in the index or index portion; -
Candidate Value Generator 427 for retrieving candidate value combinations; in some implementations, for an index portion,Candidate Value Generator 427 retrieves index entries having a first section (including values for one or more properties) and a second section (including values for one or more additional properties) and, after retrieving the index entries, identifies a combination of the values in the first section and the second section as the candidate value combination for the index portion (e.g.,Candidate Value Generator 427 truncates index entries retrieved from different indexes so that comparable portions of index entries from otherwise incompatible indexes can be compared with each other); and - one or more Logical-
Relationship Scanners 428 for retrieving identifiers of matching entities from the index portions identified byIndex Portion Identifier 424 in accordance with the received search query, the Logical-Relationship Scanners 428 typically include one or more of an AND_Scanner 440 (described in greater detail below with reference toFIG. 5C ), aNOT_Scanner 442 and an OR Scanner 444 (described in greater detail below with reference toFIG. 5D );
-
-
Response Generator 128 for organizing information concerning matching entities identified byQuery Engine 126 and generating display information to be transmitted toClient 102, where the display information specifies formatting of the search results atClient 102; -
Index Generator 130 for generating indexes for use in executing search queries, in someimplementations Index Generator 130 generates a large number of indexes (e.g., at least one index for each property that can be used to sort and/or filter search results) so that for each possible combination of filters and sort orders in a search query, there exists an index including an index portion where the index entries matching the combination of filters are arranged in a contiguous block of index entries sorted in the sort order; - optionally,
Entity Database 140 storing entities or information about entities; - one or
more Indexes 142 which store information about entities and properties of the entities, typically theIndexes 142 are each sorted in accordance with values of the properties for the entities, as described in greater detail below with reference toFIGS. 5A-5B ; - optionally,
User Database 450 storing information about users and user search preferences, in some embodiments when the entities are user specific (e.g., a collection of a user's photos, emails or other documents), the user database identifies which entities and indexes the user has authority to access;User Database 450, optionally, stores addition user account information as well; and - optionally, Query
Cursors 452 received fromClient 102 or generated byQuery Cursor Generator 420 and sent toClient 102 in response to prior search queries, alternatively query cursors are not stored atDatastore Server 106 and are instead received fromClient 102 on an as needed basis in conjunction with requests to perform search queries using the query cursors.
-
Claims (20)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/892,215 US9342553B1 (en) | 2012-05-13 | 2013-05-10 | Identifying distinct combinations of values for entities based on information in an index |
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201261646349P | 2012-05-13 | 2012-05-13 | |
US201261714155P | 2012-10-15 | 2012-10-15 | |
US13/892,215 US9342553B1 (en) | 2012-05-13 | 2013-05-10 | Identifying distinct combinations of values for entities based on information in an index |
Publications (1)
Publication Number | Publication Date |
---|---|
US9342553B1 true US9342553B1 (en) | 2016-05-17 |
Family
ID=55920125
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US13/892,215 Active 2034-05-05 US9342553B1 (en) | 2012-05-13 | 2013-05-10 | Identifying distinct combinations of values for entities based on information in an index |
Country Status (1)
Country | Link |
---|---|
US (1) | US9342553B1 (en) |
Cited By (36)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20160364667A1 (en) * | 2015-06-15 | 2016-12-15 | Microsoft Technology Licensing, Llc | Providing dynamically responsive availability view |
CN106886548A (en) * | 2016-08-03 | 2017-06-23 | 阿里巴巴集团控股有限公司 | Data query method and device |
US20190327206A1 (en) * | 2018-04-18 | 2019-10-24 | Forcepoint, LLC | Resolution of Entity Identifiers Using Type Dependent Normalization |
US20200076783A1 (en) * | 2018-09-04 | 2020-03-05 | Forcepoint, LLC | In-Line Resolution of an Entity's Identity |
US10769283B2 (en) | 2017-10-31 | 2020-09-08 | Forcepoint, LLC | Risk adaptive protection |
US10776708B2 (en) | 2013-03-01 | 2020-09-15 | Forcepoint, LLC | Analyzing behavior in light of social time |
US10832153B2 (en) | 2013-03-01 | 2020-11-10 | Forcepoint, LLC | Analyzing behavior in light of social time |
US10949428B2 (en) | 2018-07-12 | 2021-03-16 | Forcepoint, LLC | Constructing event distributions via a streaming scoring operation |
US20210141929A1 (en) * | 2019-11-12 | 2021-05-13 | Pilot Travel Centers Llc | Performing actions on personal data stored in multiple databases |
US11025659B2 (en) | 2018-10-23 | 2021-06-01 | Forcepoint, LLC | Security system using pseudonyms to anonymously identify entities and corresponding security risk related behaviors |
US11025638B2 (en) | 2018-07-19 | 2021-06-01 | Forcepoint, LLC | System and method providing security friction for atypical resource access requests |
US11080032B1 (en) | 2020-03-31 | 2021-08-03 | Forcepoint Llc | Containerized infrastructure for deployment of microservices |
US11080109B1 (en) | 2020-02-27 | 2021-08-03 | Forcepoint Llc | Dynamically reweighting distributions of event observations |
US11132461B2 (en) | 2017-07-26 | 2021-09-28 | Forcepoint, LLC | Detecting, notifying and remediating noisy security policies |
US11132411B2 (en) * | 2016-08-31 | 2021-09-28 | Advanced New Technologies Co., Ltd. | Search information processing method and apparatus |
US11171980B2 (en) | 2018-11-02 | 2021-11-09 | Forcepoint Llc | Contagion risk detection, analysis and protection |
US11190589B1 (en) | 2020-10-27 | 2021-11-30 | Forcepoint, LLC | System and method for efficient fingerprinting in cloud multitenant data loss prevention |
US20210383007A1 (en) * | 2020-06-04 | 2021-12-09 | Pilot Travel Centers Llc | Data deletion and obfuscation system |
US11223646B2 (en) | 2020-01-22 | 2022-01-11 | Forcepoint, LLC | Using concerning behaviors when performing entity-based risk calculations |
US11271863B2 (en) * | 2016-06-01 | 2022-03-08 | At&T Intellectual Property I, L.P. | Enterprise business mobile dashboard |
US11314787B2 (en) | 2018-04-18 | 2022-04-26 | Forcepoint, LLC | Temporal resolution of an entity |
US11411973B2 (en) | 2018-08-31 | 2022-08-09 | Forcepoint, LLC | Identifying security risks using distributions of characteristic features extracted from a plurality of events |
US11429697B2 (en) | 2020-03-02 | 2022-08-30 | Forcepoint, LLC | Eventually consistent entity resolution |
US11436512B2 (en) | 2018-07-12 | 2022-09-06 | Forcepoint, LLC | Generating extracted features from an event |
US11516206B2 (en) | 2020-05-01 | 2022-11-29 | Forcepoint Llc | Cybersecurity system having digital certificate reputation system |
US11516225B2 (en) | 2017-05-15 | 2022-11-29 | Forcepoint Llc | Human factors framework |
US11544390B2 (en) | 2020-05-05 | 2023-01-03 | Forcepoint Llc | Method, system, and apparatus for probabilistic identification of encrypted files |
US11568136B2 (en) | 2020-04-15 | 2023-01-31 | Forcepoint Llc | Automatically constructing lexicons from unlabeled datasets |
US11630901B2 (en) | 2020-02-03 | 2023-04-18 | Forcepoint Llc | External trigger induced behavioral analyses |
US11704387B2 (en) | 2020-08-28 | 2023-07-18 | Forcepoint Llc | Method and system for fuzzy matching and alias matching for streaming data sets |
US11755584B2 (en) | 2018-07-12 | 2023-09-12 | Forcepoint Llc | Constructing distributions of interrelated event features |
US11810012B2 (en) | 2018-07-12 | 2023-11-07 | Forcepoint Llc | Identifying event distributions using interrelated events |
US11836265B2 (en) | 2020-03-02 | 2023-12-05 | Forcepoint Llc | Type-dependent event deduplication |
US20230394016A1 (en) * | 2020-09-02 | 2023-12-07 | Nec Corporation | Coupling table specification system, coupling table search device, method, and program |
US11888859B2 (en) | 2017-05-15 | 2024-01-30 | Forcepoint Llc | Associating a security risk persona with a phase of a cyber kill chain |
US11895158B2 (en) | 2020-05-19 | 2024-02-06 | Forcepoint Llc | Cybersecurity system having security policy visualization |
Citations (9)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5511186A (en) * | 1992-11-18 | 1996-04-23 | Mdl Information Systems, Inc. | System and methods for performing multi-source searches over heterogeneous databases |
US5742806A (en) * | 1994-01-31 | 1998-04-21 | Sun Microsystems, Inc. | Apparatus and method for decomposing database queries for database management system including multiprocessor digital data processing system |
US20010037329A1 (en) * | 2000-04-28 | 2001-11-01 | Huffman Paul C. | Execution of database queries including filtering |
US20030140035A1 (en) * | 2002-01-07 | 2003-07-24 | Michael Burrows | System and method for indexing and querying structured text |
US20040153435A1 (en) * | 2003-01-30 | 2004-08-05 | Decode Genetics Ehf. | Method and system for defining sets by querying relational data using a set definition language |
US20070185838A1 (en) * | 2005-12-29 | 2007-08-09 | Thomas Peh | Efficient calculation of sets of distinct results |
US20080010302A1 (en) * | 2006-06-27 | 2008-01-10 | International Business Machines Corporation | Optimizing cursor movement in holistic twig joins |
US20110119249A1 (en) * | 2009-11-13 | 2011-05-19 | Oracle International Corporation | Index backbone join |
US20130282765A1 (en) * | 2012-04-24 | 2013-10-24 | International Business Machines Corporation | Optimizing sparse schema-less data in relational stores |
-
2013
- 2013-05-10 US US13/892,215 patent/US9342553B1/en active Active
Patent Citations (9)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5511186A (en) * | 1992-11-18 | 1996-04-23 | Mdl Information Systems, Inc. | System and methods for performing multi-source searches over heterogeneous databases |
US5742806A (en) * | 1994-01-31 | 1998-04-21 | Sun Microsystems, Inc. | Apparatus and method for decomposing database queries for database management system including multiprocessor digital data processing system |
US20010037329A1 (en) * | 2000-04-28 | 2001-11-01 | Huffman Paul C. | Execution of database queries including filtering |
US20030140035A1 (en) * | 2002-01-07 | 2003-07-24 | Michael Burrows | System and method for indexing and querying structured text |
US20040153435A1 (en) * | 2003-01-30 | 2004-08-05 | Decode Genetics Ehf. | Method and system for defining sets by querying relational data using a set definition language |
US20070185838A1 (en) * | 2005-12-29 | 2007-08-09 | Thomas Peh | Efficient calculation of sets of distinct results |
US20080010302A1 (en) * | 2006-06-27 | 2008-01-10 | International Business Machines Corporation | Optimizing cursor movement in holistic twig joins |
US20110119249A1 (en) * | 2009-11-13 | 2011-05-19 | Oracle International Corporation | Index backbone join |
US20130282765A1 (en) * | 2012-04-24 | 2013-10-24 | International Business Machines Corporation | Optimizing sparse schema-less data in relational stores |
Cited By (68)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US10832153B2 (en) | 2013-03-01 | 2020-11-10 | Forcepoint, LLC | Analyzing behavior in light of social time |
US11783216B2 (en) | 2013-03-01 | 2023-10-10 | Forcepoint Llc | Analyzing behavior in light of social time |
US10776708B2 (en) | 2013-03-01 | 2020-09-15 | Forcepoint, LLC | Analyzing behavior in light of social time |
US10860942B2 (en) | 2013-03-01 | 2020-12-08 | Forcepoint, LLC | Analyzing behavior in light of social time |
US20160364667A1 (en) * | 2015-06-15 | 2016-12-15 | Microsoft Technology Licensing, Llc | Providing dynamically responsive availability view |
US11271863B2 (en) * | 2016-06-01 | 2022-03-08 | At&T Intellectual Property I, L.P. | Enterprise business mobile dashboard |
CN106886548A (en) * | 2016-08-03 | 2017-06-23 | 阿里巴巴集团控股有限公司 | Data query method and device |
US11132411B2 (en) * | 2016-08-31 | 2021-09-28 | Advanced New Technologies Co., Ltd. | Search information processing method and apparatus |
US11888863B2 (en) | 2017-05-15 | 2024-01-30 | Forcepoint Llc | Maintaining user privacy via a distributed framework for security analytics |
US11902294B2 (en) | 2017-05-15 | 2024-02-13 | Forcepoint Llc | Using human factors when calculating a risk score |
US11888861B2 (en) | 2017-05-15 | 2024-01-30 | Forcepoint Llc | Using an entity behavior catalog when performing human-centric risk modeling operations |
US11888859B2 (en) | 2017-05-15 | 2024-01-30 | Forcepoint Llc | Associating a security risk persona with a phase of a cyber kill chain |
US11516225B2 (en) | 2017-05-15 | 2022-11-29 | Forcepoint Llc | Human factors framework |
US11888862B2 (en) | 2017-05-15 | 2024-01-30 | Forcepoint Llc | Distributed framework for security analytics |
US11888864B2 (en) | 2017-05-15 | 2024-01-30 | Forcepoint Llc | Security analytics mapping operation within a distributed security analytics environment |
US11888860B2 (en) | 2017-05-15 | 2024-01-30 | Forcepoint Llc | Correlating concerning behavior during an activity session with a security risk persona |
US11902296B2 (en) | 2017-05-15 | 2024-02-13 | Forcepoint Llc | Using a security analytics map to trace entity interaction |
US11902293B2 (en) | 2017-05-15 | 2024-02-13 | Forcepoint Llc | Using an entity behavior catalog when performing distributed security operations |
US11843613B2 (en) | 2017-05-15 | 2023-12-12 | Forcepoint Llc | Using a behavior-based modifier when generating a user entity risk score |
US11838298B2 (en) | 2017-05-15 | 2023-12-05 | Forcepoint Llc | Generating a security risk persona using stressor data |
US11902295B2 (en) | 2017-05-15 | 2024-02-13 | Forcepoint Llc | Using a security analytics map to perform forensic analytics |
US11621964B2 (en) | 2017-05-15 | 2023-04-04 | Forcepoint Llc | Analyzing an event enacted by a data entity when performing a security operation |
US11601441B2 (en) | 2017-05-15 | 2023-03-07 | Forcepoint Llc | Using indicators of behavior when performing a security operation |
US11563752B2 (en) | 2017-05-15 | 2023-01-24 | Forcepoint Llc | Using indicators of behavior to identify a security persona of an entity |
US11979414B2 (en) | 2017-05-15 | 2024-05-07 | Forcepoint Llc | Using content stored in an entity behavior catalog when performing a human factor risk operation |
US11546351B2 (en) | 2017-05-15 | 2023-01-03 | Forcepoint Llc | Using human factors when performing a human factor risk operation |
US11528281B2 (en) | 2017-05-15 | 2022-12-13 | Forcepoint Llc | Security analytics mapping system |
US11132461B2 (en) | 2017-07-26 | 2021-09-28 | Forcepoint, LLC | Detecting, notifying and remediating noisy security policies |
US11244070B2 (en) | 2017-07-26 | 2022-02-08 | Forcepoint, LLC | Adaptive remediation of multivariate risk |
US11250158B2 (en) | 2017-07-26 | 2022-02-15 | Forcepoint, LLC | Session-based security information |
US11379607B2 (en) | 2017-07-26 | 2022-07-05 | Forcepoint, LLC | Automatically generating security policies |
US11379608B2 (en) | 2017-07-26 | 2022-07-05 | Forcepoint, LLC | Monitoring entity behavior using organization specific security policies |
US10769283B2 (en) | 2017-10-31 | 2020-09-08 | Forcepoint, LLC | Risk adaptive protection |
US10803178B2 (en) | 2017-10-31 | 2020-10-13 | Forcepoint Llc | Genericized data model to perform a security analytics operation |
US20190327206A1 (en) * | 2018-04-18 | 2019-10-24 | Forcepoint, LLC | Resolution of Entity Identifiers Using Type Dependent Normalization |
US11314787B2 (en) | 2018-04-18 | 2022-04-26 | Forcepoint, LLC | Temporal resolution of an entity |
US10949428B2 (en) | 2018-07-12 | 2021-03-16 | Forcepoint, LLC | Constructing event distributions via a streaming scoring operation |
US11544273B2 (en) | 2018-07-12 | 2023-01-03 | Forcepoint Llc | Constructing event distributions via a streaming scoring operation |
US11755585B2 (en) | 2018-07-12 | 2023-09-12 | Forcepoint Llc | Generating enriched events using enriched data and extracted features |
US11436512B2 (en) | 2018-07-12 | 2022-09-06 | Forcepoint, LLC | Generating extracted features from an event |
US11810012B2 (en) | 2018-07-12 | 2023-11-07 | Forcepoint Llc | Identifying event distributions using interrelated events |
US11755584B2 (en) | 2018-07-12 | 2023-09-12 | Forcepoint Llc | Constructing distributions of interrelated event features |
US11025638B2 (en) | 2018-07-19 | 2021-06-01 | Forcepoint, LLC | System and method providing security friction for atypical resource access requests |
US11411973B2 (en) | 2018-08-31 | 2022-08-09 | Forcepoint, LLC | Identifying security risks using distributions of characteristic features extracted from a plurality of events |
US11811799B2 (en) | 2018-08-31 | 2023-11-07 | Forcepoint Llc | Identifying security risks using distributions of characteristic features extracted from a plurality of events |
US20200076784A1 (en) * | 2018-09-04 | 2020-03-05 | Forcepoint, LLC | In-Line Resolution of an Entity's Identity |
US20200076783A1 (en) * | 2018-09-04 | 2020-03-05 | Forcepoint, LLC | In-Line Resolution of an Entity's Identity |
US11025659B2 (en) | 2018-10-23 | 2021-06-01 | Forcepoint, LLC | Security system using pseudonyms to anonymously identify entities and corresponding security risk related behaviors |
US11595430B2 (en) | 2018-10-23 | 2023-02-28 | Forcepoint Llc | Security system using pseudonyms to anonymously identify entities and corresponding security risk related behaviors |
US11171980B2 (en) | 2018-11-02 | 2021-11-09 | Forcepoint Llc | Contagion risk detection, analysis and protection |
US20210141929A1 (en) * | 2019-11-12 | 2021-05-13 | Pilot Travel Centers Llc | Performing actions on personal data stored in multiple databases |
US11489862B2 (en) | 2020-01-22 | 2022-11-01 | Forcepoint Llc | Anticipating future behavior using kill chains |
US11570197B2 (en) | 2020-01-22 | 2023-01-31 | Forcepoint Llc | Human-centric risk modeling framework |
US11223646B2 (en) | 2020-01-22 | 2022-01-11 | Forcepoint, LLC | Using concerning behaviors when performing entity-based risk calculations |
US11630901B2 (en) | 2020-02-03 | 2023-04-18 | Forcepoint Llc | External trigger induced behavioral analyses |
US11080109B1 (en) | 2020-02-27 | 2021-08-03 | Forcepoint Llc | Dynamically reweighting distributions of event observations |
US11836265B2 (en) | 2020-03-02 | 2023-12-05 | Forcepoint Llc | Type-dependent event deduplication |
US11429697B2 (en) | 2020-03-02 | 2022-08-30 | Forcepoint, LLC | Eventually consistent entity resolution |
US11080032B1 (en) | 2020-03-31 | 2021-08-03 | Forcepoint Llc | Containerized infrastructure for deployment of microservices |
US11568136B2 (en) | 2020-04-15 | 2023-01-31 | Forcepoint Llc | Automatically constructing lexicons from unlabeled datasets |
US11516206B2 (en) | 2020-05-01 | 2022-11-29 | Forcepoint Llc | Cybersecurity system having digital certificate reputation system |
US11544390B2 (en) | 2020-05-05 | 2023-01-03 | Forcepoint Llc | Method, system, and apparatus for probabilistic identification of encrypted files |
US11895158B2 (en) | 2020-05-19 | 2024-02-06 | Forcepoint Llc | Cybersecurity system having security policy visualization |
US20210383007A1 (en) * | 2020-06-04 | 2021-12-09 | Pilot Travel Centers Llc | Data deletion and obfuscation system |
US11941138B2 (en) * | 2020-06-04 | 2024-03-26 | Pilot Travel Centers, LLC | Data deletion and obfuscation system |
US11704387B2 (en) | 2020-08-28 | 2023-07-18 | Forcepoint Llc | Method and system for fuzzy matching and alias matching for streaming data sets |
US20230394016A1 (en) * | 2020-09-02 | 2023-12-07 | Nec Corporation | Coupling table specification system, coupling table search device, method, and program |
US11190589B1 (en) | 2020-10-27 | 2021-11-30 | Forcepoint, LLC | System and method for efficient fingerprinting in cloud multitenant data loss prevention |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US9342553B1 (en) | Identifying distinct combinations of values for entities based on information in an index | |
US9195698B2 (en) | Selectively retrieving search results in accordance with different logical relationships | |
US9081851B2 (en) | Method and system for autocompletion using ranked results | |
US8027974B2 (en) | Method and system for URL autocompletion using ranked results | |
RU2718435C2 (en) | Computer-executable method and system for searching in inverted index having plurality of wordpositions lists | |
US20150234927A1 (en) | Application search method, apparatus, and terminal | |
US8396852B2 (en) | Evaluating execution plan changes after a wakeup threshold time | |
US11361036B2 (en) | Using historical information to improve search across heterogeneous indices | |
US9600501B1 (en) | Transmitting and receiving data between databases with different database processing capabilities | |
US10282358B2 (en) | Methods of furnishing search results to a plurality of client devices via a search engine system | |
US8732160B2 (en) | Exploring large textual data sets via interactive aggregation | |
US9148329B1 (en) | Resource constraints for request processing | |
US9201924B1 (en) | Processing partially supported queries | |
US20050240570A1 (en) | Partial query caching | |
CN110889023A (en) | Distributed multifunctional search engine of elastic search | |
US20150339387A1 (en) | Method of and system for furnishing a user of a client device with a network resource | |
US10235432B1 (en) | Document retrieval using multiple sort orders | |
US8930373B2 (en) | Searching with exclusion tokens | |
Sernicula et al. | A Study of a Local Search Engine for Desktop PCs using an Enhanced Boyer-Moore Algorithm |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:FULLER, ALFRED R.K.;REEL/FRAME:030757/0217Effective date: 20130510 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
CC | Certificate of correction | ||
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044566/0657Effective date: 20170929 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 4TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1551); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 4 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 8TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1552); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 8 |