GB2558980A - Neural network instruction set architecture - Google Patents
Neural network instruction set architecture Download PDFInfo
- Publication number
- GB2558980A GB2558980A GB1715031.9A GB201715031A GB2558980A GB 2558980 A GB2558980 A GB 2558980A GB 201715031 A GB201715031 A GB 201715031A GB 2558980 A GB2558980 A GB 2558980A
- Authority
- GB
- United Kingdom
- Prior art keywords
- tensor
- processing unit
- instruction
- computation
- loop
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Withdrawn
Links
- 238000013528 artificial neural network Methods 0.000 title claims abstract description 62
- 230000015654 memory Effects 0.000 claims abstract description 70
- 238000000034 method Methods 0.000 claims abstract description 57
- 230000004044 response Effects 0.000 claims description 10
- 230000004913 activation Effects 0.000 description 52
- 238000001994 activation Methods 0.000 description 52
- 239000000872 buffer Substances 0.000 description 17
- 230000008569 process Effects 0.000 description 16
- 238000004590 computer program Methods 0.000 description 11
- 230000006870 function Effects 0.000 description 8
- 238000004891 communication Methods 0.000 description 5
- 239000011159 matrix material Substances 0.000 description 5
- 230000003287 optical effect Effects 0.000 description 5
- 238000011176 pooling Methods 0.000 description 5
- 238000010586 diagram Methods 0.000 description 4
- 238000005192 partition Methods 0.000 description 4
- 238000003491 array Methods 0.000 description 2
- 238000013527 convolutional neural network Methods 0.000 description 2
- 238000010801 machine learning Methods 0.000 description 2
- 230000009467 reduction Effects 0.000 description 2
- 238000013515 script Methods 0.000 description 2
- 238000000926 separation method Methods 0.000 description 2
- 230000001133 acceleration Effects 0.000 description 1
- 238000009825 accumulation Methods 0.000 description 1
- 230000004888 barrier function Effects 0.000 description 1
- 230000005540 biological transmission Effects 0.000 description 1
- 239000003086 colorant Substances 0.000 description 1
- 238000003062 neural network model Methods 0.000 description 1
- 230000000644 propagated effect Effects 0.000 description 1
- 239000004065 semiconductor Substances 0.000 description 1
- 239000007787 solid Substances 0.000 description 1
- 239000000758 substrate Substances 0.000 description 1
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/045—Combinations of networks
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/06—Physical realisation, i.e. hardware implementation of neural networks, neurons or parts of neurons
- G06N3/063—Physical realisation, i.e. hardware implementation of neural networks, neurons or parts of neurons using electronic means
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F13/00—Interconnection of, or transfer of information or other signals between, memories, input/output devices or central processing units
- G06F13/14—Handling requests for interconnection or transfer
- G06F13/20—Handling requests for interconnection or transfer for access to input/output bus
- G06F13/28—Handling requests for interconnection or transfer for access to input/output bus using burst mode transfer, e.g. direct memory access DMA, cycle steal
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F17/00—Digital computing or data processing equipment or methods, specially adapted for specific functions
- G06F17/10—Complex mathematical operations
- G06F17/15—Correlation function computation including computation of convolution operations
- G06F17/153—Multidimensional correlation or convolution
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/30003—Arrangements for executing specific machine instructions
- G06F9/30072—Arrangements for executing specific machine instructions to perform conditional operations, e.g. using predicates or guards
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N20/00—Machine learning
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/0464—Convolutional networks [CNN, ConvNet]
Abstract
Method comprising a processing unit receiving 502 an instruction specifying data values for performing a tensor computation, and performing 504 the computation by executing a loop nest comprising a plurality of loops, the structure of the nest defined based on data values of the instruction. The tensor computation may be a portion of a neural network layer computation. At least one of the data values may specify the type of neural network layer, and the structure of the nest may be defined 506 at least in part by the type of layer. The instruction may cause the processing unit to access at least one memory address of an array in a storage medium, the address comprising a variable read by the processing unit during the computation. The processing unit may provide a control signal to a tensor traversal unit to cause the TTU to emit loop indices used in executing the loop nest. The processing unit may provide a control signal to the TTU to cause an array reference of the TTU to generate an address for a referenced array element used in executing the loop nest. Also disclosed are an electronic system and non-transitory computer-readable storage medium.
Description
(71) Applicant(s):
Google LLC
1600 Amphitheatre Parkway, Mountain View 94043, California, United States of America (72) Inventor(s):
Ravi Narayanaswami Dong Hyuk Woo Olivier Temam Harshit Khaitan (74) Agent and/or Address for Service:
Boult Wade Tennant
Verulam Gardens, 70 Gray's inn Road, LONDON, WC1X 8BT, United Kingdom (51) INT CL:
G06N 3/02 (2006.01) G06F 9/30 (2018.01) (56) Documents Cited:
EP 3226121 A2 WO 2017/196693 A1
US 9710265 B1
LIU et al., 2016 ACM/IEEE 43rd Annual International Symposium on Computer Architecture, published online 25 August 2016, IEEE, pp 393-405, Cambricon: An Instruction Set Architecture for Neural Networks
JINDAL et al., International Journal of Parallel Programming Vol 44 Issue 2, published online 20 August 2014, Springer, pp309-324, Exploiting GPUs with the Super Instruction Architecture (58) Field of Search:
INT CL G06F, G06N
Other: WPI, EPODOC, Patent Fulltext, INSPEC, XPESP, XPIEE, IP.COM, XPI3E, XPMISC, XPLNCS, XPRD, XPSPRNG, TDB (54) Title of the Invention: Neural network instruction set architecture Abstract Title: Tensor computation instruction (57) Method comprising a processing unit receiving 502 an instruction specifying data values for performing a tensor computation, and performing 504 the computation by executing a loop nest comprising a plurality of loops, the structure of the nest defined based on data values of the instruction. The tensor computation may be a portion of a neural network layer computation. At least one of the data values may specify the type of neural network layer, and the structure of the nest may be defined 506 at least in part by the type of layer. The instruction may cause the processing unit to access at least one memory address of an array in a storage medium, the address comprising a variable read by the processing unit during the computation. The processing unit may provide a control signal to a tensor traversal unit to cause the TTU to emit loop indices used in executing the loop nest. The processing unit may provide a control signal to the TTU to cause an array reference of the TTU to generate an address for a referenced array element used in executing the loop nest. Also disclosed are an electronic system and non-transitory computer-readable storage medium.
500 FIG. 5
At least one drawing originally filed was informal and the print reproduced here is taken from a later filed formal copy.
1/5
CM
Ο
E ο
ω ω
CD
C
Q.
Ε ο
Ο
Output FIG. 1 co
2/5
θ ο
CXJ
FIG. 2
300 ^
CM
Ο
3/5
Operation Code (Opcode) | Operation Type | Operation Description |
0 | TensorOp | Computations at the convolution and/or FC layers |
1 | TensorOp Computations at the max pooling layers | |
2 | TensorOp | Computations at the average pooling layers |
3 | TensorOp | Computations at the depth-wise convolution and/or elementwise multiply layers |
4 | DMAOp.ln | Compute tile (system 100) receives input activations and other data from instruction set 103 (via an example data bus) and place data in first bank 112 |
5 | DMAOp.Out | Compute tile reads data from first bank 112 and writes the data to an example data bus to output the data from system 100 |
6 | DMAOp.W-N | Compute tile moves data between the first bank 112 (N-mem) and the second bank 114 (W-mem). With this operation, data is moved from W-mem to N-mem |
7 | DMAOp.N-W | Compute tile moves data between the first bank 112 (N-mem) and the second bank 114 (W-mem). With this operation, data is moved from N-mem to W-mem |
8 | DMAOp.R-bus | Compute tile writes data to second bank 114 after retrieving the data from instruction set 103 (via an example data bus); or operation to read data from second bank and write the data to the bus to output the data from the compute tile |
9* | DMAOp.InFeed* | Higher level controller (external to compute tile) sends activations and weights/ parameter to compute tile |
10 * | DMAOp.OutFeed | Higher level controller moves inference workload results from classifier tile to external I/O device |
11 | TileFenceOp | Operation to prevent any new instructions from beina issued until pending instructions in the respective instruction buffers are retired |
12 | ScalarFenceOp | Operation to prevent issuance of new instructions until a threshold tilefenseop count is reached |
* Associated, in part, with operation performed by higher level controller device that is external to compute tile(s) |
FIG. 3
4/5
12 17
400
Input [x,y,zi]Filter [x,y,ζΐ,ζο]Output [x,y,zo]
FIG. 4A output [: ] [: ] [: ] = 0 for xx in range (1,50 , stride=10) : foryy in range (1,50 , stride=10) : forx in range (xx, xx+10) : for y in range (yy, yy+10) : for kx in range (1, 5): for ky in range (1,5) : for zi in range (1,3): for zo in range (1, 16): output [ x ] [ y ] [ zo ] += input [ x+kx ] [ y+ky ]
FIG. 4B
5/5
12 17
500
FIG. 5
NEURAL NETWORK INSTRUCTION SET ARCHITECTURE
BACKGROUND [0001] This specification relates to an instruction set for computation of Deep Neural Network (“DNN”).
[0002] Neural networks are machine learning models that employ one or more layers of models to generate an output, e.g., a classification, for a received input. Some neural networks include one or more hidden layers in addition to an output layer. The output of each hidden layer is used as input to the next layer in the network, i.e., the next hidden layer or the output layer of the network. Each layer of the network generates an output from a received input in accordance with current values of a respective set of parameters.
[0003] Some neural networks include one or more convolutional neural network layers. Each convolutional neural network layer has an associated set of kernels. Each kernel includes values established by a neural network model created by a user. In some implementations, kernels identify particular image contours, shapes, or colors. Kernels can be represented as a matrix structure of weight inputs. Each convolutional layer can also process a set of activation inputs. The set of activation inputs can also be represented as a matrix structure.
SUMMARY [0004] One innovative aspect of the subject matter described in this specification can be embodied in a computer-implemented method. The method includes receiving, by a processing unit, an instruction that specifies parameters for performing a tensor computation. In response to receiving the instruction, the method may include, performing, by the processing unit, the tensor computation by executing a loop nest comprising a plurality of loops, wherein a structure of the loop nest is defined based on one or more of the parameters of the instruction. These and other implementations can each optionally include one or more of the following features. For example, the tensor computation can be at least a portion of a computation of a neural network layer. The parameters specified by the instruction may comprise a parameter that specifies a type of the neural network layer, and the structure of the loop nest can be defined at least in part by the type of the neural network layer. Thereby, executing a loop nest comprising a plurality of loops may refer to performing a traversal over elements of a tensor in an order specified by a structure of nested loops, wherein said structure is specified e.g. by a depth of the loop nesting, and start and end indices, the stride and the direction of each loop respectively.
[0005] In some implementations, the tensor computation is at least a portion of a computation of a neural network layer. In some implementations, the data values specified by the instruction comprises at least one value that specifies a type of the neural network layer, and wherein the structure of the loop nest is defined at least in part by the type of the neural network layer. In some implementations, the instruction causes the processing unit to access at least one element of a dimension of a tensor, the element being a part of at least one index used in executing the loop nest during performance of the tensor computation. In some implementations, the instruction causes the processing unit to access at least one memory address of an array in a storage medium, the memory address of the array comprising a variable that is read by the processing unit during performance of the tensor computation.
[0006] In some implementations, performing the tensor computation comprises, providing, by the processing unit, at least one control signal to a tensor traversal unit (TTU) to cause the TTU to emit loop indices used in executing the loop nest during performance of the tensor computation. In some implementations, the method further comprises, providing, by the processing unit, at least one control signal to the TTU to cause an array reference of the TTU to generate an address for a referenced array element used in executing the loop nest during performance of the tensor computation. In some implementations, instruction indicates a first TTU counter that is summed with a second TTU counter to generate an address for an array reference associated with the TTU.
[0007] In some implementations, performing the tensor computation comprises, executing, by the processing unit, a first sync procedure that manages one or more operands associated with performance of the tensor computation, wherein managing an operand comprises stalling one or more loop nests based on a sync flag condition. In some implementations, performing the tensor computation comprises, executing, by the processing unit, a second sync procedure that manages incrementing a counter associated with a characteristic of the loop nest.
[0008] Another innovative aspect of the subject matter described in this specification can be embodied in an electronic system, comprising: a processing unit disposed in in the electronic system, the processing unit including one or more processing devices; and one or more machine-readable storage devices for storing instructions that are executable by the one or more processing devices to perform operations comprising: receiving, by the processing unit, an instruction that specifies data values for performing a tensor computation; and in response to receiving the instruction, performing, by the processing unit, the tensor computation by executing a loop nest comprising a plurality of loops, wherein a structure of the loop nest is defined based on one or more of the data values of the instruction.
[0009] Yet another innovative aspect of the subject matter described in this specification can be embodied in a non-transitory computer-readable storage medium comprising instructions executable by a processing unit which, upon such execution, causes the processing unit to perform operations comprising: receiving, by the processing unit, an instruction that specifies data values for performing a tensor computation; and in response to receiving the instruction, performing, by the processing unit, the tensor computation by executing a loop nest comprising a plurality of loops, wherein a structure of the loop nest is defined based on one or more of the data values of the instruction.
[0010] Other implementations of this and other aspects include corresponding systems, apparatus, and computer programs, configured to perform the actions of the methods, encoded on computer storage devices. A system of one or more computers can be so configured by virtue of software, firmware, hardware, or a combination of them installed on the system that in operation cause the system to perform the actions. One or more computer programs can be so configured by virtue of having instructions that, when executed by data processing apparatus, cause the apparatus to perform the actions.
[0011] The subject matter described in this specification can be implemented in particular embodiments so as to realize one or more of the following advantages. A processing unit can initiate programs to iterate deeply-nested loops with one instruction. The processing unit can execute received instructions encoded with data values for performing a tensor computation. Computation bandwidth of the processing unit is increased by reducing the number of instructions that the processor is required to execute when traversing a tensor to perform one or more computations. Instructions for performing tensor computations for a given neural network layer can be encoded and distributed amongst one or more computing systems of an example hardware computing system. Distribution of the encoded instructions to the various compute systems allows for increased computation bandwidth within a single system. Instruction quantity in a compute system is reduced because a single system is responsible only for a subset of the total computations needed for a given tensor.
[0012] The details of one or more implementations of the subject matter described in this specification are set forth in the accompanying drawings and the description below. Other potential features, aspects, and advantages of the subject matter will become apparent from the description, the drawings, and the claims.
BRIEF DESCRIPTION OF THE DRAWINGS [0013] FIG. 1 is a block diagram of an example computation system.
[0014] FIG. 2 illustrates an example tensor traversal unit.
[0015] FIG. 3 illustrates an example table that includes opcodes and corresponding operations performed, at least in part, by the example computation system of FIG. 1.
[0016] FIG. 4A illustrates an example activation tensor, an example weight tensor, and an example output tensor.
[0017] FIG. 4B illustrates an example loop nest that can be executed by a processing unit of the example computation system of FIG. 1.
[0018] FIG. 5 is a flow diagram that illustrates an example of a process for performing tensor computations by way of a computer-implemented method.
[0019] Fike reference numbers and designations in the various drawings indicate like elements.
DETAIFED DESCRIPTION [0020] The subject matter described in this specification relates to a computerimplemented process or method to accelerate machine learning inference workloads such that a processing unit performing the workload can achieve high performance while executing computations. The processes and methods described in this specification can be executed within hardware computing systems that are organized as a set of tiles, each of which are self-contained and can independently execute at least a portion of the computation required by a neural network layer.
[0021] A computation process performed within a neural network may consist of multiplication of an input tensor with a parameter/weight tensor on one or more cycles and performing an accumulation of the products over many cycles. An input-weight multiplication may then be written as the sum-of-product of each weight element multiplied with a row of the input tensor or matrix. Deep Neural Networks (DNNs) include multiple layers that feed into each other. Inference workloads that include tensor computations for a given layer are accelerated by the methods described in this specification. The subject-matter described in this specification can also relate to an image recognition and/or classification method/system using the disclosed techniques and hardware using a neural network instruction set architecture.
[0022] In general, when a software algorithm performs tensor computations by processing an N-dimensional tensor, a nested loop can be used, where each loop is responsible for traversing each dimension of the N-dimensional tensor. A multi-dimensional tensor can be a matrix, or multi-dimensional matrices. Each dimension of the N-dimensional tensor may include one or more elements, where each element may store a respective data value. For example, a tensor can be a variable in a program, where the variable may have three dimensions. The first dimension may have a length of three hundred elements, the second dimension may have a length of thousand elements, and the third dimension may have a length of twenty elements.
[0023] Traversing the tensor in a nested loop requires a computation of a memory address value of an element to load or store the corresponding data value of the element. For example, a for-loop is a nested loop, where three loops tracked by three loop index variables can be nested to traverse through the three-dimensional tensor. In some cases, a processor may need to execute a loop bound condition, such as setting a loop bound of an inner loop with an outer loop index variable. For example, in determining whether to exit the innermost loop of a nested loop, the program may compare the current value of the loop index variable of the inner-most loop with the current value of the loop index variable of the outermost loop of the nested loop.
[0024] Computational tasks associated with traversing a three-dimensional tensor can require a significant number of instructions such as branch instructions and integer arithmetic instructions. When each loop bound is small and the number of loops is large, the computations for memory address computation and tensor dimension traversal may take a significant portion of the overall execution time, and seriously degrade overall performance. As described in more detail below, methods executable by a processing unit that receives instructions encoded with data values for performing a tensor computation may increase the computation bandwidth of the processing unit by reducing the number of instructions that the processor is required to execute when traversing a tensor to perform one or more computations. In some implementations, computation bandwidth refers to, e.g., the maximum rate of operations that can be performed on a tensor or a number of operations that can be performed on a tensor.
[0025] Instructions for performing tensor computations for a given layer can be encoded and distributed amongst one or more computing systems (described below as compute tiles) within an example hardware computing system. Distribution of the encoded instructions to the various compute tiles allows for increased computation bandwidth within a single tile. Moreover, by distributing computations amongst multiple compute tiles, a processing unit of a compute tile consumes a reduced number of instructions (as compared to current systems) when traversing the tensor. Thereby, consuming an instruction e.g. refers to executing one or more instructions by a processing unit of a compute tile. Instruction quantity in a compute tile can be reduced because a single tile is responsible only for a subset of the total computations needed for a given tensor.
[0026] Additional details and descriptions relating to hardware computing systems for accelerating neural network tensor computations including dot-product and matrixmultiplications for neural network inference workloads are described in U.S. Patent Application No. 15/335,769, entitled “Neural Network Compute Tile,” filed on October 27, 2016. The entire disclosure of U.S. Patent Application No. 15/335,769 is expressly incorporated by reference herein in its entirety.
[0027] FIG. 1 shows a block diagram of an example computing system 100 for traversing one or more tensors to perform computations for a neural network layer. As shown, computing system 100 includes a processing unit 102, a storage medium 104, tensor traversal unit (TTU) 106, a multiply accumulate (MAC) operator 108, and an activation unit 110. Although a single TTU is shown, system 100 can include two or more TTUs 106 to process tensor traversal operations as well as memory access operations when one or more compute tiles are used to process tensor computations for a given neural network layer. Fikewise, although a single MAC is shown, system 100 can include multiple MAC operators 108.
[0028] The processing unit 102 is configured to process instructions for execution within the computing system 100, including instructions or program code stored in the storage medium 104 or other instructions/code stored in another storage device. The processing unit 102 may include one or more processors. Storage medium 104 can include one or more memory banks or units, including first bank 112 for storing activations and second bank 114 for storing weights. In some implementations, storage medium 104 is a volatile memory unit or units. In some other implementations, storage medium 104 is a non-volatile memory unit or units such as, for example, read-only memory (ROM) and/or electrically erasable programmable read-only memory (EEPROM). The storage medium 104 may also be another form of computer-readable medium, such as a floppy disk device, a hard disk device, an optical disk device, or a tape device, a flash memory or other similar solid state memory device, or an array of devices, including devices in a storage area network or other configurations.
[0029] Instruction set 103, when executed by the processing unit 102, causes the processing unit 102 to perform one or more tasks that include, for example, storing activations in memory address locations of first bank 112 and storing weights in memory address locations of second bank 114. Moreover, instructions 103 can also cause processing unit 102 to access the stored data from first bank 112 and second bank 114 and provide the accessed data to MAC operator 108. As described in more detail below, MAC operator 108 can perform multiply operations that can include multiplying an activation with a weight to produce either a partial sum(s) or to produce an output activation(s) that is provided to activation unit 110.
[0030] In general, the computing system 100 processes one or more instructions included within instruction set 103 to generate an output 116. Instruction set 103 can include at least one of a tensor operation (tensorop) instruction or direct memory access operation (DMAop) instruction. Computing system 100 can be configured to execute at least one tensorop and at least one DMAop instruction to perform tensor computations that include multiple linear algebra computations.
[0031] In some implementations, performing tensor computations include executing a DMAop instruction to access memory address locations that correspond to elements of a particular dimension of a tensor, where at least one memory address location stores data values for an element of the tensor. Tensor computations can further include executing a tensorop to traverse elements along a particular dimension of the tensor. In some implementations, performing a tensor computation corresponds to multiplying data values for elements of an activation tensor with data values for elements of a parameter or weight tensor to produce output values for a neural network layer.
[0032] As shown, TTU 106 can include instruction buffer 124. Although a single instruction buffer 124 is shown, compute system 100 may include multiple instruction buffers 124. Moreover, system 100 can include multiple TTUs 106 and each TTU 106 can include one or more instruction buffers 124. In some implementations, the different instruction buffers 124 within system 100 can include a tensorop instruction buffer and a DMAop instruction buffer. As described in more detail below, instructions received by system 100 and executed by processing unit 102 can include one of a tensorop instruction and the DMAop instruction. In some implementations, the received instructions are stored in instruction buffer 124 prior to execution by processing unit 102.
[0033] As discussed in more detail below with reference to FIG. 4, activations can be preloaded to first bank 112 in respective memory address locations that correspond to elements of an input tensor. Fikewise, weights can be pre-loaded to second bank 114 in respective memory address locations that correspond to elements of a weight tensor. In some implementations, instructions, activations, and weights are provided to system 100 from an external or higher level control device associated with a neural network hardware computing system.
[0034] In general, when the processing unit 102 executes one or more instructions for accessing a particular element of a tensor, the tensor traversal unit 106 determines the memory address of the element, such that the processing unit 102 may access storage medium 104 to read data representing the value of the particular element. For example, instructions stored in storage medium 104 can include program code for a nested loop program that can be executed by processing unit 102.
[0035] The nested loop program can include multiple variables that can have a range of values that are determined based on data values provided by instruction set 103. Processing unit 102 may execute the program code for the nested loop program to cause TTU 106 to access memory address locations that correspond to respective elements of at least two multidimensional arrays. For example, the multiple variables can include data values for instantiating an example deep loop nest that includes multiple inner and outer loops. In some implementations, the multiple variables and data values enable TTU 106 to instantiate a deep loop nest, such as a loop nest described below with reference to FIG. 4B (e.g., deep loop nest 402).
[0036] Based on current index variable values associated with the nested loop, the TTU 106 may determine an offset value that represents an offset from a first element of the multidimensional array variable. The processing unit 102 may then access, using the offset value and from the storage medium, the particular element of the two-dimensional array variable.
[0037] The tensor traversal unit 106 is configured to determine a status associated with one or more tensors. The status can include loop bound values, current loop index variable values, dimension multipliers for computing a memory address value, and/or program counter values for handling branch loop bounds. The tensor traversal unit 106 includes tensor status elements 122 and an arithmetic logic unit. Each of the tensor status elements 122 can be a storage element, for example a register or any other suitable storage circuitry. In some implementations, the tensor status elements 122 can be physically or logically arranged into different groups.
[0038] In some implementations, a group of the tensor status elements 122 can be physically or logically arranged into a multi-dimensional array. For example, each group of the tensor status elements 122 can be physically or logically arranged into a two-dimensional array. The arithmetic logic unit includes one or more arithmetic logic units (ALUs) that are configured to perform arithmetic and logic operations. For example, the arithmetic logic unit may include digital circuitry that is configured to perform addition, subtraction, multiplication, division, logic AND, logic OR, or any other suitable arithmetic and logic operations.
[0039] FIG. 2 shows an example set of tensor status elements 200 of a tensor traversal unit. The tensor status elements 200 may correspond to the tensor status elements 122 of the tensor traversal unit 106. The tensor traversal unit 200 includes a group of tensor index elements 202, a group of tensor bound elements 204, and a group of dimension multiplier elements 206. The tensor index elements 202 can be physically or logically arranged as a 2-D array having M rows and N columns, where M and N are integers greater than or equal to one. In some implementations, each row of the tensor index elements 202 may represent tensor index information for a tensor. For example, if a program defines two array variables VI and V2, the tensor traversal unit may assign rows 202a and 202b to track the tensor index information for array variables VI and V2, respectively. In some implementations, each column of the tensor index elements 202 may represent tensor index information for nested loop index variable values that are associated with a tensor. For example, if the program defines a nested loop having three loops for accessing the variable VI, where each loop of the nested loop is indexed by nested loop index variables i, j, and k, the tensor traversal unit may assign tensor index element Xyi, X12, and X13 to track the nested loop index variable i, j, and k, respectively.
[0040] The tensor bound elements 204 can be physically or logically arranged as a 2-D array having the same dimensions as the tensor index elements 202, where each element of the tensor bound elements 204 has a corresponding element in the tensor index elements 202. In some implementations, each row of the tensor bound elements 204 may represent tensor bound information for a tensor. For example, if the program defines two array variables V1 and V2, the tensor traversal unit may assign rows 204a and 204b to track the tensor bound information for array variables VI and V2, respectively.
[0041] The dimension multiplier elements 206 can be physically or logically arranged as a 2-D array having the same dimensions as the tensor index elements 202, where each element of the dimension multiplier elements 206 has a corresponding element in the tensor index elements 202. In some implementations, each row of the dimension multiplier elements 206 may represent dimension multiplier information for a tensor. For example, if the program defines two array variables VI and V2, the tensor traversal unit may assign rows 206a and 206b to track the dimension multiplier information for array variables VI and V2, respectively.
[0042] In some implementations, rather than use a multiplier to multiply a tensor index value against a dimension multiplier, alternative embodiments can include a TTU 106 that utilizes an adder function in lieu of the multiplier function. In these embodiments, processing unit 102 can execute program code to provide TTU 106 with already multiplied numbers (e.g., for the begin, end, and step values of a particular loop).
[0043] Deep Neural Networks (DNNs) include multiple layers that feed into each other. In some implementations, an example neural network can include one or more of the following layer types: a convolutional layer (e.g., depth-wise), a reduction layer, a fully connected (FC) layer, a classifier layer, an element-wise multiply layer, or a pooling layer (e.g., average & max). In some implementations, computations that have small (e.g., one or two) input and output depths can be associated with layers that have a shallow kernel property, which can be a property of an existing layer such as a fully connected layer or convolutional layer. In general, tensor computations that occur within system 100 for a first layer (e.g. a convolution layer) can produce output activations that are subsequently provided as input activations for a second layer (e.g., a pooling layer) that differs from the first layer.
[0044] In some implementations, two or more compute systems 100 can be configured as a set of compute tiles. In these implementations, each compute tile independently performs a portion of the computations required to process inference workloads for a given layer. Outputs of the computations are then moved to another tile that needs the outputs to perform follow-on computations for the given layer. Moreover, a neural network layer can be partitioned in a manner desired by a system designer and each partition can be mapped to a tile such that a portion of computations correspond to a particular layer partition.
[0045] Referring again to FIG. 1, in some implementations, system 100 receives, via instruction 103, at least one instruction that encodes multiple operations that are executed by system 100 to perform at least a portion of the tensor computations required for a given neural network layer. The instruction and encoded operations can specify the type of layer, the structure of the activation tensor, and the structure of the weight tensor. Moreover, encoded operations can cause processing unit 102 to execute program code to create a loop nest structure that is defined at least in part by the layer type of the neural network. Regarding encoded operations, instruction set 103 can include at least one of a tensor operation (tensorop) instruction or a direct memory access operation (DMAop) instruction. Instruction set 103 can also include one or more other instructions that encode a variety of miscellaneous operations such as syncing operations, barrier operations and fencing operations (described below).
[0046] FIG. 3 illustrates a table 300 that includes opcodes and corresponding operations performed, at least in part, by the system 100. Table 300 includes operations 302, operations 304, and operations 308. As shown by table 300, system 100 can execute multiple operations that are encoded by, for example, a single instruction provided by instruction set 103. In general, instruction set 103 can include a standardized structure that uses opcodes to define the types of operations that are to occur within system 100 for a particular compute sequence. A unique opcode can correspond to a particular operation type. In some implementations, encoded operations in the form of one or more instructions, input activations, and weights are provided to system 100 from an external input/output (I/O) device or higher level controller device associated with a neural network hardware computing system. One or more data buses can be used to pass instructions, activations, and weights from an example I/O device or between multiple compute tiles (e.g., multiple systems 100) of a hardware computing system.
[0047] As shown by table 300, operations 302 are encoded tensor operations that can include one or more tensorops with corresponding opcodes. In some implementations, a single instruction or instruction set can include multiple sub-instructions that define encodings in the form of opcodes that indicate a particular tensorop. For example, the subinstructions can be distributed to one or more compute tiles to cause the tiles to perform tensorops for computations that correspond to a particular neural network layer. For example, a tensorop sub-instruction can include opcodes for at least one of the above-mentioned layers: convolution, FC, pooling, reduction, or element-wise multiply. The tensorop sub-instruction can be configured such that all tensor computations that occur within a compute tile/system 100 have the needed encodings from the tensorop sub-instruction.
[0048] In general, tensor computations that occur within system 100 will have the needed encodings specified by instructions received from instruction set 103. When multiple systems 100 are arranged as a set of compute tiles, the tensorop sub-instructions and encodings can allow different compute tiles to execute different instructions. In some implementations, different sub-instructions can correspond to tensor computations for a certain partition of a neural network layer. The tensorop encoding further allows TTU 106 to emit the loop indices, to processing unit 102, via a main TTU loop nest field that indicates a desired TTU tensor operation. The tensorop encoding also enables a TTU 106 to generate the memory address for a particular array/tensor element based on a TTU loop mask that indicates which counters are added together to compute the address. The tensorop encoding can also provide multiple TTU loop nest instructions executable by processing unit 102 for traversing an input activation tensor, a weight tensor, and an output activation tensor.
[0049] In some implementations, when two or more compute systems 100 are configured as a set of compute tiles, each compute tile can be a self-contained unit which executes instructions independently. Generally, a compute tile executes instructions that define two types of operations: tensorops and DMAops. In some implementations, the different operations can be executed by independent control units within compute system 100 that synchronize on data through sync flag. However, although the control units are independent, there may be dependencies that need to be maintained, e.g., the tensorop must not execute a loop in the loop nest unless it has the data needed by the loop nest in, for example, a memory location of storage medium 104. The data required can be placed in storage medium 104 by a DMAop or another operation.
[0050] In general, data synchronization within system 100 occurs through sync flag operations. In some implementations, system 100 will have a register file that contains a sync flag entry per virtual write port. For example, a tensorop can have two or more tensor references that can be partial sums (written to second bank 114) and activations (written to first bank 112). In this implementation, there can be a sync flag register for each partial sum and activations. Moreover, during execution of a given instruction set, processing unit 102 can select a dimension of a tensor reference which will trigger an increment for a particular sync flag register. Furthermore, processing unit 102 can select the depth of a loop nest on which to wait for a required count on select sync flag registers. This ensures that the data dependencies are not violated. Moreover, one or more threads will stall if the required sync flag counts on selected sync flag registers are not yet reached.
[0051] For example, the tensorop encoding can allow for stalling of a loop nest based on one or more sync flag conditions. In some implementations, TTU 106 can be stalled due to the following conditions: 1) a predetermined sync flag condition is not met (e.g. sync flag counts not greater than a threshold count); or 2) there is a hazard detected in a particular stage of an instruction pipeline. Additionally, the tensorop encoding allows for configuring MAC operator 108 to receive a particular data value (e.g., activation or weight) of a desired bit width as well as allow for selection of a desired function to be performed by activation unit 110.
[0052] The sync flag conditions defined by the tensorop encoding can cause processing unit 102 of system 100 to execute at least one of a sync watcher operation and a sync producer operation. During execution of a tensorop by processing unit 102, the sync watcher operation can be used to indicate to processing unit 102 which loop iteration to sync on, the sync flag count required before a loop is permitted iterate, and how much to increment the expected sync flag count for the next iteration.
[0053] As shown by table 300, encoded direct memory access operations instructions can include one or more DMAops. DMA operations specified by instruction set 103 cause processing unit 102 to move data as required to accomplish performance of a particular tensorop by system 100. In some implementations, if data is moved between two memory resources of unequal widths (e.g., a wide memory unit and a narrow memory unit), the transfer size of the data must be a multiple of the wider resource. For example, given a DMAop that moves data to/from wide memory (W-mem), the size of the transfer must be a multiple of the wide memory width. Likewise, for a DMAop that moves data to/from narrow memory (N-mem), the size of the transfer of the data must be a multiple of the narrow memory width.
[0054] Wide and narrow designations used throughout the specification to describe attributes of a memory unit generally refer to an approximate size in width (bits/bytes) of one or more memory units. In some implementations, the memory width of first bank 112 and the memory width of second bank 114 are not defined by a specific number of bits such as, for example, 16-bit. In general, there are two different types of memories in each instantiation of system 100 and narrow/wide are relative terms used to indicate a characteristic of memory, which is not absolute. In some example implementations, first bank 112 includes one or more narrow memory units and second bank 114 includes one or more wide memory units.
[0055] As described above, instructions received by system 100 and executed by processing unit 102 can include the tensorop instruction and the DMAop instruction. The received instructions can be stored in instruction buffer 124 prior to execution by processing unit 102. As shown in table 300, operations 304 are DMA operations that can include instruction subtypes (e.g., indicating a ‘write-to’ buffer location) that include the following: 1) inbound instruction buffer; 2) outbound instruction buffer; 3) narrow-wide DMA instruction buffer; 4) wide-narrow DMA instruction buffer; and 5) ring bus DMA instruction buffer.
[0056] Referring now to table 300, execution of the DMAop.in operation by processing unit 102 causes system 100 to receive input activations and other data from instruction set 103 (via an example data bus) and to store the activations in first bank 112. As described in more detail below, the input activations are stored in first bank 112 at memory address locations that correspond to respective elements of an activation tensor. Execution of the DMAop.out operation by processing unit 102 causes system 100 to read data (e.g. output activations) from first bank 112 and write the data to an example data bus to output the data from system 100. Processing unit 102 can execute the DMAop.N-W operation to move data from first bank 112 (narrow memory) to second bank 114 (wide memory). Likewise, processing unit 102 can execute the DMAop.W-N operation to move data from second bank 114 (wide memory) to first bank 112 (narrow memory).
[0057] Processing unit 102 can execute the DMAop.R-bus operation to write data (e.g., weights/parameters) to second bank 114 after retrieving the data from instruction set 103 (via an example data bus). Execution of the DMAop.R-bus operation can also cause processing unit 102 to read/access data (e.g., weights) stored in memory address locations of second bank 114 and write the data to the example data bus such that the data can be output from system 100. In some implementations, the example data bus is a ring bus that connects multiple compute systems 100 in a ring structure. In addition to connecting the multiple systems 100 in a ring, the ring bus can also connect the multiple systems 100 to an external I/O device or higher level control device. Additional details and descriptions relating to hardware computing systems for accelerating neural network tensor computations including data bus options for connecting compute tiles are also described in U.S. Patent Application No. 15/335,769, entitled “Neural Network Compute Tile,” filed on October 27, 2016.
[0058] In some implementations, for a given set of compute tiles, at least one compute tile of the set of compute tiles can be a classifier tile. The classifier tile can be configured to apply a function to data values associated with tensor computations that have occurred for a particular layer of a neural network. For example, a FC layer can be partitioned across tiles, hence each tile produces a subset of outputs and stores the outputs in second bank 114. In general, a DMAop can be used to move, from a first compute tile and through the data ring bus, the linear outputs from memory address locations of second memory 114 to a second tile (e.g., classifier tile). The classifier tile will then apply at least one function (e.g., a softmax function) to each linear output and provide the post-function results to the higher level control device or the external FO device.
[0059] Referring again to table 300, in some implementations, DMAop.infeed and DMAop.outfeed correspond to operations associated with both an external controller device and system 100. In general, the DMAop.infeed operation initiates at the external controller and causes the controller to provide both input activations and weights to an example data bus (e.g., the ring bus). The data bus can be configured to multicast a data stream (e.g., a bitmap) that indicates which compute tile in a multi-tile arrangement should consume the activations and weights. Accordingly, processing unit 102 of a particular receiving tile can therefore execute a portion of the DMAop.infeed operation to move activations and weights/parameters into the memory banks of the compute tile (system 100) from the external controller. Likewise, in some implementations, processing unit 102 can then execute a portion of the DMAop.outfeed operation to move results (outputs) of an example inference workload from memory banks 112, 114 in the compute tile to the classifier tile and from the classifier tile to the external controller. Moreover, the external controller can also execute a portion of the DMAop.outfeed operation to move inference workload results to an example external I/O device.
[0060] Operations 306 are tilefenceop and scalarfenceop operations that can be executed by processing unit 102 to manage issuance of new instructions while other operations are being executed by system 100. Execution of the tilefenceop instruction by processing unit 102 causes system 100 to block or prevent any new instructions from being issued to system 100 until all pending instructions in the respective instruction buffers of system 100 are retired. Additionally, the scalarfenceop instruction cooperates with the tilefenceop instruction to preclude issuance of new instructions while pending instructions are executed by processing unit 102. For example, the tilefenceop instruction can cause processing unit 102 to monitor a sync flag count metric associated with the tilefenceop. Processing unit 102 can execute the scalarfenceop instruction to prevent issuance of new instructions until a threshold tilefenceop count metric is reached.
[0061] FIG. 4A illustrates an example input activation tensor 404, example weight tensors 406, and an example output tensor 408. FIG. 4B illustrates an example deep loop nest 402 that can be executed by processing unit 102 to perform tensor computations relating to dot product computations or matrix multiplication. In FIG. 4A, computations can include multiplication of activation tensor 404 with parameter/weight tensor 406 on one or more computation cycles to produce outputs/results in the form of output tensor 408.
[0062] Each tensor 404, 406, 408 can include multiple data elements that are arranged in a row-column format across the x, y, and z dimensional planes. Activations can be read from respective memory address locations of first bank 112 that correspond to elements of activation tensor 404. Likewise, weights can be read from second bank 114 in respective memory address locations that correspond to elements of a weight tensor. In some implementations, processing unit 102 can execute program code stored in certain memory units of storage medium 104 (e.g., ROM/EEPROM memory units) for a nested loop program to cause TTU 106 to access memory address locations that correspond to respective elements of activation tensor 404 and weight tensor 406. Processing unit 102 can perform one or more tensor computations by, in part, executing a loop nest program to instantiate a plurality of loops that traverse tensor elements for a given dimension.
[0063] As TTU 106 traverses activation tensor 404 and weight tensor 406 multiply operations including a single activation from an x-dimension data element in tensor 404 is individually multiplied with, for example, a row of weights (multiple data elements) in the kx-dimension of a particular weight tensor 406. These multiply operations can produce a row of outputs corresponding to a first x row in the zo dimension of output tensor 408. In general, MAC operator 108 can execute tensor computations that include arithmetic operations relating to dot product computations. Input activations are provided, from first bank 112, oneby-one for respective access by a single MAC operator 108. MAC operator 108 multiplies the input activation with a weight accessed from second bank 114 to produce a single output activation value corresponding to a respective data element of output tensor 408.
[0064] In FIG. 4B, an example deep loop nest 402 is shown and includes a MAC operation in the inner-most loop (zo). Input dimensions corresponding to activation tensor 404 are indicated as [x, y, zi], filter dimensions corresponding to weight tensor 406 are indicated as [x, y, zi, zo], and output dimensions corresponding to output tensor 408 are indicated as [x, y, zo]. Deep loop nest 402 therefore specifies an output tensor 408 indicated by output [x][y][zo] based on computations that span the various dimensions of tensors 404, 406. In general, deep loop nest 402 provides a software algorithm that can be executed by system 100 to perform tensor computations by processing a nested loop to traverse N-dimensional tensors. In one example computational process, each loop may be responsible for traversing particular dimensions of corresponding N-dimensional tensors. Deep loop nest 402 therefore provides an expression of the one or more tensor computations that can be performed simultaneously within multiple compute tiles.
[0065] In alternative implementations, there can be other orderings of deep loop nest 402 that produce variations of output tensor 408. System 100 can receive instructions for instantiating deep loop nest 402 that include a range of data values to allow for traversing activation tensor 404 and weight tensors 406 in any order. One or more loops can be spatially unrolled in system 100. In some implementations, the xx and yy loop nests can be unrolled across one or more compute tiles thereby allowing different compute tiles to process inference workloads associated with different layer partitions. In example deep loop nest 402 there can be an activation read every cycle and partial sum read every zi*kx*ky cycles.
[0066] The structure of the loop nest (e.g., # of inner and outer loops) can be defined based on one or more of the data values of instructions provided to system 100 via instructions set 103. Example computations that occur within a convolution layer can be used as a basis to describe an execution of an instruction that encodes operations to compute inference workloads for a given layer. Convolution layer computations can include two-dimensional (2D) spatial convolution of three-dimensional (3D) tensors. Computations for the convolution layer can involve performing a 2D spatial convolution between a 3D activation tensor 404 and at least one 3D filter (weight tensor 406).
[0067] For this computation there will be a sum of the dot products along the depth dimension. Convolving one 3D filter 406 over the 3D input produces a 2D spatial plane. As shown, there can be multiple 3D filters with which the 3D input tensor 404 needs to be convolved. Computations will result in 3D tensor output 408. Although computations for a convolution layer are described, one or more instructions that encode compute operations for other neural network layers can also be produced based on the teachings described in this specification.
[0068] In general, when a single compute tile includes multiple MAC operators 108, the operators collectively provide single instruction multiple data (SIMD) functionality by each sharing a single activation input to perform their respective computations. SIMD generally means that all parallel units (multiple MAC operators 108 in a single system 100) share the same instruction (based on the deep loop nest), but each MAC operator 108 executes the instruction on different data elements of tensor 404 and 406. In one basic example, adding the arrays [1,2,3,4] and [5,6,7,8] element-wise to obtain the array [6,8,10,12] in one cycle will typically require four arithmetic units to execute the operation on each element. By using SIMD, the four units can share the same instruction (e.g., “add”) and perform computations in parallel. A single instruction that encodes tensorops in the form a loop nest can be provided to one or more systems 100 to compute inference workloads associated with certain data elements of multi-dimensional tensors. Thus, system 100 provides enhanced acceleration and parallelism in tensor computations over prior methods.
[0069] Accelerator functions of system 100 correspond to at least two types of parallelism. The first type of parallelism is exposed through the spatial unrolling of the innermost loop of deep nest loop 402. Because system 100 includes SIMD functionality, the innermost loop bound of deep loop nest 402 can be fixed to the number of MAC operators 108 in a linear unit (e.g. cell of multiple MACs). The second aspect of parallelism is exposed by virtue of having configurations in which multiple compute tiles, each executing deep loop nest 402, but on different portions tensor computations for a particular neural network layer. There can be a configurable number of number of tiles in an accelerator device along with a configurable number of MAC operators within each tile.
[0070] In some implementations, a programmer or developer may choose to detail or construct a particular loop nest in order to, for example, reduce activation input bandwidth and increase the partial sum read bandwidth. This can be done by writing or constructing deep loop nest 402 in an alternative manner. Deep loop nests described in this specification for accelerating tensor computations are quite flexible and can be organized as desired to suit a particular problem set. The neural network and compute tile (system 100) described in this specification can support up to an eight deep loop nest computational structure, hence inputs and outputs can be tiled as desired by the developer, so as best to exploit locality and reduce overall bandwidth requirements.
[0071] FIG. 5 is a flow diagram that illustrates an example process 500 for performing tensor computations by using computing system 100 to execute one or more operations encoded by instructions. At block 502 processing unit 102 receives an instruction that specifies data values for performing tensor computations in system 100. At block 504, in response to receiving the instruction, processing unit 102 performs tensor computations by executing a loop nest that includes multiple loops. As discussed above, processing unit 102 can access instructions (distinct from instructions associated with instruction set 103) to execute program code for a nested loop program. Processing unit 102 can then execute the program code to cause TTU 106 to access memory address locations that correspond to respective elements of activation tensor 404 and weight tensor 406.
[0072] At block 506, for implementations where a loop nest has a defined structure based on a layer type, instruction set 103 can include specific data values (e.g., one or more opcodes) that indicate the layer type and loop nest structure for the layer. For example, as indicated by operations 302 of FIG. 3, instruction set 103 can include one or more opcodes that correspond to tensorops for tensor computations for a convolutional and FC layers (e.g., opcode 0). Thus, using data values associated with a tensorop instruction provided by instruction set 103, processing unit 102 can then define the loop nest structure based on data values of the instruction. Once the loop nest structure is defined, processing unit 102 performs one or more tensor computations by, in part, executing a loop nest program to instantiate loops that traverse tensor elements for a given dimension of activation tensor 404 and weight tensor 406.
[0073] At block 508, processing unit 102 causes individual output activations 116 to be written to respective data elements of output tensor 408. Additionally, at block 508 processing unit 102 can execute the DMAop.outfeed operation to cause the results of the tensor computations to be written to one or more other compute tiles for subsequent tensor computations. Alternatively, the DMAop.outfeed operation can move the results (outputs) of the inference workload from memory banks 112, 114 in a first compute tile to the classifier tile (e.g., second compute tile) and from the classifier tile to the external controller and to the external I/O device.
[0074] Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, in tangibly-embodied computer software or firmware, in computer hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions encoded on a tangible non transitory program carrier for execution by, or to control the operation of, data processing apparatus. Alternatively or in addition, the program instructions can be encoded on an artificially generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, which is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. The computer storage medium can be a machine-readable storage device, a machine-readable storage substrate, a random or serial access memory device, or a combination of one or more of them.
[0075] A computer program (which may also be referred to or described as a program, software, a software application, a module, a software module, a script, or code) can be written in any form of programming language, including compiled or interpreted languages, or declarative or procedural languages, and it can be deployed in any form, including as a stand alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data, e.g., one or more scripts stored in a markup language document, in a single file dedicated to the program in question, or in multiple coordinated files, e.g., files that store one or more modules, sub programs, or portions of code. A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
[0076] The processes and logic flows described in this specification can be performed by one or more programmable computers executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array), an ASIC (application specific integrated circuit), a GPGPU (General purpose graphics processing unit), or some other type of processor.
[0077] Computers suitable for the execution of a computer program include, by way of example, can be based on general or special purpose microprocessors or both, or any other kind of central processing unit. Generally, a central processing unit will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a central processing unit for performing or executing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device, e.g., a universal serial bus (USB) flash drive, to name just a few.
[0078] Computer readable media suitable for storing computer program instructions and data include all forms of non volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto optical disks; and CD ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
[0079] Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back end, middleware, or front end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), e.g., the Internet.
[0080] The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
[0081] Further implementations are summarized in the following examples:
[0082] Example 1: A computer-implemented method, comprising: receiving, by a processing unit, an instruction that specifies data values for performing a tensor computation; and in response to receiving the instruction, performing, by the processing unit, the tensor computation by executing a loop nest comprising a plurality of loops, wherein a structure of the loop nest is defined based on one or more of the data values of the instruction.
[0083] Example 2: The method of example 1, wherein the tensor computation is at least a portion of a computation of a neural network layer.
[0084] Example 3: The method of example 2, wherein the data values specified by the instruction comprises at least one value that specifies a type of the neural network layer, and wherein the structure of the loop nest is defined at least in part by the type of the neural network layer.
[0085] Example 4: The method of example 2 or 3, wherein the instruction causes the processing unit to access at least one element of a dimension of a tensor, the element being a part of at least one index used in executing the loop nest during performance of the tensor computation.
[0086] Example 5: The method of example 2 or 3, wherein the instruction causes the processing unit to access at least one memory address of an array in a storage medium, the memory address of the array comprising a variable that is read by the processing unit during performance of the tensor computation.
[0087] Example 6: The method of example 5, wherein performing the tensor computation comprises, providing, by the processing unit, at least one control signal to a tensor traversal unit (TTU) to cause the TTU to emit loop indices used in executing the loop nest during performance of the tensor computation.
[0088] Example 7: The method of example 5, further comprising, providing, by the processing unit, at least one control signal to the TTU to cause an array reference of the TTU to generate an address for a referenced array element used in executing the loop nest during performance of the tensor computation.
[0089] Example 8: The method of example 7, wherein the instruction indicates a first TTU counter that is summed with a second TTU counter to generate an address for an array reference associated with the TTU.
[0090] Example 9: The method of one of examples 1 to 8, wherein performing the tensor computation comprises, executing, by the processing unit, a first sync procedure that manages one or more operands associated with performance of the tensor computation, wherein managing an operand comprises stalling one or more loop nests based on a sync flag condition.
[0091] Example 10: The method of example 9, wherein performing the tensor computation comprises, executing, by the processing unit, a second sync procedure that manages incrementing a counter associated with a characteristic of the loop nest.
[0092] Example 11: An electronic system, comprising: a processing unit disposed in in the electronic system, the processing unit including one or more processing devices; and one or more machine-readable storage devices for storing instructions that are executable by the one or more processing devices to perform operations comprising: receiving, by the processing unit, an instruction that specifies data values for performing a tensor computation; and in response to receiving the instruction, performing, by the processing unit, the tensor computation by executing a loop nest comprising a plurality of loops, wherein a structure of the loop nest is defined based on one or more of the data values of the instruction.
[0093] Example 12: The electronic system of example 11, wherein the tensor computation is at least a portion of a computation of a neural network layer.
[0094] Example 13: The electronic system of example 12, wherein the data values specified by the instruction comprises at least one value that specifies a type of the neural network layer, and wherein the structure of the loop nest is defined at least in part by the type of the neural network layer.
[0095] Example 14: The electronic system of example 12 or 13, wherein the instruction causes the processing unit to access at least one element of a dimension of a tensor, the element being a part of at least one index used in executing the loop nest during performance of the tensor computation.
[0096] Example 15: The electronic system of example 12 or 13, wherein the instruction causes the processing unit to access at least one memory address of an array in a storage medium, the memory address of the array comprising a variable that is read by the processing unit during performance of the tensor computation.
[0097] Example 16: The electronic system of example 15, wherein performing the tensor computation comprises, providing, by the processing unit, at least one control signal to a tensor traversal unit (TTU) to cause the TTU to emit loop indices used in executing the loop nest during performance of the tensor computation.
[0098] Example 17: A non-transitory computer-readable storage medium comprising instructions executable by a processing unit which, upon such execution, causes the processing unit to perform operations comprising: receiving, by the processing unit, an instruction that specifies data values for performing a tensor computation; and in response to receiving the instruction, performing, by the processing unit, the tensor computation by executing a loop nest comprising a plurality of loops, wherein a structure of the loop nest is defined based on one or more of the data values of the instruction.
[0099] Example 18.The non-transitory computer-readable storage medium of example 17, wherein the tensor computation is at least a portion of a computation of a neural network layer.
[00100] Example 19: The non-transitory computer-readable storage medium of example 18, wherein the data values specified by the instruction comprises at least one value that specifies a type of the neural network layer, and wherein the structure of the loop nest is defined at least in part by the type of the neural network layer.
[00101] Example 20: The non-transitory computer-readable storage medium of example 18, wherein the instruction causes the processing unit to access at least one element of a dimension of a tensor, the element being a part of at least one index used in executing the loop nest during performance of the tensor computation.
[00102] While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any invention or of what may be claimed, but rather as descriptions of features that may be specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.
[00103] Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system modules and components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
[00104] Particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. For example, the actions recited in the claims can be performed in a different order and still achieve desirable results. As one example, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In certain implementations, multitasking and parallel processing may be advantageous.
Claims (20)
1. A computer-implemented method, comprising:
receiving, by a processing unit, an instruction that specifies data values for performing a tensor computation; and in response to receiving the instruction, performing, by the processing unit, the tensor computation by executing a loop nest comprising a plurality of loops, wherein a structure of the loop nest is defined based on one or more of the data values of the instruction.
2. The method of claim 1, wherein the tensor computation is at least a portion of a computation of a neural network layer.
3. The method of claim 2, wherein the data values specified by the instruction comprises at least one value that specifies a type of the neural network layer, and wherein the structure of the loop nest is defined at least in part by the type of the neural network layer.
4. The method of claim 2, wherein the instruction causes the processing unit to access at least one element of a dimension of a tensor, the element being a part of at least one index used in executing the loop nest during performance of the tensor computation.
5. The method of claim 2, wherein the instruction causes the processing unit to access at least one memory address of an array in a storage medium, the memory address of the array comprising a variable that is read by the processing unit during performance of the tensor computation.
6. The method of claim 5, wherein performing the tensor computation comprises, providing, by the processing unit, at least one control signal to a tensor traversal unit (TTU) to cause the TTU to emit loop indices used in executing the loop nest during performance of the tensor computation.
7. The method of claim 5, further comprising, providing, by the processing unit, at least one control signal to the TTU to cause an array reference of the TTU to generate an address for a referenced array element used in executing the loop nest during performance of the tensor computation.
8. The method of claim 7, wherein the instruction indicates a first TTU counter that is summed with a second TTU counter to generate an address for an array reference associated with the TTU.
9. The method of claim 1, wherein performing the tensor computation comprises, executing, by the processing unit, a first sync procedure that manages one or more operands associated with performance of the tensor computation, wherein managing an operand comprises stalling one or more loop nests based on a sync flag condition.
10. The method of claim 9, wherein performing the tensor computation comprises, executing, by the processing unit, a second sync procedure that manages incrementing a counter associated with a characteristic of the loop nest.
11. An electronic system, comprising:
a processing unit disposed in in the electronic system, the processing unit including one or more processing devices; and one or more machine-readable storage devices for storing instructions that are executable by the one or more processing devices to perform operations comprising:
receiving, by the processing unit, an instruction that specifies data values for performing a tensor computation; and in response to receiving the instruction, performing, by the processing unit, the tensor computation by executing a loop nest comprising a plurality of loops, wherein a structure of the loop nest is defined based on one or more of the data values of the instruction.
12. The electronic system of claim 11, wherein the tensor computation is at least a portion of a computation of a neural network layer.
13. The electronic system of claim 12, wherein the data values specified by the instruction comprises at least one value that specifies a type of the neural network layer, and wherein the structure of the loop nest is defined at least in part by the type of the neural network layer.
14. The electronic system of claim 12, wherein the instruction causes the processing unit to access at least one element of a dimension of a tensor, the element being a part of at least one index used in executing the loop nest during performance of the tensor computation.
15. The electronic system of claim 12, wherein the instruction causes the processing unit to access at least one memory address of an array in a storage medium, the memory address of the array comprising a variable that is read by the processing unit during performance of the tensor computation.
16. The electronic system of claim 15, wherein performing the tensor computation comprises, providing, by the processing unit, at least one control signal to a tensor traversal unit (TTU) to cause the TTU to emit loop indices used in executing the loop nest during performance of the tensor computation.
17. A non-transitory computer-readable storage medium comprising instructions executable by a processing unit which, upon such execution, causes the processing unit to perform operations comprising:
receiving, by the processing unit, an instruction that specifies data values for performing a tensor computation; and in response to receiving the instruction, performing, by the processing unit, the tensor computation by executing a loop nest comprising a plurality of loops, wherein a structure of the loop nest is defined based on one or more of the data values of the instruction.
18. The non-transitory computer-readable storage medium of claim 17, wherein the tensor computation is at least a portion of a computation of a neural network layer.
19. The non-transitory computer-readable storage medium of claim 18, wherein the data values specified by the instruction comprises at least one value that specifies a type of the neural network layer, and wherein the structure of the loop nest is defined at least in part by the type of the neural network layer.
20. The non-transitory computer-readable storage medium of claim 18, wherein the instruction causes the processing unit to access at least one element of a dimension of a tensor, the element being a part of at least one index used in executing the loop nest during performance of the tensor computation.
Intellectual
Property
Office
Application No: GB1715031.9 Examiner: Mr Thomas Davies
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US15/336,216 US9959498B1 (en) | 2016-10-27 | 2016-10-27 | Neural network instruction set architecture |
US15/455,685 US9836691B1 (en) | 2016-10-27 | 2017-03-10 | Neural network instruction set architecture |
Publications (2)
Publication Number | Publication Date |
---|---|
GB201715031D0 GB201715031D0 (en) | 2017-11-01 |
GB2558980A true GB2558980A (en) | 2018-07-25 |
Family
ID=60452227
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
GB1715031.9A Withdrawn GB2558980A (en) | 2016-10-27 | 2017-09-19 | Neural network instruction set architecture |
Country Status (10)
Country | Link |
---|---|
US (4) | US9959498B1 (en) |
EP (2) | EP4235509A3 (en) |
JP (2) | JP6921951B2 (en) |
KR (3) | KR102525080B1 (en) |
CN (1) | CN108009627A (en) |
DE (2) | DE102017120588A1 (en) |
GB (1) | GB2558980A (en) |
HK (1) | HK1254701A1 (en) |
SG (1) | SG11201903631XA (en) |
WO (1) | WO2018080628A1 (en) |
Families Citing this family (96)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US10175980B2 (en) | 2016-10-27 | 2019-01-08 | Google Llc | Neural network compute tile |
US9959498B1 (en) | 2016-10-27 | 2018-05-01 | Google Llc | Neural network instruction set architecture |
US10360163B2 (en) | 2016-10-27 | 2019-07-23 | Google Llc | Exploiting input data sparsity in neural network compute units |
US20190392297A1 (en) * | 2016-12-30 | 2019-12-26 | Intel Corporation | Deep learning hardware |
US10365987B2 (en) | 2017-03-29 | 2019-07-30 | Google Llc | Synchronous hardware event collection |
US9875167B1 (en) | 2017-03-29 | 2018-01-23 | Google Inc. | Distributed hardware tracing |
US10795836B2 (en) * | 2017-04-17 | 2020-10-06 | Microsoft Technology Licensing, Llc | Data processing performance enhancement for neural networks using a virtualized data iterator |
US10684955B2 (en) | 2017-04-21 | 2020-06-16 | Micron Technology, Inc. | Memory devices and methods which may facilitate tensor memory access with memory maps based on memory operations |
US11113051B2 (en) * | 2017-04-28 | 2021-09-07 | Tenstorrent Inc. | Processing core with metadata actuated conditional graph execution |
US10817293B2 (en) * | 2017-04-28 | 2020-10-27 | Tenstorrent Inc. | Processing core with metadata actuated conditional graph execution |
US11138494B2 (en) * | 2017-05-02 | 2021-10-05 | International Business Machines Corporation | Storage controller acceleration for neural network training and inference |
US10565285B2 (en) * | 2017-12-18 | 2020-02-18 | International Business Machines Corporation | Processor and memory transparent convolutional lowering and auto zero padding for deep neural network implementations |
US10747631B2 (en) * | 2018-01-19 | 2020-08-18 | DinoplusAI Holdings Limited | Mission-critical AI processor with record and replay support |
US10445638B1 (en) * | 2018-02-28 | 2019-10-15 | Amazon Technologies, Inc. | Restructuring a multi-dimensional array |
US20190318229A1 (en) * | 2018-04-12 | 2019-10-17 | Advanced Micro Devices, Inc. | Method and system for hardware mapping inference pipelines |
US11568227B1 (en) | 2018-04-20 | 2023-01-31 | Perceive Corporation | Neural network inference circuit read controller with multiple operational modes |
US11783167B1 (en) | 2018-04-20 | 2023-10-10 | Perceive Corporation | Data transfer for non-dot product computations on neural network inference circuit |
US11481612B1 (en) | 2018-04-20 | 2022-10-25 | Perceive Corporation | Storage of input values across multiple cores of neural network inference circuit |
US11501138B1 (en) | 2018-04-20 | 2022-11-15 | Perceive Corporation | Control circuits for neural network inference circuit |
US11049013B1 (en) * | 2018-04-20 | 2021-06-29 | Perceive Corporation | Encoding of weight values stored on neural network inference circuit |
US11210586B1 (en) | 2018-04-20 | 2021-12-28 | Perceive Corporation | Weight value decoder of neural network inference circuit |
US11586910B1 (en) | 2018-04-20 | 2023-02-21 | Perceive Corporation | Write cache for neural network inference circuit |
US11222257B1 (en) | 2018-04-20 | 2022-01-11 | Perceive Corporation | Non-dot product computations on neural network inference circuit |
US20190332925A1 (en) * | 2018-04-30 | 2019-10-31 | International Business Machines Corporation | Neural hardware accelerator for parallel and distributed tensor computations |
EP3769266A4 (en) * | 2018-05-08 | 2021-12-15 | Tartan Ai Ltd. | Neural network processing element |
US10887182B1 (en) * | 2018-05-10 | 2021-01-05 | Hrl Laboratories, Llc | System and method for pairwise network alignment |
CN110490295B (en) * | 2018-05-15 | 2022-04-05 | 华为技术有限公司 | Data processing method and processing device |
US11443176B2 (en) * | 2018-05-17 | 2022-09-13 | International Business Machines Corporation | Acceleration of convolutional neural networks on analog arrays |
US11449363B2 (en) * | 2018-05-31 | 2022-09-20 | Neuralmagic Inc. | Systems and methods for improved neural network execution |
US20190392287A1 (en) | 2018-06-22 | 2019-12-26 | Samsung Electronics Co., Ltd. | Neural processor |
US11205125B2 (en) | 2018-06-29 | 2021-12-21 | International Business Machines Corporation | Scheduler and simulator for an area-efficient, reconfigurable, energy-efficient, speed-efficient neural network |
US20200019836A1 (en) * | 2018-07-12 | 2020-01-16 | International Business Machines Corporation | Hierarchical parallelism in a network of distributed neural network cores |
US10956315B2 (en) * | 2018-07-24 | 2021-03-23 | Micron Technology, Inc. | Memory devices and methods which may facilitate tensor memory access |
US10796225B2 (en) * | 2018-08-03 | 2020-10-06 | Google Llc | Distributing tensor computations across computing devices |
US20210295174A1 (en) * | 2018-08-09 | 2021-09-23 | Board Of Trustees Of Michigan State University | Systems and methods for providing flexible, multi-capacity models for use of deep neural networks in mobile devices |
CN110825530B (en) * | 2018-08-10 | 2022-12-23 | 昆仑芯(北京)科技有限公司 | Instruction execution method and device for artificial intelligence chip |
CN112732601A (en) * | 2018-08-28 | 2021-04-30 | 中科寒武纪科技股份有限公司 | Data preprocessing method and device, computer equipment and storage medium |
US11586417B2 (en) * | 2018-09-28 | 2023-02-21 | Qualcomm Incorporated | Exploiting activation sparsity in deep neural networks |
CN112740174B (en) * | 2018-10-17 | 2024-02-06 | 北京比特大陆科技有限公司 | Data processing method, device, electronic equipment and computer readable storage medium |
KR102637733B1 (en) | 2018-10-31 | 2024-02-19 | 삼성전자주식회사 | Neural network processor and convolution operation method thereof |
US11263011B2 (en) | 2018-11-28 | 2022-03-01 | International Business Machines Corporation | Compound instruction set architecture for a neural inference chip |
US11537853B1 (en) | 2018-11-28 | 2022-12-27 | Amazon Technologies, Inc. | Decompression and compression of neural network data using different compression schemes |
US11604973B1 (en) | 2018-12-05 | 2023-03-14 | Perceive Corporation | Replication of neural network layers |
CN111291240B (en) * | 2018-12-06 | 2023-12-08 | 华为技术有限公司 | Method for processing data and data processing device |
CN110033091B (en) | 2018-12-13 | 2020-09-01 | 阿里巴巴集团控股有限公司 | Model-based prediction method and device |
US20200202198A1 (en) * | 2018-12-21 | 2020-06-25 | Waymo Llc | Neural network processor |
CN109670158B (en) * | 2018-12-27 | 2023-09-29 | 北京及客科技有限公司 | Method and device for generating text content according to information data |
US20200234129A1 (en) * | 2019-01-22 | 2020-07-23 | Nvidia Corporation | Techniques for removing masks from pruned neural networks |
US11347297B1 (en) | 2019-01-23 | 2022-05-31 | Perceive Corporation | Neural network inference circuit employing dynamic memory sleep |
US11961007B2 (en) * | 2019-02-06 | 2024-04-16 | Qualcomm Incorporated | Split network acceleration architecture |
CN109902819B (en) * | 2019-02-12 | 2023-04-18 | Oppo广东移动通信有限公司 | Neural network computing method, device, mobile terminal and storage medium |
CN111563587B (en) * | 2019-02-14 | 2022-12-09 | 上海寒武纪信息科技有限公司 | Splitting method of neural network model and related product |
US11748599B2 (en) * | 2019-02-21 | 2023-09-05 | Texas Instruments Incorporated | Super-tiling in neural network processing to enable analytics at lower memory speed |
EP3716154A1 (en) * | 2019-03-27 | 2020-09-30 | GrAl Matter Labs S.A.S. | Neuromorphic processing system and method of operating the same |
CN112347186B (en) * | 2019-08-09 | 2023-02-28 | 安徽寒武纪信息科技有限公司 | Data synchronization method and device and related product |
CN111831337B (en) * | 2019-04-19 | 2022-11-29 | 安徽寒武纪信息科技有限公司 | Data synchronization method and device and related product |
CN110033085B (en) * | 2019-04-15 | 2021-08-31 | 广州异构智能科技有限公司 | Tensor processor |
CN110059805B (en) * | 2019-04-15 | 2021-08-31 | 广州异构智能科技有限公司 | Method for a binary array tensor processor |
CN110033086B (en) * | 2019-04-15 | 2022-03-22 | 广州异构智能科技有限公司 | Hardware accelerator for neural network convolution operations |
CN110046705B (en) * | 2019-04-15 | 2022-03-22 | 广州异构智能科技有限公司 | Apparatus for convolutional neural network |
US11671111B2 (en) | 2019-04-17 | 2023-06-06 | Samsung Electronics Co., Ltd. | Hardware channel-parallel data compression/decompression |
US11880760B2 (en) | 2019-05-01 | 2024-01-23 | Samsung Electronics Co., Ltd. | Mixed-precision NPU tile with depth-wise convolution |
CN110147253B (en) * | 2019-05-16 | 2020-10-20 | 湖南毂梁微电子有限公司 | Multi-core processor synchronization method based on delay fence synchronization operation instruction |
CN112395002B (en) * | 2019-08-14 | 2023-04-18 | 上海寒武纪信息科技有限公司 | Operation method, device, computer equipment and storage medium |
US11625585B1 (en) | 2019-05-21 | 2023-04-11 | Perceive Corporation | Compiler for optimizing filter sparsity for neural network implementation configuration |
KR102351087B1 (en) * | 2019-06-04 | 2022-01-14 | 주식회사 딥엑스 | Data management device supporting high speed artificial neural network operation with caching data based on data locality of artificial neural networks |
KR102192325B1 (en) * | 2019-06-04 | 2020-12-28 | (주)딥엑스 | Data management device supporting high speed artificial neural network operation with caching data based on data locality of artificial neural networks |
US11354564B2 (en) * | 2019-06-27 | 2022-06-07 | Intel Corporation | Tuning of loop orders in blocked dense basic linear algebra subroutines |
US20210064987A1 (en) * | 2019-09-03 | 2021-03-04 | Nvidia Corporation | Processor and system to convert tensor operations in machine learning |
US20210081841A1 (en) * | 2019-09-12 | 2021-03-18 | Viani Systems, Inc. | Visually creating and monitoring machine learning models |
US20210103803A1 (en) * | 2019-10-08 | 2021-04-08 | Apple Inc. | Multi-Mode Planar Engine For Neural Processor |
US20210110243A1 (en) * | 2019-10-10 | 2021-04-15 | Hewlett Packard Enterprise Development Lp | Deep learning accelerator system interface |
JP7462140B2 (en) | 2019-10-29 | 2024-04-05 | 国立大学法人 熊本大学 | Neural network circuit and neural network operation method |
KR20210093127A (en) * | 2020-01-17 | 2021-07-27 | 에스케이하이닉스 주식회사 | AIM device |
US11314674B2 (en) | 2020-02-14 | 2022-04-26 | Google Llc | Direct memory access architecture with multi-level multi-striding |
CN113391842A (en) * | 2020-03-13 | 2021-09-14 | 华为技术有限公司 | Single instruction multiple data SIMD instruction generation and processing method and related equipment |
US11568249B2 (en) | 2020-04-07 | 2023-01-31 | International Business Machines Corporation | Automated decision making for neural architecture search |
CN111506520B (en) | 2020-07-01 | 2020-09-22 | 腾讯科技（深圳）有限公司 | Address generation method, related device and storage medium |
US11954580B2 (en) | 2020-09-16 | 2024-04-09 | Meta Platforms, Inc. | Spatial tiling of compute arrays with shared control |
US20220092408A1 (en) * | 2020-09-23 | 2022-03-24 | Facebook, Inc. | Neural network weight distribution using a tree direct-memory access (dma) bus |
US11526965B2 (en) * | 2020-09-28 | 2022-12-13 | Robert Bosch Gmbh | Multiplicative filter network |
CN114444675A (en) * | 2020-10-30 | 2022-05-06 | 北京晶视智能科技有限公司 | Hardware accelerator |
WO2022092416A1 (en) * | 2020-11-02 | 2022-05-05 | 주식회사 딥엑스 | Artificial neural network memory system based on artificial neural network data locality |
US11704562B1 (en) | 2020-11-04 | 2023-07-18 | Meta Platforms, Inc. | Architecture for virtual instructions |
US11709783B1 (en) | 2020-11-11 | 2023-07-25 | Meta Platforms, Inc. | Tensor data distribution using grid direct-memory access (DMA) controller |
US11972349B1 (en) | 2020-11-12 | 2024-04-30 | Meta Platforms, Inc. | Flexible compute array utilization in a tensor processor |
US11922306B2 (en) | 2020-12-28 | 2024-03-05 | Meta Platforms, Inc. | Tensor controller architecture |
US11790611B2 (en) | 2020-12-30 | 2023-10-17 | Meta Platforms, Inc. | Visual editor for designing augmented-reality effects that utilize voice recognition |
TWI792665B (en) * | 2021-01-21 | 2023-02-11 | 創惟科技股份有限公司 | Ai algorithm operation accelerator and method thereof, computing system and non-transitory computer readable media |
US11675592B2 (en) | 2021-06-17 | 2023-06-13 | International Business Machines Corporation | Instruction to query for model-dependent information |
US11797270B2 (en) | 2021-06-17 | 2023-10-24 | International Business Machines Corporation | Single function to perform multiple operations with distinct operation parameter validation |
US11693692B2 (en) | 2021-06-17 | 2023-07-04 | International Business Machines Corporation | Program event recording storage alteration processing for a neural network accelerator instruction |
US11669331B2 (en) | 2021-06-17 | 2023-06-06 | International Business Machines Corporation | Neural network processing assist instruction |
US11269632B1 (en) | 2021-06-17 | 2022-03-08 | International Business Machines Corporation | Data conversion to/from selected data type with implied rounding mode |
US11734013B2 (en) | 2021-06-17 | 2023-08-22 | International Business Machines Corporation | Exception summary for invalid values detected during instruction execution |
US11915001B1 (en) * | 2022-12-26 | 2024-02-27 | Rebellions Inc. | Neural processor and method for fetching instructions thereof |
Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US9710265B1 (en) * | 2016-10-27 | 2017-07-18 | Google Inc. | Neural network compute tile |
EP3226121A2 (en) * | 2016-02-03 | 2017-10-04 | Google, Inc. | Accessing data in multi-dimensional tensors |
WO2017196693A1 (en) * | 2016-05-07 | 2017-11-16 | 1026 Labs, Inc. | An apparatus for hardware accelerated machine learning |
Family Cites Families (49)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
JPS4874139A (en) | 1971-12-29 | 1973-10-05 | ||
JPS5364439A (en) | 1976-11-20 | 1978-06-08 | Agency Of Ind Science & Technol | Linear coversion system |
JPS58134357A (en) * | 1982-02-03 | 1983-08-10 | Hitachi Ltd | Array processor |
US5138695A (en) * | 1989-10-10 | 1992-08-11 | Hnc, Inc. | Systolic array image processing system |
US5325464A (en) * | 1990-05-22 | 1994-06-28 | International Business Machines Corporation | Pyramid learning architecture neurocomputer |
WO1991019267A1 (en) | 1990-06-06 | 1991-12-12 | Hughes Aircraft Company | Neural network processor |
AU658066B2 (en) | 1992-09-10 | 1995-03-30 | Deere & Company | Neural network based control system |
US6243734B1 (en) | 1998-10-30 | 2001-06-05 | Intel Corporation | Computer product and method for sparse matrices |
JP2001117900A (en) | 1999-10-19 | 2001-04-27 | Fuji Xerox Co Ltd | Neural network arithmetic device |
US20020044695A1 (en) | 2000-05-05 | 2002-04-18 | Bostrom Alistair K. | Method for wavelet-based compression of video images |
JP2003244190A (en) | 2002-02-19 | 2003-08-29 | Matsushita Electric Ind Co Ltd | Processor for data flow control switch and data flow control switch |
US7016529B2 (en) | 2002-03-15 | 2006-03-21 | Microsoft Corporation | System and method facilitating pattern recognition |
US7493498B1 (en) | 2002-03-27 | 2009-02-17 | Advanced Micro Devices, Inc. | Input/output permission bitmaps for compartmentalized security |
US7426501B2 (en) | 2003-07-18 | 2008-09-16 | Knowntech, Llc | Nanotechnology neural network methods and systems |
US7818729B1 (en) | 2003-09-15 | 2010-10-19 | Thomas Plum | Automated safe secure techniques for eliminating undefined behavior in computer software |
JP2007518199A (en) * | 2004-01-13 | 2007-07-05 | ニューヨーク・ユニバーシティ | Method, system, storage medium, and data structure for image recognition using multiple linear independent element analysis |
CN101441441B (en) | 2007-11-21 | 2010-06-30 | 新乡市起重机厂有限公司 | Design method of intelligent swing-proof control system of crane |
JP4513865B2 (en) | 2008-01-25 | 2010-07-28 | セイコーエプソン株式会社 | Parallel computing device and parallel computing method |
CN102037652A (en) * | 2008-05-21 | 2011-04-27 | Nxp股份有限公司 | A data handling system comprising memory banks and data rearrangement |
US8321652B2 (en) | 2008-08-01 | 2012-11-27 | Infineon Technologies Ag | Process and method for logical-to-physical address mapping using a volatile memory device in solid state disks |
EP2290563B1 (en) | 2009-08-28 | 2017-12-13 | Accenture Global Services Limited | Accessing content in a network |
US8595467B2 (en) | 2009-12-29 | 2013-11-26 | International Business Machines Corporation | Floating point collect and operate |
US8457767B2 (en) | 2010-12-31 | 2013-06-04 | Brad Radl | System and method for real-time industrial process modeling |
US8977629B2 (en) | 2011-05-24 | 2015-03-10 | Ebay Inc. | Image-based popularity prediction |
US8812414B2 (en) | 2011-05-31 | 2014-08-19 | International Business Machines Corporation | Low-power event-driven neural computing architecture in neural networks |
US8909576B2 (en) | 2011-09-16 | 2014-12-09 | International Business Machines Corporation | Neuromorphic event-driven neural computing architecture in a scalable neural network |
US9165243B2 (en) * | 2012-02-15 | 2015-10-20 | Microsoft Technology Licensing, Llc | Tensor deep stacked neural network |
US9292787B2 (en) * | 2012-08-29 | 2016-03-22 | Microsoft Technology Licensing, Llc | Computer-implemented deep tensor neural network |
US9201828B2 (en) | 2012-10-23 | 2015-12-01 | Analog Devices, Inc. | Memory interconnect network architecture for vector processor |
US9921832B2 (en) | 2012-12-28 | 2018-03-20 | Intel Corporation | Instruction to reduce elements in a vector register with strided access pattern |
CN104463209B (en) | 2014-12-08 | 2017-05-24 | 福建坤华仪自动化仪器仪表有限公司 | Method for recognizing digital code on PCB based on BP neural network |
US10013652B2 (en) | 2015-04-29 | 2018-07-03 | Nuance Communications, Inc. | Fast deep neural network feature transformation via optimized memory bandwidth utilization |
US10489703B2 (en) | 2015-05-20 | 2019-11-26 | Nec Corporation | Memory efficiency for convolutional neural networks operating on graphics processing units |
US20160358069A1 (en) * | 2015-06-03 | 2016-12-08 | Samsung Electronics Co., Ltd. | Neural network suppression |
US10671564B2 (en) * | 2015-10-08 | 2020-06-02 | Via Alliance Semiconductor Co., Ltd. | Neural network unit that performs convolutions using collective shift register among array of neural processing units |
US10380479B2 (en) * | 2015-10-08 | 2019-08-13 | International Business Machines Corporation | Acceleration of convolutional neural network training using stochastic perforation |
JP6750203B2 (en) * | 2015-10-20 | 2020-09-02 | 富士通株式会社 | Calculation method and calculation program for convolutional neural network, information processing apparatus |
US9904874B2 (en) * | 2015-11-05 | 2018-02-27 | Microsoft Technology Licensing, Llc | Hardware-efficient deep convolutional neural networks |
US10552119B2 (en) * | 2016-04-29 | 2020-02-04 | Intel Corporation | Dynamic management of numerical representation in a distributed matrix processor architecture |
CN106023065B (en) * | 2016-05-13 | 2019-02-19 | 中国矿业大学 | A kind of tensor type high spectrum image spectral-spatial dimension reduction method based on depth convolutional neural networks |
CN106127297B (en) * | 2016-06-02 | 2019-07-12 | 中国科学院自动化研究所 | The acceleration of depth convolutional neural networks based on tensor resolution and compression method |
US10360163B2 (en) | 2016-10-27 | 2019-07-23 | Google Llc | Exploiting input data sparsity in neural network compute units |
US9959498B1 (en) | 2016-10-27 | 2018-05-01 | Google Llc | Neural network instruction set architecture |
US10733505B2 (en) | 2016-11-10 | 2020-08-04 | Google Llc | Performing kernel striding in hardware |
CN106529511B (en) * | 2016-12-13 | 2019-12-10 | 北京旷视科技有限公司 | image structuring method and device |
US10037490B2 (en) | 2016-12-13 | 2018-07-31 | Google Llc | Performing average pooling in hardware |
US20180189675A1 (en) | 2016-12-31 | 2018-07-05 | Intel Corporation | Hardware accelerator architecture and template for web-scale k-means clustering |
US11164071B2 (en) | 2017-04-18 | 2021-11-02 | Samsung Electronics Co., Ltd. | Method and apparatus for reducing computational complexity of convolutional neural networks |
US10572409B1 (en) | 2018-05-10 | 2020-02-25 | Xilinx, Inc. | Sparse matrix processing circuitry |
-
2016
- 2016-10-27 US US15/336,216 patent/US9959498B1/en active Active
-
2017
- 2017-03-10 US US15/455,685 patent/US9836691B1/en active Active
- 2017-08-29 EP EP23161136.9A patent/EP4235509A3/en active Pending
- 2017-08-29 KR KR1020227011447A patent/KR102525080B1/en active IP Right Grant
- 2017-08-29 SG SG11201903631XA patent/SG11201903631XA/en unknown
- 2017-08-29 EP EP17765517.2A patent/EP3532996A1/en not_active Ceased
- 2017-08-29 KR KR1020237013355A patent/KR20230058539A/en not_active Application Discontinuation
- 2017-08-29 KR KR1020197014904A patent/KR102385349B1/en active IP Right Grant
- 2017-08-29 WO PCT/US2017/049165 patent/WO2018080628A1/en unknown
- 2017-08-29 JP JP2019522877A patent/JP6921951B2/en active Active
- 2017-09-07 DE DE102017120588.8A patent/DE102017120588A1/en active Pending
- 2017-09-07 DE DE202017105403.9U patent/DE202017105403U1/en active Active
- 2017-09-19 GB GB1715031.9A patent/GB2558980A/en not_active Withdrawn
- 2017-09-29 CN CN201710909908.8A patent/CN108009627A/en active Pending
- 2017-11-22 US US15/820,704 patent/US11379707B2/en active Active
-
2018
- 2018-10-25 HK HK18113686.2A patent/HK1254701A1/en unknown
-
2021
- 2021-07-28 JP JP2021123193A patent/JP7158543B2/en active Active
-
2022
- 2022-06-21 US US17/845,291 patent/US20220318594A1/en active Pending
Patent Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
EP3226121A2 (en) * | 2016-02-03 | 2017-10-04 | Google, Inc. | Accessing data in multi-dimensional tensors |
WO2017196693A1 (en) * | 2016-05-07 | 2017-11-16 | 1026 Labs, Inc. | An apparatus for hardware accelerated machine learning |
US9710265B1 (en) * | 2016-10-27 | 2017-07-18 | Google Inc. | Neural network compute tile |
Non-Patent Citations (2)
Title |
---|
JINDAL et al., International Journal of Parallel Programming Vol 44 Issue 2, published online 20 August 2014, Springer, pp309-324, "Exploiting GPUs with the Super Instruction Architecture" * |
LIU et al., 2016 ACM/IEEE 43rd Annual International Symposium on Computer Architecture, published online 25 August 2016, IEEE, pp 393-405, "Cambricon: An Instruction Set Architecture for Neural Networks" * |
Also Published As
Publication number | Publication date |
---|---|
US11379707B2 (en) | 2022-07-05 |
US9836691B1 (en) | 2017-12-05 |
SG11201903631XA (en) | 2019-05-30 |
KR20190068616A (en) | 2019-06-18 |
JP2019533868A (en) | 2019-11-21 |
JP2022188245A (en) | 2022-12-20 |
US20180197068A1 (en) | 2018-07-12 |
KR102385349B1 (en) | 2022-04-11 |
CN108009627A (en) | 2018-05-08 |
KR20230058539A (en) | 2023-05-03 |
US9959498B1 (en) | 2018-05-01 |
GB201715031D0 (en) | 2017-11-01 |
HK1254701A1 (en) | 2019-07-26 |
EP4235509A2 (en) | 2023-08-30 |
DE202017105403U1 (en) | 2017-12-06 |
DE102017120588A1 (en) | 2018-05-03 |
US20220318594A1 (en) | 2022-10-06 |
EP3532996A1 (en) | 2019-09-04 |
KR20220048043A (en) | 2022-04-19 |
JP2021184276A (en) | 2021-12-02 |
JP7158543B2 (en) | 2022-10-21 |
JP6921951B2 (en) | 2021-08-18 |
US20180121786A1 (en) | 2018-05-03 |
KR102525080B1 (en) | 2023-04-24 |
EP4235509A3 (en) | 2023-09-20 |
WO2018080628A1 (en) | 2018-05-03 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US20220318594A1 (en) | Neural network instruction set architecture | |
US20170097884A1 (en) | Pipelined convolutional operations for processing clusters | |
GB2555936A (en) | Neural network compute tile | |
US9047674B2 (en) | Structured grids and graph traversal for image processing | |
US20120159124A1 (en) | Method and system for computational acceleration of seismic data processing | |
US20210326683A1 (en) | Hardware circuit for accelerating neural network computations | |
Schellmann et al. | Parallel medical image reconstruction: from graphics processing units (GPU) to grids | |
EP3857384B1 (en) | Processing sequential inputs using neural network accelerators | |
Vater et al. | Simple and efficient GPU parallelization of existing H-Matrix accelerated BEM code | |
US20200250842A1 (en) | Method and apparatus with convolution neural network processing | |
JP7485740B2 (en) | Neural Network Instruction Set Architecture | |
US20220180187A1 (en) | Method and apparatus for performing deep learning operations | |
CN115129464A (en) | Stochastic sparsity handling in systolic arrays | |
Zou et al. | Supernodal sparse Cholesky factorization on graphics processing units | |
Krishnamurthy et al. | Parallel MATLAB Techniques | |
US20230333825A1 (en) | Control of storage aliasing via automatic application of artificial dependences during program compilation | |
US20230195836A1 (en) | One-dimensional computational unit for an integrated circuit | |
Krishnamurthy et al. | Parallel MATLAB Techniques | |
GB2556413A (en) | Exploiting input data sparsity in neural network compute units | |
US20230297643A1 (en) | Non-rectangular matrix computations and data pattern processing using tensor cores | |
Dolwithayakul et al. | Utilising the pipeline framework and state-based non-linear Gauss-Seidel for large satellite image denoising based on CPU-GPU cores | |
CN115526763A (en) | Reducing systolic array power consumption using sparsity metadata | |
Cavanagh | Real Time Depth Map Estimation on Cell |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
WAP | Application withdrawn, taken to be withdrawn or refused ** after publication under section 16(1) |