EP2981891B1 - A framework for user-directed profile-driven optimizations - Google Patents
A framework for user-directed profile-driven optimizations Download PDFInfo
- Publication number
- EP2981891B1 EP2981891B1 EP14724894.2A EP14724894A EP2981891B1 EP 2981891 B1 EP2981891 B1 EP 2981891B1 EP 14724894 A EP14724894 A EP 14724894A EP 2981891 B1 EP2981891 B1 EP 2981891B1
- Authority
- EP
- European Patent Office
- Prior art keywords
- profile
- value
- counter
- parameter
- user
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/40—Transformation of program code
- G06F8/41—Compilation
- G06F8/44—Encoding
- G06F8/443—Optimisation
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/40—Transformation of program code
- G06F8/41—Compilation
- G06F8/44—Encoding
- G06F8/443—Optimisation
- G06F8/4434—Reducing the memory space required by the program code
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/40—Transformation of program code
- G06F8/41—Compilation
- G06F8/44—Encoding
- G06F8/443—Optimisation
- G06F8/4441—Reducing the execution time required by the program code
Definitions
- FDO Feedback-directed optimization
- PGO Profile Guided Optimization
- PBO Profile Based Optimization
- Profiling is the process of gathering information about how an application behaves during runtime. This profile information is used to drive decisions regarding various application optimizations.
- customary feedback-directed optimization is a dual build model technique that uses static instrumentation to collect edge and value profiles.
- An instrumentation build (101) allows the compiler to insert code into an application's binary to create an instrumented version of the binary (102). This inserted code typically counts edges or collects value profiles.
- the instrumented binary (102) is run on a representative set of training data (104) in a training run (103). At the end of the training execution, all collected edge counts and value information is written and aggregated in a profile database or gcov data file (GCDA)(105).
- GCDA profile database or gcov data file
- An optimization build (106) then occurs in which the compiler uses the generated profile to make optimization decisions such as inline decisions, instruction scheduling, basic block re-ordering, function splitting, and register allocation.
- Customary feedback-directed optimization can therefore only handle a very limited set of low level profiles, such as control flow edge profiling or a predefined set of value profiles including indirect function call targets, string function call size, and alignment profiles.
- the present invention relates to a method according to claim 1.
- This specification describes technologies relating to application performance improvement in general, and specifically to methods and systems for automatically tuning performance parameters based on application runtime behavior.
- one aspect of the subject matter described in this specification can be embodied in a method for using profiling to obtain application-specific, preferred parameter values for an application.
- the method may include receiving identification of a parameter for which to obtain an application-specific value; receiving augmented code for profiling the parameter; profiling the parameter and collecting profile data; analyzing the profile data; and determining the application's preferred parameter value for the profiled parameter based on the analyzed profile data.
- a second aspect of the subject matter can be embodied in a method for user-directed per-class global value profiling which may include: receiving a user-defined profile instrumentation initialization routine; within the profile initialization routine, initializing a counter and registering a user-defined analysis call back routine; running a profile update function in a code location where the counter's value should be updated; and executing a profile handler method to process counter data and record the counter value.
- a third aspect of the subject matter described in this specification can be embodied in a method of user-directed per-site value profiling or user-directed per-site object value profiling which may include: allocating space in a compiler's static counter array for a counter; running a user-directed value profile instrumentation support interface to execute instructions on which counter type to user and the value to be profiled; and running a user-directed value profile transformation support interface to perform a specific value profile transformation on the parameter during an optimization build.
- a framework can facilitate user-directed profile-driven optimizations by allowing a software developer to profile selected parts of an application and direct a compiler to perform value profile transformations based on the profiling results as shown in FIG. 2 .
- User-defined information may be included in both the instrumentation and the optimization compilations of a feedback loop.
- An example method for obtaining application-specific, preferred parameter values for an application using profiling begins with identifying a parameter for which to obtain an application-specific value (301) as shown in FIG. 3 .
- the code to be augmented may be the application code.
- the code to be augmented may be a library which is used by the application code.
- the parameter is then profiled specifically for the application (303).
- Profiling may include two steps: (a)an instrumentation build and (b) a training run.
- the instrumentation build may invoke the compiler to generate a binary containing the necessary instrumentation code to profile the parameter or parameters when the binary is run. This step may use user-specified annotations to insert special instrumentation for profiling annotated parameters.
- the training run uses the binary produced in the instrumentation build and executes the binary with one or more representative workloads. This training run produces profile data, which is collected and stored in a database or a data file.
- the profile data can be analyzed to determine the application's preferred parameter value for the profiled parameter (304, 305).
- the user may specify a callback method to do custom processing of the profile data to select the preferred value of the parameter.
- This value is then recorded in the profile database or data file and used in an optimization build to initialize the parameter.
- This process allows for more complex special-case handling of the profile data in order to select the best parameter value.
- the optimization build may blindly apply the parameter value selected at the end of the training run via the user's callback.
- the optimization build may consume the profile data directly and, using a set of standard value profile transformations that may be provided in compiler support libraries, such as gcov, transform the code or initialize a parameter value based on the profile data.
- compiler support libraries such as gcov
- An example framework may include support for user-directed profile counter allocation, user-directed value profile instrumentation, user-directed value profile transformations, profiler counter address tracking, user-directed profile initializations, runtime integration of user-defined profile analysis callback routines, and recording of user-defined transformation decisions.
- Source code may be instrumented by a user to profile a specific parameter or parameters via new interfaces (200).
- the source code may then be compiled in an instrumentation build using compiler support for the new interfaces (201).
- An instrumented binary may contain user callbacks and new counter types and methods (202) which may then be invoked in a training run (203).
- a profile database or data file may collect value profiles for the instrumented parameters (205).
- a user callback method may be invoked after profiling. If a user callback method is invoked, the preferred parameter value is recorded in the profile database or data file and used in the optimization build (206) to create the optimized binary(207). In other cases, the optimization build (206) may analyze the profile data directly to transform the profiled parameter or parameters to create the optimized binary (207).
- user-directed profile counter allocation may be language extensions of the GNU Compiler Collection (GCC) built-in functions.
- GCC GNU Compiler Collection
- Profile counter address tracking and user directed profile initializations may be implemented using special purpose declaration attributes.
- Runtime integration of user-defined profile analysis callback routines and recording user-defined transformation decisions may be implemented using example GCC application programming interfaces.
- Methods and interfaces for the framework may use standard objects from GCOV which is a test coverage library built for GCC. More details regarding each piece of the example framework functionality is provided in the following paragraphs.
- a user-directed profile counter allocation interface may be used to instruct a compiler to allocate one entry in the static counter array for the specified counter during instrumentation.
- An example user-directed profile counter allocation method takes in four parameters: (1) the type of counter that should be allocated, (2) a pointer to the object being profiled, (3) an optional parameter that is the name of the counter's base address pointer field, and (4) an optional parameter that is a sequence id.
- the optional parameter representing the name of the counter's base address pointer field may be used when there are multiple values profiled at the same site. This parameter is discussed in more detail below.
- the optional sequence id parameter may be used when multiple values with the same type are profiled at the same site.
- An example profile counter may be allocated using the following new GCC builtin language extension based on aspects of the inventive concepts:
- Profile counter allocation may cause a counter to be allocated in an array that may be referred to as "counter_array[site_index]."
- GCC will allocate counter arrays to hold the counter values of everything being profiled.
- GCC builtin language extensions may case the compiler to allocate space in the appropriate array for the counters required by the specified builtin. For example, the compiler may initialize the base address field as follows:
- the counter base receives the address of the index that the counter was assigned in the compiler's counter array.
- Site_index refers to the index allocated for this counter.
- User-directed value profile instructs the compiler to inject code to profile specified values during profile training runs.
- An example user-directed value profile interface may take four parameters: (1) a counter type, (2) a parameter, or value, to be profiled, (3) an optional pointer to the object being profiled, and (4) an optional parameter representing the name of the counter's base address pointer field may be used when there are multiple values profiled at the same site.
- an instrumentation interface may be instantiated using the following new GCC builtin language extension based on aspects of the inventive concepts:
- User-directed value profile transformation instructs a compiler to perform a transformation on the profiled parameter, or value, based on the profile data for the parameter.
- An example user-directed value profile transformation interface may take four parameters: (1) a counter type, (2) the transformation to be performed, (3) the parameter or value on which to perform the transformation, and (4) an optional sequence id.
- a transformation interface may be instantiated using the following new GCC builtin language extension based on aspects of the inventive concepts:
- This interface may be used to instruct the compiler to perform a value profile transformation vptt using value "a" from the counter with type GT.
- gt represents the type of counter to be used and "vptt” is the type of transformation to perform.
- the parameter, "a,” is the parameter, or the value, to transform and "seq_id” is an optional parameter for a sequence id.
- a compiler annotation can be used to specify a new base address field. This attribute should be applied on a non-static field declaration.
- a base address field attribute may be specified by using a special purpose declaration attribute such as the following:
- a counter declaration may be as follows:
- Attaching the counter base attribute to a counter declaration allows the compiler to generate code to initialize the corresponding base address field for the counter right after the counter is allocated. For example, the compiler may initialize the base address field using the following assignment that was described above:
- a software developer may not want to use the predefined counters and update sequences provided by a compiler and compiler runtime.
- a software developer can initialize a profile instrumentation routine by implementing a profile initialization function. This function may be treated as a static initialization routine invoked by an .init function in the instrumentation build. In the optimization build, the function will be parsed and discarded.
- a profile initialization function may be specified by using a special purpose declaration attribute such as the following:
- An example profile initialization routine may be declared as follows:
- Attaching the profile initialization attribute to a function declaration allows the compiler to understand that the declared function defines profile initialization. When this attribute is applied on a function declaration, the function is treated as a static routine invoked by an .init function in an instrumentation build (201) compilation. In an optimization build (206), the function will be parsed and discarded.
- An invoke function may take three parameters: (1) a pointer to an update function, (2) a pointer to the user-defined counter variable, and (3) the parameter, or value, to be profiled.
- An example method may be defined as follows:
- updater points to the user-defined update function named “updater”
- profile_counter is a pointer to the user-defined counter variable
- data is the value, or parameter, to be profiled.
- the builtin may do nothing.
- the software developer may define a callback routine to process the collected profile data and record the preferred parameter value to use during an optimization build.
- the callback routine should be registered by the user in the profile initialization function discussed above.
- To register the callback routine the developer may instantiate a register interface that takes a pointer to the callback routine as a parameter. This instantiation should be called by the profile initialization function discussed above.
- the callback routine registration may be defined as follows:
- a software developer is not using predefined counters and update sequences to profile and update parameter values, the developer needs a way to process collected profile data and record the preferred parameter value for each profiled parameter. Recording values may be done with an interface that takes two parameters: (1) a macro name and (2) the preferred value.
- a recording interface may be instantiated using the following API:
- “macro_name” represents the name of the source macro to be updated with the profile optimized value “optimal_value” in the feedback-directed optimization build (206).
- the parameter, “optimal_value,” is the preferred value to which the designated macro should be set.
- This interface records the mapping between "macro_name” and the "optimal_value” for use in the optimization build.
- Pieces of an example framework can be used together to allow a software developer to define and use several different classes of value profiling including: user-directed per-class global value profiling, user-directed per-site value profiling, and user-directed per-site object value profiling.
- User-directed per-class global value profiling is used to profile and optimize specific parameter values for an application. This type of profiling may be especially beneficial when an application uses a library that is shared by multiple programs, which have no connection to each other.
- a library is a collection of code that is commonly shared by different programs which defines certain behavior through a well-defined interface.
- a typical library usually has many parameters by which to control runtime performance. However, most libraries usually either do not tune these parameters or tune the parameters for some applications which use the library, but not all. Maintaining a different set of parameters for each application which uses the library is not practical because the parameter values may become obsolete over time.
- This type of profiling may require that a software developer keep track of parameter counters independent of the compiler.
- a compiler may not understand the critical values of an application which should be tracked or how to track the values. Therefore, a user must keep track of the parameter counters.
- a software developer may use several pieces of the example framework including a user-directed profile initialization function, a registered user-defined callback routine, a user-defined update function, and a method for recording user-defined transformation decisions.
- framework pieces a software developer can embed the decision process for choosing preferred parameters into the compiler-based feedback-directed optimization loop.
- An example method for user-directed per-class global value profiling begins with a user specifying value profile counter types and defining value profile instrumentation routines instead of depending on customary predefined counters and update sequences as shown in FIG. 4 (401, 402).
- a software developer may first construct a counter. Then, a user may create a profile initialization routine function. This function may be designated by including a profile initialization attribute to the declaration of the function as discussed above. When a profile initialization attribute is applied on a function declaration, the function may be treated as a static initialization routine invoked by an .init function in instrumentation compilation. In optimization compilation, the function may be parsed and discarded. Within the profile initialization function, the developer may initialize the counter to profile a particular parameter.
- a software developer In order to update the parameter's value as it changes during an instrumentation build, a software developer provides a profile update function in a location where the counter's value should be updated (404).
- a software developer may use a language extension to GCC's builtin or some other code to invoke a user-defined profile update function in the designated location. As discussed above, an invoke function may expand to an update function. This update function records the values of the profiled parameter during the instrumentation build.
- a profile handler function may also be written by the software developer to process the counter profile data and record the determined preferred parameter value for the profiled parameter during the optimization build.
- the profile handler function may be registered in a callback routine in the profile initialization function (403).
- the software developer may also instantiate a record method as discussed above for recording user-defined transformation decisions (405).
- the buffer size parameter value is at first defined in a macro to be 32 (501).
- a software developer may use aspects of an example framework to augment the code and profile the buffer.
- a software developer constructs a counter, ProfCounter(502). Then, a user-defined profile instrumentation routine function may be designated by including a profile initialization attribute to the definition of the function.
- profile_init is designated as the profile instrumentation routine function by using "_attribute_((profile_init))" (503). The software developer then initializes the counter within the profile initialization function.
- the software developer may then define an update method to update the profiled parameter's value when the parameter's value changes during an instrumentation build.
- a software developer invokes the profile update function within a resize method which resizes the buffer (509).
- profile_update is the user-defined update function
- counter_ is the user-defined counter variable
- s is the data value to be profiled.
- this invocation may expand into a call:"profile_update(counter_,s)"
- a software developer can then define a profile handler function that processes profiled data from the instrumentation build and determines a preferred size for the buffer (507).
- This profile handler function records the preferred buffer size in a profiling database and uses a mechanism to pass the macro to a parser to be used during optimization compilation.
- the compiler may read in the gcov data file (GCDA) early in the optimization build process. This read-in process code may be enhanced to understand the new macro parameter types and communicate the macro parameters to the part of the compiler that parses the source code.
- the macro "BUF_SIZE” receives the preferred parameter value "optimal_buffer_size" when the profile handler function is run during the optimization build.
- the "optimal_buffer_size” is determined by processing all the recorded buffer sizes. For example, processing may include averaging the recorded buffer sizes and determining the preferred buffer size may be the computed average.
- the profile handler can then be registered as the callback routine to be run during the optimization build (505).
- the software developer passes the address of the profile handler function, "profile_handler" to the registration method.
- User-directed per-site value profiling may be used for example to determine preferred parameters for function call parameters, expensive operation's operands, or loop bounds.
- the instrumentation site and the transformation site are in the same location which means that there is no need for analysis callbacks.
- an example profile counter allocation interface may be used to instruct a compiler to allocate one entry in the static counter array for the specified counter during instrumentation (601).
- An example user-directed value profile instrumentation support interface may be used to instruct the code on the counter type to use and the value to profile when value profiling parameters during an instrumentation build (602).
- An example framework may also provide a user-directed value profile transformation support interface that may be used in optimization builds (604). This interface may be used to instruct a compiler to perform a value profile transformation on a certain parameter using the value from the counter with the specified counter type.
- FIG 7 Illustrates an example of value profiling and multi-version transformation for the first parameter of the call to a function, "foo.”
- Code is first augmented for profiling the parameter.
- a method is inserted for profile counter allocation.
- the profile counter allocation in this example is an allocation for a counter that finds the most frequent N values, "_GCOV_TOPN_VAL” (702).
- the user-directed value profile instrumentation support interface specifies that the compiler should instrument the code to find the most frequent "a” values using the _GCOV_TOPN_VAL counter (704).
- the user-directed value profile transformation support interface specifies that the compiler should perform a multi-versioning transformation, "_GCOV_MULTI_VER,” using value "a” from the "_GCOV_TOPN_VAL” counter (706).
- User-directed per-site object value profiling may be used to perform value profiling and transformation for objects instantiated at the same static site.
- a software developer may use several pieces of the example framework including: user-directed profile counter allocation, user-directed value profile instrumentation, profile counter address tracking, and user-directed value profiling transformation.
- Compiler annotation may be used to specify a new base address field in order to track the address of a profile counter.
- This attribute should be applied on a non-static field declaration.
- a base address field attribute may be specified by using a special purpose declaration attribute such as the following:
- Code may also be inserted for profile counter allocation. Then, instrumentation code may be inserted to profile the desired parameter or value. Finally, code may be inserted to do profile transformation.
- FIG. 8a depicts a vector class that pre-allocates a vector size.
- the new vector is created with a size of 10.
- 10 may not be the preferred size of the vector.
- a software developer may use user-directed per-site object value profiling,
- FIG. 8b illustrates the process for conducting user-directed per-site object value profiling in order to determine the preferred length of a vector.
- the class should be augmented in order to profile the length parameter.
- a macro is created for the instrumentation build, "PROFILE_GENERATE” (802).
- a compiler annotation is used to specify a new base address field as shown in FIG. 8b on counter,”counter_base_” (802).
- the profile counter allocation in this example is an allocation for a counter that keeps a running sum and count of the profiled value using the standard "_GCOV_COUNTER_AVERAGE” counter (804). In this example, the allocation uses "this" which is a pointer to the vector object being profiled.
- the next step is to insert instrumentation code to record the final length of the vector.
- the final length of the vector can be determined in the vector destructor since, at this destruction point, the code knows the final length that was required for the vector.
- the user-defined value profile instrumentation support interface specifies that the compiler should instrument the code to keep a running sum and a count of the length using a standard counter of type _GCOV_COUNTER_AVERAGE (808).
- the user-directed value profile transformation support interface specifies that the compiler should perform an averaging over the lengths using GCOV's standard average transformation, "_GCOV_AVERAGE_VAL,” and the received values of "n” from the standard counter "_GCOV_COUNTER_AVERAGE” during the training run(806).
- This average value is then sent to the profile database, or gcda file, and used as the preferred length parameter for the vector instances created at the instrumentation site.
- a builtin may tell the compiler to set the size of the vector to be the average value from the profile data.
- This type of profiling and optimization is leveraging the fact that the profile transformation sites, or places in the code to perform transformations, are inlined in many locations. As a result, there may be a context-sensitive, inline-site-specific, profile collected and transformation generated at each inline site. In this case, vectors instantiated in different places throughout the application code can get different profile-based length values rather than the library default.
- FIG. 9a and 9b An additional example of user-directed per-site object value profiling is illustrated in FIG. 9a and 9b .
- This example is a follow-on to the example discussed above in relation to FIGs. 8a and 8b .
- the amount of space to pre-allocate at the start of an insertion operation can be determined. Normally, an insertion operation increases the length of a vector one element at a time, but this increase amount may not be sufficient.
- FIG. 9a illustrates customary vector code.
- FIG. 9b illustrates the augmented code that allows the automatic process for conducting user-directed per-site object value profiling in order to determine the preferred length of a vector and the amount of space that should be pre-allocated at the start of an insertion operation.
- a macro is created for the instrumentation build, "PROFILE_GENERATE.”
- Two counters are defined, one for vector length and one for insertion size.
- Each counter is defined with a compiler annotation that is used to specify new base address field.
- FIG. 9b shows the compiler annotation "_attribute_((gcov_counter_base))" on “counter_base_constr_” and "counter_base_insert_” (902).
- the next step is to insert user-directed value profile instrumentation code to value profile the final length of the vector.
- the final length of the vector can be determined in the vector destructor since, at this destruction point, the code knows the final length that was required for the vector (906).
- the instrumentation support interface specifies that the compiler should instrument the code to record the current vector length.
- Instrumentation code should also be inserted to value profile the inserted length of elements in the vector (908).
- the inserted length can be determined in the vector's insert function.
- the instrumentation support interface specifies that the compiler should instrument the code to record the insert length.
- the field name is used in both of these uses of the user-directed value profile instrumentation support interface to generate appropriate updates to the appropriate counters.
- the field names are strings to avoid parsing errors when the instrumentation build is not being run.
- one user-directed value transformation support interface specifies that the compiler should perform an averaging over the lengths using the standard gcov transformation for averaging, "_GCOV_AVERAGE_VAL,” and values of "n" from the "_GCOV_COUNTER_AVERAGE” counter type with a sequence_id of 1.
- a second transformation support interface specifies that the compiler should perform an averaging over the inserted lengths using the inserted length values from the "_GCOV_COUNTER_AVERAGE” counter type with a sequence_id of 2.
- the sequence_id tags are used to associate the transformation site with the correct allocation site so that the appropriate counter value from the profile database, or GCDA file is used in the correct optimization decision.
- An example framework can be used to tune libraries such as STL and memory allocators, on a per-application basis based on application-specific profile information. This performance tuning may translate into very large performance improvements and machine savings.
- the framework seamlessly integrates with the FDO framework which makes application tuning automatic and removes the possibility of stale parameters.
- an example framework can be used to tune code behavior for non-performance related purposes, such as memory consumption and memory fragmentation.
- FIG. 10 is a high-level block diagram of an example computer (1000) that is arranged for creating user-directed profile-driven optimizations.
- the computing device (1000) typically includes one or more processors (1010) and system memory (1020).
- a memory bus (1030) can be used for communicating between the processor (1010) and the system memory (1020).
- the processor (1010) can be of any type including but not limited to a microprocessor ( ⁇ P), a microcontroller ( ⁇ C), a digital signal processor (DSP), or any combination thereof.
- the processor (1010) can include one more levels of caching, such as a level one cache (1011) and a level two cache (1012), a processor core (1013), and registers (1014).
- the processor core (1013) can include an arithmetic logic unit (ALU), a floating point unit (FPU), a digital signal processing core (DSP Core), or any combination thereof.
- a memory controller (1016) can also be used with the processor (1010), or in some implementations the memory controller (1015) can be an internal part of the processor (1010).
- system memory (1020) can be of any type including but not limited to volatile memory (such as RAM), non-volatile memory (such as ROM, flash memory, etc.) or any combination thereof.
- System memory (1020) typically includes an operating system (1021), one or more applications (1022), and program data (1024).
- the application (1022) may include a method for creating and obtaining application-specific, profile-driven optimizations for the application.
- Program Data (1024) includes storing instructions that, when executed by the one or more processing devices, implement a method for code optimizations. (1023).
- the application (1022) can be arranged to operate with program data (1024) on an operating system (1021).
- the computing device (1000) can have additional features or functionality, and additional interfaces to facilitate communications between the basic configuration (1001) and any required devices and interfaces.
- System memory (1020) is an example of computer storage media.
- Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computing device 1000. Any such computer storage media can be part of the device (1000).
- the computing device (1000) can be implemented as a portion of a small-form factor portable (or mobile) electronic device such as a cell phone, a smartphone, a personal data assistant (PDA), a personal media player device, a tablet computer (tablet), a wireless web-watch device, a personal headset device, an application-specific device, or a hybrid device that include any of the above functions.
- a small-form factor portable (or mobile) electronic device such as a cell phone, a smartphone, a personal data assistant (PDA), a personal media player device, a tablet computer (tablet), a wireless web-watch device, a personal headset device, an application-specific device, or a hybrid device that include any of the above functions.
- PDA personal data assistant
- tablet computer tablet computer
- non-transitory signal bearing medium examples include, but are not limited to, the following: a recordable type medium such as a floppy disk, a hard disk drive, a Compact Disc (CD), a Digital Video Disk (DVD), a digital tape, a computer memory, etc.; and a transmission type medium such as a digital and/or an analog communication medium, (e.g., fiber optics cable, a waveguide, a wired communications link, a wireless communication link, etc.)
Description
- Feedback-directed optimization (FDO) is a technique used to tune application executions based on application runtime behavior in order to improve performance. FDO is also known as Profile Guided Optimization (PGO) and Profile Based Optimization (PBO). In order to tune applications, FDO conducts profiling on the applications. Profiling is the process of gathering information about how an application behaves during runtime. This profile information is used to drive decisions regarding various application optimizations.
- As illustrated in
FIG. 1 , customary feedback-directed optimization is a dual build model technique that uses static instrumentation to collect edge and value profiles. An instrumentation build (101) allows the compiler to insert code into an application's binary to create an instrumented version of the binary (102). This inserted code typically counts edges or collects value profiles. The instrumented binary (102) is run on a representative set of training data (104) in a training run (103). At the end of the training execution, all collected edge counts and value information is written and aggregated in a profile database or gcov data file (GCDA)(105). An optimization build (106) then occurs in which the compiler uses the generated profile to make optimization decisions such as inline decisions, instruction scheduling, basic block re-ordering, function splitting, and register allocation. - One problem with customary FDO is that the technique relies on compilers that do not understand the high-level details of the applications on which FDO runs. For example, compilers do not know application-specific algorithms or parameters. Customary feedback-directed optimization can therefore only handle a very limited set of low level profiles, such as control flow edge profiling or a predefined set of value profiles including indirect function call targets, string function call size, and alignment profiles.
- In many cases, software developers have in-depth knowledge of high-level details for their applications. Developers often know which aspects of their code are important and which parameters should be tuned in order to improve application performance. However, in common runtime libraries, these parameters are either left untuned or the parameters are tuned for average applications since customary FDO processes do not allow for user-defined profile optimizations. Although some developers choose to manually tune their code for specific applications, manual processes can be labor-intensive. As recognized by the inventors, there should be a framework that allows easy application performance tuning that can be done automatically during compilation.
- A. Krishnaswamy et al., "Profile guided selection of ARM and Thumb instructions", Association for Computing Machinery, vol. 37, no. 7, pages 56 to 64, relates to profile guided algorithms for generating mixed ARM and Thumb code for application programs so that the resulting code gives significant code size reductions without loss in performance.
- The present invention relates to a method according to
claim 1. - This specification describes technologies relating to application performance improvement in general, and specifically to methods and systems for automatically tuning performance parameters based on application runtime behavior.
- In general, one aspect of the subject matter described in this specification can be embodied in a method for using profiling to obtain application-specific, preferred parameter values for an application. The method may include receiving identification of a parameter for which to obtain an application-specific value; receiving augmented code for profiling the parameter; profiling the parameter and collecting profile data; analyzing the profile data; and determining the application's preferred parameter value for the profiled parameter based on the analyzed profile data. A second aspect of the subject matter can be embodied in a method for user-directed per-class global value profiling which may include: receiving a user-defined profile instrumentation initialization routine; within the profile initialization routine, initializing a counter and registering a user-defined analysis call back routine; running a profile update function in a code location where the counter's value should be updated; and executing a profile handler method to process counter data and record the counter value. A third aspect of the subject matter described in this specification can be embodied in a method of user-directed per-site value profiling or user-directed per-site object value profiling which may include: allocating space in a compiler's static counter array for a counter; running a user-directed value profile instrumentation support interface to execute instructions on which counter type to user and the value to be profiled; and running a user-directed value profile transformation support interface to perform a specific value profile transformation on the parameter during an optimization build.
- These and other embodiments can optionally include one or more of the following features: profiling may be user-directed per-class global value profiling; profiling may be user-directed per-site value profiling; profiling may be user-directed per-site object value profiling; profiling the parameter and collecting profile data may include generating an instrumentation binary from an instrumentation build, executing a training run with one or more representative workloads using the instrumentation binary to generate profile data, and storing the generated profile data; determining the application's preferred parameter value may include using a specified callback method to do custom processing of the profile data to select the preferred value of the parameter and recording the preferred value; the recorded preferred value may be used in an optimization build to initialize the parameter; determining the application's preferred parameter may include running an optimization build that consumes the profile data and using a set of standard value profile transformations, transforming a parameter value to a preferred value based on the profile data; a profile counter may be defined for a parameter to be profiled; one entry in a static counter array may be allocated for a counter; counter allocation may be done by calling a compiler extension for counter allocation; a user-directed value profile instrumentation support interface may be a GCC builtin language extension; a user-directed value profile transformation support interface may be a GCC builtin language extension; a profile counter address may be tracked by providing a special purpose declaration attribute for the profile counter; profile initialization may be provided by a special purpose declaration attribute to designate a profile initialization function; a user-defined analysis call back routine may be defined by using a GCC interface; and a parameter may be recorded by using a GCC interface.
- The details of one or more embodiments of the invention are set forth in the accompanying drawings which are given by way of illustration only, and the description below. Other features, aspects, and advantages of the invention will become apparent from the description, the drawings, and the claims. Like reference numbers and designations in the various drawings indicate like elements.
-
-
FIG. 1 is a block diagram illustrating a conventional feedback-directed optimization loop. -
FIG. 2 is a block diagram illustrating an example user-driven feedback-directed optimization loop. -
FIG. 3 is a flow diagram of an example method for obtaining application-specific, profile-driven optimizations for an application. -
FIG. 4 is a flow diagram of an example method for user-directed per-class global value profiling. -
FIG. 5 is example code illustrating an embodiment of user-directed per-class global value profiling. -
FIG. 6 is a flow diagram of an example method for user-directed per-site value profiling or user-directed per-site object value profiling. -
FIG. 7 is example code illustrating an embodiment of user-directed per-site value profiling. -
FIG. 8a is customary code depicting a vector class that pre-allocates a vector size. -
FIG. 8b is example code illustrating an embodiment of user-directed per-site object value profiling. -
FIG. 9a is customary code depicting a vector class that pre-allocates a vector size and an element size. -
FIG. 9b is example code illustrating an embodiment of user-directed per-site object value profiling. -
FIG. 10 is a block diagram illustrating an example computing device. - According to an example embodiment, a framework can facilitate user-directed profile-driven optimizations by allowing a software developer to profile selected parts of an application and direct a compiler to perform value profile transformations based on the profiling results as shown in
FIG. 2 . User-defined information may be included in both the instrumentation and the optimization compilations of a feedback loop. - An example method for obtaining application-specific, preferred parameter values for an application using profiling begins with identifying a parameter for which to obtain an application-specific value (301) as shown in
FIG. 3 . Code should then be augmented for application-specific profiling of the parameter (302). In some embodiments, the code to be augmented may be the application code. In other embodiments, the code to be augmented may be a library which is used by the application code. The parameter is then profiled specifically for the application (303). Profiling may include two steps: (a)an instrumentation build and (b) a training run. - The instrumentation build may invoke the compiler to generate a binary containing the necessary instrumentation code to profile the parameter or parameters when the binary is run. This step may use user-specified annotations to insert special instrumentation for profiling annotated parameters.
- The training run uses the binary produced in the instrumentation build and executes the binary with one or more representative workloads. This training run produces profile data, which is collected and stored in a database or a data file.
- After the profile data is collected, the profile data can be analyzed to determine the application's preferred parameter value for the profiled parameter (304, 305).
- In some cases, the user may specify a callback method to do custom processing of the profile data to select the preferred value of the parameter. This value is then recorded in the profile database or data file and used in an optimization build to initialize the parameter. This process allows for more complex special-case handling of the profile data in order to select the best parameter value. In this case, the optimization build may blindly apply the parameter value selected at the end of the training run via the user's callback.
- In other cases, the optimization build may consume the profile data directly and, using a set of standard value profile transformations that may be provided in compiler support libraries, such as gcov, transform the code or initialize a parameter value based on the profile data.
- An example framework may include support for user-directed profile counter allocation, user-directed value profile instrumentation, user-directed value profile transformations, profiler counter address tracking, user-directed profile initializations, runtime integration of user-defined profile analysis callback routines, and recording of user-defined transformation decisions.
- As illustrated in
FIG. 2 , this functionality may work together to enhance feedback-directed optimization. Source code may be instrumented by a user to profile a specific parameter or parameters via new interfaces (200). The source code may then be compiled in an instrumentation build using compiler support for the new interfaces (201). An instrumented binary may contain user callbacks and new counter types and methods (202) which may then be invoked in a training run (203). A profile database or data file may collect value profiles for the instrumented parameters (205). As discussed above, a user callback method may be invoked after profiling. If a user callback method is invoked, the preferred parameter value is recorded in the profile database or data file and used in the optimization build (206) to create the optimized binary(207). In other cases, the optimization build (206) may analyze the profile data directly to transform the profiled parameter or parameters to create the optimized binary (207). - There may be several ways to implement this functionality in an example framework. In one embodiment, user-directed profile counter allocation, user-directed value profile instrumentation, and user-directed value profile transformations may be language extensions of the GNU Compiler Collection (GCC) built-in functions. Profile counter address tracking and user directed profile initializations may be implemented using special purpose declaration attributes. Runtime integration of user-defined profile analysis callback routines and recording user-defined transformation decisions may be implemented using example GCC application programming interfaces. Methods and interfaces for the framework may use standard objects from GCOV which is a test coverage library built for GCC. More details regarding each piece of the example framework functionality is provided in the following paragraphs.
- A user-directed profile counter allocation interface may be used to instruct a compiler to allocate one entry in the static counter array for the specified counter during instrumentation. An example user-directed profile counter allocation method takes in four parameters: (1) the type of counter that should be allocated, (2) a pointer to the object being profiled, (3) an optional parameter that is the name of the counter's base address pointer field, and (4) an optional parameter that is a sequence id. The optional parameter representing the name of the counter's base address pointer field may be used when there are multiple values profiled at the same site. This parameter is discussed in more detail below. The optional sequence id parameter may be used when multiple values with the same type are profiled at the same site.
- An example profile counter may be allocated using the following new GCC builtin language extension based on aspects of the inventive concepts:
"_builtin_vpi_alloc(GCOV_COUNTER_TYPE gt, void *this, const char *fname=0, gcov_unsigned seq_id=0);"
"counter_base_ = &counter_array[site_index];"
"void _builtin_vpi(GCOV_COUNTER_TYPE gt, gcov_type v, void *this=NULL, const char *fname = 0);"
"__builtin_vpt(GCOV_COUNTER_TYPE gt, GCOV_VPT_TYPE vptt, gcov_type a, gcov_unsigned seq_id = 0);"
"_attribute_((gcov_counter_base));"
"gcov_type *counter_base__attribute_((gcov_counter_base));"
"counter_base_ = &counter_array[site_index];"
"_attribute_((profile_init))"
"static void profile_init(void)_attribute_((profile_init);"
"void __builtin_invoke(void(*updater)(void *), void *profile_counter, gcov_type data);"
"updater(profile_counter, data)"
"void __gcov_register_profile_handler(void (*handler) (void));"
"_attribute_((gcov_counter_base));"
Claims (11)
- A method for using profiling to obtain application-specific, preferred parameter values for an application, the method comprising:receiving (301) identification of a parameter for which to obtain at least one application-specific value;receiving (302) augmented code for profiling the parameter;profiling (303) the parameter and collecting profile data by:generating an instrumentation binary from an instrumentation build, the instrumentation binary containing user-defined callbacks, counter types and methods (202);executing a training run with one or more representative workloads using the instrumentation binary to generate profile data, the training run invoking the user-defined callbacks, counter types and methods; andstoring the generated profile data;analyzing (304) the profile data;determining (305) the application's preferred parameter value for the profiled parameter based on the analyzed profile data; and:using the determined preferred value in an optimization build to initialize the parameter.
- The method of claim 1 wherein profiling is user-directed per-class global value profiling.
- The method of claim 1 wherein profiling is user-directed per-site value profiling.
- The method of claim 1 wherein profiling is user-directed per-site object value profiling.
- The method of claim 1 wherein determining the application's preferred parameter value further comprises:using a specified callback method to do custom processing of the profile data to select the preferred value of the application-specific parameter andrecording the preferred value.
- The method of claim 1 wherein determining the application's preferred parameter value further comprises:running an optimization build that consumes the profile data andusing a set of standard value profile transformations, transforming a parameter value to a preferred value based on the profile data.
- The method of claim 1 further comprising defining a profile counter for the application-specific parameter to be profiled.
- The method of claim 7 further comprising allocating one entry in the static counter array for the counter.
- The method of claim 8 wherein allocation is done by calling a compiler extension for counter allocation.
- The method of claim 1 further comprising allowing for profile counter address tracking by providing a special purpose declaration attribute for the profile counter.
- The method of claim 1 further comprising allowing for profile initialization by providing a special purpose declaration attribute to designate a profile initialization function.
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/855,557 US9760351B2 (en) | 2013-04-02 | 2013-04-02 | Framework for user-directed profile-driven optimizations |
PCT/US2014/032530 WO2014165515A1 (en) | 2013-04-02 | 2014-04-01 | A framework for user-directed profile-driven optimizations |
Publications (2)
Publication Number | Publication Date |
---|---|
EP2981891A1 EP2981891A1 (en) | 2016-02-10 |
EP2981891B1 true EP2981891B1 (en) | 2018-03-28 |
Family
ID=50733366
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
EP14724894.2A Active EP2981891B1 (en) | 2013-04-02 | 2014-04-01 | A framework for user-directed profile-driven optimizations |
Country Status (9)
Country | Link |
---|---|
US (5) | US9760351B2 (en) |
EP (1) | EP2981891B1 (en) |
JP (1) | JP6275819B2 (en) |
KR (1) | KR101759256B1 (en) |
CN (1) | CN105637480B (en) |
AU (1) | AU2014248296B2 (en) |
BR (1) | BR112015024334B1 (en) |
DE (1) | DE202014010942U1 (en) |
WO (1) | WO2014165515A1 (en) |
Families Citing this family (18)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20150154100A1 (en) * | 2013-12-04 | 2015-06-04 | International Business Machines Corporation | Tuning business software for a specific business environment |
US10261766B2 (en) * | 2014-08-28 | 2019-04-16 | Hewlett Packard Enterprise Development Lp | Sloppy feedback loop compilation |
US9547483B1 (en) | 2015-11-06 | 2017-01-17 | International Business Machines Corporation | Feedback directed optimized compiling of optimized executable code |
US9535673B1 (en) * | 2016-02-03 | 2017-01-03 | International Business Machines Corporation | Reducing compilation time using profile-directed feedback |
US9485320B1 (en) | 2016-03-31 | 2016-11-01 | International Business Machines Corporation | Monitoring and controlling perception of an online profile of a user |
US10108404B2 (en) * | 2016-10-24 | 2018-10-23 | International Business Machines Corporation | Compiling optimized entry points for local-use-only function pointers |
US9785422B1 (en) * | 2016-10-31 | 2017-10-10 | International Business Machines Corporation | Applying multiple rewriting without collision for semi-automatic program rewriting system |
US10248554B2 (en) | 2016-11-14 | 2019-04-02 | International Business Machines Corporation | Embedding profile tests into profile driven feedback generated binaries |
US10338932B2 (en) | 2016-11-15 | 2019-07-02 | Google Llc | Bootstrapping profile-guided compilation and verification |
US10853044B2 (en) | 2017-10-06 | 2020-12-01 | Nvidia Corporation | Device profiling in GPU accelerators by using host-device coordination |
US11120521B2 (en) * | 2018-12-28 | 2021-09-14 | Intel Corporation | Techniques for graphics processing unit profiling using binary instrumentation |
US10922779B2 (en) * | 2018-12-28 | 2021-02-16 | Intel Corporation | Techniques for multi-mode graphics processing unit profiling |
KR20210029621A (en) | 2019-09-06 | 2021-03-16 | 삼성전자주식회사 | Apparatus and method for improving runtime performance after application update in electronic device |
KR20210046426A (en) | 2019-10-18 | 2021-04-28 | 삼성전자주식회사 | Application optimizing method and electronic device supporting the same |
US11429434B2 (en) * | 2019-12-23 | 2022-08-30 | International Business Machines Corporation | Elastic execution of machine learning workloads using application based profiling |
US11726785B2 (en) * | 2020-09-30 | 2023-08-15 | Purdue Research Foundation | Graphics processor unit with opportunistic inter-path reconvergence |
US11481200B1 (en) | 2021-10-11 | 2022-10-25 | International Business Machines Corporation | Checking source code validity at time of code update |
US11947966B2 (en) | 2021-10-11 | 2024-04-02 | International Business Machines Corporation | Identifying computer instructions enclosed by macros and conflicting macros at build time |
Family Cites Families (21)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5815720A (en) | 1996-03-15 | 1998-09-29 | Institute For The Development Of Emerging Architectures, L.L.C. | Use of dynamic translation to collect and exploit run-time information in an optimizing compilation system |
JPH11149380A (en) | 1997-11-18 | 1999-06-02 | Hitachi Ltd | Compiler, program optimizing method and recording medium recording its processing program |
US8065504B2 (en) * | 1999-01-28 | 2011-11-22 | Ati International Srl | Using on-chip and off-chip look-up tables indexed by instruction address to control instruction execution in a processor |
US6742178B1 (en) | 2000-07-20 | 2004-05-25 | International Business Machines Corporation | System and method for instrumenting application class files with correlation information to the instrumentation |
JP4184900B2 (en) * | 2003-08-26 | 2008-11-19 | 富士通株式会社 | Compiling processing program for performing statistical processing of variables, recording medium thereof, processing method thereof, and processing apparatus thereof |
WO2005050372A2 (en) * | 2003-11-13 | 2005-06-02 | The Board Of Governors For Higher Education State Of Rhode Island : Providence Plantation | Hardware environment for low-overhead profiling |
US7769974B2 (en) * | 2004-09-10 | 2010-08-03 | Microsoft Corporation | Increasing data locality of recently accessed resources |
US7607119B2 (en) * | 2005-04-26 | 2009-10-20 | Microsoft Corporation | Variational path profiling |
US20070061785A1 (en) * | 2005-09-09 | 2007-03-15 | Sun Microsystems, Inc. | Web-based code tuning service |
KR100750834B1 (en) | 2005-10-06 | 2007-08-22 | (주)아이피엠에스 | A method of data call stack tracing in data monitoring of JAVA byte code and a device for storing the method in compter program type |
US20080126867A1 (en) * | 2006-08-30 | 2008-05-29 | Vinod Pandarinathan | Method and system for selective regression testing |
US7908593B2 (en) * | 2007-01-04 | 2011-03-15 | International Business Machines Corporation | Technique for evaluating software performance online to support online tuning |
US8214806B2 (en) * | 2007-05-09 | 2012-07-03 | International Business Machines Corporation | Iterative, non-uniform profiling method for automatically refining performance bottleneck regions in scientific code |
US20090089805A1 (en) * | 2007-09-28 | 2009-04-02 | Microsoft Corporation | Profiling techniques and systems for computer programs |
US20100125838A1 (en) * | 2008-11-19 | 2010-05-20 | Nokia Corporation | Method and Apparatus for Optimizing a Program |
US8387026B1 (en) | 2008-12-24 | 2013-02-26 | Google Inc. | Compile-time feedback-directed optimizations using estimated edge profiles from hardware-event sampling |
US8627300B2 (en) * | 2009-10-13 | 2014-01-07 | Empire Technology Development Llc | Parallel dynamic optimization |
US8635606B2 (en) * | 2009-10-13 | 2014-01-21 | Empire Technology Development Llc | Dynamic optimization using a resource cost registry |
US8856767B2 (en) * | 2011-04-29 | 2014-10-07 | Yahoo! Inc. | System and method for analyzing dynamic performance of complex applications |
CN102609351B (en) * | 2012-01-11 | 2015-12-02 | 华为技术有限公司 | For the method, apparatus and system of the performance of analytic system |
US9256410B2 (en) * | 2012-08-09 | 2016-02-09 | Apple Inc. | Failure profiling for continued code optimization |
-
2013
- 2013-04-02 US US13/855,557 patent/US9760351B2/en active Active
-
2014
- 2014-04-01 KR KR1020157030905A patent/KR101759256B1/en active IP Right Grant
- 2014-04-01 WO PCT/US2014/032530 patent/WO2014165515A1/en active Application Filing
- 2014-04-01 CN CN201480019806.3A patent/CN105637480B/en active Active
- 2014-04-01 AU AU2014248296A patent/AU2014248296B2/en active Active
- 2014-04-01 EP EP14724894.2A patent/EP2981891B1/en active Active
- 2014-04-01 BR BR112015024334-7A patent/BR112015024334B1/en active IP Right Grant
- 2014-04-01 JP JP2016506373A patent/JP6275819B2/en active Active
- 2014-04-01 DE DE202014010942.7U patent/DE202014010942U1/en not_active Expired - Lifetime
-
2017
- 2017-09-11 US US15/701,296 patent/US10365903B2/en active Active
-
2019
- 2019-07-29 US US16/524,929 patent/US11321061B2/en active Active
-
2022
- 2022-03-17 US US17/697,119 patent/US11675574B2/en active Active
-
2023
- 2023-04-11 US US18/133,190 patent/US20230244458A1/en active Pending
Also Published As
Publication number | Publication date |
---|---|
AU2014248296B2 (en) | 2017-01-19 |
US11321061B2 (en) | 2022-05-03 |
US20230244458A1 (en) | 2023-08-03 |
US9760351B2 (en) | 2017-09-12 |
DE202014010942U1 (en) | 2017-01-26 |
AU2014248296A1 (en) | 2015-09-03 |
US20220206769A1 (en) | 2022-06-30 |
US20140298307A1 (en) | 2014-10-02 |
BR112015024334A8 (en) | 2018-01-02 |
KR101759256B1 (en) | 2017-07-31 |
US11675574B2 (en) | 2023-06-13 |
WO2014165515A1 (en) | 2014-10-09 |
BR112015024334A2 (en) | 2017-07-18 |
US10365903B2 (en) | 2019-07-30 |
CN105637480B (en) | 2020-03-03 |
US20200019390A1 (en) | 2020-01-16 |
BR112015024334B1 (en) | 2022-01-25 |
JP6275819B2 (en) | 2018-02-07 |
KR20150138290A (en) | 2015-12-09 |
US20180107464A1 (en) | 2018-04-19 |
EP2981891A1 (en) | 2016-02-10 |
JP2016517109A (en) | 2016-06-09 |
CN105637480A (en) | 2016-06-01 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US11675574B2 (en) | Framework for user-directed profile-driven optimizations | |
US5539907A (en) | System for monitoring computer system performance | |
US5732273A (en) | System for monitoring compute system performance | |
US7856627B2 (en) | Method of SIMD-ization through data reshaping, padding, and alignment | |
US8161464B2 (en) | Compiling source code | |
US8402435B1 (en) | Systems and methods for organizing source code | |
US8701097B2 (en) | Partial inlining with software based restart | |
US7356813B2 (en) | System and method for optimizing a program | |
KR101962484B1 (en) | Extensible data parallel semantics | |
JP2005100402A (en) | Area based memory management for object-oriented program | |
Gustafsson et al. | Towards a flow analysis for embedded system C programs | |
US6360360B1 (en) | Object-oriented compiler mechanism for automatically selecting among multiple implementations of objects | |
US20150317139A1 (en) | Methods to eliminate extra memory loads while accessing global variables in position independent code | |
Sato et al. | Whole program data dependence profiling to unveil parallel regions in the dynamic execution | |
US8458679B2 (en) | May-constant propagation | |
US8578352B1 (en) | Optimizing object oriented programs using limited customization | |
Zhang et al. | Understanding the performance of GPGPU applications from a data-centric view | |
US20090037690A1 (en) | Dynamic Pointer Disambiguation | |
Calvert | Parallelisation of java for graphics processors | |
Hascoët et al. | Programming language features, usage patterns, and the efficiency of generated adjoint code | |
Leuverink et al. | An implementation of Andersen-style pointer analysis for the x86 mov instruction | |
US20220107825A1 (en) | Measuring the Memory Usage of Java Programs | |
Chawdhary et al. | Closing the performance gap between doubles and rationals for octagons | |
Norouzi et al. | Fast data-dependence profiling through prior static analysis | |
Shivam et al. | OpenACC Routine Directive Propagation Using Interprocedural Analysis |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
REG | Reference to a national code |
Ref country code: DERef legal event code: R138Ref document number: 202014010942Country of ref document: DEFree format text: GERMAN DOCUMENT NUMBER IS 602014022958 |
|
PUAI | Public reference made under article 153(3) epc to a published international application that has entered the european phase |
Free format text: ORIGINAL CODE: 0009012 |
|
17P | Request for examination filed |
Effective date: 20151026 |
|
AK | Designated contracting states |
Kind code of ref document: A1Designated state(s): AL AT BE BG CH CY CZ DE DK EE ES FI FR GB GR HR HU IE IS IT LI LT LU LV MC MK MT NL NO PL PT RO RS SE SI SK SM TR |
|
AX | Request for extension of the european patent |
Extension state: BA ME |
|
DAX | Request for extension of the european patent (deleted) | ||
17Q | First examination report despatched |
Effective date: 20160901 |
|
GRAP | Despatch of communication of intention to grant a patent |
Free format text: ORIGINAL CODE: EPIDOSNIGR1 |
|
INTG | Intention to grant announced |
Effective date: 20171009 |
|
RAP1 | Party data changed (applicant data changed or rights of an application transferred) |
Owner name: GOOGLE LLC |
|
GRAS | Grant fee paid |
Free format text: ORIGINAL CODE: EPIDOSNIGR3 |
|
GRAA | (expected) grant |
Free format text: ORIGINAL CODE: 0009210 |
|
AK | Designated contracting states |
Kind code of ref document: B1Designated state(s): AL AT BE BG CH CY CZ DE DK EE ES FI FR GB GR HR HU IE IS IT LI LT LU LV MC MK MT NL NO PL PT RO RS SE SI SK SM TR |
|
REG | Reference to a national code |
Ref country code: GBRef legal event code: FG4D |
|
REG | Reference to a national code |
Ref country code: CHRef legal event code: EP |
|
REG | Reference to a national code |
Ref country code: SERef legal event code: TRGR |
|
REG | Reference to a national code |
Ref country code: ATRef legal event code: REFRef document number: 984005Country of ref document: ATKind code of ref document: TEffective date: 20180415 |
|
REG | Reference to a national code |
Ref country code: IERef legal event code: FG4D |
|
REG | Reference to a national code |
Ref country code: DERef legal event code: R096Ref document number: 602014022958Country of ref document: DE |
|
REG | Reference to a national code |
Ref country code: FRRef legal event code: PLFPYear of fee payment: 5 |
|
REG | Reference to a national code |
Ref country code: FRRef legal event code: PLFPYear of fee payment: 6 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: HRFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180328Ref country code: NOFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180628Ref country code: LTFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180328Ref country code: FIFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180328 |
|
REG | Reference to a national code |
Ref country code: NLRef legal event code: MPEffective date: 20180328 |
|
REG | Reference to a national code |
Ref country code: LTRef legal event code: MG4D |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: LVFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180328Ref country code: GRFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180629Ref country code: RSFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180328Ref country code: BGFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180628 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: ITFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180328Ref country code: ROFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180328Ref country code: ALFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180328Ref country code: NLFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180328Ref country code: PLFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180328Ref country code: EEFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180328Ref country code: ESFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180328 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: CZFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180328Ref country code: SKFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180328Ref country code: SMFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180328 |
|
REG | Reference to a national code |
Ref country code: CHRef legal event code: PL |
|
REG | Reference to a national code |
Ref country code: ATRef legal event code: MK05Ref document number: 984005Country of ref document: ATKind code of ref document: TEffective date: 20180328 |
|
REG | Reference to a national code |
Ref country code: BERef legal event code: MMEffective date: 20180430 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: PTFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180730 |
|
RIC2 | Information provided on ipc code assigned after grant |
Ipc: G06F 9/45 20181130AFI20141023BHEP |
|
REG | Reference to a national code |
Ref country code: DERef legal event code: R097Ref document number: 602014022958Country of ref document: DE |
|
REG | Reference to a national code |
Ref country code: IERef legal event code: MM4A |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: DKFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180328Ref country code: ATFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180328Ref country code: LUFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20180401Ref country code: MCFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180328 |
|
PLBE | No opposition filed within time limit |
Free format text: ORIGINAL CODE: 0009261 |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: NO OPPOSITION FILED WITHIN TIME LIMIT |
|
RIC2 | Information provided on ipc code assigned after grant |
Ipc: G06F 9/45 20060101AFI20141023BHEP |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: BEFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20180430Ref country code: LIFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20180430Ref country code: CHFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20180430 |
|
26N | No opposition filed |
Effective date: 20190103 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: IEFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20180401 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: SIFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180328 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: MTFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20180401 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: TRFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180328 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: CYFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180328Ref country code: HUFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMIT; INVALID AB INITIOEffective date: 20140401Ref country code: MKFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20180328 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: ISFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20180728 |
|
P01 | Opt-out of the competence of the unified patent court (upc) registered |
Effective date: 20230506 |
|
PGFP | Annual fee paid to national office [announced via postgrant information from national office to epo] |
Ref country code: FRPayment date: 20230425Year of fee payment: 10Ref country code: DEPayment date: 20230427Year of fee payment: 10 |
|
PGFP | Annual fee paid to national office [announced via postgrant information from national office to epo] |
Ref country code: SEPayment date: 20230427Year of fee payment: 10 |
|
PGFP | Annual fee paid to national office [announced via postgrant information from national office to epo] |
Ref country code: GBPayment date: 20230427Year of fee payment: 10 |