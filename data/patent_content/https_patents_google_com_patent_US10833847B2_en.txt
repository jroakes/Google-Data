RELATED APPLICATION
This application is a non-provisional of, and claims priority to, U.S. Provisional Application No. 62/465,071, filed Feb. 28, 2017, titled “CRYPTOGRAPHIC HASH GENERATED USING DATA PARALLEL INSTRUCTIONS,” the disclosure of which is incorporated herein by reference.
BACKGROUND
Hash functions are mathematical operations run on arbitrary data. By comparing the output hash value from execution of the hash function to a known and expected hash value, the integrity of the input data can be determined. For example, computing the hash of a downloaded file and comparing the result to a previously published hash result for that file can show whether the download has been modified or tampered with. Hash functions are conventionally classified as non-cryptographic and cryptographic, which represents a strength/speed tradeoff. Non-cryptographic hash functions run faster than cryptographic hash functions, but are not as secure, making them most useful in time-sensitive tasks or in tasks where security need not be as strong, e.g., generating random numbers, bloom filters, and message authentication for short-lived messages. Cryptographic hash functions are much more secure, but run too slowly for large-scale or time-sensitive use. A key aspect of cryptographic hash functions is their collision resistance: two different input values should not result in the same hash output. Cryptographic hash functions are more collision resistant due to mixing of the input, which makes it difficult to find a pre-image, i.e., input that hashes to a given output. But mixing increases processing time, making cryptographic hash functions too slow for some uses.
SUMMARY
Implementations provide a much faster cryptographic hash function, referred to as a Secure Highway Hash, that is 5 to 10 times faster than Blake2, which is the next fastest known cryptographic hash function. The Secure Highway Hash takes advantage of multiplication and permutation operations in a parallel processing environment and achieve thorough mixing by processing the input twice. Disclosed implementations generate hash values as fast as non-cryptographic hash functions, but the hash values generated are much less vulnerable to attacks. Thus, disclosed implementations offer secure hash values to time-sensitive or large-scale processing systems. Example use cases are for generating unique fingerprints, random decisions (assigning to groups for AB tests), hash tables, secure messaging, and secure checksum for authentication.
According to one aspect, a system for generating a cryptographic hash includes at least one processor; and memory storing instructions that, when executed by the at least one processor, causes the computer system to perform operations. The operations may include, for each of a plurality of packets, each packing including data from an input file, updating an internal state using the packet. Updating the internal state using the packet may include injecting the packet into the internal state, mixing the bits of the internal state using multiplication, and shuffling the result of the multiplication so that bits with highest quality are permuted to locations that will propagate most widely in a next multiplication operation. Updating the internal state using the packet may further include performing a reduction on the internal state, injecting a dithering variable into the internal state, and repeating the update of the internal state, the modular reduction, and the injecting a second time. The operations may also include finalizing the internal state and storing a portion of the final internal state as a cryptographic hash of the input file.
According to one aspect, a method includes, updating an internal state for each of a plurality of packets, the packets being read from an input file. Updating the state for a packet can include injecting the packet into an internal state, mixing the bits of the internal state using multiplication, and shuffling the result of the multiplication so that bits with highest quality are permuted to locations that will propagate most widely in a next multiplication operation. The method may also include performing a reduction on the internal state, injecting a dithering variable into the internal state, and repeating the update of the internal state, the reduction, and the injecting a second time. The method may further include finalizing the internal state and storing a portion of the final internal state as a cryptographic hash of the input file.
According to one aspect, a method includes initializing an internal state for an input and updating, for each of a plurality of packets, the internal state with the packet using multiplication and bit shifting, the packet including information read from the input. The method also includes reducing the information in the internal state. The method further includes processing the plurality of packets a second time by repeating the updating, reducing, and injecting. The method also includes finalizing the internal state and storing a portion of the finalized internal state as a cryptographic hash of the input. The portion may be all of the finalized internal state. In some implementations, the method may also include injecting a dithering variable into the internal state after reducing the information in the internal state and prior to processing the plurality of packets a second time. The dithering variable may be a constant, a counter, or a combination of a constant and a counter.
In one general aspect, a computer program product embodied on a computer-readable storage device includes instructions that, when executed by at least one processor formed in a substrate, cause a computing device to perform any of the disclosed methods, operations, or processes. Another general aspect includes a system and/or a method for generating a cryptographic hash value using multiplication and permutation using parallel processing, substantially as shown in and/or described in connection with at least one of the figures, and as set forth more completely in the claims.
One or more of the implementations of the subject matter described herein can be implemented so as to realize one or more of the following advantages. For example, implementations compute a hash value five to ten times faster than known cryptographic hash functions, making them computationally much less expensive than other cryptographic hashes. This enables implementations to be used in processes previously unable to use cryptographic hashes, such as disk error detection or network packet authentication. Put another way, implementations lower the cost difference between safe and unsafe computing, making it easier for processes that previously employed less safe hash functions to now use a safe cryptographic hash. Thus, implementations eliminate the compromise between safety and speed for most functions. Thus, for example, implementations can be used in large-scale uses, such as file checksum, message authentication, hash tables, or generating random numbers, while providing better security than non-cryptographic hashes. Thus, disclosed implementations can save enormous amounts of CPU (central processing unit) time in data centers. As another example, systems and methods can generate a 64 to 256-bit hash without extra processing cycles.
The details of one or more implementations are set forth in the accompanying drawings and the description below. Other features will be apparent from the description and drawings, and from the claims.
BRIEF DESCRIPTION OF THE DRAWINGS
FIG. 1 is a block diagram illustrating an example system in accordance with the disclosed subject matter.
FIG. 2 illustrates a flow diagram of an example process for generating a fast, cryptographic hash value, in accordance with disclosed implementations.
FIG. 3 illustrates a flow diagram of an example process for updating the internal state of the hash, in accordance with disclosed implementations.
FIG. 4 is a pseudo-code example of process for updating the internal state of the hash using multiplication and shuffling, in accordance with disclosed implementations.
FIG. 5 is a block diagram illustrating the use of multiplication and shuffling to modify an internal state variable in a parallel processing environment, in accordance with disclosed implementations.
FIG. 6 is a block diagram illustrating a permutation used to initiate the internal state of the hash, in accordance with disclosed implementations.
FIG. 7 shows an example of a computer device that can be used to implement the described techniques.
FIG. 8 shows an example of a distributed computer device that can be used to implement the described techniques.
Like reference symbols in the various drawings indicate like elements.
DETAILED DESCRIPTION
Implementations include systems and methods that generate a cryptographic hash value for an input using multiplication and bit shuffling and a high degree of parallelism. Some implementations take advantage of modern CPUs that use single instruction, multiple data (SIMD) instructions. The systems and methods generate a cryptographic hash value five to ten times faster than Blake2, the next fastest cryptographic hash. Cryptographic hash functions conventionally require 2-3 CPU cycles-per-byte (c/b), but implementations can generate a hash value in less than 0.5 cycles per byte. Thus, implementations offer a hash function that eliminates the compromise between security and speed for most applications.
FIG. 1 is a block diagram of a multiplication-based hash system in accordance with an example implementation. The system 100 may be used to generate strong hash values with fewer processing cycles than conventional cryptographic hash functions. The system 100 may also be configured to provide cryptographic hash functions 5 to 10 times faster than the next-fastest cryptographic hash function (e.g., Blake2). The depiction of system 100 in FIG. 1 is a single computing device but implementations may also move some of the components to a server, making system 100 a client-server system. In addition, one or more components may be combined into a single module or engine, and some capabilities of the illustrated components may be performed by separate engines. In some implementations, system 100 may be incorporated into a larger system or sub-system. Thus, implementations are not limited to the exact configurations illustrated.
The multiplication-based hash system 100 includes a computing device 105. The computing device 105 may be implemented in a personal computer, for example a laptop computer, a smart phone, a wearable device (smart watch, smart glasses, etc.), a game console, a home appliance, etc. The computing device 105 may be an example of computer device 700, as depicted in FIG. 7. The computing device 105 may also be a computing device or devices that take the form of a number of different devices, for example a standard server, a group of such servers, or a rack server system. For example, computing device 105 may be implemented in a distributed manner across multiple computing devices. In addition, computing device 105 may be an example of system 800, as depicted in FIG. 8.
The computing device 105 may include one or more processors 170 formed in a substrate configured to execute one or more machine executable instructions or pieces of software, firmware, or a combination thereof. The processors 170 can be semiconductor-based—that is, the processors can include semiconductor material that can perform digital logic. The processors 170 may include multiple processing elements that provide a parallel execution environment, i.e., processing elements that perform an operation on multiple data points simultaneously. In other words, the processors 170 may employ single-instructions, multiple data (SIMD) instructions. SIMD instructions apply the same operation to multiple lanes of a vector. For example, a vector may include four lanes, each of the same size, e.g., 64 bits. A processor 170 with one SIMD vector can perform the same operation (e.g., addition, multiplication, etc.) on the four lanes at the same time. The one or more processors 170 may include one or more SIMD vectors, e.g., SIMID vector 170 a, SIMID vector 170 b, SIMID vector 170 n. In some implementations the vector lanes may be AVX2 (Advanced Vector Extensions 2) vector lanes, which is an expanded instruction set that works on 256 bit vectors.
The computing device 105 can also include one or more computer memories. The memories, for example, a main memory, may be configured to store one or more pieces of data, either temporarily, permanently, semi-permanently, or a combination thereof. The memories may include any type of storage device that stores information in a format that can be read and/or executed by the one or more processors. The memories may include volatile memory, non-volatile memory, or a combination thereof, and store modules or engines that, when executed by the one or more processors, perform certain operations. In some implementations, the modules may be stored in an external storage device and loaded into the memory of computing device 105.
The computing device 105 may include memory storing input 110. Input 110 may be any string or other digital content, e.g., a file, of any size. The input 110 represents the data to be hashed, or in other words, for which a hash value is calculated. The modules in the computing device 105 may include a comparison engine 150. The comparison engine 150 represents any process that uses a hash, e.g., a message checking process, a hash table generation/access process, a duplicate input detection process, a random number generator, a bloom filter, etc. While hash values are often used in comparisons, e.g., to determine if the input 110 has changed, to determine if the input 110 is a duplicate of some other input, to determine which row in a table to store information or from which row to retrieve information, the comparison engine 150 is understood to also include engines that employ one-time hash generation, e.g., for a random number. In some implementations, the comparison engine 150 may request a hash value be generated for the input 110. In some implementations, the comparison engine 150 may store the hash value for the input 110 in hash values 140. In some implementations the hash engine 120 may store the hash value for the input 110 in hash values 140. The hash values 140 may represent the result of the hash function performed by the hash engine 120 on a plurality of inputs 110. Although shown as part of computing device 105, comparison engine 150 and/or hash values 140 may also be remote from, but communicatively connected with computing device 105.
The modules of the multiplication-based hash system 100 may include the hash engine 120. The hash engine 120 may be configured to, for each unique input 110, initialize an internal state 122 using a key 126. The key 126 is some number not publicly known. The internal state 122 represents an internal hash sum that is manipulated by the hash engine 120 using the input 110 to generate the unique hash for the input 110. The internal state 122 is initialized using the key 126 and then manipulated using the input 110. The hash engine 120 is collision resistant, meaning that the hash value 140 generated for a particular input 110 should be different than the hash value 140 generated for a different input 110. In some implementations the internal state 122 is 1024 bits and the key 126 is 256 bits. At this size, attackers have a very low (e.g., 1 in 2256-64 chance) of guessing the key 126 after 264 inputs. The hash engine 120 may use the key 126 to initially populate the 1024 bits of the internal state 122. In some implementations, the internal state 122 may be partitioned into four portions, each of 256 bytes. The partitions of the internal state 122 may also be referred to as internal state variables. The hashing engine may expand the key 126 into the first partition by performing an exclusive-OR (XOR) operation on the key 126 and a first constant. The hash engine 120 may expand the key 126 into the second portion by permuting the bytes of the key 126 (e.g., illustrated in FIG. 6) and then performing an XOR operation between the permuted key and a second constant. The result of this XOR operation may be stored in the second portion of the internal state 122. In some implementations the first constant may be stored in the third portion of the internal state 122 and the second constant may be stored in the fourth portion of the internal state 122. This is one example of how the hashing engine 120 may initialize the internal state 122 using the key 126. This particular initialization is provided as one example, but implementations are not so limited. Other initialization procedures may use other operations, or operations in a different order, to initialize the internal state 122 using the key 126.
The hash engine 120 uses multiplication and shuffling to update the internal state 122. Updating the internal state 122 includes injecting the data from the input into the internal state 122. Injecting the data from the input can be done via an addition operation or an XOR operation. After the input is injected, the hash engine 120 may mix the internal state 122. Conventionally, hash functions mix bits of the internal state 122 via addition and exclusive-OR (XOR) operations. The more thoroughly mixed, the stronger the hash. But thorough mixing can be computationally expensive, so weaker but faster hash functions conventionally have less mixing and stronger but slower hash functions have more mixing.
Implementations compute a cryptographic hash quickly by using multiplication for mixing. In implementations that use SIMD lanes, the processor can perform multiplication in four lanes at once, with one half of a lane being the multiplicand supplied from a first vector variable and the other half of the lane being the multiplier supplied from a second vector variable. Thus, a vector of 256 bits can be separated into four lanes and four 32 bit by 32 bit multiplication operations performed in parallel, with the least significant bits of each lane e.g., 32 bits of each lane, being the multiplication operands. However, the mixing of the bits in each result of the four multiplication operations is uneven. More specifically, multiplication generates a result of mixed quality. For example, the bits in the high-order and low-order positions of the result are more predictable, i.e., of lower quality, than the bits in the middle. In other words, while the bits in the middle of the multiplication result are high quality and well mixed, the bits in the high-order and low-order positions of the result are low quality.
To address this unevenness, the hash engine 120 shuffles the bits of the multiplication results. The bit shuffling ensures that bits having the highest quality bits are relocated to locations that will propagate most widely in a next multiplication operation of the internal state 122. In some implementations the high quality bytes are moved to bytes that are the multiplier of the next multiplication. In some implementations, the multiplier bytes are the least significant bytes of a vector lane. To further increase the mixing of the internal state bytes, the shuffling may interleave adjacent vector lanes, so that some high quality bytes of one lane are moved to the neighboring lane, some low quality bytes of the lane are moved to the neighboring lane, and vice versa. Thus, the lanes are merged, with each lane receiving some low quality and some high quality bytes from the neighboring lane. This shuffling using interleaving of the lanes may be referred to as a zipperMerge( ). FIG. 5, discussed below, demonstrates an example of byte shuffling of the multiplication results that interleaves vector lanes. Shuffling may also include bit shuffling determined by an optimization algorithm.
To thoroughly mix the internal state the hash engine 120 may process the input 110 twice. After the internal state has been updated with all data in an input buffer 124 a first time, the hash engine 120 may process the input buffer 124 again. Before processing the input buffer 124 again, in some implementations, the system may perform modular reduction on the internal state and then inject a dithering variable 128 into the internal state. The modular reduction and dithering allows the buffer 124 to be processed inlined in a small amount (about 100) data parallel instructions. In addition, introduction of the dithering variable 128 ensures that an attacker does not control all the input. The dithering variable 128 can be a constant, a variable (e.g., a counter), or a combination of a constant and a counter (e.g., a counter multiplied by, added to, or XOR'd with a constant).
The hash engine 120 may include a buffer 124. The buffer 124 may hold data from input 110 to be injected into the internal state 122. If the input 110 is less than the size of the buffer 124, the buffer 124 may be padded. For example, an input 110 of 122 bytes may be padded with 2 bytes so that the buffer 124 has data that is a multiple of the vector size, e.g., a multiple of 32 bytes. In other implementations, the hash engine 120 may pad the entire input buffer 124 with data, e.g., padding the input 110 of 122 bytes with 126 bytes. Similarly, an input 110 of 250 bytes may be padded with 6 bytes. Padding can occur in a number of ways, as discussed in more detail with regard to FIG. 2. The hash engine 120 may process the input buffer 124 in packets, the packet size being the size of a vector. For example, the packets may be 256 bits. The hash engine 120 may process the packets one at a time, updating the internal state 122 with the packet data. If the input 110 is longer than the size of the buffer 124, i.e., the input 110 does not fit into the buffer 124, the hash engine 120 may read the first 256 bytes of the input 110 into the buffer 124, process the data in the input buffer 124, and then read in the next 256 bytes of the input 110, processing that data, etc. Thus, the hash engine 120 processes the input 110 in chunks the size of the input buffer 124, and pads the input buffer 124 as needed when the last chunk is read into the buffer 124. The multiplication-based hash system 100 of FIG. 1 represents example configuration but implementations may incorporate other configurations.
FIG. 2 illustrates a flow diagram of an example process 200 for generating a fast, cryptographic hash value, in accordance with disclosed implementations. Process 200 may be performed by a multiplication-based hash system, such as system 100 of FIG. 1. In some implementations, process 200 is run by a hash engine, such as hash engine 120. Process 200 may be invoked by another program, e.g., comparison engine 150, that requests a hash for an input, e.g., input 110. Process 200 may generate a hash value for the input. The hash value may be used in various ways, depending on the calling program. Some uses may be as a random number, a hash-table lookup, message authentication, a bloom filter, hash fingerprints, etc. Process 200 may execute once for each input for which a hash value is requested. The input can be a string, a message, a number, a document, or any other type of file or digital data.
Process 200 may initialize an internal state using a key (205). The key is provided by the program requesting the hash value. For a hash requested for authentication purposes, the key is conventionally unknown to attackers and generated by a secure source of randomness. For other purposes, the key can be public. The internal state is an internal hash sum that is initialized and then updated with the input and mixed to generate the hash value for the input. In other words, manipulations on the internal state using the input generate the hash value for the input. Because implementations use multiplication to mix the internal state, the initialization of the internal state should be configured to have a sufficient number of bits set, i.e., bits that are not zero. In some implementations, a sufficient number is reached when about half of the bits in each vector of the internal state are set. In some implementations, the system may set bits according to bit position. For example, in an internal state with four vectors, each vector having bit positions 0 to 255, the system may count the number of bits set at each of the given positions. If the system finds zero or one bits set at a given bit position, the system may set that bit position in the fourth vector to one. In some implementations, the internal state is 1024 bits and the key is 256 bits. Internal states that are smaller than 1024 bits are useful for CPUs that do not have 256 bit vectors, but smaller internal states are more prone to collisions. Internal states larger than 1024 bits increase processing time without a proportional benefit.
Initialization of the internal state using the key includes expanding the key to populate the larger internal state. Initialization can take several forms, so long as the internal state, once initialized, has sufficient bits set (i.e., set to one). In some implementations, the internal state may be partitioned into four equally-sized portions, also referred to as variables. With a 1024-bit internal state each partition or variable is 256 bits, which is the size of a SIMD vector. Thus, SIMD operations can be performed on any of the internal state variables. In some implementations, the system may set a first variable and a second variable using the key. For example, the system may initialize the first variable (e.g., labeled v0) to the result of an XOR operation or an addition operation between the key and a first constant. The system may initialize the second variable (e.g., labeled v1) to the result of an XOR or addition operation between a permutation of the key using SIMD instructions and a second constant. In some implementations, the system may permute the key, which is the size of a vector, by swapping the 128-bit vector halves (e.g., lanes 0/1 and lanes 2/3) and also 32-bit lane halves, as illustrated in FIG. 6. In some implementations, the permute may shuffle the lanes of the key using a SIMD operation, e.g., _mm256_permutevar8×32_eip32. In some implementations, the third variable (e.g., labeled mul0) may be set to the first constant and the fourth variable (e.g., labeled mul1) may be set to the second constant. These examples are provided as one example of initialization of the internal state, but implementations are not limited to the initialization described. As indicated above, the system may use any initialization based on the key that results in sufficient bits being set.
The system may then read input data into the input buffer (210). The input buffer is a multiple of the size of a vector. In some implementations, the input buffer is 256 bytes and the vector is 32 bytes (256 bits). While the remainder of the explanation of process 200 assumes a buffer of 256 bytes, implementations can have input buffers of larger or smaller size. If the input data is larger than 256 bytes only the first 256 bytes is read into the buffer.
The system blocks the input buffer into packets the size of the vector, e.g., into 256 bit (32 byte) packets. (215). If the input data is less than 256 bytes, or if the remainder of the input data is less than 256 bytes, the system may pad the last packet of the input buffer. In other words, if the input data is 34 bytes (or the remainder of the input data is 34 bytes) and the vector size is 32 bytes, the system pads at least 30 bytes in the input buffer, so that the input buffer includes data for two complete packets. In some implementations, the system may pad the remaining 222 bytes of the input buffer, but this lengthens the processing time for generating the hash. The padding ensures that the data provided to the vector operations that update the internal state are controlled and hash values repeatable for the same input. The system may pad the packets using one of a variety of methods.
In some implementations, the system may encode the length of the padding into the packet. For example, the system may insert the size modulo 256, encoded in a single byte, into the padded bytes. As another example, the system may insert the size modulo 32. Thus, the value of the padded bytes is set based on the number of bytes to be padded. In some implementations, the system may not pad the input buffer with the length, but may modify the internal state directly when a packet from the input buffer is less than the vector size. For example, the system may inject the quantity of bytes to be padded when the packet is injected into the internal state, e.g., as a first step in updating the state with the packet. The system may calculate the quantity of bytes to be padded by calculating the size of the packet modulo 32. In some implementations, the system may then add this number to every half-lane in a portion of the internal state, e.g., in v0, and then rotate each half-lane of another portion of the state by that number, e.g., in v1. In some implementations, the system may select one or more bytes from some known position and use those bytes to pad the packet. For example, the system may use a _mm_maskload_epi32 instruction to load multiples of four bytes from an intermediate buffer into the packet. If remaining bytes to be padded is not a multiple of four, the system may load one to three bytes individually, e.g., using a single conditional branch. In this manner the system may set a value of each of the bytes to be padded to the value of one of the four bytes in the intermediate buffer.
Once the input buffer is blocked into packets, the system may begin updating the internal state using the packets, one packet at a time (220). Updating the internal state with a packet includes injecting the packet into the internal state, mixing the bits of the internal state using multiplication, and shuffling the bits in the result of the multiplication so that high quality bits from the multiplication result are placed in locations that will propagate most widely in the next permutation. In some implementations, the multiplier propagates most widely. In some implementations, the system may use an optimization algorithm to choose the shuffling order so that the result of repeated multiplications and shuffling has maximum entropy. The update process is described in more detail with regard to FIG. 3. The system updates the internal state with each packet from the input buffer, so if there are additional packets that have not been used to update the internal state (225, Yes), the system obtains the next packet and updates the internal state with that packet (220). Once all packets have been used to update the internal state (225, No), the system performs reduces the information in the internal state (230). The reduction may be accomplished by a modular reduction. A modular reduction may be accomplished by a modulo function, which is a SIMD special instruction. The reduction may also be accomplished by discarding some of the bits in the internal state. For example, in some implementations the system may discard all the bytes in a lane (e.g., 8 bytes) of the internal state. As another example, some implementations may discard half-lanes in adjacent lanes. In some implementations, up to 50% of the bits in the internal state may be discarded.
The system may then inject a dithering variable into the internal state (235). Injecting the dithering variable re-populates the information in the internal state. The re-population may be done based on the dithering variable, which can be a constant, a counter, or some combination of these. The dithering variable ensures that an attacker cannot control all of the input. In some implementations, the dithering variable can be used to repopulate the lanes that were discarded as part of the reduction.
The system may then determine whether the data in the input buffer has been processed twice (240). If the input buffer has not been processed twice (240, No), the system may repeat steps 220 to 235 a second time. Once the input buffer has been processed a second time (240, Yes), the system may determine whether all input data has been read into the input buffer (245). If there is additional data from the input to read into the buffer (245, Yes), the system repeats steps 210 to 240 with the next 256 bytes of input.
Once all data from the input has been read into the input buffer and processed twice (245, No), the system may finalize the state by reducing the information in the internal state (250). In some implementations the system may use the reduction performed in step 230. In other words, the system may use modular reduction on the internal state or may discard up to 50% of the information in the internal state.
In some implementations, the system may, if the internal state is not already partitioned into four partitions, partition the internal state into four equal-sized partitions and combine the four partitions. For example, the system may add together the four portions, which reduces the internal state from 1024 bits to 256 bits. As another example, the system may XOR the four portions, which also reduces the internal state from 1024 bits to 256 bits. As another example the system may reduce the internal state from 1024 bits to 512 bits by adding or XORing the two halves of the internal state together.
Once the internal state is reduced, the system may then select the hash value from the finalized state (255). If a 64-bit hash value is desired, the system may retain 64 bits of the finalized state. In some implementations, the system may use the 64 bits in the lower lane, which is slightly easier to extract from SIMD registers into general purpose registers. If a longer hash value is desired, the system may provide the desired length, e.g., 128 bits or all 256 bits of the finalized internal state, as the hash value. Thus, the system can provide a 64-bit hash to a 256-bit hash without increasing the processing time. Depending on how the hash value is used, it may be stored or used to compare against a stored hash value. Process 200 then ends.
FIG. 3 illustrates a flow diagram of an example process 300 for updating the internal state of the hash using multiplication and shuffling, in accordance with disclosed implementations. Process 300 may be performed as part of step 220 of FIG. 2. Process 300 may have access to the internal state and may take, as a parameter, a packet to be injected into the internal state, which is then mixed by multiplication and the multiplication result shuffled, so that the high-quality bits of the multiplication result are moved to positions that will propagate most widely in a next update of the internal state.
Process 300 begins by injecting the packet into the internal state (305). Injecting is conventionally accomplished via an addition operation or an XOR operation. Thus, the system may add or XOR the packet with the internal state. In some implementations, the system may inject the packet into a particular portion of the internal state. For example, where the internal state comprises four equal sized portions, the system may inject the packet into one of the portions, e.g., v1. In some implementations, the system may also inject a second portion of the internal state, e.g., mul0, into the v1 portion.
The system may dither the multiplication operands (310). Dithering the multiplication operands allows for more thorough mixing at multiplication time. Dithering may be accomplished using a bitmask that has the most significant bit and the least significant bit set to one. The system may perform an OR operation between the bitmask and each of the multiplication operands. The multiplication operands are the 32-bit halves of a lane. Thus, to dither the multiplication operands, the system ORs each 32-bits of the vector with a 32-bit bitmask having the most significant bit and least significant bits set to one and all other bits set to zero. The dithering of step 310 is optional, but does increase mixing.
The system may mix the bits of the internal state via multiplication (315). In some implementations, the system may mix portions of the internal state using multiplication, and use other areas of the internal state to hold the result of the multiplication. In some implementations, the system may, as part of holding the result, inject the multiplication result into the data already in that portion of the internal state. For example, as explained above, the internal state may be stored as four variables. The system may multiply these portions together. More specifically, using SIMD instructions, the system may multiply the lowest four vector elements, which is the lower 32 bits of each 64-bit lane, of a first portion (e.g., v0) with the highest four elements, which is the higher 32 bits of each 64-bit lane, of a second portion (e.g., v1), e.g., using a _mm_256_mul_epu32( ) SIMD instruction and inject the result in another portion of the state, e.g., mul0. Likewise, the system may multiply the lowest four vector elements, which is the lower 32 bits of each 64-bit lane, of the second portion (e.g., v1) with the highest four elements, which is the higher 32 bits of each 64-bit lane, of a second portion (e.g., v0), e.g., using a _mm_256_mul_epu32( ) SIMD instruction and inject the result in another portion of the state, e.g., mul1. In addition, the system may further modify the internal state by injecting one portion of the state into another portion, e.g., injecting mul1 into v0, or the like.
The system may then shuffle the multiplication results so that bits with highest quality are moved to locations that will propagate most widely in a next round of multiplication (320). This shuffling may include interleaving the bytes of adjacent vector lanes. Thus, the shuffling may be referred to as a zipper merge. One example of the shuffling is explained in more detail below with regard to FIG. 5. In some implementations, the system may use an optimization algorithm to choose the shuffling order so that the result of repeated multiplications and shuffling has maximum entropy. In other words, the optimization algorithm used in shifting may enable a single bit change in the internal state or in the input data may have a maximum expected entropy on the internal state. In some implementations, the optimization algorithm may be a search algorithm that tries all combinations and chooses the best. In some implementations, the optimization algorithm may be a genetic algorithm or another stochastic search. After shuffling, process 300 ends. Process 300 represents an update performed on the internal state.
FIG. 4 is a pseudo-code example of a process for updating the internal state of the hash using multiplication and shuffling, in accordance with disclosed implementations. Example 400 is one example implementation of process 300 of FIG. 3 without the optional dithering. In the example of FIG. 4, the internal state 122 is represented by four variables, each of 256 bits (or 32 bytes). The four variables are v0, v1, mul0, and mul1. In the example of FIG. 4, the packet provided to the process is injected into v1, as illustrated at 405. V1 may be further modified by injection of the mul0 variable. The mul0 variable may then be modified via multiplication of the lower four elements of v1 multiplied by the upper four elements of v0. The upper four elements of v0 are shifted, so that they move into the lower four elements, because the SIMD instruction illustrated in example 400 operates on the lowest four elements of the vector. The v0 variable is then injected with the mul1 variable and then mul1 is then modified via multiplication of the lower four elements of v0 multiplied by the upper four elements of v1 (again, shifting the upper elements of v1 into the lower 4 elements). The modification of the internal state using multiplication is thus represented by 410 of FIG. 4. The system may then shuffle the multiplication results so that bits with highest quality are moved to locations that will propagate most widely in a next multiplication. This shuffling is represented by items 415 of FIG. 4. The ZipperMerge( ) function interleaves two adjacent lanes of the vector and, at the same time, moves the higher quality bytes to the least significant bits of the vector lane.
FIG. 5 is a block diagram illustrating the use of multiplication and shuffling to modify an internal state variable in a parallel processing environment, in accordance with disclosed implementations. In FIG. 5, a vector 505 includes four lanes, each of 8 bytes. The vector 505 is thus 256 bits. In some implementations, the SIMD instructions operate on four 64-bit lanes. Thus, each 8 bytes of the vector are assigned to a lane. The system can perform the same operation on all four lanes. Thus, for example, the system can perform four multiplication operations in parallel, each 32×32 bits. Each vector provides the 32 least significant bits in each lane for multiplication. Thus, in lane 0, the 32 bits of vector 502 is the multiplicand, designated by 510, and the 32 bits of vector 505 is the multiplier, designated by 515. Similarly in lane 1 the least significant 32 bits of vector 502 is multiplied by the least significant 32 bits of vector 505. FIG. 5 illustrates the multiplication 315 of two neighboring lanes for the sake of brevity, but it is understood that the system may perform the multiplication across all four lanes in parallel.
In the example of FIG. 5 the result of the multiplication in lane 0 in result 525 and the result of the multiplication in lane 1 in result 530. The bytes of the result 525 are labeled as 0 through 7, and the bytes of the result 530 are labeled as 8 through F. These labels represent byte positions for the ease of discussion and not the actual multiplication results. The middle bytes of the multiplication result, e.g., 2-5 of result 525 and A-D in result 530 are of higher quality than the bytes at either end. The higher quality bytes are more thoroughly mixed and less predictable than the lower quality bytes. Although FIG. 5 illustrates the result of the multiplication being provided directly to the shuffling, implementations are not so limited. For example, the result may undergo some type of injection (addition or XOR) prior to permutation, as illustrated in FIG. 4.
To achieve more even mixing, the system shuffles the middle bytes of the results 525 and 530, illustrated with shading in FIG. 5, to the multiplier positions, so that the multiplier bytes are uniformly good. This operation is an example of a zipperMerge( ), e.g., item 415 of FIG. 4 or the shuffling step 320 of FIG. 3. In addition to concentrating the higher quality bytes (e.g., byte positions 2-5 and A-D) into the multiplier, the system also increases mixing by interleaving bytes of similar quality from the neighboring SIMD lane. Thus, for example, the high quality bytes in positions A, B, and D are moved from lane 1 to lane 0 and the high quality bytes in positions 2, 3, and 5 are moved from lane 0 to lane 1. Similarly, the low-quality bytes are concentrated in the multiplicand and interleaved. Thus, for example, bytes in position 8 and 9 are moved from lane 1 to lane 0 and bytes 0 and 1 are moved from lane 0 to lane 1. The result of the shuffling of the high quality bytes is represented in the example of FIG. 5 as 535 and 540, which represent half of the vector. Although not shown in FIG. 5 for the sake of brevity, a similar shuffling occurs between lanes 2 and 3. Thus, the shuffling operates on all 32 bytes of the vector.
FIG. 6 is a block diagram illustrating a permutation used to initialize the internal state of the hash, in accordance with disclosed implementations. For example, a vector 605 of 256 bits (e.g., the key) may be provided for permutation. The vector 605 represents four lanes of 64-bits, or eight half-lanes of 32 bits. In the example of FIG. 6 the half-lanes are labeled 0 to 7 at 610. These labels do not represent the bit values, just a label for each half-lane. Before the permutation, the half-lanes are ordered 7 6 5 4 3 2 1 0. The permutation re-orders the half-lanes by swapping the two 128-bit halves and swapping the 32-bit half-lanes. Thus, the shuffling may re-order the half-lanes so that the half-lanes are now ordered 2 3 0 1 6 7 4 5, as illustrated at 620. This result, illustrated at 620 is the result of the permutation of the vector 605 provided. The permutation of FIG. 6 can be used during initialization of the internal state, e.g., to permute the key. Of course, FIG. 6 is one example of the permutation and implementations can include other similar permutation patterns.
Implementations provide a cryptographic hash with fewer cycles per second (c/s) than conventional cryptographic hash functions. Conventional cryptographic hash functions, such as BLAKE2, range from 2.5 to 63 cycles per byte, depending on the size of the input, wherein disclosed implementations measure slightly less than 0.5 cycles per byte for large inputs.
A paper by Alakuijala et al., titled “Fast keyed hash/pseudo-random function using SIMD multiply and permute” first published at https://arxiv.org/abs/1612.06257, on Dec. 19, 2016, is also included here by reference. The paper describes a predecessor to an implementation of the disclosed subject matter.
FIG. 7 shows an example of a generic computer device 700, which may be operated as server 110, and/or client 150 of FIG. 1, which may be used with the techniques described here. Computing device 700 is intended to represent various example forms of computing devices, such as laptops, desktops, workstations, personal digital assistants, cellular telephones, smartphones, tablets, servers, and other computing devices, including wearable devices. The components shown here, their connections and relationships, and their functions, are meant to be examples only, and are not meant to limit implementations of the inventions described and/or claimed in this document.
Computing device 700 includes a processor 702, memory 704, a storage device 706, and expansion ports 710 connected via an interface 708. In some implementations, computing device 700 may include transceiver 746, communication interface 744, and a GPS (Global Positioning System) receiver module 748, among other components, connected via interface 708. Device 700 may communicate wirelessly through communication interface 744, which may include digital signal processing circuitry where necessary. Each of the components 702, 704, 706, 708, 710, 740, 744, 746, and 748 may be mounted on a common motherboard or in other manners as appropriate.
The processor 702 can process instructions for execution within the computing device 700, including instructions stored in the memory 704 or on the storage device 706 to display graphical information for a GUI on an external input/output device, such as display 716. Display 716 may be a monitor or a flat touchscreen display. In some implementations, multiple processors and/or multiple buses may be used, as appropriate, along with multiple memories and types of memory. Also, multiple computing devices 700 may be connected, with each device providing portions of the necessary operations (e.g., as a server bank, a group of blade servers, or a multi-processor system).
The memory 704 stores information within the computing device 700. In one implementation, the memory 704 is a volatile memory unit or units. In another implementation, the memory 704 is a non-volatile memory unit or units. The memory 704 may also be another form of computer-readable medium, such as a magnetic or optical disk. In some implementations, the memory 704 may include expansion memory provided through an expansion interface.
The storage device 706 is capable of providing mass storage for the computing device 700. In one implementation, the storage device 706 may be or include a computer-readable medium, such as a floppy disk device, a hard disk device, an optical disk device, or a tape device, a flash memory or other similar solid state memory device, or an array of devices, including devices in a storage area network or other configurations. A computer program product can be tangibly embodied in such a computer-readable medium. The computer program product may also include instructions that, when executed, perform one or more methods, such as those described above. The computer- or machine-readable medium is a storage device such as the memory 704, the storage device 706, or memory on processor 702.
The interface 708 may be a high speed controller that manages bandwidth-intensive operations for the computing device 700 or a low speed controller that manages lower bandwidth-intensive operations, or a combination of such controllers. An external interface 740 may be provided so as to enable near area communication of device 700 with other devices. In some implementations, controller 708 may be coupled to storage device 706 and expansion port 714. The expansion port, which may include various communication ports (e.g., USB, Bluetooth, Ethernet, wireless Ethernet) may be coupled to one or more input/output devices, such as a keyboard, a pointing device, a scanner, or a networking device such as a switch or router, e.g., through a network adapter.
The computing device 700 may be implemented in a number of different forms, as shown in the figure. For example, it may be implemented as a standard server 730, or multiple times in a group of such servers. It may also be implemented as part of a rack server system. In addition, it may be implemented in a computing device, such as a laptop computer 732, personal computer 734, or tablet/smart phone 736. An entire system may be made up of multiple computing devices 700 communicating with each other. Other configurations are possible.
FIG. 8 shows an example of a generic computer device 800, which may be server 110 of FIG. 1, which may be used with the techniques described here. Computing device 800 is intended to represent various example forms of large-scale data processing devices, such as servers, blade servers, datacenters, mainframes, and other large-scale computing devices. Computing device 800 may be a distributed system having multiple processors, possibly including network attached storage nodes, that are interconnected by one or more communication networks. The components shown here, their connections and relationships, and their functions, are meant to be examples only, and are not meant to limit implementations of the inventions described and/or claimed in this document.
Distributed computing system 800 may include any number of computing devices 880. Computing devices 880 may include a server or rack servers, mainframes, etc. communicating over a local or wide-area network, dedicated optical links, modems, bridges, routers, switches, wired or wireless networks, etc.
In some implementations, each computing device may include multiple racks. For example, computing device 880 a includes multiple racks 858 a-858 n. Each rack may include one or more processors, such as processors 852 a-852 n and 862 a-862 n. The processors may include data processors, network attached storage devices, and other computer controlled devices. In some implementations, one processor may operate as a master processor and control the scheduling and data distribution tasks. Processors may be interconnected through one or more rack switches 858, and one or more racks may be connected through switch 878. Switch 878 may handle communications between multiple connected computing devices 880.
Each rack may include memory, such as memory 854 and memory 864, and storage, such as 856 and 866. Storage 856 and 866 may provide mass storage and may include volatile or non-volatile storage, such as network-attached disks, floppy disks, hard disks, optical disks, tapes, flash memory or other similar solid state memory devices, or an array of devices, including devices in a storage area network or other configurations. Storage 856 or 866 may be shared between multiple processors, multiple racks, or multiple computing devices and may include a computer-readable medium storing instructions executable by one or more of the processors. Memory 854 and 864 may include, e.g., volatile memory unit or units, a non-volatile memory unit or units, and/or other forms of computer-readable media, such as a magnetic or optical disks, flash memory, cache, Random Access Memory (RAM), Read Only Memory (ROM), and combinations thereof. Memory, such as memory 854 may also be shared between processors 852 a-852 n. Data structures, such as an index, may be stored, for example, across storage 856 and memory 854. Computing device 880 may include other components not shown, such as controllers, buses, input/output devices, communications modules, etc.
An entire system, such as system 100, may be made up of multiple computing devices 880 communicating with each other. For example, device 880 a may communicate with devices 880 b, 880 c, and 880 d, and these may collectively be known as system 100. As another example, system 100 of FIG. 1 may include one or more computing devices 880. Some of the computing devices may be located geographically close to each other, and others may be located geographically distant. The layout of system 800 is an example only and the system may take on other layouts or configurations.
According to certain aspects of the disclosure, a system for generating a cryptographic hash includes at least one processor; and memory storing instructions that, when executed by the at least one processor, causes the computer system to perform operations. The operations may include, for each of a plurality of packets, each packing including data from an input file, updating an internal state using the packet. Updating the internal state using the packet may include injecting the packet into the internal state, mixing the bits of the internal state using multiplication, and shuffling the result of the multiplication so that bits with highest quality are permuted to locations that will propagate most widely in a next multiplication operation. Updating the internal state using the packet may further include performing a reduction on the internal state, injecting a dithering variable into the internal state, and repeating the update of the internal state, the modular reduction, and the injecting a second time. The operations may also include finalizing the internal state and storing a portion of the final internal state as a cryptographic hash of the input file.
This and other aspects can include one or more of the following features. For example, the mixing by multiplication may be performed on 256 bits in parallel using four Single Instruction Multiple Data (SIMD) vector lanes. In some implementations, the shuffling causes bytes with highest quality to be permuted to low order bytes of a SIMD vector lane and remaining bytes to be permuted to high order bytes of the SIMD vector lane. In some implementations, the shuffling interleaves neighboring vector lanes so that at least some highest quality bytes from a first lane of the neighboring lanes and at least some highest quality bytes from a second lane of the neighboring lanes are moved to a location in the first lane. As another example, an optimization algorithm may select the shuffling order. As another example, reduction on the internal state may include a modular reduction. As another example, reduction on the internal state may include discarding at least one vector lane of the internal state. As another example, the dithering variable may be a constant, a counter, or a combination of a constant and a counter. As another example, the portion stored as the cryptographic hash may be the entire finalized-state. As another example, the portion stored as the cryptographic hash is a portion in a lower lane of a 4-lane Single Instruction Multiple Data (SIMD) processor. As another example, when the input is not a multiple of 32 bytes, the operations may also include determining a value of a byte at a particular position and setting a value of each of the bytes to be padded to the value of the byte at the particular position. As another example, when the input is not a multiple of 32 bytes, the operations may also include determining a quantity of bytes to be padded and injecting the quantity with the packet into the internal state. As another example, the operations may also include reading an input file into an input buffer and blocking the input buffer into the packets. In some implementations, the operations may also include, when the input file exceeds a size of the input buffer, repeating the reading, blocking, and updating of the internal state with each of the packets until reaching an end of the input file, wherein updating the internal state with the packet-sized portion occurs after reaching the end of the input file. As another example, the operations may also include initializing the internal state using a key.
According to one aspect, a method includes, updating an internal state for each of a plurality of packets, the packets being read from an input file. Updating the state for a packet can include injecting the packet into an internal state, mixing the bits of the internal state using multiplication, and shuffling the result of the multiplication so that bits with highest quality are permuted to locations that will propagate most widely in a next multiplication operation. The method may also include performing a reduction on the internal state, injecting a dithering variable into the internal state, and repeating the update of the internal state, the reduction, and the injecting a second time. The method may further include finalizing the internal state and storing a portion of the final internal state as a cryptographic hash of the input file.
This and other aspects can include one or more of the following features. For example, the mixing by multiplication may be performed on 256 bits in parallel using four Single Instruction Multiple Data (SIMD) vector lanes. In some implementations, the shuffling causes bytes with highest quality to be permuted to low order bytes of a SIMD vector lane and remaining bytes to be permuted to high order bytes of the SIMD vector lane. In some implementations, the shuffling interleaves neighboring vector lanes so that at least some highest quality bytes from a first lane of the neighboring lanes and at least some highest quality bytes from a second lane of the neighboring lanes are moved to a location in the first lane. As another example, an optimization algorithm may select the shuffling order. As another example, reduction on the internal state may include a modular reduction. As another example, reduction on the internal state may include discarding at least one vector lane of the internal state. As another example, the dithering variable may be a constant, a counter, or a combination of a constant and a counter. As another example, the portion stored as the cryptographic hash may be the entire finalized-state. As another example, the portion stored as the cryptographic hash is a portion in a lower lane of a 4-lane Single Instruction Multiple Data (SIMD) processor. As another example, the method may also include determining that the input file exceeds a size of an input buffer, and repeating the reading, blocking, and updating of the internal state with each of the packets until reaching an end of the input file, wherein finalizing the internal state with the packet-sized portion occurs after reaching the end of the input file. As another example, the method may also include determining that a last packet is not a multiple of the packet size, determining a number of bytes to be padded to make the last packet a multiple of the packet size, determining a value of a byte at a particular position, and setting a value of each of the bytes to be padded to the value of the byte at the particular position. As another example, the method may also include determining that a last packet is not a multiple of the packet size, determining a quantity of bytes to be padded in the last packet, and injecting the quantity into the internal state with the packet. As another example, the method may also include reading an input file into an input buffer and blocking the input buffer into the packets. The packets may be a size of a vector lane in a SIMD processor. As another example, the method may include dithering the multiplication operands prior to mixing the bits. In some implementations, dithering may include setting a most significant bit and a leas significant bit in the operands to one.
According to one aspect, a method includes initializing an internal state for an input and updating, for each of a plurality of packets, the internal state with the packet using multiplication and bit shifting, the packet including information read from the input. The method also includes reducing the information in the internal state. The method further includes processing the plurality of packets a second time by repeating the updating, reducing, and injecting. The method also includes finalizing the internal state and storing a portion of the finalized internal state as a cryptographic hash of the input. The portion may be all of the finalized internal state. In some implementations, the method may also include injecting a dithering variable into the internal state after reducing the information in the internal state and prior to processing the plurality of packets a second time. The dithering variable may be a constant, a counter, or a combination of a constant and a counter.
This and other aspects can include one or more of the following features. For example, updating the packet using multiplication and bit shifting may include injecting the packet into the internal state, multiplying two portions of the state together, and shuffling the result of the multiplication so that bits with highest quality are permuted to locations that will propagate most widely in a next multiplication operation. In some implementations mixing by multiplication may be performed on 256 bits in parallel using four Single Instruction Multiple Data (SIMD) vector lanes. In some implementations, the shuffling causes bytes with highest quality to be permuted to low order bytes of a SIMD vector lane and remaining bytes to be permuted to high order bytes of the SIMD vector lane. As another example, the bit shifting may include interleaving neighboring SIMD vector lanes so that at least some highest quality bytes from a first lane of the neighboring lanes and at least some highest quality bytes from a second lane of the neighboring lanes are moved to a location in the first lane. As another example, an optimization algorithm may select the shuffling order. As another example, reducing the information in the internal state may include a modular reduction. As another example, reducing the information in the internal state may include discarding at least one vector lane of the internal state. As another example, the method may include using the cryptographic hash in message authentication, a bloom filter, and/or duplicate input detection.
According to one aspect, a computing device comprises at least one processor and memory storing instructions that, when executed by the at least one processor cause a computing device to perform the method of any one of the methods disclosed herein.
Various implementations can include implementation in one or more computer programs that are executable and/or interpretable on a programmable system including at least one programmable processor, which may be special or general purpose, coupled to receive data and instructions from, and to transmit data and instructions to, a storage system, at least one input device, and at least one output device.
These computer programs (also known as programs, software, software applications or code) include machine instructions for a programmable processor, and can be implemented in a high-level procedural and/or object-oriented programming language, and/or in assembly/machine language. As used herein, the terms “machine-readable medium” “computer-readable medium” refers to any non-transitory computer program product, apparatus and/or device (e.g., magnetic discs, optical disks, memory (including Read Access Memory), Programmable Logic Devices (PLDs)) used to provide machine instructions and/or data to a programmable processor.
The systems and techniques described here can be implemented in a computing system that includes a back end component (e.g., as a data server), or that includes a middleware component (e.g., an application server), or that includes a front end component (e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the systems and techniques described here), or any combination of such back end, middleware, or front end components. The components of the system can be interconnected by any form or medium of digital data communication (e.g., a communication network). Examples of communication networks include a local area network (“LAN”), a wide area network (“WAN”), and the Internet.
The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
A number of implementations have been described. Nevertheless, various modifications may be made without departing from the spirit and scope of the invention. In addition, the logic flows depicted in the figures do not require the particular order shown, or sequential order, to achieve desirable results. In addition, other steps may be provided, or steps may be eliminated, from the described flows, and other components may be added to, or removed from, the described systems.