US20240126827A1 - Transferable Neural Architecture for Structured Data Extraction From Web Documents - Google Patents
Transferable Neural Architecture for Structured Data Extraction From Web Documents Download PDFInfo
- Publication number
- US20240126827A1 US20240126827A1 US18/538,584 US202318538584A US2024126827A1 US 20240126827 A1 US20240126827 A1 US 20240126827A1 US 202318538584 A US202318538584 A US 202318538584A US 2024126827 A1 US2024126827 A1 US 2024126827A1
- Authority
- US
- United States
- Prior art keywords
- word
- level
- node
- vectors
- vector
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
- 238000013075 data extraction Methods 0.000 title 1
- 230000001537 neural effect Effects 0.000 title 1
- 238000000034 method Methods 0.000 claims abstract description 64
- 238000012545 processing Methods 0.000 claims abstract description 28
- 238000013528 artificial neural network Methods 0.000 claims abstract description 26
- 239000013598 vector Substances 0.000 claims description 220
- 230000015654 memory Effects 0.000 claims description 15
- 230000006403 short-term memory Effects 0.000 claims description 7
- 230000002457 bidirectional effect Effects 0.000 claims description 5
- 238000005516 engineering process Methods 0.000 abstract description 12
- 238000010586 diagram Methods 0.000 description 14
- 238000013527 convolutional neural network Methods 0.000 description 13
- 239000011159 matrix material Substances 0.000 description 8
- 238000000605 extraction Methods 0.000 description 6
- 239000000284 extract Substances 0.000 description 5
- 238000011176 pooling Methods 0.000 description 5
- 238000009877 rendering Methods 0.000 description 5
- 238000013459 approach Methods 0.000 description 3
- 238000004422 calculation algorithm Methods 0.000 description 3
- 230000006870 function Effects 0.000 description 3
- 238000004458 analytical method Methods 0.000 description 2
- 230000008901 benefit Effects 0.000 description 2
- 238000004891 communication Methods 0.000 description 2
- 238000001914 filtration Methods 0.000 description 2
- 238000002955 isolation Methods 0.000 description 2
- 238000013515 script Methods 0.000 description 2
- 238000012549 training Methods 0.000 description 2
- 230000000007 visual effect Effects 0.000 description 2
- 241001632422 Radiola linoides Species 0.000 description 1
- 238000011161 development Methods 0.000 description 1
- 239000000446 fuel Substances 0.000 description 1
- HDKLIZDXVUCLHQ-UHFFFAOYSA-N non-3-en-2-one Chemical compound CCCCCC=CC(C)=O HDKLIZDXVUCLHQ-UHFFFAOYSA-N 0.000 description 1
- 238000010606 normalization Methods 0.000 description 1
- 230000003287 optical effect Effects 0.000 description 1
- 229920002803 thermoplastic polyurethane Polymers 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/95—Retrieval from the web
- G06F16/958—Organisation or management of web site content, e.g. publishing, maintaining pages or automatic linking
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N5/00—Computing arrangements using knowledge-based models
- G06N5/02—Knowledge representation; Symbolic representation
- G06N5/022—Knowledge engineering; Knowledge acquisition
- G06N5/025—Extracting rules from data
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/95—Retrieval from the web
- G06F16/958—Organisation or management of web site content, e.g. publishing, maintaining pages or automatic linking
- G06F16/986—Document structures and storage, e.g. HTML extensions
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/95—Retrieval from the web
- G06F16/957—Browsing optimisation, e.g. caching or content distillation
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F40/00—Handling natural language data
- G06F40/10—Text processing
- G06F40/12—Use of codes for handling textual entities
- G06F40/14—Tree-structured documents
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/044—Recurrent networks, e.g. Hopfield networks
- G06N3/0442—Recurrent networks, e.g. Hopfield networks characterised by memory or gating, e.g. long short-term memory [LSTM] or gated recurrent units [GRU]
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/045—Combinations of networks
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/0464—Convolutional networks [CNN, ConvNet]
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/044—Recurrent networks, e.g. Hopfield networks
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
- G06N3/084—Backpropagation, e.g. using gradient descent
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N5/00—Computing arrangements using knowledge-based models
- G06N5/02—Knowledge representation; Symbolic representation
Definitions
- the present technology relates to systems and methods for efficiently extracting machine- actionable structured data from web documents.
- the technology is able to utilize the raw Hypertext Markup Language (“HTML”) content of a small set of seed websites to create transferrable models regarding information of interest. Those models can then be applied to the raw HTML of other websites to identify similar information of interest without further human input, and to extract it as structured data for further use by the system and/or other systems.
- HTML Hypertext Markup Language
- the technology is thus less computationally expensive than systems and methods that rely upon visual rendering and can provide improved results tailored to the information of interest.
- the present technology provides an enhanced technical benefit by generating models that can be used across multiple domains, to enable extraction of machine-actionable structured data in a functional form that can be used by further systems.
- the disclosure describes a computer-implemented method of extracting machine-actionable data.
- the method comprises: generating, by one or more processors of a processing system, a document object model tree for a first page of a first website, wherein the document object model tree comprises a plurality of nodes, and each node in the plurality of nodes includes an XML Path (“XPath”) and content; identifying, by the one or more processors, a first node of the plurality of nodes, wherein the content of the first node comprises a first sequence of words, and each word in the first sequence comprises one or more characters; identifying, by the one or more processors, a second node of the plurality of nodes, wherein the content of the second node comprises a second sequence of words, each word in the second sequence comprises one or more characters, and the second sequence precedes the first sequence on the first page; generating, by the one or more processors, a word-level vector corresponding to each word of the first sequence and the second sequence;
- generating the character-level word vector corresponding to each word of the first sequence and the second sequence comprises, for each word in the first sequence, encoding a character vector corresponding to each of the one or more characters using a convolutional neural network, and, for each word in the second sequence, encoding a character vector corresponding to each of the one or more characters using a convolutional neural network.
- generating the sequence-level vector based on the word-level vectors and the character-level word vectors corresponding to the first sequence comprises encoding the character-level word vector and the word-level vector of each word of the first sequence using a bidirectional long short-term memory neural network.
- generating the sequence-level vector based on the word-level vectors and the character-level word vectors corresponding to the second sequence comprises encoding the character-level word vector and the word-level vector of each word of the second sequence using a bidirectional long short-term memory neural network.
- generating the node label for the first node based on the comprehensive vector for the first node comprises encoding the comprehensive vector for the first node using a multi-layer perceptron neural network to obtain a classification for the first node.
- the node label for the first node corresponds to one of a plurality of fields-of-interest.
- the method may further comprise: generating, by the one or more processors, a second document object model tree for a second page of the first website, wherein the second document object model tree comprises a second plurality of nodes, and each node in the second plurality of nodes includes an XPath and content; and extracting, by the one or more processors, a second set of structured data from the second plurality of nodes, wherein the second set of structured data associates the content of each node in the second plurality of nodes with a node label for each node in the second plurality of nodes.
- the method may additionally comprise: generating, by the one or more processors, a third document object model tree for a page of a second website, wherein the third document object model tree comprises a third plurality of nodes, and each node in the third plurality of nodes includes an XPath and content; and extracting, by the one or more processors, a third set of structured data from the third plurality of nodes, wherein the third set of structured data associates the content of each node in the third plurality of nodes with a node label for each node in the third plurality of nodes.
- the disclosure describes a computer-implemented method of extracting data, comprising: generating, by one or more processors of a processing system, a document object model tree for a first page of a first website, wherein the document object model tree comprises a first plurality of nodes, and each node in the first plurality of nodes includes an XML Path (“XPath”) and content; generating, by the one or more processors, a prediction for each node of the first plurality of nodes regarding whether the node relates to one of a plurality of fields-of-interest; generating, by the one or more processors, a plurality of node-pairs from the first plurality of nodes, wherein each node-pair of the plurality comprises a head node and tail node; generating, by the one or more processors, a comprehensive vector corresponding to each head node and each tail node; generating, by the one or more processors, an XPath vector corresponding to each head node and each
- generating the XPath vector corresponding to each head node and each tail node comprises encoding the XPaths of each head node and each tail node using a long short-term memory neural network.
- generating the comprehensive vector corresponding to each head node and each tail node comprises: for each head node, concatenating a sequence-level vector corresponding to a sequence of words in the head node, a sequence-level vector corresponding to a sequence of words in a node preceding the head node, and a discrete-features vector corresponding to one or more predefined features in the content of the head node; and for each tail node, concatenating a sequence-level vector corresponding to a sequence of words in the tail node, a sequence-level vector corresponding to a sequence of words in a node preceding the tail node, and a discrete-features vector corresponding to one or more predefined features in the content of the tail node.
- generating a pair label for each node-pair based on the pair-level vector comprises encoding the pair-level vector for each node-pair using a multi-layer perceptron neural network to obtain a classification for each node-pair.
- the node labels correspond to one of the plurality of fields-of-interest or a null identifier.
- the method may further comprise: generating, by the one or more processors, a second document object model tree for a second page of the first website, wherein the second document object model tree comprises a second plurality of nodes, and each node in the second plurality of nodes includes an XPath and content; and extracting, by the one or more processors, a second set of structured data from the second plurality of nodes, wherein the second set of structured data associates the content of each node in the second plurality of nodes with a node label for each node in the second plurality of nodes.
- the method may additionally comprise: generating, by the one or more processors, a third document object model tree for a page of a second website, wherein the third document object model tree comprises a third plurality of nodes, and each node in the third plurality of nodes includes an XPath and content; and extracting, by the one or more processors, a third set of structured data from the third plurality of nodes, wherein the third set of structured data associates the content of each node in the third plurality of nodes with a node label for each node in the third plurality of nodes.
- the method may further comprise: generating, by one or more processors, a second document object model tree for a second page of the first website, wherein the second document object model tree comprises a second plurality of nodes, and each node in the second plurality of nodes includes an XPath and content; generating, by the one or more processors, a node label for each node of the second plurality of nodes; identifying, by the one or more processors, a class of nodes from the first plurality of nodes and the second plurality of nodes, wherein the node label for each node in the class of nodes is the same; identifying, by the one or more processors, a first XPath that is a most common XPath in the class of nodes; and extracting, by the one or more processors, from each node in the first plurality of nodes and the second plurality of nodes that has the first XPath, a second set of structured data that associates the content of the node with the no
- the disclosure describes a processing system for extracting machine-actionable data.
- the processing system comprises a memory, and one or more processors coupled to the memory and configured to: generate a document object model tree for a first page of a first website, wherein the document object model tree comprises a plurality of nodes, and each node in the plurality of nodes includes an XML Path (“XPath”) and content; identify a first node of the plurality of nodes, wherein the content of the first node comprises a first sequence of words, and each word in the first sequence comprises one or more characters; identify a second node of the plurality of nodes, wherein the content of the second node comprises a second sequence of words, each word in the second sequence comprises one or more characters, and the second sequence precedes the first sequence on the first page; generate a word-level vector corresponding to each word of the first sequence and the second sequence; generate a character-level word vector corresponding to each word of the first sequence and the second sequence; generate a sequence-level vector based
- the disclosure describes a processing system for extracting machine-actionable data, comprising a memory, and one or more processors coupled to the memory and configured to: generate a document object model tree for a first page of a first website, wherein the document object model tree comprises a first plurality of nodes, and each node in the first plurality of nodes includes an XML Path (“XPath”) and content; generate a prediction for each node of the first plurality of nodes regarding whether the node relates to one of a plurality of fields-of-interest; generate a plurality of node-pairs from the first plurality of nodes, wherein each node-pair of the plurality comprises a head node and tail node; generate a comprehensive vector corresponding to each head node and each tail node; generate an XPath vector corresponding to each head node and each tail node; generate a positional vector corresponding to each head node and each tail node based at least in part on a position of each head node
- FIG. 1 is a functional diagram of an example system in accordance with aspects of the disclosure.
- FIG. 2 is a diagram showing how a section of HTML may be represented as a DOM Tree.
- FIG. 3 is a flow diagram of an exemplary method in accordance with aspects of the disclosure.
- FIG. 4 is a flow diagram of an exemplary method in accordance with aspects of the disclosure.
- FIG. 5 is a flow diagram of an exemplary method in accordance with aspects of the disclosure.
- FIG. 6 is a diagram showing how an exemplary phrase may be processed in accordance with aspects of the disclosure.
- FIG. 7 is a flow diagram of an exemplary method in accordance with aspects of the disclosure.
- FIG. 8 is a flow diagram of an exemplary method in accordance with aspects of the disclosure.
- FIG. 9 is a flow diagram of an exemplary method in accordance with aspects of the disclosure.
- FIG. 10 is a flow diagram of an exemplary method in accordance with aspects of the disclosure.
- FIG. 11 is a flow diagram of an exemplary method in accordance with aspects of the disclosure.
- FIG. 12 is a flow diagram of an exemplary method in accordance with aspects of the disclosure.
- FIG. 13 is a flow diagram of an exemplary method in accordance with aspects of the disclosure.
- FIG. 1 schematically illustrates an arrangement 100 with an exemplary processing system 102 for performing the methods described herein.
- the processing system 102 includes one or more processors 104 and memory 106 storing instructions and data.
- the one or more processors 104 may include the various modules described herein, and the instructions and data may include the various neural networks described herein.
- the processing system 102 is shown being in communication with various websites, including websites 110 and 118 , over one or more networks 108 .
- Exemplary websites 110 and 118 each include one or more servers 112 a - 112 n and 120 a - n , respectively.
- Each of the servers 112 a - 112 n and 120 a - n may have one or more processors (e.g., 114 and 122 ), and associated memory (e.g., 116 and 124 ) storing instructions and data, including the HTML of one or more webpages.
- processors e.g., 114 and 122
- memory e.g., 116 and 124
- the processing system 102 may not be in direct communication with the websites, and may instead process stored versions of the HTML of the websites to be processed.
- Processing system 102 may be implemented on different types of computing device(s), such as any type of general computing device, server, or set thereof, and may further include other components typically present in general purpose computing devices or servers.
- the memory 106 stores information accessible by the one or more processors 104 , including instructions and data that may be executed or otherwise used by the processor(s) 104 .
- the memory may be of any non-transitory type capable of storing information accessible by the processor(s) 104 .
- the memory may include a non-transitory medium such as a hard-drive, memory card, optical disk, solid-state, tape memory, or the like.
- Computing devices suitable for the roles described herein may include different combinations of the foregoing, whereby different portions of the instructions and data are stored on different types of media.
- the computing devices described herein may further include any other components normally used in connection with a computing device such as a user interface subsystem.
- the user interface subsystem may include one or more user inputs (e.g., a mouse, keyboard, touch screen and/or microphone) and one or more electronic displays (e.g., a monitor having a screen or any other electrical device that is operable to display information).
- Output devices besides an electronic display, such as speakers, lights, and vibrating, pulsing, or haptic elements, may also be included in the computing devices described herein.
- the one or more processors included in each computing device may be any conventional processors, such as commercially available central processing units (“CPUs”), tensor processing units (“TPUs”), etc.
- the one or more processors may be a dedicated device such as an ASIC or other hardware-based processor.
- Each processor may have multiple cores that are able to operate in parallel.
- the processor(s), memory, and other elements of a single computing device may be stored within a single physical housing, or may be distributed between two or more housings.
- the memory of a computing device may include a hard drive or other storage media located in a housing different from that of the processor(s), such as in an external database or networked storage device. Accordingly, references to a processor or computing device will be understood to include references to a collection of processors or computing devices or memories that may or may not operate in parallel, as well as one or more servers of a load-balanced server farm or cloud-based system.
- the computing devices described herein may store instructions capable of being executed directly (such as machine code) or indirectly (such as scripts) by the processor(s).
- the computing devices may also store data, which may be retrieved, stored, or modified by one or more processors in accordance with the instructions.
- Instructions may be stored as computing device code on a computing device-readable medium.
- the terms “instructions” and “programs” may be used interchangeably herein.
- Instructions may also be stored in object code format for direct processing by the processor(s), or in any other computing device language including scripts or collections of independent source code modules that are interpreted on demand or compiled in advance.
- the programming language may be C#, C++, JAVA or another computer programming language.
- any components of the instructions or programs may be implemented in a computer scripting language, such as JavaScript, PHP, ASP, or any other computer scripting language.
- any one of these components may be implemented using a combination of computer programming languages and computer scripting languages.
- processing system 102 could be configured to extract structured data from websites.
- processing system 102 could be configured to use a site-specific extraction program or “wrapper” for each website from which data is to be extracted.
- site-specific approaches generally require either a human to analyze the site and create a wrapper to be used by the extraction program, or that the pages of the website be sufficiently well-annotated that the extraction program can accurately identify the preselected fields-of-interest without human input.
- the wrappers created for one site will not be transferrable to a different site.
- Fields-of-interest may be any categories of information that are selected for extraction. For example, for a website relating to automobiles, fields-of-interest may include model name, vehicle type, gas mileage, engine size, engine power, engine torque, etc.
- neural networks can be trained on a set of rendered webpages to identify information of interest using various visual cues.
- visual-rendering approaches can generate models that allow fields-of-interest to be identified and extracted from other websites, they require careful feature-engineering with domain-specific knowledge in order to generate the models, and are computationally expensive due to the rendering.
- the present technology provides neural network architectures that can use the text of a set of seed websites to create transferrable extraction models with minimal or no human input, and without the need for rendering. Those extraction models can then be used to identify and extract information of interest in the text of additional websites without the need for any rendering of webpages.
- a processing system first applies a node-level module to a set of selected seed websites.
- the seed websites may be chosen based on various attributes. For example, some websites will already include annotations that identify various fields-of-interest.
- the pages for each vehicle may have a table with a row that states “model” and then lists the model name, a row that states “engine” and then lists the engine size, a row that states “gas mileage” and then lists the gas mileage, etc.
- the node-level module parses the raw HTML of each page of each seed web site as Document Object Model (“DOM”) Trees. This converts each page into a tree structure, in which each branch ends in a node, and each node includes an XML Path (“XPath”) and its associated HTML content.
- DOM Document Object Model
- XPath XML Path
- FIG. 2 shows how a section of HTML 202 may be represented as a DOM Tree 204 . While the nodes of the DOM Tree 204 are shown in FIG. 2 as empty circles, in actuality they would include the HTML content associated with each node.
- the node-level module next identifies all nodes that contain text, and filters the list of all such textual nodes to remove those that are unlikely to convey information of interest. This can be done, for example, by collecting all possible XPaths (node identifiers) of textual nodes in a given website, ranking the XPaths by the number of different text values associated with each XPath, and identifying some subset of those that have two or more different values as the nodes-of-interest.
- a flow diagram 300 showing this exemplary filtering method is included as FIG. 3 .
- the node-level module parses the raw HTML of a webpage as a DOM Tree.
- the node-level module identifies all nodes of the DOM Tree that contain text.
- the node-level module identifies all XPaths that are associated with the textual nodes of the DOM Tree.
- the node-level module ranks all XPaths according to how many different text values are associated with each such XPath.
- the node-level module identifies as the “nodes-of-interest” the top N XPaths that have two or more different text values.
- the node-level module may rank the XPaths by the number of different values associated with them, and select the top 500 XPaths (or more or less) that have at least two different values. Filtering in this way will remove most of the nodes that have common values across multiple pages, and therefore are more likely to represent generic text of the pages in that website such as the name of the website, navigation text, headers, footers, copyright information, etc.
- the node-level module next encodes the filtered set of textual nodes (the “nodes-of-interest”) using the text of each node, the text preceding each node, and one or more discrete features (e.g., content in the raw HTML that may be helpful in identifying fields-of-interest).
- the filtered set of textual nodes the “nodes-of-interest”
- discrete features e.g., content in the raw HTML that may be helpful in identifying fields-of-interest.
- the node-level module breaks each node's text down into a sequence of words W, consisting of ⁇ w 1 , w 2 , . . . , w
- ⁇ be the original text of the node, or may be the results of subjecting the original text to lexical analysis, such as by tokenizing and lemmatizing the original text using the Natural Language Toolkit (“NLTK”).
- NLTK Natural Language Toolkit
- each word w i can be expressed according to Equation 1 below as being an element of W.
- a “word” need not be comprised of letters, and can thus include text comprised of numbers and/or symbols, such as “$1,000.”
- the node-level module further breaks each word w i into a sequence of characters C, consisting of ⁇ c 1 , c 2 , . . . , c
- each character c j can be expressed according to Equation 2 as being an element of C.
- a character-embedding lookup table E c is also initialized, as shown in step 406 .
- Step 406 may take place before steps 402 and/or 404 .
- Character-embedding lookup table E c is defined according to Equation 3, in which dim c is a hyperparameter representing the dimension of character-embedding vectors, and is a symbol representing all real numbers.
- character-embedding lookup table E c is a matrix of shape
- the character-embedding vectors of E c are randomly initialized, and then updated during model training through back-propagation.
- the dimension of character-embedding vectors may be any suitable number, such as 100 (or more or less).
- step 408 for each word w i , a character-embedding vector is generated for each character c j using character-embedding lookup table E c .
- step 410 a convolutional neural network (“CNN”) is used to encode the entire sequence of character-embedding vectors for each word w i , and then pool them to create a character-level word vector c i corresponding to word w i .
- Character-level word vector c i can thus be expressed according to Equation 4 below.
- the exemplary phrase “city 25 hwy 32” is processed to create individual character-embedding vectors for each word 602 a - 602 d .
- Each set of character-embedding vectors for each word is then fed into CNN 606 and pooled to create corresponding character-level word vectors 608 a - 608 d .
- the CNN may be implemented with any suitable parameters.
- the CNN may employ a kernel size of 3 (or more or less), a filter size of 50 (or more or less), and may apply max pooling to select the maximum value from each row of the resulting matrix and thus reduce each row to a single value.
- a word-level vector lookup table E. is also initialized for each word w i .
- step 412 may take place before any or all of steps 402 - 410 .
- Word-level vector lookup table E w is defined according to Equation 5 below, in which dim w , is a hyperparameter representing the dimension of word-level vectors.
- the word-level vectors in E w may be generated from various known algorithms, such as Stanford's GloVe.
- word-level vector lookup table E w is a matrix of shape
- the dimension of character-embedding vectors may be any suitable number, such as 100 (or more or less).
- a word-level vector w i for each word w i is generated using word-level vector lookup table E w .
- the word-level vector w i is concatenated with the character-level word vectors c i created by the CNN to create a concatenated word vector t i for every word w i in each node. This is shown in Equation 6 below, in which [ ⁇ ⁇ circle around ( ⁇ ) ⁇ ⁇ ] denotes concatenation operations.
- each word 604 a - 604 d of the phrase “city 25 hwy 32 ” is processed to create corresponding word-level vectors 610 a - 610 d .
- Those word-level vectors 610 a - 610 d are then concatenated with the associated character-level word vectors 608 a - 608 d to form concatenated word vectors 612 a - 612 d.
- LSTM long short-term memory
- the forward and backward LSTM encoding steps are also shown pictorially by dashed lines 614 and 616 of FIG. 6 , respectively.
- the LSTM network encodes the sets in two directions, it can also be referred to as a bidirectional long short-term memory neural network. While the LSTM network will have the same structure in both directions, the parameters will be different for the forward and backward encoding operations.
- the LSTM network may employ any suitable number of units, such as 100 (or more or less).
- Equation 7 AVG [ ⁇ ⁇ circle around ( ⁇ ) ⁇ ⁇ ] denotes average or mean pooling operations, and in which LSTM f and LSTMb denote the LSTM operations in the forward and backward directions, respectively. This is also shown pictorially in FIG.
- n node_text AVG[LSTM f ( ⁇ t 1 , t 2 , . . . , t
- Encoding both the words and the characters of each node's text as described above enables the node-level module to identify patterns shared across nodes even where the individual words of a given node may be unknown (e.g., misspellings, abbreviations, etc.), or where the text of the node includes numbers or special characters.
- a node may contain text such as “city 25 hwy 32” as shown in FIG.
- the node-level module may only determine that these nodes share the words “city” and “hwy,” the latter of which may not even be recognized as a word as it is merely an abbreviation. But by combining the results of the character-level CNN and word-level LSTM operations as described above, the node-level module can identify that these nodes in fact share a pattern of “city ## hwy ##.” Importantly, the node-level module can do this without requiring human input.
- the node-level module also encodes the text that precedes each node-of-interest. This encoding may be performed for some fixed amount of preceding text.
- the node-level module processes the preceding text in the same manner described above with respect to FIGS. 4 - 6 , resulting in a second vector n prev-text .
- the steps of FIGS. 4 and 5 need not take place before those of FIGS. 7 and 8 . Rather, the node-level module may process the preceding text before, after, or simultaneously with its processing of the node text.
- the node-level module breaks down the text preceding a node-of-interest into a sequence of X words.
- X may be any number, such as 10 words (or more or fewer words).
- the sequence of X words may be the original text that preceded the node-of-interest, or may be the results of subjecting that preceding text to lexical analysis, such as by tokenizing and lemmatizing it using the NLTK toolkit.
- the node-level module breaks each of the X words into a sequence of characters in the same manner described above with respect to step 404 of FIG. 4 .
- the node-level module initializes a character-embedding lookup table in the same manner described above with respect to step 406 of FIG. 4 .
- step 706 of FIG. 7 may take place before steps 702 and/or 704 .
- the node-level module may utilize the same character-embedding lookup table for the processes of both FIGS. 4 and 7 , in which case steps 406 and 706 would each describe a single instance of initializing a character-embedding lookup table.
- the node-level module encodes the characters of each of the X words using the character-embedding lookup table to create corresponding character-embedding vectors, in the same manner described above with respect to step 408 of FIG. 4 .
- the node-level module encodes the corresponding sequence of character-embedding vectors using a CNN and then pools them to create a character-level word vector for each word, in the same manner described above with respect to step 410 of FIG. 4 .
- Step 710 may use the same CNN used in connection with step 410 of FIG. 4 , or may use a separate CNN.
- the node-level module initializes a word-level vector lookup table in the same manner described above with respect to step 412 of FIG. 4 .
- step 712 of FIG. 7 may take place before any or all of steps 702 - 710 of FIG. 7 .
- the node-level module may utilize the same word-level vector lookup table for the processes of both FIGS. 4 and 7 , in which case steps 412 and 712 would each describe a single instance of initializing a word-level vector lookup table.
- the node-level module encodes the word using the word-level vector lookup table to create a corresponding word-level vector in the same manner described above with respect to step 414 of FIG. 4 .
- the node-level module concatenates the corresponding word-level vector and character-level word vector to create a concatenated word representation for the word, in the same manner described above with respect to step 416 of FIG. 4 .
- steps 802 and 804 of FIG. 8 for the sequence of X words, the node-level module encodes the corresponding concatenated word representations (created in step 716 of FIG. 7 ) in both the forward and backward directions using an LSTM network, in the same manner described above with respect to steps 502 and 504 of FIG. 5 , respectively.
- steps 802 and 804 may use the same LSTM network used in connection with steps 502 and 504 , or may use a separate LSTM network.
- step 806 the results of the forward and backward LSTM encoding operations are subjected to mean pooling to arrive at the final representation of the preceding text of the node-of-interest, n prev_text , in the same manner described above with respect to generating n node_text in step 506 of FIG. 5 .
- Encoding the preceding text of each node as described above can further aid in distinguishing between nodes of similar content.
- the node-level module may be programmed to identify gas mileage values on each page.
- a given page may thus include a first node with the text “25,” and a second node with the text “32.”
- the text of these two nodes may not, in isolation, contain enough information to determine if either represents a gas mileage value.
- the text preceding those nodes will contain descriptive words such as “gas mileage,” “fuel economy,” “miles per gallon,” “highway mileage,” or some other text that strengthens or weakens that inference.
- the node-level module also checks the text of each node against a set of preselected discrete features as shown in flow 900 of FIG. 9 . This results in a third vector n dis_feat ,
- the steps of FIGS. 4 - 8 need not take place before those of FIG. 9 . Rather, the node-level module may check for discrete features before, after, or simultaneously with its processing of the node text and/or the preceding text.
- the node-level module initializes a discrete-features lookup table E d containing a preselected set of discrete features of interest.
- These discrete features may be anything in the raw HTML that is determined to be helpful in identifying fields-of-interest.
- the leaf tag type e.g., ⁇ hl>, ⁇ div>, ⁇ li>, ⁇ span>
- ⁇ hl >nodes are often more likely to include key information, such as the model name of a vehicle being displayed on the page.
- discrete-features lookup table E d is thus defined according to Equation 8 below, in which D is the set of all identified discrete features, and dim d is a hyperparameter representing the dimension of discrete-feature vectors.
- the dimension of discrete-feature vectors may be any suitable number, such as 30 (or more or less).
- the node-level module then generates a vector d in which each of the preselected discrete features present for a given node are represented as non-negative integers. For example, if the preselected discrete features for a given set of websites are ⁇ gas mileage, date, zip code ⁇ , and the node-of-interest has two gas mileage values, one date, and no zip codes, then vector d for that node would have a value of ⁇ 2, 1, 0 ⁇ . Thus, vector d is defined according to Equation 9 below, in which ⁇ 0 is a symbol representing all non-negative integers.
- step 906 of FIG. 9 for each node-of-interest, the node-level module multiplies the vector d representing the discrete features with the discrete-features lookup table E d using matrix multiplication according to Equation 10 below. This results in a single vector n dis_feat , which is a final representation of the discrete features present in the node-of-interest.
- the node-level module uses the resulting n node_text , n prev_text , and n dis_feat vectors for each node to generate a prediction of whether the node corresponds to one of a set of predefined fields-of-interest.
- fields-of-interest may include Model Name, Vehicle Type, Engine, and Gas Mileage
- the node-level module will use the final vectors generated for each node to predict whether that node corresponds to any of those fields-of-interest. If so, the node will be labeled according to the field-of-interest to which it corresponds. If not, the node will be labeled with some null identifier such as “none” or “null.” This process is set forth in further detail below with respect to flow 1000 of FIG. 10 .
- the node-level module concatenates the final representations of the text of a node-of-interest (n node_text ), the text preceding the node-of-interest (n prev_text ), and the discrete features present in the node-of-interest (n dis_feat ) to create a single vector n, which is a comprehensive representation of each node.
- Vector n is thus described according to Equation 11 below.
- n [n node_text ⁇ circle around ( ⁇ ) ⁇ n prev_text ⁇ circle around ( ⁇ ) ⁇ n dis_feat ] (11)
- the node-level module connects vector n to a multi-layer perceptron (MLP) neural network for multi-class classification via a SoftMax function.
- MLP multi-layer perceptron
- the node-level module will predict a label l for each node-of-interest.
- label l can be any one of a number of K predefined fields, or a null identifier (e.g., “none,” “null,” etc.), there are K+1 possible values for 1 .
- the SoftMax normalization can be described according to Equations 12 and 13 below, where label l will be one of the set ⁇ f 1 , . . . , f K , none ⁇ .
- This MLP network may be implemented with any suitable parameters.
- the MLP network may be a one-layer dense neural network containing K+1 nodes, such that the output h is a vector of length K+1.
- the node-level module is capable of predicting a label 1 for each node-of-interest based solely on the text of the node, its preceding text, and selected discrete features of the node.
- the node-level module's predictions are each made in isolation for a single node-of-interest, they do not take into account what predictions have been made for other nodes. In some circumstances, this may result in the node-level module assigning the same label to multiple nodes on a page, while failing to assign other labels to any node on the page.
- the technology can also employ a second-stage module that processes pairs of nodes through a relational neural network, as shown in flow 1100 of FIG. 11 .
- the second-stage module may process every possible node-pair on a given webpage, or some subset thereof, in which case the processing would begin with step 1110 of FIG. 11 .
- this may not be feasible in all circumstances.
- the node-level module identifies and encodes 300 nodes on a page
- there would be 89,700 node-pairs for the second-stage module to process i.e., 300 ⁇ 299, as the order of the head and tail nodes matters in this context
- the second-stage module may instead divide the fields-of-interest into two groups as shown in steps 1102 and 1104 of FIG. 11 .
- the second-stage module identifies all fields for which the node-level module predicted at least one node, which will be referred to going forward as “certain fields.” Likewise, in step 1104 , the second-stage module identifies all fields for which the node-level module was unable to predict any node, which will be referred to going forward as “uncertain fields.” Then, in step 1108 , the second-stage module will create all possible node-pairs from the following sets of nodes. For each certain field, the second-stage module will use the node predicted for that field.
- the second-stage module will use the top m nodes (e.g., m may between 5 and 20, or more or less) according to the h i score that was generated for that field by the node-level module according to Equations 12 and 13 above. This will result in three types of node-pairs.
- the nodes for each certain field will be paired with the nodes for all other certain fields. Thus, if there are T certain fields, there will be T(T ⁇ 1) node-pairs that consist entirely of nodes for of two certain fields.
- the nodes for each certain field will be paired with the top m nodes identified for each uncertain field.
- node_pairs (T(T—1)+2T(m(K ⁇ T))+m 2 (K ⁇ T)(K ⁇ T ⁇ 1)) (14)
- the second-stage module then processes each node-pair (nhead, ntaii) through a relational neural network in order to predict a pair-label (l head , l tail ). To do this, the second-stage module processes the node-pairs in two ways based on the assumption that two nodes that are closer to each other are more likely to be similar to each other.
- the second-stage module processes each node-pair according to the XPaths of the head and tail nodes.
- each XPath can be seen as a sequence of HTML tags such as “ ⁇ html>,” “ ⁇ body>,” “ ⁇ div>,” “ ⁇ ul>,” and “ ⁇ li>.”
- the second-stage module maintains an embedding matrix for all the possible HTML tags, where each tag is represented as a vector.
- An LSTM network (which may be a different network than the LSTM networks used by the node-level module) then uses that matrix to encode each node-pair based on their XPaths, as shown in Equation 15 below. This results in vectors n head xpath and n tail xpath for the head and tail nodes, respectively.
- the LSTM network may employ any suitable number of units, such as 100 (or more or less).
- n xpath LSTM([tag 1 , tag 2 , . . . ]) (15)
- the second-stage module processes each node-pair according to its position on the raw HTML page relative to other nodes.
- the second-stage module will then initialize a position-embedding look-up table E pos indexed according to each positional value, in which each positional value is associated with a position-embedding vector.
- the position-embedding vectors of E pos are randomly initialized, and then updated during model training through back-propagation.
- the second-stage module uses the position-embedding look-up table E pos to obtain vectors n head pos and n tail pos for the positions of the head and tail nodes of each node-pair, respectively.
- the second-stage module also makes use of the comprehensive node vectors n that were generated by the node-level module for each head and tail node, i.e., the n vectors generated pursuant to Equation 11 above.
- the second-stage module concatenates the comprehensive node vectors, n head and n tail , with the vectors n head xpath and n head xpath (from Equation 15) and n head pos and n tail pos to arrive at a single comprehensive node-pair vector r, as shown in Equation 16 below.
- the second-stage module then connects the comprehensive node-pair vector r with an MLP network (which may be a different network than the MLP network used by the node-level module) for multi-class classification via a SoftMax function.
- MLP network may be implemented with any suitable parameters.
- the MLP network may be a one-layer dense neural network containing four nodes, such that the output is a 1 x 4 vector.
- the vector output by the MLP is then normalized by the SoftMax function.
- the second-stage module assigns a normalized label to each node-pair.
- the normalized labels are selected from the set of ⁇ “none-none”, “none-value”, “value-none”, “value-value” ⁇ .
- the second-stage module utilizes the nodes predicted by the first stage module as the final prediction(s) for that field.
- the second-stage module determines whether any of the m nodes that were originally identified as candidates for that field have been classified as “value” in any of the node-pairs in which they have been included. If so, in step 1210 , the second-stage module uses that field as the final prediction for that node. For example, for a field F, and a candidate node y (which was one of the m nodes that were originally identified as candidates for field F), there may be four node-pairs involving node y.
- the processing system extracts structured data from each identified node of each page of each seed website. Importantly, the technology allows the processing system to extract this web data in a structured form that preserves the association between the data and its predicted field-of-interest.
- the extracted data may comprise data extracted about automobiles with four fields-of-interest, in which the data is associated with the label for each of those fields, e.g., ⁇ Model Name
- the data is in a structured form which is machine-actionable, allowing it to be used in controlling operation of the processing system and/or other systems for a variety of purposes.
- the structured data can be used to improve search results in a search engine, or to create databases from disparate data sources.
- the structured data from websites or HTML-based emails or messages may be used by an automated assistant to provide answers to questions, or to automatically add events to a user's calendar. These examples are, of course, not intended to be limiting.
- the second-stage module may also utilize an additional heuristic method for improving the model's predictions.
- the nodes associated with a particular field may have a relatively small number of XPaths across individual pages.
- the second-stage module can rank, for each field-of-interest f k , which XPath was most often predicted for that field across all pages.
- the second-stage module can extract data from the most commonly-predicted XPath for that field. This extraction can be done in addition to extracting data from whatever node(s) were indicated by the first set of predictions for that field, as described above with respect to FIG. 12 .
- the processing system can perform the same processing steps to generate final predictions for an additional set of non-seed websites. These additional final predictions can then be used to extract further structured data from those non-seed websites in the same manner described above.
- the models built by the neural networks will more accurately be able to identify fields-of-interest in non-seed websites which may have data that is not as well annotated, organized, current, and/or complete.
- the present technology thus enables generation of models with little or no human input that are then transferrable, such that structured, functional data can efficiently be extracted across multiple domains.
Abstract
Systems and methods for efficiently identifying and extracting machine-actionable structured data from web documents are provided. The technology employs neural network architectures which process the raw HTML content of a set of seed websites to create transferrable models regarding information of interest. These models can then be applied to the raw HTML of other websites to identify similar information of interest. Data can thus be extracted across multiple websites in a functional, structured form that allows it to be used further by a processing system.
Description
- The present application is a continuation of U.S. patent application Ser. No. 17/792,788, filed Jul. 14, 2022, which a national phase entry under 35 U.S.C. § 371 of International Application No. PCT/US2020/015602, filed Jan. 29, 2020, published in English, the entire disclosure of which is incorporated herein by reference.
- Since the advent of the Internet, there has been a need for systems and methods of gathering, organizing, and presenting the information from multiple websites so that users can effectively and efficiently find what they are looking for. This can be seen in the continuing development of search engines and algorithms, which allow users to identify and visit websites that contain information of interest. In addition, with the introduction of artificial intelligence- based recommendation systems and automated digital assistants, it has become possible to obtain information without personally visiting the source website. As the amount of information available on the Internet continues to grow, it becomes increasingly difficult for computing systems to effectively parse and catalog relevant information.
- The present technology relates to systems and methods for efficiently extracting machine- actionable structured data from web documents. Using various neural network architectures, the technology is able to utilize the raw Hypertext Markup Language (“HTML”) content of a small set of seed websites to create transferrable models regarding information of interest. Those models can then be applied to the raw HTML of other websites to identify similar information of interest without further human input, and to extract it as structured data for further use by the system and/or other systems. The technology is thus less computationally expensive than systems and methods that rely upon visual rendering and can provide improved results tailored to the information of interest. In addition, unlike other text-based methods that require specific extraction programs to be built for each domain, the present technology provides an enhanced technical benefit by generating models that can be used across multiple domains, to enable extraction of machine-actionable structured data in a functional form that can be used by further systems.
- In one aspect, the disclosure describes a computer-implemented method of extracting machine-actionable data. The method comprises: generating, by one or more processors of a processing system, a document object model tree for a first page of a first website, wherein the document object model tree comprises a plurality of nodes, and each node in the plurality of nodes includes an XML Path (“XPath”) and content; identifying, by the one or more processors, a first node of the plurality of nodes, wherein the content of the first node comprises a first sequence of words, and each word in the first sequence comprises one or more characters; identifying, by the one or more processors, a second node of the plurality of nodes, wherein the content of the second node comprises a second sequence of words, each word in the second sequence comprises one or more characters, and the second sequence precedes the first sequence on the first page; generating, by the one or more processors, a word-level vector corresponding to each word of the first sequence and the second sequence; generating, by the one or more processors, a character-level word vector corresponding to each word of the first sequence and the second sequence; generating, by the one or more processors, a sequence-level vector based on the word-level vectors and the character-level word vectors corresponding to the first sequence; generating, by the one or more processors, a sequence-level vector based on the word-level vectors and the character-level word vectors corresponding to the second sequence; generating, by the one or more processors, a discrete-features vector corresponding to one or more predefined features in the content of the first node; concatenating, by the one or more processors, the sequence-level vector corresponding to the first sequence, the sequence-level vector corresponding to the second sequence, and the discrete-features vector to obtain a comprehensive vector for the first node; generating, by the one or more processors, a node label for the first node based on the comprehensive vector for the first node; and extracting, by the one or more processors, structured data from the first node, the structured data associating the content of the first node with the node label for the first node. In some aspects, generating the character-level word vector corresponding to each word of the first sequence and the second sequence comprises, for each word in the first sequence, encoding a character vector corresponding to each of the one or more characters using a convolutional neural network, and, for each word in the second sequence, encoding a character vector corresponding to each of the one or more characters using a convolutional neural network. In some aspects, generating the sequence-level vector based on the word-level vectors and the character-level word vectors corresponding to the first sequence comprises encoding the character-level word vector and the word-level vector of each word of the first sequence using a bidirectional long short-term memory neural network. In some aspects, generating the sequence-level vector based on the word-level vectors and the character-level word vectors corresponding to the second sequence comprises encoding the character-level word vector and the word-level vector of each word of the second sequence using a bidirectional long short-term memory neural network. In some aspects, generating the node label for the first node based on the comprehensive vector for the first node comprises encoding the comprehensive vector for the first node using a multi-layer perceptron neural network to obtain a classification for the first node. In some aspects, the node label for the first node corresponds to one of a plurality of fields-of-interest. The method may further comprise: generating, by the one or more processors, a second document object model tree for a second page of the first website, wherein the second document object model tree comprises a second plurality of nodes, and each node in the second plurality of nodes includes an XPath and content; and extracting, by the one or more processors, a second set of structured data from the second plurality of nodes, wherein the second set of structured data associates the content of each node in the second plurality of nodes with a node label for each node in the second plurality of nodes. Further still, the method may additionally comprise: generating, by the one or more processors, a third document object model tree for a page of a second website, wherein the third document object model tree comprises a third plurality of nodes, and each node in the third plurality of nodes includes an XPath and content; and extracting, by the one or more processors, a third set of structured data from the third plurality of nodes, wherein the third set of structured data associates the content of each node in the third plurality of nodes with a node label for each node in the third plurality of nodes.
- In another aspect, the disclosure describes a computer-implemented method of extracting data, comprising: generating, by one or more processors of a processing system, a document object model tree for a first page of a first website, wherein the document object model tree comprises a first plurality of nodes, and each node in the first plurality of nodes includes an XML Path (“XPath”) and content; generating, by the one or more processors, a prediction for each node of the first plurality of nodes regarding whether the node relates to one of a plurality of fields-of-interest; generating, by the one or more processors, a plurality of node-pairs from the first plurality of nodes, wherein each node-pair of the plurality comprises a head node and tail node; generating, by the one or more processors, a comprehensive vector corresponding to each head node and each tail node; generating, by the one or more processors, an XPath vector corresponding to each head node and each tail node; generating, by the one or more processors, a positional vector corresponding to each head node and each tail node based at least in part on a position of each head node and each tail node relative to at least one other node of the first plurality of nodes; for each node-pair, concatenating, by the one or more processors, the comprehensive vectors, the positional vectors, and the XPath vectors corresponding to the head node and the tail node of the node-pair to obtain a pair-level vector; generating, by the one or more processors, a pair label for each node-pair based on the pair-level vector for the node-pair; generating, by the one or more processors, for the head node of each node-pair, a node label based on the pair label for the node-pair or the prediction for the head node; generating, by the one or more processors, for the tail node of each node-pair, a node label based on the pair label for the node-pair or the prediction for the tail node; and extracting, by the one or more processors, structured data from one or more nodes of the first plurality of nodes, the structured data associating the content of each of the one or more nodes with the node label for each of the one or more nodes. In some aspects, generating the XPath vector corresponding to each head node and each tail node comprises encoding the XPaths of each head node and each tail node using a long short-term memory neural network. In some aspects, generating the comprehensive vector corresponding to each head node and each tail node comprises: for each head node, concatenating a sequence-level vector corresponding to a sequence of words in the head node, a sequence-level vector corresponding to a sequence of words in a node preceding the head node, and a discrete-features vector corresponding to one or more predefined features in the content of the head node; and for each tail node, concatenating a sequence-level vector corresponding to a sequence of words in the tail node, a sequence-level vector corresponding to a sequence of words in a node preceding the tail node, and a discrete-features vector corresponding to one or more predefined features in the content of the tail node. In some aspects, generating a pair label for each node-pair based on the pair-level vector comprises encoding the pair-level vector for each node-pair using a multi-layer perceptron neural network to obtain a classification for each node-pair. In some aspects, the node labels correspond to one of the plurality of fields-of-interest or a null identifier. The method may further comprise: generating, by the one or more processors, a second document object model tree for a second page of the first website, wherein the second document object model tree comprises a second plurality of nodes, and each node in the second plurality of nodes includes an XPath and content; and extracting, by the one or more processors, a second set of structured data from the second plurality of nodes, wherein the second set of structured data associates the content of each node in the second plurality of nodes with a node label for each node in the second plurality of nodes. Further still, the method may additionally comprise: generating, by the one or more processors, a third document object model tree for a page of a second website, wherein the third document object model tree comprises a third plurality of nodes, and each node in the third plurality of nodes includes an XPath and content; and extracting, by the one or more processors, a third set of structured data from the third plurality of nodes, wherein the third set of structured data associates the content of each node in the third plurality of nodes with a node label for each node in the third plurality of nodes. The method may further comprise: generating, by one or more processors, a second document object model tree for a second page of the first website, wherein the second document object model tree comprises a second plurality of nodes, and each node in the second plurality of nodes includes an XPath and content; generating, by the one or more processors, a node label for each node of the second plurality of nodes; identifying, by the one or more processors, a class of nodes from the first plurality of nodes and the second plurality of nodes, wherein the node label for each node in the class of nodes is the same; identifying, by the one or more processors, a first XPath that is a most common XPath in the class of nodes; and extracting, by the one or more processors, from each node in the first plurality of nodes and the second plurality of nodes that has the first XPath, a second set of structured data that associates the content of the node with the node label for the node.
- In another aspect, the disclosure describes a processing system for extracting machine-actionable data. The processing system comprises a memory, and one or more processors coupled to the memory and configured to: generate a document object model tree for a first page of a first website, wherein the document object model tree comprises a plurality of nodes, and each node in the plurality of nodes includes an XML Path (“XPath”) and content; identify a first node of the plurality of nodes, wherein the content of the first node comprises a first sequence of words, and each word in the first sequence comprises one or more characters; identify a second node of the plurality of nodes, wherein the content of the second node comprises a second sequence of words, each word in the second sequence comprises one or more characters, and the second sequence precedes the first sequence on the first page; generate a word-level vector corresponding to each word of the first sequence and the second sequence; generate a character-level word vector corresponding to each word of the first sequence and the second sequence; generate a sequence-level vector based on the word-level vectors and the character-level word vectors corresponding to the first sequence; generate a sequence-level vector based on the word-level vectors and the character-level word vectors corresponding to the second sequence; generate a discrete-features vector corresponding to one or more predefined features in the content of the first node; concatenate the sequence-level vector corresponding to the first sequence, the sequence-level vector corresponding to the second sequence, and the discrete-features vector to obtain a comprehensive vector for the first node; generate a node label for the first node based on the comprehensive vector for the first node; and extract structured data from the first node, wherein the structured data associates the content of the first node with the node label for the first node. In some aspects, the node label for the first node corresponds to one of a plurality of fields-of-interest.
- In another aspect, the disclosure describes a processing system for extracting machine-actionable data, comprising a memory, and one or more processors coupled to the memory and configured to: generate a document object model tree for a first page of a first website, wherein the document object model tree comprises a first plurality of nodes, and each node in the first plurality of nodes includes an XML Path (“XPath”) and content; generate a prediction for each node of the first plurality of nodes regarding whether the node relates to one of a plurality of fields-of-interest; generate a plurality of node-pairs from the first plurality of nodes, wherein each node-pair of the plurality comprises a head node and tail node; generate a comprehensive vector corresponding to each head node and each tail node; generate an XPath vector corresponding to each head node and each tail node; generate a positional vector corresponding to each head node and each tail node based at least in part on a position of each head node and each tail node relative to at least one other node of the first plurality of nodes; for each node-pair, concatenate the comprehensive vectors, the positional vectors, and the XPath vectors corresponding to the head node and the tail node of the node-pair to obtain a pair-level vector; generate a pair label for each node-pair based on the pair-level vector for the node-pair; generate, for the head node of each node-pair, a node label based on the pair label for the node-pair or the prediction for the head node; generate, for the tail node of each node-pair, a node label based on the pair label for the node-pair or the prediction for the tail node; and extract structured data from one or more nodes of the first plurality of nodes, wherein the structured data associates the content of each of the one or more nodes with the node label for each of the one or more nodes. In some aspects, the node labels correspond to one of the plurality of fields-of-interest or a null value.
-
FIG. 1 is a functional diagram of an example system in accordance with aspects of the disclosure. -
FIG. 2 is a diagram showing how a section of HTML may be represented as a DOM Tree. -
FIG. 3 is a flow diagram of an exemplary method in accordance with aspects of the disclosure. -
FIG. 4 is a flow diagram of an exemplary method in accordance with aspects of the disclosure. -
FIG. 5 is a flow diagram of an exemplary method in accordance with aspects of the disclosure. -
FIG. 6 is a diagram showing how an exemplary phrase may be processed in accordance with aspects of the disclosure. -
FIG. 7 is a flow diagram of an exemplary method in accordance with aspects of the disclosure. -
FIG. 8 is a flow diagram of an exemplary method in accordance with aspects of the disclosure. -
FIG. 9 is a flow diagram of an exemplary method in accordance with aspects of the disclosure. -
FIG. 10 is a flow diagram of an exemplary method in accordance with aspects of the disclosure. -
FIG. 11 is a flow diagram of an exemplary method in accordance with aspects of the disclosure. -
FIG. 12 is a flow diagram of an exemplary method in accordance with aspects of the disclosure. -
FIG. 13 is a flow diagram of an exemplary method in accordance with aspects of the disclosure. - The present technology will now be described with respect to the following exemplary systems and methods.
-
FIG. 1 schematically illustrates anarrangement 100 with anexemplary processing system 102 for performing the methods described herein. Theprocessing system 102 includes one ormore processors 104 andmemory 106 storing instructions and data. In addition, the one ormore processors 104 may include the various modules described herein, and the instructions and data may include the various neural networks described herein. Theprocessing system 102 is shown being in communication with various websites, includingwebsites more networks 108.Exemplary websites processing system 102 may not be in direct communication with the websites, and may instead process stored versions of the HTML of the websites to be processed. -
Processing system 102 may be implemented on different types of computing device(s), such as any type of general computing device, server, or set thereof, and may further include other components typically present in general purpose computing devices or servers. Thememory 106 stores information accessible by the one ormore processors 104, including instructions and data that may be executed or otherwise used by the processor(s) 104. The memory may be of any non-transitory type capable of storing information accessible by the processor(s) 104. For instance, the memory may include a non-transitory medium such as a hard-drive, memory card, optical disk, solid-state, tape memory, or the like. Computing devices suitable for the roles described herein may include different combinations of the foregoing, whereby different portions of the instructions and data are stored on different types of media. - In all cases, the computing devices described herein may further include any other components normally used in connection with a computing device such as a user interface subsystem. The user interface subsystem may include one or more user inputs (e.g., a mouse, keyboard, touch screen and/or microphone) and one or more electronic displays (e.g., a monitor having a screen or any other electrical device that is operable to display information). Output devices besides an electronic display, such as speakers, lights, and vibrating, pulsing, or haptic elements, may also be included in the computing devices described herein.
- The one or more processors included in each computing device may be any conventional processors, such as commercially available central processing units (“CPUs”), tensor processing units (“TPUs”), etc. Alternatively, the one or more processors may be a dedicated device such as an ASIC or other hardware-based processor. Each processor may have multiple cores that are able to operate in parallel. The processor(s), memory, and other elements of a single computing device may be stored within a single physical housing, or may be distributed between two or more housings. Similarly, the memory of a computing device may include a hard drive or other storage media located in a housing different from that of the processor(s), such as in an external database or networked storage device. Accordingly, references to a processor or computing device will be understood to include references to a collection of processors or computing devices or memories that may or may not operate in parallel, as well as one or more servers of a load-balanced server farm or cloud-based system.
- The computing devices described herein may store instructions capable of being executed directly (such as machine code) or indirectly (such as scripts) by the processor(s). The computing devices may also store data, which may be retrieved, stored, or modified by one or more processors in accordance with the instructions. Instructions may be stored as computing device code on a computing device-readable medium. In that regard, the terms “instructions” and “programs” may be used interchangeably herein. Instructions may also be stored in object code format for direct processing by the processor(s), or in any other computing device language including scripts or collections of independent source code modules that are interpreted on demand or compiled in advance. By way of example, the programming language may be C#, C++, JAVA or another computer programming language. Similarly, any components of the instructions or programs may be implemented in a computer scripting language, such as JavaScript, PHP, ASP, or any other computer scripting language. Furthermore, any one of these components may be implemented using a combination of computer programming languages and computer scripting languages.
- In addition to the systems described above and illustrated in the figures, various operations will now be described. In that regard, there are multiple ways that
processing system 102 could be configured to extract structured data from websites. For example,processing system 102 could be configured to use a site-specific extraction program or “wrapper” for each website from which data is to be extracted. However, site-specific approaches generally require either a human to analyze the site and create a wrapper to be used by the extraction program, or that the pages of the website be sufficiently well-annotated that the extraction program can accurately identify the preselected fields-of-interest without human input. In either case, the wrappers created for one site will not be transferrable to a different site. Fields-of-interest may be any categories of information that are selected for extraction. For example, for a website relating to automobiles, fields-of-interest may include model name, vehicle type, gas mileage, engine size, engine power, engine torque, etc. - In other cases, neural networks can be trained on a set of rendered webpages to identify information of interest using various visual cues. However, while visual-rendering approaches can generate models that allow fields-of-interest to be identified and extracted from other websites, they require careful feature-engineering with domain-specific knowledge in order to generate the models, and are computationally expensive due to the rendering.
- In view of these drawbacks, the present technology provides neural network architectures that can use the text of a set of seed websites to create transferrable extraction models with minimal or no human input, and without the need for rendering. Those extraction models can then be used to identify and extract information of interest in the text of additional websites without the need for any rendering of webpages.
- In that regard, in an exemplary method according to aspects of the technology, a processing system first applies a node-level module to a set of selected seed websites. The seed websites may be chosen based on various attributes. For example, some websites will already include annotations that identify various fields-of-interest. In that regard, on an exemplary automobile websites, the pages for each vehicle may have a table with a row that states “model” and then lists the model name, a row that states “engine” and then lists the engine size, a row that states “gas mileage” and then lists the gas mileage, etc. Sites with one or more annotations related to the preselected fields-of-interest may be helpful as seed websites, as they may allow the neural networks to generate models that can more accurately identify fields-of-interest in other websites with fewer annotations. The node-level module parses the raw HTML of each page of each seed web site as Document Object Model (“DOM”) Trees. This converts each page into a tree structure, in which each branch ends in a node, and each node includes an XML Path (“XPath”) and its associated HTML content. For example,
illustration 200 ofFIG. 2 shows how a section ofHTML 202 may be represented as aDOM Tree 204. While the nodes of theDOM Tree 204 are shown inFIG. 2 as empty circles, in actuality they would include the HTML content associated with each node. - The node-level module next identifies all nodes that contain text, and filters the list of all such textual nodes to remove those that are unlikely to convey information of interest. This can be done, for example, by collecting all possible XPaths (node identifiers) of textual nodes in a given website, ranking the XPaths by the number of different text values associated with each XPath, and identifying some subset of those that have two or more different values as the nodes-of-interest. A flow diagram 300 showing this exemplary filtering method is included as
FIG. 3 . In that regard, instep 302, the node-level module parses the raw HTML of a webpage as a DOM Tree. Instep 304, the node-level module identifies all nodes of the DOM Tree that contain text. Instep 306, the node-level module identifies all XPaths that are associated with the textual nodes of the DOM Tree. Instep 308, the node-level module ranks all XPaths according to how many different text values are associated with each such XPath. Instep 310, the node-level module identifies as the “nodes-of-interest” the top N XPaths that have two or more different text values. Thus, in some examples, the node-level module may rank the XPaths by the number of different values associated with them, and select the top 500 XPaths (or more or less) that have at least two different values. Filtering in this way will remove most of the nodes that have common values across multiple pages, and therefore are more likely to represent generic text of the pages in that website such as the name of the website, navigation text, headers, footers, copyright information, etc. - The node-level module next encodes the filtered set of textual nodes (the “nodes-of-interest”) using the text of each node, the text preceding each node, and one or more discrete features (e.g., content in the raw HTML that may be helpful in identifying fields-of-interest). Each of these encoding processes utilizes different neural networks, as will be described in further detail below with respect to
FIGS. 4-9 . - In that regard, as shown in
step 402 ofapproach 400 ofFIG. 4 , when encoding based on the text of each node, the node-level module breaks each node's text down into a sequence of words W, consisting of {w1, w2, . . . , w|n|}. The sequence of words {w1, w2, . . . , w|n|} be the original text of the node, or may be the results of subjecting the original text to lexical analysis, such as by tokenizing and lemmatizing the original text using the Natural Language Toolkit (“NLTK”). Thus, for each node, each word w i can be expressed according toEquation 1 below as being an element of W. As used herein, a “word” need not be comprised of letters, and can thus include text comprised of numbers and/or symbols, such as “$1,000.” -
wi ∈ W (1) - As shown in
step 404, the node-level module further breaks each word wi into a sequence of characters C, consisting of {c1, c2, . . . , c|w|}i, Thus, for a given word wi of a node, each character c j can be expressed according toEquation 2 as being an element of C. -
cj ∈ C (2) - A character-embedding lookup table Ec is also initialized, as shown in
step 406. Step 406 may take place beforesteps 402 and/or 404. Character-embedding lookup table Ec is defined according to Equation 3, in which dimc is a hyperparameter representing the dimension of character-embedding vectors, and - As shown in
step 408, for each word w i , a character-embedding vector is generated for each character cj using character-embedding lookup table Ec. Next, instep 410, a convolutional neural network (“CNN”) is used to encode the entire sequence of character-embedding vectors for each word wi, and then pool them to create a character-level word vector ci corresponding to word wi. Character-level word vector ci can thus be expressed according to Equation 4 below. These steps are also represented pictorially inFIG. 6 , in which the exemplary phrase “city 25hwy 32” is processed to create individual character-embedding vectors for each word 602 a-602 d. Each set of character-embedding vectors for each word is then fed intoCNN 606 and pooled to create corresponding character-level word vectors 608 a-608 d. The CNN may be implemented with any suitable parameters. For example, the CNN may employ a kernel size of 3 (or more or less), a filter size of 50 (or more or less), and may apply max pooling to select the maximum value from each row of the resulting matrix and thus reduce each row to a single value. -
ci=CNN({c1, c2, . . . , c|w|}) (4) - In addition, as shown in
step 412, a word-level vector lookup table E., is also initialized for each word w i . Here as well, step 412 may take place before any or all of steps 402-410. Word-level vector lookup table Ew is defined according to Equation 5 below, in which dimw, is a hyperparameter representing the dimension of word-level vectors. The word-level vectors in Ew may be generated from various known algorithms, such as Stanford's GloVe. Thus, word-level vector lookup table Ew is a matrix of shape |W|x dimw, and each element in the matrix is a real number. The dimension of character-embedding vectors may be any suitable number, such as 100 (or more or less). - As shown in
step 414, a word-level vector wi for each word wi is generated using word-level vector lookup table Ew. Then, as shown instep 416, for each word wi, the word-level vector wi is concatenated with the character-level word vectors ci created by the CNN to create a concatenated word vector ti for every word wi in each node. This is shown in Equation 6 below, in which [· {circle around (·)} ·] denotes concatenation operations. These steps are also represented pictorially inFIG. 6 , in which each word 604 a-604 d of the phrase “city 25hwy 32” is processed to create corresponding word-level vectors 610 a-610 d. Those word-level vectors 610 a-610 d are then concatenated with the associated character-level word vectors 608 a-608 d to form concatenated word vectors 612 a-612 d. -
ti=[wi {circle around (·)} ci] (6) - As a result of the above, for the set of all words W in a given node, there will be a set of concatenated word vectors consisting of {t1, t2, . . . , t|n|}. Next, as shown in
FIGS. 5 and 6 , a long short-term memory (“LSTM”) neural network is used to contextually encode this set of concatenated word vectors both forward and backward. In other words, the LSTM network will encode the set {t1, t2, . . . , t|n|}, as well as to the reverse set {t|n|, t|n|−1, . . . , t1}. These processes are described insteps flow 500 inFIG. 5 . The forward and backward LSTM encoding steps are also shown pictorially by dashedlines FIG. 6 , respectively. Because the LSTM network encodes the sets in two directions, it can also be referred to as a bidirectional long short-term memory neural network. While the LSTM network will have the same structure in both directions, the parameters will be different for the forward and backward encoding operations. The LSTM network may employ any suitable number of units, such as 100 (or more or less). The results of the forward and backward LSTM encoding operations will then be subjected to mean pooling to arrive at the final representation of the text of that node, nnode_text, as shown instep 506 ofFIG. 5 . This can be expressed as shown in Equation 7, in which AVG [· {circle around (·)} ·] denotes average or mean pooling operations, and in which LSTMf and LSTMb denote the LSTM operations in the forward and backward directions, respectively. This is also shown pictorially inFIG. 6 , in which the output of the forward and backward LSTM encoding operations are represented by dashedlines element 622, and in which the final vector representation of that text is shown inelement 624. -
nnode_text=AVG[LSTMf({t1, t2, . . . , t|n|}) {circle around (·)} LSTMb({t1, t2, . . . , t|n|})] (7) - Encoding both the words and the characters of each node's text as described above enables the node-level module to identify patterns shared across nodes even where the individual words of a given node may be unknown (e.g., misspellings, abbreviations, etc.), or where the text of the node includes numbers or special characters. For example, in the context of a website pertaining to automobiles, a node may contain text such as “
city 25hwy 32” as shown inFIG. 6 , but a node from another page of that website may contain similar text for another automobile, such as “city 22 hwy 28.” Tracking only words, the node-level module may only determine that these nodes share the words “city” and “hwy,” the latter of which may not even be recognized as a word as it is merely an abbreviation. But by combining the results of the character-level CNN and word-level LSTM operations as described above, the node-level module can identify that these nodes in fact share a pattern of “city ## hwy ##.” Importantly, the node-level module can do this without requiring human input. - As noted above, and as shown in
flows FIGS. 7 and 8 , respectively, the node-level module also encodes the text that precedes each node-of-interest. This encoding may be performed for some fixed amount of preceding text. The node-level module processes the preceding text in the same manner described above with respect toFIGS. 4-6 , resulting in a second vector nprev-text. The steps ofFIGS. 4 and 5 need not take place before those ofFIGS. 7 and 8 . Rather, the node-level module may process the preceding text before, after, or simultaneously with its processing of the node text. - Thus, as shown in
step 702 ofFIG. 7 , the node-level module breaks down the text preceding a node-of-interest into a sequence of X words. X may be any number, such as 10 words (or more or fewer words). In addition, as described above with respect to step 402 ofFIG. 4 , the sequence of X words may be the original text that preceded the node-of-interest, or may be the results of subjecting that preceding text to lexical analysis, such as by tokenizing and lemmatizing it using the NLTK toolkit. Atstep 704, the node-level module breaks each of the X words into a sequence of characters in the same manner described above with respect to step 404 ofFIG. 4 . Atstep 706, the node-level module initializes a character-embedding lookup table in the same manner described above with respect to step 406 ofFIG. 4 . As was the case with the steps ofFIG. 4 , step 706 ofFIG. 7 may take place beforesteps 702 and/or 704. Further in that regard, the node-level module may utilize the same character-embedding lookup table for the processes of bothFIGS. 4 and 7 , in which case steps 406 and 706 would each describe a single instance of initializing a character-embedding lookup table. Atstep 708, the node-level module encodes the characters of each of the X words using the character-embedding lookup table to create corresponding character-embedding vectors, in the same manner described above with respect to step 408 ofFIG. 4 . Atstep 710, for each of the X words, the node-level module encodes the corresponding sequence of character-embedding vectors using a CNN and then pools them to create a character-level word vector for each word, in the same manner described above with respect to step 410 ofFIG. 4 . Step 710 may use the same CNN used in connection withstep 410 ofFIG. 4 , or may use a separate CNN. Atstep 712, the node-level module initializes a word-level vector lookup table in the same manner described above with respect to step 412 ofFIG. 4 . Here as well, step 712 ofFIG. 7 may take place before any or all of steps 702-710 ofFIG. 7 . Further in that regard, the node-level module may utilize the same word-level vector lookup table for the processes of bothFIGS. 4 and 7 , in which case steps 412 and 712 would each describe a single instance of initializing a word-level vector lookup table. Atstep 714, for each of the X words, the node-level module encodes the word using the word-level vector lookup table to create a corresponding word-level vector in the same manner described above with respect to step 414 ofFIG. 4 . Instep 716, for each of the X words, the node-level module concatenates the corresponding word-level vector and character-level word vector to create a concatenated word representation for the word, in the same manner described above with respect to step 416 ofFIG. 4 . - Likewise, in
steps FIG. 8 , for the sequence of X words, the node-level module encodes the corresponding concatenated word representations (created instep 716 ofFIG. 7 ) in both the forward and backward directions using an LSTM network, in the same manner described above with respect tosteps FIG. 5 , respectively. Here as well, steps 802 and 804 may use the same LSTM network used in connection withsteps step 806, the results of the forward and backward LSTM encoding operations are subjected to mean pooling to arrive at the final representation of the preceding text of the node-of-interest, nprev_text, in the same manner described above with respect to generating nnode_text instep 506 ofFIG. 5 . - Encoding the preceding text of each node as described above can further aid in distinguishing between nodes of similar content. For example, in a website pertaining to automobiles, the node-level module may be programmed to identify gas mileage values on each page. A given page may thus include a first node with the text “25,” and a second node with the text “32.” The text of these two nodes may not, in isolation, contain enough information to determine if either represents a gas mileage value. However, in many cases, the text preceding those nodes will contain descriptive words such as “gas mileage,” “fuel economy,” “miles per gallon,” “highway mileage,” or some other text that strengthens or weakens that inference.
- As noted above, the node-level module also checks the text of each node against a set of preselected discrete features as shown in
flow 900 ofFIG. 9 . This results in a third vector ndis_feat, Here as well, the steps ofFIGS. 4-8 need not take place before those ofFIG. 9 . Rather, the node-level module may check for discrete features before, after, or simultaneously with its processing of the node text and/or the preceding text. - Thus, as shown in
step 902 ofFIG. 9 , the node-level module initializes a discrete-features lookup table Ed containing a preselected set of discrete features of interest. These discrete features may be anything in the raw HTML that is determined to be helpful in identifying fields-of-interest. For example, in many cases the leaf tag type (e.g., <hl>, <div>, <li>, <span>) of a node will help classify information on a page. In that regard, <hl >nodes are often more likely to include key information, such as the model name of a vehicle being displayed on the page. Similarly, known algorithms such as the string-type checkers in the NLTK toolkit may be used to determine if the text of a given node includes selected types of information, such as dates, zip codes, or URL links that are likely to be helpful. These and any other discrete features believed to be of interest may be included in the discrete-features lookup table Ed. The discrete-features lookup table Ed is thus defined according to Equation 8 below, in which D is the set of all identified discrete features, and dimd is a hyperparameter representing the dimension of discrete-feature vectors. The dimension of discrete-feature vectors may be any suitable number, such as 30 (or more or less). - In
step 904 ofFIG. 9 , the node-level module then generates a vector d in which each of the preselected discrete features present for a given node are represented as non-negative integers. For example, if the preselected discrete features for a given set of websites are {gas mileage, date, zip code}, and the node-of-interest has two gas mileage values, one date, and no zip codes, then vector d for that node would have a value of {2, 1, 0}. Thus, vector d is defined according to Equation 9 below, in which - In
step 906 ofFIG. 9 , for each node-of-interest, the node-level module multiplies the vector d representing the discrete features with the discrete-features lookup table Ed using matrix multiplication according to Equation 10 below. This results in a single vector ndis_feat, which is a final representation of the discrete features present in the node-of-interest. -
ndis_feat=dEd (10) - Once the three encoding processes have been performed, the node-level module uses the resulting nnode_text, nprev_text, and ndis_feat vectors for each node to generate a prediction of whether the node corresponds to one of a set of predefined fields-of-interest. For example, for an automobile website, fields-of-interest may include Model Name, Vehicle Type, Engine, and Gas Mileage, and the node-level module will use the final vectors generated for each node to predict whether that node corresponds to any of those fields-of-interest. If so, the node will be labeled according to the field-of-interest to which it corresponds. If not, the node will be labeled with some null identifier such as “none” or “null.” This process is set forth in further detail below with respect to flow 1000 of
FIG. 10 . - In that regard, in
step 1002 ofFIG. 10 , the node-level module concatenates the final representations of the text of a node-of-interest (nnode_text), the text preceding the node-of-interest (nprev_text), and the discrete features present in the node-of-interest (ndis_feat) to create a single vector n, which is a comprehensive representation of each node. Vector n is thus described according toEquation 11 below. -
n=[nnode_text {circle around (·)} nprev_text {circle around (·)} ndis_feat] (11) - In
step 1004 ofFIG. 10 , the node-level module connects vector n to a multi-layer perceptron (MLP) neural network for multi-class classification via a SoftMax function. As shown instep 1006, based on the multi-class classification, the node-level module will predict a label l for each node-of-interest. As label l can be any one of a number of K predefined fields, or a null identifier (e.g., “none,” “null,” etc.), there are K+1 possible values for 1. Thus, the SoftMax normalization can be described according to Equations 12 and 13 below, where label l will be one of the set {f1, . . . , fK, none}. This MLP network may be implemented with any suitable parameters. For example, the MLP network may be a one-layer dense neural network containing K+1 nodes, such that the output h is a vector oflength K+ 1. -
- As explained above, the node-level module is capable of predicting a
label 1 for each node-of-interest based solely on the text of the node, its preceding text, and selected discrete features of the node. However, because the node-level module's predictions are each made in isolation for a single node-of-interest, they do not take into account what predictions have been made for other nodes. In some circumstances, this may result in the node-level module assigning the same label to multiple nodes on a page, while failing to assign other labels to any node on the page. Thus, to further improve the predictions for each node-of-interest, the technology can also employ a second-stage module that processes pairs of nodes through a relational neural network, as shown inflow 1100 ofFIG. 11 . - In that regard, the second-stage module may process every possible node-pair on a given webpage, or some subset thereof, in which case the processing would begin with
step 1110 ofFIG. 11 . However, this may not be feasible in all circumstances. For example, if the node-level module identifies and encodes 300 nodes on a page, there would be 89,700 node-pairs for the second-stage module to process (i.e., 300×299, as the order of the head and tail nodes matters in this context), which may be too computationally expensive. Thus, in some aspects of the technology, the second-stage module may instead divide the fields-of-interest into two groups as shown insteps FIG. 11 . Thus, instep 1102, the second-stage module identifies all fields for which the node-level module predicted at least one node, which will be referred to going forward as “certain fields.” Likewise, instep 1104, the second-stage module identifies all fields for which the node-level module was unable to predict any node, which will be referred to going forward as “uncertain fields.” Then, instep 1108, the second-stage module will create all possible node-pairs from the following sets of nodes. For each certain field, the second-stage module will use the node predicted for that field. For each uncertain field, as shown instep 1106, the second-stage module will use the top m nodes (e.g., m may between 5 and 20, or more or less) according to the hi score that was generated for that field by the node-level module according to Equations 12 and 13 above. This will result in three types of node-pairs. The nodes for each certain field will be paired with the nodes for all other certain fields. Thus, if there are T certain fields, there will be T(T−1) node-pairs that consist entirely of nodes for of two certain fields. In addition, the nodes for each certain field will be paired with the top m nodes identified for each uncertain field. Thus, if there are K total fields, this results in an additional 2T(m(K−T)) such node-pairs, as the order of the head and tail nodes matters in this context. Finally, the top m nodes identified for each uncertain field will be paired with the top m nodes identified for all other uncertain fields. This results in an additional m2(K−T)(K−T−1) such node-pairs. Accordingly, the total number of node-pairs generated as a result ofstep 1108 ofFIG. 11 can be expressed according to Equation 14 below. -
node_pairs=(T(T—1)+2T(m(K−T))+m2(K−T)(K−T−1)) (14) - The second-stage module then processes each node-pair (nhead, ntaii) through a relational neural network in order to predict a pair-label (lhead, ltail). To do this, the second-stage module processes the node-pairs in two ways based on the assumption that two nodes that are closer to each other are more likely to be similar to each other.
- In one case, as shown in
step 1110, the second-stage module processes each node-pair according to the XPaths of the head and tail nodes. In that regard, each XPath can be seen as a sequence of HTML tags such as “<html>,” “<body>,” “<div>,” “<ul>,” and “<li>.” The second-stage module maintains an embedding matrix for all the possible HTML tags, where each tag is represented as a vector. An LSTM network (which may be a different network than the LSTM networks used by the node-level module) then uses that matrix to encode each node-pair based on their XPaths, as shown in Equation 15 below. This results in vectors nhead xpath and ntail xpath for the head and tail nodes, respectively. The LSTM network may employ any suitable number of units, such as 100 (or more or less). -
nxpath=LSTM([tag1, tag2, . . . ]) (15) - In another case, as shown in
steps step 1112, every node-of-interest on the page will be assigned a positional value based on its order relative to the total number of nodes-of-interest. For example, for a page with 500 nodes-of-interest, the fifth node may be assigned a value of 5. As another example, the fifth node may be assigned a scaled value such as 5/500=0.01. As further shown instep 1112, the second-stage module will then initialize a position-embedding look-up table E pos indexed according to each positional value, in which each positional value is associated with a position-embedding vector. The position-embedding vectors of Epos are randomly initialized, and then updated during model training through back-propagation. Then, as shown instep 1114, the second-stage module uses the position-embedding look-up table Epos to obtain vectors nhead pos and ntail pos for the positions of the head and tail nodes of each node-pair, respectively. - In addition to the above, the second-stage module also makes use of the comprehensive node vectors n that were generated by the node-level module for each head and tail node, i.e., the n vectors generated pursuant to
Equation 11 above. Thus, instep 1116, the second-stage module concatenates the comprehensive node vectors, nhead and ntail, with the vectors nhead xpath and nhead xpath (from Equation 15) and nhead pos and ntail pos to arrive at a single comprehensive node-pair vector r, as shown in Equation 16 below. -
r=[nhead {circle around (·)} ntail {circle around (·)} nhead xpath {circle around (·)} ntail xpath {circle around (·)} nhead pos {circle around (·)} ntail pos](16) - As shown in
step 1202 offlow 1200 ofFIG. 12 , for each node-pair, the second-stage module then connects the comprehensive node-pair vector r with an MLP network (which may be a different network than the MLP network used by the node-level module) for multi-class classification via a SoftMax function. This MLP network may be implemented with any suitable parameters. For example, the MLP network may be a one-layer dense neural network containing four nodes, such that the output is a 1x4 vector. The vector output by the MLP is then normalized by the SoftMax function. Based on this classification, instep 1204, the second-stage module assigns a normalized label to each node-pair. The normalized labels are selected from the set of {“none-none”, “none-value”, “value-none”, “value-value” } . - As shown in
step 1206, for every certain field, the second-stage module utilizes the nodes predicted by the first stage module as the final prediction(s) for that field. As shown instep 1208, for every uncertain field, the second-stage module determines whether any of the m nodes that were originally identified as candidates for that field have been classified as “value” in any of the node-pairs in which they have been included. If so, instep 1210, the second-stage module uses that field as the final prediction for that node. For example, for a field F, and a candidate node y (which was one of the m nodes that were originally identified as candidates for field F), there may be four node-pairs involving node y. If node y received a label of “none” in three of those pairs, and a label of “value” in one of those pairs, then the final prediction for node y would be that it corresponds to field F. Finally, as shown instep 1212, based on these final predictions, the processing system extracts structured data from each identified node of each page of each seed website. Importantly, the technology allows the processing system to extract this web data in a structured form that preserves the association between the data and its predicted field-of-interest. For example, the extracted data may comprise data extracted about automobiles with four fields-of-interest, in which the data is associated with the label for each of those fields, e.g., {Model Name | 328xi, Vehicle Type | Coupe, Engine | 3.0 L Inline 6 Cylinder, Gas Mileage | 17/25 mpg}. This results in functional data. That is, the data is in a structured form which is machine-actionable, allowing it to be used in controlling operation of the processing system and/or other systems for a variety of purposes. For example, the structured data can be used to improve search results in a search engine, or to create databases from disparate data sources. In another example, the structured data from websites or HTML-based emails or messages may be used by an automated assistant to provide answers to questions, or to automatically add events to a user's calendar. These examples are, of course, not intended to be limiting. - In addition to the above, as shown in
flow 1300 ofFIG. 13 , the second-stage module may also utilize an additional heuristic method for improving the model's predictions. In that regard, for some websites, the nodes associated with a particular field may have a relatively small number of XPaths across individual pages. As such, as shown instep 1302 ofFIG. 13 , after the second-stage module has generated its first set of predictions, it can rank, for each field-of-interest fk, which XPath was most often predicted for that field across all pages. Then, as shown instep 1304, for each field-of-interest fk, the second-stage module can extract data from the most commonly-predicted XPath for that field. This extraction can be done in addition to extracting data from whatever node(s) were indicated by the first set of predictions for that field, as described above with respect toFIG. 12 . - Finally, once the processing system has generated final predictions for all pages of all seed websites as set forth above, the processing system can perform the same processing steps to generate final predictions for an additional set of non-seed websites. These additional final predictions can then be used to extract further structured data from those non-seed websites in the same manner described above. In that regard, as a result of having first exposed the neural networks to seed websites that have data regarding the fields-of-interest that are more annotated, organized, current, and/or complete, the models built by the neural networks will more accurately be able to identify fields-of-interest in non-seed websites which may have data that is not as well annotated, organized, current, and/or complete. The present technology thus enables generation of models with little or no human input that are then transferrable, such that structured, functional data can efficiently be extracted across multiple domains.
- Unless otherwise stated, the foregoing alternative examples are not mutually exclusive, but may be implemented in various combinations to achieve unique advantages. As these and other variations and combinations of the features discussed above can be utilized without departing from the subject matter defined by the claims, the foregoing description of exemplary systems and methods should be taken by way of illustration rather than by way of limitation of the subject matter defined by the claims. In addition, the provision of the examples described herein, as well as clauses phrased as “such as,” “including,” “comprising,” and the like, should not be interpreted as limiting the subject matter of the claims to the specific examples; rather, the examples are intended to illustrate only some of the many possible embodiments. Further, the same reference numbers in different drawings can identify the same or similar elements.
Claims (20)
1. A computer-implemented method of generating a node label, the method comprising:
generating, by one or more processors of a processing system, a plurality of word-level vectors and a plurality of character-level word vectors, the plurality of word-level vectors and the plurality of character-level word vectors corresponding to each word of a first sequence of words of a first text node and each word of a second sequence of words of a second text node, in which a length of each word-level vector of a given word is less than or equal to a length of a character-level word vector of the given word;
generating, by the one or more processors, a comprehensive vector of the first text node based on the plurality of word-level vectors, the plurality of character-level word vectors, and one or more predefined features in content of the first text node; and
generating, by the one or more processors, a node label for the first text node based on the comprehensive vector for the first text node.
2. The method of claim 1 , wherein generating the plurality of character-level word vectors corresponding to each word of the first sequence and the second sequence comprises:
for each given word in the first sequence, encoding a character vector corresponding to each of one or more characters of the given word using a neural network; and
for each given word in the second sequence, encoding a character vector corresponding to each of one or more characters of the given word using a neural network.
3. The method of claim 1 , further comprising:
generating, by the one or more processors, a sequence-level vector based on one or more word-level vectors of the plurality of word-level vectors and one or more character-level word vectors of the plurality of character-level word vectors;
wherein the comprehensive vector of the first text node is further based on the sequence-level vector.
4. The method of claim 3 , wherein the one or more word-level vectors of the plurality of word-level vectors correspond to the first sequence and the one or more character-level word vectors of the plurality of character-level word vectors correspond to the first sequence.
5. The method of claim 4 , wherein generating the sequence-level vector includes:
encoding the one or more character-level word vectors of the plurality of character-level word vectors and the one or more word-level vectors of the plurality of word-level vectors of each word of the first sequence using a bidirectional long short-term memory neural network.
6. The method of claim 3 , wherein the one or more word-level vectors of the plurality of word-level vectors correspond to the second sequence and the one or more character-level word vectors of the plurality of character-level word vectors correspond to the second sequence.
7. The method of claim 6 , wherein generating the sequence-level vector includes:
encoding the one or more character-level word vectors of the plurality of character-level word vectors and the one or more word-level vectors of the plurality of word-level vectors of each word of the second sequence using a bidirectional long short-term memory neural network.
8. The method of claim 1 , wherein generating the node label for the first text node based on the comprehensive vector for the first text node includes:
encoding the comprehensive vector for the first text node using a multi-layer perceptron neural network to obtain a classification for the first text node.
9. The method of claim 1 , wherein the node label for the first text node corresponds to one of a plurality of fields-of-interest.
10. The method of claim 1 , further comprising:
generating, by the one or more processors, a prediction for each of the first text node and the second text node regarding whether the respective first text node and second text node relates to one of a plurality of fields-of-interest.
11. The method of claim 10 , further comprising:
generating, by the one or more processors, a comprehensive vector of the second text node based on one or more word-level vectors of the plurality of word-level vectors and one or more character-level word vectors of the plurality of character-level word vectors;
wherein the one or more word-level vectors of the plurality of word-level vectors correspond to the second sequence and the one or more character-level word vectors of the plurality of character-level vectors correspond to the second sequence.
12. The method of claim 10 , further comprising:
generating, by the one or more processors, a positional vector of the first text node based on at least a relative position of the first text node; and
generating, by the one or more processors, a positional vector of the second text node based on at least a relative position of the second text node.
13. The method of claim 12 , further comprising:
generating, by the one or more processors, a pair-level vector based on at least the comprehensive vector of the first text node, the comprehensive vector of the second text node, the positional vector of the first text node, and the positional vector of the second text node.
14. The method of claim 13 , further comprising:
generating, by the one or more processors, a pair label for the first text node and the second text node based on the pair-level vector.
15. The method of claim 14 , wherein the node label for the first text node based is based on the pair label.
16. The method of claim 14 , further comprising:
generating, by the one or more processors, a node label for the second text node based on the comprehensive vector for the first text node.
17. A processing system, comprising:
a memory; and
one or more processors coupled to the memory and configured to:
generate a plurality of word-level vectors and a plurality of character-level word vectors, the plurality of word-level vectors and the plurality of character-level word vectors corresponding to each word of a first sequence of words of a first text node and each word of a second sequence of words of a second text node, in which a length of each word-level vector of a given word is less than or equal to a length of a character-level word vector of the given word;
generate a comprehensive vector of the first text node based on the plurality of word-level vectors, the plurality of character-level word vectors, and one or more predefined features in content of the first text node; and
generate a node label for the first text node based on the comprehensive vector for the first text node.
18. The system of claim 17 , wherein the node label for the first text node corresponds to one of a plurality of fields-of-interest.
19. The system of claim 17 , wherein the one or more processors are further configured to:
generate a prediction for each of the first text node and the second text node regarding whether the node relates to one of a plurality of fields-of-interest;
generate a comprehensive vector of the second text node based on one or more word-level vectors of the plurality of word-level vectors and one or more character-level word vectors of the plurality of character-level word vectors;
generate a positional vector of the first text node based on at least a relative position of the first text node;
generate a positional vector of the second text node based on at least a relative position of the second text node;
generate a pair-level vector based on at least the comprehensive vector of the first text node, the comprehensive vector of the second text node, the positional vector of the first text node, and the positional vector of the second text node; and
generate a pair label for the first and second text node based on the pair-level vector;
wherein the one or more word-level vectors of the plurality of word-level vectors correspond to the second sequence and the one or more character-level word vectors of the plurality of character-level vectors correspond to the second sequence.
20. The system of claim 19 , wherein the node label for the first text node based is based on the pair label.
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US18/538,584 US20240126827A1 (en) | 2020-01-29 | 2023-12-13 | Transferable Neural Architecture for Structured Data Extraction From Web Documents |
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
PCT/US2020/015602 WO2021154238A1 (en) | 2020-01-29 | 2020-01-29 | A transferrable neural architecture for structured data extraction from web documents |
US202217792788A | 2022-07-14 | 2022-07-14 | |
US18/538,584 US20240126827A1 (en) | 2020-01-29 | 2023-12-13 | Transferable Neural Architecture for Structured Data Extraction From Web Documents |
Related Parent Applications (2)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
PCT/US2020/015602 Continuation WO2021154238A1 (en) | 2020-01-29 | 2020-01-29 | A transferrable neural architecture for structured data extraction from web documents |
US17/792,788 Continuation US11886533B2 (en) | 2020-01-29 | 2020-01-29 | Transferable neural architecture for structured data extraction from web documents |
Publications (1)
Publication Number | Publication Date |
---|---|
US20240126827A1 true US20240126827A1 (en) | 2024-04-18 |
Family
ID=77079642
Family Applications (2)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US17/792,788 Active US11886533B2 (en) | 2020-01-29 | 2020-01-29 | Transferable neural architecture for structured data extraction from web documents |
US18/538,584 Pending US20240126827A1 (en) | 2020-01-29 | 2023-12-13 | Transferable Neural Architecture for Structured Data Extraction From Web Documents |
Family Applications Before (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US17/792,788 Active US11886533B2 (en) | 2020-01-29 | 2020-01-29 | Transferable neural architecture for structured data extraction from web documents |
Country Status (4)
Country | Link |
---|---|
US (2) | US11886533B2 (en) |
EP (1) | EP4078467A4 (en) |
CN (2) | CN115023710B (en) |
WO (1) | WO2021154238A1 (en) |
Families Citing this family (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20230161596A1 (en) * | 2021-11-22 | 2023-05-25 | Oracle Financial Services Software Limited | Unified pipeline flow with common and phase-specific paths |
Family Cites Families (11)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US7694216B2 (en) | 2000-12-19 | 2010-04-06 | International Business Machines Corporation | Automatic assignment of field labels |
EP2638481A1 (en) * | 2010-11-10 | 2013-09-18 | Hewlett-Packard Development Company, L.P. | Seed set expansion |
US8239425B1 (en) * | 2011-02-28 | 2012-08-07 | Battelle Memorial Institute | Isolating desired content, metadata, or both from social media |
US9268749B2 (en) * | 2013-10-07 | 2016-02-23 | Xerox Corporation | Incremental computation of repeats |
US9846836B2 (en) * | 2014-06-13 | 2017-12-19 | Microsoft Technology Licensing, Llc | Modeling interestingness with deep neural networks |
KR20180077690A (en) * | 2016-12-29 | 2018-07-09 | 주식회사 엔씨소프트 | Apparatus and method for learning narrative of document, apparatus and method for generating narrative of document |
JP2018112853A (en) * | 2017-01-11 | 2018-07-19 | 日本放送協会 | Topic classification apparatus and program therefor |
TWI695277B (en) * | 2018-06-29 | 2020-06-01 | 國立臺灣師範大學 | Automatic website data collection method |
CN109271477B (en) * | 2018-09-05 | 2020-07-24 | 杭州数湾信息科技有限公司 | Method and system for constructing classified corpus by means of Internet |
CN109445784B (en) * | 2018-09-29 | 2020-08-14 | Oppo广东移动通信有限公司 | Method and device for processing structure data, storage medium and electronic equipment |
CN109657135B (en) * | 2018-11-13 | 2023-06-23 | 华南理工大学 | Scholars user portrait information extraction method and model based on neural network |
-
2020
- 2020-01-29 US US17/792,788 patent/US11886533B2/en active Active
- 2020-01-29 EP EP20917151.1A patent/EP4078467A4/en active Pending
- 2020-01-29 CN CN202080095203.7A patent/CN115023710B/en active Active
- 2020-01-29 WO PCT/US2020/015602 patent/WO2021154238A1/en unknown
- 2020-01-29 CN CN202311184681.7A patent/CN117313853A/en active Pending
-
2023
- 2023-12-13 US US18/538,584 patent/US20240126827A1/en active Pending
Also Published As
Publication number | Publication date |
---|---|
WO2021154238A1 (en) | 2021-08-05 |
CN117313853A (en) | 2023-12-29 |
CN115023710B (en) | 2023-09-29 |
US20230014465A1 (en) | 2023-01-19 |
CN115023710A (en) | 2022-09-06 |
EP4078467A4 (en) | 2023-04-26 |
EP4078467A1 (en) | 2022-10-26 |
US11886533B2 (en) | 2024-01-30 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
CN111444320B (en) | Text retrieval method and device, computer equipment and storage medium | |
Wang et al. | A machine learning based approach for table detection on the web | |
US9323741B2 (en) | System and method for searching functions having symbols | |
US7386438B1 (en) | Identifying language attributes through probabilistic analysis | |
CN111858944B (en) | Entity aspect level emotion analysis method based on attention mechanism | |
US20240126827A1 (en) | Transferable Neural Architecture for Structured Data Extraction From Web Documents | |
Raj et al. | ConvNet frameworks for multi-modal fake news detection | |
Jabbar et al. | A survey on Urdu and Urdu like language stemmers and stemming techniques | |
CN113168499A (en) | Method for searching patent document | |
CN113196277A (en) | System for retrieving natural language documents | |
US8239425B1 (en) | Isolating desired content, metadata, or both from social media | |
Ahmed et al. | FLAG-PDFe: Features oriented metadata extraction framework for scientific publications | |
CN112445862B (en) | Internet of things equipment data set construction method and device, electronic equipment and storage medium | |
Aladakatti et al. | Exploring natural language processing techniques to extract semantics from unstructured dataset which will aid in effective semantic interlinking | |
Raghavendra Nayaka et al. | An efficient framework for algorithmic metadata extraction over scholarly documents using deep neural networks | |
Illig et al. | A comparison of content-based tag recommendations in folksonomy systems | |
CN113704420A (en) | Method and device for identifying role in text, electronic equipment and storage medium | |
Nayaka et al. | An efficient framework for metadata extraction over scholarly documents using ensemble CNN and BiLSTM technique | |
Singh et al. | Intelligent Text Mining Model for English Language Using Deep Neural Network | |
Arora et al. | Web-based news straining and summarization using machine learning enabled communication techniques for large-scale 5G networks | |
Sequeira et al. | Dynamic review modelling and recommendation of tourism data | |
EP4209967A1 (en) | Identifying a similarity of at least one component entry | |
US11651141B2 (en) | Automated generation of related subject matter footer links and previously answered questions | |
CN114528512A (en) | Webpage content extraction method and device, computer equipment and storage medium | |
Zhao et al. | Orientation Mining-Driven Approach to Analyze Web Public Sentiment. |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:SHENG, YING;LIN, YUCHEN;TATA, SANDEEP;AND OTHERS;SIGNING DATES FROM 20200127 TO 20200221;REEL/FRAME:065860/0977 |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: DOCKETED NEW CASE - READY FOR EXAMINATION |