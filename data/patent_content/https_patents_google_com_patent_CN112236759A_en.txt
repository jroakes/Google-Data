CN112236759A - Staggered merging in a log-structured merge forest - Google Patents
Staggered merging in a log-structured merge forest Download PDFInfo
- Publication number
- CN112236759A CN112236759A CN201980038341.9A CN201980038341A CN112236759A CN 112236759 A CN112236759 A CN 112236759A CN 201980038341 A CN201980038341 A CN 201980038341A CN 112236759 A CN112236759 A CN 112236759A
- Authority
- CN
- China
- Prior art keywords
- merge
- run
- records
- key
- index
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
- 238000000034 method Methods 0.000 claims abstract description 94
- 238000012545 processing Methods 0.000 claims description 157
- 238000003860 storage Methods 0.000 claims description 89
- 239000000872 buffer Substances 0.000 claims description 64
- 230000004044 response Effects 0.000 claims description 26
- 238000009826 distribution Methods 0.000 claims description 18
- 230000000977 initiatory effect Effects 0.000 claims description 3
- 238000005192 partition Methods 0.000 description 163
- 238000003780 insertion Methods 0.000 description 34
- 230000037431 insertion Effects 0.000 description 34
- 230000000875 corresponding effect Effects 0.000 description 32
- 238000011084 recovery Methods 0.000 description 32
- 238000010586 diagram Methods 0.000 description 20
- 230000000694 effects Effects 0.000 description 19
- 238000004422 calculation algorithm Methods 0.000 description 18
- 238000012217 deletion Methods 0.000 description 18
- 230000037430 deletion Effects 0.000 description 17
- 230000008569 process Effects 0.000 description 17
- 238000013461 design Methods 0.000 description 16
- 238000004891 communication Methods 0.000 description 15
- 238000004590 computer program Methods 0.000 description 13
- 230000003044 adaptive effect Effects 0.000 description 11
- 230000008859 change Effects 0.000 description 10
- 238000007596 consolidation process Methods 0.000 description 10
- 230000009471 action Effects 0.000 description 8
- 230000002776 aggregation Effects 0.000 description 8
- 238000004220 aggregation Methods 0.000 description 8
- 238000013459 approach Methods 0.000 description 6
- 230000008901 benefit Effects 0.000 description 6
- 239000013598 vector Substances 0.000 description 6
- 230000003993 interaction Effects 0.000 description 5
- 238000005457 optimization Methods 0.000 description 5
- 230000000670 limiting effect Effects 0.000 description 4
- 238000007726 management method Methods 0.000 description 4
- 230000000644 propagated effect Effects 0.000 description 4
- 230000003321 amplification Effects 0.000 description 3
- 238000004458 analytical method Methods 0.000 description 3
- 238000004364 calculation method Methods 0.000 description 3
- 230000006835 compression Effects 0.000 description 3
- 238000007906 compression Methods 0.000 description 3
- 230000006870 function Effects 0.000 description 3
- 238000002955 isolation Methods 0.000 description 3
- 238000012423 maintenance Methods 0.000 description 3
- 238000003199 nucleic acid amplification method Methods 0.000 description 3
- 230000002085 persistent effect Effects 0.000 description 3
- 238000000638 solvent extraction Methods 0.000 description 3
- 238000012546 transfer Methods 0.000 description 3
- 230000007704 transition Effects 0.000 description 3
- 230000009286 beneficial effect Effects 0.000 description 2
- 230000005540 biological transmission Effects 0.000 description 2
- 230000000903 blocking effect Effects 0.000 description 2
- 230000015556 catabolic process Effects 0.000 description 2
- 238000010924 continuous production Methods 0.000 description 2
- 230000002596 correlated effect Effects 0.000 description 2
- 238000005336 cracking Methods 0.000 description 2
- 238000006731 degradation reaction Methods 0.000 description 2
- 230000001934 delay Effects 0.000 description 2
- 230000006872 improvement Effects 0.000 description 2
- 230000007246 mechanism Effects 0.000 description 2
- 238000010606 normalization Methods 0.000 description 2
- 230000003287 optical effect Effects 0.000 description 2
- 238000002360 preparation method Methods 0.000 description 2
- 230000002829 reductive effect Effects 0.000 description 2
- 230000008439 repair process Effects 0.000 description 2
- 238000011160 research Methods 0.000 description 2
- 230000004043 responsiveness Effects 0.000 description 2
- 230000002441 reversible effect Effects 0.000 description 2
- 238000013515 script Methods 0.000 description 2
- 238000000926 separation method Methods 0.000 description 2
- RZVAJINKPMORJF-UHFFFAOYSA-N Acetaminophen Chemical compound CC(=O)NC1=CC=C(O)C=C1 RZVAJINKPMORJF-UHFFFAOYSA-N 0.000 description 1
- 208000000044 Amnesia Diseases 0.000 description 1
- 208000026139 Memory disease Diseases 0.000 description 1
- 238000003491 array Methods 0.000 description 1
- 230000001174 ascending effect Effects 0.000 description 1
- 230000000712 assembly Effects 0.000 description 1
- 238000000429 assembly Methods 0.000 description 1
- 230000003190 augmentative effect Effects 0.000 description 1
- 230000004888 barrier function Effects 0.000 description 1
- 230000006399 behavior Effects 0.000 description 1
- 238000005056 compaction Methods 0.000 description 1
- 230000000295 complement effect Effects 0.000 description 1
- 239000002131 composite material Substances 0.000 description 1
- 230000001276 controlling effect Effects 0.000 description 1
- 238000013523 data management Methods 0.000 description 1
- 230000003247 decreasing effect Effects 0.000 description 1
- 239000000284 extract Substances 0.000 description 1
- 230000037406 food intake Effects 0.000 description 1
- 238000013467 fragmentation Methods 0.000 description 1
- 238000006062 fragmentation reaction Methods 0.000 description 1
- 230000010354 integration Effects 0.000 description 1
- 238000005304 joining Methods 0.000 description 1
- 239000004973 liquid crystal related substance Substances 0.000 description 1
- 238000013507 mapping Methods 0.000 description 1
- 230000006984 memory degeneration Effects 0.000 description 1
- 208000023060 memory loss Diseases 0.000 description 1
- 238000012544 monitoring process Methods 0.000 description 1
- 230000008520 organization Effects 0.000 description 1
- 230000036961 partial effect Effects 0.000 description 1
- 238000011176 pooling Methods 0.000 description 1
- 230000010076 replication Effects 0.000 description 1
- 238000005070 sampling Methods 0.000 description 1
- 239000004065 semiconductor Substances 0.000 description 1
- 230000001953 sensory effect Effects 0.000 description 1
- 238000012163 sequencing technique Methods 0.000 description 1
- 238000001228 spectrum Methods 0.000 description 1
- 239000000758 substrate Substances 0.000 description 1
- CCEKAJIANROZEO-UHFFFAOYSA-N sulfluramid Chemical group CCNS(=O)(=O)C(F)(F)C(F)(F)C(F)(F)C(F)(F)C(F)(F)C(F)(F)C(F)(F)C(F)(F)F CCEKAJIANROZEO-UHFFFAOYSA-N 0.000 description 1
- 230000002123 temporal effect Effects 0.000 description 1
- 238000013519 translation Methods 0.000 description 1
- 230000000007 visual effect Effects 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/22—Indexing; Data structures therefor; Storage structures
- G06F16/2228—Indexing structures
- G06F16/2246—Trees, e.g. B+trees
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/22—Indexing; Data structures therefor; Storage structures
- G06F16/2228—Indexing structures
- G06F16/2272—Management thereof
Abstract
At least one aspect of the present disclosure is directed to a system and method of maintaining a key-value store. The method can include establishing a first run of data records indexed by key values. The method may include tracking a merge of data records of the first run onto a merge level on a database using an index. The method may include establishing a second run of data records indexed by the key value concurrently with the merging of the first run. The method may include determining that an index at which a data record tracking a first run merges to a merge level satisfies a quantile condition. The method may include adding a subset of the second plurality of records of the second run to a merge of the first plurality of records of the first run to a merge level maintained on the database.
Description
Cross Reference to Related Applications
The present application claims priority from U.S. provisional patent application No.62/731,630 entitled "staged recording in Log-Structured recording forms" (Log structure Merge cross-merges in forest), filed 2018, month 9, and day 14, in accordance with PCT 8, which is incorporated herein by reference in its entirety.
Technical Field
The data may be maintained and indexed in a database. Some large index databases may implement large insertion volumes. The database may process the query to search the database for one or more entries.
Disclosure of Invention
At least one aspect of the present disclosure is directed to a method of maintaining a key-value store. The method can include establishing, by a data processing system having one or more processors, a first run on a first buffer for sorting a first plurality of records. The first plurality of records can be initially indexed by a first corresponding plurality of index values. Each record of the first plurality of records can have a first key value in a key field. A key domain can define multiple key values. The method can include using, by the data processing system, a merge index to track a merge of a first plurality of records of a first run onto a merge level maintained on a database. The merge index can reference a first key value of a record of the first plurality of records added to the merge level during the merge. The method can include establishing, by the data processing system, a second run on the second buffer for sorting the second plurality of records concurrently with the merging of the first plurality of records. The second plurality of records can be indexed by a second corresponding plurality of index values that is different from the first plurality of index values. Each record of the second plurality of records can have a second key value in the key field. The method can include determining, by the data processing system, that a merge index that tracks a first plurality of merges recorded onto a merge level satisfies a quantile condition. The quantile condition can correspond to at least one of a plurality of key values in a key domain. The method can include identifying, by the data processing system, a subset of the second plurality of records of the second run from the second buffer in response to determining that the merge index corresponds to the split-point condition. Each record of the subset can have a corresponding second key value that satisfies the quantile criterion. The method can include adding, by the data processing system, a subset of the second plurality of records of the second run to a merge of the first plurality of records of the first run to a merge level maintained on the database.
In some implementations, the method can include determining, by the data processing system, a switchover key value based on a ratio of the merge index and a quantile index specified by a quantile condition. In some implementations, the method can further include determining, by the data processing system, a bandwidth offset based on the consolidated bandwidth of the database. The merge bandwidth can indicate a rate at which the database is adding the first plurality of records and a subset of the second plurality of records are being merged. In some implementations, determining that the merge index satisfies the split-point condition can include determining that the merge index satisfies a transit key value adjusted by a bandwidth offset.
In some implementations, the method can include tracking, by the data processing system, establishment of a second run using the second plurality of records using the run index. The run index can reference the number of second plurality of records ordered in a second run. In some implementations, the method can include determining, by the data processing system, that a second key value of a record of the second plurality of records referenced by the run index satisfies the split-point condition. In some implementations, adding the subset of the second plurality of records can include initiating adding the subset of the second plurality of records of the second run to the merge concurrently with establishing the second run and in response to determining that a second key value of the record referenced by the run index satisfies the quantile point condition.
In some implementations, the method can further include identifying, by the data processing system, a first run generation rate that establishes the first run on the first buffer. The first run generation rate can indicate a speed at which records of the first plurality of records are ordered in the first run. In some implementations, the method can include identifying, by the data processing system, a second run generation rate that establishes a second run on a second buffer. The second run generation rate can indicate a speed at which records of the second plurality of records are ordered in the second run. In some implementations, the method can include setting, by the data processing system, a merge bandwidth for adding the first plurality of records of the first run to the database based on at least one of a first run generation rate and a second run generation rate.
In some implementations, the method can further include identifying, by the data processing system, a distribution over the key domain of a corresponding plurality of first key values for the first plurality of records. In some implementations, the method can further include determining, by the data processing system, a plurality of quantile point conditions including a quantile point condition based on a distribution of the corresponding plurality of first key values over the key domain.
In some implementations, the method can include determining, by the data processing system, a merge level at which all of the first plurality of records of the first run are added to the database while the subset of the second plurality of records and the first plurality of records are merged at the merge level. In some implementations, the method can include releasing, by the data processing system, the first buffer from the first plurality of records to receive a third plurality of records for a third run in response to determining that all of the first plurality of records of the first run are added. In some implementations, the method can include maintaining, by the data processing system, the second plurality of records on the second buffer concurrently with the merging of the subset of the second plurality of records onto the database at the merge level.
In some implementations, the method can include determining, by the data processing system, that the merging of the subset of the second plurality of records and the first plurality of records is complete at a merge level on the database. In some implementations, the method can include initializing, by the data processing system, a second merge level on the database to receive a merge of at least a remaining subset of the second plurality of records of the second run in response to determining that the merge onto the merge level is complete.
In some implementations, the method can include receiving, by a data processing system, a query for at least one of a plurality of key values defining a key domain. In some implementations, the method can include using, by the data processing system, the query to search a merge level on the database, the merge level including records from the plurality of runs.
In some implementations, merging the subset of the second plurality of records further includes tracking, using the second merge index, a merge of the subset of the second plurality of records onto a merge level on the database. The second merge index can reference a second key value added to one of the second plurality of records at the merge level during the merge. The second merge index can be initially set based on the quantile condition.
In some implementations of the method, establishing the first run can include sorting the first plurality of records by a corresponding plurality of first key values over the key field using at least one of a quick sort or priority queue. The first plurality of records can be initially arranged by a first corresponding plurality of index values. In such implementations of the method, establishing the second run can include receiving a second plurality of records from the data acquisition source via the input data stream for storage on a second buffer. The second plurality of records can be initially arranged by sorting the second plurality of records by a corresponding plurality of second key values over the key field using at least one of a quick sort or priority queue.
At least one other aspect of the present disclosure is directed to a system for maintaining a key-value store, comprising a data processing system having one or more processors. The data processing system can establish a first run on the first buffer for sorting the first plurality of records. The first plurality of records can be initially indexed by a first corresponding plurality of index values. Each record of the first plurality of records can have a first key value in a key field. A key domain can define multiple key values. The data processing system can use the merge index to track the merge of the first plurality of records of the first run to a merge level maintained on the database. The merge index references a first key value added to a record of the first plurality of records at the merge level during the merge. The data processing system can establish a second run for sorting the second plurality of records concurrently with the merging of the first plurality of records. The second plurality of records can be indexed by a second corresponding plurality of index values that is different from the first plurality of index values. Each record of the second plurality of records can have a second key value in the key field. The data processing system can determine that a merge index that tracks a merge of the first plurality of records to a merge level satisfies a quantile condition. The quantile condition can correspond to at least one of a plurality of key values in a key domain. In response to determining that the merge index corresponds to the quantile point condition, the data processing system can identify a subset of the second plurality of records of the second run from the second buffer. Each record of the subset can have a corresponding second key value that satisfies the quantile criterion. The data processing system can add a subset of the second plurality of records of the second run to a merge of the first plurality of records of the first run to a merge level maintained on the database.
In some implementations, the data processing system is further configured to determine the diversion key value based on a ratio of the merge index and a quantile index specified by the quantile condition. In some implementations, the data processing system can determine the bandwidth offset based on the consolidated bandwidth of the database. The merge bandwidth can indicate a rate at which the database is adding the first plurality of records and a subset of the second plurality of records are being merged. In some implementations, the data processing system can determine that the merge index satisfies the switchover key value adjusted by the bandwidth offset.
In some implementations, the data processing system can use the run index to track the creation of the second run using the second plurality of records. The run index references the number of second plurality of records ordered in a second run. In some implementations, the data processing system can determine that a second key value of a record of the second plurality of records referenced by the run index satisfies the split-point condition. In some implementations, the data processing system can initiate adding a subset of the second plurality of records of the second run to the merge concurrently with establishing the second run and in response to determining that a second key value of the record referenced by the run index satisfies the quantile point condition.
In some implementations, the data processing system can identify a first run generation rate that establishes a first run on the first buffer, the first run generation rate indicating a speed at which records of the first plurality of records are ordered in the first run. In some implementations, the data processing system can identify a second run generation rate that establishes a second run on the second buffer. The second run generation rate can indicate a speed at which records of the second plurality of records are ordered in the second run. In some implementations, the data processing system can set a merge bandwidth for adding the first plurality of records of the first run to the database based on at least one of a first run generation rate and a second run generation rate.
In some implementations, the data processing system can identify a distribution of a corresponding plurality of first key values over a key domain for a first plurality of records. In some implementations, the data processing system can determine a plurality of quantile locations including a quantile location condition based on a distribution of the corresponding plurality of first key values over the key domain.
In some implementations, the data processing system can determine a merge level at which all of the first plurality of records of the first run are added to the database while merging the subset of the second plurality of records and the first plurality of records at the merge level. In some implementations, the data processing system can release the first buffer from the first plurality of records to receive a third plurality of records for a third run in response to determining that all of the first plurality of records of the first run were added. In some implementations, the data processing system can maintain the second plurality of records on the second buffer concurrently with the merging of the subset of the second plurality of records onto the database at the merge level.
In some implementations, the data processing system can determine that the merging of the subset of the second plurality of records and the first plurality of records is complete at the merge level on the database. In some implementations, the data processing system can initialize a second merge level on the database to receive a merge of at least a remaining subset of the second plurality of records of the second run in response to determining that the merge onto the merge level is complete.
In some implementations, a data processing system can receive a query for at least one of a plurality of key values defining a key domain. In some implementations, the data processing system can use the query to search a merge level on the database, the merge level including records from multiple runs.
In some implementations, the data processing system can use the second merge index to track a merge of the subset of the second plurality of records to a merge level on the database. The second merge index can reference a second key value added to one of the second plurality of records at the merge level during the merge. The second merge index can be initially set based on the quantile condition.
In some implementations, the data processing system can sort the first plurality of records by a corresponding plurality of first key values over the key domain using at least one of a quick sort or priority queue. The first plurality of records can be initially arranged by a first corresponding plurality of index values. In some implementations, the data processing system can receive a second plurality of records from the data acquisition source via the input data stream for storage on the second buffer. The second plurality of records can be initially arranged by a second corresponding plurality of index values. In some implementations, the data processing system can sort the second plurality of records by a corresponding plurality of second key values over the key domain using at least one of a quick sort or priority queue.
Aspects provide for interleaved merging for merging data, such as records in a database. Staggered merging enables merging to be performed in a continuous and stable manner, as compared to previous approaches that may result in merging operation bursts, causing computational load spikes that may severely degrade the performance of concurrent query operations. Interleaving may be based on a quantile point condition, i.e., when the quantile point condition is satisfied during merging, a second run may be added to the current merge. The quantile point condition may determine a subset of the second run of data to participate in the merging. For example, when another quantile point condition is satisfied or when the current merge is complete and another merge operation begins, the remaining run data of the second run is throttled for later merging. The merging may be hierarchical and arranged into a merge level. The output of the merge at a particular level may provide another run for merging at the next level. Are merged at all levels and then interleaved. These and other aspects and implementations are discussed in detail below. The foregoing information and the following detailed description include illustrative examples of various aspects and implementations, and provide an overview or framework for understanding the nature and character of the claimed aspects and implementations. The accompanying drawings are included to provide an illustration and a further understanding of the various aspects and implementations, and are incorporated in and constitute a part of this specification. Aspects can be combined, and it will be readily appreciated that features described in the context of one aspect of the invention can be combined with other aspects. Aspects can be implemented in any convenient form. For example, by means of a suitable computer program which may be carried on a suitable carrier medium (computer readable medium), which may be a tangible carrier medium (e.g. a diskette) or an intangible carrier medium (e.g. a communications signal). Aspects may also be implemented using suitable apparatus, which may take the form of a programmable computer running a computer program arranged to implement the aspects.
Drawings
The drawings are not intended to be drawn to scale. Like reference numbers and designations in the various drawings indicate like elements. For purposes of clarity, not every component may be labeled in every drawing. In the drawings:
fig. 1 shows two graphs illustrating the fluctuation of pain after index creation using an old strategy and a new splitting strategy.
Fig. 2 is a diagram illustrating load fluctuations due to occasional merging steps, sometimes even simultaneously, at multiple merge levels.
Fig. 3A and 3B show diagrams illustrating the merge step of reading F runs at merge level i and writing a new run at merge level i + 1.
Fig. 4A-4C show diagrams illustrating how merging starts immediately after run generation has completed its first run.
Fig. 5 is a diagram illustrating run size, run count, and current run count changes as a function of run level.
FIG. 6 shows a diagram illustrating query processing. The query can first check for the most recent small runs.
Fig. 7 shows a diagram illustrating how a switchover key value can be replaced with a lower value.
FIG. 8 illustrates a block diagram depicting an example environment for maintaining key-value stores by performing interleaved merging.
Fig. 9A shows a diagram illustrating a one-way merge becoming a two-way merge in response to a merge index reaching a target quantile.
Fig. 9B shows a diagram illustrating two-way merging continuing while a third input data stream is being assembled concurrently.
FIG. 9C shows a diagram illustrating a two-way merge changing to a three-way merge in response to a merge index reaching a target quantile
Fig. 9D shows a schematic diagram of completion of merge level initialization.
Fig. 9E shows a diagram illustrating a change of one-way merging into two-way merging in response to a merge index reaching a target quantile in contention-staggered merging.
FIG. 10 shows a diagram illustrating an in-memory index and its associated key-pointer pair.
FIG. 11 illustrates a flow chart of an example method of maintaining a key value store by performing interleaved merging.
FIG. 12 shows a general architecture of an illustrative computer system that may be employed to implement any of the computers discussed herein.
Detailed Description
For purposes of reading the following description of the various embodiments, the following description of the various portions of the specification and their respective contents may be helpful:
part a describes interleaving and merging.
Section B describes maintaining key-value stores by performing interleaved merging.
Section C describes a general computer system that can be used to implement one or more of the elements described in this application.
A. Interleaving and merging
Log-structured merge trees (forests) are good at subtitling new insertions with high bandwidth, but they may involve repeating the merge step in order to reduce the number of b-tree partitions searched in each subsequent query. For an efficient merge step, merge kickbacks at each level when there are a sufficient number of runs; furthermore, occasionally, multiple merge steps across multiple merge levels may immediately follow each other.
Each running merge step increases contention for the processor, buffer pool, and I/O path. These repeated bursts of activity and competition create fluctuations that reduce query performance, thereby creating fluctuations that are not user-full.
The present disclosure describes a schedule for organizing all merge activities in a way that stabilizes and minimizes the number of merge levels and runs (or partitions) and at the same time smoothes all merge activities without any noticeable bursts. Run generation and its bandwidth driving merge at each merge level. One difference of this approach from other merging strategies is that runs enter the merging step one at a time, rather than all at once as in all such other merging strategies.
Log structured merged trees, such as b-trees or equivalent partitioned b-trees' forests, are widely used in data management platforms, particularly where high bandwidth data intake, such as analysis of web logs, is important. In fact, the constant arrival of log records may even put pressure on large-scale clusters that attempt to capture and index new information in multiple dimensions to enable dashboard and offline analysis.
In other approaches, merge runs or partitions are occasionally employed. Not every new run involves a subsequent merge step. Merging may occur in bursts. If the input stream continues, for example, because the activity of generating the log record continues, merging and run generation can occur simultaneously. Often times, even multiple merge steps can run concurrently with run generation. As merging activities start and stop, concurrent query processing suffers unpredictable performance and user dissatisfaction becomes inevitable. Addressing degradation in query processing performance and user satisfaction requires a pattern of run-length generation and consolidation that runs continuously, efficiently, and with a continuous load on processing, buffer pools, and input/output (I/O) resources.
The current disclosure introduces scheduling (or logic) of run generation and merging, referred to herein as interleaved merging. The merge logic can run continuously and with the same bandwidth (e.g., records per second) as run generation. In general, the merge process described in this disclosure may be as efficient as in external merge sequencing, e.g., in terms of, for example, number of comparisons per record or I/O round trips per record.
B-tree indexes are commonly used in databases, key-value stores, file systems, and information retrieval. For example, a B-tree can be used to search or sort data in a database. In addition, the B-tree can allow fast random access to any block in a particular file of the file system. B-tree indexes are ubiquitous in databases, key-value stores, file systems, and information retrieval. There are many variations and optimizations of the B-tree index. For example, a b-tree key may be multi-column (e.g., composite index), hash value (e.g., ordered hash index enables efficient creation, efficient interpolation search, and easy ghost protection), space-filling curve (e.g., spatial index for multidimensional data and query predicates), or heterogeneous key (e.g., merged index or master-slave clustering). In addition, both keys and values can be compressed, e.g., as a bit vector filter rather than a sequence of line identifiers.
B-tree creation can benefit from ordering, but ordering can also benefit from B-trees. For example, runs in an external merge sort in the form of a b-tree or even all runs within a single-partition b-tree or a linearly-partitioned b-tree can achieve efficient read-ahead during merge and query processing while the merge step is still incomplete. This read-ahead capability is the basis for the log-structured merge tree discussed below.
Even if the initial b-tree creation leaves some free space in each node, e.g., 10%, the insertion may eventually force a fluctuation in node splitting. This fluctuation of node split may be sharp and high if there is a high correlation between the original key-value distribution and the inserted key-value distribution. The first fluctuation of node splitting is able to split most or all of the original b-tree nodes, doubling the size of the b-tree. When the size of the b-tree doubles over and over again, there may be subsequent fluctuations. The fluctuations may become less frequent, less abrupt, and less high.
Fig. 1 shows two graphs illustrating the fluctuation of pain after index creation using an old strategy and a new splitting strategy. Shortly after creating a new b-tree index with some free space in each node, the insertion can cause the node to split. Node splits (or calls to such splits) may occur in a wave if the insertions are highly correlated to the key value distribution of the original b-tree population. Node splitting can impose additional contention on processing, buffer pools, and I/O resources, thereby reducing query processing performance, increasing query latency, and causing user dissatisfaction.
Write optimized b-tree
The B-tree incurs a high write penalty. In particular, modifying a single byte, field, or record forces a random page to be written to persistent storage. Write-optimized b-trees attempt to reduce this cost by tuning random writes to sequential writes. More specifically, the write optimized b-tree employs append-only storage at page granularity, tracking new page storage locations within the b-tree structure. Each page move involves a pointer update in the parent page. Thus, the write optimized b-tree contains the functionality of a Flash Translation Layer (FTL). They do not allow neighbor pointers between peer nodes, however, they allow for a full consistency check (online/continuous or offline/utility) by a copy of the barrier key in each page, e.g., the branch key in an ancestor page.
Write optimized b-trees may suffer from poor scan performance on storage devices with high access latency (e.g., seek and rotation delays). One possible optimization is to divide the key range into a plurality of segments, store each segment in contiguous storage, and recycle the replacement pages within the segments. The key range of each segment may be dynamic in that the key range of each leaf node is dynamic in the b-tree. The resulting design combines the elements and advantages of write optimized b-trees and SB-trees. In flash storage, a segment may coincide with an erase block.
External merge sort
In external merging, there are a wide variety of possible sort keys, such as search keys in a b-tree index. The main stages of external merging include run generation and merging. Efficient run generation doubles the average size of each run through alternative selection, also known as run generation with priority queues or heaps. Efficient merging requires balanced merging, where all key values participate in equal or similar counts of comparisons, and merge at high fan-in, which also reduces the number of merge levels.
There are a number of strategies for interleaving run generation and merging. One strategy to interleave run generation and merging is lazy merge, which includes separate operator stages for run generation, intermediate merge steps, and final merge steps. Among all strategies for interleaving run generation and merging, lazy merge involves the largest directory of runs. Another strategy, as opposed to strategy spectrum, is eager merging, where the directory size within each merge level is limited to fan-in, and the merge step is invoked when the run count on any level reaches fan-in. Between these two strategies, semi-eager merging limits the directory size at each level to twice the fan-in and semi-lazy merging uses a single directory across all levels and limits its size, merging runs of similar size whenever a directory is full. Most database products use lazy merge. Most log structured merge trees like Napa employ eager merging. SQL Server used semi-lazy merge in the past. Volcano uses semi-eager merging.
Run generation and merging can integrate grouping, such as duplicate removal or aggregation. The grouping during run generation implements in-memory grouping for any input size as long as the final output fits into the memory. Grouping while writing runs ensures that no run contains a repeated key value and that no run is larger than the final output.
Log structured merge deep forest
If most updates in the b-tree index are inserts, the most promising storage structure is a log-structured merged tree, which is a collection of trees (forest), or a partitioned b-tree using the artificial lead key field as a partition identifier.
Log structured merge forests are widely used in NoSQL databases, key-value stores, and applications that consume and index continuous data streams. Its in-memory index for the most recent unsorted input data reflects the external merge sort (as opposed to the fast sort in the read-sort-write cycle or priority queue for replacement selection) that employs the in-memory index for run generation. The use of a merge b-tree or b-tree partition reflects merges in an external merge ordering. One difficult problem may include the option of merging fans. In external merge sorting, fan-in is limited by the memory available to the input buffer. In log-structured merge forests, fan-ins are determined by the tension between high fan-ins and low fan-ins for best merge efficiency, so that there are few partitions at any time and queries will examine few partitions. Some real-world implementations of log-structured merging forests employ binary merging steps, thereby making query performance superior to merging efficiency.
Another problem has been ignored to date. The eager merge step causes severe load fluctuations with sometimes no active merges, sometimes one merge, sometimes multiple merge steps.
Fig. 2 is a diagram illustrating load fluctuations due to occasional merging steps, sometimes even simultaneously, at multiple merge levels. It seems highly desirable to achieve a better trade-off between consolidation efficiency, query responsiveness (latency) and continuous system load.
Interleaving and merging
Interleaved merging involves immediately integrating each completed run into its next merging step. For example, the merge step that forms the level 1 run picks it up immediately each time the run generation completes the level 0 run. After the level 1 run is complete, the merge step picks it up immediately, and so on. If the time run generation produces a full set of level 0 runs, e.g., as many merge fans F as desired, the merge step can consume and merge the same volume of data.
The difference is that each run allows a scan that looks for a specific key and continues the sort from there, as opposed to an external merge sort. Thus, each run is not a sorted file but a b-tree or equivalent storage structure. In practice, the run sets at the same level within the merge logic may be a single linear partition b-tree. If so, the root-to-leaf search can occur entirely in memory.
Steady state at each merge level
In steady state, there are F completed level 0 runs plus one incomplete run being formed by the run generation. When run generation completes one run and proceeds to the next run, the newly completed run immediately adds merge logic. To accomplish that, the previous run is dropped from the merge logic. Since the merge logic proceeds once through the key field while the run generation creates F new runs, the principle may be that a newly completed run joins the merge logic not with its lowest key value, but with the key value currently being merged. Therefore, most runs participate in two merging steps: the first merging step consumes all key values above the given transit key value, and the second merging step consumes all key values below the transit key value.
There is a different jog key value for each of the F merge inputs. Ideally, the adapter key value is chosen to approximate the quantile. One merge input may be toggled at a time. An initial transfer key value can be set during the first merging step. They can be adjusted incrementally.
Fig. 3A and 3B show diagrams illustrating the merge step of reading F runs at merge level i and writing a new run at merge level i + 1. Run i and earlier runs have been merged, their content can be found at level l + 1, and these runs have thus been deleted and their space on temporary storage reclaimed. The merge logic currently consumes records from runs i +1 through i + F. Merging (from merge level l-1) or run generation (if l ═ 0) continues to add runs at level l, currently writing a run i + F + 1. The merge logic adds the run i +1 at- ∞, the run i +2 as the merge traverses the key domain, etc., and most recently the run i + F.
The merge logic is currently close to + ∞. That should coincide with the run generation or completion of the lower level merging of the run i + F + 1. At that time, the run creation at level l will switch to the run i + F + 2. Merging from level l to level l +1 drops (and deletes) the run i +1, adds the run i + F +1, wraps from + ∞ to- ∞ in runs i +2 to i + F, completes the run j at merge level l +1 and switches to the run j +1, and resumes merging.
Initialization of each merge level
The merge begins as soon as the run generation completes its first run. First, the merge fan-in is 1. When the run generation completes its second run, the merge logic should have reached a key value equal to the 1/F quantile of the key value distribution. Merging two runs continues from this split-point key. Now ignore the first 1/F fraction of the second run; it will go into the second merged output run. When run generation completes its third run, the merge logic should have reached a key value equal to the 2/F quantile instead. Merging three runs continues from this split-point key.
In this way, the actual merged fan-in grows from 1 to F during the first pass through the key field. When the merge logic reaches the end of the key field, a run can be dropped from the merge (and indeed from temporary storage), and the merge logic can add the F +1 th run.
Fig. 4A-4C show diagrams illustrating how merging starts immediately after run generation has completed its first run. Finally, runs 0 through F-1 from merge level 0 form run 0 of merge level l. Since the merge starts with a trivial fan-in of 1, run 0 at merge level l will have few records in its lowest key range. When run generation completes the second run and the merge logic reaches the first jump key value, trivial single-input merges become a true two-input (binary) merge. As the run generation completes more runs and the merge logic reaches a further jump key value, the merge fan-in grows to reach full fan-in F. This fan-in is used from the last transfer key value to the end of the merge step. The merge logic continues to fan in all from level 0 to level 1 until all inputs are exhausted indefinitely for the stream inputs. When the merge logic first reaches + ∞, it completes the first run on level l, and the merge logic starts from level l up to level 2.
The initial merging effort is not as efficient as full F-way merging. However, other methods of merge ordering do not begin merging even until the run generation has completed F runs. When the F runs are completed, the current interleaved merge achieves full effect with full fan-in of the F runs. It continues to be fully active until the input ends (always for the stream).
The initial transition key value may be any reasonable estimate of the quantile within the key domain and the distribution of key values in the unsorted input. The switchover key value can be incrementally adjusted very gracefully.
Shutdown of each merge level
If the unordered input stream is limited, the merge logic continues at each merge level until its inputs are fully processed and all runs have been dropped from the merge logic and from temporary storage. One difficulty is the different selection of the join key in the different merge levels.
System state
The same transit key value is associated with all merge levels. In effect, the entire design for the merge level 0 run continues to merge level i runs to form all levels of the level i +1 run. In other words, the next level merge begins as soon as the first merge completes its first output run, albeit initially beginning with a trivial merge fan-in. Thus, at each level, there are F completed runs and the merge logic is currently fed and another run is currently being formed. There is always a top level merge currently being initialized; initialization of the next merge level begins once that merge reaches its steady state when it completes its first output run. The top level merge (at any point in time) can run at less than full fan-in F. All lower intermediate merge levels can operate with full fan-in, with balanced input sizes, and thus with maximum efficiency and effectiveness.
The bandwidth at each merge level is the same as the run generation bandwidth. Each merge level is capable of processing as many runs of lines or pages (per unit time) as run generation results from its unsorted stream input. The storage consumption grows exponentially (by a factor equal to the merge fan-in F) step by step like the run size. The merge logic slows down step by step (also by a factor F) by the speed at which it proceeds through the key field.
Fig. 5 is a diagram illustrating the change in run size, run count, and current run count as a function of run level. The left part shows how the size of the run grows from one merge level to the next. In practice, these sizes grow exponentially, so unless the size is indicated on a logarithmic scale, the triangle is not the exact correct shape. The central portion shows the counts of runs created and merged at each level across the entire sort activity. The right part shows the count of runs that exist at each level at any point in time. This number is constant across all merge levels at F +1(F merge inputs, 1 run generation or output of lower merge levels), except for the current highest merge level at which the merge is still in its initialization stage. (not shown here as merge off).
At any point in time, a large block of data is in the highest level or it is currently being merged and moved to that level. As soon as the first run completes at the new level, there is as much data in that level of the run as in each previous level. This is also the time when the merge starts under this level and this level becomes the new top level.
As a specific example, consider a single node in a highly parallel cluster absorbing inputs into an initial run of 1GB at 50MB/s and merging them with a fan-in of 10. After 6 merge levels, the merge logic has read and written each record 6 times, the run size will be 1EB (per node), the total processing bandwidth (across run generation and all merge levels) will be 350MB/s, the count of the current existing run will be 66 (including the one formed under each merge level), and the count of the runs searched in each query will be 60. Note that 1EB/50MB/s is 20M seconds
Query processing
The query process can determine which runs to search for and then efficiently search for them. If each run is a b-tree or a partition within a b-tree, it is easy to search within each run. Among all existing runs, the query can search for any run that satisfies the following condition: (1) run complete-no writer attaches more data to the run, neither run generation nor merge; (2) runs have not been fully merged into runs at the next merge level-the merge step is still reading runs; and (3) a switchover key value with the current merge position higher than the run-no completed run already holding the run content at the next merge level.
FIG. 6 shows a diagram illustrating query processing. The query can first check for the most recent small runs. If the query references a specific time range, then some runs can be skipped. For a range query, it may be necessary to divide the query predicate in two, i.e., whether the transit key value of a run falls within the query predicate. If the ranked outputs are desired, the query execution plan will merge the scan outputs from multiple b-trees (or partitions). Since each individual scan provides a sort key, sorting may not be performed from scratch, nor will the union of all scan results be considered unsorted.
Overview of interleaved Merge
In summary, interleave merge turns an unordered input stream into an ordered index. It employs run generation and merging in the style of a log-structured merge tree. Merging is efficient because it is balanced so that in each merging step all input records have participated in the same number of earlier comparisons (except for rounding errors). Merge fanin can be chosen to get the best tradeoff between merge efficiency and the number of runs (b-trees, partitions) that exist at any time, such as the run that the query is to check.
At each merge level, the merge logic cycles through the key fields in succession. Defining that the characteristic is that different runs enter the merging step by different key values; each run is merged over the entire key field by one full loop. The current highest level merge step incrementally increases its merge; all lower merge steps are always run at the selected fan-in.
This merge strategy minimizes the number of runs that exist at any point in time. It may also stabilize this number at each merge level as well as at the overall merge level. The variants discussed below attempt to query higher level runs even more aggressively than the above designs.
Adjusting changeover key values
A good choice for the switch value is the quantile. However, the best current estimate of the split point key values can change over time. Thus, the set of transit key values can change. The following text and figures focus on adjusting a single transit key value.
Fig. 7 shows a diagram illustrating how the transit key value is replaced with a lower value. Without such a change, the merge logic would add the input run 0.F +2 immediately after the run 0.2 was dropped. If a lower switchover value is desired, the merge logic will add 0.F +2 slightly earlier at the lower key value. Thus, the merge logic temporarily has more than F inputs. If the incremental change is sufficient, the merge logic can be limited to the maximum fan-in F +1 when lowering the jump key value, and to the minimum fan-in F-1 when a higher jump key value is desired.
In summary, log-structured merge trees are ideally suited to combine high-bandwidth data intake and efficient query processing by indexing new information across multiple dimensions. On the other hand, other implementations involve occasional merge steps that impose a load on the CPU, buffer pool, and I/O devices, which in turn slows query processing and causes user confusion due to unpredictable responsiveness.
Sorting and merging is most efficient if each merging step has balanced inputs. Successive merges at each merge level achieve equal bandwidth in run generation and in each merge level and fixed storage requirements for each level of the run. Merging becomes a continuous process at each level rather than expecting bursty behavior, which is somewhat reminiscent of run generation becoming a continuous process by relying on alternative selection (e.g., using priority queues) rather than read-sort-write cycles (e.g., using fast-sort). By avoiding load spikes and performance scarps, the proposed merging strategy avoids "painful fluctuations" in other approaches.
The log-structured merge-tree and the step-merge-tree are a forest of many b-trees that provide a trade-off choice in favor of high-bandwidth data ingestion or low-latency index searches. Efficient merging of b-trees or partitions, i.e. few merge levels require maximum fan-in; but efficient searching, i.e. few partitions at a time, requires a minimum fan-in, i.e. a binary merging step. This tension cannot be eliminated, but both techniques can change the relationship between the merged fan-in and partition count in the query. In a typical case, the merged fan-in is increased by 21/2Doubling and merging level count by 11/2The search effort per query, however, is improved by almost 2 times. The proposed algorithm and storage structure is designed for use within each node of a cluster or data center; they are orthogonal to partitions, clusters, data centers, redundancy, and global scaling.
B. Maintaining key value stores by performing interleaved merging
The following is a more detailed description of various concepts related to methods, apparatus and systems for staggered consolidation in a log-structured consolidation forest and implementations thereof. The various concepts introduced above and discussed in greater detail below may be implemented in any of numerous ways, as the concepts described are not limited to any particular manner of implementation.
B-tree indexing has been ubiquitous in databases, key-value stores, file systems, and information retrieval for decades. They excel in random insertion and deletion, point and range queries, and mixed workloads. In addition, they have excellent operational characteristics, including efficient index creation after sorting, efficient consistency checking, serializable fine-grained concurrency control by locking key values and gaps between them, and efficient query execution using sorted streams, such as intra-stream aggregation and join-by-merge after ordered scanning. Indexing large data streams such as logs and history tables that are continuous is not advantageous because even a minimal update or insertion requires reading and writing at least a leaf page (in most contexts). In other words, most insertion applications suffer from write amplification equal to the blocking factor (per page record, e.g., several hundred). The count of reads (for updates) is equal to the count of writes (ignoring buffer effects, assuming the index is much larger than the available or allocated buffer pool).
Introduction to the design reside in
B-tree indexing may be used in databases, key-value stores, file systems, and information retrieval. They excel in random insertion and deletion, point and range queries, and mixed workloads. In addition, they have excellent operational characteristics, including efficient index creation after sorting, efficient consistency checking, serializable fine-grained concurrency control by locking key values and gaps between them, and efficient query execution using sorted streams, such as intra-stream aggregation and join-by-merge after ordered scanning. Indexing large data streams such as logs and history tables that are continuous is not advantageous because even a minimal update or insertion requires reading and writing at least a leaf page (in most contexts). In other words, most insertion applications suffer from write amplification equal to the blocking factor (per page record, e.g., several hundred). The count of reads (for updates) is equal to the count of writes (ignoring buffer effects, assuming the index is much larger than the available or allocated buffer pool).
The log structured merge tree and the step merge tree are specifically designed for indexing logs and history tables. They can employ large sequential reads and writes, write amplification is equal to the merge depth (e.g., about ten), and read count is equal to write count. However, they support simultaneous searches at the merge, including the concurrent control and recovery techniques required. Research introduced into the log-structured merge tree demonstrates that for its target application, the log-structured merge tree is significantly superior to the b-tree in terms of resource efficiency and data center cost.
This research has been motivated by real-world application capture, indexing, and query logging. Specific examples may include database recovery logs that are strictly ordered by time plus log archives ordered and indexed by database page identifier to enable single page repair as well as instant restart, instant restore, instant failover, self-repair indexing, etc.; or many concurrent users need to assemble and analyze the web services of the user session (sort, index, and aggregate log records on user identifiers).
Relevant characteristics of the example context are: adding a sequence run every minute in the information capturing process; each run contains a new entry of one minute worth of ordered indexes; the index is a b-tree forest with b-trees per partition (or partitioned b-trees); and queries by key value are followed up to one month (28-31 days x 24 hours). With a total merge fanin of 31 × 24 × 60 ═ 44,640, single-stage merging (e.g., once per month) is impractical, and two-stage merging requires fanin 212(≈ 3 every 212 minutes)1/2Hour with a combination step)).
Rank of | Fan in | Searching |
2 | 212 | 636 |
3 | 36 | 162 |
4 | 15 | 90 |
5 | 9 | 68 |
6 | 6 | 54 |
7 | 5 | 53 |
8 | 4 | 48 |
10 | 3 | 45 |
16 | 2 | 48 |
TABLE 1 number of minutes of pooling and searching within one month.
Table 1 shows more calculations for this example. The fan-in column implicitly indicates the number of minutes between merging the one-minute partitions. The terms delta, run, and partition are used interchangeably in this disclosure, as are the terms (run) merge and (delta) compaction. In all cases there was a final merge once a month. The search effort indicates the average (expected) number of partitions to search for per query. It is the product of the merge levels, the required fan-in F, and a constant of 1.5, which reflects that the number of partitions on each merge level oscillates in a sawtooth pattern between F and 2F. The selection of the minimum merging effort (2 merging levels) implies that the search cost (and hence query latency) is 14 times the optimal cost (636 versus 45 partitions); the selection of the minimum query latency requires more than the optimal five times the merging effort (10 for 2 merging levels); and balanced selection requires twice the best merging effort (4 for 2 merging levels) and twice the best search effort (90 for 45 partitions). The near-optimal choice of search latency still requires more than three times the optimal merging effort (6 for 2 merging levels). This is the case for abstract commitments to specifically improve coefficients.
The goal of this study is to improve on these choices, data structures, and algorithms. For example, the storage structure may be a linear form of a partitioned b-tree; the in-memory data structure may be an ordered index that manages run generation and runs on storage; and the algorithm may be interleaved sequential merge logic that eliminates runs waiting to be merged, thereby improving on the external merge ordering in terms of some metrics important to the log structure merge tree.
External merge sort
The outer merge sort has three phases: an input stage, also known as run-length generation; an output phase, also called final merging; and if necessary some intermediate merging steps. Run generation is pipelined with producers, and merge finally with consumers. For example, a merge join may consume its inputs from two sort operations in its final merge and produce its join result into another sorted run generation logic, possibly in preparation for another merge join on a different join column.
Run generation may employ read-sort-write cycles, e.g., using fast-sort, or successive replacement selection, e.g., using a priority queue. The run in the generation by the read-sort-write cycle is the size of the allocated memory. Run generation by replacement of the selection produces such runs in the worst case (reverse ordered input), producing twice the run size in the expected case (random input) and much longer in the better and best case (almost or fully pre-ordered input). The loser tree priority queue implements the replacement selection with minimal comparison. Key normalization, such as encoding the entire key value in an order-preserving binary string, reduces the cost per comparison. Offset value coding, a form of prefix truncation, avoids many byte-string comparisons and reduces the byte count of the remaining byte-string comparisons. Hardware support can speed up loser tree priority queue and offset value coding. Both normalization key and offset value coding are carried from run generation to sort output and query execution, e.g., intra-stream aggregation or merge join, via run files on temporary storage and a merge step.
The in-memory index can support read-sort-write cycles and replacement options. In addition to reordering the incoming records, the in-memory index can support aggregation, enabling ordering-based grouping (duplicate removal and aggregation) that is as efficient as hash-based grouping. Incidentally, if the in-memory index supports multiple types of records, both types of algorithms benefit, in particular a set optionally represented not by intermediate aggregate records but by input records. For example, for a query of minimum, maximum, and mean values throughout a table with grouping keys and one metric, the input records can represent a group more compactly than the intermediate records with minimum, maximum, sum, and count.
For the minimum I/O for runs on temporary storage, the outer merge sort uses the maximum merge fan-in. Fan-in is limited by buffer size, page size, and pre-read and post-write buffer requirements. Approximately, the page size should be (approximately) equal to the product of latency and bandwidth of the temporary storage. For example, if the temporary storage uses a disk drive, then 10ms 100 MB/s-1 MB may be a reasonable page size.
For example, the main design concept of external merge sorting can be applied to any step in the memory hierarchy, not only to internal memory spilled to external (temporary) storage, but also to CPU caches spilled to main memory or to flash storage spilled to disk. The transition ordered from inside to outside should be incremental, designed for graceful degradation and thus avoid "performance scarps". The same is true for introducing the transition of the intermediate merging step from the outer merging sort with a single (final) merging step to the outer merging sort with multiple (intermediate) merging steps. Again, this consideration applies to all steps in the memory hierarchy.
Log structured merge tree
The inventors speak of a log structured merge tree (LSM tree) is a disk-based data structure designed to provide low-cost indexing for records that undergo high rates of insertion (and deletion) during extended periods of time. LSM trees use algorithms that defer and batch index changes to cascade changes from memory-based groups through one or more disk assemblies in an efficient manner reminiscent of merge sorting. Furthermore, the "LSM tree is most useful in applications where index insertion is more common than lookup of search entries. This appears to be a common property of history tables and log files, for example. "in addition to its specific examples, the technique is believed to be applicable in any context that requires continuous information capture at high bandwidth and search queries across old and new (recent) data — in other words, any data warehouse, any analysis of web logs, any restart or restore operations based on pre-written log records, and the like.
The log-structured merge tree employs partitioning on permanent storage, often as a separate b-tree, rather than employing sort runs on temporary storage. The query may search the partition at any time. In addition, the log-structured merge tree employs a merge mode that is significantly different from the external merge ordering. They repeatedly merge the memory contents with all existing data. In an incentive example, they save data for a first minute, merge a second minute with the first minute, merge a third minute with the first two minutes, merge a fourth minute with the first three minutes, and so on. Finally, after half an hour, for example, they leave the partition alone and restart in one, two, three, etc. minutes. After the other half hours, they combine the second half hour with the first half hour, then the third half hour with the first hour, the fourth half hour with the previous one-half hour, and so on. Eventually, for example, after one day, they will leave the partition alone, and so on. In other words, there are multiple merge levels as in the external merge sort, but there is also a merge step within each level. Note that these merging steps are binary. They combine two inputs exactly and are often unbalanced because they combine inputs of very different sizes.
In contrast to this unbalanced merge mode, balanced merging can reduce the merging effort but it increases the search effort. In the balanced merge mode, the number of runs (partitions) searched through each query grows repeatedly from F to 2F if each merge step with a fan-in F starts when the F input runs are completed and ends when another F input runs are ready to perform the next merge step on the same level. On average, each query searches 1.5F partitions, as used in the calculations for Table 1 in the introduction. Setting a trade-off or policy decision for merge fan-in F facilitates merging or searching: the small fan-in is beneficial to efficient searching, and the large fan-in is beneficial to efficient combination. (it is assumed here that moving data to and from temporary storage or in memory is the main effort and cost in merging, and the cost of key comparison is negligible in this optimization.) binary merging minimizes the number of runs that exist at any point in time of the partition searched by each query, but maximizes the merging effort (among all balanced merging strategies). Max-fan minimizes the merge effort by minimizing the number of merge levels, but it maximizes the query effort.
The original design of the log-structured merge tree employs two additional techniques. First, the physical insertion mapped to the replacement record is logically updated, the physical insertion mapped to the "tombstone" record is logically deleted, and the correct up-to-date content is logically aggregated in the merging step and in the query execution. Second, even if this approach of bulk deletion does not provide any immediate feedback on the number of records deleted (if any), "Range delete" uses a single record of a particular type for logical deletion of the entire key range.
Partitioned B-tree and adaptive merging
A partitioned b-tree is a single b-tree that actually contains many b-trees. The manual leading key field in each index entry holds a partition identifier. Prefix truncation virtually avoids any additional storage requirements and comparison overhead. Creation and removal of partitions may require key insertions and deletions, but no directory transactions or file system updates. The search logic in the partitioned b-tree is the same as that for the Tandem multidimensional access method for the b-tree. The search will enumerate the currently existing partition identifiers and search for each partition. With the contiguous partition identifier, a search for a key requires a root-to-leaf search once per partition.
The in-memory partition absorbs small transactions, including insertion of replacement records and tombstone records. The record overflows to storage by delta overflow similar to run generation with replacement selection. Merging partitions may require only additional access to a particular partition, which is an insertion except in the last partition of the partition b-tree.
The partition b-tree can implement adaptive merging as "merge sort on interesting schedule" or merge the entire key range of query predicates as a side effect of query execution, because database cracking is "fast sort on interesting schedule", splitting one or two existing partitions in each range query. Adaptive merging in the first query (run generation, not just duplicate key values) and requires more effort in each query than database cracking until the index is fully optimized (into a single partition), but it is at a similar total effort (about N log)2N comparisons) enables much faster index optimization (fewer queries) and it is not limited to in-memory arrays and in-memory databases.
Several additional techniques may be employed for partitioning the b-tree. First, large insertions (load operations) may go directly to a new partition or even multiple new partitions, so that load operations may require run generation logic but not merge logic. Second, redundant storage structures such as secondary indexes and materialized (indexed) views may be outdated while new index entries are propagated in the primary storage structure during the merge step. This deferred maintenance still allows index-only retrieval, but it will check the most recent partition in the primary storage structure. Third, overflow from in-memory partitions to persistent storage may optionally retain "popular" index entries. This is particularly useful in order-based grouping (duplicate removal and aggregation). In recovery logs for pre-written log records, grouping and aggregation means log compression by computing "net changes" across multiple original log records; preserving popular index entries means log compression that focuses on database hotspots. Fourth, after an expensive search across multiple partitions, the latest record may be reinserted into the in-memory partition as a replacement record. Such LRU-like logic may achieve significant savings in applications and queries with temporal locality. Fifth, a request for "insert if not present" may involve an index search. Alternatively, the insertion of special "insert if not present" index entries delays the decision from update to query execution, avoids searching during insertion, and performs the check virtually free of charge as part of the merge logic. However, it does not immediately indicate whether a key value already exists. Sixth, the insertion of "insert or update if present" index entries may also avoid searching during insertion.
Overview of other methods related to B-Tree
The log-structured merge tree defines index streams, continuous high-bandwidth insertion with concurrent low-latency queries. They may need to compromise between these two goals. The partition b-tree is a possible representation or storage structure for the log-structured merge tree. Adaptive merging combines merging and query execution with side effects of merging query execution. The next two sections introduce the partition b-tree and variations of merging in the log-structured merge tree.
Linear partitioned B-tree
As a data structure, a linearly partitioned b-tree is both a b-tree and a linked list, or indeed a number of linked lists. There may be one in-memory partition organized as a b-tree (or equivalent, e.g., a 2-3-tree). The on-storage partition may have leaf nodes but no branching nodes (parent, grandparent, ancestor). Alternatively, a leaf node may hold multiple types of data records, one of which is a key-finger pair, and each partition j can include in its leaf the parent entry (key-finger pair) of partition j-1 as a data record, with the intra-memory partition holding the key-finger pair for the closest on-memory partition. Even if partitions lack branching nodes on all storage and therefore do not look like a tree, their pages of data will still be referred to as leaf nodes. Each leaf node x in the upper partition j of the store not only holds the parent entry for partition j-1, but also holds a pointer to the leaf node in partition j-1 that corresponds to the lowest key value in leaf node x.
Since leaf nodes in a linear partition b-tree support at least two record types and a shared ordering order for them, they appear ideal for merging b-trees. To cluster components of a complex object, the merged b-tree combines multiple single table indices based on their common attributes and thus based on a common ordering order. With the appropriate key structure, single table indices can be added and removed at will. To efficiently remove one index from among many indices, a "range delete" record may be designed to affect only one record type.
The storage requirement of a linearly partitioned b-tree is equal to that of a b-tree because they have the same parent entry although they are in different places; and the grandparent and further ancestor levels of the b-tree are missing in the linear partitioned b-tree, which has several additional parent and grandparent entries because the parent entries in the leaf level expand the leaf level and thus may require several more ancestor nodes.
Search and merge in a linear partitioned B-tree
Exact match (equal) queries perform a root-to-leaf b-tree search within an in-memory partition and then access the correct pages within an earlier partition like a linked list. In this search, the query accesses a data page containing a key of interest or will contain a key if one exists. By avoiding repeated root-to-leaf searches, queries in a linear partitioned b-tree are more efficient than queries in a partitioned b-tree. The range query is scanned within each partition, with the scan in partition j-1 being guided by the pointer found in partition j.
The merging step combines adjacent partitions immediately preceding the intra-memory partition. The merge logic deletes the key-pointer pairs in memory for the merge input and inserts the key-pointer pairs for the merge output. In the merge output, the merge logic suppresses key-pointer pairs to other merge inputs, but saves key-pointer pairs that reference the partition immediately preceding the merge input.
Note that this data structure readily supports multiple levels of external merge ordering. At any point in time, the intra-memory partition services run generation. Whenever there are an appropriate number of level 0 runs (immediately before the in-memory partition), they are merged and replaced with level 1 runs. Similarly, whenever there are the correct number of level 1 runs, they are merged and replaced with level 2 runs. Note that there is a point in time when these level 1 runs immediately precede an intra-memory partition-this is the time to merge them. The same logic applies to additional merge levels.
Change of linear partition B-tree
The linear partitioned b-tree supports equal search and range scanning of the sorted results. The equality search traverses the intra-memory partition from root to leaf and then traverses the linked list in the on-memory partition. The range scan starts with a search for low key values and then merges all partitions and partitions that are directed by key-fingers embedded in the in-memory index. There are some variations in data structures and algorithms that may be useful in some situations or applications.
First, the storage upper structure may include both b-tree branching nodes and linked lists. This may be useful for searching for rare search keys that appear in only a small portion of the partition. For example, if a key value only appears in 5% of all partitions, it may be more efficient to perform several root-to-page traversals in terms of I/O than following more than 20 times the partition-to-partition pointer, even if it is not efficient in terms of CPU effort. The estimate of the number of partitions to search and the conservative estimate of a particular partition may be computed using a bit vector filter, also known as a bloom filter. The redundant parent entries (both in the parent node and in the leaf nodes of the next partition) increase storage requirements gracefully compared to the default designs of b-trees and linear partition b-trees. This variant makes the linear partition b-tree somewhat similar to the Tokutek index tree.
Second, very large partitions may require very many parent entries, potentially creating space contention for in-memory partitions. In that case, a very large partition may have a parent node (immediately above a leaf node), but no grandparent node or another ancestor node; the key-pointer pairs in the intra-memory partition then reference the parent node in the previous partition instead of the leaf nodes. One can imagine a more extreme variant, for example, if each run is a b-tree, the next partition may contain root-only key-finger pairs, leaving all other b-tree levels with leaves, e.g., with data pages. Using this technique, it seems easy to be able to limit the key-pointer pairs in the next partition to perhaps 100 or 1,000, even for extremely large partitions. Note that this variant does not affect the storage requirements, it will require moving from the subsequent partition to the data partition.
Third, instead of going through a linked list of all partitions, an in-memory partition may hold key-pointer pairs from several partitions carefully selected by multiple partitions, e.g., by their age or time of creation. These partitions may also have access paths that are available only for key-pointer pairs in partitions on subsequent storage, or key-pointer pairs in partitions within memory. Again, this variant does not modify the total space requirement, but it moves the space requirement from the subsequent partition to the in-memory partition.
Finally, each key-pointer pair may have a zone filter attached. The included bit vector filters, minimums and maximums, and optionally sub-minimums and sub-maximums, summarize the data in the next partition. Not all subsequent partitions are summarized. Thus, they can save a search for data values, but not key-pointer pairs.
Overview of the Linear partitioned B Tree
In summary, a linear partition b-tree can be searched by a single in-memory root-to-leaf traversal followed by a linked-list traversal. There are a number of variations; further, any combination of these variations is possible, e.g., intra-memory partitions hold key-pointer pairs for leaf nodes and branch nodes in multiple partitions.
And (3) final marking: whereas partitioned b-trees are single b-trees with a manual leading key field in each key value, linear partitioned b-trees have on-storage components that may not actually be b-trees at all, but simply ordered runs, and they may form a single file in a file system or there may be multiple separate files. In other words, the linear partition b-tree can use any on-storage file format that allows direct access to pages.
Interleaving and merging
The merging process is continuous without abrupt start and stop of the merging step. Runs can enter and exit the merge step with key values other than- ∞ and + ∞. In other merge logic, each merge input run contributes to exactly one merge output run, whereas in interleaved merging, each merge input run contributes to two merge output runs in most cases.
To begin merging input runs with a particular key value, an efficient search within the run is required. The b-tree provides this capability at little extra cost during run creation. There are a number of ways to organize runs into a b-tree. A linear partition b-tree provides an attractive option.
The in-memory ordered index (possibly a b-tree) maintains data records and key-pointer pairs for the partitions on storage. The on-storage partitions may not have their own branch nodes; in other words, they may be flat ordered files of any format. Runs (partitions) are organized by level; the runs of each merge level form a linked list and the anchor points of these linked lists for each merge level are located in the in-memory index.
The query searches the in-memory index starting with the closest partition and traverses the linked list. The merge step modifies the in-memory index as described in the following subsection. The discussion of incremental release of temporary storage is deferred to the "storage space reclamation" section.
Referring now to FIG. 8, depicted is a system or environment 800 that maintains a key-value store by performing interleaved consolidation. The environment 800 can include at least one computer network 810. Network 810 can be a computer network that can include one or more local area networks, wide area networks, private networks, public networks, and the internet. The environment 800 can include at least one data acquisition source 855. The environment 800 can include at least one data processing system 805. The data processing system 805 can include at least one storage medium 815. The storage 815 may include any computer-readable storage medium. The data processing system 805 can include at least one run generator 825, at least one merge handler 830, at least one merge tracker 835, and at least one query handler 840. The data processing system 805 can include at least one database 845. In some implementations, the data processing system 805 can include a data acquisition source 855. In some implementations, the store 815 and the database 845 may be part of the same data store on the data processing system 805.
These components of system 800 (e.g., network 810, storage 815 of data processing system 805, run generator 825, merge handler 830, merge tracker 835, query handler 840, and database 845, and data acquisition source 855) can be implemented using the components of computing system 1200 described in detail herein in connection with fig. 12. For example, the data processing system 805 can include servers or other computing devices. Data acquisition source 855 can also comprise a server or other computing device. Each of the components of the data processing system 805 is capable of performing the functionality detailed herein in connection with parts a and B.
Data acquisition source 855 is capable of acquiring, receiving, or identifying data records (sometimes referred to herein generally as records). Each data record can include at least one key value (sometimes referred to herein generally as a value). Key values can include sets of alphanumeric characters (e.g., characters or character strings) or numbers (e.g., double precision, integer, and floating point values). A key value may be defined as being within a key domain. The key field of the key value of a data record can define the range of key values of the record. In some implementations, a key domain can have a minimum key value and a maximum key value, where the key domain includes key values between the minimum key value and the maximum key value. For example, the key field may be a range of temperatures that can be read by sensors measuring heat on the aircraft (e.g., -150 ℃ to 1500 ℃).
Each data record acquired by the data acquisition source 855 can also include an index value (e.g., a time or sequence number) corresponding to the order in which the data records were created. The index value may be different from the key domain that defines the key value. In some implementations, the index value may correspond to a time at which the data record was received by the data acquisition source 855. Data acquisition source 855 can generate and associate a time index with each data record. The data records may be, for example, structure templates, areas of memory in a computer system populated with certain values, or data structures such as class or class C structures. In some implementations, the data acquisition source 855 can generate a data record that includes one or more key values. For example, the data acquisition source 855 may be a computing system coupled to a sensor in the aircraft that is capable of measuring and sampling temperature values at intervals. In this example, the data acquisition source 855 is capable of generating a data record that includes a key value based on the temperature reading of the sensor and a key value based on the current time value of the data acquisition source.
The data acquisition source 855 can transmit the data records to the data processing system 805 via the network 810 to maintain the data records. In some implementations, the data acquisition source 855 is capable of transmitting data records in a continuous stream. In some implementations, the data acquisition source 855 can provide data records at regular intervals (e.g., one data record every ten milliseconds). In some implementations, the data acquisition source 855 can schedule transmission of data records at variable time intervals. In some implementations, the data acquisition source 855 can transmit data directly to the data processing system 805 via a communication interface. In some implementations, the data acquisition source 855 can provide data records based on a time-independent schedule.
A run length generator 825 executing on the data processing system 805 is capable of receiving data records from a data acquisition source 855 via the network 810. Upon receiving the data record, the run length generator 825 can store and maintain the data record on the store 815. The run length generator 825 is capable of accessing the storage 815 of the data processing system 805 to arrange, store, or write the received data records to one or more buffers. Each buffer can correspond to an allocated region of memory in the store 815. Each buffer can contain one or more of the data records received by the run length generator 825 from the data acquisition source 855. In some implementations, each buffer may be stored and maintained on a different store 815. In different implementations, each buffer may be stored and maintained on the same store 815. In preparation for sorting, the run-length generator 825 is capable of writing or storing data records onto the buffer in a sequential order based on the order received from the data acquisition source 855.
Using the records stored on the storage 815, the run generator 825 is able to build at least one run 820A-N (hereinafter generally referred to as runs 820) (sometimes referred to herein as partitions or deltas). To establish the run 820, the run generator 825 can access at least one of the buffers maintained on the store 815. In some implementations, the run generator 825 has access to at least one of the merge levels 850A-N maintained on the database 845. Details of maintaining the merge levels 850A-N on the database 845 are provided herein below. The record sets in the buffer in the store 815 (or database 845) can be initially arranged or indexed by an index value (e.g., a timestamp or sequence) and may be unordered above the key field. For example, the data records received by the run length generator 825 may correspond to interactions of the content item across multiple clients. A data record can contain two key values: one corresponding to the time of interaction and the other identifying the content item. The run length generator 825 may initially store the data records in the order received in a buffer on the store 815. To prepare the records for interleave merging, the run generator 825 can order the data records by content item index.
In building the run 820, the run generator 825 can execute a sorting algorithm to rearrange and sort the records of the buffer for the run 820. The sorting algorithms used to build the runs 820 can include quicksort, priority queue, merge sort, heap sort, insert sort, bubble sort, binary tree sort, radix sort, bucket sort, and the like. To execute the sorting algorithm, the run generator 825 can identify or establish a key field over which it can sort the data records into runs 820 on the store 815. As discussed above, a key field can define a range of key values for a record. In addition, the run length generator 825 is capable of identifying the key value of each data record in the buffer of the store 815. Using the key values of the data records in the buffer, the run generator 825 is able to execute a sorting algorithm to rearrange the data records. With the sorting completed, the run generator 825 can build the record of the buffer in the store 815 as a run 820.
The runs 820 created by the run generator 825 can be in accordance with a data structure for maintaining ordering records. For example, the run 820 may be a b-tree or a variation of a b-tree as described herein. In this example, the run generator 825 is capable of generating an ordering data structure, such as a b-tree or a variant of a b-tree, from the records. The run generator 825 can store the runs 820 in a buffer specified for the runs 820 in the store 815. The run 820 may be a sorted plurality of records, each record containing a key value for a key field. The runs 820 can each occupy a buffer or region of memory in the store 815. The region of memory can be established by the run length generator 825 or any other module of the data processing system 805. In some implementations, the runs 820 are each ordered b-trees of key-value indices of the key field. In some implementations, the run 820 is a different type of sort data structure, key value index or sort of key field. In some implementations, each run 820 occupies a discrete area or buffer of memory in the store 815. In some implementations, all of the runs 820 occupy a single area or buffer of memory in the store 815. In some implementations, each of the runs 820 can be ordered by key value in ascending order (e.g., by increasing the numerical value or in alphabetical order). In some implementations, each of the runs 820 can be ordered by key value in descending order (e.g., by decreasing numerical value or in reverse alphabetical order).
With the runs 820 established, a merge handler 830 executing on the data processing system 805 can merge one or more of the runs 820 to at least one merge level 850A-N (hereinafter generally referred to as merge level 850) on a database 845. In some implementations, the merging of one or more runs 820 onto one merge level 850 can be performed while performing a sorting algorithm such as those discussed above. The sorting algorithm can include, for example, a merge sort, such as an outer merge sort. Based on the number of runs 820 to merge, the merge handler 830 can perform n-way merges using n of the runs 820 maintained on the buffer of the store 815 to produce one of the merge levels 850. Each of the merge levels 850 includes records from a previous merge level 850. Upon completion of the merge, the merge level 850 can include runs of sorted data records from the previous merge level 850. For example, a run on merge level 850B results from the merging of two or more runs from the first merge level 850A. The merge handler 830 can perform merges concurrently across any of the merge levels 850. The merge handler 830 can also merge one or more runs 820 into a merge level 850 in the database 845. For example, the merge handler 830 can merge the first run 820A and the second run 820B into runs at the merge level 850A.
The database 845 may be a database configured to store one or more merge levels 850 of key value indices. In some implementations, the database 845 is internal to the data processing system 805, and may be part of the store 815 or vice versa. In some implementations, the database 845 may reside external to the data processing system 805 and may be accessed via the network 810. In some implementations, the database 845 can be distributed across many different computer systems or storage elements, and can be accessed via the network 810 and/or a suitable computer bus interface. The merge level 850 can be composed of runs of data similar to the runs 820 of data on the store 815. In some implementations, the number of runs at the merge level is less than the number of runs at the merge level that precede it. For example, if merge level 850B consists of 4 runs, merge level 850A can consist of more than 4 runs.
To perform the merge, the merge handler 830 can access the data records from one or more runs 820. In some implementations, the records accessed by the merge handler 830 can include records in one or more runs 820 from a previous merge level 850. The merge handler 830 can add data records from different runs 820 to the runs at the merge level 850. For level 0 merging, data records from different runs 820 may be merged from the store 815 into a first merge level 850A on the database 845. In another example, a first run 820A and a second run 820B on a first merge level 850A can be merged into the first run 820A on a second merge level 850B. The data records can be merged using a merge sort algorithm such that the data records in the resulting first run 820A of the second merge level 850B are stored in a sort order based on the key values in the key domain. The merge handler 830 can also perform a 1-way merge in which the ordered records of a single run 820 are merged into runs 820 at the next merge level. For example, in the case where the merge level 850A has only a single run 820A, the merge handler 830 can merge the first run 820A at the merge level 850A into the first run 820A at the second merge level 850B.
In some implementations, the merge handler 830 can add multiple runs 820 to the same merge level 850. For example, merge handler 830 can begin merging runs 820A and 820B into a run at merge level 850A. In the middle of the merge, the merge handler 830 can add run 830C, tuning what is a two-way merge into a three-way merge, all into the same run at merge level 850A. The merge handler 830 can merge one or more runs using a merge algorithm, such as merge sort or external merge sort. In some embodiments, the runs 820 are stored as ordered b-trees on the store 815. In this example, the merge handler 830 can use an external merge sort algorithm to combine the runs 820A and 820B into a single sorted B-tree at the merge level 850A. Although the present disclosure has described the runs being merged in order (e.g., 820A and 820B merged onto the merge level 850A), the merge handler 830 merges can occur according to any order or permutation of the runs, and the resulting operation can be stored at any merge level of the database 845 in any area of memory on the store 815.
As the merge of the at least one run 820 is performed, a merge tracker 835 executing on the data processing system 805 can use the merge index for the merge level 850 to track the progress of each merge performed by the merge handler 830 to the merge level 850. The merge index can reference a key value of a current data record accessed by the merge handler 830 to determine the progress of the merge operation with respect to the key domain. In some implementations, the merge tracker 835 can maintain a counter to track merges that are incremented for each key value added in a merge operation by the merge handler 830. The merge tracker 835 is capable of tracking merges between one or more runs 820 to the merge level 850. The merge tracker 835 is also able to track merges between any of the runs at any of the merge levels 850. For example, the merge tracker can track the merge between runs 820A and 820B into the corresponding run of merge level 850A with the first associated merge index. The merge tracker can concurrently track merges between one or more runs on merge level 850A into a corresponding run of merge level 850B with the second associated merge index, and so on.
The run generator 825 can concurrently build another run 820 in the store 815 when merging is performed by the merge handler 830 and tracked by the merge tracker 835. For example, the merge handler 830 may begin merging the first run 820A and the second run 820B into the first merge level 850A in the database 845, while the third run 820C is created using the newly incoming record. The merge can be tracked by the merge tracker 835 using the merge index. Additionally, the merge handler 830 may be performing merges across other merge levels 850, with each merge being tracked by the merge tracker 835 with a corresponding merge index. Concurrently with these concurrent merges, the run generator 825 can also concurrently receive the data record and generate a new run, in this example run 820C, in a buffer in the store 815.
Similar to the merge tracker 835 using the merge index to track the progress of the merge operation for each run 820, the run generator 825 can use the run index to track the progress of the build of the runs 820. The run generator 825 may also determine the run index based on the key value of the current data record associated with the key domain. For example, the first run 820A can have a predetermined size that is established or received by the run generator. The run generator 825 can receive data records from the data acquisition source 855 to get each data record and update the run index to reflect the progress of the build of the run. The run index can be used to determine how many data records exist in a run. The run index can also be used to determine the conditions under which a merge operation can occur in a similar manner as the merge index.
The merge tracker 835 is able to determine whether the merge index for the run 820 satisfies one of a set of quantile point conditions (sometimes referred to herein as quantile points, merge conditions, or switch conditions) for the merge level 850. Each quantile condition can specify a corresponding value for the merge index that tracks the merge of one run 820 to the merge level 850, at which it will trigger the addition of a record from another run 820 to the same merge level 850. In some implementations, a set of quantile conditions can be defined over a key domain. Each quantile point condition can be set or defined as a partition key field to evenly distribute the number of records in the run 820. For example, if the bond domain is a temperature range ranging from-200 ℃ to 2000 ℃, the set of quantile point conditions can be defined at uniform intervals within the bond domain at-100 ℃,0 ℃, 100 ℃, etc. In some implementations, each condition can be set or defined to divide the key domain by any other distribution. The quantile point condition can also specify, indicate, or correspond to the number of records of one run 820 merged into the merge level 850 to trigger the addition of a record from another run 820. In some implementations, the quantile point condition set can be defined based on the number of records in each run 820. For example, if there are 100 records in each run 820, the quantile condition set may be a merge index value of 25, 50, 75, and 100. The set of quantile point conditions can also be defined as the number of records in each run 820 divided by any other distribution. In some implementations, the quantile point condition may be predetermined or fixed prior to the building of the run 820 or the performance of the merge. In some implementations, the quantile condition can be determined dynamically.
In some implementations, the merge tracker 835 can use any number of factors to determine the split point condition against which to compare the merge index or the run index. In some implementations, the merge tracker 835 can determine the split point condition by determining a diversion key value. The transit key may be a key that causes the merge index to satisfy the split-point condition. In some implementations, when the merge index is equal to the switchover key value, it satisfies the quantile condition. The transit key value may be determined using a bandwidth offset based on the consolidated bandwidth of database 845. The database 845 can have a bandwidth that indicates the rate at which new entries can be added. The merge tracker 835 can modify, adjust, or otherwise set the switch keys based on the bandwidth offsets of the database 845.
The run length determiner 825 is also capable of identifying the distribution of key values over key domains in one or more data records when determining one or more quantile points conditions for merging the run length 820 to the merge level 850. For example, the run generator may determine the maximum key value and the minimum key value in a particular key domain by using the maximum key value and the minimum key value received in a particular set of data records. Using the distribution of key values, the run generator 825 is able to determine one or more quantile point conditions that can be used to organize the schedule of merge operations. For example, run generator 825 may identify key values in the key domain that range from 0 to 999. In this example, the run generator 825 can determine the quantile point condition based on the fan-in of the subsequent merge level (e.g., how many runs on the current run level should be merged into a single run on the subsequent merge level). If the merge fan-in is four in this example, the run generator may determine the quantile conditions to be 249, 499, 749, and 999.
The run generator 825 is also able to identify the rate at which runs 820 can be built on the store 815. For example, the rate at which the runs 820 are established may be limited by the speed at which the run generator 825 can sort the data records into corresponding runs. The rate at which the runs 820 are established may be limited by the computational effort required to order the data records into corresponding runs. Based on the rate at which runs can be built, the run generator 825 can set a bandwidth that determines the rate at which records can be merged onto one of the merge levels 850 on the database 845. This bandwidth can be used to determine the quantile condition as discussed above.
The merge tracker 835 can determine that the merge index does not satisfy any of the quantile conditions. When it is determined that the merge index does not satisfy the split point condition, the merge tracker 835 can continue to track a run 820 of merges onto the merge level 850. Conversely, the merge tracker 835 can determine that the merge index satisfies one of the quantile conditions. For example, if the merge handler is performing a one-way merge of the run 820A at merge level 850A to the run 820A at merge level 850B, the merge tracker 835 can track the progress of the merge and compare the merge index to the quantile point condition. If the merge index meets the quantile condition, e.g., the merge index equals a predetermined value, the merge tracker 835 can cause the merge handler 830 to add another run 820B at the merge level 850A to the one-way merge to initiate a two-way merge. After addition, the merge tracker 835 can continue to track the merged merge index of the runs 820 until the merge of the runs 820 has completed after the continuation quantile condition is satisfied.
When it is determined that the merge index satisfies the quantile point condition, the merge tracker 835 can initiate adding another run 820 to the merge level 850 to perform the multi-pass merge. The merge tracker 835 can identify a subset of the runs 820 to be added to the merge level 850. In some implementations, the merge tracker 835 can determine a subset of data records in the run 820 that satisfy the quantile point condition. Determining the subset of data records can include comparing key values in the data records to a split-point condition. When the key values in the data records are greater than the quantile point condition, then the data records may be added to the subset. For example, the split-site condition may correspond to a temperature of 50 ℃, and the merge tracker 835 may be capable of identifying a subset of data records with temperature values exceeding 50 ℃ as the merge level 850. The merge tracker 845 may also identify subsets based on the merge index. For example, the subset of data records may be any data records in the buffer that are in a position larger than the merge index.
Continuing with this example, if the second split point condition is reached, the merge tracker 835 can identify a second subset of records in the third run 830C that satisfy the second split point condition. In response to the identification of the second subset of records, the merge tracker 835 can then initiate adding the identified second subset of runs 820C to the merge of 820A and 830B to create a three-way merge. The merge tracker 835 can continue this process if there are a sufficient number of quantiles and runs 820A-N that initiate up to N merges, where N is the number of runs in the store 815 in this case. The merge tracker 835 can also perform this process on runs of any merge level 850 in the database 845.
In some implementations, the merge tracker 835 can determine that the run index has satisfied the quantile point condition. When the run index has assembled many key values in the run 820 that exceed the threshold, it can satisfy the split-point condition. In some implementations, the merge handler 830 can add the run 820 of the merge level 850 to an existing merge when the run index of the corresponding merge level 850 satisfies the split-point condition. For example, one-way merging of run 820A is in run 820A at merge level 850A to merge level 850B. When the run generator 825 determines that the run 820B satisfies the quantile point condition, the merge handler 830 can add the second run 820B at the merge level 850A to the one-way merge. The merge tracker 835 can also determine one or more quantile point conditions based on the distribution of key values in the key domain.
In some implementations, the merge tracker 835 can determine whether to add all data records in the run 820 to the merge level 850 in the database 845 while performing the merge. For example, the merge tracker 835 can determine that the merge index of the merge between the first run 820A and the second run 820B is equal to the maximum value in the key domain. In this example, because the merge proceeds from the minimum key value to the maximum key value throughout the key domain, this condition will indicate that all key values in the run 820A have been merged into runs in the merge level 850A that exist on the database 845. Because a merge with more than one run 820 is initiated in response to the merge index being determined to be equal to the quantile point condition and an additional run is added to the merge at the merge index, there may be data records in the run that have not yet been merged into the run at the merge level 850A in the database 845 in run 820B. In the event that it is determined that the merge of records of the first run 820 has not been fully added, the merge tracker 835 can track the merge until the merge index reaches the quantile condition or the merge is determined to be complete.
In the event that it is determined that the merge of the records of the first run 820 is all added to the first merge level 850A, the merge tracker 835 can free the buffer in the store 815 containing the run 820A to receive data records for the additional run 820. For example, the run 820A may occupy a certain amount of space in the store 815 and the store may be limited. In this case, keeping the data record in the store 815 is now redundant because the data record also exists in a merge run in the merge level 850A in the database 845. The merge tracker 835 is able to free the area of memory occupied by the run 820A on the store 815.
In some implementations, the merge tracker 835 can determine whether the merge level 850 is complete on the database 845. For example, the merge tracker 835 can track the merging of a subset of records in the first run 820A and records in the second run 820B onto the first merge level 850. In this example, the merge tracker 835 may determine that the merge is complete when the merged merge index has reached the maximum key value. In some implementations, the merge tracker may determine that all data records in the run 820A have been merged into the first run in the merge level 850A on the database 845. When it is determined that the merge is not complete, the merge tracker 835 can track the merge until the merge index meets the quantile condition or determines that the merge is complete.
When it is determined that the merge is complete, the merge tracker can begin merging the remaining subset of data records in the second run 820B from the smallest key value of the key field into the second run in the merge level 850B on the database 845. Merges can be maintained in a steady state by the merge handler 830 at each merge level 850 by successively merging data records left from previous merges into additional runs of the next merge level. In some implementations, the merge handler 835 can initialize another run 820 at another merge level 850B on the database 845. The merge handler 835 can begin merging the remaining data records in the run 820B into the second run in the merge level 850A on the database 845. In some implementations, the merge process 835 begins merging the remaining data records from the minimum key value, as described above.
The query handler 840 can receive a query for one or more records maintained on the database 845. The query may be generated and transmitted by a computing device connected via the network 810. In some implementations, the query handler 840 can receive the query via the network 810. The query can be a request for one or more data records and can include information identifying a particular key value. In some implementations, the query can include a request for all data records having a particular range of key values. For example, the query handler 840 may receive a query for all data records having temperature readings between-50 ℃ and-10 ℃. The query handler 840 can identify key values within the key domain that satisfy the conditions specified in the query and begin searching the store 815 and database 845.
Using the query, the query handler 840 is able to search at least one of the merge levels 850 maintained on the database 845. In some implementations, the query handler 840 can use the query to search the store 815 for at least one of the runs 820. The search can occur concurrently with the creation of the run 820 and the merging of the run 820 onto the merge level 850. The merge level 850 using the query search can include data records from one or more runs 820 (e.g., from a previous merge level 850). The number of data records merged onto the merge level 850 may depend on the split-site condition. For example, for two-way merging, all records from the first run 820A may be included in the merge level 850 and a subset of records from the second run 820B may be included in the merge level 850.
In performing the search, the query handler 840 can identify at least one of the merge levels 850. In some implementations, the query handler 840 can identify at least one of the merge levels 850 determined to be complete. In this manner, the query handler 840 can avoid searching for a merge level 850 with an incomplete merge or incomplete run 820, thereby reducing the number of searches performed. The merge level 850 identified by the query handler 840 may correspond to the most recently completed merge. With the identification of the merge level 850, the query handler 840 can identify data records in the identified merge level 850 that match the query. In some implementations, the query handler 840 can identify data records that match a key value specified by the query. For example, the query handler 840 can find data records with temperature readings between-50 ℃ and-10 ℃ as requested in the query. In some implementations, the query handler 840 can determine whether a data record matching the key value specified by the query exists on the database 845.
Based on the identification, the query handler 840 can generate a response based on the search using the query. In some implementations, the query handler 840 can include data records matching the query into the response. In some implementations, the query handler 840 can include an indication specifying whether the database 845 contains any records in the response that match the query. With generation, the query handler 840 can transmit a response to the computing device that sent the query via the network 810.
Well paced interleaved merging
The addition of runs to merges in an interleaved manner is described above. Merging may be successive merges that traverse the key domain over and over again, add runs with split-point key values, and discard them after one complete cycle through the key domain. For merge fan-in F, the desired quantile key can be a 1/F quantile, a 2/F quantile, and so on. Merging produces one output run per cycle, switching to the next output run when rewinding from + ∞ and- ∞. The quantile can be estimated and the estimate adjusted at the cost of running the merge step temporarily between the old estimated quantile key and the new estimated quantile key for F-1 or F +1 input runs.
Ideally, merging is done through the key field so that the merge reaches the next quantile point when a run generator, such as run generation, ends its next output run. In that case, each new run adds a merge step immediately after it completes. The merge step continues its progress through the key field so that the newly added runs join with the appropriate split-point key values.
During initialization of the merge level, merge fan-in is established, the first run of a run generation starts as a "one-way merge" as soon as it ends, becomes a binary (2-way) merge when it ends its second run, and so on. When run generation ends its F-th run, such as when merge mode starts its first merge step, it becomes a full F-way merge. As runs exit and enter the merge logic at each split point, the merge remains a stable F-way merge after initialization of the merge level. During initialization, the merge bandwidth may be proportional to its current merge fan-in.
Start the third run
Referring now to fig. 9A, depicted is a point in time during initialization of the merge level. The writer 920, for example, runs generates a second run 820B that has recently ended and a third run 820C that has started. When that happens, the reader 915 merges the level 0 run 820 to create a first level 1 run 925A, for example, to become a binary merge. In this example, merge index 905 has recently crossed quantile condition 910A. Prior to this event, the reader 915A is performing a one-way merge, assembling the record of the first data run 820A into the first region 940A of the first level 1 run 925A of the merge level 1850A. After the merge index 905 exceeds the quantile point condition 915B, the reader 915B starts merging both runs 820A and 820B from the merge index. Note that at this stage, this leaves the subset of data records in 820B unmerged. 820A and 820B are also added to the level 1 run 925A. The segment of 925A representing the result of the two-way merge is emphasized as 940B.
In the context of FIG. 8, the merge handler 830 can perform a first merge 915A recorded onto a first merge level 850A using the first run 820A. The merge tracker 835 can maintain the merge index 905 and determine whether it has reached the quantile point condition 910A. When it does so, the merge handler 830 can add the second run 820B to the merge 915A to create a two-way merge 915B. The result of the second merge is maintained in the database 845 in the run 925A in the merge level 850A.
The merge tracker 835 can track the first merge 915A using the merge index 905. For example, the merge tracker 835 can continuously track the progress of the first merge 915A by determining a key value of the merge index 905. If the key value satisfies the split point condition 910A, the merge handler 830 can add the second run 820B to the merge 915B. The resulting merge is stored in the merge level 850A in the run 925A, with 940A indicating the portion of the run 925A corresponding to the one-way merge and 940B indicating the portion of the run 925A corresponding to the two-way merge.
The run generator 825 is capable of writing runs 920 to the storage 815 of the data processing system 805. The run generator 825 is able to write the run 920 concurrently with the merge operations 915A-B. When a two-way merge occurs between runs 820A and 820B, a third run 820C is being generated and stored in a corresponding buffer in storage 815.
End the third run
Fig. 9B shows a later point in time during initialization of the merge level. The writer 920 is about to end its third run and the reader is about to expand the 2-way merge into a 3-way merge.
The first run 925A of the merge level 850A now includes a merge of the first plurality of data records 940A and the first and second plurality of data records 940B. At this stage, the run generator 825 may be about to complete assembling the third run 820C. The merge index 905 tracked by the merge tracker 835 may also be about to reach another quantile point condition. When the merge index satisfies the quantile condition and the run 820C can complete, the merge handler 830 can add the third run 820C to the two-way merge to create a three-way merge.
Start the fourth run
Fig. 9C shows another point in time during initialization of the merge level. When the writer ends the third run and starts the fourth run, the writer expands the 2-way merge to a 3-way merge.
The merge tracker 835 may have detected that the merge index has satisfied the second split point condition 910B and the run generator 825 has completed generation of the third run 820C. As a result, the third run has been added to the merge operation with reader 915C. The merge level 845A now further includes merges of the first, second, and third pluralities of data records 940A-C, respectively. Concurrently, the run generator 825 begins assembling the fourth run 820D of merge level 0 by writing 920 the run 820D to the store 815 on the data processing system 805.
Completing merge level initialization
FIG. 9D shows the completion of merge level initialization, where the first full output run 925A has completed. At this stage, the entire merge level 0 run 820A has been merged into the next stage, but runs 820B and 820C still have data records that remain un-merged. At this point, the merging of the second merge level l-run 925B begins. The merge handler 830 merges with the run 820B one-way, starting with the smallest key value of the key field, to write the data record to the second run 925B in the merge level 850A.
After the first full output run, the merge level is fully initialized. At that time, the next merge level begins its initialization. Thus, there may always be one merge level in initialization. Other merge levels may run at a bandwidth equal to the run generation. Therefore, the temporary storage amount for each level of the run remains constant (except for rounding). The amount of temporary storage currently in use can be used as a means of merge level pacing, and whenever its input size exceeds the allocated temporary storage, the merge level should run at full bandwidth.
With the merge paced such that the input run is dropped (after a full loop) when preparing to add another input run, the query finds F completed runs at each merge level. Any query can involve searching F partitions at each merge level, except at the topmost level in the initialization. The F runs per merge level represent a 3:2 improvement compared to the merge and search strategy, (e.g., from an average of 1.5F to a fixed F).
Eager staggered merging
Well-paced interleaved merging discards the input run j and adds the input run j + F at the same time and with the same key value. For best performance it depends on the merging of the adapter keys reaching the input run j being done with the input run j + F. In contrast, eager interleaved merging adds a run j + F whenever a run is complete, regardless of whether the input run j has been completely merged. The switchover key value of the input run j + F is set by the current progress of the prior merging step; it may be lower or higher than the jump key value of the input run j.
In eager staggered merging, the merged fan-in varies around the target fan-in F over time. The data intake bandwidth and the fraction F/F of the current and target fan-ins should guide the pace of the merging progress. However, if the temporary storage for the merge input exceeds a threshold, the merge should continue with the maximum (unconstrained) bandwidth. The threshold should be equal to F runs plus some tolerance, e.g. 20%.
Competition interleaving merging
An alternative approach focuses on the run-length representation as a linearly partitioned b-tree and its key-pointer pairs in the in-memory index. Here, it is assumed that a linked list can be formed for runs of the same merge level, that an in-memory index holds a key-pointer pair for the nearest run in each level, and that the level indicator and run number extend the key-pointer pair into a quadruple. For level indicators, run generation yields a level 0 run, and so on; and the run number simply counts the runs that once existed at a given merge level.
In such data and storage structures, the in-memory index will be as persistent as the file representing the run and partition. This requires the in-memory index to be transactional, with concurrency control due not only to run generation and multiple merge processes modifying it concurrently, but also with durability such as logging and recovery. Details of concurrency control, logging, and recovery of in-memory indexes are disclosed in later sections. Details of logging and recovery of data content, such as when and where data content is recorded or mirrored, are omitted herein.
Run generation incrementally overflows data records from the in-memory index into the on-memory partition, moving the existing key-pointer pair (or indeed the quadruplet, see above) of the most recent level 0 run into the current level 0 run and leaving the key-pointer pair of the current level 0 run in the in-memory index. Once a new key-pointer pair is submitted in the in-memory index, it and its data content are available for querying; and once the key-finger pair is moved from the in-memory index to the on-memory partition, the query can indirectly access it. The merging process does the same thing as run generation when they generate a new run as merged output: increment overflow, move existing key-finger pairs from an in-memory index to a merge output, etc.
Competition interleaving merging
Fig. 9E shows competition between readers and writers. As soon as the writer precedes the reader in key value, the reader expands merge fan-ins. Here, the writer is still working on the second run, but the reader has expanded its merge to a 2-way merge. Binary merging starts earlier than in fig. 9A, with the write key value waiting even less until being read.
The merge tracker 830 can use the merge index 905 to track the competing merges and begin a two-way merge as soon as the target quantile 910A is reached. In the case of a competing merge, the two-way merge 915B begins before the second run of data 820B has been fully established. This means that as the run generator 825 generates the run 820B, the writer 920 and the read 915B can "compete" to the end of the run. The result of the merge is a run 925 in the merge level 850A. The one-way merge portion of the run 925 is labeled 940A, while the two-way merge portion of the run 925 is labeled 940B.
The query prefers to merge the outputs over the merge inputs, searching for one place instead of F places. Based on transactional updates of the in-memory index, the merge step (level) includes the new input partition as soon as the logic that created the input partition reaches a key range that is higher than the merge step. If the query is able to search for the next merge level, the query should never search for partitions. Note that writing a new partition should take F times as long as reading it as one of the F inputs in the merge step; thus, the writer will eventually catch up with the reader and then remain ahead of it. The merge logic notes the additional merge input by means of the run number in the key-pointer quad.
A query with a random search key at a random point in time has a 50% probability that it takes time to search for F merge inputs and an equal probability that it might search for a merge output. Thus, on average, the query involves searching F/2 partitions at each merge level. This is a 3:1 improvement over the merge and search strategy.
Indexing content and maintenance
The in-memory ordered index can facilitate run generation and management of store-up runs. For run generation with input data records, the index supports replacement selection, so the initial run is twice the size of the memory. This assumes run-length generation under steady state and random input; some memory is lost due to in-memory fragmentation due to variable size recording and some memory is occupied by key-pointer pairs of previous runs.
The in-memory index is also held to an anchor that points to the linked list of the most recent runs at each merge level. For higher merge levels and their very large runs, the runs may have parent or even general levels, and entries in the in-memory index point to these levels. These most recent runs point to earlier runs on the same level.
FIG. 10 illustrates how the in-memory index 1010 references pages in runs at two merge levels. There is one level 1 run 1020 and two level 0 runs 1005A-B while a third run 1005C is starting. The most recent level 0 run 1005B holds a key-pointer pair that references a page in the older level 0 run 1005A. The merge index 1015 is tracked by the merge tracker 830.
When the eviction scan advances in run generation, the data record and key-pointer pair of the most recent level 0 run are both written to the current level 0 run; the key-pointer pair for the current level 0 run is saved in the index. This process runs whenever the memory is full, wrapping around from the key values + ∞ and- ∞ as appropriate and starting a new level 0 run at those times. Concurrency control and recovery for the index is covered below.
Each merge level advances mostly independently of run generation and other merge levels. The relationship is that each level processes about the same volume of data after initialization is completed so that the required temporary storage remains constant for each level of the run.
Each merge step removes the key-pointer pair of the merge input and inserts the key-pointer pair of its merge output. It also moves the key-pointer pair into the merged output, i.e. the key-pointer pair of the closest preceding run at the level of the merged output. Thus, the in-memory index continues to hold key-pointer pairs for the most recent runs in each level.
Referring now to FIG. 11, depicted is a flow diagram of a method 1100 for maintaining a key-value store by performing interleaved consolidation. Method 1100 can be implemented or performed using data processing system 805, described in detail herein above in connection with FIG. 8, or computer system 1200, described herein below in connection with FIG. 12. In brief overview, a data processing system can receive a data record (1105). The data processing system can establish a sorted run of data records (1110). The data processing system may begin a merge operation 1115. The data processing system can track progress of one or more merge operations (1120). The data processing system can determine whether the merge index satisfies the quantile point condition (1125). The data processing system can add another ordered run of data to the merge (1130).
A data processing system (e.g., data processing system 805) can receive 1105 a data record. The data record can include one or more key values corresponding to a key field. The key domain can have a minimum value and a maximum value. The data records can be received continuously throughout the execution of the method. The data records can be received, for example, via network 810. The data records can also be received directly from a data acquisition source, such as data acquisition source 855. The method can also add a key value corresponding to a time of receipt of the key value to each data record.
The data processing system can establish a run (1110). The data processing system can establish ordered runs (e.g., run 820) from the data records received in (1105). Runs can be indexed by key value. For example, building runs may include building a b-tree or a variant of a b-tree data structure with the data records received in step 1105. Runlengths can be established by indexing one or more key values present in a data record and inserting them into the sorted data structure. Runs can also be created by inserting each data record into a data structure and then performing a sorting algorithm on the data structure. The runs can be established, for example, by a run generator 825.
The data processing system can begin a merge operation 1115. The data processing system may begin the merge operation from the established run or runs. The merge operation can generate runs for subsequent merge levels. The merge operation can start with the smallest key value and proceed to the largest key value in the key domain. The resulting run of merges can be inserted into a merge level on the database, e.g., the merge level of the database. The merged resulting run can include all data records in one or more runs used in the merge operation.
The data processing system can track the merge operation (1120). The data processing system can use the merge index to track the progress of the merge operation. The merge index is able to track the current key value of the merge operation. The data processing system is able to track the merge by comparing the merged current key value to the key field of the merge level. The data processing system can also track merges by counting the number of records that have been merged into the next merge level.
The data processing system can determine whether the merge index satisfies the quantile point condition (1125). The data processing system can compare the merge index to the quantile condition. The quantile can be some key value and can be predetermined or dynamically determined. For example, if the merge index is equal to the key value, the quantile condition has been satisfied. The split-site condition may also be a number of merged data records. For example, if the number of merged data records exceeds a certain threshold, the merge index satisfies the quantile condition. If it is determined that the merge index does not satisfy the quantile condition, the data processing system can repeat (1120) the functionality.
If it is determined that the merge index satisfies the quantile point condition, the data processing system can add a second ordered run of data records (e.g., the second run 815B) to the merge (1130). The data processing system can add the established second run of data to the merge, starting a two-way merge at the current merge index, and continuing the merge until the merge is complete. The data processing system can continue to add runs to the merge until the merge level reaches a steady state. The merge level is in a steady state when the rate at which data records are available for merging is equal to the rate at which data records are merged.
These insertions should be incremented as the merge progresses, balancing the overhead of merge progress with low-latency incremental statistics. When a key range is committed in the merged output, the new boundary key (as a key-pointer pair) points to the new merged output for lower key values and points to the previous run for higher keys; furthermore, for runs at the level of the merge input, the same key value will point to the run before the merge input for lower key values and to the remaining merge input for higher key values. Again, concurrency control for coordinating active queries, future queries, and the like is discussed below.
Bulk deletion
"Range delete" is a powerful function already included in the original design for log-structured merge trees. This can be generalized to adding a scanning predicate called a "sealable predicate" in query optimization.
A special "Range delete" record specifies the key range and optionally the scan predicate. It "sorts" before the active records in the key range. The merge step applies range deletion and suppresses range deletion records in the merged output. In some cases, a single "range delete" record may be required to split into multiple such records with complementary key ranges. For example, if the merge step processes a limited key range and if the key range ends before the end of range deletion, the remaining key range requires its own "range delete" record. The later part covers the scope of deletion in the context of snapshot isolation and multi-version storage.
Storage space reclamation
After the merging step copies the data from its input runlength (partition) to its output runlength (partition), the input data can be erased and the storage space freed. However, that has two difficulties. First, space reclamation may be done at the granularity of a page (or group of pages); and second, while some active query execution plan still relies on one of the input partitions, that space may not be freed. The second concern is one of concurrent control and is addressed in later sections. It is sufficient to mention here snapshot isolation and multi-version concurrency control. First focus is discussed herein.
The memory page is ready to be freed when it is erased to the last pointer. If there are multiple pointers, for example from multiple pages of data in subsequent partitions, the rightmost of these pointers is important (in the sense that the merge step proceeds from left to right through the key field). In other words, if the page pointer is erased in a data page and the same data page contains another pointer to the next data page, the first pointer and its referenced data page will become stale and the page can be reclaimed as free space.
When a data page is reclaimed, the page pointer it contains is erased. All but the rightmost page pointers are the rightmost pointers to the pages of reference data in the preceding partition; thus, those pages of data are also erased. The same logic is always applied to the oldest run (partition) of the merge level if those data pages themselves contain page pointers. In this way, the eviction of a page of data in the most recent run (partition) within a merge level may propagate through the entire merge level, through all runs in the same merge level.
The page pointers in the in-memory index work slightly differently but are intended to be the same. If the merge step is performed on top of a key-pointer pair in the in-memory index, the previous key-pointer pair becomes stale and the base page can be logically deleted, subject to multi-version concurrency control for the key-pointer pair in the in-memory index. When a logical delete becomes a physical delete and the key-finger pair in memory is erased, then the underlying memory page can be reclaimed. The reclamation of the memory page may also follow the above described logic to reclaim the data pages in the previous partition. The LRU buffer pool policy should avoid all I/O during this process.
To correctly apply range deletion, the "range deletion" record should be repeated as the first key value in each affected inode, including its timestamp. This starts in the in-memory index and the merging step brings the "range delete" record to each affected inode in its output and repeats the "range delete" record on it. The query looks for "range delete" records and applies them in their own merge logic that constructs the query results.
Overview of interleaved Merge
In the overview of interleaved merging, a linear partition b-tree can be used as a storage structure for efficient merging and searching. The in-memory ordered index may hold both data and key-pointer pairs (effectively quads); the data on the temporary storage can take any storage structure that allows direct page access, and for incremental space reclamation, page-by-page freeing may be used. Interleaving merges with other designs for log-structured merge trees consumes much less temporary storage space than does a log-structured merge tree, and it allows for much faster queries for a given merge fan-in.
Mode change
There are a wide variety of possible mode variations. What is important here is the distinction between mode operation in which data movement is required and mode operation in which data movement is not required. An example of the former is index creation; an example of the latter is dropping integrity constraints. This section covers the mechanism for data movement for mode changes and ignores all other aspects.
Index creation
Index creation may involve creating a new secondary index in the form of a log-structured merge tree. Efficient creation of b-tree indexes requires scanning the data source to extract new index entries, ordering them, and constructing branching nodes while appending the index entries on leaf nodes. Here, no ordering is required; instead, new index entries are inserted in random order and logic in the log structured merge tree ensures efficient in-memory run generation, merge runs, creation and maintenance of branch nodes, and so forth.
Once the new index is defined and its existence is confirmed, all future insertions into the database table insert the appropriate new index entries as they would for the older secondary index. To backfill the new index with entries for the old row in the table, one can scan the table or one can add side effects to subsequent merge steps in the table. The table scan may include all partitions within its log-structured merge tree.
Details of the logic used to derive the correct set of index entries from the multiple merge steps are omitted here. Note that if all new index entries come from the merge step, the delay until the index is complete can be substantial.
The new secondary index becomes available for query execution when its content is complete. Merging its partitions will continue as long as the insertion continues into the base table.
Index removal
As discussed above, the primary technique for index removal is range deletion. The details depend on how well the removed index fits into the log-structured merge tree. The range-deletion record specifies a key range if the removed index is concatenated with other indices (e.g., the removed index represents a contiguous key range in final sorted order). On the other hand, if the removed index is interleaved with other indices in the merged index, the range delete record specifies the range equivalent to the merged index plus the scan predicate equivalent to the removed index.
Summary creation and removal
Sink is always a materialized view defined by a query with a "by group" clause but no join; the summary may have a choice if the predicates can be evaluated one row at a time without nested queries. The summary is stored in a primary index and it may have a secondary index.
The creation and removal of these indices, including the materialization summarized in their primary index, works much like the index creation and removal of tables as discussed above.
Repartitioning
The primary job of repartitioning is data movement. It may be implemented as a delete or an insert. Part of the problem is that the insertion requires scanning, but this is also an opportunity: scanning can implement deletion as a side effect. Furthermore, scanning and deletion may be a side effect of the merging step. In other words, what is desired is what is like a "delete to" operation that scans, deletes, and produces an output stream that can be repartitioned and then fed to the insertion logic. The insertion is handled using standard insertion logic with run generation and multiple merge levels as if the records were completely new information.
Overview of Pattern Change
In summary, changes in patterns that require data movement can be mapped to scans plus the insertion of new index "chunk delete" entries or the appropriate inverse problem. These insertions can go through run-length generation and multilevel merging in memory much like new data records captured by an application.
Operation of
This section covers operations that include synchronization, concurrency control, logging, and recovery of the primary and secondary indexes. When run generation and merging records all of its activities in the in-memory index, concurrency control, logging, and recovery are all focused on the in-memory index or indeed key-pointer pair. Implying concurrent control of data logging (all partitions are read-only once written), and the recovery of the contents of a partition relies on forcing its data pages to storage before committing them.
Synchronization of primary and secondary indexes
There are two aspects to synchronizing the primary index and the secondary index. First, they seek to contain the same logical row, and therefore, after each transaction, should contain the same number of index entries. Second, in the context of a log-structured merge tree, it should be simple and efficient to navigate from an entry in the secondary index to a corresponding entry in the primary index of the table.
The first problem is covered by creating one index entry per index from each row in the input stream. This includes replacement entries for logical updates and tombstone entries for logical deletions.
The second problem can be solved by synchronizing the merging steps of the primary and secondary indices of the table. While more complex designs are possible, it seems sufficient to place the primary index and all secondary indices of the table into the same log-structured merge tree in the spirit of a merge index, with the index identifier as a manual predecessor key field in each index entry. In this case, the merging step always affects all indexes equally. In practice, a single log structured merge tree may hold multiple related tables and all of their indices. By log K tables and indexes2The search effort grows in each root-to-leaf tree search compared to K. Prefix truncation reduces storage overhead to a vanishing level.
Late arrival
Late arrival is a notorious problem in stream processing and stream indexing. For most data items, there is a high correlation (and small difference) between event time (also referred to as user time or real world timestamp) and arrival time (also referred to as system time and capture timestamp). Late arrival is an exception to breaking the correlation of large differences between event time and arrival time.
If a column of the table indexed with the b-tree has a high correlation with another column, augmenting each parent-to-child pointer in the b-tree with the key range of the other column creates a very efficient index for the other column. This is related to the region map (and other small physicochemical aggregates) that focus on the minimum and maximum values of all columns in the table. Integration into the b-tree structure naturally creates its hierarchical variant. Another obvious variant omits the minimum and maximum values of columns that are weakly correlated with the index column. For relational keys and other columns with only equal predicates, the bit vector filter can replace or augment the minimum and maximum values. In addition to the minimum, maximum, and bit vector filters, the region filter also allows second to minimum key values and second to maximum key values to cope with strong outliers.
The log-structured merge tree can also benefit from the zone filter. With the log-structured merge tree formatted as a partition b-tree, the minimum and maximum values allow for an efficient search of event times in the case of runs representing partitions with respect to arrival time, and in the case of high correlation between event timestamps and arrival timestamps. The second to minimum value of the event timestamp allows embedding a very sharp filter in the index structure if late arrival is rare enough.
This applies to any index and any attribute; the correlation is related to the partition attribute (e.g., capture timestamp) and not the index attribute. For example, a web service may use a log-structured merge tree represented by a partition b-tree to index its log on user identifiers. A zone filter appended to each parent-to-child pointer within this b-tree may indicate a range of event timestamps. These zone filters are likely to be invalid for parent-to-child pointers and may be omitted. However, in the case where the parent-to-child pointer separates partitions and thus key ranges in arrival timestamps, the minimum and maximum values speed up the search by event timestamp. If there is a late arrival (e.g., a particularly low event timestamp) in the web log record, the minimum may be fraudulent, whereas the second to minimum appended to the parent-to-child pointer guides any future searches very accurately.
Adaptive merging by index and key range
The adaptive merge in partition b-tree scans and deletes key ranges in multiple runs and merges these index entries into higher level runs. It is usually, but not necessarily, a side effect of query execution. The key ranges may follow the query predicates, but need not. For example, in many index-concatenated merge indexes, the merge step may focus on one of those indexes. In that case, the index identifier is the leading key field after the partition identifier and the equality predicate on the index identifier defines the adaptive merging step.
One problem is that adaptive merging for a particular key range invalidates the assumption of strictly merging from left to right. Therefore, the start key value requires special attention within the in-memory index to coordinate all merge and search activities in the log-structured merge tree. Within the key domain of the log-structured merge tree, the starting key value of the adaptive merge step requires a new key-pointer pair in the in-memory index. If the adaptive merge step extracts and deletes index entries from all runs, the new key-pointer pair contains a null pointer; otherwise, it points to the nearest run not included in the adaptive merge step. In memory reclamation, key-pointer pairs that reference older runs allow pages referenced by lower key values to be freed.
In a table or view having a secondary index in addition to a primary index, key range merging within a single index destroys the one-to-one mapping between partitions in the primary and secondary indices. In those cases, the query may attempt to resolve the row pointer by accessing the matching partition, and then go to the larger partition (e.g., merge the outputs) as needed.
Concurrent control
Run generation and merging modify run files and their entries in the in-memory index, whereas the same in-memory index directs queries that check the same partition; therefore, some kind of concurrency control will be performed. Fortunately, concurrency control focuses on in-memory indexing; the run or partition, once written, remains read-only until deleted.
The in-memory index holds both the key-pointer pair of the most recent run at each merge level and the data record used for run generation. These data records are used for run-length generation; no concurrency control is required other than coordinating threads to protect low-level concurrency control of in-memory data structures. The key-pointer pair may require transactional concurrency control. Having two in-memory indices, one for data recording and one for key-to-finger pairs, may seem a good idea, but that design requires cumbersome consolidation and memory management logic in order to achieve all desired functionality while still utilizing all memory.
In the case where the query execution plan ends its work while the merge step replaces the key-pointer pair according to its merge progress, the in-memory index requires multi-version concurrency control with snapshot isolation for read-only queries, locking index updates in the merge step, and garbage collection when entries become stale.
In a database index, a delete transaction changes a valid index entry into a ghost (also referred to as a pseudo-delete record) and reserves both space and locks on the ghost index entry. Subsequent insert transactions may erase unlocked ghosts by invoking system transactions (also referred to as nested top-level actions). In a storage structure with multi-version records, the ghosting is that the deleted or replaced version record was committed before the oldest active read-only transaction; the tombstone record is a ghost image when all previous version records disappear and the tombstone is unlocked and committed. Insertion into the in-memory index, whether a data record or a key-pointer pair, performs the required garbage collection by calling system transactions for ghosting removal.
Recovery
For the content of the partition file (e.g., data records), the run generation and merge step refreshes the completed runs and even the key ranges completed within their output runs. This includes all key-pointer pairs that reference the previous partition and any region filters attached to these key-pointer pairs. The techniques herein apply to the management of runs through reliable transactional recovery of key-pointer pairs in an in-memory index.
It appears that the logical pre-written log record can provide the information and reliability needed to recover from all failures (except log failures). With appropriate organization of log records, e.g., recovery of log records in a log and a backward chain of partially ordered log records in a log archive, all forms of immediate recovery are possible, including single page repair, immediate restart, single-phase restore, immediate failover, and the like. All of these techniques rely on page-by-page restore on demand and transaction-by-transaction rollback on demand.
Logical recovery means that the database page identifier has no role or meaning; instead, the logical recovery focuses on the version number appended to the unique key. The log record contains a back-chain by a unique key and the checkpoint log record contains a list of unique keys that may be dirty (unwritten). It is equivalent to refreshing a dirty page to write a unique key and all associated information.
Log logging
The pre-written log record may be required for changes in the in-memory index that affect the key-pointer pair, its index value, and its placement in the index. Logical logging and recovery are best served for such in-memory databases. With logical logging and recovery, restart after a system failure (due to memory loss) creates new in-memory indices containing key-pointer pairs, exactly as they were committed before the failure. Thus, runs of all merge levels remain accessible. The store logic for storing the up run may remove uncommitted partial runs and key ranges.
Alternative designs including data logging and store-up runs in logging and recovery have the advantage of a single code base and uniform guarantees for all recoveries, but the disadvantage is that the log volume is as high (or even slightly higher) than the data volume.
Overview of the operation
In summary, the proposed techniques for log-structured merge trees, including in-memory indexing and interleaved merge algorithms promise excellent operational characteristics. In addition to merging bandwidth and query latency, they promise stable continuous operation without performance cliffs, support for redundant secondary indexing and materialized grouped views or summaries, and tolerance for late arrival with minimal or moderate impact on query performance. Perhaps most importantly, the proven techniques for concurrency control, logging, and recovery can provide concurrency, reliability, and availability to the central data structure, in-memory index, and all runs and partitions.
For physical recovery, a log record refers to a database page and byte offset; for "physiological" recovery, the log records refer to database pages and slot numbers; for logical recovery, a log record refers to an index and a unique key value; whereas for semantic recovery, the log records refer to tables and primary keys. Physical recovery can be used in database systems and in the form of images, and in many file systems; physiological recovery has been the default choice in databases; logical recovery enables restoring a database on a completely different device that includes storage and memory without pages; and semantic recovery can restore the database for different purposes, e.g., transactional versus query processing has different choices in physical database design such as partitioning, index selection, and compression. Semantic log recording and recovery is particularly useful in the context of replication by log shipping, which includes log shipping with selection predicates. The logical recovery focuses on the version number appended to the unique key. The log record contains a back-chain by a unique key and the checkpoint log record contains a list of unique keys that may be dirty (unwritten). It is equivalent to refreshing a dirty page to write a unique key and all associated information. And the log archiving key value for logic recovery orders the log records.
Examples of introduction
For the introduced example, the new data structure and algorithm achieves a new balance between merge performance and search performance (e.g., merge bandwidth and search latency). The difference is that the search effort is reduced by a factor of 2 without affecting the merging effort. Alternatively, the merge fan-in can be increased by a factor of 2 without affecting the search effort.
Table 2 shows the latest available choices for the fan-in and merge levels. With the same consolidation effort (e.g., 6 levels), the search effort is reduced to one third (from 54 partitions to 18 partitions) compared to table 1. With the same search effort (e.g., 54 partitions), the merge effort is cut in half (from 6 merge levels to 3 merge levels). The choice of balance requires twice the best merging effort (4 for 2 merging levels) and twice the best search effort (30 for 15 partitions). This is also a near-optimal choice in table 2. These techniques employ 21/2 times larger merge fanins (6 pairs in table 1 and 15 in table 2) compared to the near-optimal choices in table 1, and allow 11/2 times faster merges (6 merge levels in table 1 versus 4 merge levels in table 2) with almost 2 times faster search (54 partition pairs in table 1 versus 30 partitions in table 2) as promised in the abstract.
In applications motivating this study, the surrogate performance metrics were such that: how close to real-time the query results can be if each query can search for a limited number of increments, e.g., up to 30 increments? For example, in table 1, real-time querying is not possible due to the limit of 30 increments. The strict limit of 30 increments limits queries to querying older data, resulting in an artificial latency from data ingesting to first querying. For example, fanin 4 in table 1 requires 8 merge levels. In the case of 6 runs per merge level on average, 5 merge levels can be queried. Runs at the nearest 3 merge levels can be omitted from the query. Thus, the artificial delay is 1 minute times 43 or more than one hour.
Rank of | Fan in | Searching |
2 | 212 | 212 |
3 | 36 | 54 |
4 | 15 | 30 |
5 | 9 | 23 |
6 | 6 | 18 |
7 | 5 | 18 |
8 | 4 | 16 |
10 | 3 | 15 |
16 | 2 | 16 |
Table 2. number of merging and search minutes within improved month.
Alternatively, a weaker limit of 50 increments requires 8, 10, or even 16 merge levels for real-time queries. In other words, each input row goes back and forth 8, 10, or even 16 times between memory and storage. In contrast, with the table 2 based technique, 4 merge levels are sufficient to limit the query to 30 increments. In other words, half of the consolidation effort (per row of travel between memory and storage) allows for latency from ingest to first query that cannot be achieved with any consolidated fan-in using the original technique based on table 1.
Another example
As another example, consider the number of minutes in a year, where 60 × 24 × 366 ≈ 527,040 ≈ 312＝531,441≈219524,288. One possible merge plan employs 6 merge levels with a fan-in 9.
TABLE 3. number of merging and search minutes in one year.
Table 3 shows example calculations for a one minute run throughout the year (366 days). Two merge levels are approximately every 121/2Hours (726 minutes) combine one minute runs for about 726 runs end of year (or exactly 732 runs every 12 hours). For best search performance, there should be 12 merge levels. In the old merge mode, the 12 merge levels imply an average query effort to search for 54 runs; if the search for 54 runs is acceptable, the merge mode requires 4 merge levels with 3 times less merge effort.
Focusing on the alternative performance metrics, the 6-level merge of Table 3 and the limit of 30 increments per query, the merge mode for log-structured merge-tree queries runs in the top two merge levels (4 days or older data); however, the merge mode allows querying all runs, with valid real-time query results as desired for monitoring and for online dashboards.
Overview and conclusion
In summary, a b-tree index and log structured merge tree may be used with the techniques described herein. Linear partition b-tree and staggered merging may not resolve the tension between fast merging and fast search, but they alleviate the suffering by reducing the average (expected) number of partitions to search in each query and by reducing both the merging effort and the search effort at a balanced or near-optimal trade-off.
In summary, virtually any data warehouse and any web analytics application should use log-structured merge trees in order to grow tables and their indexes continuously, but they should use optimal policies and mechanisms. Linear partition b-tree and staggered consolidation can save a lot of data center resources and cost.
While this design covers many aspects of information capture and incremental merging in log-structured merge trees, it is particularly focused on in-memory ordered indexes that coordinate all merging and searching activities. This design covers rollups (materialized "per-group" views) and secondary indexes (which may be considered particularly simple materialized views), but it does not cover materialized join views (views that combine two or more tables, indexes, or other materialized views). The detailed design is left to future work, but several suggestions may be allowed here.
If one of the added inputs is a stream, the stream can be indexed using techniques presented earlier. Other join inputs should have the appropriate index so that the stream inputs can be added and the results applied to materialized joins. Applying the join output itself may use the techniques described above. The materialized join view is materialized and indexed as a log-structured merge tree of its primary index and any secondary indexes.
If the two joining inputs are streams, they should both be indexed using the techniques described above. As the input arrives, it joins with the indices of other tables, and the join results are materialized and indexed as a log-structured merge tree, expected to be optimized as described in this disclosure.
C. Computer framework
Fig. 12 shows the general architecture of an illustrative computer system 1200 that may be employed to implement any of the computer systems discussed herein, in accordance with some embodiments. Computer system 1200 may be used to provide information for display via network 810. The computer system 1200 of fig. 12 includes one or more processors 1220, one or more communication interfaces 1205, and one or more output devices 1210 (e.g., one or more display units) and one or more input devices 1215 communicatively coupled to a memory 1225. Processor 1220 may be included in data processing system 110 or other components of system 800, such as data processing system 805.
In computer system 1200 of fig. 12, memory 1225 may comprise any computer-readable storage medium and may store computer instructions, such as processor-executable instructions for implementing the various functionalities described herein for the respective system, and any data associated therewith, generated thereby or received via a communication interface or input device (if present). Referring again to the system 800 of FIG. 8, the data processing system may include a memory 1225 to store information relating to user identifiers, generated vectors, and the like. The processor 1220 shown in fig. 12 may be used to execute instructions stored in the memory 1225, and in so doing, may also read from and write to the memory various information processed and/or generated pursuant to execution of the instructions.
The processor 1220 of the computer system 1200 shown in fig. 12 may also be communicatively coupled to or control the communication interface 1205 to transmit or receive various information in accordance with the execution of instructions. For example, communication interface 1205 may be coupled to a wired or wireless network, bus, or other communication means, and may therefore allow computer system 1200 to transmit information to, or receive information from, other devices (e.g., other computer systems). Although not explicitly shown in the system of fig. 12, one or more communication interfaces facilitate the flow of information between components of the system 1200. In some implementations, the communication interface may be configured (e.g., via various hardware or software components) to provide a website as an access portal to at least some aspects of the computing system 1200. Examples of the communication interface 1205 include a user interface (e.g., a web page) through which a user can communicate with the data processing system 1200.
For example, an output device 1210 of the computer system 1200 shown in fig. 12 may be provided to allow various information to be viewed or otherwise perceived in connection with execution of the instructions. An input device 1215 may be provided, for example, to allow a user to manually adjust, select, enter data, or otherwise interact with the processor during execution of instructions. Additional information regarding the general computer system architecture that can be used with the various systems discussed herein is further provided herein.
Embodiments of the subject matter and the operations described in this specification can be implemented in digital electronic circuitry, or in computer software embodied in tangible media, firmware, or hardware, including the structures disclosed in this specification and their equivalents, or in combinations of one or more of them. Implementations of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more components of computer program instructions, encoded on a computer storage medium for execution by, or to control the operation of, data processing apparatus. Program instructions may be encoded on an artificially generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. The computer storage media may be or be included in a computer-readable storage device, a computer-readable storage substrate, a random or serial access memory array or device, or a combination of one or more of them. Further, although the computer storage medium is not a propagated signal, the computer storage medium can comprise a source or destination of computer program instructions encoded in an artificially generated propagated signal. The computer storage media may also be or be embodied in one or more separate physical components or media (e.g., multiple CDs, disks, or other storage devices).
The features disclosed herein may be implemented on a smart television module (or connected television module, hybrid television module, etc.) that may include a processing module configured to integrate an internet connection with a more traditional television program source (e.g., via cable, satellite, wireless, or other signal reception). The smart television module may be physically incorporated into a television set or may comprise a separate device such as a set-top box, a blu-ray or other digital media player, a game console, a hotel television system, and other companion devices. The smart television module may be configured to allow viewers to search and find videos, movies, photos, and other content on the web, on local cable channels, satellite television channels, or stored on a local hard disk. A set-top box (STB) or set-top unit (STU) may include an information appliance device that may contain a tuner and connect to a television and an external signal source, tune the signal to content, and then display the content on a television screen or other display device. The smart television module may be configured to provide a main screen or top-level screen that includes icons for a number of different applications, such as a Web browser and a number of streaming media services, a connected cable or satellite media source, other Web channels, and so forth. The smart television module may be further configured to provide an electronic program guide to the user. A companion application for the smart television module may operate on the mobile computing device to provide additional information to the user about available programming, to allow the user to control the smart television module, and so forth. In alternative embodiments, the features may be implemented on a laptop or other personal computer, smartphone, other mobile phone, palmtop computer, tablet, or other computing device.
The operations described in this specification may be implemented as operations performed by data processing apparatus on data stored on one or more computer-readable storage devices or received from other sources.
The terms "data processing apparatus," "data processing system," "user device" or "computing device" encompass all types of apparatus, devices, and machines for processing data, including for example, a programmable processor, a computer, a system on a chip, or a plurality or combination of the foregoing. The apparatus can comprise special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit). The apparatus can include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, a cross-platform runtime environment, a virtual machine, or a combination of one or more of them. The apparatus and execution environment may implement a variety of different computing model infrastructures, such as web services, distributed computing, and grid computing infrastructures.
A computer program (also known as a program, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, object, or other unit suitable for use in a computing environment. A computer program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform actions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer include a processor for performing actions in accordance with instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. However, a computer need not have such devices. Further, the computer may be embedded in another device, e.g., a mobile telephone, a Personal Digital Assistant (PDA), a mobile audio or video player, a game player, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., a Universal Serial Bus (USB) flash drive). Devices suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, such as internal hard disks or removable disks; magneto-optical disks; and CD ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube), plasma, or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse and a trackball, by which the user can provide input to the computer. Other types of devices can also be used to provide for interaction with a user; for example, feedback provided to the user can include any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input. In addition, the computer is able to interact with the user by sending and receiving documents to and from the device used by the user; for example, by sending a web page to a web browser on the user's client device in response to a request received from the web browser.
Implementations of the subject matter described in this specification can be implemented in a computing system that includes a back end component (e.g., as a data server), or that includes a middleware component (e.g., an application server), or that includes a front end component (e.g., a client computer having a graphical user interface or a web browser through which a user can interact with an implementation of the subject matter described in this specification), or a combination of one or more such back end, middleware, or front end components. The components of the system can be interconnected by any form or medium of digital data communication (e.g., a communication network). Examples of communication networks include local area networks ("LANs") and wide area networks ("WANs"), the internet (e.g., the internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks).
A computing system, such as data processing system 805, may include clients and servers. For example, the data processing system 805 may include one or more data centers or one or more servers in a server farm. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other. In some implementations, the server transmits data (e.g., HTML pages) to the client device (e.g., for the purpose of displaying data to and receiving user input from a user interacting with the client device). Data generated at the client device (e.g., a result of the user interaction) may be received from the client device at the server.
While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any inventions or of what may be claimed, but rather as descriptions of features specific to particular implementations of the systems and methods described herein. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.
Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In some cases, the actions recited in the claims can be performed in a different order and still achieve desirable results. In addition, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results.
In some cases, multitasking and parallel processing may be advantageous. Moreover, the separation of various system components in the implementations described above should not be understood as requiring such separation in all implementations, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products. For example, the data processing system 805 may be a single module, a logical device with one or more processing modules, one or more servers, or a portion of a search engine.
Having now described some illustrative embodiments and implementations, it is apparent that the foregoing is illustrative and not limiting, having been presented by way of example. In particular, although many of the examples presented herein involve specific combinations of method acts or system elements, those acts and those elements may be combined in other ways to accomplish the same objectives. Acts, elements and features discussed only in connection with one implementation are not intended to be excluded from a similar role in other implementations or implementations.
The phraseology and terminology used herein is for the purpose of description and should not be regarded as limiting. The use of "including," "comprising," "having," "containing," "involving," "characterized by," and variations thereof herein, is meant to encompass the items listed thereafter and equivalents thereof as well as additional items and alternative embodiments that consist only of the items listed thereafter. In one embodiment, the systems and methods described herein consist of one, each combination of more than one, or all of the described elements, acts, or components.
Any reference herein to an implementation or element or act of the systems and methods in the singular may also encompass implementations including a plurality of such elements, and any reference herein to any implementation or element or act in the plural may also encompass implementations including only a single element. References in the singular or plural form are not intended to limit the presently disclosed systems or methods, their components, acts, or elements to a single or multiple configurations. References to any action or element based on any information, action, or element may include implementations in which the action or element is based, at least in part, on any information, action, or element.
Any embodiment disclosed herein may be combined with any other embodiment, and references to "an embodiment," "some embodiments," "an alternative embodiment," "various embodiments," "one embodiment," or the like are not necessarily mutually exclusive and are intended to indicate that a particular feature, structure, or characteristic described in connection with the embodiment may be included in at least one embodiment. Such terms as used herein do not necessarily all refer to the same embodiment. Any embodiment may be combined, inclusively or exclusively, with any other embodiment in any manner consistent with aspects and embodiments disclosed herein.
References to "or" may be construed as inclusive such that any term described using "or" may refer to any single, more than one, and all of the described terms.
Where technical features in the drawings, detailed description or any claim are followed by reference signs, the reference signs have been included to increase the intelligibility of the drawings, detailed description, and claims. Accordingly, the reference signs or their absence have no limiting effect on the scope of any claim element.
The systems and methods described herein may be embodied in other specific forms without departing from the characteristics thereof. Although the examples provided herein relate to controlling the display of information resource content, the systems and methods described herein may include application to other environments. The foregoing embodiments are illustrative, and not limiting of the described systems and methods. The scope of the systems and methods described herein is, therefore, indicated by the appended claims rather than by the foregoing description, and all changes that come within the meaning and range of equivalency of the claims are therefore intended to be embraced therein.
Claims (20)
1. A method of maintaining a key-value store, comprising:
establishing, by a data processing system having one or more processors, a first run on a first buffer for sorting a first plurality of records, the first plurality of records initially indexed by a first corresponding plurality of index values, each record of the first plurality of records having a first key value in a key field, the key field defining a plurality of key values;
tracking, by the data processing system, a merge of the first plurality of records of the first run onto a merge level maintained on a database using a merge index that references the first key value of a record of the first plurality of records added to the merge level during the merge;
establishing, by the data processing system, a second run on a second buffer concurrent with the merging of the first plurality of records for sorting a second plurality of records indexed by a second corresponding plurality of index values different from the first plurality of index values, each record of the second plurality of records having a second key value in the key domain;
determining, by the data processing system, that a merge index that tracks a merge of the first plurality of records onto the merge level satisfies a split-point condition, the split-point condition corresponding to at least one of the plurality of key values in the key domain;
identifying, by the data processing system and in response to determining that the merge index corresponds to the split-point condition, a subset of the second plurality of records of the second run from the second buffer, each record of the subset having a corresponding second key value that satisfies the split-point condition; and
adding, by the data processing system, the subset of the second plurality of records of the second run to a merge of the first plurality of records of the first run onto the merge level maintained on the database.
2. The method of claim 1, further comprising:
determining, by the data processing system, a switchover key value based on a ratio of the merge index and a quantile index specified by the quantile condition; and
determining, by the data processing system, a bandwidth offset based on a consolidated bandwidth of the database, the consolidated bandwidth indicating a rate at which the database is adding the first plurality of records and the subset of the second plurality of records is consolidated, and
wherein determining that the merge index satisfies the split-point condition further comprises determining that the merge index satisfies the transit key value adjusted by the bandwidth offset.
3. The method of any preceding claim, further comprising:
tracking, by the data processing system, creation of the second run using the second plurality of records using a run index that references a number of the second plurality of records ordered in the second run; and
determining, by the data processing system, that the second key value of a record of the second plurality of records referenced by the run index satisfies the split-point condition, and
wherein adding the subset of the second plurality of records further comprises initiating adding the subset of the second plurality of records of the second run to the merge concurrently with the establishment of the second run and in response to determining that a second key value of a record referenced by the run index satisfies the split point condition.
4. The method of any preceding claim, further comprising:
identifying, by the data processing system, a first run generation rate that establishes the first run on the first buffer, the first run generation rate indicating a speed at which records of the first plurality of records are ordered in the first run;
identifying, by the data processing system, a second run generation rate that establishes the second run on the second buffer, the second run generation rate indicating a speed at which records of the second plurality of records are ordered in the second run; and
setting, by the data processing system, a merge bandwidth for adding the first plurality of records of the first run onto the database based on at least one of the first run generation rate and the second run generation rate.
5. The method of any preceding claim, further comprising:
identifying, by the data processing system, a distribution of a corresponding plurality of first key values over the key domain for the first plurality of records;
determining, by the data processing system, a plurality of quantile point conditions including the quantile point condition based on a distribution of the corresponding plurality of first key values over the key domain.
6. The method of any preceding claim, further comprising:
determining, by the data processing system, a merge level at which all of the first plurality of records of the first run are added to the database while merging the subset of the second plurality of records and the first plurality of records at the merge level;
releasing, by the data processing system, the first buffer from the first plurality of records to receive a third plurality of records for a third run in response to determining that all of the first plurality of records for the first run are added; and
maintaining, by the data processing system, the second plurality of records on the second buffer concurrently with the merging of the subset of the second plurality of records onto the merge level on the database.
7. The method of any preceding claim, further comprising:
determining, by the data processing system, that the merging of the subset of the second plurality of records and the first plurality of records onto the database is complete at the merge level; and
initializing, by the data processing system, a third run at a second merge level on the database to receive a merge of at least a remaining subset of the second plurality of records of the second run in response to determining that the merge to the merge level is complete.
8. The method of any preceding claim, further comprising:
receiving, by the data processing system, a query for at least one of the plurality of key values defining the key domain; and
using, by the data processing system, the query to search the merge level on the database, the merge level including records from a plurality of runs.
9. The method of any preceding claim, wherein merging the subset of the second plurality of records further comprises tracking a merge of the subset of the second plurality of records onto the merge level on the database using a second merge index that references the second key value added to one of the second plurality of records of the merge level during the merge, the second merge index initially set based on the split-point condition.
10. The method of any preceding claim, wherein establishing the first run further comprises sorting the first plurality of records by a corresponding plurality of first key values over the key field using at least one of a quick sort or priority queue, the first plurality of records initially sorted by the first corresponding plurality of index values, and
wherein establishing the second run further comprises:
receiving the second plurality of records from a data acquisition source via an input data stream for storage on the second buffer, the second plurality of records initially arranged by the second corresponding plurality of index values; and
sorting the second plurality of records by a corresponding plurality of second key values over the key domain using at least one of a quick sort or priority queue.
11. A system for maintaining a key-value store, comprising:
a data processing system having one or more processors configured to:
establishing a first run on a first buffer for sorting a first plurality of records, the first plurality of records initially indexed by a first corresponding plurality of index values, each record of the first plurality of records having a first key value in a key field, the key field defining a plurality of key values;
tracking a merge of the first plurality of records of the first run onto a merge level maintained on a database using a merge index that references a first key value of a record of the first plurality of records added to the merge level during the merge;
establishing, concurrently with the merging of the first plurality of records, a second run for sorting a second plurality of records indexed by a second corresponding plurality of index values different from the first plurality of index values, each record of the second plurality of records having a second key value in the key domain;
determining that the merge index that tracks the merging of the first plurality of records onto the merge level satisfies a split-point condition, the split-point condition corresponding to at least one of the plurality of key values in the key domain;
in response to determining that the merge index corresponds to the split-point condition, identifying a subset of the second plurality of records of the second run from the second buffer, each record of the subset having a corresponding second key value that satisfies the split-point condition; and is
Adding a subset of the second plurality of records of the second run to a merge of the first plurality of records of the first run onto the merge level maintained on the database.
12. The system of claim 11, wherein the data processing system is further configured to:
determining a handover key value based on a ratio of the merge index and a split-point index specified by the split-point condition;
determining a bandwidth offset based on a merge bandwidth of the database, the merge bandwidth indicating a rate at which the database is adding the first plurality of records and the subset of the second plurality of records are merged; and is
Determining that the merge index satisfies the transit key value adjusted by the bandwidth offset.
13. The system of any of claims 11 to 12, wherein the data processing system is further configured to:
tracking a build of the second run using the second plurality of records using a run index that references a number of the second plurality of records ordered in the second run; and is
Determining that the second key value of a record of the second plurality of records referenced by the run index satisfies the split-point condition, and
initiating adding the subset of the second plurality of records of the second run to the merge concurrently with the creation of the second run and in response to determining that a second key value of a record referenced by the run index satisfies a split-point condition.
14. The system of any of claims 11 to 13, wherein the data processing system is further configured to:
identifying a first run generation rate at which said first run is established on said first buffer, said first run generation rate indicating a speed at which records of said first plurality of records are ordered in said first run;
identifying a second run generation rate at which the second run is established on the second buffer, the second run generation rate indicating a speed at which records of the second plurality of records are ordered in the second run; and is
Setting a merge bandwidth for adding the first plurality of records of the first run to the database based on at least one of the first run generation rate and the second run generation rate.
15. The system of any of claims 11 to 14, wherein the data processing system is further configured to:
identifying, for the first plurality of records, a distribution of a corresponding plurality of first key values over the key domain;
determining a plurality of quantile conditions including the quantile condition based on a distribution of the corresponding plurality of first key values over the key domain.
16. The system of any of claims 11 to 15, wherein the data processing system is further configured to:
determining a merge level at which all of the first plurality of records of the first run are added to the database while merging the subset of the second plurality of records and the first plurality of records at the merge level;
releasing the first buffer from the first plurality of records for a third run in response to determining that all of the first plurality of records of the first run are added; and is
Maintaining the second plurality of records on the second buffer concurrently with the merging of the subset of the second plurality of records onto the merge level on the database.
17. The system of any of claims 11 to 16, wherein the data processing system is further configured to:
determining that a merge of the subset of the second plurality of records and the first plurality of records to the merge level on the database is complete; and is
Initializing a second merge level on the database to receive a merge of at least a remaining subset of the second plurality of records of the second run in response to determining that the merge onto the merge level is complete.
18. The system of any of claims 11 to 17, wherein the data processing system is further configured to:
receiving a query for at least one of the plurality of key values defining the key domain; and
using the query to search the merge level on the database, the merge level comprising records from a plurality of runs.
19. The system of any of claims 11 to 18, wherein the data processing system is further configured to track a merge of the subset of the second plurality of records onto the merge level on the database using a second merge index that references a second key value added to one of the second plurality of records of the merge level during the merge, the second merge index initially set based on the split-point location condition.
20. The system of any of claims 11 to 19, wherein the data processing system is further configured to:
sorting the first plurality of records by a corresponding plurality of first key values over the key domain using at least one of a quick sort or priority queue, the first plurality of records initially arranged by a first corresponding plurality of index values;
receiving the second plurality of records from a data acquisition source via an input data stream for storage on the second buffer, the second plurality of records initially arranged by a second corresponding plurality of index values; and is
Sorting the second plurality of records by a corresponding plurality of second key values over the key domain using at least one of a quick sort or priority queue.
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201862731630P | 2018-09-14 | 2018-09-14 | |
US62/731,630 | 2018-09-14 | ||
PCT/US2019/050579 WO2020055977A1 (en) | 2018-09-14 | 2019-09-11 | Staggered merging in log-structured merge forests |
Publications (1)
Publication Number | Publication Date |
---|---|
CN112236759A true CN112236759A (en) | 2021-01-15 |
Family
ID=68063066
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN201980038341.9A Pending CN112236759A (en) | 2018-09-14 | 2019-09-11 | Staggered merging in a log-structured merge forest |
Country Status (4)
Country | Link |
---|---|
US (1) | US11514014B2 (en) |
EP (1) | EP3791283A1 (en) |
CN (1) | CN112236759A (en) |
WO (1) | WO2020055977A1 (en) |
Cited By (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN113721863A (en) * | 2021-11-02 | 2021-11-30 | 支付宝(杭州)信息技术有限公司 | Method and device for managing data |
CN113786607A (en) * | 2021-09-29 | 2021-12-14 | 腾讯科技（深圳）有限公司 | Interface display method, device, terminal and storage medium |
CN114047876A (en) * | 2021-11-03 | 2022-02-15 | 河南星环众志信息科技有限公司 | Data sorting method and device based on columnar storage and storage medium |
CN116561073A (en) * | 2023-04-14 | 2023-08-08 | 云和恩墨(北京)信息技术有限公司 | File merging method and system based on database, equipment and storage medium |
Families Citing this family (15)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US11409727B2 (en) * | 2019-09-18 | 2022-08-09 | International Business Machines Corporation | Concurrent execution of database operations |
US11681708B2 (en) | 2019-12-26 | 2023-06-20 | Snowflake Inc. | Indexed regular expression search with N-grams |
US10997179B1 (en) | 2019-12-26 | 2021-05-04 | Snowflake Inc. | Pruning index for optimization of pattern matching queries |
US11579771B2 (en) * | 2020-05-12 | 2023-02-14 | Seagate Technology Llc | Data storage layouts |
US20220011948A1 (en) * | 2020-07-08 | 2022-01-13 | Samsung Electronics Co., Ltd. | Key sorting between key-value solid state drives and hosts |
CN111782659B (en) * | 2020-07-10 | 2023-10-17 | 东北大学 | Database index creation method, device, computer equipment and storage medium |
US11747996B2 (en) | 2020-08-05 | 2023-09-05 | Dropbox, Inc. | System and methods for implementing a key-value data store |
CN112000698B (en) * | 2020-08-25 | 2023-09-19 | 青岛海尔科技有限公司 | Log recording method and device, storage medium and electronic device |
US11308066B1 (en) * | 2021-02-24 | 2022-04-19 | International Business Machines Corporation | Optimized database partitioning |
US11797510B2 (en) * | 2021-04-20 | 2023-10-24 | Netapp, Inc. | Key-value store and file system integration |
US11782771B2 (en) * | 2021-05-20 | 2023-10-10 | Vmware, Inc. | Method and subsystem within a distributed log-analytics system that automatically determines and enforces log-retention periods for received log-event messages |
US11537613B1 (en) * | 2021-10-29 | 2022-12-27 | Snowflake Inc. | Merge small file consolidation |
US11593306B1 (en) | 2021-10-29 | 2023-02-28 | Snowflake Inc. | File defragmentation service |
US20230315712A1 (en) * | 2022-03-31 | 2023-10-05 | Unisys Corporation | Method of making a file containing a secondary index recoverable during processing |
US11748304B1 (en) * | 2022-04-19 | 2023-09-05 | International Business Machines Corporation | Insert performance improvement |
Citations (10)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5852826A (en) * | 1996-01-26 | 1998-12-22 | Sequent Computer Systems, Inc. | Parallel merge sort method and apparatus |
US20070143571A1 (en) * | 2005-12-21 | 2007-06-21 | Sinclair Alan W | Dual mode access for non-volatile storage devices |
CN103548019A (en) * | 2011-02-21 | 2014-01-29 | 阿玛得斯两合公司 | Method and system for providing statistical from a data warehouse |
CN104133867A (en) * | 2014-07-18 | 2014-11-05 | 中国科学院计算技术研究所 | DOT in-fragment secondary index method and DOT in-fragment secondary index system |
CN104809237A (en) * | 2015-05-12 | 2015-07-29 | 百度在线网络技术（北京）有限公司 | LSM-tree (The Log-Structured Merge-Tree) index optimization method and LSM-tree index optimization system |
CN105446653A (en) * | 2014-08-27 | 2016-03-30 | 阿里巴巴集团控股有限公司 | Data merging method and device |
US20160179865A1 (en) * | 2014-12-17 | 2016-06-23 | Yahoo! Inc. | Method and system for concurrency control in log-structured merge data stores |
US20170212891A1 (en) * | 2016-01-25 | 2017-07-27 | Netapp, Inc. | Scheduling technique to smooth metadata processing latency |
CN107077495A (en) * | 2014-10-19 | 2017-08-18 | 微软技术许可有限责任公司 | High performance transaction in data base management system |
CN108022001A (en) * | 2017-09-20 | 2018-05-11 | 河海大学 | Short term probability density Forecasting Methodology based on PCA and quantile estimate forest |
Family Cites Families (6)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8200633B2 (en) * | 2009-08-07 | 2012-06-12 | International Business Machines Corporation | Database backup and restore with integrated index reorganization |
US9274950B2 (en) * | 2009-08-26 | 2016-03-01 | Hewlett Packard Enterprise Development Lp | Data restructuring in multi-level memory hierarchies |
US9268502B2 (en) | 2013-09-16 | 2016-02-23 | Netapp, Inc. | Dense tree volume metadata organization |
US9792310B2 (en) * | 2015-04-29 | 2017-10-17 | Sap Se | Run index compression |
US10824558B2 (en) * | 2017-04-26 | 2020-11-03 | Oracle International Corporation | Optimized sorting of variable-length records |
US11182356B2 (en) * | 2019-05-23 | 2021-11-23 | International Business Machines Corporation | Indexing for evolving large-scale datasets in multi-master hybrid transactional and analytical processing systems |
-
2019
- 2019-09-11 EP EP19774024.4A patent/EP3791283A1/en active Pending
- 2019-09-11 WO PCT/US2019/050579 patent/WO2020055977A1/en unknown
- 2019-09-11 US US17/059,197 patent/US11514014B2/en active Active
- 2019-09-11 CN CN201980038341.9A patent/CN112236759A/en active Pending
Patent Citations (10)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5852826A (en) * | 1996-01-26 | 1998-12-22 | Sequent Computer Systems, Inc. | Parallel merge sort method and apparatus |
US20070143571A1 (en) * | 2005-12-21 | 2007-06-21 | Sinclair Alan W | Dual mode access for non-volatile storage devices |
CN103548019A (en) * | 2011-02-21 | 2014-01-29 | 阿玛得斯两合公司 | Method and system for providing statistical from a data warehouse |
CN104133867A (en) * | 2014-07-18 | 2014-11-05 | 中国科学院计算技术研究所 | DOT in-fragment secondary index method and DOT in-fragment secondary index system |
CN105446653A (en) * | 2014-08-27 | 2016-03-30 | 阿里巴巴集团控股有限公司 | Data merging method and device |
CN107077495A (en) * | 2014-10-19 | 2017-08-18 | 微软技术许可有限责任公司 | High performance transaction in data base management system |
US20160179865A1 (en) * | 2014-12-17 | 2016-06-23 | Yahoo! Inc. | Method and system for concurrency control in log-structured merge data stores |
CN104809237A (en) * | 2015-05-12 | 2015-07-29 | 百度在线网络技术（北京）有限公司 | LSM-tree (The Log-Structured Merge-Tree) index optimization method and LSM-tree index optimization system |
US20170212891A1 (en) * | 2016-01-25 | 2017-07-27 | Netapp, Inc. | Scheduling technique to smooth metadata processing latency |
CN108022001A (en) * | 2017-09-20 | 2018-05-11 | 河海大学 | Short term probability density Forecasting Methodology based on PCA and quantile estimate forest |
Non-Patent Citations (2)
Title |
---|
N. Y. SONG 等: "Efficient Key-Value Stores with Ranged Log-Structured Merge Trees", 2018 IEEE 11TH INTERNATIONAL CONFERENCE ON CLOUD COMPUTING (CLOUD), pages 652 - 659 * |
史英杰 等: "云数据管理系统中查询技术研究综述", 计算机学报, pages 209 - 225 * |
Cited By (10)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN113786607A (en) * | 2021-09-29 | 2021-12-14 | 腾讯科技（深圳）有限公司 | Interface display method, device, terminal and storage medium |
CN113786607B (en) * | 2021-09-29 | 2023-11-03 | 腾讯科技（深圳）有限公司 | Interface display method, device, terminal and storage medium |
CN113721863A (en) * | 2021-11-02 | 2021-11-30 | 支付宝(杭州)信息技术有限公司 | Method and device for managing data |
CN113721863B (en) * | 2021-11-02 | 2021-12-31 | 支付宝(杭州)信息技术有限公司 | Method and device for managing data |
CN114237507A (en) * | 2021-11-02 | 2022-03-25 | 支付宝(杭州)信息技术有限公司 | Method and device for managing data |
CN114237507B (en) * | 2021-11-02 | 2024-04-12 | 支付宝(杭州)信息技术有限公司 | Method and device for managing data |
CN114047876A (en) * | 2021-11-03 | 2022-02-15 | 河南星环众志信息科技有限公司 | Data sorting method and device based on columnar storage and storage medium |
CN114047876B (en) * | 2021-11-03 | 2022-11-18 | 河南星环众志信息科技有限公司 | Data sorting method and device based on columnar storage and storage medium |
CN116561073A (en) * | 2023-04-14 | 2023-08-08 | 云和恩墨(北京)信息技术有限公司 | File merging method and system based on database, equipment and storage medium |
CN116561073B (en) * | 2023-04-14 | 2023-12-19 | 云和恩墨(北京)信息技术有限公司 | File merging method and system based on database, equipment and storage medium |
Also Published As
Publication number | Publication date |
---|---|
US20210216517A1 (en) | 2021-07-15 |
WO2020055977A1 (en) | 2020-03-19 |
US11514014B2 (en) | 2022-11-29 |
EP3791283A1 (en) | 2021-03-17 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US11514014B2 (en) | Staggered merging in log-structured merge forests | |
Raju et al. | Pebblesdb: Building key-value stores using fragmented log-structured merge trees | |
Luo et al. | LSM-based storage techniques: a survey | |
US11556505B2 (en) | Policy driven data placement and information lifecycle management | |
US10162598B2 (en) | Flash optimized columnar data layout and data access algorithms for big data query engines | |
JP7410181B2 (en) | Hybrid indexing methods, systems, and programs | |
US9690799B2 (en) | Unified architecture for hybrid database storage using fragments | |
US9400816B1 (en) | System for indexing collections of structured objects that provides strong multiversioning semantics | |
US9009439B2 (en) | On-disk operations on fragments to support huge data sizes | |
US8595248B2 (en) | Querying a cascading index that avoids disk accesses | |
Ahn et al. | ForestDB: A fast key-value storage system for variable-length string keys | |
US9348833B2 (en) | Consolidation for updated/deleted records in old fragments | |
Yang et al. | F1 Lightning: HTAP as a Service | |
Zhang et al. | The hv-tree: a memory hierarchy aware version index | |
EP2778963A1 (en) | Assignment of data temperatures in a fragmented data set | |
Seidemann et al. | ChronicleDB: A high-performance event store | |
EP2778964B1 (en) | Hierarchical indices | |
US20210326320A1 (en) | Data segment storing in a database system | |
Wu et al. | Hm: A column-oriented mapreduce system on hybrid storage | |
Ravindran et al. | Data structures for big data stores | |
Raju | PebblesDB: building key-value stores using fragmented log-structured merge trees | |
Kim et al. | Vertically-partitioned parallel signature file method | |
Ahmed | Kite: A Scalable Microblogs Data Management System | |
Bößwetter | SPAX–PAX with Super-Pages | |
Kim | Effective Complex Data Retrieval Mechanism for Mobile Applications |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
SE01 | Entry into force of request for substantive examination |