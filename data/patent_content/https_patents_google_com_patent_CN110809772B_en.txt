CN110809772B - System and method for improving optimization of machine learning models - Google Patents
System and method for improving optimization of machine learning models Download PDFInfo
- Publication number
- CN110809772B CN110809772B CN201880044003.1A CN201880044003A CN110809772B CN 110809772 B CN110809772 B CN 110809772B CN 201880044003 A CN201880044003 A CN 201880044003A CN 110809772 B CN110809772 B CN 110809772B
- Authority
- CN
- China
- Prior art keywords
- computer
- computing devices
- machine learning
- training
- batch
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active
Links
- 238000000034 method Methods 0.000 title claims abstract description 91
- 238000010801 machine learning Methods 0.000 title claims abstract description 53
- 238000005457 optimization Methods 0.000 title abstract description 26
- 238000012549 training Methods 0.000 claims abstract description 82
- 239000011159 matrix material Substances 0.000 claims description 32
- 238000013528 artificial neural network Methods 0.000 claims description 24
- 230000006870 function Effects 0.000 claims description 23
- 238000011156 evaluation Methods 0.000 claims description 10
- 238000013527 convolutional neural network Methods 0.000 claims description 3
- 230000007717 exclusion Effects 0.000 claims description 2
- 238000004422 calculation algorithm Methods 0.000 abstract description 40
- 238000002474 experimental method Methods 0.000 description 13
- 230000015654 memory Effects 0.000 description 13
- 239000008186 active pharmaceutical agent Substances 0.000 description 7
- 238000010586 diagram Methods 0.000 description 6
- ORILYTVJVMAKLC-UHFFFAOYSA-N Adamantane Natural products C1C(C2)CC3CC1CC2C3 ORILYTVJVMAKLC-UHFFFAOYSA-N 0.000 description 5
- 230000008901 benefit Effects 0.000 description 5
- 238000004891 communication Methods 0.000 description 5
- 230000000694 effects Effects 0.000 description 5
- 230000006872 improvement Effects 0.000 description 5
- 238000012986 modification Methods 0.000 description 5
- 230000004048 modification Effects 0.000 description 5
- 238000012545 processing Methods 0.000 description 5
- 238000010200 validation analysis Methods 0.000 description 5
- 230000001133 acceleration Effects 0.000 description 4
- 230000007423 decrease Effects 0.000 description 4
- 230000008859 change Effects 0.000 description 3
- 230000010355 oscillation Effects 0.000 description 3
- 230000008569 process Effects 0.000 description 3
- 238000012795 verification Methods 0.000 description 3
- 238000007792 addition Methods 0.000 description 2
- 230000032683 aging Effects 0.000 description 2
- 238000013459 approach Methods 0.000 description 2
- 230000003247 decreasing effect Effects 0.000 description 2
- 230000003467 diminishing effect Effects 0.000 description 2
- 238000003909 pattern recognition Methods 0.000 description 2
- 230000000306 recurrent effect Effects 0.000 description 2
- 238000006467 substitution reaction Methods 0.000 description 2
- 238000012360 testing method Methods 0.000 description 2
- 101100153586 Caenorhabditis elegans top-1 gene Proteins 0.000 description 1
- 101100370075 Mus musculus Top1 gene Proteins 0.000 description 1
- 235000009499 Vanilla fragrans Nutrition 0.000 description 1
- 244000263375 Vanilla tahitensis Species 0.000 description 1
- 235000012036 Vanilla tahitensis Nutrition 0.000 description 1
- 238000002679 ablation Methods 0.000 description 1
- 238000004458 analytical method Methods 0.000 description 1
- 230000006399 behavior Effects 0.000 description 1
- 238000004364 calculation method Methods 0.000 description 1
- 230000015556 catabolic process Effects 0.000 description 1
- 239000003795 chemical substances by application Substances 0.000 description 1
- 238000013145 classification model Methods 0.000 description 1
- 238000013135 deep learning Methods 0.000 description 1
- 238000006731 degradation reaction Methods 0.000 description 1
- 238000000280 densification Methods 0.000 description 1
- 238000006073 displacement reaction Methods 0.000 description 1
- 238000005516 engineering process Methods 0.000 description 1
- 238000013100 final test Methods 0.000 description 1
- 230000008014 freezing Effects 0.000 description 1
- 238000007710 freezing Methods 0.000 description 1
- 238000010348 incorporation Methods 0.000 description 1
- 230000003993 interaction Effects 0.000 description 1
- 230000007787 long-term memory Effects 0.000 description 1
- 238000013507 mapping Methods 0.000 description 1
- 238000010606 normalization Methods 0.000 description 1
- 230000003287 optical effect Effects 0.000 description 1
- 230000007170 pathology Effects 0.000 description 1
- 238000012552 review Methods 0.000 description 1
- 230000006403 short-term memory Effects 0.000 description 1
- 230000001360 synchronised effect Effects 0.000 description 1
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/047—Probabilistic or stochastic networks
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
- G06N3/084—Backpropagation, e.g. using gradient descent
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F17/00—Digital computing or data processing equipment or methods, specially adapted for specific functions
- G06F17/10—Complex mathematical operations
- G06F17/16—Matrix or vector computation, e.g. matrix-matrix or matrix-vector multiplication, matrix factorization
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N20/00—Machine learning
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/045—Combinations of networks
Abstract
In general, the present disclosure relates to systems and methods for improving optimization of machine learning models. In particular, the present disclosure provides a random optimization algorithm that is faster than widely used algorithms for fixed computational volumes, and that can also scale significantly better as more computational resources become available. Random optimization algorithms can be used with large batch sizes. As an example, in some embodiments, the systems and methods of the present disclosure may implicitly calculate the inverse Hessian for each small batch of training data to produce a descent direction.
Description
Technical Field
The present disclosure relates generally to machine learning. More specifically, the present disclosure relates to systems and methods for improving optimization of machine learning models (such as, for example, deep neural networks).
Background
The progress of machine learning (e.g., deep learning) is slowed by the number of days or weeks required to train a large model. Natural solutions that use more hardware are limited by diminishing returns and result in inefficient use of additional resources.
The current state of training deep neural networks is that simple small-batch (mini-batch) optimizers such as random gradient descent (stochastic gradient descent, SGD) and momentum optimizers, as well as diagonal natural gradient methods are most used in practice. As distributed computing availability increases, the total real time (wall-time) of training large models has become a substantial bottleneck, and methods to reduce the total real time without sacrificing model generalization are of great value.
In the simplest version of a small batch SGD, an average gradient is calculated for a small set of examples and steps are taken toward a negative gradient direction. The convergence of the original SGD algorithm has two conditions, one of which depends on the variance of the gradient estimate. In practice, however, reducing variance by increasing the batch size generally results in acceleration that is linear (sub-linear) with the batch size, as well as reduced generalization capability.
Disclosure of Invention
Aspects and advantages of embodiments of the disclosure will be set forth in part in the description which follows, or may be learned from the description, or may be learned by practice of the embodiments.
One example aspect of the present disclosure is directed to a computer-implemented method. The method includes accessing, by one or more computing devices, a batch of training examples. The method includes inputting, by one or more computing devices, the batch training examples into a machine learning model to obtain a plurality of predictions. The machine learning model includes a plurality of parameters. The method includes determining, by the one or more computing devices, a direction of decline of an objective function using a power series expansion of an approximate inverse (approximate inverse) of the Hessian matrix, the objective function evaluating a plurality of predictions relative to a plurality of targets. The method includes updating, by the one or more computing devices, one or more values of the plurality of parameters based at least in part on the determined direction of descent.
In some implementations, determining, by the one or more computing devices, the direction of descent using a power series expansion of an approximate inverse of the Hessian matrix includes determining, by the one or more computing devices, the direction of descent using a Neumann series expansion of the approximate inverse of the Hessian matrix.
In some implementations, determining, by the one or more computing devices, the direction of descent using a power series expansion of an approximate inverse of the Hessian matrix includes iteratively updating Neumann iterations for each training example included in the set of training examples.
In some implementations, the power series expansion using the approximate inverse of the Hessian matrix by the one or more computing devices includes the power series expansion using only the approximate inverse of the Hessian matrix for the batch by the one or more computing devices.
In some implementations, determining, by the one or more computing devices, the direction of descent using a power series expansion of an approximate inverse of the Hessian matrix includes performing, by the one or more computing devices, an inner loop iteration that applies the approximate inverse of the Hessian matrix without explicitly representing the Hessian or calculating a Hessian vector product.
In some implementations, the objective function includes one or both of a triple regularization term (cubic regularizer) and a repulsive regularization term (repulsive regularizer).
In some implementations, determining, by the one or more computing devices, the direction of descent using a power series expansion of an approximate inverse of the Hessian matrix includes determining, by the one or more computing devices, a gradient at an alternate point that is different from a current point at which one or more values of the plurality of parameters are currently located.
In some implementations, determining, by the one or more computing devices, the direction of descent using a power series expansion of an approximate inverse of the Hessian matrix includes solving, by the one or more computing devices, the linear system using the power series expansion.
In some embodiments, the method further comprises: the accessing, inputting, using, and updating are performed for each of the additional training examples of the plurality of additional batches.
In some embodiments, the method further comprises: multiple iterations of random gradient descent are performed on the machine learning model prior to inputting the batch training example into the machine learning model.
In some implementations, the machine learning model includes a neural network.
Another example aspect of the present disclosure is directed to a computer-implemented method. The method includes one or more training iterations. For each of the one or more training iterations, the following steps are performed. The method includes obtaining, by one or more computing devices, the batch training example. The method includes inputting, by one or more computing devices, the batch of training examples into a machine learning model to obtain a plurality of predictions. The machine learning model includes a plurality of parameters. The method includes determining, by one or more computing devices, a derivative of an objective function that evaluates a plurality of predictions relative to a plurality of targets. The method includes determining, by the one or more computing devices, an update based at least in part on a derivative of the objective function. The method includes updating, by the one or more computing devices, the power series iteration based at least in part on the updating. The method includes updating, by the one or more computing devices, one or more values of the plurality of parameters based at least in part on the updated power series iterations.
In some implementations, the power series iteration is a Neumann iteration.
In some implementations, the method further includes updating, by the one or more computing devices, the moving average of the plurality of parameters based at least in part on the updated values of the plurality of parameters.
In some implementations, determining, by the one or more computing devices, the update based at least in part on the derivative of the objective function includes determining, by the one or more computing devices, the update based at least in part on the derivative of the objective function and based at least in part on the one or more regularization terms.
In some implementations, the one or more regularization terms include one or both of a triple regularization term and a exclusion regularization term.
In some implementations, determining, by the one or more computing devices, the update based at least in part on the derivative of the objective function includes determining, by the one or more computing devices, the update based at least in part on the derivative of the objective function and based at least in part on a moving average of the plurality of parameters.
In some implementations, updating, by the one or more computing devices, the power series iteration based at least in part on the updating includes setting, by the one or more computing devices, the power series iteration equal to: the previous iteration power series iteration times the momentum parameter minus the update times the learning rate parameter.
In some implementations, updating, by the one or more computing devices, the one or more values of the plurality of parameters includes setting, by the one or more computing devices, the values of the plurality of parameters equal to: the previous iteration set of values plus the updated power series iteration times the momentum parameter minus the update times the learning rate parameter.
In some implementations, the method further includes returning, by the one or more computing devices, a final set of values for the plurality of parameters.
In some implementations, the final set of values for the plurality of parameters is equal to the most recent updated set of values for the plurality of parameters minus the most recent power series iteration times the momentum parameter.
In some implementations, the method can further include periodically resetting, by the one or more computing devices, the power series iteration values.
In some implementations, the machine learning model includes a neural network.
In some implementations, the batch training examples include more than 16000 training examples.
In some implementations, the batch training examples include at least 32000 training examples.
Another example aspect of the disclosure relates to a computer system comprising one or more processors and one or more non-transitory computer-readable media collectively storing instructions that, when executed by the one or more processors, cause the computer system to perform one or more methods described herein.
Another example aspect of the disclosure is directed to one or more non-transitory computer-readable media collectively storing instructions that, when executed by one or more processors, cause a computer system to perform one or more methods described herein.
Other aspects of the disclosure are directed to various systems, apparatuses, non-transitory computer-readable media, user interfaces, and electronic devices.
These and other features, aspects, and advantages of various embodiments of the present disclosure will become better understood with reference to the following description and appended claims. The accompanying drawings, which are incorporated in and constitute a part of this specification, illustrate exemplary embodiments of the disclosure and together with the description, serve to explain the principles of interest.
Drawings
A detailed discussion of embodiments directed to one of ordinary skill in the art is set forth in the specification in view of the accompanying drawings, wherein:
1A-1B depict example training and evaluation curves for acceptance V3, according to example embodiments of the present disclosure.
Fig. 2A-2C depict example comparisons of a Neumann optimizer with a manual adjustment optimizer on different image network (ImageNet) models according to example embodiments of the present disclosure.
Fig. 3A-3B depict example scaling characteristics of a Neumann optimizer relative to an SGD having momentum, according to an example embodiment of the present disclosure.
Fig. 4A depicts a block diagram of an example computing system, according to an example embodiment of the present disclosure.
Fig. 4B depicts a block diagram of an example computing device, according to an example embodiment of the present disclosure.
Fig. 4C depicts a block diagram of an example computing device, according to an example embodiment of the present disclosure.
FIG. 5 depicts a flowchart of an example method of training a machine learning model, according to an example embodiment of the present disclosure.
FIG. 6 depicts a flowchart of an example method of training a machine learning model, according to an example embodiment of the present disclosure.
FIG. 7 depicts a flowchart of an example method of training a machine learning model in accordance with an example embodiment of the present disclosure.
Repeated reference characters in the drawings are intended to represent like features in different embodiments.
Detailed Description
1. Summary of the invention
In general, the present disclosure relates to systems and methods for improving optimization of machine learning models. In particular, the present disclosure provides a random optimization algorithm that is faster than widely used algorithms for fixed computational volumes, and that can also scale significantly better as more computational resources become available. Random optimization algorithms can be used with large batch sizes. As an example, in some embodiments, the systems and methods of the present disclosure may implicitly calculate the inverse Hessian for each small batch of training data to produce a descent direction. This can be done without explicit approximation of the Hessian or Hessian vector product. Example experiments are provided that demonstrate the effectiveness of example embodiments of the algorithms described herein by successfully training large image mesh models (e.g., acceptance-V3, resnet-50, resnet-101, and acceptance-Resnet-V2) using small batch sizes of up to 32000, with no loss of validation error relative to the current baseline and no increase in the total number of steps. With smaller small lot sizes, the systems and methods of the present disclosure improve the validation errors in these models by 0.8-0.9%. Alternatively, this accuracy may be weighed (tracked off) to reduce the number of training steps required by about 10-30%. The systems and methods described herein are practical and readily used by others. In some embodiments, only one hyper-parameter (e.g., learning rate) needs to be adjusted. Furthermore, in some embodiments, the algorithms described herein are as computationally inexpensive as conventional Adam optimizers. Thus, the systems and methods of the present disclosure provide a number of technical effects and benefits, including faster training and/or improved model performance. In other words, fewer computing resources may be used to train the model, thereby saving computing resources such as processing power, memory space, and the like.
More specifically, training the current state of deep neural networks is that simple small-batch optimizers such as random gradient descent (SGD) and momentum optimizers, as well as diagonal natural gradient methods are most used in practice. As distributed computing availability increases, the total real time of training a large model has become a substantial bottleneck, and methods to reduce the total real time without sacrificing model generalization are very valuable.
In the simplest version of a small batch SGD, the average loss gradient is calculated for a small set of examples and steps are taken toward the negative gradient direction. The convergence of the original SGD algorithm has two conditions, one of which depends on the variance of the gradient estimate. In practice, decreasing variance by increasing the batch size is affected by diminishing returns, which typically results in a linear acceleration of the batch size, and worse yet, a generalization performance decline.
The present disclosure provides systems and methods that, in some embodiments, solve training problems with reduced real time via novel stochastic optimization algorithms that use second order information (e.g., limited second order information) without explicit approximation of the Hessian matrix or even Hessian vector products. In some embodiments, for each small lot, the systems and methods of the present disclosure may calculate the descent direction by solving an intermediate optimization problem and inverting the Hessian for the small lot.
Explicit computation with the Hessian matrix is extremely expensive. Accordingly, the present disclosure provides an inner loop iteration that applies the Hessian inverse without explicitly representing the Hessian or calculating the Hessian vector product. In some embodiments, one key aspect of such an iteration is the Neumann series expansion of the matrix inverse and the observation that allows each occurrence of Hessian to be replaced by a single gradient evaluation.
Extensive experiments were performed on image network datasets using real models (e.g., acceptance-V3, resnet-50, resnet-101, acceptance-Resnet-V2). The results of these example experiments are provided herein.
Example embodiments of the systems and methods described herein have advantageous scaling characteristics compared to recent work. Linear acceleration of batch sizes up to 32000 can be obtained while maintaining or even improving the quality of the model compared to baseline. Furthermore, example embodiments of the present disclosure are able to improve validation errors in all test models by 0.8-0.9% when using smaller small lot runs. Alternatively, the baseline model quality may be maintained while reducing the number of steps by 10-30%.
Accordingly, the present disclosure provides an optimization algorithm (e.g., a bulk optimization algorithm) for training a machine learning model (e.g., a deep neural network). Roughly described, in some embodiments, the systems and methods of the present disclosure implicitly invert a single small batch of hessians. Some example algorithms described herein are practical at high speed, and in some embodiments, the only hyper-parameter that needs to be adjusted is the learning rate. Experiments have shown that example embodiments of the optimizer are able to handle very large small batch sizes of up to 32000 without any degradation in quality relative to the current model trained to converge. Interestingly, at smaller small lot sizes, the example implementation of the optimizer can produce a better generalized model and improve the validation error of the first name (top-1) in various architectures by 0.8-0.9% without a consequent drop in classification loss.
Example embodiments of the present disclosure will be discussed in further detail.
2. Example algorithm
Order theIs an input to a machine learning model, such as having some weight +.>Is a neural network g (x, w): the neural network is trained to learn targets for prediction, which may be discrete or continuous +.>Can be reduced by minimizing the loss function->To train the network to do this, where x is extracted from the data distribution and l is the per sample loss function. Therefore, the objective is to solve the optimization problem
If the true data distribution is not known (which often happens in practice), the expected loss will be replaced by an empirical loss. Given N training sample sets { (x) 1 ,y 1 ),(x 2 ,y 2 ),…,(x N ,y N ) Let f i (w)＝l(y i ,g(x i W) is a specific sample x i Is a loss of (2). The problem of the solution is
Consider point w t Surrounding ofIs a regularized first order approximation of (a):
minimization ofRule causing familiar gradient descent, +.>If the loss function is convex, it can be substituted for a local quadratic approximation of the calculated loss
Wherein,is empirically lost (positive) Hessian. Minimize->Give Newton update rulesThis includes solving a linear system:
one example algorithm provided by the present disclosure works as follows: for each small lot, a separate secondary sub-problem is formed as in equation (2). These sub-problems can be solved using the iterative scheme described in section 2.1. Unfortunately, simple application of this iterative scheme requires a Hessian matrix; section 2.2 shows how this challenge is avoided. Practical modifications to the algorithm are described in section 3.
2.1Neumann series
There are many ways in which the linear system of equation (3) can be solved. Explicit representation of the Hessian matrix is extremely expensive; thus, the first attempt might be to use the Hessian vector product instead. Such a strategy may apply conjugate gradients or Lanczos type iterations using Hessian vector products efficiently computed via the pearlmaster technique to directly minimize the quadratic form. In preliminary experiments with this idea, the cost of the Hessian vector product overwhelms any improvement from a better descent direction. Thus, aspects of the present disclosure take an even more indirect approach, even avoiding the Hessian vector product.
The core of some example methods described herein is the power series expansion that is used to solve the approximate inverse of a linear system. Specifically, aspects of the present disclosure use the Neumann power series of matrix inversion-given a matrix a whose eigenvalues λ (a) satisfy 0< λ (a) <1, the inversion is given by:
variable substitution (substitution) r= (I) n -A), which is a geometric series (1-r) -1 ＝1+r+r 2 + …. Using this, the linear system az=b can be solved via a recursive relation
z 0 ＝b，z t+1 ＝(I n -A)z t +b， (4)
Wherein z can be easily shown t →A -1 b. This is the richaadson iteration (Varga, richard s.matrix iterative analysis, volume 27.Springer Science &Business Media 2009) and corresponds to a gradient drop on the secondary target.
2.2 Secondary approximation of small batches
The complete batch processing approach is impractical even for moderately large networks trained with moderate amounts of data. It is common practice to obtain an unbiased estimate of the loss by using small batches. Given a training set of size BIs made of small batches of
Is a function that is optimized in a specific step. Similar to equation (2), a small batch of random quadratic approximations can be formed as:
as before, the linear system can be solvedTo calculate the followingThe direction of descent, but now, linear systems are only on small batches. For this purpose, the Neumann series in equation (4) may be used. Assuming that Hessian is positive (section 3.1 shows the assumption of how positive is removed), and has an operator norm boundary +.>Setting eta<1/λ max By adding->z t ＝m t And->Substituting into equation (4) to define Neumann iteration m t ：
The rationality of the above-described decreasing order is demonstrated by the following observations: the bold term of the second row is for a sufficiently small ||ηm via a taylor series t II pairIs a first order approximation of (a):
this idea of gradient transport is one of the novel contributions of the present disclosure, using the second order information in a practical way for optimization. By using only first order information at points that are not current weights, curvature information can be incorporated in a matrix-free manner. This approximation is the main reason for using a slowly converging Neumann series-it allows extremely inexpensive incorporation of second order information. An idealized Neumann algorithm is exemplified as follows:
Example algorithm 1 idealized Two-cycle (Two-Loop) Neumann optimizer
In some embodiments, two different learning rates, an inner loop learning rate and an outer loop learning rate, may be used instead of the single learning rate shown in algorithm 1.
The actual solution of equation (6) will be discussed further below. However, in view of the above description, the differences between the techniques described herein and a typical random quasi-Newton (quasi-Newton) algorithm are as follows: in an idealized random Newton-like algorithm, one would like to have Hessian for the total lossApproximation is performed and then inverted to obtain the descent direction +.>On the other hand, aspects of the present disclosure are satisfied by approximating Hessian only for small batches to obtain the direction of descent +.>These two quantities are radically different, even in anticipation, because the presence of batches in both the Hessian and gradient estimates results in no consideration of the (factor) product. One can consider that the random Newton-like algorithm tries to find the optimal descent direction by using the second order information about the total target, while some of the algorithms described herein try to find the descent direction by using small batches of implicit second order information. While it is well understood in the literature that it is not desirable to attempt to use curvature information based on small batches, it is reasonable to justify the method by noting that curvature information comes only from gradient evaluations, and in large batch settings, gradients have better concentration characteristics than Hessian.
Two loop structures are used in this document, such as the loop structures contained in algorithm 1. However, one typically solves a difficult convex optimization problem in the internal loop. In contrast, algorithm 1 solves for a simpler linear system in the inner loop.
Here, instead of using standard assumptions on smoothness and strong convexity to derive convergence speed, the present disclosure goes to the problem of constructing an optimizer suitable for large-scale deep neural networks that is defined worse.
3. Example optimizer for machine learning model such as neural network
Some practical problems associated with the Neumann optimizer are:
1. it is assumed that the expected Hessian is positive, and further, that the Hessian for each small lot is also positive.
2. There are a number of super-parameters that significantly affect the optimization learning, including rate(s), internal loop iteration, and batch size.
Two separate techniques for highlighting the problem will be introduced-one for total Hessian and one for small batches of Hessian, and the number of superparameters will be reduced to only the learning rate.
3.1 convexity
In deterministic settings, non-convexity in a target can be handled by three regularization: adding regularization term in objective function Where α is a scalar (scaler) hyper-parameter weight. It has been shown that under mild assumptions, the gradient dip on the regularized target converges to a second order fixed point (i.e., theorem 3.1). The triple regularization method belongs to a broad class of trust zone methods. This term is critical to theoretically ensuring convergence to the critical point.
In some implementations, the present disclosure adds two regularization terms-a triple regularization term to the targetAnd repulsive force regularization term beta/|w-v t II, where v t Is the exponential shift level of the parameter in the optimization processAnd (5) an average value. These two items are attractive to each other—the three items are attractive and prevent a large update to the parameters, especially when the learning rate is high (in the initial part of the training), while the second item adds repulsive forces and starts to dominate when the learning rate becomes small (at the end of the training). Regularization target is +.>And its gradient is
Even if the expected Hessian is positive, this does not mean that individual batches of Hessian are positive themselves. This creates great difficulty because the intermediate quadratic form becomes unbounded and has any minimum in the subspace span of negative eigenvalues. Assume that the eigenvalues of Hessian Satisfy->The coefficients are defined as follows:
and->
In this case, the matrixIs a positive definite matrix. If the matrix is used in the inner loop to replace +.>One can obtain an update to the descent direction:
matrix is not yet clearWill yield a good a priori for the direction of descent, but if |lambda min Ratio lambda max Smaller, the perturbation does not affect the Hessian beyond a simple scaling. This is the case in later training, but in order to verify this, an experiment was performed in which a very small batch of Hessian eigenvalues were calculated using Lanczos algorithm. On the training trajectory, the following qualitative behavior occurs: initially, there are many large negative eigenvalues; during the optimization process, these large negative eigenvalues decrease in magnitude toward zero; meanwhile, during the optimization process, the maximum positive eigenvalue is continuously increased (almost linearly increased).
This validates the small batch densification routine. In principle, the triple regularization term is superfluous—if each small lot is convex, the entire problem is also convex. But due to lambda min And lambda (lambda) max Only roughly estimated, so the triple regularization term ensures convexity without applying toThe Hessian in (c) produces excessive distortion. Based on findings in experimental studies, the following settings were used: And η.gt1/t.
3.2 run optimizer: SGD aging (Burn) and internal loop iteration
Some example adjustments to the idealized Neumann algorithm are now presented to improve the performance and stability of the training. As a first variation, a very short phase of naive SGD (vanilla SGD) is performed at the beginning. SGDs are generally more robust to initialized pathology (path) than other optimization algorithms.
Next, there is an open question as to how many internal loop iterations are needed. Experiments have led to experience that the marginal benefit of reusing small batches returns is significantly reduced. Depth networks have on the order of millions of parameters and even the largest small batch sizes are often less than fifty thousand examples. Thus, one cannot wish to rely on very fine-grained information from each small lot. From an efficiency point of view, the number of inner loop iterations should be kept relatively low; on the other hand, this results in the algorithm degenerating into an SGD-form (SGD-request) iteration, wherein the inner loop falls in direction m t Never really useful.
The problem can be solved as follows: instead of freezing a small batch and then calculating the gradient with respect to the small batch in each iteration of the inner loop, we calculate a random gradient in each iteration of the inner loop. One can consider this to be solving a stochastic optimization sub-problem in the inner loop, rather than a deterministic optimization problem. This small change is effective in practice and also eliminates the need to carefully select the number of inner loop iterations-instead of having to carefully balance the considerations of optimizing quality in the inner loop and the overfitting to a particular small batch, the optimizer now becomes relatively insensitive to the number of inner loop iterations. The doubling schedule (doubling schedule) was chosen for the experiment, but the linear schedule (e.g., as presented by algorithm 2) works equally well. In addition, since the inner and outer loop updates are now the same, a single learning rate η may be applied (rather than using two different rates for the inner and outer loops instead).
Finally, there is a problem of how to set a small batch size for the algorithm. Since one goal is to extract the second order information from a small batch, one possible explanation is that the Neumann optimizer is better suited for large batch settings, and the small batch size should be as large as possible. Section 4 provides experimental evidence for this assumption.
Example algorithm 2Neumann optimizer.
Learning rate eta (t), cubic regularization term alpha, repulsive regularization term beta, momentum mu (t), moving average parameter gamma and internal loop iteration K
As a simplification of the implementation, in some implementations, w is maintained in algorithm 2 t In effect, the displacement parameter (displaced parameters) (w) t +μm t ). This slight sign change then allows us to "flatten" (flat) the two loop structure without changing the underlying iterations. In table 1, an example hyper-parameter list applicable to various models is compiled (all experiments we performed on both large and small models use these values): the only choice that the user needs to select is the learning rate.
Table 1: overview of superparameter.
4. Example experiment
The optimizer performs experimental evaluations on several large convolutional neural networks for image classification. While experiments on smaller datasets (CIFS-10 and CIFS-100) were successful without any hyper-parameter modification, the results were reported only for the image network datasets.
Experiments were run in Tensorflow on Tesla P100 GPU in a distributed infrastructure. To abstract the variability inherent in distributed systems (such as network traffic, workload, preemption, etc.), training rounds are used as a concept of time. Since the same calculation amount and memory amount are used as Adam optimizer (Diederik Kingma and Jimmy ba: adam: A method for stochastic optimization. International Conference for Learning Representations, 2015), the step time (step time) is comparable to the usual optimizer. Standard enhancement of acceptance data (Szegedy et al, acceptance-v 4, acceptance-resnet and the impact of residual connections on learning.in AAAI, pp.4278-4284,2017) was used for all models. The input image sizes used by the acceptance-V3 and acceptance-Resnet-V2 models are 299 by 299, and the input image sizes used by all Resnet models are 224 by 224. The evaluation index is measured using a single crop (crop).
The Neumann optimizer appears to be robust to different initializations and trajectories. In particular, the final evaluation index is stable and does not change significantly in each run (run to run), so results from a single run are presented throughout the experimental results section.
4.1 fixed small batch size: better accuracy or faster training
First, the Neumann optimizer is compared to a standard optimization algorithm of fixed small batch size. To this end, for baseline, the Incept-V3 model (Szegedy et al Rethinking the Inception architecture for computer vision in Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pp.2818-2826,2016), a Resnet-50 and Resnet-101 (He et al Deep residual learning for image receptions. In Proceedings of the IEEE conference on computer vision and pattern recognition, pp.770-778,2016a and He et al Identity mappings in deep residual works. In European Conference on Computer Vision, pp.630-645.Springer,2016 b), and finally the Incept-Resnet-V2 (Szegedy et al, incept-V4, in Resnet and the impact of residual connections on learning. InAAAI, pp.4278-4284,2017) were trained. The RMSProp optimizer is used in a synchronized manner, with the addition of small batch sizes (from 32) to 64 to accommodate modern hardware to train the acceptance-V3 and acceptance-Resnet-V2 models as in their respective papers. The Resnet-50 and Resnet-101 models were trained in an asynchronous manner with a small batch size of 32 using an SGD with momentum of 0.9 and a learning rate of 0.045 (the learning rate decays by a factor of 0.94 every two rounds). In all cases, 50 GPUs were used. When training synchronously, the learning rate scales linearly after an initial aging period of 5 rounds, during which we slowly increase the learning rate and decay by a factor of 0.3 every 40 rounds (this is in contrast to asynchronously set up The schedule is similar because of 0.94 20 0.3). In addition, adam was run for comparison with popular baseline algorithms.
Table 2: final first name verification error
The optimizer evaluates based on the final test accuracy (first name verification error) and the number of rounds needed to achieve a fixed accuracy. FIGS. 1A-1B provide training curves and test errors for the indication V3 as compared to the baseline RMSProp.
Some of the salient features are as follows: first, the classification loss (sum of the main cross entropy loss and the auxiliary head loss (auxiliary head loss)) is not improved, and second, there is oscillation early in training, which is also shown in the evaluation. The oscillations are quite disturbing and they are assumed to originate from slight irregularities of the hyper-parameter μ, but all trained models appear to be robust to these oscillations. The lack of improvement in classification loss is interesting, especially because the evaluation error is improved by small increments of 0.8-0.9%. This improvement was consistent across all our models (see table 2 and figures 2A-2C). Fig. 2A-2C provide example graphs comparing Neumann optimizers and manual adjustment optimizers across different image mesh models. When changing from a well-tuned optimizer, it is unusual to obtain such quality improvement.
This generalization improvement can also be weighed for faster training: if one is satisfied with obtaining the previous baseline validation error, one can simply run the Neumann optimizer for fewer steps. This produces an acceleration of 10-30% while maintaining the current baseline accuracy.
Adam showed poor performance compared to both Neumann optimizers and RMSProp on these large scale image classification models. This reflects an understanding that the architecture and algorithm are tuned to each other for optimal performance. In the remainder of this section, the Neumann optimizer will only compare with RMSProp.
4.2 Linear scaling at very large batch sizes
Previously, it was assumed that the method described herein could be used effectively in large volumes. As shown in fig. 3B and table 3, this was investigated by training Resnet-50 (using the same learning rate schedule as section 4.1) on an increasingly larger batch. Each GPU may handle a small batch of 32 examples, so for example, a batch size of 8000 implies 250 GPUs. For batch sizes of 16000 and 32000, we use 250 graphics processors, each of which evaluates the model and its gradient multiple times before applying any updates.
Fig. 3A-3B provide example graphs illustrating the scaling characteristics of a Neumann optimizer relative to an SGD with momentum.
The Neumann optimizer algorithm can scale to very large small batches: up to 32000 small lot sizes, performance is still better than baseline. Thus, the Neumann optimizer is the new most advanced technique to take advantage of large, small batch sizes while maintaining model quality. It can utilize 4 times (4 x) larger small batches than Goyal et al (Accurate, large minibatch sgd: training imagenet in 1hour.arXiv preprint arXiv:1706.02677,2017.); it uses the same small lot size as You et al (Scaling sgd batch size to 32k for imagenet training.arXiv preprint arXiv:1708.03888,2017a and Imagenet training in 24minutes.arXiv preprint arXiv:1709.05011,2017b), but matches the baseline accuracy, while You et al experience a 0.4-0.7% drop.
Table 3: scaling performance of our optimizer on Resnet-50
4.3 effect of regularization
By performing an ablation experiment (setting α and β to 0), the effect of regularization was studied. The main findings are summarized in table 4. It can be seen that regularization improves the verification performance, but running just the Neumann optimizer improves performance even without regularization.
Table 4: effect of regularization-Resnet-50, batch size 4000
Method | First name error |
Base line | 24.3％ |
Neumann (without normalization) | 23.5％ |
Neumann (with regularization) | 23.0％ |
5. Example devices and systems
Fig. 4A depicts a block diagram of an example computing system 100 including a machine learning model, according to an example embodiment of the present disclosure. The system 100 includes a user computing device 102, a server computing system 130, and a training computing system 150 communicatively coupled by a network 180.
The user computing device 102 may be any type of computing device, such as, for example, a personal computing device (e.g., laptop or desktop), a mobile computing device (e.g., smart phone or tablet), a game console or controller, a wearable computing device, an embedded computing device, or any other type of computing device.
The user computing device 102 includes one or more processors 112 and memory 114. The one or more processors 112 may be any suitable processing device (e.g., a processor core, microprocessor, ASIC, FPGA, controller, microcontroller, etc.), and may be one processor or multiple processors operatively connected. Memory 114 may include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, and the like, and combinations thereof. Memory 114 may store data 116 and instructions 118 executed by processor 112 to cause user computing device 102 to perform operations.
The user computing device 102 may store or include one or more machine learning models 120. For example, the machine learning model 120 may be or otherwise include various machine learning models, such as a neural network (e.g., a deep neural network), other multi-layer nonlinear models, or other models. The neural network may include a recurrent neural network (e.g., a long and short term memory recurrent neural network), a feed-forward neural network, a convolutional neural network, or other form of neural network. Although the present disclosure is discussed with particular reference to neural networks, the present disclosure is applicable to all types of machine learning models, including but not limited to neural networks.
In some implementations, one or more machine learning models 120 may be received from the server computing system 130 over the network 180, stored in the user computing device memory 114, and used or otherwise implemented by the one or more processors 112. In some implementations, the user computing device 102 may implement multiple parallel instances of a single machine learning model 120.
Additionally or alternatively, one or more machine learning models 140 may be included in the server computing system 130 in communication with the user computing device 102 according to a client-server relationship, or otherwise stored and implemented by the server computing system 130. For example, the machine learning model 140 may be implemented by the server computing system 130 as part of a web service. Accordingly, one or more models 120 may be stored and implemented at the user computing device 102 and/or one or more models 140 may be stored and implemented at the server computing system 130.
The user computing device 102 may also include one or more user input components 122 that receive user input. For example, the user input component 122 may be a touch-sensitive component (e.g., a touch-sensitive display screen or touchpad) that is sensitive to touch by a user input object (e.g., a finger or stylus). The touch sensitive component may be used to implement a virtual keyboard. Other example user input components include a microphone, a conventional keyboard, or other device through which a user may input communications.
The server computing system 130 includes one or more processors 132 and memory 134. The one or more processors 132 may be any suitable processing device (e.g., a processor core, microprocessor, ASIC, FPGA, controller, microcontroller, etc.), and may be one processor or multiple processors operatively connected. Memory 134 may include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, and the like, and combinations thereof. Memory 134 may store instructions 138 and data 136 that are executed by processor 132 to cause server computing system 130 to perform operations.
In some implementations, the server computing system 130 includes or is otherwise implemented by one or more server computing devices. Where the server computing system 130 includes multiple server computing devices, such server computing devices may operate in accordance with a sequential computing architecture, a parallel computing architecture, or some combination thereof.
As described above, the server computing system 130 may store or otherwise include one or more machine learning models 140. For example, the model 140 may be or otherwise include various machine learning models, such as a neural network (e.g., deep neural network), other multi-layer nonlinear models, or other models.
The server computing system 130 may train the model 140 via interaction with a training computing system 150 communicatively coupled via a network 180. The training computing system 150 may be separate from the server computing system 130 or may be part of the server computing system 130.
The training computing system 150 includes one or more processors 152 and memory 154. The one or more processors 152 may be any suitable processing device (e.g., processor core, microprocessor, ASIC, FPGA, controller, microcontroller, etc.), and may be one processor or multiple processors operatively connected. The memory 154 may include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, and the like, and combinations thereof. The memory 154 may store instructions 158 and data 156 that are executed by the processor 152 to cause the training computing system 150 to perform operations. In some implementations, the training computing system 150 includes or is otherwise implemented by one or more server computing devices.
Training computing system 150 may include a model trainer 160, model trainer 160 training machine learning models 120 or 140 using various training or learning techniques (such as, for example, back propagation of errors). In some implementations, performing back-propagation of the error may include performing truncated back-propagation over time. Model trainer 160 may perform a variety of generalization techniques (e.g., weight decay, absence, etc.) to improve the generalization ability of the trained model.
Specifically, model trainer 160 may train machine learning model 120 or 140 based on training data set 162. Training data 162 may include, for example, a multi-batch training example. In some implementations, each training example can have a target answer associated with it.
In some implementations, the model trainer 160 may train the model 120 or 140 using the methods, techniques, and/or algorithms described herein (e.g., methods 200, 300, and/or 400, algorithms 1 and/or 2, etc.).
Model trainer 160 includes computer logic for providing the desired functionality. Model trainer 160 may be implemented in hardware, firmware, and/or software that controls a general purpose processor. For example, in some embodiments, model trainer 160 includes program files stored on a storage device, loaded into memory, and executed by one or more processors. In other embodiments, model trainer 160 includes one or more sets of computer-executable instructions stored in a tangible computer-readable storage medium, such as a RAM hard disk or an optical or magnetic medium. In some implementations, the model trainer (e.g., including performing the optimization techniques described herein) can be provided as a service as part of a larger machine learning platform that enables users to receive machine learning services.
The network 180 may be any type of communication network, such as a local area network (e.g., an intranet), a wide area network (e.g., the internet), or some combination thereof, and may include any number of wired or wireless links. In general, communications over network 180 may be carried via any type of wired and/or wireless connection using a variety of communication protocols (e.g., TCP/IP, HTTP, SMTP, FTP), coding or formats (e.g., HTML, XML), and/or protection schemes (e.g., VPN, secure HTTP, SSL).
FIG. 4A illustrates one example computing system that may be used to implement the present disclosure. Other computing systems may also be used. For example, in some implementations, the user computing device 102 may include a model trainer 160 and a training data set 162. In such implementations, the model 120 may be trained and used locally at the user computing device 102. In some of such implementations, the user computing device 102 may implement the model trainer 160 to personalize the model 120 based on user-specific data.
Fig. 4B depicts a block diagram of an example computing device 10, performed in accordance with an example embodiment of the present disclosure. Computing device 10 may be a user computing device or a server computing device.
Computing device 10 includes a plurality of applications (e.g., applications 1 through N). Each application contains its own machine learning library and machine learning model(s). For example, each application may include a machine learning model. Example applications include text messaging applications, email applications, dictation applications, virtual keyboard applications, browser applications, and the like
As shown in fig. 4B, each application may communicate with a number of other components of the computing device, such as one or more sensors, a context manager, a device state component, and/or additional components. In some implementations, each application can communicate with each device component using an API (e.g., public API). In some implementations, the APIs used by each application are application specific.
Fig. 4C depicts a block diagram of an example computing device 50, performed in accordance with an example embodiment of the present disclosure. Computing device 50 may be a user computing device or a server computing device.
Computing device 50 includes a plurality of applications (e.g., applications 1 through N). Each application communicates with a central intelligent layer. Example applications include text messaging applications, email applications, dictation applications, virtual keyboard applications, browser applications, and the like. In some implementations, each application can communicate with the central intelligence layer (and model(s) stored therein) using an API (e.g., a common API for all applications).
The central intelligence layer includes a plurality of machine learning models. For example, as shown in fig. 4C, a respective machine learning model (e.g., model) may be provided for each application and managed by a central intelligent agent. In other implementations, two or more applications may share a single machine learning model. For example, in some embodiments, the central intelligence layer may provide a single model (e.g., a single model) for all applications. In some implementations, the central intelligence layer is included within or otherwise implemented by the operating system of computing device 50.
The central intelligence layer may communicate with the central device data layer. The central device data layer may be a central data repository for computing device 50. As shown in fig. 4C, the central device data layer may communicate with a plurality of other components of the computing device, such as one or more sensors, a context manager, a device status component, and/or additional components. In some implementations, the central device data layer can communicate with each device component using an API (e.g., a dedicated API).
6. Example method
Fig. 5 depicts a flowchart of an example method performed in accordance with an example embodiment of the present disclosure. Although fig. 5 depicts steps performed in a particular order for purposes of illustration and discussion, the methods of the present disclosure are not limited to the particular order or arrangement shown. The various steps of method 200 may be omitted, rearranged, combined, and/or modified in various ways without departing from the scope of the present disclosure.
At 202, a computing system may access a batch of training examples.
At 204, the computing system may input the batch training example into a machine learning model to obtain a plurality of predictions. The machine learning model may include a plurality of parameters.
At 206, the computing system may determine a direction of decline of an objective function using a power series expansion of an approximate inverse of the Hessian matrix, wherein the objective function evaluates a plurality of predictions relative to a plurality of targets.
At 208, the computing system may update one or more values of the plurality of parameters based at least in part on the determined direction of descent.
Fig. 6 depicts a flowchart of an example method performed in accordance with an example embodiment of the present disclosure. Although fig. 6 depicts steps performed in a particular order for purposes of illustration and discussion, the methods of the present disclosure are not limited to the particular order or arrangement shown. The various steps of method 300 may be omitted, rearranged, combined, and/or modified in various ways without departing from the scope of the present disclosure.
At 302, a computing system accesses a batch of training examples.
At 304, the computing system determines the derivative of the objective function and sets the determined value to the initial power series iteration value.
At 306, the computing system obtains the next training example in the batch.
At 308, the computing system updates the power series iteration based at least in part on the derivative of the objective function at points other than the location where the parameters of the model are currently located. For example, in some embodiments, the computing system may incorporate curvature information in a matrix-free manner by using only first-order information at points that are not current parameter values.
At 310, the computing system determines whether additional training examples are included in the batch. If so, the method returns to 306. If no additional training examples remain in the batch, the method proceeds to 312.
At 312, the computing system updates the parameter values based at least in part on the final power series iteration values.
At 314, the computing system determines whether additional training example batches are available and/or desired. If so, the method returns to 302. If additional lots are not available and/or desired, the method proceeds to 316.
At 316, the computing system returns the final parameter values.
Fig. 7 depicts a flowchart of an example method performed in accordance with an example embodiment of the present disclosure. Although fig. 7 depicts steps performed in a particular order for purposes of illustration and discussion, the methods of the present disclosure are not limited to the particular order or arrangement shown. The various steps of method 400 may be omitted, rearranged, combined, and/or modified in various ways without departing from the scope of the present disclosure.
At 402, a computing system may access a batch of training examples.
At 404, the computing system may input the batch training example into a machine learning model to obtain a plurality of predictions. The machine learning model may include a plurality of parameters.
At 406, the computing system may determine a derivative of the objective function that evaluates a plurality of predictions relative to a plurality of targets.
At 408, the computing system may determine an update based at least in part on the derivative of the objective function.
At 410, the computing system can update the power series iteration based at least in part on the update.
At 412, the computing system can update one or more values of the plurality of parameters based at least in part on the updated power series iteration.
At 414, the computing system may update the moving average of the plurality of parameters based at least in part on the updated values of the plurality of parameters.
At 416, the computing system may determine whether additional training example batches are available and/or desired. If so, the method returns to 402. If additional lots are not available and/or desired, the method proceeds to 418.
At 418, the computing system returns a final set of parameters.
7. Additional disclosure
The technology discussed herein relates to servers, databases, software applications, and other computer-based systems, as well as actions taken and information sent to and received from such systems. The flexibility inherent in computer-based systems allows for a variety of possible configurations, combinations, and divisions of tasks and functions between components. For example, the processes discussed herein may be implemented using a single device or component or multiple devices or components working in combination. The database and applications may be implemented on a single system or may be distributed across multiple systems. Distributed components may run sequentially or in parallel.
While the present invention has been described in detail with respect to various specific example embodiments thereof, each example is provided by way of explanation and not limitation of the present disclosure. Modifications, variations and equivalents to these embodiments may readily occur to those skilled in the art upon review of the foregoing description. Accordingly, the subject disclosure does not preclude inclusion of such modifications, variations and/or additions to the present subject matter as would be readily apparent to one of ordinary skill in the art. For instance, features illustrated or described as part of one embodiment, can be used with another embodiment to yield a still further embodiment. Accordingly, the present disclosure is intended to cover such alternatives, modifications, and equivalents.
Claims (14)
1. A computer-implemented method, the method comprising:
accessing, by one or more computing devices, a batch of training examples of a current training iteration;
inputting, by one or more computing devices, the batch of training examples into a machine learning model to obtain a plurality of predictions, wherein the machine learning model includes a plurality of parameters that were determined after a previous training iteration;
determining, by the one or more computing devices, a direction of descent of an objective function using a Neumann series expansion of an approximate inverse of the Hessian matrix, the objective function evaluating a plurality of predictions with respect to a plurality of targets, including determining, by the one or more computing devices, a gradient at a surrogate point that is different from a current point at which one or more values of the plurality of parameters are currently located, wherein using the Neumann series expansion of the approximate inverse of the Hessian matrix includes replacing each occurrence of the Hessian matrix with a single gradient evaluation, the single gradient evaluation being a gradient evaluated at the surrogate point; and
Updating, by the one or more computing devices, one or more values of the plurality of parameters based at least in part on the determined direction of descent;
wherein the machine learning model is used for image classification, the machine learning model receives one or more images as input and generates a classification for each image.
2. The computer-implemented method of claim 1, wherein determining, by one or more computing devices, a direction of descent using a Neumann series expansion of an approximate inverse of the Hessian matrix comprises: the Neumann iteration for each training example included in the batch of training examples is iteratively updated.
3. The computer-implemented method of claim 1, wherein using, by one or more computing devices, a Neumann series expansion of an approximate inverse of the Hessian matrix comprises: only the Neumann series expansion of the approximate inverse of the Hessian matrix is used by the one or more computing devices for the batch.
4. The computer-implemented method of claim 1, wherein determining, by one or more computing devices, a direction of descent using a Neumann series expansion of an approximate inverse of the Hessian matrix comprises: an inner loop iteration is performed by one or more computing devices that applies an approximate inverse of the Hessian matrix without explicitly representing the Hessian or computing a Hessian vector product.
5. The computer-implemented method of claim 1, wherein the objective function comprises one or both of a triple regularization term and a exclusion regularization term.
6. The computer-implemented method of claim 1, wherein determining, by one or more computing devices, a direction of descent using a Neumann series expansion of an approximate inverse of the Hessian matrix comprises: the Neumann series expansion is used by one or more computing devices to solve a linear system.
7. The computer-implemented method of claim 1, further comprising:
the accessing, inputting, using, and updating are performed for each of the additional training examples of the plurality of additional batches.
8. The computer-implemented method of claim 1, further comprising:
a plurality of iterations of random gradient descent is performed on the machine learning model prior to inputting the batch of training examples into the machine learning model.
9. The computer-implemented method of claim 1, wherein the machine learning model comprises a neural network.
10. The computer-implemented method of claim 9, wherein the neural network is a convolutional neural network for image classification, the neural network receiving one or more images as input, and generating a classification for each image.
11. The computer-implemented method of claim 1, wherein the batch of training examples comprises more than 16000 training examples.
12. The computer-implemented method of claim 1, wherein the batch of training examples comprises at least 32000 training examples.
13. A computer system, comprising:
one or more processors; and
one or more non-transitory computer-readable media collectively storing instructions that, when executed by the one or more processors, cause the computer system to perform the method of any one of claims 1-12.
14. One or more non-transitory computer-readable media collectively storing instructions that, when executed by the one or more processors, cause a computer system to perform the method of any one of claims 1-12.
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201762578349P | 2017-10-27 | 2017-10-27 | |
US62/578,349 | 2017-10-27 | ||
PCT/US2018/041033 WO2019083578A1 (en) | 2017-10-27 | 2018-07-06 | Systems and methods for improved optimization of machine-learned models |
Publications (2)
Publication Number | Publication Date |
---|---|
CN110809772A CN110809772A (en) | 2020-02-18 |
CN110809772B true CN110809772B (en) | 2024-04-02 |
Family
ID=63036380
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN201880044003.1A Active CN110809772B (en) | 2017-10-27 | 2018-07-06 | System and method for improving optimization of machine learning models |
Country Status (4)
Country | Link |
---|---|
US (1) | US20200250515A1 (en) |
EP (1) | EP3616134A1 (en) |
CN (1) | CN110809772B (en) |
WO (1) | WO2019083578A1 (en) |
Families Citing this family (27)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
WO2018176000A1 (en) | 2017-03-23 | 2018-09-27 | DeepScale, Inc. | Data synthesis for autonomous control systems |
US10671349B2 (en) | 2017-07-24 | 2020-06-02 | Tesla, Inc. | Accelerated mathematical engine |
US11157441B2 (en) | 2017-07-24 | 2021-10-26 | Tesla, Inc. | Computational array microprocessor system using non-consecutive data formatting |
US11409692B2 (en) | 2017-07-24 | 2022-08-09 | Tesla, Inc. | Vector computational unit |
US11893393B2 (en) | 2017-07-24 | 2024-02-06 | Tesla, Inc. | Computational array microprocessor system with hardware arbiter managing memory requests |
US11561791B2 (en) | 2018-02-01 | 2023-01-24 | Tesla, Inc. | Vector computational unit receiving data elements in parallel from a last row of a computational array |
US11215999B2 (en) | 2018-06-20 | 2022-01-04 | Tesla, Inc. | Data pipeline and deep learning system for autonomous driving |
US11361457B2 (en) | 2018-07-20 | 2022-06-14 | Tesla, Inc. | Annotation cross-labeling for autonomous control systems |
US11636333B2 (en) | 2018-07-26 | 2023-04-25 | Tesla, Inc. | Optimizing neural network structures for embedded systems |
US11562231B2 (en) | 2018-09-03 | 2023-01-24 | Tesla, Inc. | Neural networks for embedded devices |
CN115512173A (en) | 2018-10-11 | 2022-12-23 | 特斯拉公司 | System and method for training machine models using augmented data |
US11196678B2 (en) | 2018-10-25 | 2021-12-07 | Tesla, Inc. | QOS manager for system on a chip communications |
US11816585B2 (en) | 2018-12-03 | 2023-11-14 | Tesla, Inc. | Machine learning models operating at different frequencies for autonomous vehicles |
US11537811B2 (en) | 2018-12-04 | 2022-12-27 | Tesla, Inc. | Enhanced object detection for autonomous vehicles based on field view |
US11610117B2 (en) | 2018-12-27 | 2023-03-21 | Tesla, Inc. | System and method for adapting a neural network model on a hardware platform |
US10997461B2 (en) | 2019-02-01 | 2021-05-04 | Tesla, Inc. | Generating ground truth for machine learning from time series elements |
US11567514B2 (en) | 2019-02-11 | 2023-01-31 | Tesla, Inc. | Autonomous and user controlled vehicle summon to a target |
US10956755B2 (en) | 2019-02-19 | 2021-03-23 | Tesla, Inc. | Estimating object properties using visual image data |
US11657118B2 (en) * | 2019-05-23 | 2023-05-23 | Google Llc | Systems and methods for learning effective loss functions efficiently |
JP7116711B2 (en) * | 2019-06-14 | 2022-08-10 | 株式会社東芝 | Information processing device, information processing method, and computer program |
US11521254B2 (en) * | 2019-08-08 | 2022-12-06 | Ebay Inc. | Automatic tuning of machine learning parameters for non-stationary e-commerce data |
US11922316B2 (en) * | 2019-10-15 | 2024-03-05 | Lg Electronics Inc. | Training a neural network using periodic sampling over model weights |
US11348036B1 (en) | 2020-12-01 | 2022-05-31 | OctoML, Inc. | Optimizing machine learning models with a device farm |
CN112688809B (en) * | 2020-12-21 | 2023-10-03 | 声耕智能科技(西安)研究院有限公司 | Diffusion self-adaptive network learning method, system, terminal and storage medium |
CN113837260A (en) * | 2021-09-17 | 2021-12-24 | 北京百度网讯科技有限公司 | Model training method, object matching method, device and electronic equipment |
CN114325777B (en) * | 2021-11-11 | 2023-10-13 | 中航机载系统共性技术有限公司 | Cycle slip detection and repair method, device and equipment |
US11853392B2 (en) | 2021-11-30 | 2023-12-26 | International Business Machines Corporation | Providing reduced training data for training a machine learning model |
Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5408424A (en) * | 1993-05-28 | 1995-04-18 | Lo; James T. | Optimal filtering by recurrent neural networks |
CN103064878A (en) * | 2012-11-19 | 2013-04-24 | 北京大学 | Rapid sequence labeling method |
CN104781836A (en) * | 2012-11-20 | 2015-07-15 | 高通股份有限公司 | Piecewise linear neuron modeling |
Family Cites Families (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US9390370B2 (en) * | 2012-08-28 | 2016-07-12 | International Business Machines Corporation | Training deep neural network acoustic models using distributed hessian-free optimization |
US9269012B2 (en) * | 2013-08-22 | 2016-02-23 | Amazon Technologies, Inc. | Multi-tracker object tracking |
US9483728B2 (en) * | 2013-12-06 | 2016-11-01 | International Business Machines Corporation | Systems and methods for combining stochastic average gradient and hessian-free optimization for sequence training of deep neural networks |
US10572800B2 (en) * | 2016-02-05 | 2020-02-25 | Nec Corporation | Accelerating deep neural network training with inconsistent stochastic gradient descent |
-
2018
- 2018-07-06 EP EP18746405.2A patent/EP3616134A1/en active Pending
- 2018-07-06 US US16/624,949 patent/US20200250515A1/en active Pending
- 2018-07-06 CN CN201880044003.1A patent/CN110809772B/en active Active
- 2018-07-06 WO PCT/US2018/041033 patent/WO2019083578A1/en unknown
Patent Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5408424A (en) * | 1993-05-28 | 1995-04-18 | Lo; James T. | Optimal filtering by recurrent neural networks |
CN103064878A (en) * | 2012-11-19 | 2013-04-24 | 北京大学 | Rapid sequence labeling method |
CN104781836A (en) * | 2012-11-20 | 2015-07-15 | 高通股份有限公司 | Piecewise linear neuron modeling |
Non-Patent Citations (3)
Title |
---|
Naman Agarwal et al.Second-Order Stochastic Optimization for Machine Learning in Linear Time.Journal of Machine Learning Research.2017,摘要、正文第1-39页. * |
亢良伊 ; 王建飞 ; 刘杰 ; 叶丹 ; .可扩展机器学习的并行与分布式优化算法综述.软件学报.2017,(01),第113-134页. * |
可扩展机器学习的并行与分布式优化算法综述;亢良伊;王建飞;刘杰;叶丹;;软件学报(第01期);第113-134页 * |
Also Published As
Publication number | Publication date |
---|---|
WO2019083578A1 (en) | 2019-05-02 |
CN110809772A (en) | 2020-02-18 |
US20200250515A1 (en) | 2020-08-06 |
EP3616134A1 (en) | 2020-03-04 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
CN110809772B (en) | System and method for improving optimization of machine learning models | |
Chaudhari et al. | Deep relaxation: partial differential equations for optimizing deep neural networks | |
Rosasco et al. | Convergence of stochastic proximal gradient algorithm | |
Sirignano et al. | DGM: A deep learning algorithm for solving partial differential equations | |
Schmidt et al. | Minimizing finite sums with the stochastic average gradient | |
Botev et al. | Practical Gauss-Newton optimisation for deep learning | |
Zeiler | Adadelta: an adaptive learning rate method | |
Zhang et al. | Deep learning with elastic averaging SGD | |
US20230267330A1 (en) | Parameter-Efficient Multi-Task and Transfer Learning | |
CN111970163B (en) | Network flow prediction method of LSTM model based on attention mechanism | |
US20190197404A1 (en) | Asychronous training of machine learning model | |
CN113657578A (en) | Efficient convolutional neural network | |
Tang et al. | Automatic sparse connectivity learning for neural networks | |
EP3792841A1 (en) | Automated feature generation for machine learning application | |
US20220108215A1 (en) | Robust and Data-Efficient Blackbox Optimization | |
Krishnan et al. | Neumann optimizer: A practical optimization algorithm for deep neural networks | |
CN113705793B (en) | Decision variable determination method and device, electronic equipment and medium | |
Guan et al. | Delay compensated asynchronous adam algorithm for deep neural networks | |
Liu et al. | Gradient-sensitive optimization for convolutional neural networks | |
CN111630530A (en) | Data processing system and data processing method | |
Su et al. | Neural dynamics for improving optimiser in deep learning with noise considered | |
Wang et al. | Dichotomy value iteration with parallel learning design towards discrete-time zero-sum games | |
Metz et al. | Learned optimizers that outperform SGD on wall-clock and test loss | |
Axenie et al. | STARLORD: sliding window temporal accumulate-retract learning for online reasoning on datastreams | |
Pasini et al. | Stable Anderson acceleration for deep learning |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
GR01 | Patent grant | ||
GR01 | Patent grant |