US6108383A - Method and apparatus for compression and decompression of video images - Google Patents
Method and apparatus for compression and decompression of video images Download PDFInfo
- Publication number
- US6108383A US6108383A US09/115,895 US11589598A US6108383A US 6108383 A US6108383 A US 6108383A US 11589598 A US11589598 A US 11589598A US 6108383 A US6108383 A US 6108383A
- Authority
- US
- United States
- Prior art keywords
- blocktype
- block
- green
- pixel
- pixels
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Lifetime
Links
Images
Classifications
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/50—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding
- H04N19/59—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding involving spatial sub-sampling or interpolation, e.g. alteration of picture size or resolution
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/102—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or selection affected or controlled by the adaptive coding
- H04N19/103—Selection of coding mode or of prediction mode
- H04N19/107—Selection of coding mode or of prediction mode between spatial and temporal predictive coding, e.g. picture refresh
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/102—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or selection affected or controlled by the adaptive coding
- H04N19/12—Selection from among a plurality of transforms or standards, e.g. selection between discrete cosine transform [DCT] and sub-band transform or selection between H.263 and H.264
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/169—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding
- H04N19/186—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding the unit being a colour or a chrominance component
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/50—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding
- H04N19/503—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding involving temporal prediction
- H04N19/51—Motion estimation or motion compensation
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/60—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using transform coding
- H04N19/61—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using transform coding in combination with predictive coding
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/80—Details of filtering operations specially adapted for video compression, e.g. for pixel interpolation
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/90—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using coding techniques not provided for in groups H04N19/10-H04N19/85, e.g. fractals
- H04N19/98—Adaptive-dynamic-range coding [ADRC]
Definitions
- An extant object of a particular type is objectType x
- a list or matrix of values or objects like a list of test scores or a spreadsheet.
- elements of one-dimensional arrays with integers (eg. an array containing -200, 5.12, 9999, 0.00001, -26) 2 represents the 3rd element of the array (9999) and 0 represents the first (-200)).
- Multidimensional arrays are accessed using (x, y, z, . . . ) coordinates.
- element (3,4 ) of array ⁇ a ⁇ is in the fourth column, fifth row (since (0, 0) is the first position).
- Defining an array or creating an instance of one requires the constituent object type AND the arrays dimensions. Our syntax for this procedure is
- a symbol (usually a number) used to represent a numerically unrelated value.
- a vector is an object containing a number of values. These values represent different properties of the same object.
- a date is a vector--6/24/97 contains three values which represent month day and year--three ⁇ properties ⁇ of a date.
- the value assigned to variable y is said to be the result or the return value.
- Supposing x is a real number, let's define: f(x) as x+1.
- the name of the function is f(x) pronounced ⁇ f of x ⁇ .
- the other part of this definition is called the function's body. This is a simple operation which adds one to a real number and returns the result.
- It is also possible for a function to change the objects that it operates on: Suppose f(x) increment x by one. There is no return value in this case, however the value of x is altered after performing f(x).
- a class of objects is said to have properties. Concretely, a color can be said to have red, green and blue components. We will access individual properties of objects using, the following convention:
- Image . . . A rectangular array of RGB vectors accesed by ⁇ x,y ⁇ coordinates
- DeltaTable . . . contains a integer length and an array integer table[length]. The values in such arrays saved in various combinations are literally the ⁇ meat ⁇ of a compressed image.
- ordinalStream . . . an array of numbers representing various types of compressed data and define the objects in our programming shorthand.
- the source material is a sequence of images stored as sequences of 24 Bit color pixels, 8 bits for each color component, red green and blue (rgb).
- the color information can be ⁇ interlaced ⁇ (rgb rgb rgb rgb etc.) or planar (rrrrrrrr . . . ggggggggg . . . bbbbbbbbbbb . . . ).
- the pixels in a source image are stored in order starting at the upper right and end at the lower left, scanned horizontally like the letters and words in this text. We will call this method of organization Scan-Line order.
- Each 8-bit value in the sequence represents the intensity of one of the color components at a single point in the source image.
- the result of using the TM2 Compression algorithm to compress the source material is a sequence of ⁇ compressed ⁇ images, each consisting of a sequence of binary digits (bits).
- the data in a single compressed frame is comprised of as many as 7 sequences of tokens called streams, one stream for each of the 7 different types of token: HiResLuma deltas, LoResLuma deltas, HiResChroma deltas, LoResChroma deltas, Update color differences, Motion coordinates and BlockType tokens.
- Each stream is preceeded by a value representing length-in-tokens and may also be preceeded by additional data.
- the tokens are represented as variable-bit-length binary numbers.
- Data-rate control is automatic.
- the user of the algorithm must enter a desired data-rate for the entire sequence of images.
- the algorithm accumulates the average data-rate for each frame. Using this number, the data rate for the most recently compressed frame, a predicted data-rate based on pre-compression or average acceleration and the user-selected data-rate, the algorithm adjusts the values of the threshold for each blockType to allow blocktypes with lower data-rate's to be used.
- additional lines of permanently black pixels are added to allow lines of pixels above and to the left of the original image to have known values when accessing the leftmost and topmost lines of 5 ⁇ 5 blocks.
- rows and columns of coherent color may be added to the right and bottom of the original source image to allow the compression algorithm to access pixels on 4 ⁇ 4 boundaries.
- the image's 4 ⁇ 4 blocks are traversed in scan-line order and the following logic is applied to each in sequence:
- the original (colorspace reduced) pixel values in the 5 ⁇ 5 block are stored in a temporary location.
- the original (colorspace reduced) pixel values in the 5 ⁇ 5 block are stored in a temporary location.
- the chromas for pixel (1,0), (2,0), (0,1) and (0,2) are discarded and new chromas for these pixels are calculated by interpolating between pixels (0,0) and (0,3) and also between pixels (0,0) and (3,0). This process is described in detail in section ⁇ Edge Interpolation ⁇ below.
- pixel(0,3) interpolating between pixels (0,2) and (0,4)
- Blocktypes are called interframe because they depend not only on the raw data in the current image but also on data (pixels) from a previously compressed image.
- the original (colorspace reduced) pixel values in the 5 ⁇ 5 block are stored in a temporary location.
- a compressed Still block retains only one ordinal (blocktype).
- Compressing a 4 ⁇ 4 pixel block as a ⁇ Motion ⁇ block reqires a single deltaTable, the decompressed pixel values from the entire previously compressed image, a Hi-res compressed version of the current block and the current uncompressed 4 ⁇ 4 block.
- a compressed Motion block retains two ordinals representing the signed x and y distances to the upper left corner of a 4 ⁇ 4 region in the previous frame to the upper-left corner of the current block (blocktype) (see FIG. 3).
- Compressing a 4 ⁇ 4 pixel block as a ⁇ Motion ⁇ block is requires copying the decompressed green and chroma values from the pixels in a 4 ⁇ 4 region with different, possibly non-aligned coordinates in a previously compressed image.
- the original (colorspace reduced) pixel values in the 5 ⁇ 5 block are stored in a temporary location.
- every 4 ⁇ 4 pixel region in the previous frame that lies within a pre-set distance from the block being compressed is compared with the block being compressed and, provided the lowest return value is lower than the motion-block threshold, the pixels of 4 ⁇ 4 region which compares most favorably (the one with the lowest compare() return value) are copied into the current 4 ⁇ 4Block.
- the ordinals of the x,y distances of the chosen region are retained.
- seven buffers of fixed bit-length ordinals contain the information required to approximately reconstruct the image. They are the High-res Chroma buffer, the Low-res Chroma buffer, the High-res Luma buffer, the Low-res Luma buffer, the Update buffer, the Motion buffer and the blocktype buffer. This information will remain in this order as the file is further compressed, the constituent fixed bit-length ordinals will be replaced by variable bit length tokens by a known process called Huffman encoding. A brief description of our application of this technique follows:
- a histogram is constructed denoting each represented value's population in the buffer. Then a special table of binary numbers is constructed, each unique entry in the table representing an ordinal value. Using a known technique, binary numbers of minimum possible bit-length are chosen to represent ordinal values with the highest populations.
- Each buffer is prepended with a length in tokens and an encapsulated version of this table for decoding the buffer's contents. Then each ordinal is converted to its corresponding binary ⁇ token ⁇ in the table and re-packed into the buffer.
- the seven buffers are archived as a single image in the compressed video sequence.
Abstract
Description
______________________________________ Intraframe: High Res (high resolution) 16 changes in green's.sub.-- BiDirectional Rate of Change.sub.-- 4 changes in red and blue differences'.sub.-- BDRC.sub.-- Medium Res (medium resolution) 16 changes in green's.sub.-- BDRC.sub.-- 1 change in red and blue differences'.sub.-- BDRC.sub.-- Low Res (low resolution) 4 changes in green's.sub.-- BDRC.sub.-- 1 change in red and blue differences'.sub.-- BDRC.sub.-- Null no change in either components.sub.-- BDRC.sub.-- Res Interframe: Still no change in pixels from previous frame Motion pixels copied from another region of previous frame 2 spatial coordinates (X offset and Y offset) Update small change in pixels from previous frame 16 temporal changes in green 4 temporal changes in red and blue differences ______________________________________
______________________________________ class a { type or class b type or class c . . . other members } ______________________________________
______________________________________ c = a.b A concrete example, integer i = pixel.green In fact `chroma` could be considered a function of pixel chroma chroma( pixel p) { chroma c c.redDifference = p.red - p.green c.blueDifference = p.blue - p.green return c but it could also be considered a property of pixel class pixel { integer red integer green integer blue . . . other properties . . . chroma chroma( pixel p) { chroma c c.redDifference = red - green c.blueDifference = blue - green return c } . . . other properties . . . } ______________________________________
______________________________________ class pixel { integer red integer green integer blue integer luma() { return red * 7 + green * 12 + blue * 5 } chroma chroma() { chroma c c.redDifference = red - green c.blueDifference = blue - green return c integer combine( integer g, chroma c) { if { (g > 0) and ( g < 256)}{ green = g red = g + c.redDifference blue g + c.blueDifference if { ( red < 0) or ( red > 255) or ( blue < 0) or ( blue > 255)}{ return FAILED } return SUCCEEDED } else return FAILED } integer compare( pixel a){ return (((red - a.red) * (red - a.red) * 7) + ((green - a.green) * (green - a.green) * 12) + ((blue - a.blue) * (blue - a.blue) * 5)) } } class DeltaTable { integer len array integer table[ length] ordinal nearest( integer x) { search table for closest match with x change x's value to closest match with x return index to closest match with x } integer delta( integer i){ return table[i] } } class 4x4Block { array pixel p[5][5] integer compare( 4x4Block blk){ integer i = 1 integer j = 1 integer k = 0 while { i < 5 }{ while { j < 5 }{ k = k + p[j][i].compare ( blk.p[j][i]) } } return k } InterpolateEdgeGreen(){ p[1][0].green = ( p[0][0].green + p[2][0].green) >> 1 p[3][0].green = ( p[2][0].green + p[4][0].green) >> 1 p[0][1].green = ( p[0][0].green + p[0][2].green) >> 1 p[0][3].green = ( p[0][2].green + p[0][4].green) >> 1 } interpolateEdgeChroma(){ 2 Chromas are interpolated as above for chroma-plane positions and (1,0) ( } integer interpolateEdges(){ interpolateEdgeGreen() interpolateEdgeChroma() if { any combine( new green values, new chroma values) == FAILED} return FAILED } } class cxHiRes4x4Block{ array ordinal red[4] array ordinal blue[4] array ordinal luma[16] ordinal btype = 0 } class cxMedRes4x4Block{ ordinal red ordinal blue array ordinal luma[16] ordinal btype = 1 } class cxLoRes4x4Block{ ordinal red ordinal blue array ordinal luma[4] ordinal btype = 2 } class cxNulRes4x4Block{ ordinal btype = 3 } class cxUpdate4x4Block{ array ordinal red[4] array ordinal blue[4] array ordinal luma[16] ordinal btype = 4 } class cxStill4x4Block{ ordinal btype = 5 } class cxMotion4x4Block{ ordinal x ordinal y ordinal btype = 6 } class image { integer width integer height integer widthInBlocks integer heightInBlocks array pixel[width][height] 4x4Block GetNext4x4Block(){see 1. below } 4x4Block Get4x4Block( integer offsetX, integer offsetY){see 2. below } Set4x4Block( integer blockX, integer blockY, 4x4Block){see 1. below } } ______________________________________
______________________________________ blockType cx4x4Block::Compress( 4x4Block blk,image lastFrame, integer bx, integer by, ThreshTable dThr, TokenBus dtb, integer keyframe) 4x4Block lastBlk; 4x4Block highBlk; blk.CopyInto( &highBlk); cxHiResBlock hiRes( &highBlk, dtb); if( !keyframe){ lastFrame.ReadBlockFromMap( bx, by, &lastBlk); if( dThr.Threshold( STILL)){ cxStillBlock stl( blk,&highBlk, &lastBlk, dThr.Threshold( STILL)); if( stl.isValid) { stl.write( dtb); return STILL;} }if( dThr.Threshold( MOTION)){ duk.sub.-- MotionBlock mot( blk,&highBlk, lastFrame, bx, by, dtb, dThr.Threshold( MOTION)); if( mot.isValid) {mot.write( dtb); return MOTION;} } } if( dThr.Threshold( NUL.sub.-- RES)){ cxNulResBlock nulRes( blk,&highBlk, dThr.Threshold( NUL.sub.-- RES)); if( nulRes.isValid) { nulRes.write( dtb); return NUL.sub.-- RES;} } if( dThr.Threshold( LO.sub.-- RES)){ cxLowResBlock loRes( blk,&highBlk, dtb, dThr.Threshold( LO.sub.-- RES)); if( loRes.isValid) { loRes.write( dtb); return LO.sub.-- RES;} } if( !keyframe){ if( dThr.Threshold( UPDATE)){ cxUpdateBlock update( blk,&highBlk, &lastBlk, dtb, dThr.Threshold( UPDATE)); if( update.isValid) { update.write( dtb); return UPDATE;} } } if( dThr.Threshold( MED.sub.-- RES)){ cxMedResBlock medRes( blk,&highBlk, dtb, dThr.Threshold( MED.sub.-- RES)); if( medRes.isValid) { medRes.write( dtb); return MED.sub.-- RES;} } highBlk.CopyInto( blk); hiRes.write( dtb); return HI.sub.-- RES } ______________________________________
______________________________________ 3.For every pixel ( accessed in scan-line order){ we will say the pixel in question = A the pixel to the left = B the pixel to the left and above = C the pixel above = D If the pixel lies on an even boundary{ CVP = chroma( B) - chroma( C) CDelta = chroma( A) - chroma( D) - CVP Search Hi-ResChroma DeltaTable for two values representing the nearest match with CDelta's redDiff and blueDiff components set CDelta to these values store indeces to both chosen table entries in red[nextposition] and blue[nextPosition] CA = CVP + chroma( D) + CDelta LVP = luma( b) - luma( c) If the pixel lies on an even boundary{ add to LVP redDiff( CDelta) * 7 +blueDiff( CDelta) * 5 } GVP = green( B) - green( C) + green( D) LDelta = luma( A) - luma( D) - LVP GDelta = LDelta /24; Search Hi-Res Luma DeltaTable for a value representing the nearest match with GDelta set GDelta to this value maybeG = GVP + GDelta if { (pixelA.combine( maybeG, CA ( or chroma( D) if row is odd))) == SUCCEEDED}{ store index to chosen table entry in luma[nextPosition] } if any component of the resulting pixel is greater than 8 bits or less than 0{ for every entry in the Hi-res luma delta Table { LDelta = thisTableEntry * 24; LA = LVP + LDelta + luma( D) maybeG = GVP + thisTableEntry if ( pixelA.combine( maybeG, CA ( or chroma( D) if row is odd))==SUCCEEDED) { if the absolute value of luma( A) - LA is less than the value computed for the previous delta ( or less than 64000 if this is the first entry) { store index to chosen table entry in luma[currentPosition] store index to chosen table entry in current position in Compressed-Luma Array } } } } If an index has not yet been stored for this pixel's luma value{ reset the 4x4 blocks pixel values to the saved original values set margin equal to double it's value clip all 16 pixel values by margin do over from step 3 with newly clipped pixel values. } set GDelta to the chosen entry in Hi-Res.sub.-- luma delta table for this pixel maybeG = GVP + GDelta set A = combine( maybeG, CA (or chroma( D) if row is odd)) if ( any component of the resulting pixel is greater than 8 bits or less than 0) and (margin < 128 or ( 1/2 bit depth if not 8 bits)){ set margin equal to double it's value clip all 16 pixel values by margin do over from step 3 with newly clipped pixel values. } pixel A now contains an approximation of the pixel at the same location in the original image. its values are equal to the pixel values in the decompressed image. } ______________________________________
______________________________________ 2.For every pixel ( accessed in scan-line order){ we will say the pixel in question = A the pixel to the left = B the pixel to the left and above = C the pixel above = D the pixel to the left and below = E the pixel to the right and above = F If the this is the upper-leftmost pixel{ CVP = chroma( E) - chroma( C) CDelta = chroma( A) - chroma( F) - CVP Search Lo-ResChroma DeltaTable for two values representing the nearest match with CDelta's redDiff and blueDiff components set CDelta to these values store indeces to both chosen table entries in next 2 positions in Compressed-Chroma Array set CVP = chroma( B) - chroma( C) CA = CVP + chroma( D) + CDelta if this pixel lies in the upper-left corner of a chroma quadrant{ CVP = chroma( B) - chroma( C) CA = CVP + chroma( D) } if this pixel doesn't lie in the upper-left corner of a chroma quadrant{ CA = chroma( d) } LVP = luma( b) - luma( c) If the this is the upper-leftmost pixel{ add to LVP redDiff( CDelta) * 7 + blueDiff( CDelta) * 5 } GVP = green( B) - green( C) + green( D) LDelta = Luma( A) - luma( D) - LVP GDelta = LDelta /24; Search Hi-Res Luma DeltaTable for a value representing the nearest match with GDelta set GDelta to this value maybeG = GVP + GDelta pixelA = combine( maybeG, CA) if no component of the resulting pixel is greater than 8 bits or less than 0{ store index to chosen table entry in next position in Compressed- Luma Array. } if any component of the resulting pixel is greater than 8 bits or less than 0{ for every entry in the Hi-res luma delta Table{ LDelta = thisTableEntry * 24; LA = LVP + LDelta + luma( D) maybeG = GVP + thisTableEntry pixelA = combine( maybeG, CA) if no component of the resulting pixel is greater than 8 bits or less than 0{ if the absolute value of luma( A) - LA is less than the value computed for the previous delta ( or less than 64000 if this is the first entry){ store index to chosen table entry in current position in Compressed-Luma Array } } } } } set GDelta to the chosen entry in Hi-Res.sub.-- luma delta table for this pixel maybeG = GVP + GDelta set A = combine( maybeG, CA) pixel A now contains an approximation of the pixel at the same location in the original image. its values are equal to the pixel values in the decompressed image. } ______________________________________
______________________________________ 2.For every pixel in the 4x4 block( accessed in scan-line order){ we will say the pixel in question = A the pixel to the left = B the pixel to the left and above = C the pixel above = D the pixel to the left and below = E the pixel to the right and above = F If the this is the upper-leftmost pixel{ CVP = chroma( E) - chroma( C) CDelta = chroma( A) - chroma( F) - CVP Search Lo-ResChroma DeltaTable for two values representing the nearest match with CDelta's redDiff and blueDiff components set CDelta to these values store indeces to both chosen table entries in next 2 positions in Compressed-Chroma Array set CVP = chroma( B) - chroma( C) CA = CVP + chroma( D) + CDelta if this pixel lies in the upper-left corner of a chroma quadrant{ CVP = chroma( B) - chroma( C) CA = CVP + chroma( D) } if this pixel doesn't lie in the upper-left corner of a chroma quadrant{ CA = chroma( d) } LVP = luma( b) - luma( c) If the this is the upper-leftmost pixel { add to LVP redDiff( CDelta) * 7 + blueDiff( CDelta) * 5 } set GDelta 0 if this pixel lies in the upper-left corner of a chroma quadrant{ save the original values in the 2x2 quadrant in a temporary location for every delta in the lo-res luma delta table{ For every pixel in the 2x2 quadrant( accessed in scan-line order){ we will say the pixel in question = A the pixel to the left = B the pixel to the left and above = C the pixel above = D if this is the upper left pixel { GD = thisTableEntry } if this is not the upper left pixel { GD = 0 } GVP = Green( B) - Green( C) maybeG = GVP + green( D) + GD set A = combine( maybeG, CA) if any component of the resulting pixel is greater than 8 bits or less than 0{ reset 2x2 quadrant to original pixel values try the next delta table entry } } compare each of the four new pixels in the 2x2 quadrant with the corresponding Hi-Res compressed pixels, sum the results and save this total if lower than the previously saved one ( or infinity if this is the first table entry) } } set GDelta to the table entry with the lowest comparison results store index to chosen table entry in next position in LoRes-Luma Array } GVP = green( B) - green( C) maybeG = GVP + GDelta set A = combine( maybeG, CA) pixel A now contains an approximation of the pixel at the same location in the original image. its values are equal to the pixel values in the decompressed image. } ______________________________________
______________________________________ 3. Green values for the 16 null-res block pixels are calculated as follows: green (1,1) = green( 0,0) + ((green( 0,4) - green( 0,0)) / 4) + ((green( 4,0) - green( 0,0)) / 4) green (2,1) = green( 0,0) + ((green( 0,4) - green( 0,0)) / 4) + ((green( 4,0) - green( 0,0)) / 2) green (3,1) = green( 4,0) + ((green( 0,4) - green( 0,0)) / 4) - ((green( 4,0) - green( 0,0)) / 4) green (4,1) = green( 4,0) + ((green( 0,4) - green( 0,0)) / 4) green (1,2) = green( 0,0) + ((green( 0,4) - green( 0,0)) / 2) + ((green( 4,0) - green( 0,0)) / 4) green (2,2) = green( 0,0) + ((green( 0,4) - green( 0,0)) / 2) + ((green( 4,0) - green( 0,0)) / 2) green (3,2) = green( 4,0) + ((green( 0,4) - green( 0,0)) / 2) - ((green( 4,0) - green( 0,0)) / 4) green (4,2) = green( 4,0) + ((green( 0,4) - green( 0,0)) / 2) green (1,3) = green( 0,4) - ((green( 0,4) - green( 0,0)) / 4) + ((green( 4,0) - green( 0,0)) / 4) green (2,3) = green( 0,4) - ((green( 0,4) - green( 0,0)) / 4) + ((green( 4,0) - green( 0,0) / 2 ) green (3,3) = green( 0,4) - ((green( 0,4) - green( 0,0)) / 4) + (green( 4,0) - green( 0,0)) - ((green( 4,0) - green( 0,0))/4) green (4,3) = green( 4,0) + (green( 0,4) - green( 0,0)) - ((green( 0,4) - green( 0,0)) / 4) green (1,4) = green( 0,4) + ((green( 4,0) - green( 0,0) / 4) green (2,4) = green( 0,4) + ((green( 4,0) - green( 0,0)) / 2) green (3,4) = green( 0,4) + (green( 4,0) - green( 0,0)) - ((green( 4,0) - green( 0,0) / 4) (green (4,4) = green( 0,4) + (green( 4,0) - green( 0,0)) 4. Chroma vectors for the 4 null-res block chroma quadrants are computed as follows: chromaQuad( 1,1) = chroma( 0,0) + ((chroma( 2, 0) - chroma( 0,0))/ 2) + ((chroma( 0, 2) - chroma( 0,0))/ 2) chromaQuad( 2,1) = chroma( 2,0) + (( chroma( 0, 2) - chroma( 0,0))/ 2) chromaQuad( 1 ,2) = chroma( 0, 2) + (( chroma( 2, 0) - chroma( 0,0))/ 2) chromaQuad( 2,2) = chroma( 2,0) + ( chroma( 0,2) - chroma(0,0)) ______________________________________
______________________________________ 4. for { all 16 pixels }{ greenOrdinal[currentpixelIndex] = updateDeltaTable.nearest ( currentBlock.( ( green[currentPixelIndex] - previousBlock.green[currentPixelIndex])) green[currentPixelIndex] = previousBlock.green[currentPixelIndex] + currentBlock.( ( green[currentPixelIndex] { a similar operation is used on chroma ordinals } ______________________________________
Claims (13)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US09/115,895 US6108383A (en) | 1997-07-15 | 1998-07-15 | Method and apparatus for compression and decompression of video images |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US5259497P | 1997-07-15 | 1997-07-15 | |
US09/115,895 US6108383A (en) | 1997-07-15 | 1998-07-15 | Method and apparatus for compression and decompression of video images |
Publications (1)
Publication Number | Publication Date |
---|---|
US6108383A true US6108383A (en) | 2000-08-22 |
Family
ID=26730848
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US09/115,895 Expired - Lifetime US6108383A (en) | 1997-07-15 | 1998-07-15 | Method and apparatus for compression and decompression of video images |
Country Status (1)
Country | Link |
---|---|
US (1) | US6108383A (en) |
Cited By (61)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
WO2003067777A1 (en) * | 2002-01-16 | 2003-08-14 | Cornerstone Group Ltd. | Optimized data transmission system and method |
US6757687B2 (en) * | 2001-05-31 | 2004-06-29 | Nokia Corporation | Storage of data entries in digital devices and methods |
US6765587B1 (en) * | 1999-06-29 | 2004-07-20 | Sharp Kabushiki Kaisha | Image processing apparatus |
US20050141617A1 (en) * | 2003-12-27 | 2005-06-30 | Samsung Electronics Co., Ltd. | Residue image down/up sampling method and apparatus and image encoding/decoding method and apparatus using residue sampling |
WO2005074143A1 (en) * | 2004-02-02 | 2005-08-11 | Adams Platform Pty Ltd | System and method for encoding/decoding live audio/video information |
EP1589761A1 (en) * | 2004-04-19 | 2005-10-26 | Oplayo Oy | A codec adapted to operate in rgb color space |
EP1551184A3 (en) * | 2003-12-27 | 2006-06-28 | Samsung Electronics Co., Ltd. | Residue image downsampling and encoding method |
US20100061461A1 (en) * | 2008-09-11 | 2010-03-11 | On2 Technologies Inc. | System and method for video encoding using constructed reference frame |
US20100061645A1 (en) * | 2008-09-11 | 2010-03-11 | On2 Technologies Inc. | System and method for video encoding using adaptive loop filter |
US20100061455A1 (en) * | 2008-09-11 | 2010-03-11 | On2 Technologies Inc. | System and method for decoding using parallel processing |
US20100061444A1 (en) * | 2008-09-11 | 2010-03-11 | On2 Technologies Inc. | System and method for video encoding using adaptive segmentation |
AU2004212552B2 (en) * | 2003-09-29 | 2010-09-30 | Honda Motor Co., Ltd. | Hybrid vehicle |
US20110142137A1 (en) * | 2009-12-16 | 2011-06-16 | International Business Machines Corporation | Video processing |
US8611415B1 (en) | 2010-11-15 | 2013-12-17 | Google Inc. | System and method for coding using improved motion estimation |
US8665952B1 (en) | 2010-09-15 | 2014-03-04 | Google Inc. | Apparatus and method for decoding video encoded using a temporal filter |
US20140126644A1 (en) * | 2011-06-30 | 2014-05-08 | Telefonaktiebolaget L M Ericsson (Publ) | A Method a Decoder and Encoder for Processing a Motion Vector |
US8767817B1 (en) | 2011-04-07 | 2014-07-01 | Google Inc. | Apparatus and method for coding using parameterized equation |
US8780996B2 (en) | 2011-04-07 | 2014-07-15 | Google, Inc. | System and method for encoding and decoding video data |
US8780971B1 (en) | 2011-04-07 | 2014-07-15 | Google, Inc. | System and method of encoding using selectable loop filters |
US8781004B1 (en) | 2011-04-07 | 2014-07-15 | Google Inc. | System and method for encoding video using variable loop filter |
US8885706B2 (en) | 2011-09-16 | 2014-11-11 | Google Inc. | Apparatus and methodology for a video codec system with noise reduction capability |
US8989256B2 (en) | 2011-05-25 | 2015-03-24 | Google Inc. | Method and apparatus for using segmentation-based coding of prediction information |
US9014266B1 (en) | 2012-06-05 | 2015-04-21 | Google Inc. | Decimated sliding windows for multi-reference prediction in video coding |
US9094681B1 (en) | 2012-02-28 | 2015-07-28 | Google Inc. | Adaptive segmentation |
US9106933B1 (en) | 2010-05-18 | 2015-08-11 | Google Inc. | Apparatus and method for encoding video using different second-stage transform |
US9131073B1 (en) | 2012-03-02 | 2015-09-08 | Google Inc. | Motion estimation aided noise reduction |
US9154799B2 (en) | 2011-04-07 | 2015-10-06 | Google Inc. | Encoding and decoding motion via image segmentation |
US9185429B1 (en) | 2012-04-30 | 2015-11-10 | Google Inc. | Video encoding and decoding using un-equal error protection |
US9210442B2 (en) | 2011-01-12 | 2015-12-08 | Google Technology Holdings LLC | Efficient transform unit representation |
US9219915B1 (en) | 2013-01-17 | 2015-12-22 | Google Inc. | Selection of transform size in video coding |
US9247257B1 (en) | 2011-11-30 | 2016-01-26 | Google Inc. | Segmentation based entropy encoding and decoding |
US9247251B1 (en) | 2013-07-26 | 2016-01-26 | Google Inc. | Right-edge extension for quad-tree intra-prediction |
US9262670B2 (en) | 2012-02-10 | 2016-02-16 | Google Inc. | Adaptive region of interest |
US9344729B1 (en) | 2012-07-11 | 2016-05-17 | Google Inc. | Selective prediction signal filtering |
US9350988B1 (en) | 2012-11-20 | 2016-05-24 | Google Inc. | Prediction mode-based block ordering in video coding |
US9380319B2 (en) | 2011-02-04 | 2016-06-28 | Google Technology Holdings LLC | Implicit transform unit representation |
US9380298B1 (en) | 2012-08-10 | 2016-06-28 | Google Inc. | Object-based intra-prediction |
US9392280B1 (en) | 2011-04-07 | 2016-07-12 | Google Inc. | Apparatus and method for using an alternate reference frame to decode a video frame |
US9392272B1 (en) | 2014-06-02 | 2016-07-12 | Google Inc. | Video coding using adaptive source variance based partitioning |
US9426459B2 (en) | 2012-04-23 | 2016-08-23 | Google Inc. | Managing multi-reference picture buffers and identifiers to facilitate video data coding |
US9490850B1 (en) | 2011-11-28 | 2016-11-08 | Google Inc. | Method and apparatus for decoding packetized data |
US9532059B2 (en) | 2010-10-05 | 2016-12-27 | Google Technology Holdings LLC | Method and apparatus for spatial scalability for video coding |
US9544597B1 (en) | 2013-02-11 | 2017-01-10 | Google Inc. | Hybrid transform in video encoding and decoding |
US9565451B1 (en) | 2014-10-31 | 2017-02-07 | Google Inc. | Prediction dependent transform coding |
US9578324B1 (en) | 2014-06-27 | 2017-02-21 | Google Inc. | Video coding using statistical-based spatially differentiated partitioning |
US9609341B1 (en) | 2012-04-23 | 2017-03-28 | Google Inc. | Video data encoding and decoding using reference picture lists |
US9674530B1 (en) | 2013-04-30 | 2017-06-06 | Google Inc. | Hybrid transforms in video coding |
US9681128B1 (en) | 2013-01-31 | 2017-06-13 | Google Inc. | Adaptive pre-transform scanning patterns for video and image compression |
US9756331B1 (en) | 2013-06-17 | 2017-09-05 | Google Inc. | Advance coded reference prediction |
US9762931B2 (en) | 2011-12-07 | 2017-09-12 | Google Inc. | Encoding time management in parallel real-time video encoding |
US9769499B2 (en) | 2015-08-11 | 2017-09-19 | Google Inc. | Super-transform video coding |
US9794574B2 (en) | 2016-01-11 | 2017-10-17 | Google Inc. | Adaptive tile data size coding for video and image compression |
US9807423B1 (en) | 2015-11-24 | 2017-10-31 | Google Inc. | Hybrid transform scheme for video coding |
US9826229B2 (en) | 2012-09-29 | 2017-11-21 | Google Technology Holdings LLC | Scan pattern determination from base layer pixel information for scalable extension |
US9967559B1 (en) | 2013-02-11 | 2018-05-08 | Google Llc | Motion vector dependent spatial transformation in video coding |
US10034023B1 (en) | 2012-07-30 | 2018-07-24 | Google Llc | Extended protection of digital video streams |
US10102613B2 (en) | 2014-09-25 | 2018-10-16 | Google Llc | Frequency-domain denoising |
US10277905B2 (en) | 2015-09-14 | 2019-04-30 | Google Llc | Transform selection for non-baseband signal coding |
US10542258B2 (en) | 2016-01-25 | 2020-01-21 | Google Llc | Tile copying for video compression |
US11122297B2 (en) | 2019-05-03 | 2021-09-14 | Google Llc | Using border-aligned block functions for image compression |
US11425395B2 (en) | 2013-08-20 | 2022-08-23 | Google Llc | Encoding and decoding using tiling |
Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5068724A (en) * | 1990-06-15 | 1991-11-26 | General Instrument Corporation | Adaptive motion compensation for digital television |
US5091782A (en) * | 1990-04-09 | 1992-02-25 | General Instrument Corporation | Apparatus and method for adaptively compressing successive blocks of digital video |
US5274442A (en) * | 1991-10-22 | 1993-12-28 | Mitsubishi Denki Kabushiki Kaisha | Adaptive blocking image signal coding system |
-
1998
- 1998-07-15 US US09/115,895 patent/US6108383A/en not_active Expired - Lifetime
Patent Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5091782A (en) * | 1990-04-09 | 1992-02-25 | General Instrument Corporation | Apparatus and method for adaptively compressing successive blocks of digital video |
US5068724A (en) * | 1990-06-15 | 1991-11-26 | General Instrument Corporation | Adaptive motion compensation for digital television |
US5274442A (en) * | 1991-10-22 | 1993-12-28 | Mitsubishi Denki Kabushiki Kaisha | Adaptive blocking image signal coding system |
Cited By (77)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6765587B1 (en) * | 1999-06-29 | 2004-07-20 | Sharp Kabushiki Kaisha | Image processing apparatus |
US6757687B2 (en) * | 2001-05-31 | 2004-06-29 | Nokia Corporation | Storage of data entries in digital devices and methods |
AU2002235321B2 (en) * | 2002-01-16 | 2006-03-16 | Vedanti Systems Limited | Optimized data transmission system and method |
CN100395959C (en) * | 2002-01-16 | 2008-06-18 | 科纳斯通集团有限公司 | Optimized data transmission system and method |
WO2003067777A1 (en) * | 2002-01-16 | 2003-08-14 | Cornerstone Group Ltd. | Optimized data transmission system and method |
AU2004212552B2 (en) * | 2003-09-29 | 2010-09-30 | Honda Motor Co., Ltd. | Hybrid vehicle |
US7720156B2 (en) | 2003-12-27 | 2010-05-18 | Samsung Electronics Co., Ltd. | Residue image down/up sampling method and apparatus and image encoding/decoding method and apparatus using residue sampling |
US20050141617A1 (en) * | 2003-12-27 | 2005-06-30 | Samsung Electronics Co., Ltd. | Residue image down/up sampling method and apparatus and image encoding/decoding method and apparatus using residue sampling |
EP1551184A3 (en) * | 2003-12-27 | 2006-06-28 | Samsung Electronics Co., Ltd. | Residue image downsampling and encoding method |
EP2224724A3 (en) * | 2003-12-27 | 2012-04-11 | Samsung Electronics Co., Ltd. | Image encoding and decoding method using residue sampling |
WO2005074143A1 (en) * | 2004-02-02 | 2005-08-11 | Adams Platform Pty Ltd | System and method for encoding/decoding live audio/video information |
EP1589761A1 (en) * | 2004-04-19 | 2005-10-26 | Oplayo Oy | A codec adapted to operate in rgb color space |
US8385404B2 (en) | 2008-09-11 | 2013-02-26 | Google Inc. | System and method for video encoding using constructed reference frame |
US8325796B2 (en) | 2008-09-11 | 2012-12-04 | Google Inc. | System and method for video coding using adaptive segmentation |
US20100061455A1 (en) * | 2008-09-11 | 2010-03-11 | On2 Technologies Inc. | System and method for decoding using parallel processing |
USRE49727E1 (en) | 2008-09-11 | 2023-11-14 | Google Llc | System and method for decoding using parallel processing |
US20100061645A1 (en) * | 2008-09-11 | 2010-03-11 | On2 Technologies Inc. | System and method for video encoding using adaptive loop filter |
US8311111B2 (en) | 2008-09-11 | 2012-11-13 | Google Inc. | System and method for decoding using parallel processing |
US8326075B2 (en) | 2008-09-11 | 2012-12-04 | Google Inc. | System and method for video encoding using adaptive loop filter |
US8897591B2 (en) | 2008-09-11 | 2014-11-25 | Google Inc. | Method and apparatus for video coding using adaptive loop filter |
US9357223B2 (en) | 2008-09-11 | 2016-05-31 | Google Inc. | System and method for decoding using parallel processing |
US9374596B2 (en) | 2008-09-11 | 2016-06-21 | Google Inc. | System and method for video encoding using constructed reference frame |
US9924161B2 (en) | 2008-09-11 | 2018-03-20 | Google Llc | System and method for video coding using adaptive segmentation |
US20100061461A1 (en) * | 2008-09-11 | 2010-03-11 | On2 Technologies Inc. | System and method for video encoding using constructed reference frame |
US20100061444A1 (en) * | 2008-09-11 | 2010-03-11 | On2 Technologies Inc. | System and method for video encoding using adaptive segmentation |
US20110142137A1 (en) * | 2009-12-16 | 2011-06-16 | International Business Machines Corporation | Video processing |
US9106933B1 (en) | 2010-05-18 | 2015-08-11 | Google Inc. | Apparatus and method for encoding video using different second-stage transform |
US8665952B1 (en) | 2010-09-15 | 2014-03-04 | Google Inc. | Apparatus and method for decoding video encoded using a temporal filter |
US9532059B2 (en) | 2010-10-05 | 2016-12-27 | Google Technology Holdings LLC | Method and apparatus for spatial scalability for video coding |
US8611415B1 (en) | 2010-11-15 | 2013-12-17 | Google Inc. | System and method for coding using improved motion estimation |
US9210442B2 (en) | 2011-01-12 | 2015-12-08 | Google Technology Holdings LLC | Efficient transform unit representation |
US9380319B2 (en) | 2011-02-04 | 2016-06-28 | Google Technology Holdings LLC | Implicit transform unit representation |
US9154799B2 (en) | 2011-04-07 | 2015-10-06 | Google Inc. | Encoding and decoding motion via image segmentation |
US8780996B2 (en) | 2011-04-07 | 2014-07-15 | Google, Inc. | System and method for encoding and decoding video data |
US8767817B1 (en) | 2011-04-07 | 2014-07-01 | Google Inc. | Apparatus and method for coding using parameterized equation |
US8780971B1 (en) | 2011-04-07 | 2014-07-15 | Google, Inc. | System and method of encoding using selectable loop filters |
US9392280B1 (en) | 2011-04-07 | 2016-07-12 | Google Inc. | Apparatus and method for using an alternate reference frame to decode a video frame |
US8781004B1 (en) | 2011-04-07 | 2014-07-15 | Google Inc. | System and method for encoding video using variable loop filter |
US8989256B2 (en) | 2011-05-25 | 2015-03-24 | Google Inc. | Method and apparatus for using segmentation-based coding of prediction information |
US20140126644A1 (en) * | 2011-06-30 | 2014-05-08 | Telefonaktiebolaget L M Ericsson (Publ) | A Method a Decoder and Encoder for Processing a Motion Vector |
US8885706B2 (en) | 2011-09-16 | 2014-11-11 | Google Inc. | Apparatus and methodology for a video codec system with noise reduction capability |
US9490850B1 (en) | 2011-11-28 | 2016-11-08 | Google Inc. | Method and apparatus for decoding packetized data |
US9247257B1 (en) | 2011-11-30 | 2016-01-26 | Google Inc. | Segmentation based entropy encoding and decoding |
US9762931B2 (en) | 2011-12-07 | 2017-09-12 | Google Inc. | Encoding time management in parallel real-time video encoding |
US9262670B2 (en) | 2012-02-10 | 2016-02-16 | Google Inc. | Adaptive region of interest |
US9094681B1 (en) | 2012-02-28 | 2015-07-28 | Google Inc. | Adaptive segmentation |
US9131073B1 (en) | 2012-03-02 | 2015-09-08 | Google Inc. | Motion estimation aided noise reduction |
US9609341B1 (en) | 2012-04-23 | 2017-03-28 | Google Inc. | Video data encoding and decoding using reference picture lists |
US9426459B2 (en) | 2012-04-23 | 2016-08-23 | Google Inc. | Managing multi-reference picture buffers and identifiers to facilitate video data coding |
US9185429B1 (en) | 2012-04-30 | 2015-11-10 | Google Inc. | Video encoding and decoding using un-equal error protection |
US9014266B1 (en) | 2012-06-05 | 2015-04-21 | Google Inc. | Decimated sliding windows for multi-reference prediction in video coding |
US9344729B1 (en) | 2012-07-11 | 2016-05-17 | Google Inc. | Selective prediction signal filtering |
US10034023B1 (en) | 2012-07-30 | 2018-07-24 | Google Llc | Extended protection of digital video streams |
US9380298B1 (en) | 2012-08-10 | 2016-06-28 | Google Inc. | Object-based intra-prediction |
US9826229B2 (en) | 2012-09-29 | 2017-11-21 | Google Technology Holdings LLC | Scan pattern determination from base layer pixel information for scalable extension |
US9350988B1 (en) | 2012-11-20 | 2016-05-24 | Google Inc. | Prediction mode-based block ordering in video coding |
US9219915B1 (en) | 2013-01-17 | 2015-12-22 | Google Inc. | Selection of transform size in video coding |
US9681128B1 (en) | 2013-01-31 | 2017-06-13 | Google Inc. | Adaptive pre-transform scanning patterns for video and image compression |
US10462472B2 (en) | 2013-02-11 | 2019-10-29 | Google Llc | Motion vector dependent spatial transformation in video coding |
US9544597B1 (en) | 2013-02-11 | 2017-01-10 | Google Inc. | Hybrid transform in video encoding and decoding |
US9967559B1 (en) | 2013-02-11 | 2018-05-08 | Google Llc | Motion vector dependent spatial transformation in video coding |
US10142628B1 (en) | 2013-02-11 | 2018-11-27 | Google Llc | Hybrid transform in video codecs |
US9674530B1 (en) | 2013-04-30 | 2017-06-06 | Google Inc. | Hybrid transforms in video coding |
US9756331B1 (en) | 2013-06-17 | 2017-09-05 | Google Inc. | Advance coded reference prediction |
US9247251B1 (en) | 2013-07-26 | 2016-01-26 | Google Inc. | Right-edge extension for quad-tree intra-prediction |
US11722676B2 (en) | 2013-08-20 | 2023-08-08 | Google Llc | Encoding and decoding using tiling |
US11425395B2 (en) | 2013-08-20 | 2022-08-23 | Google Llc | Encoding and decoding using tiling |
US9392272B1 (en) | 2014-06-02 | 2016-07-12 | Google Inc. | Video coding using adaptive source variance based partitioning |
US9578324B1 (en) | 2014-06-27 | 2017-02-21 | Google Inc. | Video coding using statistical-based spatially differentiated partitioning |
US10102613B2 (en) | 2014-09-25 | 2018-10-16 | Google Llc | Frequency-domain denoising |
US9565451B1 (en) | 2014-10-31 | 2017-02-07 | Google Inc. | Prediction dependent transform coding |
US9769499B2 (en) | 2015-08-11 | 2017-09-19 | Google Inc. | Super-transform video coding |
US10277905B2 (en) | 2015-09-14 | 2019-04-30 | Google Llc | Transform selection for non-baseband signal coding |
US9807423B1 (en) | 2015-11-24 | 2017-10-31 | Google Inc. | Hybrid transform scheme for video coding |
US9794574B2 (en) | 2016-01-11 | 2017-10-17 | Google Inc. | Adaptive tile data size coding for video and image compression |
US10542258B2 (en) | 2016-01-25 | 2020-01-21 | Google Llc | Tile copying for video compression |
US11122297B2 (en) | 2019-05-03 | 2021-09-14 | Google Llc | Using border-aligned block functions for image compression |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US6108383A (en) | Method and apparatus for compression and decompression of video images | |
US5300949A (en) | Scalable digital video decompressor | |
US5675382A (en) | Spatial compression and decompression for video | |
US5187755A (en) | Method of and apparatus for compressing image data | |
CN101816182B (en) | Image encoding device, image encoding method, and image encoding system | |
US5463701A (en) | System and method for pattern-matching with error control for image and video compression | |
JP2005524319A (en) | Image and image sequence compression through adaptive parcels | |
US6157741A (en) | Image processing apparatus and image processing method | |
CN110087083B (en) | Method for selecting intra chroma prediction mode, image processing apparatus, and storage apparatus | |
US7248735B2 (en) | Compression and decompression method of image data | |
US6195128B1 (en) | Video processing for storage or transmission | |
US6421466B1 (en) | Hierarchical motion estimation with levels of varying bit width for digital video compression | |
JPH088504B2 (en) | Data compression method | |
GB2362055A (en) | Image compression using a codebook | |
US6512853B2 (en) | Method and apparatus for compressing digital image data | |
US20060215920A1 (en) | Image processing apparatus, image processing method, and storage medium storing programs therefor | |
Strutz | Adaptive selection of colour transformations for reversible image compression | |
JPH0779352A (en) | Picture processing unit | |
EP0845191B1 (en) | A method and apparatus for compressing digital image data | |
WO2001084849A1 (en) | Video data transmission | |
Son et al. | Fast FPGA implementation of YUV-based fractal image compression | |
US5296938A (en) | Address generating method, and circuit therefor | |
WO2001084848A2 (en) | Loss less image compression | |
US20030156651A1 (en) | Method for reducing code artifacts in block coded video signals | |
JP4462360B2 (en) | Image compression apparatus and image expansion apparatus |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
FPAY | Fee payment |
Year of fee payment: 4 |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
AS | Assignment |
Owner name: ON2 TECHNOLOGIES, INC., NEW YORKFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:MILLER, DANIEL;MURPHY, TIMOTHY S.;SLOAN, BLAKE;AND OTHERS;REEL/FRAME:023032/0205;SIGNING DATES FROM 20090729 TO 20090730 |
|
AS | Assignment |
Owner name: ON2 TECHNOLOGIES, LLC, CALIFORNIAFree format text: MERGER;ASSIGNOR:ON2 TECHNOLOGIES, INC.;REEL/FRAME:025411/0153Effective date: 20100219Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:ON2 TECHNOLOGIES, LLC;REEL/FRAME:025409/0880Effective date: 20101028 |
|
FEPP | Fee payment procedure |
Free format text: PAT HOLDER NO LONGER CLAIMS SMALL ENTITY STATUS, ENTITY STATUS SET TO UNDISCOUNTED (ORIGINAL EVENT CODE: STOL); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
REFU | Refund |
Free format text: REFUND - PAYMENT OF MAINTENANCE FEE, 12TH YR, SMALL ENTITY (ORIGINAL EVENT CODE: R2553); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
FPAY | Fee payment |
Year of fee payment: 12 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044127/0735Effective date: 20170929 |