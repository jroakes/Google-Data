CA2619076C - Scalable user clustering based on set similarity - Google Patents
Scalable user clustering based on set similarity Download PDFInfo
- Publication number
- CA2619076C CA2619076C CA2619076A CA2619076A CA2619076C CA 2619076 C CA2619076 C CA 2619076C CA 2619076 A CA2619076 A CA 2619076A CA 2619076 A CA2619076 A CA 2619076A CA 2619076 C CA2619076 C CA 2619076C
- Authority
- CA
- Canada
- Prior art keywords
- user
- hash
- values
- interest
- clusters
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Fee Related
Links
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06Q—INFORMATION AND COMMUNICATION TECHNOLOGY [ICT] SPECIALLY ADAPTED FOR ADMINISTRATIVE, COMMERCIAL, FINANCIAL, MANAGERIAL OR SUPERVISORY PURPOSES; SYSTEMS OR METHODS SPECIALLY ADAPTED FOR ADMINISTRATIVE, COMMERCIAL, FINANCIAL, MANAGERIAL OR SUPERVISORY PURPOSES, NOT OTHERWISE PROVIDED FOR
- G06Q30/00—Commerce
- G06Q30/02—Marketing; Price estimation or determination; Fundraising
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/95—Retrieval from the web
- G06F16/953—Querying, e.g. by the use of web search engines
- G06F16/9535—Search customisation based on user profiles and personalisation
Abstract
Methods and apparatus, including systems and computer program products, to provide clustering of users in which users are each represented as a set of elements representing items. In one aspect, a program operates to obtain a respective interest set for each of multiple users, each interest set representing items in which the respective user expressed interest; for each of the users, to determine k hash values of the respective interest set, wherein the i-th hash value is a minimum value under a corresponding i-th hash function; and to assign each of the multiple users to each of the respective k clusters established for the respective user, the i-th cluster being represented by the i-th hash value. The assignment of each of the users to k clusters is done without regard to the assignment of any of the other users to k clusters.
Description
SCALABLE USER CLUSTERING BASED ON SET SIMILARITY
BACKGROUND
The present invention relates to digital data processing and more particularly to grouping users of a computer application or system into clusters.
Grouping users into clusters is done for a variety of purposes. To achieve user personalization, for example, one of the well known techniques, collaborative filtering, involves clustering users and recommending to a user items that other users in the user's cluster have expressed interest in. Conventionally, a user may be taken to have expressed interest in an item in various ways, e.g., by clicking on it, purchasing it, or adding it to a shopping cart. The recommendation can take a variety of forms, e.g., presenting to the user as part of search results, showing as news stories the user may want to read, identifying items the user may want to purchase, and so on.
One way to achieve user clustering is to define a distance measure between two users and then cluster them using well-known clustering algorithms like k-means or hierarchical agglomerative clustering (HAC). However, such techniques have shortcomings. For example, HAC has a running time of 0(n2) which is prohibitive for n values that are hundreds of millions; and the k-means algorithm requires representing the mean of data points, which is not possible when the data points are sets.
SUMMARY
Embodiments of the present invention, in particular implementations, can provide scalable clustering of users where users are each represented as a set of elements representing items from a universe of items.
For example, given a universe of items that a user can select through interaction with a computer system, users may each express their interest in a respective subset of the items through various actions like clicking on an item, purchasing an item, adding an item to a shopping list, viewing an item, and so on.
Particular implementations of the invention cluster users (i.e., assign users to clusters) in such a way that users in the same cluster are likely to have a high overlap between their respective subsets of items.
According to another aspect of the invention, there is provided a system comprising: one or more computers; and a computer-readable medium coupled to the one or more computers having instructions stored thereon which, when executed by the one or more computers, cause the one or more computers to perform operations comprising: obtaining a set of data elements that represent items in which a particular user has expressed interest through interaction with one or more web applications; applying a fingerprint function and k distinct seed values to each of the data elements to generate a set of k minhash values, wherein k is an integer parameter, and wherein each minhash value corresponds to a respective data element of the set of data elements; and assigning the particular user to k clusters, each of which is represented by a respective corresponding one of the k minhash values.
A further aspect of the invention provides a computer-implemented method comprising: obtaining a set of data elements that represent items in which a particular user has expressed interest through interaction with one or more web applications; applying a fingerprint function and k distinct seed values to each of the data elements to generate a set of k minhash values, wherein k is an integer parameter, and wherein each minhash value corresponds to a respective data element of the set of data elements; and assigning, by one or more computers, the particular user to k clusters, each of which is represented by a respective corresponding one of the k minhash values.
There is also provided a computer readable storage medium encoded with a computer program, the program comprising instructions that when executed by data processing apparatus cause the data processing apparatus to perform operations comprising: obtaining a set of data elements that represent items in which a particular user has expressed interest through interaction with one or more web
BACKGROUND
The present invention relates to digital data processing and more particularly to grouping users of a computer application or system into clusters.
Grouping users into clusters is done for a variety of purposes. To achieve user personalization, for example, one of the well known techniques, collaborative filtering, involves clustering users and recommending to a user items that other users in the user's cluster have expressed interest in. Conventionally, a user may be taken to have expressed interest in an item in various ways, e.g., by clicking on it, purchasing it, or adding it to a shopping cart. The recommendation can take a variety of forms, e.g., presenting to the user as part of search results, showing as news stories the user may want to read, identifying items the user may want to purchase, and so on.
One way to achieve user clustering is to define a distance measure between two users and then cluster them using well-known clustering algorithms like k-means or hierarchical agglomerative clustering (HAC). However, such techniques have shortcomings. For example, HAC has a running time of 0(n2) which is prohibitive for n values that are hundreds of millions; and the k-means algorithm requires representing the mean of data points, which is not possible when the data points are sets.
SUMMARY
Embodiments of the present invention, in particular implementations, can provide scalable clustering of users where users are each represented as a set of elements representing items from a universe of items.
For example, given a universe of items that a user can select through interaction with a computer system, users may each express their interest in a respective subset of the items through various actions like clicking on an item, purchasing an item, adding an item to a shopping list, viewing an item, and so on.
Particular implementations of the invention cluster users (i.e., assign users to clusters) in such a way that users in the same cluster are likely to have a high overlap between their respective subsets of items.
According to another aspect of the invention, there is provided a system comprising: one or more computers; and a computer-readable medium coupled to the one or more computers having instructions stored thereon which, when executed by the one or more computers, cause the one or more computers to perform operations comprising: obtaining a set of data elements that represent items in which a particular user has expressed interest through interaction with one or more web applications; applying a fingerprint function and k distinct seed values to each of the data elements to generate a set of k minhash values, wherein k is an integer parameter, and wherein each minhash value corresponds to a respective data element of the set of data elements; and assigning the particular user to k clusters, each of which is represented by a respective corresponding one of the k minhash values.
A further aspect of the invention provides a computer-implemented method comprising: obtaining a set of data elements that represent items in which a particular user has expressed interest through interaction with one or more web applications; applying a fingerprint function and k distinct seed values to each of the data elements to generate a set of k minhash values, wherein k is an integer parameter, and wherein each minhash value corresponds to a respective data element of the set of data elements; and assigning, by one or more computers, the particular user to k clusters, each of which is represented by a respective corresponding one of the k minhash values.
There is also provided a computer readable storage medium encoded with a computer program, the program comprising instructions that when executed by data processing apparatus cause the data processing apparatus to perform operations comprising: obtaining a set of data elements that represent items in which a particular user has expressed interest through interaction with one or more web
2 =
applications; applying a fingerprint function and k distinct seed values to each of the data elements to generate a set of k minhash values, wherein k is an integer parameter, and wherein each minhash value corresponds to a respective data element of the set of data elements; and assigning the particular user to k clusters, each of which is represented by a respective corresponding one of the k minhash values.
In accordance with a still further aspect of the invention, there is provided a computer readable storage device, storing instructions that when executed by a processor cause a data processing apparatus to: obtain a respective interest set for each of multiple users, each interest set being a set of elements, each element representing a respective item in which the respective user has expressed interest through interaction with a data processing system; for each of the multiple users, apply an i-th hash function to each element of the interest set of the user to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and determine, from the function values obtained from the k hash functions, k hash values of the respective interest set, wherein the i-th hash value of the respective interest set is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, and where k is an integer greater than or equal to 1; and assign each of the multiple users to each of k clusters, the i-th cluster being represented by the i-th hash value of the respective interest set of the respective user, wherein the assignment of each of the multiple users to k clusters is done without regard to the assignment of any of the other users to k clusters.
According to another aspect of the invention, there is provided a computer readable storage device, storing instructions that when executed by a processor cause a data processing apparatus to: obtain an interest set for a user, the interest set being a set of elements, each element representing a respective item in which the user has expressed interest through interaction with a data processing system; apply an i-th hash function to each element of the interest set to obtain a 2a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and determine, from the function values obtained from the k hash functions, k hash values of the interest set, wherein the i-th hash value is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, where k is an integer greater than or equal to 1; and assign the user to each of k clusters, the i-th cluster being represented by the i-th hash value.
A further aspect of the invention provides a system, comprising: one or more machine-readable storage media storing a log of items selected by multiple users using a data processing system, the log of items identifying, for each of the multiple users, multiple items that the respective user has selected through interaction with the data processing system; one or more computers configured to use the log to generate a respective interest set for each of the multiple users, each interest set being a set of elements, each element representing a respective item in which the respective user has selected through interaction with the data processing system; one or more computers configured to apply, for each of the multiple users, an i-th hash function to each element of the interest set of the user to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and to determine, from the function values obtained from the k hash functions, k hash values of the respective interest set, wherein the i-th hash value of the respective interest set is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, and where k is an integer greater than or equal to 1; one or more computers configured to assign each of the multiple users to each of k clusters, the i-th cluster being represented by the i-th hash value of the respective interest set of the respective user, wherein the assignment of each of the multiple users to k clusters is done without regard to the assignment of any of the other users to k clusters; and one or more computers configured to execute a collaborative filtering computer program application to provide information to a first 2b =
user of the multiple users based on the assignment of the first user to one or more of the k clusters.
There is also provided a computer-implemented method comprising:
obtaining a respective interest set for each of multiple users, each interest set being a set of elements, each element representing a respective item in which the respective user has expressed interest through interaction with a data processing system;
for each of the multiple users, applying an i-th hash function to each element of the interest set of the user to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and determining, from the function values obtained from the k hash functions, k hash values of the respective interest set, wherein the i-th hash value of the respective interest set is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, where k is an integer greater than or equal to 1; and assigning each of the multiple users to each of k clusters established for the respective user, the i-th cluster being represented by the i-th hash value of the respective interest set of the respective user, wherein the assignment of each of the multiple users to k clusters is done without regard to the assignment of any of the other users to k clusters.
In accordance with a still further aspect of the invention, there is provided a computer-implemented method comprising: obtaining an interest set for a user, the interest set being a set of elements, each element representing a respective item in which the user has expressed interest through interaction with a data processing system; applying an i-th hash function to each element of the interest set to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and determining, from the function values obtained from the k hash functions, k hash values of the interest set, wherein the i-th hash value is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, where k is an integer greater than or equal to 1;
and 2c assigning the user to each of k clusters, the i-th cluster being represented by the i-th hash value.
According to another aspect of the invention, there is provided a system comprising: one or more computers; and a machine-readable storage medium coupled to the one or more computers having instructions stored thereon which, when executed by the one or more computers, cause the one or more computers to perform operations comprising: obtaining an interest set for a user, the interest set being a set of elements, each element representing a respective item in which the user has expressed interest through interaction with a data processing system;
applying an i-th hash function to each element of the interest set to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and determine, from the function values obtained from the k hash functions, k hash values of the interest set, wherein the i-th hash value is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, where k is an integer greater than or equal to 1; and assigning the user to each of k clusters, the i-th cluster being represented by the i-th hash value.
A further aspect of the invention provides a system comprising: one or more computers; and a machine-readable storage medium coupled to the one or more computers having instructions stored thereon which, when executed by the one or more computers, cause the one or more computers to perform operations comprising: obtaining a respective interest set for each of multiple users, each interest set being a set of elements, each element representing a respective item in which the respective user has expressed interest through interaction with a data processing system; for each of the multiple users, applying an i-th hash function to each element of the interest set of the user to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and determine, from the function values obtained from the k hash functions, k hash values of the respective interest set, wherein the i-th hash value of the respective interest set is a minimum value 2d =
among the function values obtained by applying the i-th hash function to the elements of interest set of the user, and where k is an integer greater than or equal to 1; and assigning each of the multiple users to each of k clusters, the i-th cluster being represented by the i-th hash value of the respective interest set of the respective user, wherein the assignment of each of the multiple users to k clusters is done without regard to the assignment of any of the other users to k clusters.
There is also provided a computer readable storage device, storing instructions that when executed by a processor cause a data processing apparatus to: store a log of items selected by multiple users using a data processing system, the log of items identifying, for each of the multiple users, multiple items that the respective user has selected through interaction with the data processing system;
one or more computers configured to use the log to generate a respective interest set for each of the multiple users, each interest set being a set of elements, each element representing a respective item in which the respective user has selected through interaction with the data processing system; one or more computers configured to apply, for each of the multiple users, an i-th hash function to each element of the interest set of the user to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and to determine, from the function values obtained from the k hash functions, k hash values of the respective interest set, wherein the i-th hash value of the respective interest set is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, and where k is an integer greater than or equal to 1; one or more computers configured to assign each of the multiple users to each of k clusters, the i-th cluster being represented by the i-th hash value of the respective interest set of the respective user, wherein the assignment of each of the multiple users to k clusters is done without regard to the assignment of any of the other users to k clusters; and one or more computers configured to execute a collaborative filtering computer program application to provide information to a first 2e user of the multiple users based on the assignment of the first user to one or more of the k clusters.
In accordance with a still further aspect of the invention, there is provided a system comprising: one or more computers; and a computer-readable medium coupled to the one or more computers having instructions stored thereon which, when executed by the one or more computers, cause the one or more computers to perform operations comprising: obtaining a vector that represents a particular user; applying k locality sensitive hash functions to the vector to generate a set of k hash values, wherein k is an integer parameter, and wherein each hash value corresponds to a respective component of the vector; and assigning the particular user to k clusters, each of which is represented by a respective corresponding one of the k hash values.
A further aspect of the invention provides a computer-implemented method comprising: obtaining a vector that represents a particular user;
applying k locality sensitive hash functions to the vector to generate a set of k hash values, wherein k is an integer parameter, and wherein each hash value corresponds to a respective component of the vector; and assigning the particular user to k clusters, each of which is represented by a respective corresponding one of the k hash values.
There is also provided a computer readable storage medium encoded with a computer program, the program comprising instructions that when executed by one or more computers cause the one or more computers to perform operations comprising: obtaining a vector that represents a particular user; applying k locality sensitive hash functions to the vector to generate a set of k hash values, wherein k is an integer parameter, and wherein each hash value corresponds to a respective component of the vector; and assigning the particular user to k clusters, each of which is represented by a respective corresponding one of the k hash values.
In another aspect, a computer program product in accordance with an implementation of the invention can cause data processing apparatus to obtain a respective interest set for each of multiple users, each interest set representing items 2f in which the respective user has expressed interest through interaction with a data processing system; for each of the multiple users, determine k hash values of the respective interest set, wherein the i-th hash value is a minimum value in the respective interest set under a corresponding i-th hash function, where i is an integer between 1 and k, and where k is an integer greater than or equal to 1; and assign each of the multiple users to each of the respective k clusters established for the respective user, the i-th cluster being represented by the i-th hash value, wherein the assignment of each of the multiple users to k clusters is done without regard to the assignment of any of the other users to k clusters.
Implementations can include one or more of the following features. The product can cause data processing apparatus to record actions expressing user interest in a log; and use the log to generate the interest sets for the multiple users.
The product can cause data processing apparatus to obtain a changed interest set for a first user of the multiple users; determine k hash values for the first user using the changed interest set; and assign the first user only to each of the respective k clusters represented by the k hash values determined using the changed interest set without changing the assignment of any the other multiple users to clusters.
In another aspect, a computer program product in accordance with an implementation of the invention can cause data processing apparatus to obtain an interest set for a user, the interest set representing items in which the user has expressed interest through interaction with a data processing system;
determine k hash values of the interest set, wherein the i-th hash value is a minimum value in the interest set under a corresponding i-th hash function, where i is an integer between 1 and k, and where k is an integer greater than or equal to 1; and assign the user of each of k clusters, the i-th cluster being represented by the i-th hash value.
2g Implementations can include one or more of the following features. The interest set has m elements; the i-th hash value is a minimum value of m applications of a one-way hash function, each of the m application hashing an i-th seed value and a respective one of the m elements of the interest set. The product can cause data processing apparatus to use the k user clusters to perform collaborative filtering for the user.
In another aspect, a system in accordance with an implementation of the invention includes a log of items selected by multiple users using a data processing system; a means for using a fingerprint function and the log of items to assign each of the multiple users to k clusters, where k is an integer greater than or equal to 1;
and a collaborative filtering computer program application operable to provide information to a first user of the multiple users based on the assignment of the first user to one or more of the k clusters.
Implementations can include one or more of the following features. The information includes at least one of a recommendation, a prediction, or a ranking.
In another aspect, a computer program product in accordance with an implementation of the invention can cause data processing apparatus to use an ordered set of k elements to identify a user of a data processing system, where k is an integer greater than 1, where each of the k elements corresponds to an element in an interest set, each element in the interest set representing an item in which the user has expressed interest through actions by the user using the data processing system.
Implementations can include one or more of the following features. The product can cause data processing apparatus to use the ordered set of k elements to identify the user in performing collaborative filtering for the user.
The collaborative filtering includes recommending items to the user or ranking items for the user. The product can cause data processing apparatus to receive input from the user in response to which input the data processing system removes elements from the interest set to generate a revised interest set; determine a revised ordered set of k elements where each of the k elements corresponds to an element in the revised interest set; and use the revised ordered set of k elements rather than the
applications; applying a fingerprint function and k distinct seed values to each of the data elements to generate a set of k minhash values, wherein k is an integer parameter, and wherein each minhash value corresponds to a respective data element of the set of data elements; and assigning the particular user to k clusters, each of which is represented by a respective corresponding one of the k minhash values.
In accordance with a still further aspect of the invention, there is provided a computer readable storage device, storing instructions that when executed by a processor cause a data processing apparatus to: obtain a respective interest set for each of multiple users, each interest set being a set of elements, each element representing a respective item in which the respective user has expressed interest through interaction with a data processing system; for each of the multiple users, apply an i-th hash function to each element of the interest set of the user to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and determine, from the function values obtained from the k hash functions, k hash values of the respective interest set, wherein the i-th hash value of the respective interest set is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, and where k is an integer greater than or equal to 1; and assign each of the multiple users to each of k clusters, the i-th cluster being represented by the i-th hash value of the respective interest set of the respective user, wherein the assignment of each of the multiple users to k clusters is done without regard to the assignment of any of the other users to k clusters.
According to another aspect of the invention, there is provided a computer readable storage device, storing instructions that when executed by a processor cause a data processing apparatus to: obtain an interest set for a user, the interest set being a set of elements, each element representing a respective item in which the user has expressed interest through interaction with a data processing system; apply an i-th hash function to each element of the interest set to obtain a 2a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and determine, from the function values obtained from the k hash functions, k hash values of the interest set, wherein the i-th hash value is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, where k is an integer greater than or equal to 1; and assign the user to each of k clusters, the i-th cluster being represented by the i-th hash value.
A further aspect of the invention provides a system, comprising: one or more machine-readable storage media storing a log of items selected by multiple users using a data processing system, the log of items identifying, for each of the multiple users, multiple items that the respective user has selected through interaction with the data processing system; one or more computers configured to use the log to generate a respective interest set for each of the multiple users, each interest set being a set of elements, each element representing a respective item in which the respective user has selected through interaction with the data processing system; one or more computers configured to apply, for each of the multiple users, an i-th hash function to each element of the interest set of the user to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and to determine, from the function values obtained from the k hash functions, k hash values of the respective interest set, wherein the i-th hash value of the respective interest set is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, and where k is an integer greater than or equal to 1; one or more computers configured to assign each of the multiple users to each of k clusters, the i-th cluster being represented by the i-th hash value of the respective interest set of the respective user, wherein the assignment of each of the multiple users to k clusters is done without regard to the assignment of any of the other users to k clusters; and one or more computers configured to execute a collaborative filtering computer program application to provide information to a first 2b =
user of the multiple users based on the assignment of the first user to one or more of the k clusters.
There is also provided a computer-implemented method comprising:
obtaining a respective interest set for each of multiple users, each interest set being a set of elements, each element representing a respective item in which the respective user has expressed interest through interaction with a data processing system;
for each of the multiple users, applying an i-th hash function to each element of the interest set of the user to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and determining, from the function values obtained from the k hash functions, k hash values of the respective interest set, wherein the i-th hash value of the respective interest set is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, where k is an integer greater than or equal to 1; and assigning each of the multiple users to each of k clusters established for the respective user, the i-th cluster being represented by the i-th hash value of the respective interest set of the respective user, wherein the assignment of each of the multiple users to k clusters is done without regard to the assignment of any of the other users to k clusters.
In accordance with a still further aspect of the invention, there is provided a computer-implemented method comprising: obtaining an interest set for a user, the interest set being a set of elements, each element representing a respective item in which the user has expressed interest through interaction with a data processing system; applying an i-th hash function to each element of the interest set to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and determining, from the function values obtained from the k hash functions, k hash values of the interest set, wherein the i-th hash value is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, where k is an integer greater than or equal to 1;
and 2c assigning the user to each of k clusters, the i-th cluster being represented by the i-th hash value.
According to another aspect of the invention, there is provided a system comprising: one or more computers; and a machine-readable storage medium coupled to the one or more computers having instructions stored thereon which, when executed by the one or more computers, cause the one or more computers to perform operations comprising: obtaining an interest set for a user, the interest set being a set of elements, each element representing a respective item in which the user has expressed interest through interaction with a data processing system;
applying an i-th hash function to each element of the interest set to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and determine, from the function values obtained from the k hash functions, k hash values of the interest set, wherein the i-th hash value is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, where k is an integer greater than or equal to 1; and assigning the user to each of k clusters, the i-th cluster being represented by the i-th hash value.
A further aspect of the invention provides a system comprising: one or more computers; and a machine-readable storage medium coupled to the one or more computers having instructions stored thereon which, when executed by the one or more computers, cause the one or more computers to perform operations comprising: obtaining a respective interest set for each of multiple users, each interest set being a set of elements, each element representing a respective item in which the respective user has expressed interest through interaction with a data processing system; for each of the multiple users, applying an i-th hash function to each element of the interest set of the user to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and determine, from the function values obtained from the k hash functions, k hash values of the respective interest set, wherein the i-th hash value of the respective interest set is a minimum value 2d =
among the function values obtained by applying the i-th hash function to the elements of interest set of the user, and where k is an integer greater than or equal to 1; and assigning each of the multiple users to each of k clusters, the i-th cluster being represented by the i-th hash value of the respective interest set of the respective user, wherein the assignment of each of the multiple users to k clusters is done without regard to the assignment of any of the other users to k clusters.
There is also provided a computer readable storage device, storing instructions that when executed by a processor cause a data processing apparatus to: store a log of items selected by multiple users using a data processing system, the log of items identifying, for each of the multiple users, multiple items that the respective user has selected through interaction with the data processing system;
one or more computers configured to use the log to generate a respective interest set for each of the multiple users, each interest set being a set of elements, each element representing a respective item in which the respective user has selected through interaction with the data processing system; one or more computers configured to apply, for each of the multiple users, an i-th hash function to each element of the interest set of the user to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and to determine, from the function values obtained from the k hash functions, k hash values of the respective interest set, wherein the i-th hash value of the respective interest set is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, and where k is an integer greater than or equal to 1; one or more computers configured to assign each of the multiple users to each of k clusters, the i-th cluster being represented by the i-th hash value of the respective interest set of the respective user, wherein the assignment of each of the multiple users to k clusters is done without regard to the assignment of any of the other users to k clusters; and one or more computers configured to execute a collaborative filtering computer program application to provide information to a first 2e user of the multiple users based on the assignment of the first user to one or more of the k clusters.
In accordance with a still further aspect of the invention, there is provided a system comprising: one or more computers; and a computer-readable medium coupled to the one or more computers having instructions stored thereon which, when executed by the one or more computers, cause the one or more computers to perform operations comprising: obtaining a vector that represents a particular user; applying k locality sensitive hash functions to the vector to generate a set of k hash values, wherein k is an integer parameter, and wherein each hash value corresponds to a respective component of the vector; and assigning the particular user to k clusters, each of which is represented by a respective corresponding one of the k hash values.
A further aspect of the invention provides a computer-implemented method comprising: obtaining a vector that represents a particular user;
applying k locality sensitive hash functions to the vector to generate a set of k hash values, wherein k is an integer parameter, and wherein each hash value corresponds to a respective component of the vector; and assigning the particular user to k clusters, each of which is represented by a respective corresponding one of the k hash values.
There is also provided a computer readable storage medium encoded with a computer program, the program comprising instructions that when executed by one or more computers cause the one or more computers to perform operations comprising: obtaining a vector that represents a particular user; applying k locality sensitive hash functions to the vector to generate a set of k hash values, wherein k is an integer parameter, and wherein each hash value corresponds to a respective component of the vector; and assigning the particular user to k clusters, each of which is represented by a respective corresponding one of the k hash values.
In another aspect, a computer program product in accordance with an implementation of the invention can cause data processing apparatus to obtain a respective interest set for each of multiple users, each interest set representing items 2f in which the respective user has expressed interest through interaction with a data processing system; for each of the multiple users, determine k hash values of the respective interest set, wherein the i-th hash value is a minimum value in the respective interest set under a corresponding i-th hash function, where i is an integer between 1 and k, and where k is an integer greater than or equal to 1; and assign each of the multiple users to each of the respective k clusters established for the respective user, the i-th cluster being represented by the i-th hash value, wherein the assignment of each of the multiple users to k clusters is done without regard to the assignment of any of the other users to k clusters.
Implementations can include one or more of the following features. The product can cause data processing apparatus to record actions expressing user interest in a log; and use the log to generate the interest sets for the multiple users.
The product can cause data processing apparatus to obtain a changed interest set for a first user of the multiple users; determine k hash values for the first user using the changed interest set; and assign the first user only to each of the respective k clusters represented by the k hash values determined using the changed interest set without changing the assignment of any the other multiple users to clusters.
In another aspect, a computer program product in accordance with an implementation of the invention can cause data processing apparatus to obtain an interest set for a user, the interest set representing items in which the user has expressed interest through interaction with a data processing system;
determine k hash values of the interest set, wherein the i-th hash value is a minimum value in the interest set under a corresponding i-th hash function, where i is an integer between 1 and k, and where k is an integer greater than or equal to 1; and assign the user of each of k clusters, the i-th cluster being represented by the i-th hash value.
2g Implementations can include one or more of the following features. The interest set has m elements; the i-th hash value is a minimum value of m applications of a one-way hash function, each of the m application hashing an i-th seed value and a respective one of the m elements of the interest set. The product can cause data processing apparatus to use the k user clusters to perform collaborative filtering for the user.
In another aspect, a system in accordance with an implementation of the invention includes a log of items selected by multiple users using a data processing system; a means for using a fingerprint function and the log of items to assign each of the multiple users to k clusters, where k is an integer greater than or equal to 1;
and a collaborative filtering computer program application operable to provide information to a first user of the multiple users based on the assignment of the first user to one or more of the k clusters.
Implementations can include one or more of the following features. The information includes at least one of a recommendation, a prediction, or a ranking.
In another aspect, a computer program product in accordance with an implementation of the invention can cause data processing apparatus to use an ordered set of k elements to identify a user of a data processing system, where k is an integer greater than 1, where each of the k elements corresponds to an element in an interest set, each element in the interest set representing an item in which the user has expressed interest through actions by the user using the data processing system.
Implementations can include one or more of the following features. The product can cause data processing apparatus to use the ordered set of k elements to identify the user in performing collaborative filtering for the user.
The collaborative filtering includes recommending items to the user or ranking items for the user. The product can cause data processing apparatus to receive input from the user in response to which input the data processing system removes elements from the interest set to generate a revised interest set; determine a revised ordered set of k elements where each of the k elements corresponds to an element in the revised interest set; and use the revised ordered set of k elements rather than the
3 initial ordered set of k elements to identify the user. The ordered set of k elements =
identifies the user as belonging to each of k user clusters. The product can cause data processing apparatus to record actions expressing user interest in a log;
and use the log to generate the interest set for the user. The data processing system includes a web site; and the interest set for the user includes representations of one or more items the user has clicked on in a web page, items the user has purchased from an on-line retailer, or items the user has added to a shopping cart. The actions by the user expressing interest in items include actions implicitly expressing interest. The actions by the user expressing interest in items include actions expressly expressing interest. The user is an individual identified by a user logon. The user is an individual identified by a cookie. The user is one or more individuals having an observed attribute in common, where the attribute is an attribute disclosed to the data processing system by each of the one or more individuals. The user is a session of an individual interacting with the data processing system. Each element in the interest set is an item that the user has selected in interaction with the data processing system.
In further aspects, implementations of the invention can includes methods corresponding to the foregoing programs and systems, and programs corresponding to the foregoing systems.
Some embodiments of the invention can be implemented to realize one or more of the following advantages. Clustering calculations are scalable. Calculations can be performed for applications used by hundreds of millions of individual users, where individual users can have tens, hundreds, or more items represented in their interest sets.
Clustering can be performed where the clustered entities are represented by subsets of a universe of items. The universe need not be predefined. Clustering is based on a set similarity measure. Clustering of new users occurs without changing any existing clustering. The clustering of one user occurs without consideration of how other users were clustered or are being clustered. However, some global values, e.g., seed values or permutations, may be shared among clusterings. By changing their selections ¨ e.g., by deleting or adding to item selections, in effect ¨
users can change the clusters to which they are assigned when clusters are subsequently
identifies the user as belonging to each of k user clusters. The product can cause data processing apparatus to record actions expressing user interest in a log;
and use the log to generate the interest set for the user. The data processing system includes a web site; and the interest set for the user includes representations of one or more items the user has clicked on in a web page, items the user has purchased from an on-line retailer, or items the user has added to a shopping cart. The actions by the user expressing interest in items include actions implicitly expressing interest. The actions by the user expressing interest in items include actions expressly expressing interest. The user is an individual identified by a user logon. The user is an individual identified by a cookie. The user is one or more individuals having an observed attribute in common, where the attribute is an attribute disclosed to the data processing system by each of the one or more individuals. The user is a session of an individual interacting with the data processing system. Each element in the interest set is an item that the user has selected in interaction with the data processing system.
In further aspects, implementations of the invention can includes methods corresponding to the foregoing programs and systems, and programs corresponding to the foregoing systems.
Some embodiments of the invention can be implemented to realize one or more of the following advantages. Clustering calculations are scalable. Calculations can be performed for applications used by hundreds of millions of individual users, where individual users can have tens, hundreds, or more items represented in their interest sets.
Clustering can be performed where the clustered entities are represented by subsets of a universe of items. The universe need not be predefined. Clustering is based on a set similarity measure. Clustering of new users occurs without changing any existing clustering. The clustering of one user occurs without consideration of how other users were clustered or are being clustered. However, some global values, e.g., seed values or permutations, may be shared among clusterings. By changing their selections ¨ e.g., by deleting or adding to item selections, in effect ¨
users can change the clusters to which they are assigned when clusters are subsequently
4 calculated or recalculated. Cluster membership for a new user or a user with modified interest set can be calculated without using data from other users.
Clustering calculations are not limited to clustering users who are individuals. For example, clustering can be done effectively whether each user is an individual, each user is an aggregations of individual, each user is an interaction with a system, or some combination of them.
The details of one or more embodiments of the invention are set forth in the accompanying drawings and the description below. Other features and advantages will become apparent from the description, the drawings, and the claims.
= claims.
BRIEF DESCRIPTION OF THE DRAWINGS
FIG. 1 is a flowchart illustrating a first method for clustering users in accordance with an embodiment of the invention.
FIG. 2 is a flowchart illustrating a second method for clustering users in accordance with an embodiment of the invention.
FIG. 3 is a flowchart illustrating operation of a recommender system using clusters of users in accordance with an embodiment of the invention.
FIG. 4 is a schematic diagram illustrating a news service with a new recommender engine in accordance with one embodiment of the invention.
Like reference numbers and designations in the various drawings indicate like elements.
DETAILED DESCRIPTION
FIG. 1 illustrates the following logical description of a minhash method for clustering users. While this method can be implemented, it is being presented here principally for explanatory purposes. A practical implementation for clustering users in a system that has a very large number of users will be described below in reference to FIG. 2.
As shown in FIG. 1, the inputs for the minhash method are a universe of items 110, denoted U; a set of k permutations 112, denoted pl, p2, pk; and an interest set 114 for a user, denoted X_A for user A.
Clustering calculations are not limited to clustering users who are individuals. For example, clustering can be done effectively whether each user is an individual, each user is an aggregations of individual, each user is an interaction with a system, or some combination of them.
The details of one or more embodiments of the invention are set forth in the accompanying drawings and the description below. Other features and advantages will become apparent from the description, the drawings, and the claims.
= claims.
BRIEF DESCRIPTION OF THE DRAWINGS
FIG. 1 is a flowchart illustrating a first method for clustering users in accordance with an embodiment of the invention.
FIG. 2 is a flowchart illustrating a second method for clustering users in accordance with an embodiment of the invention.
FIG. 3 is a flowchart illustrating operation of a recommender system using clusters of users in accordance with an embodiment of the invention.
FIG. 4 is a schematic diagram illustrating a news service with a new recommender engine in accordance with one embodiment of the invention.
Like reference numbers and designations in the various drawings indicate like elements.
DETAILED DESCRIPTION
FIG. 1 illustrates the following logical description of a minhash method for clustering users. While this method can be implemented, it is being presented here principally for explanatory purposes. A practical implementation for clustering users in a system that has a very large number of users will be described below in reference to FIG. 2.
As shown in FIG. 1, the inputs for the minhash method are a universe of items 110, denoted U; a set of k permutations 112, denoted pl, p2, pk; and an interest set 114 for a user, denoted X_A for user A.
5 The permutations are permutations over U, and they are picked uniformly from the set of all permutations over U, so that each permutation is as likely to be picked as any other. The permutations are each a one-to-one mapping (a bijection) of U onto U. Such permutations can only be realized if U is fixed and enumerable.
The integer k is a parameter of choice. Generally the value of k will be in the range of 5 to 10. However, it can be any integer 1 or greater. The method will assign k clusters to the user, denoted Cl, Ck. After the permutations are selected and used to assign users to clusters, if the permutations are changed, all the clusterings must be recalculated.
The interest set is a set of elements representing items from the universe U.
For the uses now being described, in which the elements are the items themselves, the interest set is a set of selections by the user, X_A, of items from the universe U.
These can be selected as described above. For convenience in this specification, the term "item" can refer either to an element of the interest set or an actual selection by a user, and the sense will be clear from the context.
Using this data, k hash values are determined (step 120) for the user, one for each permutation. For permutation pi, the hash value is denoted by hi(X_A).
The hash value for permutation pi is the minimum element from X_A under permutation pi, i.e., the minhash value. The minimum can be determined from the values of the elements or from an ordering of U.
Each minhash value serves as the identifier for a cluster, and the user is assigned to each of the clusters. The user will belong to k clusters, the i-th cluster being identified by the i-th minhash value. Thus, for a given permutation pi, two users belong to the same cluster if and only if the minhash values of the interest sets under this permutation are identical.
This minhashing technique, associating a hash value for each data element, is one of a class of techniques, called the locality sensitive hashing techniques, that have the desirable property that two data elements have the same hash value with a certain probability that is directly proportional to the similarly between the two data elements. In the present case, if the similarity between two users A, B
(represented by their interest-sets X_A and X_B) is defined as size of (X_A intersect X B)
The integer k is a parameter of choice. Generally the value of k will be in the range of 5 to 10. However, it can be any integer 1 or greater. The method will assign k clusters to the user, denoted Cl, Ck. After the permutations are selected and used to assign users to clusters, if the permutations are changed, all the clusterings must be recalculated.
The interest set is a set of elements representing items from the universe U.
For the uses now being described, in which the elements are the items themselves, the interest set is a set of selections by the user, X_A, of items from the universe U.
These can be selected as described above. For convenience in this specification, the term "item" can refer either to an element of the interest set or an actual selection by a user, and the sense will be clear from the context.
Using this data, k hash values are determined (step 120) for the user, one for each permutation. For permutation pi, the hash value is denoted by hi(X_A).
The hash value for permutation pi is the minimum element from X_A under permutation pi, i.e., the minhash value. The minimum can be determined from the values of the elements or from an ordering of U.
Each minhash value serves as the identifier for a cluster, and the user is assigned to each of the clusters. The user will belong to k clusters, the i-th cluster being identified by the i-th minhash value. Thus, for a given permutation pi, two users belong to the same cluster if and only if the minhash values of the interest sets under this permutation are identical.
This minhashing technique, associating a hash value for each data element, is one of a class of techniques, called the locality sensitive hashing techniques, that have the desirable property that two data elements have the same hash value with a certain probability that is directly proportional to the similarly between the two data elements. In the present case, if the similarity between two users A, B
(represented by their interest-sets X_A and X_B) is defined as size of (X_A intersect X B)
6 divided by size of (X _A union X_B), then the minhashing technique has the property that the probability (defined over the set of permutations from which was chosen the actual permutation used) that the minhash values for the two users A and B are the same is equal to the similarity measure defined above. Thus, minhashing achieves a probabilistic clustering where users fall into the same cluster with probability equal to their similarity.
Because k clusters are identified (step 122), if two users have probability p (0 p :5 1) of being in the same cluster, then even if they do not get clustered together in one of the clusterings, they will get clustered together in a fraction p of the clusterings. This gives a smoothing effect such that each user uniformly belongs to k different clusterings and for each clustering gets clustered with other similar users. The parameter k should be chosen to optimize the tradeoff between efficiency (lower k gives better efficiency) and quality (higher k gives better quality). Although not strictly necessary, the number k will typically be a constant;
and a small value like 10 can provide good results.
This minhash clustering method is very scalable and has several other advantages. For example, the running time of the method is linear in the size of the data, i.e., the total amount of (user, item) pairs.
Also, each user is clustered in isolation, i.e., independent of all other users.
This is particularly interesting in the web domain where users are added, deleted and updated all the time. An advantage that follows from this is that several cases can be handled easily and incrementally that are difficult for conventional clustering algorithms. If a user is identified as spammy, i.e., as expressing sham interest for the purpose of affecting a system that uses the clustering, the user can be deleted without affecting any other user, i.e., the rest of the clustering does not change.
Also, if a user who had kept her selections private decides to disclose her selections, or if a new user is added to the system, she can be added to clusters without reclustering the other users. Finally, if a user decides to change his profile by, in effect, editing his interest set, the clustering for the user can be updated in real time, as opposed to update by a batch process, to take this into account, without affecting the clustering of any other user.
Because k clusters are identified (step 122), if two users have probability p (0 p :5 1) of being in the same cluster, then even if they do not get clustered together in one of the clusterings, they will get clustered together in a fraction p of the clusterings. This gives a smoothing effect such that each user uniformly belongs to k different clusterings and for each clustering gets clustered with other similar users. The parameter k should be chosen to optimize the tradeoff between efficiency (lower k gives better efficiency) and quality (higher k gives better quality). Although not strictly necessary, the number k will typically be a constant;
and a small value like 10 can provide good results.
This minhash clustering method is very scalable and has several other advantages. For example, the running time of the method is linear in the size of the data, i.e., the total amount of (user, item) pairs.
Also, each user is clustered in isolation, i.e., independent of all other users.
This is particularly interesting in the web domain where users are added, deleted and updated all the time. An advantage that follows from this is that several cases can be handled easily and incrementally that are difficult for conventional clustering algorithms. If a user is identified as spammy, i.e., as expressing sham interest for the purpose of affecting a system that uses the clustering, the user can be deleted without affecting any other user, i.e., the rest of the clustering does not change.
Also, if a user who had kept her selections private decides to disclose her selections, or if a new user is added to the system, she can be added to clusters without reclustering the other users. Finally, if a user decides to change his profile by, in effect, editing his interest set, the clustering for the user can be updated in real time, as opposed to update by a batch process, to take this into account, without affecting the clustering of any other user.
7 FIG. 2 illustrates a practical implementation for clustering users in a system that has a very large number of users, up to hundreds of millions, and possibly hundreds or more items in the interest set of each user, over a universe of items that is not actually or practically enumerable. This implementation uses the MapReduce programming model and technology, which will be described later.
The inputs to this implementation are a collection 210 of data elements (e.g., result click logs, purchase logs, etc.), denoted D, stored in no particular order, an ordered set of k seed values 212, denoted sl, s2, sk, and a fingerprint function 214. Each data element can be considered a pair (user, item) indicating that a particular user has expressed interest in a certain item. Optionally, a suffix can be added to the root form of an item to indicate whether the data element refers to the first, second, etc. instance of the user expressing interest, to capture the how often the user has done so. Advantageously, the form of the item is a text string, so that the item can easily represent any user action expressing interest through any web application ¨ i.e., through any application that uses a web browser to present a user interface to the user.
An action by which a user expresses interest can be express ¨ e.g., when the user provides information to the system indicating the user's interest in the form of an answer to a on-line questionnaire, for example; or they can be implicit ¨
e.g., when the user selects a news story to read on a news site.
The k seed values sl, s2, sk are numbers considered as strings of bits chosen to appear random, e.g., so that the bits in the binary representation are uniformly "0" or "1".
The fingerprint function maps a seed value and an item (from an interest set) to a large number, e.g., a 64-bit or 128-bit number.
In one implementation, the seed values are generated using the unix rand function to generate k 32-bit integer values. The rand function may have to be called more than once to generate a single seed. In this implementation, the fingerprint function implements the MD5 one-way hash algorithm, and hashes the seed value concatenated with the item (which generally will be a text string or binary data) to produce a 128-bit value.
The inputs to this implementation are a collection 210 of data elements (e.g., result click logs, purchase logs, etc.), denoted D, stored in no particular order, an ordered set of k seed values 212, denoted sl, s2, sk, and a fingerprint function 214. Each data element can be considered a pair (user, item) indicating that a particular user has expressed interest in a certain item. Optionally, a suffix can be added to the root form of an item to indicate whether the data element refers to the first, second, etc. instance of the user expressing interest, to capture the how often the user has done so. Advantageously, the form of the item is a text string, so that the item can easily represent any user action expressing interest through any web application ¨ i.e., through any application that uses a web browser to present a user interface to the user.
An action by which a user expresses interest can be express ¨ e.g., when the user provides information to the system indicating the user's interest in the form of an answer to a on-line questionnaire, for example; or they can be implicit ¨
e.g., when the user selects a news story to read on a news site.
The k seed values sl, s2, sk are numbers considered as strings of bits chosen to appear random, e.g., so that the bits in the binary representation are uniformly "0" or "1".
The fingerprint function maps a seed value and an item (from an interest set) to a large number, e.g., a 64-bit or 128-bit number.
In one implementation, the seed values are generated using the unix rand function to generate k 32-bit integer values. The rand function may have to be called more than once to generate a single seed. In this implementation, the fingerprint function implements the MD5 one-way hash algorithm, and hashes the seed value concatenated with the item (which generally will be a text string or binary data) to produce a 128-bit value.
8
9 PCT/US2006/031868 The seed values and the fingerprint function correspond logically to the k permutations p1,... pk, described in reference to FIG. 1, and provide an ordering and permutation of items without requiring an enumerable universe of items.
The collection D is processed using the MapReduce framework, which will be described later.
In the map phase 220, for each (user, item) pair, a (key, value) pair is output with key=user and value=item, in a distributed fashion.
In the reduce phase 222, all such (key, value) pairs with the same key (user) are collected and presented to the reduce routine, which is run once for each distinct key (user) value, in a distributed fashion.
The reduce routine (for a particular user) processes all the items in the interest set of the user; for this description, these m items will be denoted il, i2, im. For each seed value si, the reduce routine computes m values (one for each item) that are the fingerprint of the item and the seed value, i.e., fingerprint (si, ii).
The minimum of these fingerprints, over the m items, is computed and that becomes the i-th minhash value, corresponding to the i-th seed si.
A user is represented by the k minhash values thus computed. These represent the k clusters that the user belongs to, and the user is said to be assigned to these clusters.
As shown in FIG. 3, a recommender computer program application can use user clusters generated according to any of the methods described in this specification.
In one implementation, a system records selections made by its users in a log (step 310). The log can be stored in any form, e.g., as lines of unstructured text or as records in a structured database; and it can be stored on any computer-readable medium, e.g., on disk drives on a file server. The system can be a web site serving search results, advertisements, purchase selections, simple links to pages within or outside the site, or other items. The selections that are logged can be, but need not be, all the selections made by users of the system. For example, an application may only be interested in selections of news sites rather than all sites, or selections of items for purchase rather than all items viewed. In addition, the system can maintain multiple logs of different kinds of selections for different recommender applications, which can calculate their own respective user clusterings. For example, in a method using seeds and fingerprint functions, each separate clustering can have its own distinct seed sequence and fingerprint function.
The system can identify individuals as users by user registration and log on, by cookies, or otherwise. Optionally, a system can treat a user session as a user for purposes of clustering if it is undesirable to maintain information about individual users across multiple sessions of interaction with the system. Cookies can also be used to maintain sessions. (A cookie is a packet of information sent by a server to a web browser and then sent back by the browser each time it accesses that server.) Optionally, a system can allow individuals to determine whether or not they participate in logging, i.e., to include themselves in, or to exclude themselves from, logging of their selections.
Optionally, a system can treat some attribute or combination of attributes of an individual interacting with the system as a user. The attribute can be observed by the system, e.g., the lP (Internet Protocol) address being used or the language being used, or it can be information provided by the individual, e.g., a city or country of residence, or a subscription to service provided by the system. Thus, for example, a system could treat individuals from Cupertino as one user and individuals from Redmond as a different user. An advantage of such collective clustering is that it allows a system to provide a degree of personalization without requiring login or registration. In addition, a system can optionally either do clustering for all kinds of users ¨ e.g., individuals and aggregations ¨ together in the same clusters, or it can establish different clusters for different kinds of users.
The selections made by the users of the system can be simple selections or, optionally, composite selections. A composite selection is a sequence of selections, for example, a sequence of navigating from to a first web page and then directly to a second web page. A web page is a resource, typically an HTML (Hypertext Markup Language) document, served by a web server to a web browser. A web server is a computer program that accepts HTTP (Hypertext Transfer Protocol) requests, typically received over a network, and provides an HTTP responses to the requester.
The HTTP response typically consists of an HTML document, but can also be a text file, an image, or some other type of document.
Based on the logged selections, users are each assigned to k clusters (step 312), as described elsewhere in this specification. This clustering of users can be updated as new users appear in the system and as selections are added to or removed from the log. Optionally, under some circumstances, not all users are assigned to k clusters. In such circumstances, one or more, but fewer than k, cluster identifiers can be obtained to find recommendations for a particular user. For example, if a system receives a request to provide a recommendation for a new user who has a set of selections, the system can optionally calculate the identity of a first cluster using the selections, use that to find recommendations, continue and similarly calculate and use a second cluster, and so on, until a system-defined sufficient number of recommendations has been found.
The recommender application can then use the user clusters to make a recommendation for a particular user (step 314). Any method for making recommendations based on grouping users each into a single cluster can be used with the multiple clusters described here. For example, such a method can be applied k times and the k results merged to provide a union set of recommended items for the user. Alternatively, the number of different results in which an item appears can be used to rank the items. Or, a few items from each of the cluster-based recommendation results can be provided to the user, to give the user a diversity of recommendations. The multiple clusters a user is assigned to may reflect different kinds of interests the user has had when using the system, and so giving the user such a diversity of recommendations makes it more likely that the recommendations include something from the user's current interest than if only a single cluster were used.
A recommender application is one example of collaborative filtering, and the methods of user clustering described in this specification can be applied to other kinds of collaborative filtering as well. In collaborative filtering, users are found who are similar to a current user, and from their preferences or behaviors, a ranking, recommendation or prediction is made for the current user. By grouping users into multiple clusters, a system implicitly identifies the users' preferences and groups items through the grouping of users.
As illustrated schematically in FIG. 4, the techniques for assigning users to clusters described in this specification can be implemented in a news recommender engine 410 that can provide recommendations of news articles to be presented to users 402a, 402b based on selections of articles previously made by those users.
The users 402a, 402b communicate through their respective browsers with one or more web servers 430 through a data communications network 404, for example, a local, wide-area, or virtual private network, or the Internet. The news service 420 is implemented as a computer program hosted on the server or servers 430 and serves web pages to the users 402a, 402b in response to the users' requests. Among the pages served by the news service 420 are pages from which a user can select one or multiple news articles for display by the user's browser. In response to user selections, the news service 420 serves the user selected articles (functionality 424).
If the news recommender engine 410 has provided recommendations for a particular user, the news service can serve pages showing articles for selection by that user according to the recommendations for the user (functionality 422).
The news recommender engine 410 is implemented as a computer program running on the server or servers 430. The news recommender engine 410 receives selections from the users of the news service 420 and logs those selections (functionality 412) in a log 440. Using the information in the log 440, the engine assigns users to clusters (functionality 414) as described elsewhere in the specification. For any particular user who has been assigned to a cluster, the engine determines recommendations based on the clusters to which that user is assigned (functionality 416) and provides those recommendations to the news service 420.
In determining what recommendations to make for a particular user, the engine considers what selections were made by other users who are assigned to the same cluster or clusters as the particular user. Of the possible recommendations, the engine can optionally eliminate news articles that the user has already selected. The engine or the service can rank the recommendations on a variety of criteria, including the number of times a news article has been selected by other users assigned to the clusters to which the user is assigned, how recent the news article is, the number of sources having articles on the subject of the news article in question, and so on. In this way, a news service can provide a personalized offering and ranking of news articles to its users.
In one implementation, the news recommender engine 410 identifies users as individuals and so requires users to log in and register to get personalized recommendations. In other implementations, users can be identified implicitly or as collective groups, as described elsewhere in this specification.
A recommender engine can be implemented along these lines to support personalization of other kinds of services, for example, services offering selections of images, blogs, or shopping information.
Although illustrated in FIG. 4 as separate modules, the functionalities of the engine and the service need not be implemented in this way; in particular, the engine can be implemented as part of the implementation of the service.
The following paragraphs describe the MapReduce programming model and an implementation of the model for processing and generating large data sets.
The model and its library implementation will both be referred to as MapReduce.
Using MapReduce, programmers specify a map function that processes a key/value pair to generate a set of intermediate key/value pairs, and a reduce function that merges all intermediate values associated with the same intermediate key. Programs written in this functional style can automatically be parallelized and executed on a large cluster of commodity computers. The runtime system or framework can be implemented to partition the input data, schedule the program's execution across a set of machines, handle machine failures, and manage the required inter-machine communication.
A MapReduce computation takes a set of input key/value pairs, and produces a set of output key/value pairs. The user expresses the computation as two functions: Map and Reduce.
Map, written by the user, takes an input key/value pair and produces a set of intermediate key/value pairs. The MapReduce library groups together all intermediate values associated with the same intermediate key I and passes them to the Reduce function.
The Reduce function, also written by the user, accepts an intermediate key I
and a set of values for that key. It merges together these values to form a possibly smaller set of values. Typically just zero or one output value is produced for each Reduce invocation. The intermediate values are supplied to the user's reduce function through an iterator. In this way lists of values that are too large to fit in memory can be handled.
Consider the problem of counting the number of occurrences of each word in a large collection of documents. The user would write code similar to the following pseudo-code:
map(String key, String value):
// key: document name // value: document contents for each word w in value:
EmitIntermediate(w, "1");
reduce (String key, Iterator values):
// key: a word // values: a list of counts int result = 0;
for each v in values:
result += ParseInt(v);
Emit(AsString(result));
The map function emits each word plus an associated count of occurrences (just '1' in this simple example). The reduce function sums together all counts emitted for a particular word.
In one implementation, to perform a computation, the user writes code to fill in a specification object with the names of the input and output files, and optional tuning parameters. The user then invokes a MapReduce function, passing it the specification object. The user's code is linked together with the MapReduce library.
Even though the previous pseudo-code is written in terms of string inputs and outputs, conceptually the map and reduce functions supplied by the user have associated types:
map (kl, v1) list(k2, v2) reduce (k2, list(v2)) ---* list(v2) That is, the input keys and values are drawn from a different domain than the output keys and values. Furthermore, the intermediate keys and values are from the same domain as the output keys and values.
Many different implementations of the MapReduce model are possible.
The following paragraphs describe an implementation targeted to a computing environment having large clusters of commodity personal computers connected together with switched Ethernet. In this environment machines typically have 2-4 GB (gigabytes) of memory per machine, a cluster has hundreds or thousands of machines, storage is provided by inexpensive IDE (Integrated Drive Electronics standard) disks attached directly to individual machines, a distributed file system is used to manage the data stored on these disks that uses replication to provide availability and reliability on top of unreliable hardware, and users submit jobs to a scheduling system. Each job consists of a set of tasks, and is mapped by the scheduler of the scheduling system to a set of available machines within a cluster.
The Map invocations are distributed across multiple machines by automatically partitioning the input data into a set of M splits. The input splits can be processed in parallel by different machines. Reduce invocations are distributed by partitioning the intermediate key space into R pieces using a partitioning function (e.g., hash(key) mod R). The number of partitions (R) and the partitioning function are specified by the user.
When the user program calls the MapReduce function, the following sequence of actions occurs:
1. The MapReduce library in the user program first splits the input files into M pieces of typically 16 megabytes to 64 megabytes (MB) per piece (controllable by the user). It then starts up many copies of the program on a cluster of machines.
2. One of the copies of the program is the master. The rest are workers that are assigned work by the master. There are M map tasks and R reduce tasks to assign. The master picks idle workers and assigns each one a map task or a reduce task.
3. A worker assigned a map task reads the contents of the corresponding input split. It parses key/value pairs out of the input data and passes each pair to the user-defined Map function. The intermediate key/value pairs produced by the Map function are buffered in memory.
4. Periodically, the buffered pairs are written to local disk, partitioned into R regions by the partitioning function. The locations of these buffered pairs on the local disk are passed back to the master, who is responsible for forwarding these locations to the reduce workers.
5. When a reduce worker is notified by the master about these locations, it uses remote procedure calls to read the buffered data from the local disks of the map workers. When a reduce worker has read all intermediate data, it sorts it by the intermediate keys so that all occurrences of the same key are grouped together. The sorting is useful because typically many different keys map to the same reduce task.
If the amount of intermediate data is too large to fit in memory, an external sort is used.
6. The reduce worker iterates over the sorted intermediate data and for each unique intermediate key encountered, it passes the key and the corresponding set of intermediate values to the user's Reduce function. The output of the Reduce function is appended to a final output file for this reduce partition.
7. When all map tasks and reduce tasks have been completed, the master wakes up the user program. At this point, the MapReduce call in the user program returns back to the user code.
After successful completion, the output of the execution is available in the R
output files (one per reduce task, with file names as specified by the user).
Users do not need to combine these R output files into one file; they can pass these files as input to another MapReduce call, or use them from another distributed application that is able to deal with input that is partitioned into multiple files.
The master keeps several data structures. For each map task and reduce task, it stores the state (idle, in-progress, or completed) and the identity of the worker machine (for non-idle tasks).
The master is the conduit through which the location of intermediate file regions is propagated from map tasks to reduce tasks. Therefore, for each completed map task, the master stores the locations and sizes of the R intermediate file regions produced by the map task. Updates to this location and size information are received as map tasks are completed. The information is pushed incrementally to workers that have in-progress reduce tasks.
Because this implementation MapReduce library is designed to process very large amounts of data using hundreds or thousands of machines, the library tolerates machine failures gracefully.
The master pings every worker periodically. If no response is received from a worker in a certain amount of time, the master marks the worker as failed.
Any map tasks completed by the worker are reset back to their initial idle state, and therefore become eligible for scheduling on other workers. Similarly, any map task or reduce task in progress on a failed worker is also reset to idle and becomes eligible for rescheduling.
Completed map tasks are re-executed on a failure because their output is stored on the local disk(s) of the failed machine and is therefore inaccessible.
Completed reduce tasks do not need to be re-executed because their output is stored in a global file system.
When a map task is executed first by worker A and then later executed by worker B (because A failed), all workers executing reduce tasks are notified of the re-execution. Any reduce task that has not already read the data from worker A
will read the data from worker B.
Because there is only a single master, its failure is unlikely; therefore the MapReduce computation is aborted if the master fails. Users or user programs can check for this condition and retry the MapReduce operation if they desire.
When the user supplied map and reduce operators are deterministic functions of their input values, this distributed implementation produces the same output as would have been produced by a non-faulting sequential execution of the entire program. Each in-progress task writes its output to private temporary files.
When a map task completes, the worker sends a message to the master and includes the names of the R temporary files in the message. If the master receives a completion message for an already completed map task, it ignores the message.
Otherwise, it records the names of R files in a master data structure. When a reduce task completes, the reduce worker atomically renames its temporary output file to the final output file. If the same reduce task is executed on multiple machines, multiple rename calls will be executed for the same final output file. The atomic rename operation provided by the underlying file system guarantees that the final file system state contains just the data produced by one execution of the reduce task.
The implementation conserves network bandwidth by taking advantage of the fact that the input data is stored on the local disks of the machines that make up a cluster. The file system divides each file into 64 MB blocks and stores copies of each block on different machines. The MapReduce master takes the location information of the input files into account and attempts to schedule a map task on a machine that contains a replica of the corresponding input data. Failing that, it attempts to schedule a map task near a replica of that task's input data (e.g., on a worker machine that is on the same network switch as the machine containing the data).
For dynamic load balancing, M and R should be much larger than the number of worker machines. There are practical bounds on how large M and R can be in this implementation, because the master must make 0(M+R) scheduling decisions and keep 0(MxR) states in memory, as described above. Furthermore, R
is often constrained by the user because the output of each reduce task ends up in a separate output file. In practice, M would be chosen so that each individual task has roughly 16 MB to 64 MB of input data so that the locality optimization described above is most effective, and R would be a small multiple of the number of worker machines expected to be used.
The total time taken for a MapReduce operation can be affected adversely by a straggler: a machine that takes an unusually long time to complete one of the last few map or reduce tasks in the computation. To alleviate the problem of stragglers, when a MapReduce operation is close to completion, the master schedules backup executions of the remaining in-progress tasks. The task is marked as completed whenever either the primary or the backup execution completes.
In addition to the basic functionality described above, the implementation provides the following useful extensions.
In some cases, it is useful to partition data by some particular function of the key. To support this, the user of the MapReduce library can provide a partitioning function.
The implementation guarantees that within a given partition, the intermediate key/value pairs are processed in increasing key order. This makes it easy to generate a sorted output file per partition, which is useful when the output file format needs to support efficient random access lookups by key, or users of the output find it convenient to have the data sorted.
In some cases, there is significant repetition in the intermediate keys produced by each map task, and the user-specified Reduce function is commutative and associative. An example of this is the word counting example, above. Each map task may produce hundreds or thousands of records of the form <the, l>. All of these counts will be sent over the network to a single reduce task and to be added together by the Reduce function to produce one number. To provide for such cases, the implementation allows the user to specify an optional combiner function that does partial merging of data before it is sent over the network.
The combiner function is executed on each machine that performs a map task. The same code can be used to implement both the combiner and the reduce functions. The only difference between a reduce function and a combiner function is how the MapReduce library handles the output of the function. The output of a reduce function is written to the final output file. The output of a combiner function is written to an intermediate file that will be sent to a reduce task.
The MapReduce library provides support for reading input data in several different formats. For example, "text" mode input treats each line as a key/value pair: the key is the offset in the file and the value is the contents of the line. Another common supported format stores a sequence of key/value pairs sorted by key.
Each implementation of an input type knows how to split data of its type into meaningful ranges for processing as separate map tasks (e.g., text mode's range splitting ensures that range splits occur only at line boundaries). Users can add support for a new input type by providing an implementation of a simple reader interface. In addition, a reader is not limited to providing data read from a file. For example, a reader can read records from a database or from data structures mapped in memory.
In a similar fashion, the implementation supports a set of output types for producing data in different formats, and it is easy for user code to add support for new output types.
Sometimes bugs in user or third-party code cause the Map or Reduce functions to crash deterministically on certain records. Sometimes it is acceptable to ignore a few records, for example, when doing statistical analysis on a large data set. The implementation provides an optional mode of execution where the MapReduce library detects which records cause deterministic crashes and skips these records in order to make forward progress.
For this mode, each worker process installs a signal handler that catches segmentation violations and bus errors. Before invoking a user Map or Reduce operation, the MapReduce library stores the sequence number of the argument in a global variable. If the user code generates a signal, the signal handler sends a "last gasp" UDP (User Datagram Protocol) packet that contains the sequence number to the MapReduce master. When the master has seen more than one failure on a particular record, it indicates that the record should be skipped when it issues the next re-execution of the corresponding Map or Reduce task.
More information about MapReduce can be found in J. Dean and S.
Ghemawat, MapReduce: Simplified Data Processing on Large Clusters, Proceedings of the 6th Symposium on Operating Systems Design and Implementation, pp.
137-150 (December 6, 2004), the contents of which are incorporated here by reference.
Another method of clustering of users into multiple clusters using a locality sensitive hashing scheme will now briefly be described. In this method, each user has a profile represented as a vector of high dimension characterizing the user. A
set of k hash functions operating on such vectors is chosen. The i-th hash value for a user profile represents the i-th cluster the user is assigned to. Locality sensitive hash functions useful for this method are described in Charikar, Similarity Estimation Techniques from Rounding Algorithms, 34th ACM Symposium on Theory of Computing, May 19-21, 2002, Montreal, Quebec, Canada.
In one implementation of such a method, the users are represented by a list of <term, weight> pairs. As before, k is the number of clusters and the number of hash values calculated for a user. The number of seed values will be given as 8k for illustration, though in general what is given as the constant 8 is a parameter. The 8k random seed values are represented as strings denoted s_1, s_2, ...s_8k, and are chosen to appear random, e.g., so that the bits in the binary representation are uniformly "0" or "1". For every user, the i-th hash value is computed as follows:
For b from 1 to 8:
do initialize sum = 0;
for all <term_j, weight_j> pairs in the user's list:
do if (fingerprint(term_j + s_((i-1)*8 + b)) has least significant bit = 1) sum = sum + weight_j else sum = sum - weight_j done if (sum > 0) b-th bit of i-th hash value is set to 1.
else b-th bit of i-th hash value is set to 0.
done.
Thetmlfingerprint(term_j + s_((i-1)*8 + b)representsthe fingerprint function (calculated as described above) of the j-th term (term_j) concatenated with the seed string s_ i--1 ) *8 + b) , i.e., the ((i-1)*8 + b)-th seed string.
Embodiments of the invention and all of the functional operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of them.
Embodiments of the invention can be implemented as one or more computer program products, i.e., one or more modules of computer program instructions encoded on a computer-readable medium, e.g., a machine-readable storage device, a machine-readable storage medium, a memory device, or a machine-readable propagated signal, for execution by, or to control the operation of, data processing apparatus. The term "data processing apparatus" encompasses all apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers. The apparatus can include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of them,. A propagated signal is an artificially generated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus.
A computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub-programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both.
The essential elements of a computer are a processor for executing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio player, a Global Positioning System (GPS) receiver, to name just a few. Information carriers suitable for embodying computer program instructions and data include all forms of non-volatile memory, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
To provide for interaction with a user, embodiments of the invention can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.
Embodiments of the invention can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a web browser through which a user can interact with an implementation of the invention, or any combination of such back-end, middleware, or front-end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network ("LAN") and a wide area network ("WAN"), e.g., the Internet.
The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
Particular embodiments of the invention have been described. Other embodiments are within the scope of the following claims. For example, the steps recited in the claims can be performed in a different order and still achieve desirable results.
The collection D is processed using the MapReduce framework, which will be described later.
In the map phase 220, for each (user, item) pair, a (key, value) pair is output with key=user and value=item, in a distributed fashion.
In the reduce phase 222, all such (key, value) pairs with the same key (user) are collected and presented to the reduce routine, which is run once for each distinct key (user) value, in a distributed fashion.
The reduce routine (for a particular user) processes all the items in the interest set of the user; for this description, these m items will be denoted il, i2, im. For each seed value si, the reduce routine computes m values (one for each item) that are the fingerprint of the item and the seed value, i.e., fingerprint (si, ii).
The minimum of these fingerprints, over the m items, is computed and that becomes the i-th minhash value, corresponding to the i-th seed si.
A user is represented by the k minhash values thus computed. These represent the k clusters that the user belongs to, and the user is said to be assigned to these clusters.
As shown in FIG. 3, a recommender computer program application can use user clusters generated according to any of the methods described in this specification.
In one implementation, a system records selections made by its users in a log (step 310). The log can be stored in any form, e.g., as lines of unstructured text or as records in a structured database; and it can be stored on any computer-readable medium, e.g., on disk drives on a file server. The system can be a web site serving search results, advertisements, purchase selections, simple links to pages within or outside the site, or other items. The selections that are logged can be, but need not be, all the selections made by users of the system. For example, an application may only be interested in selections of news sites rather than all sites, or selections of items for purchase rather than all items viewed. In addition, the system can maintain multiple logs of different kinds of selections for different recommender applications, which can calculate their own respective user clusterings. For example, in a method using seeds and fingerprint functions, each separate clustering can have its own distinct seed sequence and fingerprint function.
The system can identify individuals as users by user registration and log on, by cookies, or otherwise. Optionally, a system can treat a user session as a user for purposes of clustering if it is undesirable to maintain information about individual users across multiple sessions of interaction with the system. Cookies can also be used to maintain sessions. (A cookie is a packet of information sent by a server to a web browser and then sent back by the browser each time it accesses that server.) Optionally, a system can allow individuals to determine whether or not they participate in logging, i.e., to include themselves in, or to exclude themselves from, logging of their selections.
Optionally, a system can treat some attribute or combination of attributes of an individual interacting with the system as a user. The attribute can be observed by the system, e.g., the lP (Internet Protocol) address being used or the language being used, or it can be information provided by the individual, e.g., a city or country of residence, or a subscription to service provided by the system. Thus, for example, a system could treat individuals from Cupertino as one user and individuals from Redmond as a different user. An advantage of such collective clustering is that it allows a system to provide a degree of personalization without requiring login or registration. In addition, a system can optionally either do clustering for all kinds of users ¨ e.g., individuals and aggregations ¨ together in the same clusters, or it can establish different clusters for different kinds of users.
The selections made by the users of the system can be simple selections or, optionally, composite selections. A composite selection is a sequence of selections, for example, a sequence of navigating from to a first web page and then directly to a second web page. A web page is a resource, typically an HTML (Hypertext Markup Language) document, served by a web server to a web browser. A web server is a computer program that accepts HTTP (Hypertext Transfer Protocol) requests, typically received over a network, and provides an HTTP responses to the requester.
The HTTP response typically consists of an HTML document, but can also be a text file, an image, or some other type of document.
Based on the logged selections, users are each assigned to k clusters (step 312), as described elsewhere in this specification. This clustering of users can be updated as new users appear in the system and as selections are added to or removed from the log. Optionally, under some circumstances, not all users are assigned to k clusters. In such circumstances, one or more, but fewer than k, cluster identifiers can be obtained to find recommendations for a particular user. For example, if a system receives a request to provide a recommendation for a new user who has a set of selections, the system can optionally calculate the identity of a first cluster using the selections, use that to find recommendations, continue and similarly calculate and use a second cluster, and so on, until a system-defined sufficient number of recommendations has been found.
The recommender application can then use the user clusters to make a recommendation for a particular user (step 314). Any method for making recommendations based on grouping users each into a single cluster can be used with the multiple clusters described here. For example, such a method can be applied k times and the k results merged to provide a union set of recommended items for the user. Alternatively, the number of different results in which an item appears can be used to rank the items. Or, a few items from each of the cluster-based recommendation results can be provided to the user, to give the user a diversity of recommendations. The multiple clusters a user is assigned to may reflect different kinds of interests the user has had when using the system, and so giving the user such a diversity of recommendations makes it more likely that the recommendations include something from the user's current interest than if only a single cluster were used.
A recommender application is one example of collaborative filtering, and the methods of user clustering described in this specification can be applied to other kinds of collaborative filtering as well. In collaborative filtering, users are found who are similar to a current user, and from their preferences or behaviors, a ranking, recommendation or prediction is made for the current user. By grouping users into multiple clusters, a system implicitly identifies the users' preferences and groups items through the grouping of users.
As illustrated schematically in FIG. 4, the techniques for assigning users to clusters described in this specification can be implemented in a news recommender engine 410 that can provide recommendations of news articles to be presented to users 402a, 402b based on selections of articles previously made by those users.
The users 402a, 402b communicate through their respective browsers with one or more web servers 430 through a data communications network 404, for example, a local, wide-area, or virtual private network, or the Internet. The news service 420 is implemented as a computer program hosted on the server or servers 430 and serves web pages to the users 402a, 402b in response to the users' requests. Among the pages served by the news service 420 are pages from which a user can select one or multiple news articles for display by the user's browser. In response to user selections, the news service 420 serves the user selected articles (functionality 424).
If the news recommender engine 410 has provided recommendations for a particular user, the news service can serve pages showing articles for selection by that user according to the recommendations for the user (functionality 422).
The news recommender engine 410 is implemented as a computer program running on the server or servers 430. The news recommender engine 410 receives selections from the users of the news service 420 and logs those selections (functionality 412) in a log 440. Using the information in the log 440, the engine assigns users to clusters (functionality 414) as described elsewhere in the specification. For any particular user who has been assigned to a cluster, the engine determines recommendations based on the clusters to which that user is assigned (functionality 416) and provides those recommendations to the news service 420.
In determining what recommendations to make for a particular user, the engine considers what selections were made by other users who are assigned to the same cluster or clusters as the particular user. Of the possible recommendations, the engine can optionally eliminate news articles that the user has already selected. The engine or the service can rank the recommendations on a variety of criteria, including the number of times a news article has been selected by other users assigned to the clusters to which the user is assigned, how recent the news article is, the number of sources having articles on the subject of the news article in question, and so on. In this way, a news service can provide a personalized offering and ranking of news articles to its users.
In one implementation, the news recommender engine 410 identifies users as individuals and so requires users to log in and register to get personalized recommendations. In other implementations, users can be identified implicitly or as collective groups, as described elsewhere in this specification.
A recommender engine can be implemented along these lines to support personalization of other kinds of services, for example, services offering selections of images, blogs, or shopping information.
Although illustrated in FIG. 4 as separate modules, the functionalities of the engine and the service need not be implemented in this way; in particular, the engine can be implemented as part of the implementation of the service.
The following paragraphs describe the MapReduce programming model and an implementation of the model for processing and generating large data sets.
The model and its library implementation will both be referred to as MapReduce.
Using MapReduce, programmers specify a map function that processes a key/value pair to generate a set of intermediate key/value pairs, and a reduce function that merges all intermediate values associated with the same intermediate key. Programs written in this functional style can automatically be parallelized and executed on a large cluster of commodity computers. The runtime system or framework can be implemented to partition the input data, schedule the program's execution across a set of machines, handle machine failures, and manage the required inter-machine communication.
A MapReduce computation takes a set of input key/value pairs, and produces a set of output key/value pairs. The user expresses the computation as two functions: Map and Reduce.
Map, written by the user, takes an input key/value pair and produces a set of intermediate key/value pairs. The MapReduce library groups together all intermediate values associated with the same intermediate key I and passes them to the Reduce function.
The Reduce function, also written by the user, accepts an intermediate key I
and a set of values for that key. It merges together these values to form a possibly smaller set of values. Typically just zero or one output value is produced for each Reduce invocation. The intermediate values are supplied to the user's reduce function through an iterator. In this way lists of values that are too large to fit in memory can be handled.
Consider the problem of counting the number of occurrences of each word in a large collection of documents. The user would write code similar to the following pseudo-code:
map(String key, String value):
// key: document name // value: document contents for each word w in value:
EmitIntermediate(w, "1");
reduce (String key, Iterator values):
// key: a word // values: a list of counts int result = 0;
for each v in values:
result += ParseInt(v);
Emit(AsString(result));
The map function emits each word plus an associated count of occurrences (just '1' in this simple example). The reduce function sums together all counts emitted for a particular word.
In one implementation, to perform a computation, the user writes code to fill in a specification object with the names of the input and output files, and optional tuning parameters. The user then invokes a MapReduce function, passing it the specification object. The user's code is linked together with the MapReduce library.
Even though the previous pseudo-code is written in terms of string inputs and outputs, conceptually the map and reduce functions supplied by the user have associated types:
map (kl, v1) list(k2, v2) reduce (k2, list(v2)) ---* list(v2) That is, the input keys and values are drawn from a different domain than the output keys and values. Furthermore, the intermediate keys and values are from the same domain as the output keys and values.
Many different implementations of the MapReduce model are possible.
The following paragraphs describe an implementation targeted to a computing environment having large clusters of commodity personal computers connected together with switched Ethernet. In this environment machines typically have 2-4 GB (gigabytes) of memory per machine, a cluster has hundreds or thousands of machines, storage is provided by inexpensive IDE (Integrated Drive Electronics standard) disks attached directly to individual machines, a distributed file system is used to manage the data stored on these disks that uses replication to provide availability and reliability on top of unreliable hardware, and users submit jobs to a scheduling system. Each job consists of a set of tasks, and is mapped by the scheduler of the scheduling system to a set of available machines within a cluster.
The Map invocations are distributed across multiple machines by automatically partitioning the input data into a set of M splits. The input splits can be processed in parallel by different machines. Reduce invocations are distributed by partitioning the intermediate key space into R pieces using a partitioning function (e.g., hash(key) mod R). The number of partitions (R) and the partitioning function are specified by the user.
When the user program calls the MapReduce function, the following sequence of actions occurs:
1. The MapReduce library in the user program first splits the input files into M pieces of typically 16 megabytes to 64 megabytes (MB) per piece (controllable by the user). It then starts up many copies of the program on a cluster of machines.
2. One of the copies of the program is the master. The rest are workers that are assigned work by the master. There are M map tasks and R reduce tasks to assign. The master picks idle workers and assigns each one a map task or a reduce task.
3. A worker assigned a map task reads the contents of the corresponding input split. It parses key/value pairs out of the input data and passes each pair to the user-defined Map function. The intermediate key/value pairs produced by the Map function are buffered in memory.
4. Periodically, the buffered pairs are written to local disk, partitioned into R regions by the partitioning function. The locations of these buffered pairs on the local disk are passed back to the master, who is responsible for forwarding these locations to the reduce workers.
5. When a reduce worker is notified by the master about these locations, it uses remote procedure calls to read the buffered data from the local disks of the map workers. When a reduce worker has read all intermediate data, it sorts it by the intermediate keys so that all occurrences of the same key are grouped together. The sorting is useful because typically many different keys map to the same reduce task.
If the amount of intermediate data is too large to fit in memory, an external sort is used.
6. The reduce worker iterates over the sorted intermediate data and for each unique intermediate key encountered, it passes the key and the corresponding set of intermediate values to the user's Reduce function. The output of the Reduce function is appended to a final output file for this reduce partition.
7. When all map tasks and reduce tasks have been completed, the master wakes up the user program. At this point, the MapReduce call in the user program returns back to the user code.
After successful completion, the output of the execution is available in the R
output files (one per reduce task, with file names as specified by the user).
Users do not need to combine these R output files into one file; they can pass these files as input to another MapReduce call, or use them from another distributed application that is able to deal with input that is partitioned into multiple files.
The master keeps several data structures. For each map task and reduce task, it stores the state (idle, in-progress, or completed) and the identity of the worker machine (for non-idle tasks).
The master is the conduit through which the location of intermediate file regions is propagated from map tasks to reduce tasks. Therefore, for each completed map task, the master stores the locations and sizes of the R intermediate file regions produced by the map task. Updates to this location and size information are received as map tasks are completed. The information is pushed incrementally to workers that have in-progress reduce tasks.
Because this implementation MapReduce library is designed to process very large amounts of data using hundreds or thousands of machines, the library tolerates machine failures gracefully.
The master pings every worker periodically. If no response is received from a worker in a certain amount of time, the master marks the worker as failed.
Any map tasks completed by the worker are reset back to their initial idle state, and therefore become eligible for scheduling on other workers. Similarly, any map task or reduce task in progress on a failed worker is also reset to idle and becomes eligible for rescheduling.
Completed map tasks are re-executed on a failure because their output is stored on the local disk(s) of the failed machine and is therefore inaccessible.
Completed reduce tasks do not need to be re-executed because their output is stored in a global file system.
When a map task is executed first by worker A and then later executed by worker B (because A failed), all workers executing reduce tasks are notified of the re-execution. Any reduce task that has not already read the data from worker A
will read the data from worker B.
Because there is only a single master, its failure is unlikely; therefore the MapReduce computation is aborted if the master fails. Users or user programs can check for this condition and retry the MapReduce operation if they desire.
When the user supplied map and reduce operators are deterministic functions of their input values, this distributed implementation produces the same output as would have been produced by a non-faulting sequential execution of the entire program. Each in-progress task writes its output to private temporary files.
When a map task completes, the worker sends a message to the master and includes the names of the R temporary files in the message. If the master receives a completion message for an already completed map task, it ignores the message.
Otherwise, it records the names of R files in a master data structure. When a reduce task completes, the reduce worker atomically renames its temporary output file to the final output file. If the same reduce task is executed on multiple machines, multiple rename calls will be executed for the same final output file. The atomic rename operation provided by the underlying file system guarantees that the final file system state contains just the data produced by one execution of the reduce task.
The implementation conserves network bandwidth by taking advantage of the fact that the input data is stored on the local disks of the machines that make up a cluster. The file system divides each file into 64 MB blocks and stores copies of each block on different machines. The MapReduce master takes the location information of the input files into account and attempts to schedule a map task on a machine that contains a replica of the corresponding input data. Failing that, it attempts to schedule a map task near a replica of that task's input data (e.g., on a worker machine that is on the same network switch as the machine containing the data).
For dynamic load balancing, M and R should be much larger than the number of worker machines. There are practical bounds on how large M and R can be in this implementation, because the master must make 0(M+R) scheduling decisions and keep 0(MxR) states in memory, as described above. Furthermore, R
is often constrained by the user because the output of each reduce task ends up in a separate output file. In practice, M would be chosen so that each individual task has roughly 16 MB to 64 MB of input data so that the locality optimization described above is most effective, and R would be a small multiple of the number of worker machines expected to be used.
The total time taken for a MapReduce operation can be affected adversely by a straggler: a machine that takes an unusually long time to complete one of the last few map or reduce tasks in the computation. To alleviate the problem of stragglers, when a MapReduce operation is close to completion, the master schedules backup executions of the remaining in-progress tasks. The task is marked as completed whenever either the primary or the backup execution completes.
In addition to the basic functionality described above, the implementation provides the following useful extensions.
In some cases, it is useful to partition data by some particular function of the key. To support this, the user of the MapReduce library can provide a partitioning function.
The implementation guarantees that within a given partition, the intermediate key/value pairs are processed in increasing key order. This makes it easy to generate a sorted output file per partition, which is useful when the output file format needs to support efficient random access lookups by key, or users of the output find it convenient to have the data sorted.
In some cases, there is significant repetition in the intermediate keys produced by each map task, and the user-specified Reduce function is commutative and associative. An example of this is the word counting example, above. Each map task may produce hundreds or thousands of records of the form <the, l>. All of these counts will be sent over the network to a single reduce task and to be added together by the Reduce function to produce one number. To provide for such cases, the implementation allows the user to specify an optional combiner function that does partial merging of data before it is sent over the network.
The combiner function is executed on each machine that performs a map task. The same code can be used to implement both the combiner and the reduce functions. The only difference between a reduce function and a combiner function is how the MapReduce library handles the output of the function. The output of a reduce function is written to the final output file. The output of a combiner function is written to an intermediate file that will be sent to a reduce task.
The MapReduce library provides support for reading input data in several different formats. For example, "text" mode input treats each line as a key/value pair: the key is the offset in the file and the value is the contents of the line. Another common supported format stores a sequence of key/value pairs sorted by key.
Each implementation of an input type knows how to split data of its type into meaningful ranges for processing as separate map tasks (e.g., text mode's range splitting ensures that range splits occur only at line boundaries). Users can add support for a new input type by providing an implementation of a simple reader interface. In addition, a reader is not limited to providing data read from a file. For example, a reader can read records from a database or from data structures mapped in memory.
In a similar fashion, the implementation supports a set of output types for producing data in different formats, and it is easy for user code to add support for new output types.
Sometimes bugs in user or third-party code cause the Map or Reduce functions to crash deterministically on certain records. Sometimes it is acceptable to ignore a few records, for example, when doing statistical analysis on a large data set. The implementation provides an optional mode of execution where the MapReduce library detects which records cause deterministic crashes and skips these records in order to make forward progress.
For this mode, each worker process installs a signal handler that catches segmentation violations and bus errors. Before invoking a user Map or Reduce operation, the MapReduce library stores the sequence number of the argument in a global variable. If the user code generates a signal, the signal handler sends a "last gasp" UDP (User Datagram Protocol) packet that contains the sequence number to the MapReduce master. When the master has seen more than one failure on a particular record, it indicates that the record should be skipped when it issues the next re-execution of the corresponding Map or Reduce task.
More information about MapReduce can be found in J. Dean and S.
Ghemawat, MapReduce: Simplified Data Processing on Large Clusters, Proceedings of the 6th Symposium on Operating Systems Design and Implementation, pp.
137-150 (December 6, 2004), the contents of which are incorporated here by reference.
Another method of clustering of users into multiple clusters using a locality sensitive hashing scheme will now briefly be described. In this method, each user has a profile represented as a vector of high dimension characterizing the user. A
set of k hash functions operating on such vectors is chosen. The i-th hash value for a user profile represents the i-th cluster the user is assigned to. Locality sensitive hash functions useful for this method are described in Charikar, Similarity Estimation Techniques from Rounding Algorithms, 34th ACM Symposium on Theory of Computing, May 19-21, 2002, Montreal, Quebec, Canada.
In one implementation of such a method, the users are represented by a list of <term, weight> pairs. As before, k is the number of clusters and the number of hash values calculated for a user. The number of seed values will be given as 8k for illustration, though in general what is given as the constant 8 is a parameter. The 8k random seed values are represented as strings denoted s_1, s_2, ...s_8k, and are chosen to appear random, e.g., so that the bits in the binary representation are uniformly "0" or "1". For every user, the i-th hash value is computed as follows:
For b from 1 to 8:
do initialize sum = 0;
for all <term_j, weight_j> pairs in the user's list:
do if (fingerprint(term_j + s_((i-1)*8 + b)) has least significant bit = 1) sum = sum + weight_j else sum = sum - weight_j done if (sum > 0) b-th bit of i-th hash value is set to 1.
else b-th bit of i-th hash value is set to 0.
done.
Thetmlfingerprint(term_j + s_((i-1)*8 + b)representsthe fingerprint function (calculated as described above) of the j-th term (term_j) concatenated with the seed string s_ i--1 ) *8 + b) , i.e., the ((i-1)*8 + b)-th seed string.
Embodiments of the invention and all of the functional operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of them.
Embodiments of the invention can be implemented as one or more computer program products, i.e., one or more modules of computer program instructions encoded on a computer-readable medium, e.g., a machine-readable storage device, a machine-readable storage medium, a memory device, or a machine-readable propagated signal, for execution by, or to control the operation of, data processing apparatus. The term "data processing apparatus" encompasses all apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers. The apparatus can include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of them,. A propagated signal is an artificially generated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus.
A computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub-programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both.
The essential elements of a computer are a processor for executing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio player, a Global Positioning System (GPS) receiver, to name just a few. Information carriers suitable for embodying computer program instructions and data include all forms of non-volatile memory, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
To provide for interaction with a user, embodiments of the invention can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.
Embodiments of the invention can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a web browser through which a user can interact with an implementation of the invention, or any combination of such back-end, middleware, or front-end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network ("LAN") and a wide area network ("WAN"), e.g., the Internet.
The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
Particular embodiments of the invention have been described. Other embodiments are within the scope of the following claims. For example, the steps recited in the claims can be performed in a different order and still achieve desirable results.
Claims (74)
1. A system comprising:
one or more computers; and a computer-readable medium coupled to the one or more computers having instructions stored thereon which, when executed by the one or more computers, cause the one or more computers to perform operations comprising:
obtaining a set of data elements that represent items in which a particular user has expressed interest through interaction with one or more web applications;
applying a fingerprint function and k distinct seed values to each of the data elements to generate a set of k minhash values, wherein k is an integer parameter, and wherein each minhash value corresponds to a respective data element of the set of data elements; and assigning the particular user to k clusters, each of which is represented by a respective corresponding one of the k minhash values.
one or more computers; and a computer-readable medium coupled to the one or more computers having instructions stored thereon which, when executed by the one or more computers, cause the one or more computers to perform operations comprising:
obtaining a set of data elements that represent items in which a particular user has expressed interest through interaction with one or more web applications;
applying a fingerprint function and k distinct seed values to each of the data elements to generate a set of k minhash values, wherein k is an integer parameter, and wherein each minhash value corresponds to a respective data element of the set of data elements; and assigning the particular user to k clusters, each of which is represented by a respective corresponding one of the k minhash values.
2. The system of claim 1, wherein the data elements are text strings or binary data.
3. The system of claim 1, wherein applying the fingerprint function and the k distinct seed values further comprises:
generating i hash values for each of the k distinct seed values, by applying the fingerprint function and the respective seed value to each of the data elements, wherein i represents a quantity of data elements in the set;
selecting, for each of the k distinct seed values, a minimum hash value from among the i hash values generated for the respective seed value; and establishing the k respective minimum hash values as the set of k minhash values.
generating i hash values for each of the k distinct seed values, by applying the fingerprint function and the respective seed value to each of the data elements, wherein i represents a quantity of data elements in the set;
selecting, for each of the k distinct seed values, a minimum hash value from among the i hash values generated for the respective seed value; and establishing the k respective minimum hash values as the set of k minhash values.
4. The system of claim 1, wherein k is an integer parameter between 5 and 10, inclusive.
5. The system of claim 1, wherein each item is a search result or a news story that the particular user has selected.
6. The system of claim 1, wherein each item is an item that the particular user has purchased or added to a shopping cart.
7. The system of claim 1, wherein each item represents a sequence of selections made by the particular user to navigate between web pages.
8. The system of claim 1, wherein:
the operations further comprise obtaining a collection of data pairs, each data pair identifying a user and an item in which the user has expressed interest; and obtaining the set of data elements further comprises processing the collection of data pairs by a reduce routine that uses data that identifies the particular user as a key.
the operations further comprise obtaining a collection of data pairs, each data pair identifying a user and an item in which the user has expressed interest; and obtaining the set of data elements further comprises processing the collection of data pairs by a reduce routine that uses data that identifies the particular user as a key.
9. The system of claim 1, wherein fingerprint function is a RAND function and the hash values are 32-bit integer values or the fingerprint function is a function that performs an MD5 one-way hash algorithm and the hash values are 128-bit values.
10. The system of claim 1, wherein assigning the particular user to the k clusters occurs without affecting an assignment or non assignment of any other user to any of the k clusters.
11. The system of claim 1, wherein the operations further comprise:
determining that the particular user has expressed sham interest in the items; and un-assigning the particular user from the k clusters that are represented by the k minhash values, without affecting an assignment of any other user to any of the k clusters.
determining that the particular user has expressed sham interest in the items; and un-assigning the particular user from the k clusters that are represented by the k minhash values, without affecting an assignment of any other user to any of the k clusters.
12. The system of claim 1, wherein:
the operations further comprise determining that the particular user has elected to publicize the items in which the particular user has expressed interest; and assigning the particular user to the k clusters further comprises assigning the particular user to the k clusters in response to determining that the particular user has elected to publicize the items in which the particular user has expressed interest.
the operations further comprise determining that the particular user has elected to publicize the items in which the particular user has expressed interest; and assigning the particular user to the k clusters further comprises assigning the particular user to the k clusters in response to determining that the particular user has elected to publicize the items in which the particular user has expressed interest.
13. The system of claim 1, wherein:
the operations further comprise determining that the particular user has edited the items in which the particular user has expressed interest; and assigning the particular user to the k clusters further comprises assigning the particular user to the k clusters in response to determining that the particular user has edited the items in which the particular user has expressed interest.
the operations further comprise determining that the particular user has edited the items in which the particular user has expressed interest; and assigning the particular user to the k clusters further comprises assigning the particular user to the k clusters in response to determining that the particular user has edited the items in which the particular user has expressed interest.
14. A computer-implemented method comprising:
obtaining a set of data elements that represent items in which a particular user has expressed interest through interaction with one or more web applications;
applying a fingerprint function and k distinct seed values to each of the data elements to generate a set of k minhash values, wherein k is an integer parameter, and wherein each minhash value corresponds to a respective data element of the set of data elements; and assigning, by one or more computers, the particular user to k clusters, each of which is represented by a respective corresponding one of the k minhash values.
obtaining a set of data elements that represent items in which a particular user has expressed interest through interaction with one or more web applications;
applying a fingerprint function and k distinct seed values to each of the data elements to generate a set of k minhash values, wherein k is an integer parameter, and wherein each minhash value corresponds to a respective data element of the set of data elements; and assigning, by one or more computers, the particular user to k clusters, each of which is represented by a respective corresponding one of the k minhash values.
15. A computer readable storage medium encoded with a computer program, the program comprising instructions that when executed by data processing apparatus cause the data processing apparatus to perform operations comprising:
obtaining a set of data elements that represent items in which a particular user has expressed interest through interaction with one or more web applications;
applying a fingerprint function and k distinct seed values to each of the data elements to generate a set of k minhash values, wherein k is an integer parameter, and wherein each minhash value corresponds to a respective data element of the set of data elements; and assigning the particular user to k clusters, each of which is represented by a respective corresponding one of the k minhash values.
obtaining a set of data elements that represent items in which a particular user has expressed interest through interaction with one or more web applications;
applying a fingerprint function and k distinct seed values to each of the data elements to generate a set of k minhash values, wherein k is an integer parameter, and wherein each minhash value corresponds to a respective data element of the set of data elements; and assigning the particular user to k clusters, each of which is represented by a respective corresponding one of the k minhash values.
16. The computer readable storage medium of claim 15, wherein applying the fingerprint function and the k distinct seed values further comprises:
generating i hash values for each of the k distinct seed values, by applying the fingerprint function and the respective seed value to each of the data elements, wherein i represents a quantity of data elements in the set;
selecting, for each of the k distinct seed values, a minimum hash value from among the i hash values generated for the respective seed value; and establishing the k respective minimum hash values as the set of k minhash values.
generating i hash values for each of the k distinct seed values, by applying the fingerprint function and the respective seed value to each of the data elements, wherein i represents a quantity of data elements in the set;
selecting, for each of the k distinct seed values, a minimum hash value from among the i hash values generated for the respective seed value; and establishing the k respective minimum hash values as the set of k minhash values.
17. The computer readable storage medium of claim 15, wherein:
the operations further comprise obtaining a collection of data pairs, each data pair identifying a user and an item in which the user has expressed interest; and obtaining the set of data elements further comprises processing the collection of data pairs by a reduce routine that uses data that identifies the particular user as a key.
the operations further comprise obtaining a collection of data pairs, each data pair identifying a user and an item in which the user has expressed interest; and obtaining the set of data elements further comprises processing the collection of data pairs by a reduce routine that uses data that identifies the particular user as a key.
18. The computer readable storage medium of claim 15, wherein assigning the particular user to the k clusters occurs without affecting an assignment or non assignment of any other user to any of the k clusters.
19. The computer readable storage medium of claim 15, wherein the operations further comprise:
determining that the particular user has expressed sham interest in the items; and un-assigning the particular user from the k clusters that are represented by the k minhash values, without affecting an assignment of any other user to any of the k clusters.
determining that the particular user has expressed sham interest in the items; and un-assigning the particular user from the k clusters that are represented by the k minhash values, without affecting an assignment of any other user to any of the k clusters.
20. The computer readable storage medium of claim 15, wherein:
the operations further comprise determining that the particular user has elected to publicize the items in which the particular user has expressed interest; and assigning the particular user to the k clusters further comprises assigning the particular user to the k clusters in response to determining that the particular user has elected to publicize the items in which the particular user has expressed interest.
the operations further comprise determining that the particular user has elected to publicize the items in which the particular user has expressed interest; and assigning the particular user to the k clusters further comprises assigning the particular user to the k clusters in response to determining that the particular user has elected to publicize the items in which the particular user has expressed interest.
21. A computer readable storage device, storing instructions that when executed by a processor cause a data processing apparatus to:
obtain a respective interest set for each of multiple users, each interest set being a set of elements, each element representing a respective item in which the respective user has expressed interest through interaction with a data processing system;
for each of the multiple users, apply an i-th hash function to each element of the interest set of the user to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and determine, from the function values obtained from the k hash functions, k hash values of the respective interest set, wherein the i-th hash value of the respective interest set is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, and where k is an integer greater than or equal to 1; and assign each of the multiple users to each of k clusters, the i-th cluster being represented by the i-th hash value of the respective interest set of the respective user, wherein the assignment of each of the multiple users to k clusters is done without regard to the assignment of any of the other users to k clusters.
obtain a respective interest set for each of multiple users, each interest set being a set of elements, each element representing a respective item in which the respective user has expressed interest through interaction with a data processing system;
for each of the multiple users, apply an i-th hash function to each element of the interest set of the user to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and determine, from the function values obtained from the k hash functions, k hash values of the respective interest set, wherein the i-th hash value of the respective interest set is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, and where k is an integer greater than or equal to 1; and assign each of the multiple users to each of k clusters, the i-th cluster being represented by the i-th hash value of the respective interest set of the respective user, wherein the assignment of each of the multiple users to k clusters is done without regard to the assignment of any of the other users to k clusters.
22. The computer readable storage device of claim 21, the instructions further comprising instructions that when executed by a processor cause a data processing apparatus to:
record actions expressing user interest in a log; and use the log to generate the interest sets for the multiple users.
record actions expressing user interest in a log; and use the log to generate the interest sets for the multiple users.
23. The computer readable storage device of claim 21, the instructions further comprising instructions that when executed by a processor cause a data processing apparatus to:
obtain a changed interest set for a first user of the multiple users;
determine k hash values for the first user using the changed interest set; and assign the first user only to each of the respective k clusters represented by the k hash values determined using the changed interest set without changing the assignment of any of the other multiple users to clusters.
obtain a changed interest set for a first user of the multiple users;
determine k hash values for the first user using the changed interest set; and assign the first user only to each of the respective k clusters represented by the k hash values determined using the changed interest set without changing the assignment of any of the other multiple users to clusters.
24. The computer readable storage device of claim 21, where k is greater than 1.
25. The computer readable storage device of claim 21, wherein the instructions further cause a data processing apparatus to:
execute a collaborative filtering computer program application to provide information to a first user of the multiple users based on the assignment of the first user to one or more of the k clusters.
execute a collaborative filtering computer program application to provide information to a first user of the multiple users based on the assignment of the first user to one or more of the k clusters.
26. A computer readable storage device, storing instructions that when executed by a processor cause a data processing apparatus to:
obtain an interest set for a user, the interest set being a set of elements, each element representing a respective item in which the user has expressed interest through interaction with a data processing system;
apply an i-th hash function to each element of the interest set to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and determine, from the function values obtained from the k hash functions, k hash values of the interest set, wherein the i-th hash value is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, where k is an integer greater than or equal to 1; and assign the user to each of k clusters, the i-th cluster being represented by the i-th hash value.
obtain an interest set for a user, the interest set being a set of elements, each element representing a respective item in which the user has expressed interest through interaction with a data processing system;
apply an i-th hash function to each element of the interest set to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and determine, from the function values obtained from the k hash functions, k hash values of the interest set, wherein the i-th hash value is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, where k is an integer greater than or equal to 1; and assign the user to each of k clusters, the i-th cluster being represented by the i-th hash value.
27. The computer readable storage device of claim 26, wherein:
the interest set has m elements;
the i-th hash value is a minimum value of m applications of a one-way hash function, each application hashing an i-th seed value and a respective one of the m elements of the interest set.
the interest set has m elements;
the i-th hash value is a minimum value of m applications of a one-way hash function, each application hashing an i-th seed value and a respective one of the m elements of the interest set.
28. The computer readable storage device of claim 26, the instructions further comprising instructions that when executed by a processor cause a data processing apparatus to:
use the k user clusters to perform collaborative filtering for the user.
use the k user clusters to perform collaborative filtering for the user.
29. A system, comprising:
one or more machine-readable storage media storing a log of items selected by multiple users using a data processing system, the log of items identifying, for each of the multiple users, multiple items that the respective user has selected through interaction with the data processing system;
one or more computers configured to use the log to generate a respective interest set for each of the multiple users, each interest set being a set of elements, each element representing a respective item in which the respective user has selected through interaction with the data processing system;
one or more computers configured to apply, for each of the multiple users, an i-th hash function to each element of the interest set of the user to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and to determine, from the function values obtained from the k hash functions, k hash values of the respective interest set, wherein the i-th hash value of the respective interest set is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, and where k is an integer greater than or equal to 1;
one or more computers configured to assign each of the multiple users to each of k clusters, the i-th cluster being represented by the i-th hash value of the respective interest set of the respective user, wherein the assignment of each of the multiple users to k clusters is done without regard to the assignment of any of the other users to k clusters; and one or more computers configured to execute a collaborative filtering computer program application to provide information to a first user of the multiple users based on the assignment of the first user to one or more of the k clusters.
one or more machine-readable storage media storing a log of items selected by multiple users using a data processing system, the log of items identifying, for each of the multiple users, multiple items that the respective user has selected through interaction with the data processing system;
one or more computers configured to use the log to generate a respective interest set for each of the multiple users, each interest set being a set of elements, each element representing a respective item in which the respective user has selected through interaction with the data processing system;
one or more computers configured to apply, for each of the multiple users, an i-th hash function to each element of the interest set of the user to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and to determine, from the function values obtained from the k hash functions, k hash values of the respective interest set, wherein the i-th hash value of the respective interest set is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, and where k is an integer greater than or equal to 1;
one or more computers configured to assign each of the multiple users to each of k clusters, the i-th cluster being represented by the i-th hash value of the respective interest set of the respective user, wherein the assignment of each of the multiple users to k clusters is done without regard to the assignment of any of the other users to k clusters; and one or more computers configured to execute a collaborative filtering computer program application to provide information to a first user of the multiple users based on the assignment of the first user to one or more of the k clusters.
30. The system of claim 29, wherein the information comprises at least one of a recommendation, a prediction, or a ranking.
31. The system of claim 29, wherein k is between 5 and 10, inclusive.
32. The system of claim 29, further comprising one or more computers configured to:
apply the fingerprint function to the interest sets to generate k sets of hash values, and select, as the respective k fingerprint values, a minimum value from each set of hash values.
apply the fingerprint function to the interest sets to generate k sets of hash values, and select, as the respective k fingerprint values, a minimum value from each set of hash values.
33. A computer-implemented method comprising:
obtaining a respective interest set for each of multiple users, each interest set being a set of elements, each element representing a respective item in which the respective user has expressed interest through interaction with a data processing system;
for each of the multiple users, applying an i-th hash function to each element of the interest set of the user to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and determining, from the function values obtained from the k hash functions, k hash values of the respective interest set, wherein the i-th hash value of the respective interest set is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, where k is an integer greater than or equal to 1;
and assigning each of the multiple users to each of k clusters established for the respective user, the i-th cluster being represented by the i-th hash value of the respective interest set of the respective user, wherein the assignment of each of the multiple users to k clusters is done without regard to the assignment of any of the other users to k clusters.
obtaining a respective interest set for each of multiple users, each interest set being a set of elements, each element representing a respective item in which the respective user has expressed interest through interaction with a data processing system;
for each of the multiple users, applying an i-th hash function to each element of the interest set of the user to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and determining, from the function values obtained from the k hash functions, k hash values of the respective interest set, wherein the i-th hash value of the respective interest set is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, where k is an integer greater than or equal to 1;
and assigning each of the multiple users to each of k clusters established for the respective user, the i-th cluster being represented by the i-th hash value of the respective interest set of the respective user, wherein the assignment of each of the multiple users to k clusters is done without regard to the assignment of any of the other users to k clusters.
34. The method of claim 33, further comprising:
recording actions expressing user interest in a log; and using the log to generate the interest sets for the multiple users.
recording actions expressing user interest in a log; and using the log to generate the interest sets for the multiple users.
35. The method of claim 33, where k is greater than 1.
36. The method of claim 33, further comprising executing a collaborative filtering computer program application to provide information to a first user of the multiple users based on the assignment of the first user to one or more of the k clusters.
37. The method of claim 33, further comprising:
obtaining a changed interest set for a first user of the multiple users;
determining k hash values for the first user using the changed interest set; and assigning the first user only to each of the respective k clusters represented by the k hash values determined using the changed interest set without changing the assignment of any of the other multiple users to clusters.
obtaining a changed interest set for a first user of the multiple users;
determining k hash values for the first user using the changed interest set; and assigning the first user only to each of the respective k clusters represented by the k hash values determined using the changed interest set without changing the assignment of any of the other multiple users to clusters.
38. A computer-implemented method comprising:
obtaining an interest set for a user, the interest set being a set of elements, each element representing a respective item in which the user has expressed interest through interaction with a data processing system;
applying an i-th hash function to each element of the interest set to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and determining, from the function values obtained from the k hash functions, k hash values of the interest set, wherein the i-th hash value is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, where k is an integer greater than or equal to 1; and assigning the user to each of k clusters, the i-th cluster being represented by the i-th hash value.
obtaining an interest set for a user, the interest set being a set of elements, each element representing a respective item in which the user has expressed interest through interaction with a data processing system;
applying an i-th hash function to each element of the interest set to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and determining, from the function values obtained from the k hash functions, k hash values of the interest set, wherein the i-th hash value is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, where k is an integer greater than or equal to 1; and assigning the user to each of k clusters, the i-th cluster being represented by the i-th hash value.
39. The method of claim 38, wherein:
the interest set has m elements;
the i-th hash value is a minimum value of m applications of a one-way hash function, each application hashing an i-th seed value and a respective one of the m elements of the interest set.
the interest set has m elements;
the i-th hash value is a minimum value of m applications of a one-way hash function, each application hashing an i-th seed value and a respective one of the m elements of the interest set.
40. The method of claim 38, further comprising:
using the k user clusters to perform collaborative filtering for the user.
using the k user clusters to perform collaborative filtering for the user.
41. The method of claim 38, further comprising:
recording actions expressing user interest in a log; and using the log to generate the interest set for the user.
recording actions expressing user interest in a log; and using the log to generate the interest set for the user.
42. A system comprising:
one or more computers; and a machine-readable storage medium coupled to the one or more computers having instructions stored thereon which, when executed by the one or more computers, cause the one or more computers to perform operations comprising:
obtaining an interest set for a user, the interest set being a set of elements, each element representing a respective item in which the user has expressed interest through interaction with a data processing system;
applying an i-th hash function to each element of the interest set to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and determine, from the function values obtained from the k hash functions, k hash values of the interest set, wherein the i-th hash value is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, where k is an integer greater than or equal to 1; and assigning the user to each of k clusters, the i-th cluster being represented by the i-th hash value.
one or more computers; and a machine-readable storage medium coupled to the one or more computers having instructions stored thereon which, when executed by the one or more computers, cause the one or more computers to perform operations comprising:
obtaining an interest set for a user, the interest set being a set of elements, each element representing a respective item in which the user has expressed interest through interaction with a data processing system;
applying an i-th hash function to each element of the interest set to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and determine, from the function values obtained from the k hash functions, k hash values of the interest set, wherein the i-th hash value is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, where k is an integer greater than or equal to 1; and assigning the user to each of k clusters, the i-th cluster being represented by the i-th hash value.
43. The system of claim 42, wherein the operations further comprise:
recording actions expressing user interest in a log; and using the log to generate the interest set for the user.
recording actions expressing user interest in a log; and using the log to generate the interest set for the user.
44. The system of claim 42, wherein:
the interest set has m elements;
the i-th hash value is a minimum value of m applications of a one-way hash function, each application hashing an i-th seed value and a respective one of the m elements of the interest set.
the interest set has m elements;
the i-th hash value is a minimum value of m applications of a one-way hash function, each application hashing an i-th seed value and a respective one of the m elements of the interest set.
45. The system of claim 42, wherein the operations further comprise:
using the k user clusters to perform collaborative filtering for the user.
using the k user clusters to perform collaborative filtering for the user.
46. A system comprising:
one or more computers; and a machine-readable storage medium coupled to the one or more computers having instructions stored thereon which, when executed by the one or more computers, cause the one or more computers to perform operations comprising:
obtaining a respective interest set for each of multiple users, each interest set being a set of elements, each element representing a respective item in which the respective user has expressed interest through interaction with a data processing system;
for each of the multiple users, applying an i-th hash function to each element of the interest set of the user to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and determine, from the function values obtained from the k hash functions, k hash values of the respective interest set, wherein the i-th hash value of the respective interest set is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, and where k is an integer greater than or equal to 1; and assigning each of the multiple users to each of k clusters, the i-th cluster being represented by the i-th hash value of the respective interest set of the respective user, wherein the assignment of each of the multiple users to k clusters is done without regard to the assignment of any of the other users to k clusters.
one or more computers; and a machine-readable storage medium coupled to the one or more computers having instructions stored thereon which, when executed by the one or more computers, cause the one or more computers to perform operations comprising:
obtaining a respective interest set for each of multiple users, each interest set being a set of elements, each element representing a respective item in which the respective user has expressed interest through interaction with a data processing system;
for each of the multiple users, applying an i-th hash function to each element of the interest set of the user to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and determine, from the function values obtained from the k hash functions, k hash values of the respective interest set, wherein the i-th hash value of the respective interest set is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, and where k is an integer greater than or equal to 1; and assigning each of the multiple users to each of k clusters, the i-th cluster being represented by the i-th hash value of the respective interest set of the respective user, wherein the assignment of each of the multiple users to k clusters is done without regard to the assignment of any of the other users to k clusters.
47. The system of claim 46, wherein the operations further comprise:
recording actions expressing user interest in a log; and using the log to generate the interest sets for the multiple users.
recording actions expressing user interest in a log; and using the log to generate the interest sets for the multiple users.
48. The system of claim 46, wherein the operations further comprise:
obtaining a changed interest set for a first user of the multiple users;
determining k hash values for the first user using the changed interest set; and assigning the first user only to each of the respective k clusters represented by the k hash values determined using the changed interest set without changing the assignment of any of the other multiple users to clusters.
obtaining a changed interest set for a first user of the multiple users;
determining k hash values for the first user using the changed interest set; and assigning the first user only to each of the respective k clusters represented by the k hash values determined using the changed interest set without changing the assignment of any of the other multiple users to clusters.
49. The system of claim 46, where k is greater than 1.
50. A computer readable storage device, storing instructions that when executed by a processor cause a data processing apparatus to:
store a log of items selected by multiple users using a data processing system, the log of items identifying, for each of the multiple users, multiple items that the respective user has selected through interaction with the data processing system;
one or more computers configured to use the log to generate a respective interest set for each of the multiple users, each interest set being a set of elements, each element representing a respective item in which the respective user has selected through interaction with the data processing system;
one or more computers configured to apply, for each of the multiple users, an i-th hash function to each element of the interest set of the user to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and to determine, from the function values obtained from the k hash functions, k hash values of the respective interest set, wherein the i-th hash value of the respective interest set is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, and where k is an integer greater than or equal to 1;
one or more computers configured to assign each of the multiple users to each of k clusters, the i-th cluster being represented by the i-th hash value of the respective interest set of the respective user, wherein the assignment of each of the multiple users to k clusters is done without regard to the assignment of any of the other users to k clusters; and one or more computers configured to execute a collaborative filtering computer program application to provide information to a first user of the multiple users based on the assignment of the first user to one or more of the k clusters.
store a log of items selected by multiple users using a data processing system, the log of items identifying, for each of the multiple users, multiple items that the respective user has selected through interaction with the data processing system;
one or more computers configured to use the log to generate a respective interest set for each of the multiple users, each interest set being a set of elements, each element representing a respective item in which the respective user has selected through interaction with the data processing system;
one or more computers configured to apply, for each of the multiple users, an i-th hash function to each element of the interest set of the user to obtain a respective function value corresponding to the respective element, for each integer i between 1 and k, the k hash functions being distinct each from the others, and to determine, from the function values obtained from the k hash functions, k hash values of the respective interest set, wherein the i-th hash value of the respective interest set is a minimum value among the function values obtained by applying the i-th hash function to the elements of interest set of the user, and where k is an integer greater than or equal to 1;
one or more computers configured to assign each of the multiple users to each of k clusters, the i-th cluster being represented by the i-th hash value of the respective interest set of the respective user, wherein the assignment of each of the multiple users to k clusters is done without regard to the assignment of any of the other users to k clusters; and one or more computers configured to execute a collaborative filtering computer program application to provide information to a first user of the multiple users based on the assignment of the first user to one or more of the k clusters.
51. The computer readable storage device of claim 50, wherein the information comprises at least one of a recommendation, a prediction, or a ranking.
52. The computer readable storage device of claim 50, wherein k is between 5 and 10, inclusive.
53. The computer readable storage device of claim 50, wherein the instructions further cause a data processing apparatus to:
apply the fingerprint function to the interest sets to generate k sets of hash values, and select, as the respective k fingerprint values, a minimum value from each set of hash values.
apply the fingerprint function to the interest sets to generate k sets of hash values, and select, as the respective k fingerprint values, a minimum value from each set of hash values.
54. A system comprising:
one or more computers; and a computer-readable medium coupled to the one or more computers having instructions stored thereon which, when executed by the one or more computers, cause the one or more computers to perform operations comprising:
obtaining a vector that represents a particular user;
applying k locality sensitive hash functions to the vector to generate a set of k hash values, wherein k is an integer parameter, and wherein each hash value corresponds to a respective component of the vector; and assigning the particular user to k clusters, each of which is represented by a respective corresponding one of the k hash values.
one or more computers; and a computer-readable medium coupled to the one or more computers having instructions stored thereon which, when executed by the one or more computers, cause the one or more computers to perform operations comprising:
obtaining a vector that represents a particular user;
applying k locality sensitive hash functions to the vector to generate a set of k hash values, wherein k is an integer parameter, and wherein each hash value corresponds to a respective component of the vector; and assigning the particular user to k clusters, each of which is represented by a respective corresponding one of the k hash values.
55. The system of claim 54, wherein each component of the vector comprises a <term, weight> pair.
56. The system of claim 55, wherein, for each component of the vector, applying the k locality sensitive hash functions to the vector comprises:
applying, for each of k distinct seed values, a fingerprint function to an argument that consists of the term associated with the component, concatenated with the kth distinct seed value.
applying, for each of k distinct seed values, a fingerprint function to an argument that consists of the term associated with the component, concatenated with the kth distinct seed value.
57. The system of claim 56, wherein, for each component of the vector, applying the k locality sensitive hash functions to the vector comprises:
determining, for each of the k distinct seed values, whether a result of applying the fingerprint function to the argument has a least significant bit that equals a predetermined comparison value.
determining, for each of the k distinct seed values, whether a result of applying the fingerprint function to the argument has a least significant bit that equals a predetermined comparison value.
58. The system of claim 57, wherein, for each component of the vector, applying the k locality sensitive hash functions to the vector comprises:
initializing one of the minhash values of the set of k minhash values with a predetermined initialization value; and based on determining that the result has a least significant bit that equals the first comparison value, adding the weight associated with the component to the predetermined initialization value.
initializing one of the minhash values of the set of k minhash values with a predetermined initialization value; and based on determining that the result has a least significant bit that equals the first comparison value, adding the weight associated with the component to the predetermined initialization value.
59. The system of claim 57, wherein, for each component of the vector, applying the k locality sensitive hash functions to the vector comprises:
initializing one of the minhash values of the set of k minhash values with a predetermined initialization value; and based on determining that the result has a least significant bit that does not equal the first comparison value, subtracting the weight associated with the component from the predetermined initialization value.
initializing one of the minhash values of the set of k minhash values with a predetermined initialization value; and based on determining that the result has a least significant bit that does not equal the first comparison value, subtracting the weight associated with the component from the predetermined initialization value.
60. The system of claim 57, wherein the predetermined comparison value is 1.
61. A computer-implemented method comprising:
obtaining a vector that represents a particular user;
applying k locality sensitive hash functions to the vector to generate a set of k hash values, wherein k is an integer parameter, and wherein each hash value corresponds to a respective component of the vector; and assigning the particular user to k clusters, each of which is represented by a respective corresponding one of the k hash values.
obtaining a vector that represents a particular user;
applying k locality sensitive hash functions to the vector to generate a set of k hash values, wherein k is an integer parameter, and wherein each hash value corresponds to a respective component of the vector; and assigning the particular user to k clusters, each of which is represented by a respective corresponding one of the k hash values.
62. The method of claim 61, wherein each component of the vector comprises a <term, weight> pair.
63. The method of claim 62, wherein, for each component of the vector, applying the k locality sensitive hash functions to the vector comprises:
applying, for each of k distinct seed values, a fingerprint function to an argument that consists of the term associated with the component, concatenated with the kth distinct seed value.
applying, for each of k distinct seed values, a fingerprint function to an argument that consists of the term associated with the component, concatenated with the kth distinct seed value.
64. The method of claim 63, wherein, for each component of the vector, applying the k locality sensitive hash functions to the vector comprises:
determining, for each of the k distinct seed values, whether a result of applying the fingerprint function to the argument has a least significant bit that equals a predetermined comparison value.
determining, for each of the k distinct seed values, whether a result of applying the fingerprint function to the argument has a least significant bit that equals a predetermined comparison value.
65. The method of claim 64, wherein, for each component of the vector, applying the k locality sensitive hash functions to the vector comprises:
initializing one of the minhash values of the set of k minhash values with a predetermined initialization value; and based on determining that the result has a least significant bit that equals the first comparison value, adding the weight associated with the component to the predetermined initialization value.
initializing one of the minhash values of the set of k minhash values with a predetermined initialization value; and based on determining that the result has a least significant bit that equals the first comparison value, adding the weight associated with the component to the predetermined initialization value.
66. The method of claim 64, wherein, for each component of the vector, applying the k locality sensitive hash functions to the vector comprises:
initializing one of the minhash values of the set of k minhash values with a predetermined initialization value; and based on determining that the result has a least significant bit that does not equal the first comparison value, subtracting the weight associated with the component from the predetermined initialization value.
initializing one of the minhash values of the set of k minhash values with a predetermined initialization value; and based on determining that the result has a least significant bit that does not equal the first comparison value, subtracting the weight associated with the component from the predetermined initialization value.
67. The method of claim 64, wherein the predetermined comparison value is 1.
68. A computer readable storage medium encoded with a computer program, the program comprising instructions that when executed by one or more computers cause the one or more computers to perform operations comprising:
obtaining a vector that represents a particular user;
applying k locality sensitive hash functions to the vector to generate a set of k hash values, wherein k is an integer parameter, and wherein each hash value corresponds to a respective component of the vector; and assigning the particular user to k clusters, each of which is represented by a respective corresponding one of the k hash values.
obtaining a vector that represents a particular user;
applying k locality sensitive hash functions to the vector to generate a set of k hash values, wherein k is an integer parameter, and wherein each hash value corresponds to a respective component of the vector; and assigning the particular user to k clusters, each of which is represented by a respective corresponding one of the k hash values.
69. The medium of claim 68, wherein each component of the vector comprises a <term, weight> pair.
70. The medium of claim 69, wherein, for each component of the vector, applying the k locality sensitive hash functions to the vector comprises:
applying, for each of k distinct seed values, a fingerprint function to an argument that consists of the term associated with the component, concatenated with the kth distinct seed value.
applying, for each of k distinct seed values, a fingerprint function to an argument that consists of the term associated with the component, concatenated with the kth distinct seed value.
71. The medium of claim 70, wherein, for each component of the vector, applying the k locality sensitive hash functions to the vector comprises:
determining, for each of the k distinct seed values, whether a result of applying the fingerprint function to the argument has a least significant bit that equals a predetermined comparison value.
determining, for each of the k distinct seed values, whether a result of applying the fingerprint function to the argument has a least significant bit that equals a predetermined comparison value.
72. The medium of claim 71, wherein, for each component of the vector, applying the k locality sensitive hash functions to the vector comprises:
initializing one of the minhash values of the set of k minhash values with a predetermined initialization value; and based on determining that the result has a least significant bit that equals the first comparison value, adding the weight associated with the component to the predetermined initialization value.
initializing one of the minhash values of the set of k minhash values with a predetermined initialization value; and based on determining that the result has a least significant bit that equals the first comparison value, adding the weight associated with the component to the predetermined initialization value.
73. The medium of claim 71, wherein, for each component of the vector, applying the k locality sensitive hash functions to the vector comprises:
initializing one of the minhash values of the set of k minhash values with a predetermined initialization value; and based on determining that the result has a least significant bit that does not equal the first comparison value, subtracting the weight associated with the component from the predetermined initialization value.
initializing one of the minhash values of the set of k minhash values with a predetermined initialization value; and based on determining that the result has a least significant bit that does not equal the first comparison value, subtracting the weight associated with the component from the predetermined initialization value.
74. The medium of claim 71, wherein the predetermined comparison value is 1.
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US11/204,922 US7739314B2 (en) | 2005-08-15 | 2005-08-15 | Scalable user clustering based on set similarity |
US11/204,922 | 2005-08-15 | ||
PCT/US2006/031868 WO2007022199A2 (en) | 2005-08-15 | 2006-08-15 | Scalable user clustering based on set similarity |
Publications (2)
Publication Number | Publication Date |
---|---|
CA2619076A1 CA2619076A1 (en) | 2007-02-22 |
CA2619076C true CA2619076C (en) | 2014-02-11 |
Family
ID=37743789
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CA2619076A Expired - Fee Related CA2619076C (en) | 2005-08-15 | 2006-08-15 | Scalable user clustering based on set similarity |
Country Status (6)
Country | Link |
---|---|
US (4) | US7739314B2 (en) |
EP (1) | EP1915669A4 (en) |
JP (2) | JP5230421B2 (en) |
CN (2) | CN102682059B (en) |
CA (1) | CA2619076C (en) |
WO (1) | WO2007022199A2 (en) |
Families Citing this family (160)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6658423B1 (en) * | 2001-01-24 | 2003-12-02 | Google, Inc. | Detecting duplicate and near-duplicate files |
US7505964B2 (en) | 2003-09-12 | 2009-03-17 | Google Inc. | Methods and systems for improving a search ranking using related queries |
US7756919B1 (en) | 2004-06-18 | 2010-07-13 | Google Inc. | Large-scale data processing in a distributed and parallel processing enviornment |
US9065727B1 (en) | 2012-08-31 | 2015-06-23 | Google Inc. | Device identifier similarity models derived from online event signals |
US7937265B1 (en) | 2005-09-27 | 2011-05-03 | Google Inc. | Paraphrase acquisition |
US7617231B2 (en) * | 2005-12-07 | 2009-11-10 | Electronics And Telecommunications Research Institute | Data hashing method, data processing method, and data processing system using similarity-based hashing algorithm |
US7624117B2 (en) * | 2006-06-12 | 2009-11-24 | Sap Ag | Complex data assembly identifier thesaurus |
US8015162B2 (en) * | 2006-08-04 | 2011-09-06 | Google Inc. | Detecting duplicate and near-duplicate files |
US8190610B2 (en) * | 2006-10-05 | 2012-05-29 | Yahoo! Inc. | MapReduce for distributed database processing |
JP5233220B2 (en) * | 2006-10-11 | 2013-07-10 | 株式会社リコー | Page additional information sharing management method |
US20080104066A1 (en) * | 2006-10-27 | 2008-05-01 | Yahoo! Inc. | Validating segmentation criteria |
US8661029B1 (en) | 2006-11-02 | 2014-02-25 | Google Inc. | Modifying search result ranking based on implicit user feedback |
US9110975B1 (en) | 2006-11-02 | 2015-08-18 | Google Inc. | Search result inputs using variant generalized queries |
US7801885B1 (en) | 2007-01-25 | 2010-09-21 | Neal Akash Verma | Search engine system and method with user feedback on search results |
US8407226B1 (en) | 2007-02-16 | 2013-03-26 | Google Inc. | Collaborative filtering |
US8135718B1 (en) | 2007-02-16 | 2012-03-13 | Google Inc. | Collaborative filtering |
US8065254B1 (en) | 2007-02-19 | 2011-11-22 | Google Inc. | Presenting a diversity of recommendations |
US8938463B1 (en) | 2007-03-12 | 2015-01-20 | Google Inc. | Modifying search result ranking based on implicit user feedback and a model of presentation bias |
US8694374B1 (en) | 2007-03-14 | 2014-04-08 | Google Inc. | Detecting click spam |
JP4538757B2 (en) * | 2007-12-04 | 2010-09-08 | ソニー株式会社 | Information processing apparatus, information processing method, and program |
US7576370B2 (en) * | 2007-04-20 | 2009-08-18 | California Micro Devices | Low operating voltage electro-static discharge device and method |
US9092510B1 (en) | 2007-04-30 | 2015-07-28 | Google Inc. | Modifying search result ranking based on a temporal element of user feedback |
US8359309B1 (en) | 2007-05-23 | 2013-01-22 | Google Inc. | Modifying search result ranking based on corpus search statistics |
US8694511B1 (en) | 2007-08-20 | 2014-04-08 | Google Inc. | Modifying search result ranking based on populations |
US8909655B1 (en) | 2007-10-11 | 2014-12-09 | Google Inc. | Time based ranking |
US20090132571A1 (en) * | 2007-11-16 | 2009-05-21 | Microsoft Corporation | Efficient use of randomness in min-hashing |
US7925598B2 (en) * | 2008-01-24 | 2011-04-12 | Microsoft Corporation | Efficient weighted consistent sampling |
US20090198666A1 (en) * | 2008-02-01 | 2009-08-06 | Winston Ronald H | Affinity matching system and method |
US8184953B1 (en) * | 2008-02-22 | 2012-05-22 | Google Inc. | Selection of hash lookup keys for efficient retrieval |
US20090216757A1 (en) * | 2008-02-27 | 2009-08-27 | Robi Sen | System and Method for Performing Frictionless Collaboration for Criteria Search |
US8824422B2 (en) | 2008-03-11 | 2014-09-02 | Intel Corporation | Techniques enabling dynamic bandwidth reservation in a wireless personal area network |
CN101685458B (en) * | 2008-09-27 | 2012-09-19 | 华为技术有限公司 | Recommendation method and system based on collaborative filtering |
US8640163B2 (en) * | 2008-09-30 | 2014-01-28 | Microsoft Corporation | Determining user-to-user similarities in an online media environment |
JP5229731B2 (en) * | 2008-10-07 | 2013-07-03 | インターナショナル・ビジネス・マシーンズ・コーポレーション | Cache mechanism based on update frequency |
US8682998B2 (en) * | 2008-10-31 | 2014-03-25 | Software Ag | Method and server cluster for map reducing flow services and large documents |
US8396865B1 (en) | 2008-12-10 | 2013-03-12 | Google Inc. | Sharing search engine relevance data between corpora |
US20100169258A1 (en) * | 2008-12-31 | 2010-07-01 | Microsoft Corporation | Scalable Parallel User Clustering in Discrete Time Window |
US20100191734A1 (en) * | 2009-01-23 | 2010-07-29 | Rajaram Shyam Sundar | System and method for classifying documents |
US20100228951A1 (en) * | 2009-03-05 | 2010-09-09 | Xerox Corporation | Parallel processing management framework |
US8209664B2 (en) * | 2009-03-18 | 2012-06-26 | Microsoft Corporation | High level programming extensions for distributed data parallel processing |
US8239847B2 (en) * | 2009-03-18 | 2012-08-07 | Microsoft Corporation | General distributed reduction for data parallel computing |
US9009146B1 (en) | 2009-04-08 | 2015-04-14 | Google Inc. | Ranking search results based on similar queries |
JP5331549B2 (en) * | 2009-04-09 | 2013-10-30 | 株式会社エヌ・ティ・ティ・ドコモ | Distributed processing system and distributed processing method |
US8204838B2 (en) * | 2009-04-10 | 2012-06-19 | Microsoft Corporation | Scalable clustering |
US8510538B1 (en) * | 2009-04-13 | 2013-08-13 | Google Inc. | System and method for limiting the impact of stragglers in large-scale parallel data processing |
US20100301114A1 (en) * | 2009-05-26 | 2010-12-02 | Lo Faro Walter F | Method and system for transaction based profiling of customers within a merchant network |
US8321873B2 (en) * | 2009-06-09 | 2012-11-27 | Yahoo! Inc. | System and method for offline data generation for online system analysis |
US8447760B1 (en) | 2009-07-20 | 2013-05-21 | Google Inc. | Generating a related set of documents for an initial set of documents |
US8498974B1 (en) | 2009-08-31 | 2013-07-30 | Google Inc. | Refining search results |
WO2011034475A1 (en) * | 2009-09-21 | 2011-03-24 | Telefonaktiebolaget Lm Ericsson (Publ) | Method and apparatus for executing a recommendation |
US20110077998A1 (en) * | 2009-09-29 | 2011-03-31 | Microsoft Corporation | Categorizing online user behavior data |
US8972391B1 (en) | 2009-10-02 | 2015-03-03 | Google Inc. | Recent interest based relevance scoring |
US8244767B2 (en) * | 2009-10-09 | 2012-08-14 | Stratify, Inc. | Composite locality sensitive hash based processing of documents |
US9355171B2 (en) * | 2009-10-09 | 2016-05-31 | Hewlett Packard Enterprise Development Lp | Clustering of near-duplicate documents |
US9009156B1 (en) * | 2009-11-10 | 2015-04-14 | Hrl Laboratories, Llc | System for automatic data clustering utilizing bio-inspired computing models |
US8874555B1 (en) | 2009-11-20 | 2014-10-28 | Google Inc. | Modifying scoring data based on historical changes |
CN102111392A (en) * | 2009-12-24 | 2011-06-29 | 王子嘉 | System for making friends based on interest rank |
CN102141995B (en) * | 2010-01-29 | 2013-06-12 | 国际商业机器公司 | System and method for simplifying transmission in parallel computing system |
US8874600B2 (en) | 2010-01-30 | 2014-10-28 | International Business Machines Corporation | System and method for building a cloud aware massive data analytics solution background |
US8615514B1 (en) | 2010-02-03 | 2013-12-24 | Google Inc. | Evaluating website properties by partitioning user feedback |
US8924379B1 (en) | 2010-03-05 | 2014-12-30 | Google Inc. | Temporal-based score adjustments |
US8959093B1 (en) | 2010-03-15 | 2015-02-17 | Google Inc. | Ranking search results based on anchors |
US8838587B1 (en) | 2010-04-19 | 2014-09-16 | Google Inc. | Propagating query classifications |
US8555265B2 (en) | 2010-05-04 | 2013-10-08 | Google Inc. | Parallel processing of data |
US8935232B2 (en) * | 2010-06-04 | 2015-01-13 | Yale University | Query execution systems and methods |
US9495427B2 (en) | 2010-06-04 | 2016-11-15 | Yale University | Processing of data using a database system in communication with a data processing framework |
US9336263B2 (en) | 2010-06-04 | 2016-05-10 | Yale University | Data loading systems and methods |
US9311403B1 (en) * | 2010-06-16 | 2016-04-12 | Google Inc. | Hashing techniques for data set similarity determination |
US9623119B1 (en) | 2010-06-29 | 2017-04-18 | Google Inc. | Accentuating search results |
US8832083B1 (en) | 2010-07-23 | 2014-09-09 | Google Inc. | Combining user feedback |
US9454763B2 (en) | 2010-08-24 | 2016-09-27 | Adobe Systems Incorporated | Distribution of offer to a social group by sharing based on qualifications |
US8661042B2 (en) * | 2010-10-18 | 2014-02-25 | Hewlett-Packard Development Company, L.P. | Collaborative filtering with hashing |
CN102467570B (en) * | 2010-11-17 | 2014-03-12 | 日电（中国）有限公司 | Connection query system and method for distributed data warehouse |
CN102480512B (en) | 2010-11-29 | 2015-08-12 | 国际商业机器公司 | For the method and apparatus of expansion servers end disposal ability |
US20120144022A1 (en) * | 2010-12-07 | 2012-06-07 | Microsoft Corporation | Content recommendation through consumer-defined authorities |
US8499222B2 (en) * | 2010-12-14 | 2013-07-30 | Microsoft Corporation | Supporting distributed key-based processes |
US8631017B2 (en) * | 2010-12-16 | 2014-01-14 | Hewlett-Packard Development, L.P. | Collaborative filtering with hashing |
US9307048B2 (en) | 2010-12-28 | 2016-04-05 | Microsoft Technology Licensing, Llc | System and method for proactive task scheduling of a copy of outlier task in a computing environment |
US9002867B1 (en) | 2010-12-30 | 2015-04-07 | Google Inc. | Modifying ranking data based on document changes |
US9177327B2 (en) | 2011-03-02 | 2015-11-03 | Adobe Systems Incorporated | Sequential engine that computes user and offer matching into micro-segments |
US8635226B2 (en) * | 2011-03-02 | 2014-01-21 | Adobe Systems Incorporated | Computing user micro-segments for offer matching |
JP2012204894A (en) * | 2011-03-24 | 2012-10-22 | Toshiba Corp | Information recommendation device |
WO2012146508A1 (en) * | 2011-04-25 | 2012-11-01 | Alcatel Lucent | Privacy protection in recommendation services |
CN102779137A (en) * | 2011-05-13 | 2012-11-14 | 北京搜狗科技发展有限公司 | Method and device for treating personalized feedback information of users about webpages |
US8954967B2 (en) * | 2011-05-31 | 2015-02-10 | International Business Machines Corporation | Adaptive parallel data processing |
US8856047B2 (en) | 2011-06-21 | 2014-10-07 | Microsoft Corporation | Fast personalized page rank on map reduce |
CN103597473B (en) * | 2011-06-30 | 2018-06-05 | 慧与发展有限责任合伙企业 | For merging the system and method for partially polymerized query result |
WO2013009503A2 (en) | 2011-07-08 | 2013-01-17 | Yale University | Query execution systems and methods |
CN102316167B (en) * | 2011-09-26 | 2013-11-06 | 中国科学院计算机网络信息中心 | Website recommending method, system thereof and network server |
US9031992B1 (en) * | 2011-09-30 | 2015-05-12 | Emc Corporation | Analyzing big data |
JP5716966B2 (en) * | 2011-12-20 | 2015-05-13 | 株式会社日立製作所 | Data analysis apparatus, data analysis method and program |
US20130179252A1 (en) * | 2012-01-11 | 2013-07-11 | Yahoo! Inc. | Method or system for content recommendations |
US8838435B2 (en) | 2012-01-11 | 2014-09-16 | Motorola Mobility Llc | Communication processing |
JP5825122B2 (en) * | 2012-01-31 | 2015-12-02 | 富士通株式会社 | GENERATION PROGRAM, GENERATION METHOD, AND GENERATION SYSTEM |
US9262216B2 (en) | 2012-02-14 | 2016-02-16 | Microsoft Technologies Licensing, LLC | Computing cluster with latency control |
US8983998B1 (en) | 2012-04-25 | 2015-03-17 | Google Inc. | Prioritizing points of interest in unfamiliar regions |
US9053185B1 (en) | 2012-04-30 | 2015-06-09 | Google Inc. | Generating a representative model for a plurality of models identified by similar feature data |
US8527526B1 (en) | 2012-05-02 | 2013-09-03 | Google Inc. | Selecting a list of network user identifiers based on long-term and short-term history data |
US20150242906A1 (en) * | 2012-05-02 | 2015-08-27 | Google Inc. | Generating a set of recommended network user identifiers from a first set of network user identifiers and advertiser bid data |
WO2013171758A2 (en) * | 2012-05-18 | 2013-11-21 | Tata Consultancy Services Limited | System and method for creating structured event objects |
US8914500B1 (en) | 2012-05-21 | 2014-12-16 | Google Inc. | Creating a classifier model to determine whether a network user should be added to a list |
JP5853866B2 (en) | 2012-06-05 | 2016-02-09 | 富士通株式会社 | Allocation program, allocation device, and allocation method |
CA2779235C (en) * | 2012-06-06 | 2019-05-07 | Ibm Canada Limited - Ibm Canada Limitee | Identifying unvisited portions of visited information |
US8886575B1 (en) | 2012-06-27 | 2014-11-11 | Google Inc. | Selecting an algorithm for identifying similar user identifiers based on predicted click-through-rate |
EP2688264B1 (en) * | 2012-07-16 | 2016-08-24 | Alcatel Lucent | Method and apparatus for privacy protected clustering of user interest profiles |
US8874589B1 (en) | 2012-07-16 | 2014-10-28 | Google Inc. | Adjust similar users identification based on performance feedback |
US8782197B1 (en) | 2012-07-17 | 2014-07-15 | Google, Inc. | Determining a model refresh rate |
TWI459223B (en) * | 2012-08-15 | 2014-11-01 | Hon Hai Prec Ind Co Ltd | System and method for creating indexes of massive data |
US9104767B2 (en) * | 2012-08-28 | 2015-08-11 | Adobe Systems Incorporated | Identifying web pages that are likely to guide browsing viewers to improve conversion rate |
US8886799B1 (en) | 2012-08-29 | 2014-11-11 | Google Inc. | Identifying a similar user identifier |
US20150169727A1 (en) * | 2012-09-03 | 2015-06-18 | Sony Corporation | Information processing apparatus, information processing method, and system |
CN103679494B (en) * | 2012-09-17 | 2018-04-03 | 阿里巴巴集团控股有限公司 | Commodity information recommendation method and device |
US8983888B2 (en) | 2012-11-07 | 2015-03-17 | Microsoft Technology Licensing, Llc | Efficient modeling system for user recommendation using matrix factorization |
US9278255B2 (en) | 2012-12-09 | 2016-03-08 | Arris Enterprises, Inc. | System and method for activity recognition |
US10212986B2 (en) | 2012-12-09 | 2019-02-26 | Arris Enterprises Llc | System, apparel, and method for identifying performance of workout routines |
US9471390B2 (en) | 2013-01-16 | 2016-10-18 | International Business Machines Corporation | Scheduling mapreduce jobs in a cluster of dynamically available servers |
US10229367B2 (en) * | 2013-02-06 | 2019-03-12 | Jacob Drew | Collaborative analytics map reduction classification learning systems and methods |
US9183499B1 (en) | 2013-04-19 | 2015-11-10 | Google Inc. | Evaluating quality based on neighbor features |
US10939258B2 (en) * | 2013-04-19 | 2021-03-02 | xAd, Inc. | System and method for marketing mobile advertising supplies |
US9467452B2 (en) * | 2013-05-13 | 2016-10-11 | International Business Machines Corporation | Transferring services in a networked environment |
EP2824589A1 (en) * | 2013-07-12 | 2015-01-14 | Thomson Licensing | Method for enriching a multimedia content, and corresponding device. |
EP2827277A1 (en) * | 2013-07-16 | 2015-01-21 | Alcatel Lucent | Privacy protection in personalisation services |
CN103886003A (en) * | 2013-09-22 | 2014-06-25 | 天津思博科科技发展有限公司 | Collaborative filtering processor |
KR101482700B1 (en) * | 2013-09-27 | 2015-01-14 | (주)잉카엔트웍스 | Method For Verifying Integrity of Program Using Hash |
US8819038B1 (en) * | 2013-10-06 | 2014-08-26 | Yahoo! Inc. | System and method for performing set operations with defined sketch accuracy distribution |
CN104035949B (en) * | 2013-12-10 | 2017-05-10 | 南京信息工程大学 | Similarity data retrieval method based on locality sensitive hashing (LASH) improved algorithm |
CN103678672B (en) * | 2013-12-25 | 2017-05-24 | 北京中兴通德网络科技有限公司 | Method for recommending information |
US10574508B1 (en) | 2014-01-27 | 2020-02-25 | Amazon Technologies, Inc. | MapReduce optimization for partitioned intermediate output |
US10055506B2 (en) | 2014-03-18 | 2018-08-21 | Excalibur Ip, Llc | System and method for enhanced accuracy cardinality estimation |
US20150379022A1 (en) * | 2014-06-27 | 2015-12-31 | General Electric Company | Integrating Execution of Computing Analytics within a Mapreduce Processing Environment |
KR101601820B1 (en) * | 2014-08-20 | 2016-03-14 | 경기대학교 산학협력단 | Method and program for similar user index |
US10831765B1 (en) * | 2014-10-21 | 2020-11-10 | Zoosk, Inc. | System and method for providing information about users who performed internet-based activities |
JP6334431B2 (en) * | 2015-02-18 | 2018-05-30 | 株式会社日立製作所 | Data analysis apparatus, data analysis method, and data analysis program |
CN104715021B (en) * | 2015-02-27 | 2018-09-11 | 南京邮电大学 | A kind of learning method of the Multi-label learning based on hash method |
US20160275169A1 (en) * | 2015-03-17 | 2016-09-22 | Infoutopia Co., Ltd. | System and method of generating initial cluster centroids |
CN104778234A (en) * | 2015-03-31 | 2015-07-15 | 南京邮电大学 | Multi-label file nearest neighbor search method based on LSH (Locality Sensitive Hashing) technology |
US10095807B2 (en) * | 2015-04-28 | 2018-10-09 | Microsoft Technology Licensing, Llc | Linked data processor for database storage |
CN104899267B (en) * | 2015-05-22 | 2017-12-19 | 中国电子科技集团公司第二十八研究所 | A kind of integrated data method for digging of social network sites account similarity |
CN106469163A (en) * | 2015-08-18 | 2017-03-01 | 中兴通讯股份有限公司 | A kind of public number recommends method and system |
US10140327B2 (en) * | 2015-08-24 | 2018-11-27 | Palantir Technologies Inc. | Feature clustering of users, user correlation database access, and user interface generation system |
CN105162875B (en) * | 2015-09-23 | 2019-03-12 | 四川师范大学 | Big data group method for allocating tasks and device |
US10530892B2 (en) * | 2015-09-28 | 2020-01-07 | Microsoft Technology Licensing, Llc | Processing request for multi-versioned service |
CN105224328A (en) * | 2015-10-08 | 2016-01-06 | 浪潮电子信息产业股份有限公司 | A kind of user interface creating method and system, server |
EP3283984A4 (en) * | 2015-11-03 | 2018-04-04 | Hewlett-Packard Enterprise Development LP | Relevance optimized representative content associated with a data storage system |
US10116536B2 (en) * | 2015-11-18 | 2018-10-30 | Adobe Systems Incorporated | Identifying multiple devices belonging to a single user |
US10778707B1 (en) * | 2016-05-12 | 2020-09-15 | Amazon Technologies, Inc. | Outlier detection for streaming data using locality sensitive hashing |
CN106227881B (en) * | 2016-08-04 | 2021-11-09 | 腾讯科技（深圳）有限公司 | Information processing method and server |
US20180052864A1 (en) * | 2016-08-16 | 2018-02-22 | International Business Machines Corporation | Facilitating the sharing of relevant content |
CN106355449B (en) | 2016-08-31 | 2021-09-07 | 腾讯科技（深圳）有限公司 | User selection method and device |
US10637940B2 (en) * | 2016-11-21 | 2020-04-28 | Roku, Inc. | Streaming content based on skip histories |
CN106543880B (en) * | 2016-12-12 | 2018-12-18 | 河北晨阳工贸集团有限公司 | A kind of environmental protection coating material and preparation method thereof that can promote spectacle-frame comfort level |
CN106649781B (en) * | 2016-12-28 | 2020-11-20 | 北京小米移动软件有限公司 | Application recommendation method and device |
CN107122390B (en) * | 2017-03-04 | 2020-09-25 | 华数传媒网络有限公司 | Recommendation system construction method based on user group |
US20190057430A1 (en) * | 2017-08-17 | 2019-02-21 | Retailcommon Inc. | Method and system for clustering products in an electronic commerce environment |
US10769306B2 (en) * | 2017-09-21 | 2020-09-08 | International Business Machines Corporation | Applying a differential privacy operation on a cluster of data |
US11100573B1 (en) * | 2018-02-28 | 2021-08-24 | Intuit Inc. | Credit score cohort analysis engine |
US11023495B2 (en) * | 2018-03-19 | 2021-06-01 | Adobe Inc. | Automatically generating meaningful user segments |
EP3642690A1 (en) * | 2018-08-30 | 2020-04-29 | Google LLC | Percentile linkage clustering |
US11501257B2 (en) * | 2019-12-09 | 2022-11-15 | Jpmorgan Chase Bank, N.A. | Method and apparatus for implementing a role-based access control clustering machine learning model execution module |
CN113420141B (en) * | 2021-06-24 | 2022-10-04 | 中国人民解放军陆军工程大学 | Sensitive data searching method based on Hash clustering and context information |
Family Cites Families (29)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6850252B1 (en) * | 1999-10-05 | 2005-02-01 | Steven M. Hoffberg | Intelligent electronic appliance system and method |
US5832182A (en) * | 1996-04-24 | 1998-11-03 | Wisconsin Alumni Research Foundation | Method and system for data clustering for very large databases |
US5909677A (en) | 1996-06-18 | 1999-06-01 | Digital Equipment Corporation | Method for determining the resemblance of documents |
US6134532A (en) * | 1997-11-14 | 2000-10-17 | Aptex Software, Inc. | System and method for optimal adaptive matching of users to most relevant entity and information in real-time |
US6374251B1 (en) * | 1998-03-17 | 2002-04-16 | Microsoft Corporation | Scalable system for clustering of large databases |
US6119124A (en) | 1998-03-26 | 2000-09-12 | Digital Equipment Corporation | Method for clustering closely resembling data objects |
US6317722B1 (en) | 1998-09-18 | 2001-11-13 | Amazon.Com, Inc. | Use of electronic shopping carts to generate personal recommendations |
US6415297B1 (en) * | 1998-11-17 | 2002-07-02 | International Business Machines Corporation | Parallel database support for workflow management systems |
US6564202B1 (en) * | 1999-01-26 | 2003-05-13 | Xerox Corporation | System and method for visually representing the contents of a multiple data object cluster |
US6347313B1 (en) * | 1999-03-01 | 2002-02-12 | Hewlett-Packard Company | Information embedding based on user relevance feedback for object retrieval |
US6564261B1 (en) * | 1999-05-10 | 2003-05-13 | Telefonaktiebolaget Lm Ericsson (Publ) | Distributed system to intelligently establish sessions between anonymous users over various networks |
US6542889B1 (en) * | 2000-01-28 | 2003-04-01 | International Business Machines Corporation | Methods and apparatus for similarity text search based on conceptual indexing |
US6854069B2 (en) * | 2000-05-02 | 2005-02-08 | Sun Microsystems Inc. | Method and system for achieving high availability in a networked computer system |
US6697800B1 (en) * | 2000-05-19 | 2004-02-24 | Roxio, Inc. | System and method for determining affinity using objective and subjective data |
AU2002223811B8 (en) * | 2000-11-20 | 2007-10-18 | British Telecommunications Public Limited Company | Method of managing resources |
US7069367B2 (en) * | 2000-12-29 | 2006-06-27 | Intel Corporation | Method and apparatus for avoiding race condition with edge-triggered interrupts |
US6968334B2 (en) * | 2001-05-15 | 2005-11-22 | Nokia Corporation | Method and business process to maintain privacy in distributed recommendation systems |
WO2003017055A2 (en) * | 2001-08-15 | 2003-02-27 | Visa International Service Association | Method and system for delivering multiple services electronically to customers via a centralized portal architecture |
US7203343B2 (en) | 2001-09-21 | 2007-04-10 | Hewlett-Packard Development Company, L.P. | System and method for determining likely identity in a biometric database |
US7512652B1 (en) * | 2001-09-28 | 2009-03-31 | Aol Llc, A Delaware Limited Liability Company | Passive personalization of buddy lists |
US7343365B2 (en) * | 2002-02-20 | 2008-03-11 | Microsoft Corporation | Computer system architecture for automatic context associations |
US7899067B2 (en) * | 2002-05-31 | 2011-03-01 | Cisco Technology, Inc. | Method and apparatus for generating and using enhanced tree bitmap data structures in determining a longest prefix match |
US20040098458A1 (en) * | 2002-09-16 | 2004-05-20 | Husain Syed Mohammad Amir | Distributed computing infrastructure including multiple collaborative sessions |
US7228351B2 (en) * | 2002-12-31 | 2007-06-05 | International Business Machines Corporation | Method and apparatus for managing resource contention in a multisystem cluster |
US20040139072A1 (en) * | 2003-01-13 | 2004-07-15 | Broder Andrei Z. | System and method for locating similar records in a database |
US20060168006A1 (en) * | 2003-03-24 | 2006-07-27 | Mr. Marvin Shannon | System and method for the classification of electronic communication |
US7831679B2 (en) * | 2003-10-15 | 2010-11-09 | Microsoft Corporation | Guiding sensing and preferences for context-sensitive services |
US7257571B2 (en) * | 2004-01-26 | 2007-08-14 | Microsoft Corporation | Automatic query clustering |
US7433869B2 (en) * | 2005-07-01 | 2008-10-07 | Ebrary, Inc. | Method and apparatus for document clustering and document sketching |
-
2005
- 2005-08-15 US US11/204,922 patent/US7739314B2/en not_active Expired - Fee Related
-
2006
- 2006-08-15 WO PCT/US2006/031868 patent/WO2007022199A2/en active Application Filing
- 2006-08-15 CN CN201210016687.9A patent/CN102682059B/en active Active
- 2006-08-15 JP JP2008527069A patent/JP5230421B2/en not_active Expired - Fee Related
- 2006-08-15 CN CNA2006800381007A patent/CN101535944A/en active Pending
- 2006-08-15 EP EP06801549A patent/EP1915669A4/en not_active Ceased
- 2006-08-15 CA CA2619076A patent/CA2619076C/en not_active Expired - Fee Related
-
2010
- 2010-05-06 US US12/774,775 patent/US7962529B1/en not_active Expired - Fee Related
-
2011
- 2011-04-01 US US13/078,122 patent/US8185561B1/en not_active Expired - Fee Related
-
2012
- 2012-04-04 US US13/439,030 patent/US20120191714A1/en not_active Abandoned
- 2012-11-16 JP JP2012252056A patent/JP5538510B2/en not_active Expired - Fee Related
Also Published As
Publication number | Publication date |
---|---|
JP5538510B2 (en) | 2014-07-02 |
WO2007022199A3 (en) | 2009-05-22 |
US7962529B1 (en) | 2011-06-14 |
CN102682059A (en) | 2012-09-19 |
CN102682059B (en) | 2014-11-12 |
US20120191714A1 (en) | 2012-07-26 |
EP1915669A4 (en) | 2011-01-05 |
JP2013033551A (en) | 2013-02-14 |
JP5230421B2 (en) | 2013-07-10 |
US20070038659A1 (en) | 2007-02-15 |
EP1915669A2 (en) | 2008-04-30 |
CA2619076A1 (en) | 2007-02-22 |
JP2009505290A (en) | 2009-02-05 |
US8185561B1 (en) | 2012-05-22 |
WO2007022199A2 (en) | 2007-02-22 |
US7739314B2 (en) | 2010-06-15 |
CN101535944A (en) | 2009-09-16 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
CA2619076C (en) | Scalable user clustering based on set similarity | |
US20170293865A1 (en) | Real-time updates to item recommendation models based on matrix factorization | |
US20170214676A1 (en) | Reducing latency | |
US20160210321A1 (en) | Real-time content recommendation system | |
US20180189417A1 (en) | Dynamic faceting for personalized search and discovery | |
US11403663B2 (en) | Ad preference embedding model and lookalike generation engine | |
US11790020B2 (en) | System and method for delivery of content based on matching of user profiles with content metadata | |
US8468051B2 (en) | Selecting and delivering personalized content | |
US20130013429A1 (en) | Systems, methods, and media for providing advertisements based upon relational data | |
US10417286B1 (en) | Content Selection | |
Pal | An efficient system using implicit feedback and lifelong learning approach to improve recommendation | |
US10810493B1 (en) | Training and/or utilizing recurrent neural network model to determine subsequent source(s) for electronic resource interaction | |
US20230259815A1 (en) | Machine learning techniques for user group based content distribution | |
US20220318644A1 (en) | Privacy preserving machine learning predictions | |
JP7230231B2 (en) | Robust model performance across heterogeneous subgroups within the same group | |
US11842379B2 (en) | Method and system for obtaining item-based recommendations | |
JP7223164B2 (en) | Data integrity optimization | |
US11586676B2 (en) | Mode-specific search query processing | |
Suchacka et al. | Characterizing Web Sessions Of E-Customers Interested In Traditional And Innovative Products. | |
Suvarna et al. | Context Aware Service Information Extraction from Bigdata | |
ANUSHA et al. | Towards Keyword Based Recommendation for Big Data Applications |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
EEER | Examination request | ||
MKLA | Lapsed |
Effective date: 20210816 |