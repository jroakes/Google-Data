BACKGROUND
Computing devices can perform various functions, such as executing applications, receiving user input, and outputting information for display. For instance, computing devices may execute applications, such as an email client, travel assistant, messaging client, and the like. Software developers may write such applications in human-readable source code that is compiled into machine-readable code. In some instances, machine-readable code may be organized into discrete executable components, such as compiled classes in an object-oriented design. An application may include one or more executable components that implement various functionality. In some distributed environments, a user computing device (e.g., a smartphone) may use a media store application to search for and install applications, which are provided by a remote computing system. Typically, when a user selects an application in the media store application to install at the user computing device, the remote computing system sends a single file that includes all of the executable components to perform all functionality of the application, regardless of whether the user actually uses all the functionality. As applications grow in size, the amount time needed to download and install such applications may grow, thereby requiring a user to wait greater amounts of time to install and execute applications.
SUMMARY
In some examples, a method includes receiving, by a supervisor component executing at a computing device, a request to execute particular functionality of an application; responsive to determining that an application container for maintaining installable sub-packages of the application is not allocated in memory of the computing device, retrieving, by the supervisor component, an application definition from a first remote computing system, wherein the application definition defines a plurality of mappings between the installable sub-packages of the application and user-specified identifiers; responsive to allocating the application container in the memory of the computing device, initiating, by the supervisor component and based at least in part on a user-specified identifier of the request, the particular functionality of the application; responsive to determining, by the application container executing at the computing device, based at least in part on the application definition and the user-specified identifier, that an installable sub-package for the particular functionality is not stored at the computing device, retrieving, by the application container, the installable sub-package that includes a plurality of executable components from a second remote computing system; and executing, by the application container and using the plurality of executable components, the particular functionality of the application.
In some examples, a computing device comprising: one or more computer processors; and a memory comprising instructions that when executed by the one or more computer processors cause the one or more computer processors to: receive, by a supervisor component of the computing device, a request to execute particular functionality of an application; responsive to determining that an application container for maintaining installable sub-packages of the application is not allocated in memory of the computing device, retrieve, by the supervisor component, an application definition from a first remote computing system, wherein the application definition defines a plurality of mappings between the installable sub-packages of the application and user-specified identifiers; responsive to allocating the application container in the memory of the computing device, initiate, by the supervisor component and based at least in part on a user-specified identifier of the request, the particular functionality of the application; responsive to determining, by the application container of the computing device, based at least in part on the application definition and the user-specified identifier, that an installable sub-package for the particular functionality is not stored at the computing device, retrieving, by the application container, the installable sub-package that includes a plurality of executable components from a second remote computing system; and execute, by the application container and using the plurality of executable components, the particular functionality of the application.
A non-transitory computer-readable storage medium encoded with instructions that, when executed, cause at least one processor of a computing device to: receive, by a supervisor component of the computing device, a request to execute particular functionality of an application; responsive to determining that an application container for maintaining installable sub-packages of the application is not allocated in memory of the computing device, retrieve, by the supervisor component, an application definition from a first remote computing system, wherein the application definition defines a plurality of mappings between the installable sub-packages of the application and user-specified identifiers; responsive to allocating the application container in the memory of the computing device, initiate, by the supervisor component and based at least in part on a user-specified identifier of the request, the particular functionality of the application; responsive to determining, by the application container of the computing device, based at least in part on the application definition and the user-specified identifier, that an installable sub-package for the particular functionality is not stored at the computing device, retrieving, by the application container, the installable sub-package that includes a plurality of executable components from a second remote computing system; and execute, by the application container and using the plurality of executable components, the particular functionality of the application.
The details of one or more examples are set forth in the accompanying drawings and the description below. Other features, objects, and advantages of the disclosure will be apparent from the description and drawings, and from the claims.
BRIEF DESCRIPTION OF DRAWINGS
FIG. 1 is a conceptual diagram illustrating an example computing device with application containers for dynamically loading installable sub-packages, in accordance with techniques of this disclosure.
FIG. 2 is a block diagram illustrating further details of a computing device, in accordance with one or more aspects of the present disclosure.
FIG. 3 is a sequence diagram illustrating example operations of a computing device with application containers for dynamically loading installable sub-packages, in accordance with techniques of this disclosure.
FIG. 4 is a conceptual diagram of an application containers for dynamically loading installable sub-packages and corresponding libraries, in accordance with techniques of this disclosure.
FIG. 5 is a flow diagram illustrating example operations of a computing device with application containers for dynamically loading installable sub-packages, in accordance with techniques of this disclosure.
DETAILED DESCRIPTION
In general, techniques of the present disclosure provide for an application container that dynamically loads installable sub-packages in a piecemeal manner, on-demand, as functionalities provided by the installable sub-packages are needed by an application. An application container may provide a self-contained execution environment for an application, which may be comprised of multiple sub-packages and each sub-package includes one or more executable components. As an example, a software developer may design an application (e.g., a navigation application) with discrete sets of functionality. The navigation application may include a turn-by-turn navigation user interface, a point-of-interest user interface (e.g., displaying details for a point of interest on a map), and a settings user interface. The software developer may design the application with three different sub-packages, where each sub-package includes a set of executable components to implement the functionality for the respective user interface.
While all of the sub-packages for the application collectively may be large in size, an application container for the application may retrieve, install, and execute only those sub-packages necessary to provide functionality requested by a user. As such, when installing and/or executing the application, only a portion of sub-packages for the application need to reside locally at the computing device for the application to execute. When a user requests additional functionality for the application, the application container may automatically retrieve the needed sub-packages that provide the requested functionality. In this way, applications may install and load more quickly because the entire set of sub-packages for the application need not be retrieved and installed if only a subset of the application's functionality is needed. Moreover, in some examples, an application container may provide for updating a container runtime without requiring an update of the operating system or the runtime system of the computing device.
FIG. 1 is a conceptual diagram illustrating an example computing device 100 with application containers 102A-102C (“application containers 102”) for dynamically loading installable sub-packages, in accordance with techniques of this disclosure. Examples of computing device 100 may include, but are not limited to, portable or mobile devices such as mobile phones (including smart phones), laptop computers, tablet computers, wearable computing devices such as smart watches or computerized eyewear, smart television platforms, cameras, personal digital assistants (PDAs), etc. In some examples, computing device 102 may include stationary computing devices such as desktop computers, servers, mainframes, etc.
As shown in FIG. 1, computing device 100 includes application containers 102, system runtime 126, operating system 136, and hardware components 138. Computing device 100 may communicate with one or more other remote computing systems 142A-142C (“remote computing systems 142”) via network 140 and communication links 148A-148B. As shown in FIG. 1, network 140 represents any public or private communication network, for instance, a cellular, Wi-Fi, and/or other type of network for transmitting data between computing devices. Computing device 100 and remote computing systems 142 may send and receive data across network 140 using any suitable communication techniques. For example, computing device 100 may be operatively coupled to network 140 using communication link 148A. Remote computing system 142A may be operatively coupled to network 140 by communication link 148B. Network 140 may include network hubs, network switches, network routers, etc., that are operatively inter-coupled thereby providing for the exchange of information between computing device 102 and remote computing systems 142. In some examples, communication links 138A-138B may be Ethernet, ATM or other network connections. Such connections may be wireless and/or wired connections.
Hardware components 138 may include but are not limited to computer processors, communication units (e.g., modems, network interface controllers, and the like), input components, output components, a presence-sensitive display, volatile and non-volatile memories, and a power source to name only a few examples. Further description of hardware components 138 is provided with respect to FIG. 2. Operating system 136 may execute on hardware components 138 and manage hardware and software components of computing device 100. For instance, operating system 136 may perform memory management, process scheduling and non-volatile storage management. Operating system 136 may also provide network and security services to applications executing at computing device 100. Operating system 136 may also perform more or fewer functions than described above.
Runtime system 126 implements an execution model for applications that are built according to a particular programming language in which the applications are written and built or compiled. Runtime system 126 may include one or more libraries and/or services that are accessible to application containers 102 during execution. As further described in this disclosure, each application container 102 may correspond to a distinct application. Runtime system 126 may include thread-management services, screen drawing and user-interface rendering component, and inter- and intra-application messaging services to name only a few example services. Application containers 102 may access the services through Application Programming Interfaces (APIs) that are exposed by runtime components 128. In some examples, runtime system 126 may be executed as one or more processes and/or threads. One or more of the processes and/or threads may execute with or without operating system privileges.
As shown in FIG. 1, runtime system 126 may include runtime components 128. Each distinct runtime component may be implemented with one or more processes and/or threads. In some examples, each distinct runtime component may provide a user-defined set of functionality. For instance, a user-interface rendering component may be implemented with one or more libraries that define user-interface elements (e.g., buttons, lists, images, input fields, and the like) and their corresponding behaviors. The user-interface rendering component may provide APIs, which are called by application containers 102 to render the user-interface elements in a graphical user interface.
Supervisor component 128A is included in runtime components 128. Supervisor component 128A provides inter- and intra-application messaging services. Supervisor component 128A includes a message broker 130 that listens for messages generated by application containers 102 and performs actions for the sending application container or one or more other application containers. Supervisor component 128A may have first priority or the first opportunity at dispatching any message (e.g., a message containing a URI as a user-specified identifier). In some examples, message broker 130 may provide additional processing for messages, such as allocating application containers from application container pool 132, enforcing security for messages, and logging messages, to name only a few examples. As an example, application container 102A may generate a message to navigate from a first user interface to a second user interface within the same application. Application container 102A may send the message to message broker 130, which includes a messaging table 134 comprising a set of filters, where each filter has one or more conditions and one or more corresponding actions. If the content of the message matches a condition of a filter, message broker 130 may execute the corresponding action, such as executing instructions to output the second graphical user interface. In some examples, such messages described above may be routed internally by router 112 without forwarding the messages to message broker 130.
As described above, each of application containers 102 may correspond to a distinct application. Applications may include distinct functionality to perform operations on computing device 100. For instance, applications may include an email application, text messing application, instant messaging application, weather application, video conferencing application, social networking application, weather application, stock market application, emergency alert application, sports application, office productivity application, multimedia player, to name only a few examples.
As shown in FIG. 1, application container 102A provides an execution environment and supporting services to direct the execution of executable components 108 of an application. Application containers 102 may execute as separate processes in operating system 136. In some examples, application container 102A includes a messaging interface 115. Router 112 may receive messages from runtime system 126 via messaging interface 115, and runtime system 126 may receive messages from executable components 108 and router 112 via messaging interface 115. Program logic for application container 102A may be implemented in executable components 108. An executable component may be a logical grouping of machine-executable code. For instance, in object-oriented design, a single executable component may be a single, compiled class file that includes machine-executable code.
Application container 102A may be a vessel for one or more sub-packages 104. In some examples, a sub-package includes two or more executable components 108A-108C (“executable components 108”). A sub-package may include resources (e.g., images, text, videos or any other non-compiled data), security and/or signing information, version information and/or dependency information, or any other information for an application. A software developer may design an application to be comprised of multiple, user-defined sub-packages. Each user-defined sub-package may include set of executable components that collectively provide a discrete set of functionality. For instance, a software developer may design a navigation application with multiple different user interfaces. Each user interface may include a different set of user interface elements and corresponding behaviors. As such each user interface may be implemented with a distinct set of executable components. For instance, the navigation application may include a turn-by-turn navigation user interface, a point-of-interest user interface (e.g., displaying details for a point of interest on a map), and a settings user interface. The software developer may design the application with three different sub-packages, where each sub-package includes a set of executable components to implement the functionality for the respective user interface.
Application container 102A may include container runtime 124. Container runtime 124 may include one or more libraries and/or one or more Application Programming Interfaces (APIs) to services and/or functions that are provided by libraries within container runtime 124, runtime system 126, and/or operating system 136. As such, container runtime 124 may provide a secure in-process API layer. By controlling the application container and container runtime, runtime system 126 can verify that application container and container runtime have not been tampered with and therefore provide runtime logic for sensitive behavior. For instance, an application that requests access a user's device identifier (e.g., a globally unique identifier of the device) could be required to call through APIs of the container runtime, which could then check with supervisor component 128A to ensure this is allowed behavior. In this way, container runtime 124 may enforce a guarantee that such checks occur various operations because such operations could only be made through APIs of container runtime 124. Container runtime 124 may provide a layer to iterate on APIs that require platform coordination. For instance, sub-package could declare that it requires some particular data, such as location, and container runtime 124 could obtain the location in parallel with loading executable components for a particular sub-package and provide the location as an argument on startup of an application.
As further described below, by allowing the software developer to design an application with separate sub-packages for separate sets of functionality, application containers 102 may enable an application to execute at computing device 100 without all of its respective execution components for all of its sub-packages being locally resident on computing device 100. In this way, the initial execution of an application may not require the retrieval and/or installation of all sub-packages but rather only a subset of sub-packages that include executable components implementing the requested functionality. Moreover, by packaging multiple, executable components in a single sub-package, the retrieval and/or installation of executable components may occur on a sub-package basis according to requested functionality (e.g., to render a particular user interface) rather retrieving and installing executable components on an executable component-by-executable component basis, which may have poorer performance and/or result in a poorer user experience.
As described above, each application may be executed with an application container that includes one or more executable components that define the operations of the application. Application container 102A includes a router 112 that sends and receives messages, which change the behavior of the application and/or cause the application to perform one or more operations, with executable components 108 and messaging interface 115. For instance, router 112 may receive a message that requests the execution of one or more operations. Router 112 may determine, based on the contents of the message, whether a sub-package that includes executable components to perform the one or more operations are stored locally or are otherwise accessible on computing device 100. The contents of the message may include an identifier such as a Uniform Resource Identifier (URI) that corresponds to the sub-package. If the sub-package is stored locally or is otherwise accessible on computing device 100, then router 112 identifies one or more executable components to perform the operations based on contents of the message. In some examples, the message may include additional attributes (e.g., category for launching user interface, MIME type of data, explicit component class for execution) or data (e.g., user data or machine generated data) that further specify the one or more operations to perform. As such, the one or more executable components identified by router 112 may perform the one or more operations based on the additional attributes or data.
As described above, all of the sub-packages for a particular application need not be locally resident at computing device 100 to execute the application. To determine whether a sub-package for specific functionality is resident or otherwise accessible at computing device 100, router 112 may perform a lookup on application definition 116. Application definition 116, generally, may define mappings between user-specified identifiers (e.g., URIs, strings, integers, or any other suitable identifier) and sub-packages that specify specific functionality for the application. Application definition 116 includes these mappings in routing table 118, which includes mappings between user-specified identifiers 120A-120N (“user-specified identifiers 120”) and sub-package identifiers 122A-122N (“sub-package identifiers 122”). If router 112 receives a message with a user-specified identifier to perform functionality using a particular sub-package, router 112 may perform a lookup in router table 118. If router 112 determines that user-specified identifier 120A, for example, matches the user-specified identifier in the message, router 112 may determine whether sub-package 104A that corresponds to sub-package identifier 122A is resident on computing device 100. Since sub-package 104A is resident on computing device 100, router 112 executes a call to sub-package 104A based on the message or sends the message to sub-package 104A, which performs one or more operations using executable components 108A.
As described above, because the entire set of sub-packages for an application need not be stored locally on computing device 100, the initial installation and/or initial execution of an application at computing device 100 may require less time than if the entire application needed to be downloaded from a remote computing system, installed, and executed by computing device 100. As such, a user may experience greater responsiveness from the application and/or performance for the behavior of the application.
In the example of FIG. 1, a user may desire to initially install and execute the navigation application as described above. Initially, none of the sub-packages or the application definition for navigation application may be stored at computing device 100. The user may provide a user input to computing device 100 to initially select an icon in a user interface provided by operating system 136 that corresponds to the map application. Alternatively, the user may select the map application in a media store application (not shown) that executes at computing device 100 and communicates with remote computing systems 142 to retrieve sub-packages and application definitions. In any case, message broker 130 of supervisor component 128A receives a message from operating system 136 or the media store application that requests execution of particular functionality for the navigation application. Because the navigation application is not yet installed, the particular functionality requested is to display the default or main user interface for the application.
Supervisor component 128A may determine whether an application container has already been allocated in the memory of computing device 100 for the navigation application based on the content of the message. For instance, the content of the message may include a unique identifier of the navigation application, such as name for the application. In response to determining that supervisor component 128A has not yet allocated an application container for the navigation application, supervisor component 128A may allocate an application container 102A from application container pool 132. Application container pool 132 may include a set of processes that are reserved for and usable to execute applications. In some examples, supervisor component 128A may communicate with operating system 136 to create a new process for application container 102A.
Supervisor component 128A may determine that the navigation application is not yet installed and request an application definition from one or more of remote computing systems 142. For instance, supervisor component 128A may send a message to remote computing system 142A, where the message includes an identifier for the navigation application that is globally unique in remote computing systems 142. Remote computing system 142A, upon receiving the message, selects application definition 116 from application definitions 144, and sends application definition 116 to computing device 100. Supervisor component 128A receives application definition 116, which may be included in or accessible to application container 102A.
Supervisor component 128A causes message broker 130 to send a message to application container 102A to display the default or main user interface for the application. In particular, the message may include a user-specified identifier that corresponds to a sub-package with functionality to display the default or main user interface for the application. In some examples, message broker 130 receives (or generates) the user-specified identifier based on information received from the media store application, or from bootstrapping functionality associated with the icon for the mapping application that was initially selected by the user. The bootstrapping functionality may include, but is not limited to, sending the user-specified identifier to message broker 130.
Router 112 receives the message with the user-specified identifier via messaging interface 115. In this example of FIG. 1, the user-specified identifier is 120A. Based on the user-specified identifier, router 112 determines that the sub-package for sub-package identifier 122A corresponding to user-specified identifier 120A is not stored locally at computing device 100. Router 112 may send a message, using container runtime 124 and/or runtime system 126, to remote computing system 142A to request the sub-package for sub-package identifier 122A. For instance, the message sent by container runtime 124 and/or runtime system 126 to remote computing system 142A may include sub-package identifier 122A. Remote computing system 142A may send a sub-package to computing device 100 comprising executable components for displaying the default or main user interface of the navigation application.
Router 112, in response to determining that the sub-package for sub-package identifier 122A is not stored locally, may cause lifecycle manager 110 to listen for system lifecycles calls via callback interface 113, where the lifecycle calls are issued by runtime system 126. Lifecycle calls may include starting an application, pausing an application, restarting an application, or terminating an application, to name only a few examples. Lifecycle manager 110 may buffer the lifecycle calls, which will be executed by the executable components of sub-package 104A, once computing device 100 has retrieved sub-package 104A from remote computing system 142A. Once sub-package 104A has been retrieved by computing device 100, lifecycle manager 110 may send each of the buffered lifecycle calls to sub-package 104A.
In the example of FIG. 1, upon lifecycle manager 110 determining that computing device 100 has retrieved and stored sub-package 104A locally, lifecycle manager 110 sends a call or otherwise invokes loader 106 to load one or more of executable components 108 into memory of computing device 100 in order to execute the particular functionality initially requested, e.g., display the default or main user interface for the application. In some examples, loader 106 is responsible for loading executable components into memory. In some examples, loader 106 may represent multiple loaders, where each loader is responsible for loading a different executable component into memory. Loader 106 may, for a particular executable component, locate corresponding libraries used by the particular executable component and load any such libraries into memory, such that the libraries are accessible to the particular executable component. Lifecycle manager 110 may also send the buffered lifecycle calls to one or more of executable components 108. Upon receiving the buffered lifecycle calls, the one or more of executable components 108 cause computing device 100 to display the default or main user interface for the application.
At a later time, if the user wishes to navigate to a settings user interface, the user may provide a user input that selects a user interface element (e.g., icon, button, label, or the like) for the settings in the currently displayed default or main user interface for the application. Runtime system 126 sends a message to application container 102A that indicates the selection of the user interface element. Executable component 108A determines that the selection displays the settings user interface. Executable component 108A generates a message with a user-specified identifier 120N for sub-package 122N that includes the functionality for the settings user interface. Executable component 108A may send the message to router 112 directly, or to runtime system 126, which in turn routes the message back to router 112. In either case, router 112 performs a lookup of user-specified identifier 120N and determines that the sub-package for sub-package identifier 122N is not locally stored at computing device 100.
In a similar to manner, as described above with respect to sub-package 104A, router 112 sends a message, using container runtime 124 and/or runtime system 126, to remote computing system 142A to retrieve the sub-package for sub-package identifier 122N. Remote computing system 142A may send sub-package 122N to computing device 100 comprising executable components for displaying the settings interface of the navigation application. While computing device 100 is retrieving sub-package 122N, lifecycle manager 110 may buffer lifecycle calls received at callback interface 113. Upon downloading sub-package 122N, lifecycle manager 110 causes loader 106 to load executable components of sub-package 122N into memory. Loader 106 may initiate execution of one or more of the executable components to cause the settings interface of the navigation application to be displayed at a display device of computing device 100.
FIG. 2 is a block diagram illustrating further details of computing device 100, in accordance with one or more aspects of the present disclosure. FIG. 2 illustrates only one particular example of computing device 100. Many other examples of computing device 100 may be used in other instances and may include a subset of the components included in example computing device 100 or may include additional components not shown example computing device 100 in FIG. 2.
As shown in the example of FIG. 2, computing device 100 includes one or more processors 240, one or more input components 242, one or more communication units 244, one or more output components 246, one or more storage devices 248, and presence-sensitive display 212. Storage devices 248 of computing device 100 include Application containers 102, system runtime 126, and operating system 136. Communication channels 250 may interconnect each of the components 240, 244, 246, 242, 258, 204, 213, 215, 248, 102, 126, and/or 136 for inter-component communications (physically, communicatively, and/or operatively). In some examples, communication channels 250 may include a system bus, a network connection, one or more inter-process communication data structures, or any other components for communicating data between hardware and/or software.
One or more processors 240 may implement functionality and/or execute instructions within computing device 100. For example, processors 240 on computing device 100 may receive and execute instructions stored by storage devices 248 that provide the functionality of operating system 136, application containers 102, and system runtime 126. These instructions executed by processors 240 may cause computing device 100 to store and/or modify information, within storage devices 248 during program execution. Processors 240 may execute instructions of operating system 136, application containers 102, and system runtime 126 to perform one or more operations. That is, rating system 136, application containers 102, and system runtime 126 may be operable by processors 240 to perform various functions described in this disclosure.
One or more input components 242 of computing device 100 may receive input. Examples of input are tactile, audio, kinetic, and optical input, to name only a few examples. Input components 242 of computing device 100, in one example, include a mouse, keyboard, voice responsive system, video camera, buttons, control pad, microphone or any other type of device for detecting input from a human or machine. In some examples, input component 242 may be a presence-sensitive input component, which may include a presence-sensitive screen, touch-sensitive screen, etc.
One or more output components 246 of computing device 100 may generate output. Examples of output are tactile, audio, and video output. Output components 246 of computing device 100, in some examples, include a presence-sensitive screen, sound card, video graphics adapter card, speaker, cathode ray tube (CRT) monitor, liquid crystal display (LCD), or any other type of device for generating output to a human or machine. Output components may include display components such as cathode ray tube (CRT) monitor, liquid crystal display (LCD), Light-Emitting Diode (LED) or any other type of device for generating tactile, audio, and/or visual output.
In some examples, presence-sensitive display 204 of computing device 100 may include functionality of input component 242 and/or output components 246. In the example of FIG. 2, presence-sensitive display 204 may include a presence-sensitive input component 215, such as a presence-sensitive screen or touch-sensitive screen. In some examples, presence-sensitive input component 215 may detect an object at and/or near the presence-sensitive input component. As one example range, presence-sensitive input component 215 may detect an object, such as a finger or stylus that is within two inches or less of presence-sensitive input component 215. Presence-sensitive input component 215 may determine a location (e.g., an (x,y) coordinate) of the presence-sensitive input component at which the object was detected. In another example range, presence-sensitive input component 215 may detect an object two inches or less from presence-sensitive input component 215 and other ranges are also possible. Presence-sensitive input component 215 may determine the location of presence-sensitive input component 215 selected by a user's finger using capacitive, inductive, and/or optical recognition techniques.
In some examples, presence-sensitive display 204 may also provide output to a user using tactile, audio, or video stimuli as described with respect to output component 246. For instance, presence-sensitive display 204 may include display component 213 that presents a graphical user interface. Display component 213 may be any type of output component that provides visual output, such as described with respect to output components 246. While illustrated as an integrated component of computing device 100, presence-sensitive display 204 may, in some examples, be an external component that shares a data path with other components of computing device 100 for transmitting and/or receiving input and output. For instance, presence-sensitive display 204 may be a built-in component of computing device 100 located within and physically connected to the external packaging of computing device 100 (e.g., a screen on a mobile phone). In another example, presence-sensitive display 204 may be an external component of computing device 100 located outside and physically separated from the packaging of computing device 100 (e.g., a monitor, a projector, etc. that shares a wired and/or wireless data path with a tablet computer). In some examples, presence-sensitive display 204, when located outside of and physically separated from the packaging of computing device 100, may be implemented by two separate components: a presence-sensitive input component 215 for receiving input and a display component 213 for providing output.
One or more communication units 244 of computing device 100 may communicate with external devices by transmitting and/or receiving data. For example, computing device 100 may use communication units 244 to transmit and/or receive radio signals on a radio network such as a cellular radio network. In some examples, communication units 244 may transmit and/or receive satellite signals on a satellite network such as a Global Positioning System (GPS) network. Examples of communication units 244 include a network interface card (e.g. such as an Ethernet card), an optical transceiver, a radio frequency transceiver, a GPS receiver, or any other type of device that can send and/or receive information. Other examples of communication units 244 may include Bluetooth®, GPS, 3G, 4G, and Wi-Fi® radios found in mobile devices as well as Universal Serial Bus (USB) controllers and the like.
One or more storage devices 248 within computing device 100 may store information for processing during operation of computing device 100. In some examples, storage device 248 is a temporary memory, meaning that a primary purpose of storage device 248 is not long-term storage. Storage devices 248 on computing device 100 may configured for short-term storage of information as volatile memory and therefore not retain stored contents if deactivated. Examples of volatile memories include random access memories (RAM), dynamic random access memories (DRAM), static random access memories (SRAM), and other forms of volatile memories known in the art.
Storage devices 248, in some examples, also include one or more computer-readable storage media. Storage devices 248 may be configured to store larger amounts of information than volatile memory. Storage devices 248 may further be configured for long-term storage of information as non-volatile memory space and retain information after activate/off cycles. Examples of non-volatile memories include magnetic hard discs, optical discs, floppy discs, flash memories, or forms of electrically programmable memories (EPROM) or electrically erasable and programmable (EEPROM) memories. Storage devices 248 may store program instructions and/or data associated with operating system 136, system runtime 126, and application containers 102.
As shown in FIG. 2, computing device 100 may include a power source 258. In some examples, power source 258 may be a battery. Power source 258 may provide power to one or more components of computing device 100. Examples of power source 258 may include, but are not necessarily limited to, batteries having zinc-carbon, lead-acid, nickel cadmium (NiCd), nickel metal hydride (NiMH), lithium ion (Li-ion), and/or lithium ion polymer (Li-ion polymer) chemistries. In some examples, power source 258 may have a limited capacity (e.g., 1000-3000 mAh).
In accordance with techniques of the disclosure, system runtime 126 receives a request to execute particular functionality of an application. For instance, a user may provide a user input at presence-sensitive display 204. Presence-sensitive display 204 may cause system runtime 126 to generate an event that corresponds to selecting an icon for the application. Responsive to determining that an application container for maintaining installable sub-packages of the application is not allocated in volatile memory of storage components 248, system runtime 126 retrieves an application definition from a remote computing system. For instance, system runtime 126 causes one of communication units 244 to send a request to the remote computing system for the application definition. The application definition may define a plurality of mappings between the installable sub-packages of the application and user-specified identifiers.
Responsive to allocating application container 102A in the volatile memory of computing device 100, system runtime 126 may initiate, based at least in part on a user-specified identifier of the request, the particular functionality of the application. Responsive to determining, by application container 102A executing at the computing device, based at least in part on the application definition and the user-specified identifier, that an installable sub-package for the particular functionality is not stored at computing device 100, application container 102A may retrieve the installable sub-package that includes a plurality of executable components from a remote computing system. The remote computing system may be the same computing device that includes the application definition or a different computing device. In some examples, if the computing devices are different, they may be operated by a common operator. In some examples, an operator is an administrator or any other entity that owns and/or operates one or more computing systems.
Rather than downloading each executable component and a component-by-component basis and rather than downloading all of the executable components of the application, computing device 100 may retrieve only the one or more sub-packages that correspond to discrete sets of functionality needed by the application. Moreover, rather than having loader 106 (shown in FIG. 1) identify, at run-time and during execution, each separate executable component that is not stored locally, and retrieving and installing such executable components separately on a component-by-component basis, application container 102A may download a sub-package for particular functionality based on the software developer's identification of the sub-package with a user-specified identifier. As such, retrieving sub-packages may be a less granular but more efficient retrieval mechanism than retrieving and installing such executable components separately on a component-by-component basis. Application container 102A may execute using one or more executable components of the retrieved sub-package, the particular functionality of the application.
In some examples, each respective application container may correspond to a distinct application. For instance, an operating system may include a user interface that allows a user to select different applications (e.g., from a menu or icon grid) based on respective icons that correspond to the different applications. For example, a user may select an email client icon from the operating system user interface that causes execution of the email client application with its own separate application container. Unlike an application container, an extension or other sub-application (e.g., plugins, JavaScript, Java Virtual Machine, etc.,) of a web-browser may not be represented as a separate applications to be launched in a user interface of an operating system. For instance, even if a web browser created a separate process for each tab of a tabbed interface, each of the tabs may not be represented as a separate application within a user interface of the operating system as different launchable applications.
An application container, as described in this disclosure, may differ from a web browser because an application container may include a container runtime. As described in this disclosure, a container runtime of an application container may include libraries, but may also expose operating system APIs to executable components of sub-packages within an application container. Unlike an application container, a web browser may not expose such operating system APIs to extensions or other sub-applications within the web-browser.
An application container, as described in this disclosure, may differ from a web browser because the application container may receive user-specified identifiers (e.g., URI's) from a supervisor component (e.g., in a runtime system or operating system) that is external to the application container that may cause the retrieval of sub-packages that change the execution behavior or appearance of the application without additional user intervention. The user-specified identifiers may originate from other applications executing on the same computing device or different computing devices, and upon being received by an application container may automatically change the execution behavior or appearance of the application. By contrast, a web browser may receive user input (e.g., inputting text for a URL) within the web-browser itself and not from a source external to the application container, e.g., either a supervisor component or another application external to the web-browser. Additionally, a web browser may not include a router and/or application definition, as described within an application container of this disclosure, to perform a lookup of user-specified identifiers and change the execution of the application represented by the application container. Unlike an application container, a web browser may not include a callback interface, which receives and buffers lifecycle calls to change the operation of sub-packages within the application container.
In some examples, a web browser may include core functionality (e.g., rendering engine) and one or more third-party extensions, plugins, and/or sub-application. A web browser, unlike an application container, may not function properly or execute at all without all of the web browser's core functionality being stored locally and available to the computing device for execution. By contrast, an application container may function properly with only a sub-set of its core functionality (e.g., only sub-packages for a subset of user interfaces) stored locally and available to the computing device for execution.
FIG. 3 is a sequence diagram illustrating example operations of a computing device with application containers for dynamically loading installable sub-packages, in accordance with techniques of this disclosure. For purposes of illustration only, the example operations are described below within the context of computing device 100 and remote computing system 142 of FIG. 1.
As shown in FIG. 3, computing device 100 may initially detect or receive a request 300 to initiate particular functionality of computing device 100. For instance, the user may provide a user input to computing device 100 to initially select an icon that corresponds to the application, which for purposes of FIG. 3 is a navigation application. Alternatively, the user may select the navigation application in a media store application that executes at computing device 100 and communicates with remote computing systems 142 to retrieve sub-packages and application definitions. Supervisor 302 may receive the request. In FIG. 3, the request may include a user-specified identifier http: //wh.com/s/123. The user specified identifier may be a Uniform Resource Locator (URL). The URL includes a sub-identifier wh.com that is a globally unique identifier in remote computing systems 142 for the navigation application as described in this disclosure.
Supervisor 302 may determine whether one or more sub-packages for the navigation application are stored at computing device 100 (308). If no sub-packages for the navigation application are stored at computing device 100, computing device 100 submits a request to resolve the user-specified identifier http: //wh.com/s/123 to a particular application definition (310). One or more of remote computing systems 142 perform a lookup on all or a part of the user-specified identifier http: //wh.com/s/123 to identify an application definition. Upon identifying the application definition, the one or more of remote computing systems 142 send the application definition app_def {package: com.wh.app, . . . } to computing device 100 (312).
Supervisor 102, upon receiving application definition app_def {package: com.wh.app, . . . } may associate the software developer-assigned package identifier for the application (com.wh.app) with the sub-identifier wh.com is a globally unique identifier for the navigation application in remote computing systems 142 (316). Supervisor 302 sends a message to application container 102A to execute the particular functionality specified in the initial request 300 (318). In some examples, the message may specify the application definition, the user-specified identifier, and/or one or more commands. As an example, the message sent in FIG. 3, START {app_def, http: //wh.com/s/123}, includes the command START, the application definition app_def, and the user-specified identifier http: //wh.com/s/123.
Application container 102A receives the message and initiates the particular functionality specified by the message. Application container 102A performs a lookup to determine whether one or more sub-packages for performing the functionality specified by the suffix /s/123 are locally stored at computing device 100. In the example of FIG. 3, the /s portion of the suffix specifies settings functionality for which a sub-package implements the appearance and behavior of the settings functionality. The /123 suffix specifies an attribute that may be processed for defining the appearance and/or behavior of the user interface. For instance, the /123 suffix may specify a particular user interface provided in the settings functionality.
Upon determining that a sub-package for the settings functionality is not stored locally at computing device 100, application container 102A sends a message to one or more of remote computing systems 142 to retrieve the sub-package for the settings functionality (322). The message may comprise information including, but not limited to, the software developer-assigned package identifier for the application (com.wh.app) and the sub-package identifier (settings_function) for the sub-package that provides the settings functionality. The one or more remote computing systems that receive the message perform a lookup based on the software developer-assigned package identifier for the application (com.wh.app), and further based on the sub-package identifier (settings_function) for the sub-package, selects the sub-package for the settings functionality and sends the sub-package to application container (324). Application container 102A receives the settings_function sub-package (324). Computing device 100 may execute one or more executable components of the settings_function sub-package to perform the particular functionality specified in the request.
FIG. 4 is a conceptual diagram of an application containers for dynamically loading installable sub-packages and corresponding libraries, in accordance with techniques of this disclosure. FIG. 4 illustrates application container 102A of FIG. 1 with container runtime 124. Application container 102A communicates with supervisor component 128A. FIG. 4 illustrates relationship between application container 102A, sub-packages 104C and 104A, and libraries 400A-400C (“libraries 400”). Sub-package 104C includes functionality to implement turn-by-turn and points-of-interest user interfaces, as described in FIG. 1. Sub-package 104A includes functionality to implement the settings user interface, as described in FIG. 1.
If a user provides a user input to cause computing device 100 to display the settings user interface, application container 102A may determine whether sub-package 104A is stored locally on computing device 100. For instance, application container 102A may receive a URI with the /settings suffix and determine whether the corresponding sub-package is locally installed. If not, application container 102A may communicate with supervisor 128A to retrieve sub-package 104A from a remote computing system. In some examples, application container 102A may determine that sub-package 104A uses one or more libraries, such as library 400C to perform one or more operations. Application container 102A, and in some examples, loader 106 of application container 102A, may cause library 400C to be loaded into memory. For instance, application container 102A may send a message to supervisor 128 A specifying library 400C, which causes library 400C to be loaded into memory. In another example, application container 104A may directly invoke library 400C, or may invoke library 400C through container runtime 124. In still other examples, upon loading sub-package 104A into memory, one or more executable components of sub-package 104A may invoke library 400C.
If library 400C and/or sub-package 104A has a transitive dependency on library 400B, then application container 102A, sub-package 104A, and/or supervisor 128A may also load library 400B. In this way, all libraries necessary for executing sub-package 104A are loaded into memory or are otherwise made accessible to application container 102A and/or sub-package 104A. In some examples, container runtime 124A includes libraries 400, while in other examples, libraries 400 are included in runtime system 126, as shown in FIG. 1.
In examples where libraries 400 are included in container runtime 124A, application container 102A may automatically update container runtime 124 by retrieving updated libraries locally and/or from a remote computing system. For instance, application container 102A may retrieve an application definition which specifies a minimum version of a library. Application container 102A may, based on the specified version, automatically retrieve a library that has at least the minimum version. In some examples, application container 102A may check periodically or asynchronously (e.g., when the application is initially loaded into memory) whether updated libraries are available and automatically retrieve such libraries from one or more remote computing systems. In this way, software developers may not have to check whether a library is up to date because the application container may guarantee that the libraries dependencies are satisfied by container runtime 124 before any executable components run. Moreover, container runtime 124 may be updated without the need to update operating system 136 and/or without the need update runtime system 126.
FIG. 5 is a flow diagram illustrating example operations of a computing device with application containers for dynamically loading installable sub-packages, in accordance with techniques of this disclosure. For purposes of illustration only, the example operations are described below within the context of computing device 100 of FIG. 1.
In FIG. 5, computing device 100 may initially receive a request to execute particular functionality of an application (500). For instance, a user may provide a user input at computing device 100 to launch the application. Computing device 100 may determine that an application container for maintaining installable sub-packages of the application is not allocated in memory of computing device 100. Responsive to determining that an application container for maintaining installable sub-packages of the application is not allocated in memory, computing device 100 may retrieve an application definition from a remote computing system (502). For instance, computing device 100 may send a request to the remote computing system that includes a unique identifier for the application. The remote computing system may perform a lookup and identify a corresponding application definition. The remote computing system may send the application definition to computing device 100.
Computing device 100 may receive the application definition from computing device 100. Computing device 100 may further allocate an application in memory of computing device 100 for the application. Responsive to allocating the application container in the memory, computing device 100 may initiate, based at least in part on a user-specified identifier of the request, the particular functionality of the application (504). For instance, the supervisor component may send a message to the application container that includes a user-specific identifier (e.g., URI, tag, label, etc.) that corresponds to one or more sub-packages that include executable components to execute the particular functionality of the application.
Computing device 100 may determine, based at least in part on the application definition and the user-specified identifier, that an installable sub-package for the particular functionality is not stored at computing device 100. Responsive to determining, based at least in part on the application definition and the user-specified identifier, that an installable sub-package for the particular functionality is not stored at computing device 100, computing device 100 may retrieve the installable sub-package that includes a plurality of executable components from the remote computing system (506). In some examples, computing device 100 may retrieve the installable sub-package that includes a plurality of executable components from a remote computing system that is different than the remote computing system that includes the application definition. In some examples, computing device 100 may retrieve the installable sub-package(s) that includes a plurality of executable components from a remote computing system that is the same as the remote computing system that includes the application definition. Computing device 100 executes, using one or more executable components of the one or more sub-packages, the particular functionality of the application (508). For instance, computing device 100, upon executing the executable components may change the behavior and/or appearance of the application.
Example 1: A method comprising: receiving, by a supervisor component executing at a computing device, a request to execute particular functionality of an application; responsive to determining that an application container for maintaining installable sub-packages of the application is not allocated in memory of the computing device, retrieving, by the supervisor component, an application definition from a first remote computing system, wherein the application definition defines a plurality of mappings between the installable sub-packages of the application and user-specified identifiers; responsive to allocating the application container in the memory of the computing device, initiating, by the supervisor component and based at least in part on a user-specified identifier of the request, the particular functionality of the application; responsive to determining, by the application container executing at the computing device, based at least in part on the application definition and the user-specified identifier, that an installable sub-package for the particular functionality is not stored at the computing device, retrieving, by the application container, the installable sub-package that includes a plurality of executable components from a second remote computing system; and executing, by the application container and using the plurality of executable components, the particular functionality of the application.
Example 2: The method of Example 1, wherein the particular functionality is first particular functionality, wherein the request to execute particular functionality is a first request to execute first particular functionality, the method further comprising: receiving a second request to execute second particular functionality of the application; responsive to determining that the application container for the application is allocated in memory and that an installable sub-package for the second particular functionality is not stored at the computing device, retrieving, by the application container, the installable sub-package for the second particular functionality from the second remote computing system without retrieving a third sub-package of the application from the second remote computing system, wherein the third sub-package is not installed on the computing device; and executing, by the application container and using a plurality of executable components included in the installable sub-package for the second particular functionality, the particular functionality of the application.
Example 3: The method of any of Examples 1-2, further comprising: buffering, by a lifecycle component of the application container, a plurality of lifecycle calls received from a runtime system of the computing device; and responsive to determining that at least one of the plurality of executable components is loaded in the memory of the computing device, sending the one or more of the plurality of lifecycle calls to the at least one of the plurality of executable components.
Example 4: The method of any of Examples 1-3, further comprising: receiving, by a router of the application container, the user-specified identifier; querying, by the router of the application container, a router table comprising the plurality of mappings between the installable sub-packages of the application and user-specified identifiers to determine whether the installable sub-package for the particular functionality is stored at the computing device; and responsive to determining that the installable sub-package for the particular functionality is not stored locally at the computing device, sending a message that includes an identifier of the installable sub-package to the second remote computing system.
Example 5: The method of any of Examples 1-4, further comprising: identifying, by the application container, a minimum version of a library specified in the application definition; prior to executing the application using the runtime container: retrieving an instance of the library with a version that is greater than or equal to the minimum version; installing the instance of the library in a container runtime of the application container; and wherein executing the particular functionality of the application comprises executing the particular functionality using the instance of the library in the container runtime.
Example 6: The method of any of Examples 1-5, wherein each of the plurality of executable components is a compiled class in an object-oriented design, wherein the application container is implemented as process in an operation system executing at the computing device, and wherein the sub-package for the particular functionality includes fewer than all executable components that implement the application.
Example 7: The method of any of Examples 1-6, wherein the first and second remote computing systems are a same computing device.
Example 8: The method of any of Examples 1-7, wherein the first and second remote computing systems are included in a system that is operated by a common operator.
Example 9: A computing device comprising: one or more computer processors; and a memory comprising instructions that when executed by the one or more computer processors cause the one or more computer processors to: receive, by a supervisor component of the computing device, a request to execute particular functionality of an application; responsive to determining that an application container for maintaining installable sub-packages of the application is not allocated in memory of the computing device, retrieve, by the supervisor component, an application definition from a first remote computing system, wherein the application definition defines a plurality of mappings between the installable sub-packages of the application and user-specified identifiers; responsive to allocating the application container in the memory of the computing device, initiate, by the supervisor component and based at least in part on a user-specified identifier of the request, the particular functionality of the application; responsive to determining, by the application container of the computing device, based at least in part on the application definition and the user-specified identifier, that an installable sub-package for the particular functionality is not stored at the computing device, retrieving, by the application container, the installable sub-package that includes a plurality of executable components from a second remote computing system; and execute, by the application container and using the plurality of executable components, the particular functionality of the application.
Example 10: The computing device of Example 9, wherein the instructions when executed by the one or more computer processors cause the one or more computer processors to perform any of the method of Examples 2-8.
Example 11: A non-transitory computer-readable storage medium encoded with instructions that, when executed, cause at least one processor of a computing device to: receive, by a supervisor component of the computing device, a request to execute particular functionality of an application; responsive to determining that an application container for maintaining installable sub-packages of the application is not allocated in memory of the computing device, retrieve, by the supervisor component, an application definition from a first remote computing system, wherein the application definition defines a plurality of mappings between the installable sub-packages of the application and user-specified identifiers; responsive to allocating the application container in the memory of the computing device, initiate, by the supervisor component and based at least in part on a user-specified identifier of the request, the particular functionality of the application; responsive to determining, by the application container of the computing device, based at least in part on the application definition and the user-specified identifier, that an installable sub-package for the particular functionality is not stored at the computing device, retrieving, by the application container, the installable sub-package that includes a plurality of executable components from a second remote computing system; and execute, by the application container and using the plurality of executable components, the particular functionality of the application.
Example 12: The non-transitory computer-readable storage medium of Example 11 encoded with instructions that, when executed, cause at least one processor of a computing device to perform any of the method of examples 2-8.
Example 13: An apparatus comprising means for performing any of the method of examples 2-8.
In one or more examples, the functions described may be implemented in hardware, software, firmware, or any combination thereof. If implemented in software, the functions may be stored on or transmitted over, as one or more instructions or code, a computer-readable medium and executed by a hardware-based processing unit. Computer-readable media may include computer-readable storage media, which corresponds to a tangible medium such as data storage media, or communication media including any medium that facilitates transfer of a computer program from one place to another, e.g., according to a communication protocol. In this manner, computer-readable media generally may correspond to (1) tangible computer-readable storage media, which is non-transitory or (2) a communication medium such as a signal or carrier wave. Data storage media may be any available media that can be accessed by one or more computers or one or more processors to retrieve instructions, code and/or data structures for implementation of the techniques described in this disclosure. A computer program product may include a computer-readable medium.
By way of example, and not limitation, such computer-readable storage media can comprise RAM, ROM, EEPROM, CD-ROM or other optical disk storage, magnetic disk storage, or other magnetic storage devices, flash memory, or any other medium that can be used to store desired program code in the form of instructions or data structures and that can be accessed by a computer. Also, any connection is properly termed a computer-readable medium. For example, if instructions are transmitted from a website, server, or other remote source using a coaxial cable, fiber optic cable, twisted pair, digital subscriber line (DSL), or wireless technologies such as infrared, radio, and microwave, then the coaxial cable, fiber optic cable, twisted pair, DSL, or wireless technologies such as infrared, radio, and microwave are included in the definition of medium. It should be understood, however, that computer-readable storage media and data storage media do not include connections, carrier waves, signals, or other transient media, but are instead directed to non-transient, tangible storage media. Disk and disc, as used herein, includes compact disc (CD), laser disc, optical disc, digital versatile disc (DVD), floppy disk and Blu-ray disc, where disks usually reproduce data magnetically, while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer-readable media.
Instructions may be executed by one or more processors, such as one or more digital signal processors (DSPs), general purpose microprocessors, application specific integrated circuits (ASICs), field programmable logic arrays (FPGAs), or other equivalent integrated or discrete logic circuitry. Accordingly, the term “processor,” as used herein may refer to any of the foregoing structure or any other structure suitable for implementation of the techniques described herein. In addition, in some aspects, the functionality described herein may be provided within dedicated hardware and/or software modules. Also, the techniques could be fully implemented in one or more circuits or logic elements.
The techniques of this disclosure may be implemented in a wide variety of devices or apparatuses, including a wireless handset, an integrated circuit (IC) or a set of ICs (e.g., a chip set). Various components, modules, or units are described in this disclosure to emphasize functional aspects of devices configured to perform the disclosed techniques, but do not necessarily require realization by different hardware units. Rather, as described above, various units may be combined in a hardware unit or provided by a collection of interoperative hardware units, including one or more processors as described above, in conjunction with suitable software and/or firmware.
Various aspects of the disclosure have been described. These and other aspects are within the scope of the following claims.