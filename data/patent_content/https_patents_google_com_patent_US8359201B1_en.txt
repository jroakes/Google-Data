US8359201B1 - Randomized language models - Google Patents
Randomized language models Download PDFInfo
- Publication number
- US8359201B1 US8359201B1 US13/488,914 US201213488914A US8359201B1 US 8359201 B1 US8359201 B1 US 8359201B1 US 201213488914 A US201213488914 A US 201213488914A US 8359201 B1 US8359201 B1 US 8359201B1
- Authority
- US
- United States
- Prior art keywords
- gram
- array
- grams
- computing system
- location
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Fee Related
Links
Images
Classifications
-
- G—PHYSICS
- G10—MUSICAL INSTRUMENTS; ACOUSTICS
- G10L—SPEECH ANALYSIS OR SYNTHESIS; SPEECH RECOGNITION; SPEECH OR VOICE PROCESSING; SPEECH OR AUDIO CODING OR DECODING
- G10L15/00—Speech recognition
- G10L15/28—Constructional details of speech recognition systems
- G10L15/30—Distributed recognition, e.g. in client-server systems, for mobile phones or network applications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F40/00—Handling natural language data
- G06F40/20—Natural language analysis
- G06F40/205—Parsing
- G06F40/216—Parsing using statistical methods
-
- G—PHYSICS
- G10—MUSICAL INSTRUMENTS; ACOUSTICS
- G10L—SPEECH ANALYSIS OR SYNTHESIS; SPEECH RECOGNITION; SPEECH OR VOICE PROCESSING; SPEECH OR AUDIO CODING OR DECODING
- G10L15/00—Speech recognition
- G10L15/08—Speech classification or search
- G10L15/18—Speech classification or search using natural language modelling
- G10L15/183—Speech classification or search using natural language modelling using context dependencies, e.g. language models
- G10L15/19—Grammatical context, e.g. disambiguation of the recognition hypotheses based on word sequence rules
- G10L15/197—Probabilistic grammars, e.g. word n-grams
Definitions
- This specification relates to language models stored for digital language processing.
- Language models are used to model a probability that a string of words in a given vocabulary will appear in a language.
- language models are used in automatic speech recognition, machine translation, and optical character recognition applications. Modeling the probability for a string of words in the vocabulary is typically performed using a chain rule and calculating the probability of a given word, w, in a given string context, p(w
- n-gram language model the words in the vocabulary are formed into n-grams.
- An n-gram is a sequence of n consecutive words.
- An n-gram has an order, which is the number of words in the n-gram. For example, a 1-gram (or unigram) includes one word; a 2-gram (or bi-gram) includes two words.
- a given n-gram can be described according to different portions of the n-gram.
- An n-gram can be described as a context and a future word, (context, w), where the context has a length n ⁇ 1 and w represents the future word.
- the 3-gram “the black sheep” can be described in terms of an n-gram context and a future word.
- the n-gram context includes all words of the n-gram preceding the last word of the n-gram. In the given example, “the black” is the context. The left most word in the context is referred to as the left word.
- the future word is the last word of the n-gram, which in the example is “sheep”.
- the n-gram can also be described with respect to a right context and a backed off context.
- the right context includes all words of the n-gram following the first word of the n-gram, represented as a (n ⁇ 1)-gram.
- black sheep is the right context.
- the backed off context is the context of the n-gram less the left most word in the context.
- black is the backed off context.
- the probability according to the n-gram language model that a particular string will occur can be determined using the chain rule.
- the chain rule determines a probability of a string as a product of individual probabilities.
- the probability for the string, p(e 1 , e 2 , . . . e k ) is equal to:
- the n-gram language model can be limited to a particular maximum size n-gram, e.g., limited to 1-grams, 2-grams, 3-grams, etc.
- n-gram e.g., limited to 1-grams, 2-grams, 3-grams, etc.
- n is the order of the largest n-gram allowed in the language model.
- Identifying locations in the array can further include building an array having a specified number of locations, identifying a plurality of locations corresponding to each n-gram in the collection, identifying a first n-gram-location pair corresponding to a first n-gram associated with a first location of degree one, where the first location is of degree one when no other n-gram of the collection of n-grams is associated with the first location, and removing the first n-gram-location pair such that the n-gram no longer corresponds to any other locations in the array such that one or more other locations in the array are of degree one.
- the aspect can further include reducing an error rate including performing a search for an n ⁇ 1-gram as a lesser included n-gram of the received n-gram and when one or more parameter values for the n ⁇ 1-gram is not identified, truncating the search for the received n-gram to a lesser included n-gram.
- a language model can be encoded such that the language model has a small memory footprint.
- the storage size of the language model does not depend on the order of the encoded n-grams or the vocabulary size.
- the language model is encoded to provide efficient access to n-gram parameter values. The actual n-grams themselves do not need to be stored explicitly within the language model. Lookup of particular n-gram values is very efficient.
- FIG. 1 is a block diagram illustrating components for building a language model.
- FIG. 2 is a flow chart of an example method for encoding a language model.
- FIG. 3 is an example diagram of using a composite hash function to identify a parameter value for an n-gram
- FIG. 4 is a flow chart of an example method 400 for encoding values in an array.
- FIG. 5 shows a sequence of diagrams illustrating the relationship between n-gram keys and array locations for an example collection of n-grams and array locations.
- FIG. 6 is a flow chart of an example method for retrieving a parameter value for an n-gram.
- FIG. 7 is an example diagram of a two byte encoding.
- FIG. 1 is a block diagram illustrating components for building a language model 100 .
- the language model 100 includes a vocabulary 102 and a collection of n-grams 104 .
- the vocabulary 102 is a collection of distinct words found in a corpus of text used to train the language model.
- the corpus can include a number of different sources of text, including, e.g., web pages and news articles. In some implementations, the corpus includes text on the order of tens to hundreds of billions of words, or even more.
- One such corpus is the Linguistic Data Consortium (“LDC”) Web 1T 5-gram Version 1 corpus, LDC Catalog No.: DC2006T13, ISBN: 1-58563-397-6, contributed by Google Inc.
- LDC Linguistic Data Consortium
- the length of the n-grams ranges from unigrams (single words) to five-grams, and each n-gram has an n-gram count generated from approximately one trillion word tokens (including individual words, punctuation, markers identifying a beginning and end of individual sentences) of text from publicly accessible Web pages.
- the corpus can be a single language or can include several languages, e.g., for machine translation applications, for which a language model can be built for each language.
- a sample corpus could include texts of 200 billion English words, 88 billion Chinese words, and 30 billion German words.
- n-gram entries can be reduced to a single n-gram entry.
- the n-gram “word-A word-B RareWord1 word-C word-D” and the n-gram “word-A word-B RareWord2 word-C word-D” can both be mapped to the n-gram “word-A word-B ⁇ UNK> word-C word-D”.
- the language model for a corpus can be very large.
- the language model is built using distributed processing.
- the raw data of the corpus can be separated into a number of different parts by sharding the corpus.
- Sharding refers to the process of separating a large data set into smaller pieces.
- a sharding function applies a unique shard identifier to chunks of data in the corpus, splitting the large data set into a number of disjoint subsets. There can be redundancy in the data contained within shards, for example, for efficiency or to protect against hardware failures for a particular shard.
- the data forming the language model can be distributed, for example, according to the GoogleTM File System (GFS).
- GFS GoogleTM File System
- the GFS architecture includes a GFS cluster having a single master and multiple “chunkservers”. Files are divided into fixed size chunks, which are uniquely identified by the master and stored on a particular chunkserver. Each chunk can be replicated on multiple chunkservers.
- the master includes file system metadata. This includes namespace, access control information, mapping from files to chunks, and locations of chunks. Additional information about GFS can be found in Ghemawat et al., “The Google File System”, Symposium on Operating System Principles, Oct. 19-20, 2003.
- the data contained in each shard is processed in parallel to identify words including sentence beginning (“ ⁇ s>”) and end (“ ⁇ /s>”) marker.
- the processed information can be used when generating the vocabulary for the language model, which includes sentence markers as words, as will be described below.
- a MapReduce process can be undertaken to process the data.
- MapReduce Simplified Data Processing on Large Clusters , Proceedings of the 6th Symposium on Operating Systems Design and Implementation, pp. 137 150 (Dec. 6, 2004), the contents of which are incorporated here by reference.
- a language model can be generated from a corpus in the following steps.
- the system generates a vocabulary.
- the system uses input text from the corpus, the system outputs a vocabulary of 1-grams and their frequencies.
- n-grams and their frequencies are identified.
- the n-grams and their frequencies are identified using the text and vocabulary as input. Relative frequencies for the n-grams are calculated using the n-grams and their respective frequencies.
- Each step in the process can be implemented using MapReduce as described above.
- FIG. 2 is a flow chart of an example method 200 for encoding a language model. For convenience, the method 200 will be described with respect to a system that performs the method 200 .
- the system receives 202 a language model.
- the language model includes a collection of n-grams and one or more associated parameter values.
- the parameter values can be, for example, probability values for each n-gram indicating the probability of the n-gram occurring in a particular corpus. Additionally, the parameter values can include back-off weights for each back-off n-gram, the n-grams' frequencies, or other values associated with the n-grams.
- the language model is constructed by the system, for example, as described in FIG. 1 .
- the language model data is received.
- the system can receive a previously constructed (e.g., by the system or from a separate system including third party systems) collection of n-grams and associated parameter values.
- the language model is encoded using a Bloomier filter such that parameter values for each n-gram in the language model can be retrieved using an associative array of values.
- a Bloomier filter is a generalized form of a Bloom filter.
- a Bloom filter is a succinct approximate membership tester that uses an array and hash functions to approximately represent a set.
- the system uses randomization to map each n-gram to a distinct fingerprint and to generate hash functions to associate each n-gram with their corresponding parameter values.
- the system encodes the language model including a set of n-grams/parameter value pairs using an array A having a size M.
- Each n-gram x i is a member of the collection of all possible n-grams, U, and their associated parameter values v(x i ) can be drawn from a corresponding set of possible values, V.
- the system determines 204 a fingerprint value for each n-gram in the collection of n-grams S. Note the distinction between all possible n-grams U over which the hash/fingerprint functions are defined and the set of actual n-grams S that are stored in the model. Using a fingerprint function, a corresponding fingerprint value can be stored for each n-gram such that the n-grams themselves no longer need to be explicitly stored in the language model. The system determines the fingerprint for each n-gram using a particular fingerprint function. For example, a fingerprint function f: U ⁇ [0, B ⁇ 1] provides a random hash function that maps n-grams to integers having values between 0 and B ⁇ 1.
- a hash function is a function that when applied to an input (e.g., an n-gram) produces a particular output value (e.g., a number). Thus, application of a hash function to each element of a collection of n-grams produces a corresponding fingerprint value for each n-gram.
- the array A has a number of locations (addresses) of size log 2 B.
- the size of B impacts the amount so space used per encoded n-gram. While a larger B can be used to lower the probability of a false positive result (e.g., the error rate identifying the probability that two different n-grams incorrectly correspond to the same parameter values in the array), the larger B also increases the size of the encoded language model. Therefore, a balance is needed between the size of the language model and an acceptable error rate.
- each hash function h i U ⁇ [0, M ⁇ 1] maps each n-gram to a location in the array A, which has M cells numbered from 0 to M ⁇ 1.
- the composite perfect hash function g(x i ) is defined as:
- f(x i ) is the fingerprint of n-gram x i
- A[h i (x i )] is the value stored in location h i (x i ) of the array A corresponding to the hash h i applied to the n-gram x i for all k hash functions
- ⁇ circle around (x) ⁇ is the bitwise exclusive OR operator.
- the system encodes 208 one or more parameter values of the n-grams as a function of the corresponding array values and fingerprint.
- FIG. 3 is an example diagram 300 of using a composite hash function to identify a parameter value for an n-gram X 302 .
- the n-gram X 302 has an associated parameter value of 3.
- the n-gram 302 is shown operated on by each of three hash functions, h 1 (x) 304 , h 2 (x) 306 , and h 3 (x) 308 as well as the fingerprint function f(x) 310 .
- the fingerprint function f(x) 312 when applied to the n-gram, produces a value of 7.
- Each of the three hash functions 304 , 306 , and 308 when applied to X, point to particular locations in the array 312 .
- hash function h 1 (x) 304 points to a location in the array 312 having a value of 5.
- Hash function h 2 (x) 306 points to a location in the array 312 having a value of 8.
- Hash function h 3 (x) 308 points to a location in the array 312 having a value of 9.
- each location in the array is selected such that the composite perfect hash function returns the value of the corresponding n-gram.
- the values are assigned to locations in the array such that each n-gram x i is associated with a single updatable location in the array.
- the updatable location for each n-gram is selected from among the k locations given by h j (x i ), j ⁇ [k], where k is the number of hash functions and h j (x i ) is a particular hash function applied to the n-gram x i .
- the composite function g(x i ) depends on the values stored at all k locations, A[h 1 (x i )], A[h 2 (x i )], . . . , A[h k (x i )], in the array (i.e., the values stored at each location identified by the k applied hash functions). Therefore, once a location is assigned a value for encoding an n-gram x i , the value at that location should not be changed by the encoding of values for other n-grams. Similarly, in some implementations, the locations in A referenced by the other h j (x i ) for a given n-gram x i remains unchanged once the n-gram x i has been encoded in the model.
- each n-gram can be encoded in the array such that the composite hash function returns the parameter value for the corresponding n-gram according to an update rule described by:
- v(x i ) is the value of n-gram x i
- f(x i ) is the fingerprint of n-gram x i
- FIG. 4 is a flow chart of an example method 400 for encoding values in an array.
- the method 400 is used to select one of the k hash functions, h j , j ⁇ [k], for each n-gram x i ⁇ S, where S is the collection of n-grams to be encoded.
- the method 400 also determines an order in which to apply the update rule above so that g(x i ) maps x i to v(x i ) for all n-grams in S.
- the system generates 402 an array having size M (e.g., having M address locations).
- each location is initially assigned a value of zero, or alternatively is empty.
- a single location is uniquely updated for each encoded n-gram.
- the system has to identify the location in the array unique to a particular n-gram such that other n-gram encodings do not change the value stored at that location.
- the system hashes 404 each n-gram in a collection of n-grams with k different hash functions. In some implementations, three hash functions are used. However, any number of hash functions can be used.
- the system associates 406 each n-gram with k locations in the array corresponding to the k hash functions. For example, if three hash functions are used, each n-gram is associated with three locations in the array corresponding to the values produced by the respective hash functions (i.e., the value produced by the hash function when applied to a particular n-gram identifies a particular location in the array). Thus, the k hash functions are selected such that their output values are within the range of the array.
- the n-grams of the collection and the locations in the array can be used to form a bipartite graph whose left hand side nodes correspond to n-grams and whose right hand side nodes correspond to locations in the array.
- the graph includes edges from each n-gram to each of the k locations in the array given by hash functions h 1 (x i ), h 2 (x i ), . . . , h k (x i ).
- FIG. 5 shows a sequence of diagrams 500 - 512 illustrating the relationship between n-gram keys and array locations for an example collection of n-grams and array locations.
- Diagram 500 shows a collection of five n-grams ( 1 - 5 ) and seven array locations (A-G). Each n-gram has three edges directed to three array locations. The edges represent the hash functions applied to the n-gram, where the result of each hash function identifies a respective array location. For example, the hash functions applied to n-gram 1 points to locations A, B, and F in the array.
- the system identifies 408 a first location in the array for which only one n-gram points. While each n-gram includes k edges from the n-gram to locations in the array, not all array locations are identified more than once. Additionally, some array locations may not be identified by any n-gram.
- a location in the array with only one edge can be referred to as a location that has degree one. In a bipartite graph, when a right hand side node has a degree of one, it can be matched with its associated left hand side node since no other left hand side node can be dependent on it. Thus, the location in the array with only one edge can be matched with a particular n-gram.
- one or more new hash functions are selected and the n-grams are rehashed.
- One method for selecting hash functions is to use 2-universal hash functions defined for a range of size M (i.e., for the size of the array) using a prime P ⁇ M and two random numbers 1 ⁇ a j ⁇ P and 0 ⁇ b j ⁇ P for j ⁇ [k] such that h j (x) ⁇ (a j x+b j )mod P taken modulo M.
- Hash functions are generated by sampling k pairs of random numbers (a j , b j ), j ⁇ [k]. If the ordering technique does not match all the n-grams to locations using the generated hash function, the pairs of random numbers are resampled to provide new hash functions.
- diagram 500 includes an array location E that is only identified by n-gram 3 . Every other location in the array is pointed to by more than one n-gram. Therefore, the first identified location is location E (the first location in the array having degree one).
- the system removes 410 each other edge from the n-gram corresponding to the identified first location.
- the n-gram 3 is left with a single edge corresponding to the first location E.
- diagram 502 shows n-gram 3 with only an edge pointing to location E.
- the edges from n-gram 3 to locations A and D are removed.
- the location and corresponding n-gram node can be removed from the graph and pushed onto a matched stack of n-gram/location pairs, (x i , h j (x i )). Removing the locations from the graph after they are matched with a unique n-gram can be used to guarantee that each n-gram x i is assigned a unique location in the array.
- the system repeats 412 the process of removing remaining edges from n-grams including an edge corresponding to a location of degree one in the array until each n-gram has been associated with a single location in the array. Once the edges are removed, additional locations in the array can become degree one. Thus, each location of degree one is sequentially identified, pairing each location with a unique n-gram to which the location is connected. The pairs are moved, in order, onto the matched stack.
- diagram 506 of FIG. 5 shows the five n-grams each including an edge pointing to a unique location in the array. Since the array has more locations than there are n-grams, there are empty locations B and F that are not identified by any n-gram after the other edges are eliminated. Additionally, diagram 506 indicates the order in which the n-grams were associated with a single location in the array.
- the locations can be encoded with location values.
- the system initially assigns 414 location values to locations associated with the last n-gram to have edges removed.
- the process is repeated 416 for locations associated with each n-gram in the reverse order to which edges were removed.
- the order in which the n-grams were pushed onto the stack of matched pairs determines the encoding order (i.e., n-grams are taken from the stack in the reverse order to which they were inserted).
- the edges are restored (e.g., all the locations for which the hash functions of the n-gram point) and the system identifies the unique location in the array that was paired with the n-gram during the matching process described above. This is the unique location that will be updated such that the composite hash function returns the one or more correct parameter values of the n-gram.
- FIG. 5 An example of assigning location values is shown in diagrams 508 , 510 , and 512 of FIG. 5 .
- the values of locations associated with n-gram 1 are encoded since n-gram 1 was the last n-gram to be associated with a single location in the array (location A).
- the other locations pointed to by n-gram 1 e.g., using the other hash functions
- locations B and F are not uniquely associated with any of the n-grams.
- those locations are assigned a value of zero.
- those locations are already assigned a value of zero by default when the array is generated.
- any constant or otherwise chosen value can be assigned to those locations. Those locations are not subsequently changed for the encoding of n-gram 1 to remain valid.
- a value for location A V 1 is determined and encoded.
- the location value for location A is determined such that the composite hash function returns a value corresponding to the one or more parameter values for n-gram 1 . Since the values for the fingerprint of n-gram 1 as well as the values for locations B and F are constants, an appropriate value V 1 for location A can be determined.
- the value for location A is unchanged (along with the values for locations B and F). As values for other n-grams are encoded, only the location value of the uniquely associated location is modified.
- the values of locations associated with n-gram 2 are encoded since n-gram 2 was the next to last n-gram to be associated with a single location in the array (location C).
- the three hash functions of n-gram 2 point to locations A, B, and C.
- the location values for locations A and B have already been assigned and are not changed.
- the location value for location value for location C the location uniquely associated with n-gram 2 , can be assigned.
- a location value V 2 is determined such that the composite hash function returns a value corresponding to the one or more parameter values of n-gram 2 .
- the final encoding is illustrated for all of the locations in the array.
- the fingerprint value and array values corresponding to the hash functions applied to the n-gram provide a result corresponding to the one or more parameter values encoded for that n-gram (e.g., the probability of the n-gram occurring in a corpus).
- Input Set of n-grams S; k hash functions h j , j ⁇ [k]; number of available locations M.
- Output Ordered matching ‘matched’ or FAIL. matched [ ] for all i ⁇ [M] do r2l i empty set end for for all x i ⁇ S do l2r i empty set for all j ⁇ [k] do l2r i l2r i ⁇ h j (x i ) r2l h j (x i ) r2l h j (x i ) +1 end for end for degree_one ⁇ i ⁇ [0,M ⁇ 1]
- 1 ⁇ while
- the array is separated into a plurality of array chunks to aid in encoding and searching the array.
- the raw data and the graph are held in memory as the hash functions are applied.
- this makes it difficult to encode a very large collection of n-gram/parameter value pairs in a single array. Determining unique locations in which to encode each n-gram can become cumbersome if the set of n-grams and/or the array are large.
- the n-gram/parameter value pairs are split into smaller chunks that are arranged in lexicographic order by n-gram. As an example, one or more of the smaller chunks can each encode five million n-grams.
- the one or more parameter values for the n-grams in each chunk can then be encoded in a separate array in turn while being held in memory.
- An index can be sorted that includes the final n-gram encoded in each array.
- searching for the one or more parameter values encoded for a particular n-gram the system performs a binary search for the appropriate array using the index. Alternatively, the system can use one or more other searching techniques to identify the appropriate array. Once the array is located, the particular values of locations in the array can be retrieved.
- FIG. 6 is a flow chart of an example method 600 for retrieving a parameter value for an n-gram.
- the method 600 will be described with respect to a system that performs the method 600 (e.g., a speech recognition, machine translation, or optical character recognition system).
- the system receives 602 an n-gram.
- the n-gram can be received as part of a string (e.g., of text) including one or more n-grams.
- the string of text can be, for example, a string of text generated from an optical character recognition, voice recognition, or machine translation operation.
- the string can include text forming words, punctuation symbols, and other characters. Additionally, the string can include information for identifying a beginning of a sentence, an end of a sentence, or other formatting information about the content of the string.
- the system identifies 604 a fingerprint for the n-gram.
- the fingerprint of the n-gram is identified by applying the fingerprint function f(x i ) to the n-gram.
- the fingerprint function can apply a particular hash function to the n-gram such that a particular fingerprint value is generated.
- the system applies 606 one or more hash functions to the n-gram (e.g., three hash functions).
- the hash functions together create a perfect hash function for S.
- Each hash function when applied to the n-gram, provides a value identifying a particular location in the array (or a particular array when multiple arrays are used).
- the system identifies 608 the values encoded in the array at the locations identified by the applied hash functions.
- the multiple arrays are used and a search is performed to identify the correct array for each identified location. For example, a binary search can be performed to identify the correct array. The value associated with each array location is retrieved.
- the system combines 610 the array values with the fingerprint to identify the one or more parameter values for the received n-gram.
- the array values and fingerprint value are combined using an exclusive bitwise OR operation.
- the identified parameter values can include, for example, a probability of the n-gram occurring within a corpus of text.
- a NULL result is returned because the n-gram is not included in the language model.
- the values encoded at each location in the array have a specified size.
- the size allotted to each location for encoding the values is selected to provide a balance between the size required to store the one or more parameter values and the acceptable error rate ⁇ (i.e., the rate of having a false positive result whereby an n-gram not included in the model is assigned a value that is not NULL).
- the size allotted for each location is two bytes.
- the one or more parameter values can be stored in the first byte while the second byte can be used for error checking.
- FIG. 7 is an example diagram of a two byte encoding 700 .
- the first byte 702 including bits 0 - 7 is used to encode the one or more parameter values associated with the particular n-gram.
- the second byte 704 including bits 8 - 15 is used for error checking.
- Using a full byte for error checking results in an error rate ⁇ of 1/256.
- the composite hash function is applied to an unknown n-gram (e.g., an n-gram that is not found in the collection of n-grams S), the result can correspond to a value that is non-zero in the second byte.
- mapping from integers in the range [0, B ⁇ 1] to values can be implemented, for example, using a lookup table or a function of the integers between [0, B ⁇ 1] where values in that range that do not correspond to valid values are mapped to a NULL symbol.
- an n-gram search typically first searches for the full n-gram first and then for shorter included n-grams only if the full n-gram is not found.
- a received n-gram is a 5-gram (w 1 , w 2 , w 3 , w 4 , w 5 ) when only the final unigram (w 5 ) is encoded in the model
- the probability of returning a false positive using the standard back-off process would not be the error rate ⁇ (e.g., 1/256), but instead would be compounded for each back-off n-gram prior to backing off to the unigram. This results in an error rate of approximately 4 ⁇ .
- the actual resulting error would be approximately 1/64, resulting in more false positive results during back-off operations.
- n-gram ABCDE the system can first check for the n ⁇ 1-gram (ABCD). If this n-gram has be previously searched for but backed off to a lesser n-gram (e.g., CD), then the search can be initially truncated to CDE instead of ABCDE since we know that ABCD does not exist.
- ABCD n ⁇ 1-gram
- FIG. 8 shows a schematic diagram of an example computer system 800 .
- the system 800 can be used for the operations described in association with the method 200 shown in FIG. 2 , according to one implementation, the method 400 shown in FIG. 4 , according to one implementation, or the method 600 shown in FIG. 6 , according to another implementation.
- the system 800 includes a processor 810 , a memory 820 , a storage device 830 , and an input/output device 840 .
- Each of the components 810 , 820 , 830 , and 840 can, for example, be interconnected using a system bus 850 .
- the processor 810 is capable of processing instructions for execution within the system 800 .
- the processor 810 is a single-threaded processor.
- the processor 810 is a multi-threaded processor.
- the processor 810 is capable of processing instructions stored in the memory 820 or on the storage device 830 to display graphical information for a user interface on the input/output device 840 .
- a parallel processing set of systems 800 connected over a network may be employed, clustered into one or more server centers.
- the memory 820 stores information within the system 800 .
- the memory 820 is a computer-readable medium.
- the memory 820 is a volatile memory unit.
- the memory 820 is a non-volatile memory unit.
- the storage device 830 is capable of providing mass storage for the system 800 .
- the storage device 830 is a computer-readable medium.
- the storage device 830 can include, for example, a hard disk device, an optical disk device, or some other large capacity storage device.
- the input/output device 840 provides input/output operations for the system 800 .
- the input/output device 840 includes a keyboard and/or pointing device.
- the input/output device 840 includes a display unit for displaying graphical user interfaces.
- Embodiments of the invention and all of the functional operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them.
- Embodiments of the invention can be implemented as one or more computer program products, i.e., one or more modules of computer program instructions encoded on a computer-readable medium for execution by, or to control the operation of, data processing apparatus.
- the computer-readable medium can be a machine-readable storage device, a machine-readable storage memory device, a composition of matter effecting a machine-readable propagated signal, or a combination of one or more them.
- data processing apparatus encompasses all apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers.
- the apparatus can include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them.
- a propagated signal is an artificially generated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus.
- the processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output.
- the processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
- processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer.
- a processor will receive instructions and data from a read-only memory or a random access memory or both.
- the essential elements of a computer are a processor for performing instructions and one or more memory devices for storing instructions and data.
- a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks.
- mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks.
- a computer need not have such devices.
- a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio player, a Global Positioning System (GPS) receiver, to name just a few.
- Computer-readable media suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks.
- the processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
- embodiments of the invention can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer.
- a display device e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor
- keyboard and a pointing device e.g., a mouse or a trackball
- Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.
- Embodiments of the invention can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the invention, or any combination of one or more such back-end, middleware, or front-end components.
- the components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), e.g., the Internet.
- LAN local area network
- WAN wide area network
- the computing system can include clients and servers.
- a client and server are generally remote from each other and typically interact through a communication network.
- the relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
Abstract
Description
where n is the order of the largest n-gram allowed in the language model.
where f (NASA officials say) is a frequency or a count of the occurrences of the string “NASA officials say” in the corpus. Conditional probabilities for strings within the maximum n-gram order in the n-gram language model correspond to the probability stored in the language model for the n-gram, e.g., p(say|NASA officials) is the conditional probability stored in the language model for the 3-gram entry “NASA officials say”.
S={(x 1 ,v(x 1),(x 2 ,v(x 2)), . . . ,(x N ,v(x N))}
Each n-gram xi is a member of the collection of all possible n-grams, U, and their associated parameter values v(xi) can be drawn from a corresponding set of possible values, V.
Where f(xi) is the fingerprint of n-gram xi, A[hi(xi)] is the value stored in location hi(xi) of the array A corresponding to the hash hi applied to the n-gram xi for all k hash functions, and {circle around (x)} is the bitwise exclusive OR operator. Additionally, to encode the one or more parameter values v(xi) for a particular n-gram using the array, the array values are chosen such that the value of g(xi)=v(xi). The system encodes 208 one or more parameter values of the n-grams as a function of the corresponding array values and fingerprint.
v(X)=g(X)=7
Where v(xi) is the value of n-gram xi, f(xi) is the fingerprint of n-gram xi, and
is the bitwise exclusive OR of the values stored in the locations in the array A indexed by the k−1 hash functions excluding hj for the n-gram xi (i.e., the locations other than the location hj(xi) that will be updated for this n-gram).
Input : Set of n-grams S; k hash functions hj, j ∈ [k]; number of available |
locations M. |
Output: Ordered matching ‘matched’ or FAIL. |
matched |
for all i ∈ [M] do |
r2li |
end for |
for all xi ∈ S do |
l2ri |
for all j ∈ [k] do |
l2ri |
r2lh |
end for |
end for |
degree_one |
while |degree_one| ≧ 1 do |
rhs |
lhs |
PUSH (lhs, rhs) onto matched |
for all rhs′ ∈ l2rlhsdo |
POP r2lrhs′ |
if |r2lrhs′| = 1 then |
degree_one |
end if |
end for |
end while |
if |matched| = |S| then |
return matched |
else |
return FAIL |
end if |
(w 1 ,w 2 , . . . ,w n)
Thus, an n-gram is not present in the model if the n−1-gram including the final n−1 words has already tested false (e.g., the lesser n-gram is not in the collection). Thus, unnecessary false positives can be avoided by not searching for the longer n-gram in such cases. Therefore, the system first searches for the unigram working up to the full n-gram requested only if the preceding searches test positive. As a result, the probability of returning a false positive for any n-gram requested, but not in the collection, returns to ε.
Claims (25)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/488,914 US8359201B1 (en) | 2008-01-10 | 2012-06-05 | Randomized language models |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US11/972,349 US8209178B1 (en) | 2008-01-10 | 2008-01-10 | Randomized language models |
US13/488,914 US8359201B1 (en) | 2008-01-10 | 2012-06-05 | Randomized language models |
Related Parent Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US11/972,349 Continuation US8209178B1 (en) | 2008-01-10 | 2008-01-10 | Randomized language models |
Publications (1)
Publication Number | Publication Date |
---|---|
US8359201B1 true US8359201B1 (en) | 2013-01-22 |
Family
ID=46272958
Family Applications (2)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US11/972,349 Expired - Fee Related US8209178B1 (en) | 2008-01-10 | 2008-01-10 | Randomized language models |
US13/488,914 Expired - Fee Related US8359201B1 (en) | 2008-01-10 | 2012-06-05 | Randomized language models |
Family Applications Before (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US11/972,349 Expired - Fee Related US8209178B1 (en) | 2008-01-10 | 2008-01-10 | Randomized language models |
Country Status (1)
Country | Link |
---|---|
US (2) | US8209178B1 (en) |
Cited By (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US9953646B2 (en) | 2014-09-02 | 2018-04-24 | Belleau Technologies | Method and system for dynamic speech recognition and tracking of prewritten script |
KR20190064181A (en) * | 2017-11-30 | 2019-06-10 | 삼성전자주식회사 | Method for training language model and apparatus therefor |
US10410114B2 (en) | 2015-09-18 | 2019-09-10 | Samsung Electronics Co., Ltd. | Model training method and apparatus, and data recognizing method |
US10585915B2 (en) | 2017-10-25 | 2020-03-10 | International Business Machines Corporation | Database sharding |
Families Citing this family (16)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8725509B1 (en) * | 2009-06-17 | 2014-05-13 | Google Inc. | Back-off language model compression |
US8612367B2 (en) * | 2011-02-04 | 2013-12-17 | Microsoft Corporation | Learning similarity function for rare queries |
US9129606B2 (en) * | 2011-09-23 | 2015-09-08 | Microsoft Technology Licensing, Llc | User query history expansion for improving language model adaptation |
US9613026B2 (en) * | 2011-12-28 | 2017-04-04 | Bloomberg Finance L.P. | System and method for interactive automatic translation |
US9230548B2 (en) * | 2012-06-06 | 2016-01-05 | Cypress Semiconductor Corporation | Hybrid hashing scheme for active HMMS |
US9047868B1 (en) * | 2012-07-31 | 2015-06-02 | Amazon Technologies, Inc. | Language model data collection |
US9679024B2 (en) * | 2014-12-01 | 2017-06-13 | Facebook, Inc. | Social-based spelling correction for online social networks |
US11262909B2 (en) * | 2016-06-02 | 2022-03-01 | Myscript | System and method for input recognition linguistic resource management |
US11188594B2 (en) * | 2018-02-07 | 2021-11-30 | Oracle International Corporation | Wildcard searches using numeric string hash |
US10769150B1 (en) | 2019-12-26 | 2020-09-08 | Snowflake Inc. | Pruning indexes to enhance database query processing |
US11372860B2 (en) | 2019-12-26 | 2022-06-28 | Snowflake Inc. | Processing techniques for queries where predicate values are unknown until runtime |
US11567939B2 (en) | 2019-12-26 | 2023-01-31 | Snowflake Inc. | Lazy reassembling of semi-structured data |
US11681708B2 (en) | 2019-12-26 | 2023-06-20 | Snowflake Inc. | Indexed regular expression search with N-grams |
US10997179B1 (en) | 2019-12-26 | 2021-05-04 | Snowflake Inc. | Pruning index for optimization of pattern matching queries |
US11308090B2 (en) | 2019-12-26 | 2022-04-19 | Snowflake Inc. | Pruning index to support semi-structured data types |
US11880369B1 (en) | 2022-11-21 | 2024-01-23 | Snowflake Inc. | Pruning data based on state of top K operator |
Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20040243411A1 (en) | 2003-05-30 | 2004-12-02 | Microsoft Corporation | Method and apparatus for compressing asymmetric clustering language models |
US6856956B2 (en) | 2000-07-20 | 2005-02-15 | Microsoft Corporation | Method and apparatus for generating and displaying N-best alternatives in a speech recognition system |
US7031910B2 (en) | 2001-10-16 | 2006-04-18 | Xerox Corporation | Method and system for encoding and accessing linguistic frequency data |
US7877258B1 (en) | 2007-03-29 | 2011-01-25 | Google Inc. | Representing n-gram language models for compact storage and fast retrieval |
-
2008
- 2008-01-10 US US11/972,349 patent/US8209178B1/en not_active Expired - Fee Related
-
2012
- 2012-06-05 US US13/488,914 patent/US8359201B1/en not_active Expired - Fee Related
Patent Citations (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6856956B2 (en) | 2000-07-20 | 2005-02-15 | Microsoft Corporation | Method and apparatus for generating and displaying N-best alternatives in a speech recognition system |
US7031910B2 (en) | 2001-10-16 | 2006-04-18 | Xerox Corporation | Method and system for encoding and accessing linguistic frequency data |
US20040243411A1 (en) | 2003-05-30 | 2004-12-02 | Microsoft Corporation | Method and apparatus for compressing asymmetric clustering language models |
US7231349B2 (en) | 2003-05-30 | 2007-06-12 | Microsoft Corporation | Method and apparatus for compressing asymmetric clustering language models |
US7877258B1 (en) | 2007-03-29 | 2011-01-25 | Google Inc. | Representing n-gram language models for compact storage and fast retrieval |
Cited By (6)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US9953646B2 (en) | 2014-09-02 | 2018-04-24 | Belleau Technologies | Method and system for dynamic speech recognition and tracking of prewritten script |
US10410114B2 (en) | 2015-09-18 | 2019-09-10 | Samsung Electronics Co., Ltd. | Model training method and apparatus, and data recognizing method |
US10585915B2 (en) | 2017-10-25 | 2020-03-10 | International Business Machines Corporation | Database sharding |
US10592532B2 (en) | 2017-10-25 | 2020-03-17 | International Business Machines Corporation | Database sharding |
KR20190064181A (en) * | 2017-11-30 | 2019-06-10 | 삼성전자주식회사 | Method for training language model and apparatus therefor |
US10509864B2 (en) | 2017-11-30 | 2019-12-17 | Samsung Electronics Co., Ltd. | Language model translation and training method and apparatus |
Also Published As
Publication number | Publication date |
---|---|
US8209178B1 (en) | 2012-06-26 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US8359201B1 (en) | Randomized language models | |
US7877258B1 (en) | Representing n-gram language models for compact storage and fast retrieval | |
US8725509B1 (en) | Back-off language model compression | |
KR102268875B1 (en) | System and method for inputting text into electronic devices | |
US8055498B2 (en) | Systems and methods for building an electronic dictionary of multi-word names and for performing fuzzy searches in the dictionary | |
EP2137639B1 (en) | Large language models in machine translation | |
JP5122486B2 (en) | Distributed Model Coding and Adaptive Scalable Access Processing | |
US7031910B2 (en) | Method and system for encoding and accessing linguistic frequency data | |
JP2009266244A (en) | System and method of creating and using compact linguistic data | |
US8423350B1 (en) | Segmenting text for searching | |
US8175864B1 (en) | Identifying nearest neighbors for machine translation | |
Talbot et al. | Randomized language models via perfect hash functions | |
EP1486885A2 (en) | Method and system for grammatical text condensation | |
CN112541062B (en) | Parallel corpus alignment method and device, storage medium and electronic equipment | |
Daciuk et al. | Finite automata for compact representation of language models in NLP | |
KR20090066470A (en) | System and method for korean morphological analysis using pre-analysis data | |
Daciuk et al. | Finite automata for compact representation of tuple dictionaries | |
Daciuk et al. | A Finite-State Library for NLP | |
Noh et al. | A joint statistical model for simultaneous word spacing and spelling error correction for Korean |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:TALBOT, DAVID;BRANTS, THORSTEN;REEL/FRAME:028321/0264Effective date: 20080109 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
CC | Certificate of correction | ||
FPAY | Fee payment |
Year of fee payment: 4 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044101/0405Effective date: 20170929 |
|
FEPP | Fee payment procedure |
Free format text: MAINTENANCE FEE REMINDER MAILED (ORIGINAL EVENT CODE: REM.); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
LAPS | Lapse for failure to pay maintenance fees |
Free format text: PATENT EXPIRED FOR FAILURE TO PAY MAINTENANCE FEES (ORIGINAL EVENT CODE: EXP.); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
STCH | Information on status: patent discontinuation |
Free format text: PATENT EXPIRED DUE TO NONPAYMENT OF MAINTENANCE FEES UNDER 37 CFR 1.362 |
|
FP | Lapsed due to failure to pay maintenance fee |
Effective date: 20210122 |