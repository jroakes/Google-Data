CN112805695A - Co-sharding and randomized co-sharding - Google Patents
Co-sharding and randomized co-sharding Download PDFInfo
- Publication number
- CN112805695A CN112805695A CN202080005621.2A CN202080005621A CN112805695A CN 112805695 A CN112805695 A CN 112805695A CN 202080005621 A CN202080005621 A CN 202080005621A CN 112805695 A CN112805695 A CN 112805695A
- Authority
- CN
- China
- Prior art keywords
- data
- row
- indexed
- split
- index table
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
- 238000000034 method Methods 0.000 claims description 24
- 239000012634 fragment Substances 0.000 claims description 6
- 230000003247 decreasing effect Effects 0.000 claims description 4
- 230000004044 response Effects 0.000 claims description 4
- 238000005516 engineering process Methods 0.000 abstract description 5
- 238000000638 solvent extraction Methods 0.000 abstract description 2
- 230000015654 memory Effects 0.000 description 11
- 238000012545 processing Methods 0.000 description 9
- 238000004891 communication Methods 0.000 description 7
- 238000010586 diagram Methods 0.000 description 7
- 238000007726 management method Methods 0.000 description 4
- 238000013475 authorization Methods 0.000 description 3
- 239000000835 fiber Substances 0.000 description 3
- 238000013515 script Methods 0.000 description 3
- 230000008901 benefit Effects 0.000 description 2
- 238000003491 array Methods 0.000 description 1
- 230000005540 biological transmission Effects 0.000 description 1
- 230000015572 biosynthetic process Effects 0.000 description 1
- 238000013506 data mapping Methods 0.000 description 1
- 230000007423 decrease Effects 0.000 description 1
- 238000013467 fragmentation Methods 0.000 description 1
- 238000006062 fragmentation reaction Methods 0.000 description 1
- 230000006870 function Effects 0.000 description 1
- 230000003287 optical effect Effects 0.000 description 1
- 229920001690 polydopamine Polymers 0.000 description 1
- 239000007787 solid Substances 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/22—Indexing; Data structures therefor; Storage structures
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/22—Indexing; Data structures therefor; Storage structures
- G06F16/2282—Tablespace storage structures; Management thereof
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/24—Querying
- G06F16/245—Query processing
- G06F16/2458—Special types of queries, e.g. statistical queries, fuzzy queries or distributed queries
- G06F16/2477—Temporal data queries
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/27—Replication, distribution or synchronisation of data between databases or within a distributed database system; Distributed database system architectures therefor
Abstract
The present technology relates to common sharding of tables in a distributed storage system. A data table including one or more rows may be received. Each row in the data table may include an identifier key and a data segment. Each data segment in the data table may be indexed into a separate row of an index table, wherein each row in the index table includes data associated with the identifier key of the data table from which the data segment in the respective row is indexed. The index table may be partitioned into splits, wherein the partitioning includes assigning each row of the index table to one of the splits based on the identifier key of the data table from which the data segment in the corresponding row is indexed. The split may be stored into two or more portions of the distributed storage system.
Description
Cross Reference to Related Applications
This application claims benefit of U.S. provisional application No. 62/821,156 entitled sharing and Randomized sharing (co-sharding and Randomized co-sharding) filed on 3/20/2019, the disclosure of which is incorporated herein by reference.
Background
Relational databases typically operate with data arranged in tables for efficient storage and retrieval. As tables grow, data is typically distributed across many database servers. However, splitting the table to different database servers may reduce the efficiency of the relational database in retrieving data. In this regard, distributed operations (i.e., operations requiring communication between different database servers or components within a database center) may be required to locate and retrieve the retrieved data.
Disclosure of Invention
The present disclosure generally relates to co-slicing (cosharding) a table. One aspect of the technology is directed to a method for co-sharding a table within a distributed storage system. The method can comprise the following steps: receiving, by one or more processors, a data table comprising one or more rows, wherein each row comprises an identifier key and a data segment; indexing, by one or more processors, each data segment in the data table into a separate row of the index table, wherein each row in the index table includes data associated with an identifier key of the data table from which the data segment in the respective row is indexed; fragmenting, by the one or more processors, the index table into splits, wherein fragmenting comprises assigning each row of the index table to one of the splits based on an identifier key of a data table from which the data segment in the corresponding row is indexed; and storing, by the one or more processors, the split into two or more portions of the distributed storage system.
In some examples, one or more rows from the data table may be fragmented along with one or more index table rows to which data segments of the respective rows of the data table are indexed. In some instances, one or more rows from the data table may be stored in the same split as one or more index table rows to which data segments of corresponding rows of the data table are indexed.
In some examples, the data in the data table may be in one or more columns of the data table.
In some examples, the identifier key may comprise a randomly generated number, among others. In some instances, the identifier key may include a timestamp. In some examples, the splits may be ordered by timestamp.
In some examples, the identifier key may comprise a monotonically increasing or decreasing value. In some instances, the splits may be ordered by monotonically increasing or decreasing values.
In some examples, the entire index table may be fragmented into splits.
In some examples, the storing the split into two or more portions of the distributed storage system may include: the first split is stored into a first portion of the two or more portions of the distributed storage system and the second split is stored into a second portion of the two or more portions of the distributed storage system.
In some examples, the method may include: receiving a request to retrieve one or more keys associated with the indexed data segment; in response to receiving the request, identifying, by a first server of the distributed data system, one or more keys associated with the indexed data segment in a first split, and identifying, by a second server of the distributed data system, one or more keys associated with the indexed data segment in a second split; merging the keys identified from the first split and the second split; and outputting the merged key through the distributed data system.
In some examples, each row in the data table is transactionally indexed into the index table in a relational online database stored in the distributed storage system.
Another aspect of the technology is directed to a system for co-sharding a table. The system may include: a distributed storage system; and one or more processors, wherein the one or more processors are configured to: receiving a data table comprising one or more rows, wherein each row comprises an identifier key and a data segment; indexing each data segment in the data table into a separate row of the index table, wherein each row in the index table includes data associated with an identifier key of the data table from which the data segment in the respective row is indexed; sharding the index table into splits, wherein sharding includes assigning each row of the index table to one of the splits based on an identifier key of the data table from which the data segment in the corresponding row is indexed; and storing the split into two or more portions of the distributed storage system.
In some examples, the one or more processors may be further configured to: one or more rows from the data table are fragmented along with one or more index table rows to which data segments of corresponding rows of the data table are indexed. In some instances, one or more rows from the data table may be stored in the same split as one or more index table rows to which data segments of corresponding rows of the data table are indexed.
In some examples, the data in the data table may be in one or more columns of the data table.
In some examples, the identifier key may include a timestamp. In some instances, the splits may be ordered by timestamp.
In some examples, storing the split into two or more portions of the distributed storage system may include: the first split is stored into a first portion of the two or more portions of the distributed storage system and the second split is stored into a second portion of the two or more portions of the distributed storage system. In some examples, in response to receiving a request to retrieve one or more keys associated with the indexed data segment, identifying, by a first server of the distributed data system, the one or more keys associated with the indexed data segment in a first split, and identifying, by a second server of the distributed data system, the one or more keys associated with the indexed data segment in a second split; merging the keys identified from the first split and the second split; and outputting the merged key through the distributed data system.
In some examples, each row in the data table is transactionally indexed into the index table in a relational online database stored in the distributed storage system.
Another aspect of the technology is directed to a method for co-sharding a table within a distributed storage system. The method can comprise the following steps: receiving, by one or more processors, a data table comprising one or more rows and a plurality of columns, wherein each row corresponding to a first column of the plurality of columns comprises an identifier key and a second column and a third column of the plurality of columns each comprise a data segment; indexing, by the one or more processors, each data segment in the second column in the data table into a separate row and column of the first index table, wherein each row in the index table includes data associated with an identifier key of the data table from which the data segment in the respective row is indexed; indexing, by the one or more processors, each data segment in a third column in the data table into a separate row and column of a second index table, wherein each row in the index table includes data associated with an identifier key of the data table from which the data segment in the respective row is indexed; fragmenting, by the one or more processors, the first index table and the second index table into splits, wherein fragmenting comprises assigning, based on an identifier key of a data table from which data segments in respective rows are indexed, each row of the first index table and the second index table to one of the splits; and storing, by the one or more processors, the split into two or more portions of the distributed storage system.
The methods described herein may be implemented using one or more computing devices and/or systems. The method may be stored in a computer readable medium, such as a non-transitory computer readable medium.
Drawings
Fig. 1 is a block diagram of an example system within a distributed storage system in accordance with various aspects of the present disclosure.
Fig. 2 is an illustration of generating an index table from a data table in accordance with various aspects of the present disclosure.
Fig. 3A is an illustration of sharding an index table based on keys of the index table in accordance with various aspects of the disclosure.
FIG. 3B is a diagram illustrating how keys in an index table map back to rows in a data table in accordance with aspects of the present disclosure.
FIG. 4A is an illustration of sharding an index table based on keys of a data table in accordance with various aspects of the present disclosure.
Fig. 4B is a diagram illustrating how keys in an index table map back to rows in a data table in accordance with various aspects of the present disclosure.
Fig. 5 is a diagram illustrating an example of searching for splits in a distributed data store, in accordance with various aspects of the present disclosure.
Fig. 6 is a diagram illustrating an example of searching for splits in a distributed data store, in accordance with various aspects of the present disclosure.
Fig. 7 is an illustration of data allocated for processing by a server in accordance with various aspects of the disclosure.
Fig. 8 is an illustration of generating an index table from a data table having randomized identifiers in accordance with various aspects of the disclosure.
Fig. 9 is an illustration of common sharding of an index table generated from a data table with randomized identifiers in accordance with various aspects of the disclosure.
Fig. 10 is a flow diagram in accordance with various aspects of the present disclosure.
Detailed Description
SUMMARY
The techniques generally involve fragmenting (i.e., splitting) an index table such that entries are stored in fragmented form based on keys of another table, and transactionally maintaining these commonly fragmented indices in a relational online database. Transactionally maintaining the index in the relational online database may include: for each new data row added to the storage system, the row is indexed atomically (in a transactional manner) using the add document operation so that both the row and the index can become visible to the query when the transaction is completed. As the amount of data increases, the distributed storage system may store data from the data table into an index table that indexes data from rows in the data table to keys in the index table. Each row in the index table may include a key and data mapping the key back to the row in the data table from which it was indexed. The index table may be split into a plurality of splits by row based on the keys of the rows in the index table. The shards may be stored in different portions of the distributed storage system (e.g., servers, storage devices, etc.). However, slicing the index table through keys of each row in the index table may result in keys corresponding to a single data table row being scattered across multiple portions of the distributed storage system. Thus, when searching an index table, distributed operations (i.e., operations requiring communication between different portions of the distributed storage system) may be required, such as concatenating search results from each portion of the distributed storage system to determine whether the data to be searched is within a single row of the data table.
To reduce the number of distributed operations required to determine whether the data to be searched is located within a row of a data table, the index may be sliced through keys of the data table or another index table. In this way, rows in the index table may be fragmented into splits, such that all index table keys corresponding to one data table row are found in a single split. Thus, it may be determined locally (i.e., on a portion of the distributed storage system) whether a given data table row matches the query. Although the examples herein describe indexing data tables into a single index table, data tables may be indexed into more than one index table, and these index tables may be sharded by the keys of the data tables or other index tables.
Example System
FIG. 1 illustrates an example system 100 that includes a distributed storage system. Multiple data centers 160, 170, 180 may be communicatively coupled, for example, by a network 150. The data centers 160, 170, 180 may further communicate with one or more client devices (e.g., client computing devices 110) over the network 150. Thus, for example, the client computing device 110 may perform operations in the "cloud". In some examples, the data centers 160, 170, 180 may further be in communication with a server/controller 190.
Each client computing device 110 may be a personal computer for use by a person having all of the internal components typically found in a personal computer, such as a Central Processing Unit (CPU), CD-ROM, hard drive and display device (e.g., a monitor having a screen, a projector, a touch screen, a small LCD screen, a television or another device such as an electrical device operable to display information processed by processor 120), speakers, a modem and/or network interface device, user input such as a mouse, keyboard, touch screen or microphone, and all of the components used to connect these elements to one another. Further, computers according to the systems and methods described herein may include devices capable of processing instructions and transmitting data between a person and other computers, including general purpose computers, PDAs, tablets, mobile phones, smart watches, network computers lacking local storage functionality, set-top boxes for televisions, and other networked devices.
The client computing device 110 may contain a processor 120, memory 130, and other components typically found in a general purpose computer. Memory 130 may store information accessible to processor 120, including instructions 132 that may be executed by processor 120. Memory 130 may also include data 134 that may be retrieved, manipulated, or stored by processor 120. Memory 130 is a type of non-transitory computer readable medium capable of storing information accessible by processor 120, such as hard disk drives, solid state drives, tape drives, optical storage, memory cards, ROM, RAM, DVD, CD-ROM, writable read-only memory. The processor 120 may be a well known processor or other less well known type of processor. Alternatively, the processor 120 may be a dedicated controller, such as an ASIC.
The instructions 132 may be a set of instructions, such as machine code, that are directly executed by the processor 120, or instructions, such as scripts, that are indirectly executed. In this regard, the terms "instructions," "steps," and "programs" may be used interchangeably herein. The instructions 132 may be stored in an object code format for direct processing by the processor 120, or in other types of computer languages, including scripts or collections of independent source code modules, which scripts or collections are interpreted or pre-compiled as needed.
Data 134 may be retrieved, stored, or modified by processor 120 according to instructions 132. For example, although the systems and methods are not limited by a particular data structure, the data 134 may be stored in computer registers, in a distributed storage system as a structure having a number of different fields and records, in a document, or in a buffer. Data 134 may also be formatted in a computer-readable format, such as, but not limited to, binary values, ASCII, or Unicode. Further, the data 134 may include information sufficient to identify the relevant information, such as numbers, descriptive text, proprietary codes, pointers, references to data stored in other memories (including other network locations), or information for functions used to calculate the relevant data.
Although fig. 1 functionally shows the processor 120 and memory 130 as being within the same block, the processor 120 and memory 130 may actually comprise multiple processors and memories that may or may not be stored within the same physical housing. For example, some of the instructions 132 and data 134 may be stored on a removable CD-ROM, while others may be stored on a read-only computer chip. Some or all of the instructions and data may be stored in a location physically remote from processor 120 but still accessible to processor 120. Similarly, processor 120 may actually comprise a collection of processors, which may or may not operate in parallel.
The data centers 160, 170, 180 may be positioned a substantial distance from each other. For example, data centers may be located in various countries around the world. Each data center 160, 170, 180 may include one or more computing devices, such as processors, servers, shards, and the like. For example, as shown in fig. 1, data center 160 includes computing devices 162, 164, data center 170 includes computing device 172, and data center 180 includes computing devices 181-186. According to some examples, a computing device may include one or more virtual machines running on a host machine. For example, the computing device 162 may be a host that supports multiple virtual machines 166, 167 that run operating systems and applications. Although only a few virtual machines 166, 167 are illustrated in fig. 1, it should be understood that any number of virtual machines may be supported by any number of host computing devices. Further, it should be understood that the configuration shown in fig. 1 is merely an example, and that the computing devices in each of the example data centers 160, 170, 180 may have various structures and components that may be the same or different from one another.
The program may be executed across these computing devices, e.g., such that some operations are performed by one or more computing devices of a first data center and other operations are performed by one or more computing devices of a second data center. In some examples, computing devices in various data centers may have different capacities. For example, different computing devices may have different processing speeds, workloads, etc. Although only a few of these computing devices are shown, it should be understood that each data center 160, 170, 180 may include any number of computing devices, and that the number of computing devices in a first data center may be different than the number of computing devices in a second data center. Moreover, it should be understood that the number of computing devices in each data center 160, 170, 180 may change over time, for example, as hardware is removed, replaced, upgraded, or expanded.
In addition, various backend systems may be built on a distributed storage system. Such as an identity management system, a Domain Name Server (DNS) setting management system, etc. Such backend systems may be somewhat interrelated. For example, a user of the DNS settings management system may log in using an identity managed by the identity management system.
In some examples, each data center 161, 170, 180 may also include a plurality of storage devices (not shown), such as hard disk drives, random access memory, diskettes, disk arrays, tape drives, or any other type of storage device. The data centers 160, 170, 180 may implement any of a variety of architectures and technologies, including but not limited to Direct Attached Storage (DAS), Network Attached Storage (NAS), Storage Area Networks (SAN), Fibre Channel (FC), fibre channel over ethernet (FCoE), hybrid architecture networks, and the like. In addition to storage devices, data centers may include many other devices, such as cables, routers, and the like. Further, in some examples, the data centers 160, 170, 180 may be virtualized environments. Further, although only a few data centers 1160, 170, 180 are shown, several data centers may be coupled by the network 150 and/or additional networks.
In some examples, the controller 190 may be in communication with computing devices in the data centers 160, 170, 180 and may facilitate execution of programs. For example, controller 190 may track capacity, status, workload, or other information for each computing device and use such information to assign tasks. Similar to the client computing device 110 described above, the controller 190 may include a processor 120 and a memory 191, including data 194 and instructions 192. The controller 190 may be configured to populate various components of the distributed storage system with changes that affect the authorization parameters without shutting down service to the user. For example, the controller 190 may have knowledge of the organizational structure and map to fill in changes that affect the authorization parameters throughout the organizational structure.
The client computing devices 110, data centers 160, 170, 180, and controller 190 are capable of direct and indirect communication, such as over the network 150. For example, using an internet socket, the client computing device 110 may connect to a service operating on a remote server through an internet protocol suite. The server may set up a listening socket that may accept the initial connection for sending and receiving information. The network 150 and intermediate nodes may include various configurations and protocols, including the internet, world wide web, intranets, virtual private networks, wide area networks, local area networks, private networks using communication protocols proprietary to one or more companies, ethernet, WiFi (e.g., 702.71, 702.71b, g, n, or other such standards), and HTTP, as well as various combinations thereof. Devices capable of sending data to other computers, such as modems (e.g., dial-up, cable, or fiber optic) and wireless interfaces, may facilitate such communication.
The client computing device 110 may request access to the program using one of the backend systems in the cloud. Such requests may be processed by controller 190 and/or one or more computing devices in data centers 160, 170, 180. When changes are made that affect authorization, such as changing access rights to a particular role, such changes can be made to infiltrate the distributed storage system by using inference, reasoning, and transmission without shutting down the backend system or disrupting service to the client computing device 110.
Example method
The data input into the distributed storage system may be in the form of a data table. In this regard, the data table may include one or more identifier keys (IDs) for each row and data corresponding to each identifier key. An exemplary data table 201 is shown in fig. 2. The data table 201 includes three identifier keys '1', '2', and '3'. The data in the row 210 of ID '1' includes data 'a b c', the data in the row 212 of ID '2' includes data 'b c', and the data in the row 214 of ID '3' includes data 'b'. The data 'a', 'b' and 'c' may represent different data segments, such as individual words in a text entry, an entire text entry, a portion of a file, an entire file, and so on. Although the data corresponding to each identifier key is shown within a single column in the data table 201, the data associated with the identifier key may be within multiple columns in a row. Further, for a row entry having more than one identifier key, the identifier keys may be distributed across multiple columns in the row. For example, data within a row of ID '1' may be included in three columns, with data 'a' in a first column, data 'b' in a second column, and data 'c' in a third column. There may be any number of columns in a row.
Each data segment in the data table 201 may be indexed into a separate row of the index table. In this regard, a server or controller (such as controller 190) may index each data segment into a corresponding key within a row of the index table. For example, FIG. 2 further illustrates that the data associated with ID '1' (i.e., 'a', 'b', and 'c') in row 210 of data table 201 is indexed to rows 213, 215, and 221 in index table 203 corresponding to keys 'a', 'b', and 'c', respectively. Data associated with ID '2' (i.e., 'b' and 'c') in row 212 of data table 201 and data associated with ID '3' (i.e., 'b') in row 214 of data table 201 are indexed into rows 217, 223, 219 of index table 203 corresponding to keys 'b', 'c', and 'b', respectively. For a data table having multiple identifier keys, one or more of the identifier keys may be used to index corresponding data.
Each key in index table 203 may correspond to data indicating an identifier key of a data table in which the data indexed to the key of the index table is located. For example, the rows in the index table 203 corresponding to keys 'a' (row 213), 'b' (row 215), and 'c' (row 221) include data '1' indicating an identifier key corresponding to row 210 in the data table 201 where the data indexed to keys 'a', 'b', and 'c' are located. Similarly, the rows of keys 'b' (row 217) and 'c' (row 223) include data '2', which data '2' indicates the identifier key corresponding to row 212 in the data table 201. The row of key 'b' (row 219) includes a "3" indicating the identifier key corresponding to row 214 in data table 201. In an instance in which an index table (first index table) is created from another index table (second index table), the first index table may include data indicating keys of the second index table to which data of keys indexed to the first index table corresponds. Although data from data table 201 is shown indexed into the key column of index table 203, some or all of the data from data table 201 may be placed in the data column of the index table. Similarly, although the IDs of data table 201 are shown indexed into the data column of index table 203, some or all of the IDs may be placed in the key column of index table 203.
The index table may be split into splits by key ranges. Fragmenting the index table may include: the index table is split into a plurality of splits and the splits are stored in different portions of the distributed storage system. In a typical distributed storage system, the index table may be sliced according to the rows of key presses of the index table. FIG. 3A illustrates an example of splitting index table 203 into split 1 and split 2 by rows according to keys of index table 203. In this regard, lobe 1 includes row 213 of the index table having a ' key, and lobe 2 includes rows 215-223 of the index table having ' b ' and ' c ' keys.
Fragmentation of the index table by its keys may result in the keys corresponding to a single data table row being scattered across multiple portions of the distributed storage system. For example, as shown in FIG. 3B, lobe 1 of index table 203 includes row 213 having key 'a' that indexes data 'a' of the data in the data table row (row 210) identified by identifier key '1'. Lobe 2 includes rows 215 and 221 with keys 'b' and 'c', respectively, which index data 'b' and 'c', i.e., the remaining data in the data table row (row 210) identified by identifier key '1'. Each data split may be stored in a different portion of the distributed storage system. For example, split 1 may be stored in a first portion of the distributed storage system, while split 2 may be stored in a second portion of the distributed storage system.
The sharding of an index table may be based on the identifier key of the data table and/or another index table, as opposed to sharding by the key of the index table. Sharding an index table based on an identifier key of the data table and/or another index table may be referred to as co-sharding. By co-sharding the rows of the index table corresponding to the identifier keys of the data table, all index entries in the data table corresponding to the same row in the data table may be arranged within the same shard. For example, as shown in FIG. 4A, the index table may be split into two splits based on the identifier key of the data table 201: lobe 1 and lobe 2. In this regard, the row of keys in the index table having data '1' (including rows 213, 215, and 221, which indicate identifier keys corresponding to row 210 of the data table (not shown)) is fragmented into split 1. The rows of keys in the index table with data '2' (including rows 217 and 223, which indicate identifier keys corresponding to row 212 of the data table) and the row of keys with data '3' (including row 219, which indicates identifier keys corresponding to row 214 of the data table) are fragmented into fragment 2.
As shown in fig. 4B, split 1 of index table 203 includes rows with keys 'a' 213, 'B' 215, and 'c' 221 that index all of the data in data table row 210 identified by identifier key '1'. Lobe 2 of index table 203 includes rows with keys 'b' 217, 'c' 223, and 'b' 219, which index all data in the data table rows (212 and 214) identified by identifier keys '2' and '3'. Each data split may be stored in a different portion of the distributed storage system.
In some instances, a data table (or another index table) may be sharded along with the index table. In this regard, rows from the data table may be sliced along with one or more index table rows corresponding to them. In other words, data from one or more indices of the data table may be sliced along with the data table itself. For example, row 210 of data table 201 identified by ID '1' may be fragmented into lobe 1, and rows 212 and 214 of data table 201 identified by ID '2' and '3', respectively, may be fragmented into lobe 2, as further illustrated in FIG. 4B. It is optional to fragment the data table together with its corresponding index table (i.e., the index table that indexes the data of the data table); the corresponding index tables may be sharded together.
Fragmenting the index table into multiple fragments by the keys of the index table may allow more than one server (such as servers of data centers 160, 170, and/or 180) or other computing devices to retrieve, search, and/or access the index table at the same time. This may reduce the load that would otherwise be placed on a single server and reduce the amount of processing time.
For large indices, the index table may be fragmented into splits, such that multiple distributed operations may be required to retrieve non-duplicate result sets from the splits. For example, as shown in FIG. 5, the index table 203 is partitioned into two splits by the index table's keys: lobe 1 and lobe 2. The splits may be searched for keys corresponding to index entries of the data. For example, the search may include a search for the text "a b c". A server, such as server 60, may determine from the data associated with the keys in split 2 that the row of data table 201 (not shown) identified with ID '1' and '2' includes data "b c" and ID '3' includes data "b", as shown in block 512. Another server (such as server 170) may determine from the data associated with the key in split 1 that the row of table 201 identified with ID '1' includes "b". However, since server 160 does not know the contents of lobe 1 and server 170 does not know the contents of lobe 2, additional distributed operations may be performed, as shown in block 514, such as a 'connect' operation. The distributed operation may combine the results output by servers 160 and 170, as shown in block 516. Based on the combined results, the one or more servers or another computing device may determine that the data associated with ID '1' satisfies the search request, as shown at block 518.
Fragmenting the index table based on the keys of another data table and/or the index table may reduce the number and expense of distributed operations required to retrieve, search, and/or access the index table. For example, as shown in FIG. 6, index table 203 is sliced based on keys of data table 201 (not shown). A search request may be made for a key corresponding to an index entry containing data for the text "a b c". A server (such as server 160) may determine that the key in split 1 associated with the data in the row of data table 201 identified by ID '1' satisfies the search criteria, as shown in block 610. Another server (such as server 170 and/or 180) may determine that the key in split 2 associated with the data in the row of data table 201 identified by ID '2' and '3' does not satisfy the search criteria. Since the server searching for the key corresponding to the index entry for data containing the text "a b c" in lobe 2 knows that all data corresponding to IDs '2' and '3' are in lobe 2, the server may determine that IDs '2' and '3' do not satisfy the search criteria if a complete result set is not found. The results of the server's search may be merged together and only the IDs that meet the search criteria (e.g., ID ' 1 ') may be output, as shown at block 618. All data in a row of a data table is indexed in the same split by sharding an index table based on keys of another data table and/or index table. In this way, the number of distributed operations to search the entire index table can be reduced.
Another aspect of the technique relates to co-sharding index tables by random keys assigned to data tables or other index tables to reduce hot spots. In this regard, when the identifier key of the data table monotonically increases (such as in instances where the ID corresponds to a timestamp or the identifier monotonically decreases), new incoming data may be directed to a single server, as the assigned identifiers may all be within the key range of a single server. Thus, a single server may be burdened with processing tasks while other servers remain underutilized or unutilized. A similar burden may be placed on a single server when simultaneously requesting data within a particular range of key values.
To address this problem, the identifier values may be randomized. In this regard, a random number generator may be used to generate numbers that fall within two or more keys. These random numbers may be assigned to data when entered into the distributed storage system as an identifier key (ID) in a data table. By assigning identifiers within the scope of the keys, processing tasks may be distributed among multiple servers. For example, as shown in FIG. 7, a first server 710 may have a key range of 1-10, while a second server 712 may have a key range of 11-20. The data within data table 701 may be received by a distributed storage system, and a processor, such as controller 190 (not shown), may assign a portion of the data to a server for processing based on the ID of the data. For example, data associated with ID 1 may be assigned to the first server 710 because 1 falls within the key range 1-10 of the first server. Data associated with ID 3 may also be assigned to the first server 710. Because IDs 14 and 12 fall within the key range of 11-20, data associated with IDs 14 and 12 may also be assigned to second server 712. Although FIG. 7 illustrates two key ranges, any number of key ranges is possible. In addition, the random numbers may not be limited to any particular key range, but may be randomly generated such that they are well distributed over a larger integer space (such as the entire integer 64-bit space).
The data in the data table 801 that is present may be indexed into an index table having a plurality of keys per row. For example, data associated with ID 1, Time1 in data table 801 of FIG. 8 is indexed into keys 'a, Time 1', 'b, Time 1' and 'c of index table 803, rows 813, 815 and 823 of Time 1', respectively. The data associated with ID 14, Time2 may be indexed into rows 817 and 825 of keys 'b, Time 2' and 'c, Time 2', respectively. The data associated with ID 12, Time3 may be indexed into line 819 of key 'b, Time 3', and the data associated with ID 3, Time4 may be indexed into line 821 of key 'b, Time 4'. The data associated with each key in the index table may correspond to data indicating an identifier key of the data table in which the data indexed into the key of the index table is located.
The indices may be co-sliced by random identifier keys assigned to the data table 801. For example, as shown in fig. 9, rows corresponding to keys 'a', 'b', and 'c' having data corresponding to ID 1 of table 801 may be fragmented into split 1, and rows corresponding to keys 'b' and 'c' having data corresponding to IDs 3, 14, and 12 may be fragmented into split 2.
In some instances, each split may be arranged in a particular order, such as by an identifier key or a timestamp value. For example, as further shown in FIG. 9, the rows of splits may be arranged by a "time" identifier key stored in the index table data and corresponding to a timestamp of the data in the data table 801.
By arranging the rows of the split data in order, retrieving, searching, and/or accessing various portions of the index table may be performed faster, as only a portion of the split may need to be traversed. For example, if a key in index table 803 having data associated with "Time 2" is queried, the distributed storage system may stop traversing the second split after reaching the row corresponding to key 'b' and having Time "Time 3" because keys having data associated with Time2 are grouped together. Similarly, the distributed storage system may traverse the row corresponding to key 'c', stopping once no more entries are found or another Time (e.g., Time3) is reached.
FIG. 10 illustrates a flow diagram 1000 of a method for co-sharding tables within a distributed storage system. In this regard, in block 1002, one or more processors (such as processor 120) may receive a data table comprising one or more rows, wherein each row comprises an identifier key and a data segment. As shown at block 1004, each data segment in the data table may be indexed into a separate row of the index table, where each row in the index table includes data associated with an identifier key of the data table from which the data segment in the respective row is indexed. As shown at block 1006, the index table may be partitioned into splits, where the partitioning includes assigning each row of the index table to one of the splits based on an identifier key of the data table from which the data segment in the corresponding row is indexed. The split may be stored into two or more portions of the distributed storage system, as shown at block 1008.
The features described herein allow for improved retrieval speed of data dispersed in the splinters. In this regard, time-consuming join operations may be performed locally by splitting the index into splits by source, so that all data corresponding to one source is found in a single split. The features described herein also avoid the formation of hot spots on a particular server during the entry and retrieval of data while maintaining the required ordering order on disk.
Unless otherwise specified, the foregoing alternative examples are not mutually exclusive and may be implemented in various combinations to achieve unique advantages. As these and other variations and combinations of the features discussed above can be utilized without departing from the subject matter defined by the claims, the foregoing description of the embodiments should be taken by way of illustration rather than by way of limitation of the subject matter defined by the claims. In addition, the provision of examples described herein, as well as the use of phrases such as "such as," "including," and the like, should not be construed to limit claimed subject matter to the specific examples; rather, these examples are intended to illustrate only one of many possible embodiments. Further, the same reference numbers in different drawings may identify the same or similar elements.
Claims (20)
1. A method for co-sharding a table within a distributed storage system, the method comprising:
receiving, by one or more processors, a data table comprising one or more rows, wherein each row comprises an identifier key and a data segment;
indexing, by the one or more processors, each data segment in the data table into a separate row of an index table, wherein each row in the index table comprises data associated with the identifier key of the data table from which the data segment in the respective row is indexed;
fragmenting, by the one or more processors, the index table into fragments, wherein the fragmenting comprises: assigning each row of the index table into one of the splits based on the identifier key of the data table from which the data segment in the respective row is indexed; and
storing, by the one or more processors, the split into two or more portions of the distributed storage system.
2. The method of claim 1, further comprising: sharding the one or more rows from the data table with the one or more index table rows to which the data segments of the respective row of the data table are indexed.
3. The method of claim 2, wherein the one or more rows from the data table are stored in the same split as the one or more index table rows to which the data segments of the respective row of the data table are indexed.
4. The method of claim 1, wherein the data in the data table is in one or more columns of the data table.
5. The method of claim 1, wherein the identifier key comprises a randomly generated number, and
the splits are ordered by timestamp.
6. The method of claim 1, wherein the identifier key comprises a timestamp, and
the splits are ordered by the timestamps.
7. The method of claim 1, wherein the identifier key comprises a monotonically increasing or decreasing value, and
the splits are ordered by the monotonically increasing or decreasing value.
8. The method of claim 1, wherein storing the split into two or more portions of the distributed storage system comprises: storing a first split into a first portion of two or more portions of the distributed storage system and a second split into a second portion of the two or more portions of the distributed storage system.
9. The method of claim 8, further comprising:
receiving a request to retrieve one or more keys associated with the indexed data segment;
in response to receiving the request, identifying, by a first server of the distributed data system, the one or more keys associated with the indexed data segment in the first split, and identifying, by a second server of the distributed data system, the one or more keys associated with the indexed data segment in the second split;
merging the keys identified from the first split and the second split;
and outputting the merged key through the distributed data system.
10. The method of claim 1, wherein, in a relational online database stored in the distributed storage system, each row in the data table is transactionally indexed into the index table.
11. A system for co-sharding a table, the system comprising:
a distributed storage system; and
one or more processors, wherein the one or more processors are configured to:
receiving a data table comprising one or more rows, wherein each row comprises an identifier key and a data segment;
indexing each data segment in the data table into a separate row of an index table, wherein each row in the index table includes data associated with the identifier key of the data table from which the data segment in the respective row is indexed;
fragmenting the index table into fragments, wherein the fragmenting comprises: assigning each row of the index table into one of the splits based on the identifier key of the data table from which the data segment in the respective row is indexed; and
storing the split into two or more portions of the distributed storage system.
12. The system of claim 11, wherein the one or more processors are further configured to: sharding the one or more rows from the data table with the one or more index table rows to which the data segments of the respective row of the data table are indexed.
13. The system of claim 12, wherein the one or more rows from the data table are stored in the same split as the one or more index table rows to which the data segments of the respective row of the data table are indexed.
14. The system of claim 11, wherein the data in the data table is in one or more columns of the data table.
15. The system of claim 11, wherein the identifier key comprises a randomly generated number, and
the splits are ordered by timestamp.
16. The system of claim 11, wherein the identifier key comprises a timestamp, and
the splits are ordered by the timestamps.
17. The system of claim 11, wherein storing the split into two or more portions of the distributed storage system comprises: storing a first split into a first portion of two or more portions of the distributed storage system and a second split into a second portion of the two or more portions of the distributed storage system.
18. The system of claim 17, wherein, in response to receiving the request to retrieve one or more keys associated with the indexed data segment, the one or more keys associated with the indexed data segment are identified in the first split by a first server of the distributed data system, and the one or more keys associated with the indexed data segment are identified in the second split by a second server of the distributed data system;
merging the keys identified from the first split and the second split;
and outputting the merged key through the distributed data system.
19. The system of claim 11, wherein each row in the data table is transactionally indexed into the index table in a relational online database stored in the distributed storage system.
20. A non-transitory computer-readable medium storing instructions that, when executed by one or more processors, cause the one or more processors to:
receiving a data table comprising one or more rows and a plurality of columns, wherein each row corresponding to a first column of the plurality of columns comprises an identifier key and a second column and a third column of the plurality of columns each comprise a data segment;
indexing each data segment in the second column in the data table into a separate row and column of a first index table, wherein each row in the index table includes data associated with the identifier key of the data table from which the data segment in the respective row is indexed;
indexing each data segment in the third column in the data table into a separate row and column of a second index table, wherein each row in the index table includes data associated with the identifier key of the data table from which the data segment in the respective row is indexed;
fragmenting the first index table and the second index into fragments, wherein the fragmenting comprises: assigning each row of the first index table and the second index table into one of the splits based on the identifier key of the data table from which the data segment in the respective row is indexed; and
storing the split into two or more portions of a distributed storage system.
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201962821156P | 2019-03-20 | 2019-03-20 | |
US62/821,156 | 2019-03-20 | ||
PCT/US2020/023330 WO2020191029A1 (en) | 2019-03-20 | 2020-03-18 | Cosharding and randomized cosharding |
Publications (1)
Publication Number | Publication Date |
---|---|
CN112805695A true CN112805695A (en) | 2021-05-14 |
Family
ID=70224420
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN202080005621.2A Pending CN112805695A (en) | 2019-03-20 | 2020-03-18 | Co-sharding and randomized co-sharding |
Country Status (5)
Country | Link |
---|---|
US (2) | US11561953B2 (en) |
EP (1) | EP3861458A1 (en) |
KR (1) | KR20210066004A (en) |
CN (1) | CN112805695A (en) |
WO (1) | WO2020191029A1 (en) |
Families Citing this family (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
KR102030785B1 (en) * | 2019-04-26 | 2019-10-10 | 주식회사그린존시큐리티 | An apparatus for obfuscating data of IoT devices using pseudorandom number and a method therefor |
US20210342317A1 (en) * | 2020-04-29 | 2021-11-04 | Oracle International Corporation | Techniques for efficient migration of key-value data |
Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20120084316A1 (en) * | 2010-10-05 | 2012-04-05 | International Business Machines Corporation | Database-transparent near online archiving and retrieval of data |
US20140108421A1 (en) * | 2012-10-04 | 2014-04-17 | Codefutures Corporation | Partitioning database data in a sharded database |
CN107506464A (en) * | 2017-08-30 | 2017-12-22 | 武汉烽火众智数字技术有限责任公司 | A kind of method that HBase secondary indexs are realized based on ES |
Family Cites Families (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US7249118B2 (en) * | 2002-05-17 | 2007-07-24 | Aleri, Inc. | Database system and methods |
US9774676B2 (en) | 2012-05-21 | 2017-09-26 | Google Inc. | Storing and moving data in a distributed storage system |
US9483568B1 (en) | 2013-06-05 | 2016-11-01 | Google Inc. | Indexing system |
WO2018170276A2 (en) * | 2017-03-15 | 2018-09-20 | Fauna, Inc. | Methods and systems for a database |
-
2020
- 2020-03-18 US US17/296,441 patent/US11561953B2/en active Active
- 2020-03-18 EP EP20717741.1A patent/EP3861458A1/en active Pending
- 2020-03-18 KR KR1020217013584A patent/KR20210066004A/en not_active Application Discontinuation
- 2020-03-18 CN CN202080005621.2A patent/CN112805695A/en active Pending
- 2020-03-18 WO PCT/US2020/023330 patent/WO2020191029A1/en unknown
-
2023
- 2023-10-03 US US18/376,255 patent/US20240037085A1/en active Pending
Patent Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20120084316A1 (en) * | 2010-10-05 | 2012-04-05 | International Business Machines Corporation | Database-transparent near online archiving and retrieval of data |
US20140108421A1 (en) * | 2012-10-04 | 2014-04-17 | Codefutures Corporation | Partitioning database data in a sharded database |
CN107506464A (en) * | 2017-08-30 | 2017-12-22 | 武汉烽火众智数字技术有限责任公司 | A kind of method that HBase secondary indexs are realized based on ES |
Non-Patent Citations (1)
Title |
---|
XIAOMING GAO: "Investigation and Comparison of Distributed NoSQL Database Systems", 《HTTPS://WWW.SEMANTICSCHOLAR.ORG/PAPER/INVESTIGATION-AND-COMPARISON-OF-DISTRIBUTED-NOSQL-GAO/54459B8DAC8795A2E15A2B9A68802803DEE95841?P2DF》, 29 August 2017 (2017-08-29), pages 1 - 14 * |
Also Published As
Publication number | Publication date |
---|---|
KR20210066004A (en) | 2021-06-04 |
EP3861458A1 (en) | 2021-08-11 |
US20220019568A1 (en) | 2022-01-20 |
WO2020191029A1 (en) | 2020-09-24 |
US11561953B2 (en) | 2023-01-24 |
US20240037085A1 (en) | 2024-02-01 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
CN108256076B (en) | Distributed mass data processing method and device | |
US9317536B2 (en) | System and methods for mapping and searching objects in multidimensional space | |
US7617265B2 (en) | Indexing method of database management system | |
US11816086B2 (en) | Cosharding and randomized cosharding | |
US20160350302A1 (en) | Dynamically splitting a range of a node in a distributed hash table | |
US20240037085A1 (en) | Cosharding and Randomized Cosharding | |
EP2637111A1 (en) | Data management system and method using database middleware | |
US10877810B2 (en) | Object storage system with metadata operation priority processing | |
JP2021500649A (en) | Computer implementation methods, computer program products, and systems for storing records in shard database shard tables, computer implementation methods, computer program products, and systems for retrieving records from shard database shard tables. System, as well as a system for storing shard databases | |
US11093446B2 (en) | Duplicate request checking for file system interfaces | |
US10515078B2 (en) | Database management apparatus, database management method, and storage medium | |
JP2014232483A (en) | Database system, retrieval method and program | |
US9734177B2 (en) | Index merge ordering | |
JP5858307B2 (en) | Database management system, computer, database management method | |
JP6168635B2 (en) | Database management system, computer, database management method | |
CN111886592A (en) | Method and system for performing inlining on a fragmented data set | |
US11188532B2 (en) | Successive database record filtering on disparate database types | |
CN113632073B (en) | Scalable streaming over data sources | |
CN116848517A (en) | Cache indexing using data addresses based on data fingerprints | |
US9870152B2 (en) | Management system and management method for managing data units constituting schemas of a database | |
JP6108418B2 (en) | Database management system, computer, database management method | |
Bin et al. | An efficient distributed B-tree index method in cloud computing | |
CN113127717A (en) | Key retrieval method and system | |
Chang et al. | Resilient distributed computing platforms for big data analysis using Spark and Hadoop | |
KR102571783B1 (en) | Search processing system performing high-volume search processing and control method thereof |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
SE01 | Entry into force of request for substantive examination |