CN117643050A - Reference motion vector candidate library - Google Patents
Reference motion vector candidate library Download PDFInfo
- Publication number
- CN117643050A CN117643050A CN202180100419.2A CN202180100419A CN117643050A CN 117643050 A CN117643050 A CN 117643050A CN 202180100419 A CN202180100419 A CN 202180100419A CN 117643050 A CN117643050 A CN 117643050A
- Authority
- CN
- China
- Prior art keywords
- block
- buffer
- reference frame
- frame
- candidate
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
- 239000013598 vector Substances 0.000 title claims abstract description 90
- 239000000872 buffer Substances 0.000 claims abstract description 188
- 238000000034 method Methods 0.000 claims abstract description 130
- 238000012545 processing Methods 0.000 claims abstract description 121
- 230000004044 response Effects 0.000 claims abstract description 18
- 238000005192 partition Methods 0.000 claims description 19
- 239000002131 composite material Substances 0.000 claims description 15
- 238000000638 solvent extraction Methods 0.000 claims description 7
- 230000015654 memory Effects 0.000 description 32
- 238000010586 diagram Methods 0.000 description 21
- 238000004891 communication Methods 0.000 description 9
- 238000001914 filtration Methods 0.000 description 7
- 230000008569 process Effects 0.000 description 6
- 230000006835 compression Effects 0.000 description 5
- 238000007906 compression Methods 0.000 description 5
- 238000013139 quantization Methods 0.000 description 5
- 238000007796 conventional method Methods 0.000 description 4
- 230000006870 function Effects 0.000 description 4
- 230000003287 optical effect Effects 0.000 description 3
- 230000002123 temporal effect Effects 0.000 description 3
- 208000037170 Delayed Emergence from Anesthesia Diseases 0.000 description 2
- 230000005540 biological transmission Effects 0.000 description 2
- 238000004590 computer program Methods 0.000 description 2
- 238000013461 design Methods 0.000 description 2
- 238000006073 displacement reaction Methods 0.000 description 2
- 238000005516 engineering process Methods 0.000 description 2
- 239000012634 fragment Substances 0.000 description 2
- 238000012986 modification Methods 0.000 description 2
- 230000004048 modification Effects 0.000 description 2
- 238000013519 translation Methods 0.000 description 2
- 230000003139 buffering effect Effects 0.000 description 1
- 230000001413 cellular effect Effects 0.000 description 1
- 230000008859 change Effects 0.000 description 1
- 239000003086 colorant Substances 0.000 description 1
- 230000008867 communication pathway Effects 0.000 description 1
- 150000001875 compounds Chemical class 0.000 description 1
- 230000008878 coupling Effects 0.000 description 1
- 238000010168 coupling process Methods 0.000 description 1
- 238000005859 coupling reaction Methods 0.000 description 1
- 230000006837 decompression Effects 0.000 description 1
- 238000002474 experimental method Methods 0.000 description 1
- 239000004973 liquid crystal related substance Substances 0.000 description 1
- 230000007774 longterm Effects 0.000 description 1
- 238000005259 measurement Methods 0.000 description 1
- 239000004065 semiconductor Substances 0.000 description 1
- 238000012546 transfer Methods 0.000 description 1
- 230000009466 transformation Effects 0.000 description 1
- 230000001131 transforming effect Effects 0.000 description 1
Classifications
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/50—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding
- H04N19/503—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding involving temporal prediction
- H04N19/51—Motion estimation or motion compensation
- H04N19/513—Processing of motion vectors
- H04N19/517—Processing of motion vectors by encoding
- H04N19/52—Processing of motion vectors by encoding by predictive encoding
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/50—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding
- H04N19/503—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding involving temporal prediction
- H04N19/51—Motion estimation or motion compensation
- H04N19/58—Motion compensation with long-term prediction, i.e. the reference frame for a current frame not being the temporally closest one
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/169—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding
- H04N19/17—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding the unit being an image region, e.g. an object
- H04N19/174—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding the unit being an image region, e.g. an object the region being a slice, e.g. a line of blocks or a group of blocks
Abstract
A method for inter prediction, comprising: code processing a first block of the current frame using a first Motion Vector (MV) and a reference frame type; storing the first MV and the reference frame type in at least one MV buffer; identifying MV candidates for code processing of the current block using a reference frame type; in response to determining that the cardinality of MV candidates is less than the maximum number of MV candidates: identifying a first motion vector in at least one MV buffer; and in response to determining that the first MV is not included in the MV candidates, adding the first MV as a MV candidate; and selecting one of the MV candidates for code processing of the current block.
Description
Background
The digital video stream may represent video using a series of frames or still images. Digital video can be used for a variety of applications including, for example, video conferencing, high definition video entertainment, video advertising, or sharing user-generated video. Digital video streams can contain large amounts of data and consume large amounts of computing or communication resources of a computing device in order to process, transmit, or store video data. Various methods have been proposed to reduce the amount of data in video streams, including compression techniques and other coding techniques.
Disclosure of Invention
The present disclosure relates generally to encoding and decoding of video data, and more particularly to encoding and decoding blocks of video frames using a reference motion vector candidate bank (candidate bank).
A first aspect is a method for inter prediction. The method comprises the following steps: performing code processing (coding) on a first block of the current frame using a first Motion Vector (MV) and a reference frame type; storing the first MV and the reference frame type in at least one MV buffer; identifying MV candidates for code processing of the current block using a reference frame type; in response to determining that the cardinality of MV candidates is less than the maximum number of MV candidates: identifying a first motion vector in at least one MV buffer; and in response to determining that the first MV is not included in the MV candidates, adding the first MV as a MV candidate; and selecting one of the MV candidates for code processing of the current block.
A second aspect is an apparatus for inter prediction. The device comprises: a processor configured to: obtaining partition division (partitioning) of the current frame into super blocks, the super blocks being arranged into rows of super blocks; initializing row MV banks, wherein each row MV bank is associated with one or more rows of the superblock and one or more reference frame types; encoding a first block of a first super block of the super block using a first Motion Vector (MV) and a reference frame type, wherein the first block is in a row of the super block; storing the first MV in a row MV bank associated with a row of the super block and a reference frame type; obtaining MV candidates for code-processing a second block of a second super block using the reference frame type; and identifying additional MV candidates for code processing of the second block using a row MV bank associated with the row of the super block and the reference frame type on condition that the cardinality of the MV candidates is less than the maximum number of MV candidates.
A third aspect is a method for decoding a current block of a current frame. The method comprises the following steps: storing a first Motion Vector (MV) of a first block decoded before a current block in a row MV bank associated with a row of a super block including the first block and the current block; obtaining a candidate MV for decoding the current block, wherein the candidate MV is stored in slots (slots) of a candidate MV list, and a cardinality of the candidate MV is smaller than a size of the candidate MV list; adding the first additional MV candidate to the candidate MV list using the row MV bank; and decoding the current block using the candidate MVs of the candidate MV list.
These and other aspects of the disclosure are disclosed in the following detailed description, appended claims and drawings.
Drawings
The description herein makes reference to the accompanying drawings wherein like reference numerals refer to like parts throughout the several views.
Fig. 1 is a schematic diagram of a video encoding and decoding system.
Fig. 2 is a block diagram of an example of a computing device capable of implementing a sending station or a receiving station.
Fig. 3 is a schematic diagram of a typical video stream to be encoded and subsequently decoded.
Fig. 4 is a block diagram of an encoder according to an embodiment of the present disclosure.
Fig. 5 is a block diagram of a decoder according to an embodiment of the present disclosure.
Fig. 6 is a block diagram of an example of a reference frame buffer.
Fig. 7A is a schematic diagram of an example of a multi-layer code processing structure.
Fig. 7B is a schematic diagram of an example of a one-layer code processing structure.
Fig. 8 is a schematic diagram of an example of a search area of candidate motion vectors.
Fig. 9 is a flow chart of an inter prediction technique.
Fig. 10 is a schematic diagram of an example of a motion vector library.
Fig. 11 is a flow chart of a technique of adding motion vectors to a motion vector buffer.
Fig. 12 illustrates a scene in which a motion vector is added to a motion vector buffer.
Fig. 13 illustrates an example of adding a candidate motion vector to a list of candidate motion vectors from a motion vector buffer.
Fig. 14 is a flow chart of a technique for obtaining motion vector candidates.
Fig. 15 is a flow chart of a technique for decoding a current block.
Detailed Description
Compression schemes related to encoding (coding) video content (e.g., video streams, video files, etc.) may include decomposing each image into blocks and generating a digital video output bitstream using one or more techniques to limit the information included in the output. The received bit stream can be decoded to recreate the block and source images from the limited information. Encoding a video stream or a portion thereof, such as a frame or block, can include using temporal and spatial similarities in the video stream to improve code processing efficiency. For example, a current block of a video stream may be encoded based on a previously encoded block in the video stream by predicting motion and color information of the current block based on the previously encoded block and identifying a difference (residual) between a prediction value and the current block. In this way, only the residual and the parameters used to generate the residual need be added to the bitstream, rather than including the entirety of the current block. This technique may be referred to as inter prediction.
One of the parameters in inter prediction is a Motion Vector (MV), which represents the spatial displacement of a previously coded block relative to the current block. MV can be identified using motion estimation methods (e.g., motion search). In motion search, a portion of a reference frame can be translated to a series of positions to form a prediction block, which can be subtracted from a portion of a current frame to form a series of residuals. The horizontal translation and the vertical translation corresponding to the position with the smallest residual can be selected as MV. Bits representing MVs can be included in the encoded bitstream to allow a decoder to replicate the prediction block and decode portions of the encoded video bitstream associated with the MVs.
For video compression schemes, the code processing of MVs typically consumes a significant proportion of the overall bit rate, especially for video streams encoded at lower data rates or higher compression ratios. In order to improve coding efficiency, MVs can be differentially encoded using reference MVs. That is, only the difference (residual) between the MV and the reference MV is encoded. In some cases, a reference MV can be selected from MVs previously used in the video stream, e.g., the last non-zero MV from a neighboring block. Selecting a previously used MV to encode the current MV (i.e., the MV of the current block being encoded) can further reduce the number of bits included in the encoded video bitstream, thereby reducing the bandwidth requirements for transmission and storage. The motion vector reference mode allows the code processing block to infer motion information from neighboring blocks previously coded.
The reference MV can be selected from a list of candidate reference MVs (also referred to as MV candidates). Different techniques have been developed for obtaining (e.g., selecting, choosing, determining, etc.) MV candidate lists from previously coded neighboring blocks. Illustrative techniques for obtaining MV candidates are described herein. However, the present disclosure is not limited to any particular technique for obtaining a list of candidate reference MVs.
For example, h.265/HEVC uses Advanced Motion Vector Prediction (AMVP) to construct MV candidate lists. To illustrate, in h.265, a list of candidate reference motion vectors is obtained using a two-pass encoding technique. In the first encoding, the codec checks whether any specified neighboring block contains (e.g., uses, etc.) a reference frame index equal to the reference frame index of the current block being encoded. The first motion vector found can be regarded as MV candidate. In a second encoding that may not be used, a scaling factor can be used to scale the motion vector of one or more specified neighboring blocks. The scaling factor can be calculated based on a first temporal distance between a current frame including a current block to be code-processed and a reference frame of a candidate neighboring block and a second temporal distance between the current frame and the reference frame of the current block.
In another example, such as in AV1, MV candidates can include motion vectors from previously coded (encoded or decoded) blocks in the video stream, such as blocks (e.g., mode units) from previously coded (or decoded) frames, or previously encoded (or decoded) blocks from the same frame. The candidate reference blocks may include co-located blocks (of the current block) in the reference frame and their surrounding blocks. For example, the surrounding blocks can include blocks to the right, lower left, lower right, or lower below the blocks in the same location. Thus, the search area of the previously encoded processing block is limited. One or more candidate reference frames can be used, including single reference frames and composite reference frames.
In an example, a candidate MV can be selected from candidate reference motion vectors based on a distance between the reference block and the current block and a popularity of the reference motion vector. For example, the distance between the reference block and the current block can be based on the spatial displacement between the pixels in the previously coded block and the co-located pixels in the current block, which is measured in pixels. For example, the popularity of a motion vector can be based on the number of previously coded pixels using the motion vector. The more previously coded pixels that use a motion vector, the higher the probability of the motion vector. In one example, the popularity value is the number of previously coded pixels that use the motion vector. In another example, the prevalence value is a percentage of previously coded pixels within an area using motion vectors.
The prediction mode used to encode the current block can also be encoded and transmitted, so the decoder can use the same prediction mode in the decoding and reconstruction process to form the prediction block. In the case of inter prediction, a prediction mode may be selected from among a plurality of inter prediction modes using one or more reference frames. The current block may be encoded using a single reference frame prediction mode (which may be referred to as single reference prediction) or a composite reference frame prediction mode (which may be referred to as composite reference prediction) using one corresponding motion vector. For ease of reference, MVs as used herein (unless the context clearly indicates otherwise) may be used to represent one motion vector (such as in the case of a single reference frame) as well as two motion vectors (such as in the case of a composite reference frame), as the distinction between one and two reference frames is not necessary to understand the present disclosure. The reference frames available for code processing of the current block may be obtained in a reference frame buffer (e.g., stored therein, etc.). An example of a reference frame buffer is described with respect to fig. 6.
In an example, up to seven reference frames may be available for code processing of a block using a single reference frame prediction mode or a composite reference frame prediction mode. For the composite reference frame prediction mode, a combination of reference frames may be used. In an example, any two reference frames may be used in the composite reference frame prediction mode. Thus, any combination (e.g., 28 possible combinations) of two of the seven available reference frames (e.g., C (7, 2)) may be used. In another example, only a subset of all possible combinations may be active (e.g., for code processing the current block).
In an example, the bitstream syntax may support three types of inter prediction modes. The inter prediction modes can include, for example: a mode (sometimes referred to as a ZERO MV mode) in which a block from the same position within the reference frame as the current block is used as a prediction block; a mode (sometimes referred to as a new_mv mode) of transmitting a motion vector to indicate a position of a block to be used as a prediction block with respect to a current block within a reference frame; or no motion vector is sent and the current block uses the last or penultimate non-zero motion vector used by the neighboring previously coded block to generate a mode of the predicted block (sometimes referred to as ref_mv mode, including near_mv or near_mv mode). Inter prediction modes may be used with any available reference frame. Near_mv and near_mv can indicate which set of neighboring blocks (i.e., unit of pixels) to use to obtain the reference motion vector. For example, the NEAR MV can indicate a pixel unit closer to the current block than a pixel unit indicated by the NEAR MV. The pixel cell is illustrated with reference to fig. 8.
As a summary, in some examples, for an inter-coded (inter-coded) current block, a list of candidate MVs can be generated, which typically consist of MVs of nearby blocks (e.g., unit modes) that use the same reference frame as the current block or scaled MVs of nearby blocks that do not use the same reference frame as the current block. One MV in the list can be selected as a reference MV for code processing of a block. The reference MV can be used directly for inter prediction (such as in the case of NEAR MV or NEAR MV mode). Otherwise, the difference can be applied to the reference MVs to form the final MVs (such as in the case of new_mv mode). The reference MV candidate list can be generated by scanning spatially and temporally adjacent coded blocks of the current block and retrieving MVs corresponding to the same reference frame used by the current block. The scan range (for spatial neighbors) is limited to a number of pixel cells (e.g., 5 pixel cells, with 4 pixels per cell) above and to the left of the current block.
The MV candidate list has a fixed size. Each identified MV candidate occupies a corresponding position (e.g., slot, etc.) in the MV candidate list. In some cases, the number of identified candidate MVs (e.g., cardinality, etc.) may be less than the number of slots of the candidate reference motion vector list.
A limitation of conventional techniques for obtaining candidate MVs, such as those described above, is that MVs of blocks further away from the current block (referred to herein as far blocks) are not utilized, such as due to limitations on the scan range. A scan range refers to a set of blocks or pixel units that are typically used to obtain candidate MVs.
Additional reference MV candidates can be provided according to embodiments of the present disclosure. When a block is encoded, an MV buffer can be used to store MVs of the block. When the current block is code processed, the buffer can be used to identify additional candidate MVs in case more slots are still available in the candidate MV list after the candidate MVs are identified using conventional scanning techniques. Additional candidate MVs can be identified using MVs of far blocks relative to the current block. Far blocks refer to blocks (e.g., unit modes) that are not searched in a conventional manner (i.e., outside of the search range) to identify candidate MVs for the current block.
In an example, after the block is coded, the MV buffers can be updated (e.g., one or more MVs can be added to the corresponding MV buffers). In an example, the MV buffer can be updated after all blocks of the super block including the block are encoded. Super blocks are blocks with the largest block size. In an example, the superblock can be 128×128 or 64×64 pixels. Super blocks may also be referred to as macro blocks. After performing conventional reference MV candidate generation (such as those described above), if there are open slots in the MV candidate list, the codec can refer (e.g., search, use, etc.) the MV candidate buffer for additional MV candidates according to embodiments of the present disclosure.
In an example, MV buffers can be distinguished into MV banks. As explained further below, several reference frame types may be available for code processing of blocks of a frame. The MV buffer can be an associated reference frame type. A reference MV candidate bank (or MV bank) refers to a set of MV buffers (e.g., a set of MV buffers), where the set can include MV buffers for each possible reference frame type. Experiments have shown that the reference motion vector candidate buffer (or library) is capable of producing a peak signal to noise ratio (PSNR) gain of over 0.5% relative to the AV1 baseline.
Further details of a reference motion vector candidate library are described herein by first referencing a system in which the reference motion vector candidate library can be implemented.
Fig. 1 is a schematic diagram of a video encoding and decoding system 100. The transmitting station 102 can be, for example, a computer having an internal configuration such as the hardware described in fig. 2. However, other suitable implementations of the sending station 102 are also possible. For example, the processing of the sending station 102 can be distributed across multiple devices.
The network 104 is capable of connecting a transmitting station 102 and a receiving station 106 for encoding and decoding of video streams. Specifically, the video stream can be encoded in the transmitting station 102 and the encoded video stream can be decoded in the receiving station 106. The network 104 can be, for example, the internet. The network 104 can also be a Local Area Network (LAN), wide Area Network (WAN), virtual Private Network (VPN), cellular telephone network, or any other means of transmitting a video stream from the sending station 102 to the receiving station 106 in this example.
In one example, the receiving station 106 can be a computer having an internal configuration such as the hardware depicted in fig. 2. However, other suitable implementations of the receiving station 106 are also possible. For example, the processing of the receiving station 106 can be distributed across multiple devices.
Other implementations of the video encoding and decoding system 100 are possible. For example, embodiments can omit the network 104. In another embodiment, the video stream can be encoded and then stored for later transmission to the receiving station 106 or any other device having memory. In one embodiment, the receiving station 106 receives (e.g., via the network 104, a computer bus, and/or some communication pathway) the encoded video stream and stores the video stream for later decoding. In an example embodiment, real-time transport protocol (RTP) is used to transport encoded video over network 104. In another embodiment, transport protocols other than RTP may be used, such as, for example, a hypertext transfer protocol (HTTP-based) video streaming protocol.
For example, when used in a video conferencing system, the sending station 102 and/or the receiving station 106 may include both the capabilities to encode and decode video streams as described below. For example, the receiving station 106 may be a video conference participant that receives the encoded video bitstream from a video conference server (e.g., the sending station 102) for decoding and viewing, and further encodes and transmits its own video bitstream to the video conference server for decoding and viewing by other participants.
Fig. 2 is a block diagram of an example of a computing device 200 (e.g., device) capable of implementing a sending station or a receiving station. For example, computing device 200 can implement one or both of transmitting station 102 and receiving station 106 of fig. 1. The computing device 200 can be in the form of a computing system including multiple computing devices, or one computing device, such as a mobile phone, tablet, laptop, notebook, desktop, or the like.
The CPU 202 in the computing device 200 can be a conventional central processing unit. Alternatively, the CPU 202 can be any other type of device or devices capable of operating or processing existing or later developed information. While the disclosed embodiments can be practiced using one processor (e.g., CPU 202) as shown, more than one processor can be used to realize advantages in terms of speed and efficiency.
The memory 204 in the computing device 200 can be a Read Only Memory (ROM) device or a Random Access Memory (RAM) device in an embodiment. Any other suitable type of storage device can be used as memory 204. The memory 204 can include code and data 206 accessed by the CPU 202 using the bus 212. The memory 204 can further include an operating system 208 and application programs 210, the application programs 210 including at least one program that allows the CPU 202 to perform the methods described herein. For example, the application 210 can include application 1 through application N, which further includes a video code processing application that performs the methods described herein. The computing device 200 can also include secondary storage 214, which can be, for example, a memory card for use with a mobile computing device. Because video communication sessions may contain a large amount of information, they can be stored in whole or in part in secondary storage 214 and loaded into memory 204 as needed for processing.
The computing device 200 can also include one or more output devices, such as a display 218. In one example, the display 218 may be a touch sensitive display that combines the display with a touch sensitive element operable to sense touch input. A display 218 can be coupled to the CPU 202 via the bus 212. In addition to or as an alternative to display 218, other output devices can be provided that allow a user to program computing device 200 or otherwise use computing device 200. When the output device is or includes a display, the display can be implemented in a variety of ways, including by a Liquid Crystal Display (LCD), a Cathode Ray Tube (CRT) display, or a Light Emitting Diode (LED) display, such as an Organic LED (OLED) display.
The computing device 200 can also include or be in communication with an image sensing apparatus 220, such as a camera, or any other image sensing device 220, now or later developed, capable of sensing images (e.g., images of a user operating the computing device 200). The image sensing device 220 can be positioned such that it is directed to a user operating the computing device 200. In an example, the position and optical axis of the image sensing device 220 can be configured such that the field of view includes an area directly adjacent to the display 218 and from which the display 218 is visible.
The computing device 200 can also include or communicate with a sound sensing means 222, such as a microphone, or any other sound sensing device now or later developed that can sense sound in the vicinity of the computing device 200. The sound sensing device 222 can be positioned such that it is directed to a user operating the computing device 200 and can be configured to receive sound (e.g., speech or other utterances) emitted by the user while the user is operating the computing device 200.
Although fig. 2 depicts the CPU 202 and memory 204 of the computing device 200 as being integrated in one unit, other configurations can be utilized. The operation of the CPU 202 can be distributed across multiple machines (where a single machine can have one or more processors) that can be directly coupled or across a local area network or other network. The memory 204 can be distributed across multiple machines, such as network-based memory or memory in multiple machines performing the operations of the computing device 200. Although depicted herein as one bus, the bus 212 of the computing device 200 can be comprised of multiple buses. Further, secondary storage 214 may be directly couplable to other components of computing device 200 or accessible via a network and may include an integrated unit such as a memory card or multiple units such as multiple memory cards. Accordingly, the computing device 200 can be implemented in a variety of configurations.
Fig. 3 is a schematic diagram of an example of a video stream 300 to be encoded and subsequently decoded. Video stream 300 includes video sequence 302. At the next level, the video sequence 302 includes a number of adjacent frames 304. When three frames are described as adjacent frames 304, the video sequence 302 can include any number of adjacent frames 304. Adjacent frames 304 can then be further subdivided into individual frames, such as frame 306. At the next level, the frame 306 can be divided into a series of planes or segments 308. The fragments 308 can be, for example, a subset of frames that allow parallel processing. Segment 308 can also be a subset of frames that can separate video data into separate colors. For example, a frame 306 of color video data can include one luminance plane and two chrominance planes. The segments 308 may be sampled at different resolutions.
Regardless of whether frame 306 is divided into segments 308, frame 306 may be further subdivided into blocks 310, with blocks 310, for example, containing data corresponding to 16 x 16 pixels in frame 306. The block 310 can also be arranged to include data from one or more segments 308 of pixel data. The block 310 can also be any other suitable size, such as 4 x 4 pixels, 8 x 8 pixels, 16 x 8 pixels, 8 x 16 pixels, 16 x 16 pixels, or larger. Unless otherwise indicated, the terms block and macroblock are used interchangeably herein.
Fig. 4 is a block diagram of an encoder 400 according to an embodiment of the present disclosure. As described above, the encoder 400 can be implemented in the sending station 102, such as by providing a computer software program stored in a memory (e.g., memory 204). The computer software program can include machine instructions that, when executed by a processor (such as CPU 202), cause the sending station 102 to encode video data in the manner described in fig. 4. Furthermore, the encoder 400 can be implemented as dedicated hardware included in, for example, the transmitting station 102. In a particularly preferred embodiment, encoder 400 is a hardware encoder.
The encoder 400 has the following stages for performing various functions in the forward path (shown by the solid line connection) to produce an encoded or compressed bitstream 420 using the video stream 300 as input: an intra/inter prediction stage 402, a transform stage 404, a quantization stage 406, and an entropy encoding stage 408. Encoder 400 may also include a reconstruction path (shown by dashed connecting lines) to reconstruct the frames used to encode the future blocks. In fig. 4, the encoder 400 has the following stages for performing various functions in the reconstruction path: a dequantization stage 410, an inverse transform stage 412, a reconstruction stage 414, and a loop filtering stage 416. Other structural variations of encoder 400 can be used to encode video stream 300.
When video stream 300 is provided for encoding, a corresponding frame 304 (such as frame 306) can be processed in units of blocks. In the intra/inter prediction stage 402, the corresponding block can be encoded using intra-frame prediction (also referred to as intra-prediction) or inter-frame prediction (also referred to as inter-prediction). In either case, a prediction block can be formed. In the case of intra prediction, a prediction block may be formed from samples in the current frame that have been previously encoded and reconstructed. In the case of inter prediction, the prediction block may be formed from samples in one or more reference frames previously constructed.
Next, still referring to fig. 4, the prediction block can be subtracted from the current block in an intra/inter prediction stage 402 to produce a residual block (also referred to as a residual). The transform stage 404 transforms the residual into transform coefficients, e.g., in the frequency domain, using a block-based transform. The quantization stage 406 uses the quantizer values or quantization levels to convert the transform coefficients into discrete quantization values called quantized transform coefficients. For example, the transform coefficients may be divided by the quantizer values and truncated (truncate). The quantized transform coefficients are then entropy encoded by an entropy encoding stage 408. The entropy encoded coefficients are then output to the compressed bitstream 420 along with other information for decoding the block (which may include, for example, the type of prediction used, the type of transform, the motion vectors, and the quantizer values). The compressed bitstream 420 can be formatted using various techniques, such as variable length code processing (VLC) or arithmetic code processing. The compressed bitstream 420 can also be referred to as an encoded video stream or an encoded video bitstream, and these terms will be used interchangeably herein.
The reconstruction path (shown by the dashed connection line) in fig. 4 can be used to ensure that the encoder 400 and decoder 500 (described below) decode the compressed bitstream 420 using the same reference frame. The reconstruction path performs functions similar to those that occur during the decoding process discussed in more detail below, including dequantizing quantized transform coefficients in dequantization stage 410 and inverse transforming dequantized transform coefficients in inverse transform stage 412 to produce a derived (derivative) residual block (also referred to as a derivative residual). In the reconstruction stage 414, the prediction block predicted in the intra/inter prediction stage 402 can be added to the derived residual to create a reconstructed block. Loop filtering stage 416 can be applied to the reconstructed block to reduce distortion (such as block artifacts).
Other variations of encoder 400 can be used to encode compressed bit stream 420. For example, a non-transform-based encoder can directly quantize the residual signal for certain blocks or frames without the transform stage 404. In another embodiment, the encoder can combine quantization stage 406 and dequantization stage 410 in a common stage.
Fig. 5 is a block diagram of a decoder 500 according to an embodiment of the present disclosure. The decoder 500 can be implemented in the receiving station 106, for example by providing a computer software program stored in the memory 204. The computer software program can include machine instructions that, when executed by a processor (e.g., CPU 202), cause the receiving station 106 to decode video data in the manner described in fig. 5. The decoder 500 can also be implemented in hardware, for example, included in the transmitting station 102 or the receiving station 106.
Similar to the reconstruction path of encoder 400 discussed above, in one example, decoder 500 includes the following stages for performing various functions to produce output video stream 516 from compressed bitstream 420: entropy decoding stage 502, dequantization stage 504, inverse transform stage 506, intra/inter prediction stage 508, reconstruction stage 510, loop filtering stage 512, and deblocking filtering stage 514. Other structural variations of decoder 500 can be used to decode compressed bitstream 420.
When the compressed bitstream 420 is provided for decoding, data elements within the compressed bitstream 420 can be decoded by the entropy decoding stage 502 to produce a set of quantized transform coefficients. Dequantization stage 504 dequantizes the quantized transform coefficients (e.g., by multiplying the quantized transform coefficients by quantizer values), and inverse transform stage 506 dequantizes the dequantized transform coefficients to produce a derived residual that can be the same as the derived residual created in encoder 400 by inverse transform stage 412. Using header information decoded from the compressed bitstream 420, the decoder 500 can use the intra/inter prediction stage 508 to create the same prediction block as that created in the encoder 400, e.g., in the intra/inter prediction stage 402. In the reconstruction stage 510, the prediction block can be added to the derived residual to create a reconstructed block. The loop filter stage 512 can be applied to the reconstructed block to reduce block artifacts.
Other filtering can be applied to the reconstructed block. In this example, the deblocking filtering stage 514 is applied to reconstructed blocks to reduce block distortion, and the results are output as an output video stream 516. The output video stream 516 can also be referred to as a decoded video stream, and these terms will be used interchangeably herein. Other variations of decoder 500 can be used to decode compressed bit stream 420. For example, decoder 500 can generate output video stream 516 without deblocking filtering stage 514.
Fig. 6 is a block diagram of an example of a reference frame buffer 600. The reference frame buffer 600 stores reference frames for encoding or decoding blocks of frames of a video sequence. Tags, roles, or types may be associated with different reference frames stored in a reference frame buffer, or used to describe them. The reference frame buffer 600 is provided as an illustration and operation of a reference frame buffer, and reference frames described with reference to fig. 6 may not be generated according to embodiments of the present disclosure.
Reference frame buffer 600 includes LAST frame LAST 602, GOLDEN frame GOLDEN 604, and alternate reference frame ALTREF 606. The frame header of the reference frame can include a virtual index 608, the virtual index 608 pointing to a location in the reference frame buffer 600 where the reference frame is stored. The reference frame map 612 can map the virtual index 608 of the reference frame to a physical index 614 of a memory storing the reference frame. When two reference frames are the same frame, the reference frames can have the same physical index even though they have different virtual indexes. The one or more refresh flags 610 can be used to remove one or more stored reference frames from the reference frame buffer 600, e.g., clear space in the reference frame buffer 600 for a new reference frame if no other blocks are to be encoded or decoded using the stored reference frame or a new golden frame is to be encoded or decoded.
The reference frames stored in the reference frame buffer 600 can be used to identify motion vectors to predict blocks of frames to be encoded or decoded. Depending on the type of prediction used to predict the current block of the current frame, different reference frames may be used. For example, in inter-frame compound prediction, the block of the current frame can be forward predicted using any combination of LAST frame LAST 602, GOLDEN frame GOLDEN 604, and alternate reference frame ALTREF 606.
There may be a limited number of reference frames that can be stored within the reference frame buffer 600. As shown in fig. 6, the reference frame buffer 600 can store up to 8 reference frames. Each stored reference frame can be associated with a respective virtual index 608 of the reference frame buffer. Although 3 of the 8 spaces in reference frame buffer 600 are used by LAST frame LAST 602, GOLDEN frame GOLDEN 604, and alternate reference frame ALTREF 606, there are still 5 spaces available for storing other reference frames.
In particular, one or more available spaces in reference frame buffer 600 may be used to store additional alternative reference frames (e.g., ALTREF 1, ALTREF 2, EXTRA ALTREF, etc., where original alternative reference frame ALTREF 606 may be referred to as ALTREF 0). Alternative reference frame ALTREF 606 is a frame in the video sequence that is far from the current frame in display order, but is encoded or decoded before it is displayed. For example, alternate reference frame ALTREF 606 may be 10, 12, or more (or less) frames after the current frame in display order.
The additional alternative reference frame can be a frame that is positioned closer to the current frame in display order. For example, the first additional alternative reference frame ALTREF 2 can be 5 or 6 frames after the current frame in display order, while the second additional alternative reference frame ALTREF 3 can be 3 or 4 frames after the current frame in display order. Closer to the current frame in display order increases the likelihood that the features of the reference frame are more similar to those of the current frame. Thus, one of the additional alternative reference frames can be stored in the reference frame buffer 600 as an additional option available for backward prediction.
Although reference frame buffer 600 is shown as being capable of storing up to 8 reference frames, other embodiments of reference frame buffer 600 may be capable of storing more or fewer reference frames. Furthermore, the available space in the reference frame buffer 600 may be used to store frames other than additional alternative reference frames. For example, the available space may store the second LAST frame LAST2 and/or the third LAST frame LAST3 as additional forward prediction reference frames. In another example, the backward frame bwrref may be stored as an additional backward prediction reference frame.
As described above, the frames of the GOP may be subjected to code processing in a code processing order different from the display order of the frames. For example, the encoder may receive frames in display order, determine a code processing order (or code processing structure), and encode groups of frames accordingly. For example, a decoder may receive frames in a code processing order (e.g., in an encoded bitstream), decode the frames in the code processing order, and display the frames in a display order. When frames are code processed (i.e., encoded by an encoder or decoded by a decoder), they may be added to the reference frame buffer 600 and assigned a different role (e.g., LAST, GOLDEN, ALTREF, LAST, LAST3, bwrref, etc.) for code processing of subsequent frames. That is, some frames that are first code processed may be stored in the reference frame buffer 600 and used as reference frames for code processing (using inter prediction) of other frames. For example, a first frame of a GOP may be encoded first and assigned as a GOLDEN frame, and a last frame in the GOP may be encoded second and assigned as an alternate reference (i.e., ALTREF) for the encoding of all other frames.
The frames of the GOP can be encoded using a code processing structure. As used herein, a code processing structure refers to the order of code processing of frames of a GF group and/or which reference frames are available for code processing of which other frames of a GOP. In order to illustrate the concept of the code processing structure, and without losing generality or any limitation regarding the present disclosure, the multi-layer code processing structure and the one-layer code processing structure are described below with reference to fig. 7A to 7B, respectively. Note that when referring to an encoder, code processing means encoding; when referring to a decoder, code processing means decoding.
The frames of the GF group can be encoded independently of the frames of the other GF groups. In general, the first frame of the GF group is coded using intra-prediction, and all other frames of the GF group are coded using the frame of the GF group as a reference frame. In some cases, the first frame of the GF group can be coded using the frame of the previous GF group. In some cases, the last frame of the GF group can be coded using the frame of the previous GF group. In some cases, the first frame and the last frame of the GF group may be coded using the frames of the previous GF group.
In an example, three reference frames may be used to encode or decode blocks of other frames of a video sequence. The first reference frame may be an intra-predicted frame, which may be referred to as a key frame or a golden frame. In some code processing structures, the second reference frame may be the most recently encoded or decoded frame. The most recently encoded or decoded frame may be referred to as a LAST frame. The third reference frame may be an alternative reference frame that is encoded or decoded before most other frames, but displayed after most frames in the output bitstream. An alternative reference frame may be referred to as an ALTREF frame. The efficacy of the reference frame in encoding or decoding a block may be measured based on the resulting signal-to-noise ratio.
Fig. 7A is a schematic diagram of an example of a multi-layer code processing structure 720 according to an embodiment of the present disclosure. The multi-layer code processing structure 720 shows a code processing structure for a GF group of length 10 (i.e., the frame group includes 10 frames): frames 700 through 718.
An encoder, such as encoder 400 of fig. 4, is capable of encoding groups of frames according to a multi-layer code processing structure 720. A decoder, such as decoder 500 of fig. 5, is capable of decoding groups of frames using a multi-layer code processing structure 720. The decoder is capable of receiving an encoded bitstream, such as the compressed bitstream 420 of fig. 5. In the encoded bitstream, the frames in the group of frames can be ordered (e.g., ordered, stored, etc.) in the code processing order of the multi-layer code processing structure 720. The decoder is able to decode the frames and display them in their display order in the multi-layer code processing structure 720. The coded bitstream can include syntax elements that can be used by a decoder to determine a display order.
The numbered blocks of fig. 7A indicate the code processing order of the frame groups. Thus, the code processing order is given by the frame order 700, 702, 704, 706, 708, 710, 712, 714, 716, and 718. The display order of the frames in the frame group is indicated by the left-to-right order of the frames. Thus, the display order is given by frame orders 700, 708, 706, 710, 704, 716, 714, 718, 712, and 702. That is, for example, the second frame in display order (i.e., frame 708) is the fifth frame to be coded; the last frame of the group of frames (i.e., frame 702) is the second frame to be encoded.
In fig. 7A, the first layer includes frames 700 and 702, the second layer includes frames 704 and 712, the third layer includes frames 706 and 714, and the fourth layer includes frames 708, 710, 716, and 718. The frames of one layer do not necessarily correspond to the code processing order. For example, although frame 712 (corresponding to code processing order 7) is at the second layer, frame 706 of the third layer (corresponding to code processing order 4) and frame 708 of the fourth layer (corresponding to code processing order 5) are code processed before frame 712.
In a multi-layer code processing structure, such as multi-layer code processing structure 720, frames within GF groups may not be code processed in their display order, and the code processed frames can be used as backward references for frames in different layers (i.e., higher layers).
The code processing structure of fig. 7A is referred to as a multi-layer code processing structure because frames of one layer are code-processed using only lower-layer code-processed frames and code-processed frames of the same layer as reference frames. That is, at least some of the frames of the lower layer and the frames of the same layer of the current frame (i.e., the frame being encoded) can be used as reference frames for the current frame. The code-processed frame of the same layer as the current frame is a frame of the same layer as the current frame and is code-processed before the current frame. For example, frame 712 (code processing order 7) can be code processed using frames of the first layer (i.e., frames 700 and 702) and code processed frames of the same layer (i.e., frame 704). As another example, frame 710 (code processing order 6) can be code processed using the first layer of code processed frames (i.e., frames 700 and 702), the second layer of code processed frames (i.e., frame 704), the third layer of code processed frames (i.e., frame 706), and the same layer of code processed frames (i.e., frame 708). Which frames are actually used for encoding the frames depends on the roles assigned to them in the reference frame buffer.
Arrows in fig. 7A and 7B illustrate partial examples of which frames can be used as reference frames for code processing of the frames. For example, as indicated by the arrow, frame 700 can be used to code frame 702, frames 700 and 702 can be used to code frame 704, and so on. However, as described above, to reduce clutter, only a subset of the possible arrows are displayed. For example, as indicated above, frames 700 and 702 can be used to code any other frame in a group of frames; however, for example, arrows are not illustrated between frames 700 and/or 702 and frames 710, 716, 718, and so on.
In an embodiment, the number of layers and the code processing order of the frames of the frame group can be selected by the encoder based on the length of the frame group. For example, if the frame group includes 10 frames, the multi-layer code processing structure shown in fig. 7A can be used. In another example, if the frame group includes 9 frames, the code processing order can be frames 1, 9, 8, 7, 6, 5, 4, 3, and 2. That is, for example, the 3 rd frame in the display order is code-processed in the code processing order, 8 th frame. The first layer can include the 1 st and 9 th frames in display order, the second layer can include the 5 th frame in display order, the third layer can include the 3 rd and 7 th frames in display order, and the fourth layer can include the 2 nd, 4 th, 6 th and 8 th frames in display order.
As described above, the code processing order of each frame group can be different from the display order. This allows frames in the video sequence following the current frame to be used as reference frames for encoding the current frame. A decoder, such as decoder 500, may share a common group code processing structure with an encoder, such as encoder 400. The group code processing structure assigns different roles that the corresponding frames within the group may play in the reference frame buffer (e.g., last frame, alternate reference frame, etc.), and defines or indicates the code processing order of the frames within the group.
In the multi-layer code processing structure, first and last frames (in display order) are code-processed. Thus, frame 700 (first in display order) is first code processed, and frame 702 (last in display order) is next code processed. The first frame of the frame set can be referred to as a GOLDEN frame, such as the GOLDEN frame described with reference to GOLDEN frame GOLDEN 604 of fig. 6 (i.e., having the role of a GOLDEN frame). The last frame in the display order (e.g., frame 702) can be referred to as an ALTREF frame, such as the ALTREF frame described with reference to alternative reference frame ALTREF 606 of fig. 6 (i.e., having the role of an ALTREF frame).
In code processing the blocks of each of frames 704 through 718, frame 700 (as the golden frame) may be used as a forward predicted frame and frame 702 (as an alternative reference frame) may be used as a backward reference frame. In addition, a reference frame buffer (e.g., reference frame buffer 600) is updated after each frame is code processed, thereby updating the identification of the reference frame (also referred to as the LAST frame (e.g., LAST)), which may be used as a forward predicted frame in a similar manner to frame 700. For example, when predicting a block of frame 706 (e.g., in intra/inter prediction stage 402), frame 708 can be designated as the LAST frame (LAST), such as LAST frame LAST 602 in reference frame buffer 600. When predicting the block of frame 708, frame 706 is designated as the last frame, replacing frame 704 as the last frame in the reference frame buffer. This process continues to predict the remaining frames of the group in coding order.
The first frame can be encoded using intra prediction or inter prediction. In the case of inter prediction, the first frame can be encoded using the frame of the previous GF group. The last frame can be encoded using intra prediction or inter prediction. In the case of inter prediction, the last frame can be encoded using the first frame (e.g., frame 700) as indicated by arrow 719. In some embodiments, the last frame can be encoded using the frame of the previous GF group. All other frames of the frame set (i.e., frames 704 through 718) are encoded using the encoded frames of the frame set as described above.
GOLDEN frame (i.e., frame 700) can be used as a forward reference and ALTREF (i.e., frame 702) can be used as a backward reference for code processing frames 704 through 718. Because each other frame of the group of frames (i.e., frames 704 through 718) has at least one past frame (e.g., frame 700) and at least one future frame (e.g., frame 702) available, the frames may be code processed (i.e., at least a portion of the blocks of the frames) using one reference or two references (e.g., intra-composite prediction).
In a multi-layer code processing structure, some of the layers can be assigned roles. For example, the second layer (i.e., the layer comprising frames 704 and 712) can be referred to as an EXTRA ALTREF layer, and the third layer (i.e., the layer comprising frames 706 and 714) can be referred to as a bwref layer. Frames of the EXTRA ALTREF layer can be used as additional alternative prediction reference frames. Frames of the bwref layer can be used as additional backward prediction reference frames. If GF groups are classified as non-stationary GF groups (i.e., when using a multi-layer code processing structure), bwref frames and EXTRA ALTREF frames can be used to improve code processing performance.
Fig. 7B is a schematic diagram of an example of a one-layer code processing structure 750, according to an embodiment of the present disclosure. A layer of code processing structure 750 can be used to code groups of frames.
An encoder, such as encoder 400 of fig. 4, is capable of encoding groups of frames according to a layer code processing structure 750. A decoder, such as decoder 500 of fig. 5, is capable of decoding groups of frames using a layer of code processing structure 750. The decoder is capable of receiving an encoded bitstream, such as the compressed bitstream 420 of fig. 5. In the encoded bitstream, the frames of a group of frames can be ordered (e.g., ordered, stored, etc.) in the code processing order of a layer of the code processing structure 750. The decoder is able to decode the frames in a layer code processing structure 750 and display them in their display order. The coded bitstream can include syntax elements that can be used by a decoder to determine a display order.
The display order of the group of frames of fig. 7B is given by the left to right ordering of the frames. Thus, the display order is 752, 754, 756, 758, 760, 762, 764, 766, 768, and 770. The numbers in the boxes indicate the code processing order of the frames. Thus, the code processes are 752, 770, 754, 756, 758, 760, 762, 764, 766, and 768.
To code any of frames 754, 756, 758, 760, 762, 764, 766, and 768 in one layer of code processing structure 750, no backward reference frames are used other than the far-end ALTREF frame (e.g., frame 770). Additionally, in one-layer code processing structure 750, the bwref layer (as shown in fig. 7A), the EXTRA ALTREF layer (as shown in fig. 7A), or both, are disabled. That is, no bwrref and/or EXTRA ALTREF reference frames may be used to code any of frames 754-768. Multiple references can be employed for code processing of frames 754 through 768. That is, in connection with using the remote ALTREF coupling, reference frames LAST, LAST 2, LAST3, and GOLDEN can be used for code processing of the frames. For example, frame 752 (GOLDEN), frame 760 (LAST 3), frame 762 (LAST 2), frame 764 (LAST), and frame 770 (ALTREF) can be available in a reference frame buffer (e.g., reference frame buffer 600) for code processing of frame 766.
Fig. 8 is a schematic diagram of an example 800 of a search area for candidate motion vectors. Example 800 is for illustration purposes and is not limiting of the present disclosure, and other conventional methods of obtaining candidate motion vectors are possible. As mentioned herein, when a current block (e.g., current block 802) is code processed using a reference frame (e.g., using a reference frame type), the codec obtains (e.g., generates, selects) a list of candidate motion vectors. Candidate MVs are identified in scan areas adjacent to the current block.
The scan area can be measured in a mode unit such as mode unit 808. The mode unit can be the smallest block size that is possible for inter prediction. For example, some codecs may not perform inter prediction on blocks smaller than mxn pixels. In an example, m=n=4. Thus, the size of the mode cell can be 4×4 pixels. The scan region can have a height 806 above the current block 802 and a width 804 to the left of the current block 802. The height 806 and width 804 can be measured in mode units (or equivalently, in pixels).
Each mode unit can be associated with mode information. The mode information can include a reference frame type and a motion vector for the prediction mode unit. Although the pattern information is associated with a pattern unit, the pattern unit is not necessarily code-processed independently of other pattern units. To illustrate, mode information may be used to predict blocks of size P X Q (where P.gtoreq.M, Q.gtoreq.gtoreq.N) without further partitioning. Mode information can be associated with each mxn mode unit of the p×q block. To further illustrate, inter prediction may be performed on a super block of size 128×128 without further partitioning. Thus, motion vectors and reference frame types can be associated with all non-overlapping 4 x 4 mode units of the super block.
A shadow pattern unit, such as pattern unit 810, illustrates a pattern unit of a scan region using the same reference frame as the current block 802. Thus, the shadow mode unit can be used to obtain candidate MVs for the current block 802.
Fig. 9 is a flow chart of an inter prediction technique 900. The technique 900 may be implemented in whole or in part in the intra/inter prediction stage 402 of the encoder 400 of fig. 4 and/or the intra/inter prediction stage 508 of the decoder 500 of fig. 5. When implemented in an encoder, "code processing" means "encoding"; when implemented in a decoder, "code processing" means "decoding".
For example, the technique 900 can be implemented as a software program that can be executed by a computing device, such as the sending station 102 or the receiving station 106 of fig. 1. For example, the software program can include machine-readable instructions that can be stored in a memory, such as memory 204 or secondary storage 214 of fig. 2, and that when executed by a processor, such as CPU 202 of fig. 2, can cause the computing device to perform technique 900. The technique 900 can be implemented using specialized hardware or firmware. As described above, some computing devices may have multiple memories or processors and may be capable of using multiple processors, memory, or both to allocate the operations described in the technology 900. The technique 900 can be implemented using specialized hardware or firmware. Multiple processors, memories, or both may be used.
The technique 900 can be used to obtain candidate MVs for code processing of a current block of a current frame. The current block is coded using some type of reference frame. Several frame types may be available. In an example, a frame type can be described with reference to fig. 6. Thus, in the case of using a single reference frame prediction block, the frame type can be one of 7 frame types ALTREF, ALTREF, LAST 2, LAST 3, GOLDEN, BWDREF, fewer, more, other frame types, or a combination thereof. In case of predicting a block using a composite reference frame, the frame type can be a combination of two separate (fixed) frame types. Thus, assuming that 7 individual frame types are available, a total of 28 frame types (7 individual + (C (7, 2) =21) composite frame types) are available.
The current frame may be divided into a plurality of partitions (e.g., headers, slices, etc.). Each partition can include rows and columns of superblocks. Note that depending on the partitioning scheme, one row (column) of a partition may include more superblocks than a second row (column) of a partition.
In an example, one or more MV buffers can be available to store MVs of the coded blocks. In an example, one or more MV buffers can be initialized at the beginning of the code processing for each partition of the current frame. For example, one or more MV buffers may be initialized before a tile (tile) of a current block including the current block is coded. Initializing the MV buffer can mean or can include allocating memory for the MV buffer so that MVs of the coded block can be stored in the MV buffer. The MV buffers can be reset (e.g., deleted, deallocated, etc.) in response to completing the code processing of the partition.
MV buffering can be distinguished into MV banks. Thus, in an example, the technique 900 can include initializing an MV bank. Initializing the MV bank can include initializing a MV buffer of the MV bank. Each MV buffer of the MV bank corresponds to a reference frame type. For illustration and not by way of limitation, a row MV buffer corresponding to a reference frame type bwref can be used to store motion vectors for blocks (e.g., motion units) of the row of super blocks coded using the reference frame type bwref.
In an example, a respective MV bank can be associated with a row of the superblock of the partition of the current frame. In an example, the respective MV bank can additionally or alternatively be associated with a column of superblock blocks of the partition of the current frame. In an example, a row MV bank can be associated with more than one row of a partition. In an example, a column MV bank can be associated with more than one column of a partition. For illustration and not by way of limitation, each row MV bank can be associated with two rows of the partitioned superblock and each column MV bank can be associated with three columns of the partitioned superblock.
MV libraries can provide long-term motion dependencies that are not captured by scanning a neighborhood of the current block for motion vectors, where the neighborhood is typically a few pixel units (or blocks) adjacent to the current block. Longer-term motion dependency may mean a motion vector farther from the current block or a motion vector farther from a pixel or block of the current block.
Fig. 10 is a schematic diagram of an example 1000 of a motion vector library. Example 1000 includes a frame portion 1002 of a current frame being code processed. The frame portion 1002 can be a tile of the current frame, a slice of the current frame, the current frame itself, or some other partition of the current frame. Example 1000 illustrates frame portion 1002 including 4 rows of superblocks and 4 columns of superblocks. However, the present disclosure is not limited thereto: the number of rows of superblocks and the number of columns of superblocks can depend on the width and height (e.g., in pixels) of the frame portion 1002 and the size of the superblock.
Example 1000 illustrates superblock 1004 being the current superblock being code processed. Superblocks 1006 through 1014 have been code processed. Although not specifically shown in fig. 10, one skilled in the art will recognize that each super block of frame portion 1002 may be further divided into smaller blocks that are code processed.
In example 1000, column MV bank 1015 is associated with column 0 of superblocks including at least superblocks 1006, 1014, and 1020; column MV library 1017 is associated with column 1 of super blocks including at least super blocks 1008, 1004, and 1022; column MV library 1019 is associated with column 2 of superblocks including at least superblocks 1010, 1016, and 1024; column MV bank 1021 is associated with column 3 of superblocks including at least superblocks 1012, 1018, and 1026; row MV bank 1028 is associated with row 0 of the superblocks including at least superblocks 1006, 1008, 1010, and 1012; row MV library 1030 is associated with row 1 of superblocks including at least superblocks 1014, 1004, 1016, and 1018; and row MV bank 1032 is associated with row 2 of superblocks including at least superblocks 1020, 1022, 1024, and 1026.
Each MV bank in example 1000 is shown to include MV buffers for each of the available reference frame types a through N. For example, the column MV bank 1015 is illustrated as including MV buffers 1034, 1036, 1038, 1040 corresponding to reference frame types A, B, …, N, respectively. In an example, each MV bank can be initialized to include a respective MV buffer of available reference frame types. In another example, MV buffers in the MV bank may be allocated on demand. That is, an MV buffer corresponding to a reference frame type may be allocated in response to encountering a first block using the reference frame type.
The MVs of the block of the super block encoded using inter prediction are added to the respective MV buffers of the corresponding MV bank. When a block is code processed, an MV can be added to the MV buffer (e.g., after the code processing of the block is completed or after the MV of the block is obtained). In another example, MVs for all blocks of a super block can be added after all blocks of the super block have been coded. To illustrate, after all blocks of the super block 1014 are coded, MVs for all blocks of the super block 1014 can be added to the corresponding MV buffers. For example, using the MVs of the inter-coded blocks of reference frame type B of the super block 1014, the MVs can be added to the MV buffers 1042 of the row MV bank 1030 and the MV buffers 1036 of the column MV bank 1015.
Some embodiments may use only row MV banks or row MV buffers; other embodiments may use a column MV bank or column MV buffer; while still other embodiments may use both row and column MV banks or buffers. The code processing of the superblock is typically performed in raster scan order. Thus, the MVs of all blocks of a row of super blocks can be added to one MB library. The same row MV bank can be updated when the code processing proceeds from one superblock to the next in a row. However, a different column MV buffer (or bank) is used when the code processing proceeds from the superblock to the next in raster order.
Note that with respect to the encoder, the MVs of the coded block can mean or include MVs that have been selected by the encoder (such as based on rate distortion measurements) for encoding the block; whereas with respect to a decoder, the MVs of a coded block can mean or include MVs that the decoder uses to obtain a predicted block of the block (and which can be determined based on syntax elements in the compressed bitstream).
Referring again to fig. 9, at 902, technique 900 codes a first block of a current frame using a first Motion Vector (MV) and a reference frame type. To illustrate, the first block can be the super block 1008 of fig. 10, or can be a block of the super block 1008; alternatively, the first block can be the superblock 1014 of FIG. 10, or can be a block of the superblock 1014. In an example, and more generally, the process codes a first block of a current frame that precedes a current block to be code processed. The first block may be code processed using the corresponding reference frame type. In an example, the current frame may be partitioned, such as into tiles, fragments, or some other partition. For simplicity, an undivided frame may still be referred to as a divided frame divided into one partition consistent with the frame range. The technique 902 performs code processing for a first block preceding a current block in the same partition (e.g., tile, slice, etc.) as the current block. As mentioned above, the reference frame type can be or correspond to a single reference frame prediction mode; or the reference frame type can be or correspond to a composite reference frame prediction mode.
At 904, the technique 900 stores the first MV and reference frame type in at least one MV buffer. For illustration, and assuming that the reference frame type is reference frame type B, the at least one MV buffer can be at least one of MV buffer 1042 or MV buffer 1036 of fig. 10. In an example, the reference frame type may already be associated with at least one MV buffer. Thus, the reference frame type may not be explicitly stored in the at least one MV buffer. Instead, the reference frame type is considered to be stored in at least one MV buffer, since at least one MV buffer is associated with at least one MV buffer.
The at least one MV buffer can include a MV buffer associated with a row of the super block of the current frame. In an example, at least one MV buffer can be associated with a row of super blocks or a column of super blocks of a slice block of the current frame. In an example, at least one MV buffer can be associated with a row of a super block or a column of a super block of a slice of the current frame. In an example, the at least one MV buffer can additionally or alternatively include a MV buffer associated with a column of the super block of the current frame.
The first MV can be added to the at least one MV buffer in any number of ways. In an example, a first MV can be added to the next open slot of at least one MV buffer. In another example, if the first MV is already included in the at least one MV buffer, the first MV is not added a second time. In another example, storing the first MV in at least one MV buffer can be as described with reference to fig. 11 and 12.
Fig. 11 is a flow chart of a technique 1100 for adding motion vectors to a motion vector buffer. The technique 1100 can be performed on each MV block of the super block. The technique 1100 can be performed after each block of the superblock has been code processed, or after all blocks of the superblock have been code processed. Although the technique 1100 is described with respect to motion vectors (e.g., in singular form), in the case of a composite reference frame prediction mode, the motion vectors actually comprise two motion vectors, as already mentioned. Thus, a "motion vector" encompasses one motion vector or two motion vectors, depending on the frame reference type.
Technology 1100 is described with reference to fig. 12. Fig. 12 illustrates a scene in which a motion vector is added to a motion vector buffer. The MV buffer can be a row MV buffer of a row MV bank. The MV buffer can be a column MV buffer of a column MV bank. In fig. 12, scenes 1210, 1220, and 1230 illustrate storing motion vectors MV2 in the MV buffer under different conditions of the MV buffer. The MV buffer can be a fixed-size first-in first-out (FIFO) with a reorder data structure. It is well known that in FIFO structures, elements are added at the tail (e.g., end, back) and removed from the head (e.g., front). The MV buffers can be ordered in the MV buffers such that MVs closer to the tail are used later in time than MVs closer to the head. That is, the MVs are ordered in the MV buffer in the last used order.
At 1102, motion vectors to be added to the MV buffer are identified (e.g., selected, received, determined, etc.). MV can be MV2 of fig. 12.
At 1104, the technique 1100 determines whether the MV is already in the MV buffer. If the MV is in an MV buffer (such as illustrated by scene 1220), then technique 1100 proceeds to 1106 to move the MV to the MV buffer's header; otherwise, technique 1100 proceeds to 1108. Scene 1220 shows MV2 in a second position of MV buffer 1222. Thus, the MV buffer 1222 includes MV2, which indicates that a block farther than the current block uses MV2.MV buffer 1224 illustrates the results of 1106; that is, the MV buffer 1222 is reordered so MV2 is moved to the end of the MV buffer 1224.
At 1108, the technique 1100 determines whether the MV buffer is full. If the MV buffer is full (e.g., as shown in scene 1230), then technique 1100 proceeds to 1110 to remove the head of the MV buffer to make room for MVs at the tail of the MV buffer. If the MV buffer is not full (such as illustrated by scenario 1210), then the technique 1100 proceeds to 1112.
In scene 1230, technique 1100 stores MV2 in full MV buffer 1232. The technique 1100 removes the earliest MV in the buffer, which is the MV at the head of the buffer (i.e., MV 0), and adds MV2 to the tail of the buffer. MV buffer 1234 illustrates the result of storing MV2 in MV buffer 1232. In scenario 1210, the MV buffer includes empty slots. Thus, technique 1100 stores MV2 at the end of the MV buffer as indicated by MV buffer 1214.
Thus, referring again to fig. 9, technique 900 can include code processing a second block of the current frame using a second MV and a reference frame type; and in response to determining that the at least one MV buffer is not full, adding a second MV to the at least one MV buffer. The technique 900 can further include, in response to determining that the at least one MV buffer is full, removing previously added MVs from the at least one MV buffer; and adding a second MV. The previously added MV can be at the head of at least one MV buffer. In an example, the first MV can be stored in any location in the MV buffer other than the tail, and the second MV can be stored in the tail of at least one MV buffer. The technique 900 can further include, in response to determining that the first MV is used for code processing of the third block, moving the first MV to the tail of the at least one MV buffer, as illustrated with respect to the scenario 1220 of fig. 12.
At 906, the technique 900 identifies MV candidates for code processing the current block using the reference frame type. The current block can be the superblock 1004 of fig. 10, or can be a block of superblock 1004. MV candidates can be identified using any technique for identifying MV candidates in the neighborhood of the current block. The decoder may decode a reference frame (e.g., an indication of a reference frame) to be used for decoding the current block, a decoding mode, and decode one or more motion vectors from the compressed bitstream. The encoder may select the reference frame using any technique for selecting the reference frame used to code the current block. Knowing the type of reference frame to be used, the decoder obtains a list of candidate motion vectors (which may be an ordered list). The ordered list can be generated by at least scanning pixels in a spatial neighborhood of the current block for candidate motion vectors.
At 908, the technique 900 determines whether the cardinality (M) of MV candidates is less than the maximum number (N) of MV candidates. In other words, the technique 900 determines whether there are more slots available in the MV candidate list or whether M is less than N. If there are more slots available, technique 900 proceeds to 910. If there are no more slots available, technique 900 proceeds to 916.
At 910, the technique 900 identifies a first motion vector in at least one MV buffer. In an example, the first motion vector may be randomly selected from at least one MV buffer to add to the candidate list (i.e., MV candidates). In another example, the at least one MV buffer can be an ordered list. In each of the at least one MV buffers, the order of MVs may be from the earliest MV added to the buffer to the most recently added MV. Identifying the first motion vector in the at least one MV buffer can include traversing the at least one MV buffer from tail to head and, for each MV, determining whether the MV is already a candidate MV (i.e., whether the MV is on a candidate list of MVs).
Thus, at 912, the technique 900 determines whether the first MV is included in the MV candidates. In response to determining that the first MV is included in the MV candidates, the technique proceeds to 916. In response to determining that the first MV is not included in the MV candidates, the technique 900 proceeds to 914.
At 914, the technique 900 adds the first MV as a MV candidate. That is, at 914, the technique 900 adds the first MV to the MV candidate list. In an example, the technique 900 can include, in response to determining that the cardinality of the MV candidates is less than the maximum number of MV candidates and that the first MV is included in the MV candidates, identifying, in the at least one MV buffer, another MV that is different from the first MV and that is not included in the MV candidates; and adding another MV as MV candidate.
Fig. 13 illustrates an example 1300 of adding a candidate motion vector to a list of candidate motion vectors from a motion vector buffer. Example 1300 includes MV buffer 1310 and MV candidate list 1320.MV buffer 1310 and MV candidate list 1320 are shown as sizes 4 and 6, respectively. However, the MV buffer 1310 and the MV candidate list 1320 can include a greater or lesser number of MVs. Candidate MV list 1330 shows the state of candidate MV list 1320 after MV from MV buffer 1310 is added to candidate MV list 1320.
As described above, after the conventional reference MV candidate scan is completed (e.g., after the MV candidate list is typically obtained), if there is an open slot in the MV candidate list, the codec section references the MV candidate library (more specifically, has a buffer matching the reference frame type) for additional MV candidates. Proceeding from the tail back to the head of the MV buffer, if an MV in the buffer is not already present in the MV candidate list, then the MV may be appended to the MV candidate list.
MV buffer 1310 includes MVs MV2, MV5, MV6, and MV4 from head to tail. The MV candidate list 1320 includes motion vectors MV0, MV1, MV3, and MV4. Two slots (e.g., positions) in MV candidate list 1320 are empty; namely slots 1322, 1324. Starting from the tail, the MV at the slot 1312 of MV buffer 1310 (i.e., MV 4) is checked first. The technique 900 determines that the MV candidate list 1320 already includes MV4 in the slot 1326. Next, the technique 900 considers MV6 (i.e., MV in the next slot 1314 of MV buffer 1310). Because MV candidate list 1320 does not include MV6, technique 900 adds MV6 as a candidate, as shown by slot 1332 of MV candidate list 1330. Next, the technique 900 considers MV5 (i.e., MV in the next slot 1316 of MV buffer 1310). Because MV candidate list 1320 does not include MV5, technique 900 adds MV5 as a candidate, as shown by slot 1334 of MV candidate list 1330. Because MV candidate list 1330 is now full, technique 900 stops evaluating other MVs in MV buffer 1310.
In some cases, after evaluating all MVs in the MV buffer, slots in the MV candidate list may still be available. As already mentioned, in some embodiments, two MV buffers may be available: a row MV buffer and a column MV buffer. The technique 900 may first use one of the two MV buffers. For example, a row (or column) MV buffer may be used first. If more slots remain available in the candidate MV list, then the technique 900 can add more candidates from another MV buffer, as described with reference to fig. 13.
Referring again to fig. 9, at 916, the technique 900 selects one of the MV candidates for code processing on the current block, as described above. When implemented in a decoder, one of the MV candidates may be selected by decoding an index of the one of the MV candidates from the compressed bitstream. When implemented in an encoder, the encoder is able to encode the index of one of the MV candidates in the compressed bitstream. As described above, one of the MV candidates itself can be used for code processing of the current block, and also can be used as a reference MV for differential code processing of the MV of the current block. One of the MV candidates may be used for code processing of the current block in other ways.
Fig. 14 is a flow chart of a technique 1400 for obtaining motion vector candidates. The technique 1400 may be implemented, in whole or in part, in the intra/inter prediction stage 402 of the encoder 400 of fig. 4 and/or the intra/inter prediction stage 508 of the decoder 500 of fig. 5. When implemented in an encoder, "code processing" means "encoding"; when implemented in a decoder, "code processing" means "decoding".
For example, the technique 1400 can be implemented as a software program that can be executed by a computing device, such as the sending station 102 or the receiving station 106 of fig. 1. For example, a software program can include machine-readable instructions that can be stored in a memory, such as memory 204 or secondary storage 214 of fig. 2, and that when executed by a processor, such as CPU 202 of fig. 2, can cause the computing device to perform technique 1400. The technique 1400 can be implemented using specialized hardware or firmware. As described above, some computing devices may have multiple memories or processors and may be capable of using multiple processors, memories, or both to distribute the operations described in technique 1400. The technique 1400 can be implemented using specialized hardware or firmware. Multiple processors, memories, or both may be used.
At 1402, the technique 1400 obtains partition partitioning (partitioning) that partitions the current frame into super blocks, where the super blocks are arranged into rows of super blocks, as described herein. At 1404, technique 1400 initializes the row MV bank. Each row MV bank can be associated with one or more rows of the superblock and one or more reference frame types. As described herein, a row MV bank can include one or more MV buffers. Each MV buffer can be associated with a reference frame type. As described herein, the MV buffer is capable of storing motion vectors. In the case that the reference frame type associated with the MV buffer indicates a single reference frame, each MV stored in the slots of the MV buffer is a single MV; and in the case that the reference frame type associated with the MV buffer indicates a composite reference frame, each MV stored in the slots of the MV buffer is actually two MVs.
At 1406, the technique 1400 codes a first block of a first super block in a row of super blocks using a first Motion Vector (MV) and a reference frame type. The first block can be code processed as described with reference to 904 of fig. 9. At 1408, the technique 1400 stores the first MV in a row MV bank associated with the row and reference frame type of the superblock. The first MV can be stored in a row MV bank as described above. At 1410, technique 1400 obtains MV candidates for code processing a second block of a second super block using a reference frame type. The technique 1400 can obtain MV candidates using any conventional technique for obtaining MV candidates.
At 1412, the technique 1400 uses the row MV bank and reference frame type associated with the row of the super block to identify additional MV candidates for code processing of the second block, provided that the cardinality of MV candidates is less than the maximum number of MV candidates. In an example, the technique 1400 can search a row MV bank for MVs that are not included in MV candidates to add MVs to the MV candidates. The technique 1400 is able to search a bank of row MVs from the most recently added MV to the earliest added MV.
The first block can be in a column of the super block, and the technique 1400 can further include initializing a column MV bank; and storing the first MV in a column MV bank associated with the column of the super block and the reference frame type. Each column MV bank can be associated with one or more columns of the superblock and one or more reference frame types. In an example, the technique 1400 can search the row MV bank for MVs that are not included in the MV candidates before searching the column MV bank to add MVs to the MV candidates. .
Fig. 15 is a flow diagram of a technique 1500 for decoding a current block. The technique 1500 may be implemented in whole or in part in the intra/inter prediction stage 508 of the decoder 500 of fig. 5. The technique 1500 can be implemented as a software program that can be executed by a computing device, such as the sending station 102 or the receiving station 106 of fig. 1. For example, the software program can include machine-readable instructions that can be stored in a memory, such as memory 204 or secondary storage 214 of fig. 2, and that when executed by a processor, such as CPU 202 of fig. 2, can cause the computing device to perform technique 1500. The technique 1500 can be implemented using specialized hardware or firmware. As described above, some computing devices may have multiple memories or processors, and may be capable of using multiple processors, memories, or both to distribute the operations described in technique 1500. The technique 1500 can be implemented using specialized hardware or firmware. Multiple processors, memories, or both may be used.
At 1502, the technique 1500 stores a first Motion Vector (MV) of a first block decoded prior to a current block in a row MV bank. The row MV bank can be associated with a row of superblocks including the first block and the current block, as described above with reference to fig. 9. At 1504, the technique 1500 obtains candidate MVs for decoding the current block. Candidate MVs can be stored in slots of the MV candidate list. The cardinality of candidate MVs is smaller than the size of the candidate MV list. Candidate MVs can be obtained by any conventional technique for obtaining MVs.
At 1506, the technique 1500 adds the first additional MV candidate to the candidate MV list using the row MV bank, as described above. At 1508, the technique 1500 decodes the current block using the candidate MVs of the candidate MV list.
In an example, the technique 1500 can further include: storing a second Motion Vector (MV) of a second block decoded before the current block in a column MV bank; and adding the second additional MV candidate to the candidate MV list using the column MV bank. The column MV bank can be associated with a column of super blocks including the second block and the current block.
For simplicity of explanation, 900, 1100, 1400, and 1500 of the techniques of fig. 9, 11, 14, and 15, respectively, are described as a series of steps or operations. However, steps or operations according to the present disclosure can occur in various orders and/or concurrently. Furthermore, other steps or operations not provided or described herein may be used. Furthermore, not all illustrated steps or operations are required to implement a method in accordance with the disclosed subject matter.
The above-described encoding and decoding aspects illustrate some examples of encoding and decoding techniques. It should be understood, however, that encoding and decoding, as those terms are used in the claims, may mean compression, decompression, transformation, or any other processing or change of data.
The word "example" is used herein to mean serving as an example, instance, or illustration. Any aspect or design described herein as "example" is not necessarily to be construed as preferred over other aspects or designs. Rather, use of the word "example" is intended to present concepts in a concrete fashion. As used in this application, the term "or" is intended to mean an inclusive "or", rather than an exclusive "or". That is, unless otherwise indicated or clear from the context, "X includes a or B" is intended to mean any natural inclusive permutation. That is, if X includes A; x comprises B; or X includes both A and B, then "X includes A or B" is satisfied in either of the above cases. Furthermore, the articles "a" and "an" as used in this application and the appended claims should generally be construed to mean "one or more" unless specified otherwise or clear from context to be directed to a singular form. Furthermore, the use of the terms "an embodiment" or "one embodiment" throughout are not intended to mean the same example or embodiment unless described so.
Embodiments of the sending station 102 and/or the receiving station 106 (and algorithms, methods, instructions, etc., stored thereon and/or executed thereby, including algorithms, methods, instructions, etc., executed by the encoder 400 and decoder 500) can be implemented in hardware, software, or any combination thereof. The hardware can include, for example, a computer, an Intellectual Property (IP) core, an Application Specific Integrated Circuit (ASIC), a programmable logic array, an optical processor, a programmable logic controller, microcode, a microcontroller, a server, a microprocessor, a digital signal processor, or any other suitable circuit. In the claims, the term "processor" should be understood to encompass any of the hardware described above, whether alone or in combination. The terms "signal" and "data" are used interchangeably. Furthermore, portions of the sending station 102 and the receiving station 106 do not necessarily have to be implemented in the same manner.
Furthermore, in one aspect, for example, the sending station 102 or the receiving station 106 can be implemented using a general-purpose computer or general-purpose processor with a computer program that, when executed, implements any of the respective methods, algorithms, and/or instructions described herein. Additionally or alternatively, for example, a special purpose computer/processor can be utilized that can contain other hardware for carrying out any of the methods, algorithms, or instructions described herein.
For example, the sending station 102 and the receiving station 106 can be implemented on computers in a video conferencing system. Alternatively, the sending station 102 can be implemented on a server and the receiving station 106 can be implemented on a device separate from the server, such as a handheld communication device. In this case, the transmitting station 102 can encode the content into an encoded video signal using the encoder 400 and transmit it to the communication device. Further, the communication device can then decode the encoded video signal using decoder 500. Alternatively, the communication device can decode content stored locally on the communication device (e.g., content that is not transmitted by the transmitting station 102). Other suitable transmit and receive implementations are also available. For example, the receiving station 106 can be a generally stationary personal computer rather than a portable communication device, and/or a device including the encoder 400 can also include the decoder 500.
Furthermore, all or part of the embodiments of the present disclosure can take the form of a computer program product accessible from a computer-usable or computer-readable medium. A computer-usable or computer-readable medium can be any apparatus that can, for example, tangibly contain, store, communicate, or transport the program for use by or in connection with any processor. The medium can be, for example, an electrical, magnetic, optical, electromagnetic or semiconductor device. Other suitable media are also available.
The foregoing examples, embodiments and aspects have been described in order to facilitate an understanding of the invention and are not limiting of the invention. On the contrary, the invention is intended to cover various modifications and equivalent arrangements included within the scope of the appended claims, which scope is to be accorded the broadest interpretation so as to encompass all such modifications and equivalent structures as is permitted under the law.
Claims (20)
1. A method for inter prediction, comprising:
code processing a first block of the current frame using a first Motion Vector (MV) and a reference frame type;
storing the first MV and the reference frame type in at least one MV buffer;
identifying MV candidates for code-processing the current block using the reference frame type;
in response to determining that the cardinality of the MV candidates is less than the maximum number of MV candidates:
identifying the first motion vector in the at least one MV buffer; and
in response to determining that the first MV is not included in the MV candidates, adding the first MV as a MV candidate; and
one of the MV candidates is selected for coding the current block.
2. The method of claim 1, further comprising:
code processing a second block of the current frame using a second MV and the reference frame type; and
In response to determining that the at least one MV buffer is not full, the second MV is added to the at least one MV buffer.
3. The method of claim 2, further comprising:
in response to determining that the at least one MV buffer is full:
removing previously added MVs from the at least one MV buffer; and
the second MV is added.
4. A method according to claim 3, wherein the previously added MV is at the head of the at least one MV buffer.
5. The method according to claim 2,
wherein the at least one MV buffer is an ordered list, and
wherein the second MV is stored at the tail of the at least one MV buffer, the method further comprising:
the first MV is moved to the tail of the at least one MV buffer in response to determining that the first MV is used for coding a third block.
6. The method of claim 1, further comprising:
in response to determining that the cardinality of the MV candidates is less than the maximum number of MV candidates, and that the first MV is included in the MV candidates,
identifying, in the at least one MV buffer, another MV that is different from the first MV and that is not included in the MV candidates; and
The other MV is added as another MV candidate.
7. The method of claim 6, wherein identifying the another MV in the at least one MV buffer comprises:
the at least one MV buffer is searched starting from the tail of the at least one MV buffer to identify the another MV.
8. The method of claim 1, wherein the reference frame type corresponds to a single reference frame prediction mode.
9. The method of claim 1, wherein the reference frame type corresponds to a composite reference frame prediction mode.
10. The method of claim 1, wherein the at least one MV buffer is associated with a row of superblocks or a column of superblocks of tiles of the current frame.
11. The method of claim 1, wherein the at least one MV buffer is associated with a row of superblocks or a column of superblocks of a slice of the current frame.
12. An apparatus for inter prediction, comprising:
a processor configured to:
obtaining a partition partitioning that partitions a current frame into super blocks, wherein the super blocks are arranged as rows of super blocks;
the row MV bank is initialized and,
Wherein each row MV bank is associated with one or more rows of the superblock and one or more reference frame types;
encoding a first block of a first one of the super blocks using a first Motion Vector (MV) and a reference frame type, wherein the first block is in a row of the super block;
storing the first MV in a row MV bank associated with the row of superblocks and the reference frame type;
obtaining MV candidates for code processing of a second block of a second super block using the reference frame type; and
the row MV bank associated with a row of a super block and the reference frame type are used to identify additional MV candidates for code processing of the second block on condition that the cardinality of the MV candidates is less than the maximum number of MV candidates.
13. The apparatus of claim 12, wherein identifying the additional MV candidates for encoding the second block using the row MV bank associated with the row of super block and the reference frame type comprises:
searching for MVs not included in the MV candidates in the row MV bank to add the MVs to the MV candidates.
14. The apparatus of claim 12, wherein the row MV bank is searched from a most recently added MV to an earliest added MV.
15. An apparatus according to claim 12,
wherein the first block is in a column of the super block, an
Wherein the processor is further configured to:
initializing column MV banks, wherein each column MV bank is associated with one or more columns of the superblock and the one or more reference frame types; and
the first MV is stored in a column MV bank associated with the column of the superblock and the reference frame type.
16. The apparatus of claim 15, wherein identifying the additional MV candidates for encoding the second block using the row MV bank associated with the row of super block and the reference frame type comprises:
searching the column MV bank for a MV that is not included in the MV candidate, and searching the row MV bank to add the MV to the MV candidate.
17. The apparatus of claim 12, wherein the reference frame type corresponds to a single reference prediction.
18. The apparatus of claim 12, wherein the reference frame type corresponds to a composite reference prediction.
19. A method for decoding a current block of a current frame, comprising:
Storing a first Motion Vector (MV) of a first block decoded before the current block in a row MV bank, wherein the row MV bank is associated with a row of a super block including the first block and the current block;
obtaining a candidate MV for decoding the current block, wherein the candidate MV is stored in a slot of a candidate MV list, and a cardinality of the candidate MV is smaller than a size of the candidate MV list;
adding a first additional MV candidate to the candidate MV list using the row MV bank; and
and decoding the current block by using the candidate MVs of the candidate MV list.
20. The method of claim 19, further comprising:
storing a second Motion Vector (MV) of a second block decoded before the current block in a column MV bank, wherein the column MV bank is associated with a column of a super block including the second block and the current block; and
a second additional MV candidate is added to the candidate MV list using the column MV bank.
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
PCT/US2021/041831 WO2023287418A1 (en) | 2021-07-15 | 2021-07-15 | Reference motion vector candidate bank |
Publications (1)
Publication Number | Publication Date |
---|---|
CN117643050A true CN117643050A (en) | 2024-03-01 |
Family
ID=77127124
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN202180100419.2A Pending CN117643050A (en) | 2021-07-15 | 2021-07-15 | Reference motion vector candidate library |
Country Status (3)
Country | Link |
---|---|
EP (1) | EP4352958A1 (en) |
CN (1) | CN117643050A (en) |
WO (1) | WO2023287418A1 (en) |
Family Cites Families (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
WO2017131908A1 (en) * | 2016-01-29 | 2017-08-03 | Google Inc. | Dynamic reference motion vector coding mode |
WO2020125738A1 (en) * | 2018-12-21 | 2020-06-25 | Huawei Technologies Co., Ltd. | An encoder, a decoder and corresponding methods using history based motion vector prediction |
CN111213381B (en) * | 2018-12-29 | 2021-11-12 | 深圳市大疆创新科技有限公司 | Video processing method and device |
-
2021
- 2021-07-15 WO PCT/US2021/041831 patent/WO2023287418A1/en active Application Filing
- 2021-07-15 CN CN202180100419.2A patent/CN117643050A/en active Pending
- 2021-07-15 EP EP21748772.7A patent/EP4352958A1/en active Pending
Also Published As
Publication number | Publication date |
---|---|
WO2023287418A1 (en) | 2023-01-19 |
EP4352958A1 (en) | 2024-04-17 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US10986361B2 (en) | Video coding using reference motion vectors | |
US11405631B2 (en) | Constrained motion field estimation for hardware efficiency | |
US10555000B2 (en) | Multi-level compound prediction | |
US10484707B1 (en) | Dynamic reference motion vector coding mode | |
US11284107B2 (en) | Co-located reference frame interpolation using optical flow estimation | |
CN107205156B (en) | Motion vector prediction by scaling | |
CN107231557B (en) | Encoding, decoding methods and apparatus for intelligent reordering in recursive block partitioning for advanced intra prediction in video coding | |
US11025950B2 (en) | Motion field-based reference frame rendering for motion compensated prediction in video coding | |
US20170272773A1 (en) | Motion Vector Reference Selection Through Reference Frame Buffer Tracking | |
US10582212B2 (en) | Warped reference motion vectors for video compression | |
US10951894B2 (en) | Transform block-level scan order selection for video coding | |
WO2019036080A1 (en) | Constrained motion field estimation for inter prediction | |
US8611415B1 (en) | System and method for coding using improved motion estimation | |
US20190058883A1 (en) | Modifying a scan order to limit scan distance | |
CN117643050A (en) | Reference motion vector candidate library | |
US10412383B2 (en) | Compressing groups of video frames using reversed ordering | |
US10701364B2 (en) | Golden-frame group structure design using stillness detection |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
SE01 | Entry into force of request for substantive examination |