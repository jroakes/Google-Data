US5881380A - Device and method for data management based on values - Google Patents
Device and method for data management based on values Download PDFInfo
- Publication number
- US5881380A US5881380A US08/632,362 US63236296A US5881380A US 5881380 A US5881380 A US 5881380A US 63236296 A US63236296 A US 63236296A US 5881380 A US5881380 A US 5881380A
- Authority
- US
- United States
- Prior art keywords
- values
- value
- data
- descriptions
- pointers
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Lifetime
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/21—Design, administration or maintenance of databases
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99941—Database schema or data structure
- Y10S707/99942—Manipulating data structure, e.g. compression, compaction, compilation
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99941—Database schema or data structure
- Y10S707/99943—Generating database or data structure, e.g. via user interface
Definitions
- the present invention generally relates to data-management devices and data-management methods such as databases, and particularly relates to a data-management device and a data-management method which determine a data structure while storing data.
- Data-management methods used in databases and the like include a relation-type data-management method expressing relations between objects by using tables and a network-type data-management method linking each object by representing relations between objects by using links. These two methods are those most commonly used in the field.
- a schema (information about a data structure of stored data) should be decided first, and, then, values of data are stored based on the determined data structure. Namely, a schema must be decided by estimating usage of stored data prior to the development of databases.
- objects can inherit attributes from more general objects. Based on this inheritance relation, data can be organized by grouping objects of upper-level concepts and objects of lower-level concepts together. Thus, data management can be efficiently carried out. Even in such data-management devices employing the object-oriented scheme, values of each data can be stored only after a data structure of objects representing concepts is determined.
- the data-management devices based on the object-oriented scheme, there is a case in which a gap develops between concepts represented by objects and values to be stored, as the values of data are accumulated in the databases. Namely, as the values are accumulated after deciding on a data structure representing concepts from upper levels to lower levels, a new data structure may become necessary to represent new concepts, or concepts based on the existing data structure may be required to be modified. In this case, the data-management devices of the related art need reentry of all the data after newly developing a data structure representing the upper-level concepts.
- a method of data management includes the steps of receiving a plurality of values, obtaining descriptions, each of the descriptions describing a corresponding one of the values, linking each of the values with a corresponding one of the descriptions, generating pointers, each of the pointers pointing to a corresponding one of the values, organizing the pointers in an arrangement representing a set having the values as elements, obtaining a description of the set, and linking the arrangement with the description of the set, wherein a data structure relating the values with each other is determined by the arrangement through accumulation of the values.
- the device for data management includes an inputting unit for receiving values and first descriptions, each of the first descriptions describing a corresponding one of the values, a collecting unit for putting some of the values together to create a set, the collecting unit comprising a first unit for generating pointers, each of the pointers pointing to a corresponding one of the some of the values, and a second unit for organizing the pointers in an arrangement representing the set having the some of the values as elements, wherein a plurality of sets equivalent to the set are created and the sets are treated as the values, an analyzing unit for generating second descriptions, each of the second descriptions describing a corresponding one of the values, a link unit for linking each of the values with a corresponding one of the first descriptions and a corresponding one of the second descriptions, and a storing unit for storing the values including the sets, the first descriptions, and the second descriptions, wherein a data structure relating the values with each other is determined by the arrangement through accumulation of the values.
- the set values are formed by putting the values together, so that the data structure can be determined through accumulation of the values. Therefore, there is no need to determine a schema in advance. Also, an appropriate data structure can be generated in accordance with usage of the values through the accumulation of the values.
- the set values have a structure in which the values are linked through the pointers.
- This data structure does not need definitions of data sizes and data types as needed in an array or a structure. Therefore, even when the data structure is changed within a purview of the present invention, application programs are free from a failure to read the values because of data-size mismatches and data-type mismatches. Also, this makes it easier to develop application programs after a change in the data structure or an addition of a new data structure.
- the data structure is determined by using the values actually accumulated in the database rather than by projecting the usage of the values in advance.
- the data structure thus created is an appropriate reflection of the usage of the values actually stored in the database.
- FIGS. 1A and 1B are illustrative drawings showing a principle of the present invention
- FIGS. 2A and 2B are illustrative drawings showing relations between attribute values, records, and a table
- FIG. 3 is a block diagram of a data-management device according to an embodiment of the present invention.
- FIG. 4 is a flowchart of a process of storing values according to the embodiment of the present invention.
- FIG. 5 is a flowchart of a process of generating a set value according to the embodiment of the present invention.
- FIGS. 6A and 6B are illustrative drawings for explaining a value copying function
- FIGS. 7A and 7B are illustrative drawings for explaining a value generating function
- FIGS. 8A and 8B are illustrative drawings for explaining a value inserting function
- FIG. 9 is an illustrative drawing showing a structure of indexes used when a search is conducted by using a recognition module as a search condition according to the embodiment of the present invention.
- FIG. 10 is a flowchart of a process of searching for values by using the recognition module as a search condition
- FIG. 11 is a flowchart of a process of giving indexes to single values for a set value (table) having set values as constituent elements with these set values having these single values as constituent elements;
- FIG. 12 is a flowchart of a process of searching for values by using values as a search condition
- FIG. 13 is an illustrative drawing for explaining a value grouping process by a super-class generating unit of FIG. 3;
- FIG. 14 is a flowchart of the value grouping process by the super-class generating unit.
- FIGS. 1A and 1B are illustrative drawings showing a principle of the present invention.
- a description is attached to the value.
- the description attached to the value is comprised of a memory module and a recognition module.
- the memory module is always attached thereto, but the recognition module may or may not be attached thereto.
- the memory module includes two elements. One is a name of the value given by a user, and the other is a date and a time automatically given by the data-management device. The date and time record the date and time when the value is stored.
- the recognition module is an arbitrary description of the stored value other than the name and the date and time. For example, the recognition module may include management information useful for data management such as an owner's name, and may include attribute information for representing features of the stored value.
- the memory module and the recognition module both of which are information for describing the value.
- the purpose of the classification of the memory module and the recognition module is to distinguish mandatory information from non-essential information.
- the mandatory information is the name and the date and time which are stored as the memory module, and the non-essential information is stored as the recognition module.
- the mandatory information does not always have to be the name and the date and time, but other information may be used as the mandatory information.
- information about a type of a value is implicitly attached to the value itself, and, therefore, need not be included in the memory module or the recognition module.
- the value, the memory module, and the recognition module may be related with each other by a pointer indicating each of them, for example.
- a method of storing the value and these modules in relation with each other is not limited to any particular type of a data structure.
- a comparison can be made between different values.
- a method of the comparison can be determined for each element. For example, it is possible to compare the date and time of the memory module between different values so as to sort the values chronologically.
- a plurality of values can be collected together to treat them as one value.
- a value serving as the smallest unit is called a single value
- a value comprised of a set of single values is called a set value.
- FIG. 1B In the example of FIG. 1B, five single values 1 through 5 are collected together to form a set value.
- a structure of the set value is represented by an arrangement of the memory modules attached to the single values. Namely, although a single value has a memory module and a recognition module, only the memory modules of the single values are shown in FIG. 1B.
- a similar illustration will be used throughout this description to represent a structure of a set value in the data-management device of the present invention. Namely, an arrangement of memory modules or an arrangement of names will be typically used to represent the structure of a set value.
- a set of pointers (an array of pointers) is used as shown in FIG. 1B.
- Each of the pointers corresponds to one of the values 1 through 5, and a set of the pointers is regarded as one set value.
- the pointers are sorted in a particular order.
- one set value may have a plurality of sets of pointers arranged in different orders. For example, one arrangement is made by sorting the pointers based on certain information contained in the recognition modules, and another arrangement is made by sorting the pointers based on the dates contained in the memory modules to represent an order in which the values are stored. Also, it should be apparent that constituent elements of a set value may be other set values instead of single values.
- FIGS. 2A and 2B are illustrative drawings showing relations between attribute values, records, and a table.
- FIG. 2A shows a table listing country data.
- a set value can be formed by using each data of the United States as a single value, for example.
- a name of this set value is "US”
- this set value includes a country name, population data, and area data of the United States as constituent elements. Namely, this set value can be regarded as a record named "US”.
- set values for Japan and the United Kingdom are created in the same manner as for the United States.
- a set value having the set values "US", "JAPAN”, and "UK” as constituent elements can be regarded as a table having a name "COUNTRY DATA".
- FIG. 2B shows a data structure of the set value corresponding to the table.
- the set value having the name "COUNTRY DATA” is comprised of the set values "US", "JAPAN”, and "UK".
- a set value according to the principle of the present invention has double aspects corresponding to the two concepts, i.e., the record and the table of the relational database.
- FIG. 2B only names of the memory modules are shown, and the date and time of the memory modules and the recognition modules are omitted.
- the values are stored with the descriptions thereof attached thereto, so that the values can be used as a database. Also, since the set values are formed by putting the values together, a structure of the values, i.e., a data structure, can be determined through accumulation of the values. Therefore, there is no need to determine a schema in advance. Also, an appropriate data structure can be generated in accordance with usage of the values through the accumulation of the values.
- the set values have a structure in which the values are linked through the pointers.
- This data structure does not need definitions of data sizes and data types as needed in an array or a structure. Therefore, even when the data structure is changed within a purview of the present invention, application programs are free from a failure to read the values because of data-size mismatches and data-type mismatches.
- FIG. 3 is a block diagram of a data-management device according to the embodiment of the present invention.
- a data-management device 10 includes a data inputting unit 11, an input analyzing unit 12, a processing unit 13, a data-storage processing unit 14, and a data storing unit 15.
- the data inputting unit 11 includes at least one input device such as a keyboard, and receives data inputs and command inputs from a user to supply them to the input analyzing unit 12.
- the input analyzing unit 12 includes a CPU (central processing unit) and a memory, and generates a procedure to be processed by the processing unit 13 based on the inputs from the user. Also, the input analyzing unit 12 generates some elements of the memory module and the recognition module which can be automatically generated (e.g., the date and time).
- the processing unit 13 includes a CPU and a memory, and carries out a required process based on the procedure generated by the input analyzing unit 12.
- the data inputs from the user are supplied to the processing unit 13 via the input analyzing unit 12, and are subjected to various processes such as storing, adding, and modifying of values.
- Values, memory modules, and recognition modules generated by the processing unit 13 in the memory are stored by the data-storage processing unit 14 in the data storing unit 15, which is long-term data storage means.
- the data-storage processing unit 14 reads these pieces of data from the data storing unit 15.
- the data storing unit 15 is an external memory such as a hard drive, and stores the values, the memory modules, and the recognition modules.
- the processing unit 13 includes a process controlling unit 20, a value generating unit 21, a set-value generating unit 22, a super-class generating unit 23, an attribute-index generating unit 24, and a search unit 25.
- the process controlling unit 20 controls other elements of the processing unit 13, and is responsible for data exchanges between these elements and the input analyzing unit 12.
- the value generating unit 21 acquires memory areas in the memory for a single value or a set value, a memory module, and a recognition module, and, then, sets data in these memory areas. Also, the value generating unit 21 releases these memory areas in the memory to delete the values.
- the set-value generating unit 22 generates a set value by selecting values (single values or set values) and putting them together, based on contents of the memory modules and the recognition modules and structures of the recognition modules.
- the structure of the recognition module is defined by the number and types of elements in the recognition module.
- the super-class generating unit 23 extracts common elements of recognition modules from a plurality of values selected by the user, and forms a set of common recognition-module elements. Then, the super-class generating unit 23 generates a super class by attaching a memory module to the set of common recognition-module elements.
- the memory module of the generated super class is linked through pointers with the plurality of values selected by the user.
- the attribute-index generating unit 24 generates indexes used when data is searched for in the set values serving as tables.
- a set value is regarded as a table, and constituent elements of the set value are regarded as records. Also, further constituent elements of the constituent elements are regarded as attributes of the tables. The indexes are attached to these attributes.
- the search unit 25 carries out the search, updating, and removal of the data by treating the set value as a table and constituent elements of the set value as records.
- FIG. 4 is a flowchart of a process of storing values according to the embodiment of the present invention. The process of FIG. 4 is carried out by the value generating unit 21 of the processing unit 13 in FIG. 3, generating a data structure as shown in FIG. 1A.
- the value generating unit 21 receives a value from the input analyzing unit 12.
- the value generating unit 21 receives a memory module from the input analyzing unit 12.
- the value generating unit 21 checks whether a recognition module is provided from the input analyzing unit 12. If it is, the procedure goes to a step S4. Otherwise, the procedure goes to a step S5.
- the value, the memory module, and the recognition module are connected with each other through links. That is, each is linked by a pointer.
- the value and the memory module are connected through a link. This ends the procedure.
- FIG. 5 is a flowchart of a process of generating a set value according to the embodiment of the present invention. The process of FIG. 5 is carried out by the set-value generating unit 22 of the processing unit 13 in FIG. 3, generating a data structure as shown in FIG. 1B.
- values to be put together are selected.
- the selection of the values is made based on the contents of memory modules and recognition modules as well as the structures of the recognition modules defined by the number and types of the recognition-module elements.
- a single value corresponding to population data has a name "POPULATION” in the memory module thereof. Therefore, it is possible to select single values regarding population data by using the name "POPULATION” as a keyword.
- These single values may have attribute data "COUNTRY POPULATION DATA" in the recognition modules thereof. Therefore, it is possible to select these single values regarding population data by using the attribute data "COUNTRY POPULATION DATA" as a keyword.
- conditions for selecting the values can be set based on the number and types of elements contained in a recognition module.
- a set of pointers pointing to values is generated.
- the values can be treated as one set.
- the pointers are sorted based on an appropriate element of the memory module or the recognition module.
- the sorting of the pointers may be based on the date and time of the memory module, or may be based on an alphabetical order of the name. Conditions of the sorting may be preset as default, or may be determined each time a set value is generated. Also, a plurality of sets of pointers may be generated to represent different orders.
- a set value is generated by attaching a memory module and a recognition module, if necessary, to a set of the values. This ends the process of generating a set value.
- the data-management device 10 of FIG. 3 can store the value, the memory module, and the recognition module in a form as shown in FIG. 1A or 1B, respectively. In doing so, the value is stored with a description thereof attached thereto, so that the value can be used in a database. Also, since the data structure is determined through accumulation of the values, there is no need to determine a schema in advance. Further, an appropriate data structure can be generated in accordance with usage of the values through the accumulation of the values.
- the data-management device 10 provides various functions of manipulating the values (single values and set values). These functions include copying, generating, inserting, deleting, destroying, adding to a value, removing from a value, etc. Each function will be briefly described below. Here, all the functions of manipulating values are provided for the manipulating of existing values, and there is no concept in the present invention of the manipulation of schema.
- FIGS. 6A and 6B are illustrative drawings for explaining a value copying function.
- the value copying function may be used when a value having the same contents as an existing value is newly stored. As shown in the figure, a value copying process is carried out by newly generating the same value as an existing value through the replication of the existing value. The newly generated value is linked to the memory module of the existing value. When the existing value is a set value, a newly generated value will point to the constituent elements of the existing value.
- FIGS. 7A and 7B are illustrative drawings for explaining a value generating function.
- the value generating function may be used when a value having the same description as an existing value is newly stored.
- a value generating process generates a new value, and links it with the memory module of an existing value.
- the new value will have the specific value.
- the new value has an indeterminate content (the content of the new value is yet to be decided).
- FIGS. 8A and 8B are illustrative drawings for explaining a value inserting function.
- the value inserting function may be used when a value is newly added to an existing value.
- the existing value When the existing value is a single value, it will become a set value after the insertion.
- values 1 through 4 constitute an existing set value.
- a set value By adding a value 5 to the existing set value, a set value comprising the values 1 through 5 is created.
- a new pointer is allocated to the value 5, and is added to an existing set of pointers.
- a value deleting function removes a value having an indicated description from an existing value.
- This value deleting function is a reversed process of the value inserting function of FIGS. 8A and 8B. If the existing value is a single value, the value deleting function will delete only one remaining value. In this case, thus, the value deleting function means a deletion of the existence of the value.
- a destroying function decreases the number of references made by set values.
- each value is made reference to by a plurality of set values, and the number of these references is recorded. If the number of references is zero, the destroying function deletes an existing value from the data storing unit 15. The destroying function deletes a value itself if it is a single value, and deletes a set of pointers if the value is a set value.
- a value adding function adds values with the same description to all values included in a set value.
- the value adding function may add another item to each country in addition to the items "COUNTRY NAME", “POPULATION”, and "AREA", for example. That is, an item “GDP” may be added to store GDP (gross domestic product) data of each country.
- a column “GDP” is added to the right-hand side of the table.
- a single value having a name "GDP" and the same description for each country is added to a set value of each country as a new constituent element.
- a value removing function removes values with the same description from all values included in a set value. This value removing function carries out a reverse process of the value adding function described above. The value removing function does not remove a value itself having an indicated description.
- a recognition-module copying function duplicates a description of an existing value for another value. That is, the description is added to a description of another value.
- a recognition-module adding function adds a new description to a value.
- a recognition-module removing function removes the same description as an indicated description from a description of a value.
- a recognition-module modifying function modifies a specific description to an indicated description.
- a value can be searched for by using the recognition module as a search condition. For example, values having a name "COUNTRY NAME" may be searched for, or values created within the last two months may be searched for.
- the memory module is also called the recognition module unless there is a need for the distinction.
- FIG. 9 is an illustrative drawing showing a structure of indexes used when a search is conducted by using the recognition module as a search condition according to the embodiment of the present invention. Since the recognition module is used as a search condition, indexes are prepared for each recognition module element.
- recognition-module-element-1 indexes, recognition-module-element-2 indexes, and recognition-module-element-3 indexes are provided.
- recognition-module elements such as the name, the date and time, and the owner
- name indexes, date-and-time indexes, and owner indexes are prepared, respectively.
- each index of the name indexes points to the name of a corresponding value.
- Each index of the owner indexes points to the owner of a corresponding value which has the owner as a recognition-module element.
- recognition-module-element-index indexes are prepared to index the recognition-module-element indexes. This is a mechanism to assure a rapid access to the recognition-module-element indexes since the number of the recognition-module-element indexes becomes numerous.
- FIG. 10 is a flowchart of a process of searching for values by using the recognition module as a search condition.
- values are searched for based on the recognition module, and a set value is created by putting selected values together.
- This searching process is implemented by the set-value generating unit 22 of FIG. 3. That is, the flowchart of FIG. 10 corresponds to a search process automatically carrying out the selection of values at the step S11 of FIG. 5 by the set-value generating unit 22.
- names of recognition-module elements and conditions of these recognition-module elements are indicated.
- the name of one recognition-module element may be "date and time”, and the condition may be "within the last three month”.
- the indicated names of the recognition-module elements are searched for in the recognition-module-element-index indexes, and the indicated-recognition-module-element indexes are extracted.
- an empty set value is prepared to store selected values.
- a set value putting the selected values together can be created.
- a recognition module is attached to the empty set value.
- recognition-module elements satisfying the indicated conditions are searched for by using the indicated-recognition-module-element indexes, and values satisfying the conditions are selected.
- the selected values are stored in the set value. This ends the procedure.
- the set-value generating unit 22 carries out the search process as described above, so that values are searched for based on search conditions of the recognition-module elements. Since the recognition-module-element indexes and the recognition-module-element-index indexes are used in the search, the values are searched for at high speed.
- the embodiment of the present invention is provided with another search method which extracts set values or single values (constituent elements) of the set values based on conditions of values. For example, countries (set values) with a population less than two million may be extracted, or areas (single values) of the countries with a population less than two million may be extracted. In the search based on conditions of values, indexes are prepared to speed up the search.
- FIG. 11 is a flowchart of a process of giving indexes to single values for a set value (table) having set values as constituent elements with these set values having these single values as constituent elements. This corresponds to the indexing of attribute values of each record in the table.
- the process of giving indexes is carried out by attribute-index generating unit 24 of FIG. 3.
- a set value used as a table is extracted.
- a name to be indexed is indicated. For example, when the population data in the table of FIG. 2A is to be indexed, the name "POPULATION" is indicated.
- the single value having the indicated name is indexed, and this index is stored in one of the empty indexes.
- generated indexes are linked to the memory module of the set value (table). By doing so, the generated index table can be used for searching attribute values in the table.
- FIG. 12 is a flowchart of a process of searching for values by using values as a search condition. This process of searching for values is carried out by the search unit 25 of FIG. 3.
- a set value treated as a table is extracted.
- a search condition and a name of a value used for the search condition are indicated.
- an empty set value for storing selected values is prepared.
- values satisfying the indicated search condition are searched for by using indexes, and the selected values are stored in the empty set value.
- step S48 values satisfying the indicated search condition are searched for one by one, and the selected values are stored in the empty set value.
- the search unit 25 carries out the search process described above, so that values are searched for based on a search condition using an indicated value. Since the attribute-index generating unit 24 can index the values in advance, the search can be conducted at high speed.
- FIG. 13 is an illustrative drawing for explaining a value grouping process by the super-class generating unit 23 of FIG. 3.
- values bearing similar features are grouped together. By grouping the values in this manner, the values bearing similar features can be reused without explicitly conducting a search.
- common recognition-module elements are extracted from a plurality of values, and a super class having these common recognition-module elements is generated.
- a user may newly add a common concept to the recognition module of the super class.
- the generated super class is then provided with the memory module. This memory module is linked to the values from which the common recognition-module elements are extracted.
- FIG. 14 is a flowchart of the value grouping process by the super-class generating unit 23.
- values having similar structures are selected.
- the selection of the values may be made by a user.
- the data-management device may present a tentative list of values having similar structures, and, then, the user may select the values having similar structures from this list.
- common recognition-module elements shared by all the selected values are searched for and copied from the recognition modules of the selected values.
- the common recognition-module elements thus copied are stored as one set.
- a memory module is attached to the set of common recognition-module elements.
- a name is provided by the user.
- the memory module is linked through pointers with the values from which the common recognition-module elements are extracted. This ends the procedure.
- the super-class generating unit 23 carries out the value grouping process as described above, so that values bearing similar features can be categorized as lower-level concepts of a more general super class comprised of the similar features. That is, the super class represents purely the common features, and the values having the common features plus individual features are placed as the lower-level concepts under the super class. In this manner, grouping of data based on upper-level concepts and lower-level concepts is carried out through accumulation of values without determining a schema in advance.
- a value having a content "120 million” and a name “POPULATION” shown in FIG. 2B is used as an example for explanation. Assuming that this value has a recognition-module element "Japan's population in 1988", the value and the description thereof will be represented as "120 million: population, Japan's population in 1988" for the sake of explanation.
- a user starts operating the data-management device 10, and modifies the value "120 million” to a value "121 million”. In this case, the data-management device 10 of the present invention does not immediately delete the original value "120 million”. Instead, the data-management device 10 keeps the original value and the description "120 million: population, Japan's population in 1988" in the data storing unit 15. For the user, it seems that the user has modified the data of the database. In reality, however, the original value in the data storing unit 15 is separated from the value in the memory manipulated by the user.
- the user modifies the recognition module from "Japan's population in 1988” to "Japan's population in 1993".
- the data-management device 10 notifies the user that the data "120 million: population, Japan's population in 1988” is changed to the data "121 million: population, Japan's population in 1993".
- the user determines whether to delete the original value or to retain it, thereby sorting out relations between values having the same name.
- a plurality of values having the same name "POPULATION” can exist.
- the user can given an instruction to retain the original value.
- the modified value not the original value, is used in the set value of the country data shown in FIG. 2B.
- the original data is stored separately from the set value of the country data as a collection of the value, the memory module, and the recognition module.
- each value can be distinguished based on the description of the recognition module.
- the data-management method generates set values having values as constituent elements through the accumulation of values, so that a data structure relating the values with each other need not be determined in advance.
- a single value, a set value comprised of a plurality of single values, and a set value comprised of a plurality of set values are treated in the same manner.
- values serving as constituent values of a set value are stored after they are sorted in a specific arrangement, so that a comparison between different set values is easily made.
- copying of a value provides a function of manipulating values based on a defined data structure.
- generation of a new value having the same description as an existing value provides a function of manipulating values based on an existing data structure.
- an addition of a constituent element to a set value provides a function of manipulating values based on a defined data structure.
- a removal of a constituent element from a set value provides a function of manipulating values based on a defined data structure.
- a function of removing a set value is provided.
- a description of a value is comprised of a plurality of recognition-module elements, so that each element of the description can be treated separately.
- one or more of the plurality of recognition-module elements can be used for a search condition to conduct a search for values.
- indexes are provided for each of the recognition-module elements, and, also, indexes for these indexes are provided, so that a search using one of the recognition-module elements as a search condition can be conducted at high speed.
- the description of a value includes a name of the value, so that the value can be identified by using the name.
- a value or a set value comprised of values can be searched for by using a value as a search condition.
- indexes are generated for values having an indicated name, so that a search using a value as a search condition is carried out at high speed.
- values having the same name are treated separately, and are sorted out at the end of an operation, so that an integrity of the values can be maintained.
Abstract
Description
Claims (33)
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
JP7234380A JPH0981582A (en) | 1995-09-12 | 1995-09-12 | Method and device for data management based on value |
JP7-234380 | 1995-09-12 |
Publications (1)
Publication Number | Publication Date |
---|---|
US5881380A true US5881380A (en) | 1999-03-09 |
Family
ID=16970101
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US08/632,362 Expired - Lifetime US5881380A (en) | 1995-09-12 | 1996-04-11 | Device and method for data management based on values |
Country Status (2)
Country | Link |
---|---|
US (1) | US5881380A (en) |
JP (1) | JPH0981582A (en) |
Cited By (8)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6253264B1 (en) * | 1997-03-07 | 2001-06-26 | Intelligent Compression Technologies | Coding network grouping data of same data type into blocks using file data structure and selecting compression for individual block base on block data type |
WO2002001395A1 (en) * | 2000-06-27 | 2002-01-03 | Ubs Ag | Method and system for providing distributed functionality and data analysis system utilizing same |
EP1202191A2 (en) * | 2000-10-31 | 2002-05-02 | Kabushiki Kaisha Toshiba | Data management method and storage medium storing data management program |
US20030235189A1 (en) * | 2002-06-04 | 2003-12-25 | Mathews Gregory S. | Pointer allocation by prime numbers |
US6694324B1 (en) | 1999-12-16 | 2004-02-17 | Ncr Corporation | Determination of records with a specified number of largest or smallest values in a parallel database system |
US20040139221A1 (en) * | 2002-12-02 | 2004-07-15 | Knut Heusermann | Data structure mapping and packaging |
US20110040808A1 (en) * | 2009-08-13 | 2011-02-17 | Microsoft Corporation | Distributed analytics platform |
US8255504B1 (en) * | 2006-10-03 | 2012-08-28 | United States Automobile Association (USAA) | Systems and methods for data source management |
Citations (21)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4989141A (en) * | 1987-06-01 | 1991-01-29 | Corporate Class Software | Computer system for financial analyses and reporting |
US5062074A (en) * | 1986-12-04 | 1991-10-29 | Tnet, Inc. | Information retrieval system and method |
US5119465A (en) * | 1989-06-19 | 1992-06-02 | Digital Equipment Corporation | System for selectively converting plurality of source data structures through corresponding source intermediate structures, and target intermediate structures into selected target structure |
US5175810A (en) * | 1989-06-19 | 1992-12-29 | Digital Equipment Corporation | Tabular data format |
US5189608A (en) * | 1987-06-01 | 1993-02-23 | Imrs Operations, Inc. | Method and apparatus for storing and generating financial information employing user specified input and output formats |
US5359724A (en) * | 1992-03-30 | 1994-10-25 | Arbor Software Corporation | Method and apparatus for storing and retrieving multi-dimensional data in computer memory |
US5434971A (en) * | 1991-06-28 | 1995-07-18 | Digital Equipment Corp. | System for constructing a table data structure based on an associated configuration data structure and loading it with chemical sample physical data |
US5452440A (en) * | 1993-07-16 | 1995-09-19 | Zitel Corporation | Method and structure for evaluating and enhancing the performance of cache memory systems |
US5471596A (en) * | 1992-04-13 | 1995-11-28 | Digital Equipment Corporation | Computer memory device holding a data structure for implementation of function objects |
US5479614A (en) * | 1989-09-14 | 1995-12-26 | Fujitsu Limited | Object sensor processing method and processor |
US5481718A (en) * | 1993-05-21 | 1996-01-02 | Fujitsu Limited | Object-oriented system having object models containing plural objects with instantiation following static classification by class relationships, dynamic classification by temporal instantiation, and causality restrictions |
US5481692A (en) * | 1989-10-12 | 1996-01-02 | Fujitsu Limited | Computing system for data processing apparatus |
US5504886A (en) * | 1993-07-02 | 1996-04-02 | International Business Machines Corporation | System and method for applying user supplied relation definitions to application files for a relational database |
US5513348A (en) * | 1989-10-17 | 1996-04-30 | Fujitsu Limited | System for relational database retrieval through a link file built to access components of relational tables |
US5548751A (en) * | 1990-03-16 | 1996-08-20 | Fujitsu Limited | Dynamic data storage system allowing variable size records and fields by using linked record segments |
US5557787A (en) * | 1993-02-18 | 1996-09-17 | Fuji Xerox Co., Ltd. | Table generating apparatus employing heading, layout, and table script data |
US5560012A (en) * | 1993-05-25 | 1996-09-24 | Fujitsu Limited | Object-oriented data processing system |
US5594836A (en) * | 1993-05-25 | 1997-01-14 | Fujitsu Limited | Ennoversion management system for data processing system |
US5634048A (en) * | 1989-09-14 | 1997-05-27 | Fujitsu Limited | Distributed database system having a center system with a link file and a method for retrieving data from same |
US5675784A (en) * | 1995-05-31 | 1997-10-07 | International Business Machnes Corporation | Data structure for a relational database system for collecting component and specification level data related to products |
US5680618A (en) * | 1993-05-26 | 1997-10-21 | Borland International, Inc. | Driver query and substitution for format independent native data access |
-
1995
- 1995-09-12 JP JP7234380A patent/JPH0981582A/en not_active Withdrawn
-
1996
- 1996-04-11 US US08/632,362 patent/US5881380A/en not_active Expired - Lifetime
Patent Citations (22)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5062074A (en) * | 1986-12-04 | 1991-10-29 | Tnet, Inc. | Information retrieval system and method |
US4989141A (en) * | 1987-06-01 | 1991-01-29 | Corporate Class Software | Computer system for financial analyses and reporting |
US5189608A (en) * | 1987-06-01 | 1993-02-23 | Imrs Operations, Inc. | Method and apparatus for storing and generating financial information employing user specified input and output formats |
US5119465A (en) * | 1989-06-19 | 1992-06-02 | Digital Equipment Corporation | System for selectively converting plurality of source data structures through corresponding source intermediate structures, and target intermediate structures into selected target structure |
US5175810A (en) * | 1989-06-19 | 1992-12-29 | Digital Equipment Corporation | Tabular data format |
US5280575A (en) * | 1989-06-19 | 1994-01-18 | Digital Equipment Corporation | Apparatus for cell format control in a spread sheet |
US5479614A (en) * | 1989-09-14 | 1995-12-26 | Fujitsu Limited | Object sensor processing method and processor |
US5634048A (en) * | 1989-09-14 | 1997-05-27 | Fujitsu Limited | Distributed database system having a center system with a link file and a method for retrieving data from same |
US5481692A (en) * | 1989-10-12 | 1996-01-02 | Fujitsu Limited | Computing system for data processing apparatus |
US5513348A (en) * | 1989-10-17 | 1996-04-30 | Fujitsu Limited | System for relational database retrieval through a link file built to access components of relational tables |
US5548751A (en) * | 1990-03-16 | 1996-08-20 | Fujitsu Limited | Dynamic data storage system allowing variable size records and fields by using linked record segments |
US5434971A (en) * | 1991-06-28 | 1995-07-18 | Digital Equipment Corp. | System for constructing a table data structure based on an associated configuration data structure and loading it with chemical sample physical data |
US5359724A (en) * | 1992-03-30 | 1994-10-25 | Arbor Software Corporation | Method and apparatus for storing and retrieving multi-dimensional data in computer memory |
US5471596A (en) * | 1992-04-13 | 1995-11-28 | Digital Equipment Corporation | Computer memory device holding a data structure for implementation of function objects |
US5557787A (en) * | 1993-02-18 | 1996-09-17 | Fuji Xerox Co., Ltd. | Table generating apparatus employing heading, layout, and table script data |
US5481718A (en) * | 1993-05-21 | 1996-01-02 | Fujitsu Limited | Object-oriented system having object models containing plural objects with instantiation following static classification by class relationships, dynamic classification by temporal instantiation, and causality restrictions |
US5560012A (en) * | 1993-05-25 | 1996-09-24 | Fujitsu Limited | Object-oriented data processing system |
US5594836A (en) * | 1993-05-25 | 1997-01-14 | Fujitsu Limited | Ennoversion management system for data processing system |
US5680618A (en) * | 1993-05-26 | 1997-10-21 | Borland International, Inc. | Driver query and substitution for format independent native data access |
US5504886A (en) * | 1993-07-02 | 1996-04-02 | International Business Machines Corporation | System and method for applying user supplied relation definitions to application files for a relational database |
US5452440A (en) * | 1993-07-16 | 1995-09-19 | Zitel Corporation | Method and structure for evaluating and enhancing the performance of cache memory systems |
US5675784A (en) * | 1995-05-31 | 1997-10-07 | International Business Machnes Corporation | Data structure for a relational database system for collecting component and specification level data related to products |
Non-Patent Citations (6)
Title |
---|
"Planning and Execution of Micro CAAT", Computer Audit Update, Nov. 1993. |
Ceri et al. "Supporting Interoperability Between New Database Languages", Compeuro /91 Advanced Computer Technology, Reliable Systems and Applications, pp. 273-281, May 1991. |
Ceri et al. Supporting Interoperability Between New Database Languages , Compeuro /91 Advanced Computer Technology, Reliable Systems and Applications, pp. 273 281, May 1991. * |
Chawathe et al. "The TSMIS Project: Integration of Heterogeneous Information Souces", Oct. 1994. |
Chawathe et al. The TSMIS Project: Integration of Heterogeneous Information Souces , Oct. 1994. * |
Planning and Execution of Micro CAAT , Computer Audit Update, Nov. 1993. * |
Cited By (16)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6253264B1 (en) * | 1997-03-07 | 2001-06-26 | Intelligent Compression Technologies | Coding network grouping data of same data type into blocks using file data structure and selecting compression for individual block base on block data type |
US6694324B1 (en) | 1999-12-16 | 2004-02-17 | Ncr Corporation | Determination of records with a specified number of largest or smallest values in a parallel database system |
WO2002001395A1 (en) * | 2000-06-27 | 2002-01-03 | Ubs Ag | Method and system for providing distributed functionality and data analysis system utilizing same |
US6968355B2 (en) | 2000-06-27 | 2005-11-22 | Ubs Ag | Method and system for providing distributed functionaltiy and data analysis system utilizing same |
US20020112056A1 (en) * | 2000-06-27 | 2002-08-15 | Bernard Baldwin | Method and system for providing distributed functionaltiy and data analysis system utilizing same |
EP1202191A3 (en) * | 2000-10-31 | 2003-06-18 | Kabushiki Kaisha Toshiba | Data management method and storage medium storing data management program |
EP1202191A2 (en) * | 2000-10-31 | 2002-05-02 | Kabushiki Kaisha Toshiba | Data management method and storage medium storing data management program |
US20060080282A1 (en) * | 2000-10-31 | 2006-04-13 | Kabushiki Kaisha Toshiba | Data management method and storage medium storing data management program |
US20030235189A1 (en) * | 2002-06-04 | 2003-12-25 | Mathews Gregory S. | Pointer allocation by prime numbers |
US7733888B2 (en) * | 2002-06-04 | 2010-06-08 | Alcatel-Lucent Usa Inc. | Pointer allocation by prime numbers |
US20040139221A1 (en) * | 2002-12-02 | 2004-07-15 | Knut Heusermann | Data structure mapping and packaging |
US7627585B2 (en) * | 2002-12-02 | 2009-12-01 | Sap Ag | Data structure mapping and packaging |
US8255504B1 (en) * | 2006-10-03 | 2012-08-28 | United States Automobile Association (USAA) | Systems and methods for data source management |
US9015305B1 (en) | 2006-10-03 | 2015-04-21 | United Services Automobile Association (Usaa) | Systems and methods for data source management |
US20110040808A1 (en) * | 2009-08-13 | 2011-02-17 | Microsoft Corporation | Distributed analytics platform |
US9383970B2 (en) * | 2009-08-13 | 2016-07-05 | Microsoft Technology Licensing, Llc | Distributed analytics platform |
Also Published As
Publication number | Publication date |
---|---|
JPH0981582A (en) | 1997-03-28 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US6327593B1 (en) | Automated system and method for capturing and managing user knowledge within a search system | |
US7523095B2 (en) | System and method for generating refinement categories for a set of search results | |
JP3849279B2 (en) | Index creation method and search method | |
US6920458B1 (en) | Model repository | |
US6263341B1 (en) | Information repository system and method including data objects and a relationship object | |
USRE40235E1 (en) | Data processing system and method for detecting mandatory relations violation in a relational database | |
US6185550B1 (en) | Method and apparatus for classifying documents within a class hierarchy creating term vector, term file and relevance ranking | |
US5812995A (en) | Electronic document filing system for registering and retrieving a plurality of documents | |
KR20010083096A (en) | Value-instance-connectivity computer-implemented database | |
JPH05342264A (en) | Method for indexing and retrieval and device for the same | |
MXPA06001214A (en) | File system represented inside a database. | |
Masseglia et al. | Sequential pattern mining | |
US20040073581A1 (en) | Version controlled associative array | |
US5881380A (en) | Device and method for data management based on values | |
JP3166689B2 (en) | Thesaurus retrieval and synthesis system | |
JPH0550774B2 (en) | ||
JPH0358249A (en) | Access method of file | |
EP1116137B1 (en) | Database, and methods of data storage and retrieval | |
JP3707912B2 (en) | Graphical user interface | |
JPH08137887A (en) | Information storage and retrieval device | |
JPH0934906A (en) | Book management device | |
JPH0727532B2 (en) | Information retrieval method and system | |
JP4056622B2 (en) | Database management device | |
Lazinger | To merge and not to merge: Israel's Union List of Monographs in the context of merging algorithms | |
US20030078938A1 (en) | Database and method of storing and retrieving data |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: FUJITSU LIMITED, JAPANFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:MOCHIZUKI, SHINICHI;RYU, TADAMITSU;KUROKAWA, IHOKO;REEL/FRAME:007965/0506Effective date: 19960401 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
FPAY | Fee payment |
Year of fee payment: 4 |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYFree format text: PAYER NUMBER DE-ASSIGNED (ORIGINAL EVENT CODE: RMPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
FPAY | Fee payment |
Year of fee payment: 12 |
|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:FUJITSU LIMITED;REEL/FRAME:028411/0838Effective date: 20120329 |