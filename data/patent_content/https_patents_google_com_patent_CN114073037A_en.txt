CN114073037A - Compression and imperceptible extension of RLWE plaintext - Google Patents
Compression and imperceptible extension of RLWE plaintext Download PDFInfo
- Publication number
- CN114073037A CN114073037A CN201980098195.9A CN201980098195A CN114073037A CN 114073037 A CN114073037 A CN 114073037A CN 201980098195 A CN201980098195 A CN 201980098195A CN 114073037 A CN114073037 A CN 114073037A
- Authority
- CN
- China
- Prior art keywords
- server
- plaintext
- result
- integers
- sequence
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Granted
Links
- 230000006835 compression Effects 0.000 title description 7
- 238000007906 compression Methods 0.000 title description 7
- 238000000034 method Methods 0.000 claims abstract description 44
- 238000012545 processing Methods 0.000 claims description 52
- 230000015654 memory Effects 0.000 claims description 36
- 238000004891 communication Methods 0.000 claims description 16
- 239000013598 vector Substances 0.000 description 14
- 238000010586 diagram Methods 0.000 description 11
- 238000004590 computer program Methods 0.000 description 8
- 230000006870 function Effects 0.000 description 7
- 238000004422 calculation algorithm Methods 0.000 description 5
- 238000013500 data storage Methods 0.000 description 3
- 230000003287 optical effect Effects 0.000 description 3
- 230000008569 process Effects 0.000 description 3
- 230000004044 response Effects 0.000 description 3
- 230000008901 benefit Effects 0.000 description 2
- 230000003993 interaction Effects 0.000 description 2
- 238000012946 outsourcing Methods 0.000 description 2
- PXFBZOLANLWPMH-UHFFFAOYSA-N 16-Epiaffinine Natural products C1C(C2=CC=CC=C2N2)=C2C(=O)CC2C(=CC)CN(C)C1C2CO PXFBZOLANLWPMH-UHFFFAOYSA-N 0.000 description 1
- 230000003592 biomimetic effect Effects 0.000 description 1
- 238000004364 calculation method Methods 0.000 description 1
- 239000002775 capsule Substances 0.000 description 1
- 230000008859 change Effects 0.000 description 1
- 239000004973 liquid crystal related substance Substances 0.000 description 1
- 238000012423 maintenance Methods 0.000 description 1
- 238000007726 management method Methods 0.000 description 1
- 238000012986 modification Methods 0.000 description 1
- 230000004048 modification Effects 0.000 description 1
- 230000006855 networking Effects 0.000 description 1
- 238000012856 packing Methods 0.000 description 1
- 229920000582 polyisocyanurate Polymers 0.000 description 1
- 239000004065 semiconductor Substances 0.000 description 1
- 230000001953 sensory effect Effects 0.000 description 1
- 239000007787 solid Substances 0.000 description 1
- 230000003068 static effect Effects 0.000 description 1
- 238000012546 transfer Methods 0.000 description 1
- 230000000007 visual effect Effects 0.000 description 1
Images
Classifications
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/30—Public key, i.e. encryption algorithm being computationally infeasible to invert or user's encryption keys not requiring secrecy
- H04L9/3006—Public key, i.e. encryption algorithm being computationally infeasible to invert or user's encryption keys not requiring secrecy underlying computational problems or public-key parameters
- H04L9/3026—Public key, i.e. encryption algorithm being computationally infeasible to invert or user's encryption keys not requiring secrecy underlying computational problems or public-key parameters details relating to polynomials generation, e.g. generation of irreducible polynomials
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/06—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols the encryption apparatus using shift registers or memories for block-wise or stream coding, e.g. DES systems or RC4; Hash functions; Pseudorandom sequence generators
- H04L9/0618—Block ciphers, i.e. encrypting groups of characters of a plain text message using fixed encryption transformation
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/901—Indexing; Data structures therefor; Storage structures
- G06F16/9027—Trees
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/008—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols involving homomorphic encryption
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/08—Key distribution or management, e.g. generation, sharing or updating, of cryptographic keys or passwords
- H04L9/0816—Key establishment, i.e. cryptographic processes or cryptographic protocols whereby a shared secret becomes available to two or more parties, for subsequent use
- H04L9/0819—Key transport or distribution, i.e. key establishment techniques where one party creates or otherwise obtains a secret value, and securely transfers it to the other(s)
- H04L9/083—Key transport or distribution, i.e. key establishment techniques where one party creates or otherwise obtains a secret value, and securely transfers it to the other(s) involving central third party, e.g. key distribution center [KDC] or trusted third party [TTP]
- H04L9/0833—Key transport or distribution, i.e. key establishment techniques where one party creates or otherwise obtains a secret value, and securely transfers it to the other(s) involving central third party, e.g. key distribution center [KDC] or trusted third party [TTP] involving conference or group key
- H04L9/0836—Key transport or distribution, i.e. key establishment techniques where one party creates or otherwise obtains a secret value, and securely transfers it to the other(s) involving central third party, e.g. key distribution center [KDC] or trusted third party [TTP] involving conference or group key using tree structure or hierarchical structure
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/30—Public key, i.e. encryption algorithm being computationally infeasible to invert or user's encryption keys not requiring secrecy
- H04L9/3093—Public key, i.e. encryption algorithm being computationally infeasible to invert or user's encryption keys not requiring secrecy involving Lattices or polynomial equations, e.g. NTRU scheme
Abstract
The method (600) includes obtaining a plaintext query (134) comprising a sequence of plaintext integers (136), and generating a polynomial (172) having coefficients (173), the coefficients (173) comprising the sequence of plaintext integers of the plaintext query. The method further comprises encrypting the polynomial using the secret encryption key (132) and transmitting the encrypted polynomial (182) to the server (111). The secret encryption key is randomly sampled from a ciphertext space, and the server is configured to expand the encryption polynomial using a public encryption key (130) to obtain a sequence of encrypted integers (210) related to the sequence of plaintext integers. The method also includes receiving an encryption result from the server (192). The encryption result is based on the sequence of encrypted integers.
Description
Technical Field
The present disclosure relates to compression and imperceptible expansion of RLWE plaintext.
Background
A Private Information Retrieval (PIR) scheme allows a user to retrieve data from one or more storage devices while not revealing any information about the user or the retrieved data to a server hosting the one or more storage devices. For PIR, the server storage is typically unprotected, and private information is retrieved from a public storage or server storage with a set of subscribing users, all of whom are allowed to download data from the entire storage. Although the user may simply download all content from the server storage device so that the access pattern is not displayed, it takes a long time when all content must be downloaded from the cloud storage service across a plurality of storage devices. In addition, conventional PIR schemes consume a large amount of bandwidth, especially when a user wishes to retrieve multiple data blocks or entries from a server.
Disclosure of Invention
One aspect of the disclosure provides a method for compressing one or more integers into an encryption polynomial. The method includes obtaining, at data processing hardware of a user device, a plaintext query comprising a sequence of plaintext integers, and generating, by the data processing hardware, a polynomial having coefficients comprising the sequence of plaintext integers for the plaintext query. The method also includes encrypting, by the data processing hardware, the polynomial using a secret encryption key and sending the encrypted polynomial to a server in communication with the data processing hardware. The secret encryption key is randomly sampled from a ciphertext space by data processing hardware, and the server is configured to expand the encryption polynomial using a public encryption key to obtain a sequence of encrypted integers related to the sequence of plaintext integers for the plaintext query. The method also includes receiving, at the data processing hardware, the encryption result from the server. The encryption result is based on the sequence of encrypted integers.
Implementations of the disclosure may include one or more of the following optional features. In some embodiments, the server is configured to, after expanding the encryption polynomial using the public encryption key: calculating the encryption result based on an untrusted data store at the server and the sequence of encrypted integers; and returning the encryption result to the user equipment. In some embodiments, the server is configured to calculate the encryption result by determining an inner product of the untrusted data store and the sequence of encrypted integers. Additionally or alternatively, in these embodiments, the method further comprises, after receiving the encrypted result from the server, decrypting, by the data processing hardware, the encrypted result to obtain a decrypted result. Here, the decryption result corresponds to at least one data block of the untrusted data storage.
In some examples, the server is configured to expand the cryptographic polynomial by generating a tree data structure, whereby the cryptographic polynomial includes a root of the tree data structure. In these examples, the top row of the tree data structure includes the sequence of encrypted integers. Additionally, encrypting the polynomial may include encrypting the polynomial with a fully homomorphic encryption scheme. Each plaintext integer in the sequence of plaintext integers of the plaintext query corresponds to a selection criterion for a respective data block of an untrusted data store at the server.
In some embodiments, obtaining the plaintext query comprises generating a randomized query comprising the sequence of plaintext integers. In these embodiments, the method may further optionally comprise: inverting, by the data processing hardware, a plaintext integer selected from the sequence of plaintext integers of the randomized query to form a modified query; and sending, by the data processing hardware, the modified query to the server. Here the selected plaintext integer is associated with a respective data block of an untrusted data store of the server, and the server is configured to: computing an unencrypted result based on an untrusted data store at the server and the modified query; and returning the unencrypted result to the user equipment. Optionally, the method further comprises: after receiving the encrypted result and the unencrypted result from the server, calculating, by the data processing hardware, a difference between the encrypted result and the unencrypted result to obtain a value of a respective block of data of the untrusted data store that is associated with the selected plaintext integer of the sequence of plaintext integers of the randomized query.
Another aspect of the disclosure provides a system for compressing one or more integers into an encryption polynomial. The system includes user data processing hardware and memory hardware in communication with the data processing hardware of the user device. The memory hardware stores instructions that, when executed on the data processing hardware, cause the data processing hardware to: a plaintext query comprising a sequence of plaintext integers is obtained and a polynomial having coefficients comprising the sequence of plaintext integers for the plaintext query is generated. The operations further comprise encrypting the polynomial using a secret encryption key and sending the encrypted polynomial to a server in communication with the data processing hardware. The secret encryption key is randomly sampled from a ciphertext space by data processing hardware, and the server is configured to expand the encryption polynomial using a public encryption key to obtain a sequence of encrypted integers related to the sequence of plaintext integers for the plaintext query. Operations further comprise receiving an encryption result from the server. The encryption result is based on the sequence of encrypted integers.
The present aspects can include one or more of the following optional features. In some embodiments, the server is configured to, after expanding the encryption polynomial using the public encryption key: calculating the encryption result based on an untrusted data store at the server and the sequence of encrypted integers; and returning the encryption result to the user equipment. In these embodiments, the server may be configured to calculate the encryption result by determining an inner product of the untrusted data store and the sequence of encrypted integers. Additionally or alternatively, in these embodiments, the operations further comprise, after receiving the encrypted result from the server, decrypting the encrypted result to obtain a decrypted result. Here, the decryption result corresponds to at least one data block of the untrusted data storage.
In some examples, the server is configured to expand the cryptographic polynomial by generating a tree data structure, whereby the cryptographic polynomial includes a root of the tree data structure. In these examples, the top row of the tree data structure includes the sequence of encrypted integers. Additionally, encrypting the polynomial may include encrypting the polynomial with a fully homomorphic encryption scheme. Each plaintext integer in the sequence of plaintext integers of the plaintext query corresponds to a selection criterion for a respective data block of an untrusted data store at the server.
In some embodiments, obtaining the plaintext query comprises generating a randomized query comprising the sequence of plaintext integers. In these embodiments, the operations may also optionally include: inverting a plaintext integer selected from the sequence of plaintext integers for the randomized query to form a modified query; and sending the modified query to the server. Here, the selected plaintext integer is associated with a respective data block of an untrusted data store of the server, and the server is configured to: computing an unencrypted result based on an untrusted data store at the server and the modified query; and returning the unencrypted result to the user equipment. Optionally, the operations further comprise: after receiving the encrypted result and the unencrypted result from the server, computing a difference between the encrypted result and the unencrypted result to obtain a value of a respective block of data of the untrusted data store that is associated with the selected plaintext integer of the sequence of plaintext integers of the randomized query.
The details of one or more embodiments of the disclosure are set forth in the accompanying drawings and the description below. Other aspects, features, and advantages will be apparent from the description and drawings, and from the claims.
Drawings
FIG. 1 is a schematic diagram of an exemplary private information retrieval system that compresses and expands queries upon apparent access to data blocks stored on non-transitory data storage of a distributed system.
FIG. 2A is a schematic diagram of a tree data structure generated by the expander of the system of FIG. 1.
Fig. 2B provides an example algorithm for expanding the encryption polynomial.
Fig. 3 is a schematic diagram of a decryptor of the system of fig. 1.
FIG. 4 is a schematic diagram of an example selection query to select which data chunks to download from a distributed system.
Fig. 5A and 5B are schematic diagrams of the system of fig. 1 performing online and offline computations.
FIG. 6 is a flow diagram of an exemplary arrangement of operations of a method for compressing and expanding queries when data blocks are retrieved transparently from untrusted storage using private information retrieval.
FIG. 7 is a schematic diagram of an exemplary computing device that may be used to implement the systems and methods described herein.
Like reference symbols in the various drawings indicate like elements.
Detailed Description
Fully Homomorphic Encryption (FHE) is a cryptographic system with important homomorphic properties that allows untrusted parties to perform secure computations on encrypted data. That is, a user with a secret key sK, a public key pK, and some data x wishes to apply a function f to retrieve f (x). However, the user does not want to compute and/or does not have the computing power of the application f. The FHE enables the user to encrypt data under the key sK to generate an encryption E (sK, x). The user may then outsource (outsource) f's computation of x by sending the encryption E (sK, x), the function f, and the public key pK to the server. The server may then use the public key pK to compute some function f 'such that decryption f' (E (sK, x)) will generate f (x). The server then simply applies f' to the encryption E (sK, x), which can be sent back to the user to decrypt and retrieve f (x).
In many cases, the data x is not a single value, but a value x1,...,xlAnd the user wishes that f (x) will be calculated1,...,xl) And outsourcing to the server. One original method of outsourcing computation is to construct l ciphers E (sK, x)1),...,E(sK,xl) And sends all l encryptions to the server together with the public key pK. However, since encryption is typically quite large, this results in significant overhead in the communication/network costs of the user and the server. Thus, x1,...,xlIt is advantageous to compress the encryption of (1) to less than one encryption to improve communication costs. To support this compression, the server must be able to expand the compressed encryption back to the original l encryptions E (sK, x)1),...,E(sK,xl) To be able to compute f and return f (x) ciphers. Furthermore, to maintain privacy, the extended protocol for the server must remain imperceptible (oblivious) so that the server does not know the value x1,...,xlAnd a secret key sK.
Embodiments herein are directed to Private Information Retrieval (PIR) routines that allow a user or client to compress one or more integers into an encryption polynomial and allow a server to expand the encryption polynomial to retrieve encrypted integers given a public key and the encryption polynomial without knowledge of the plaintext value or key of the integer. This routine can provide compression greater than 1000x by maximizing the use of space and packing multiple values into the same ciphertext. The server may use the expanded encrypted integer to explicitly access a block of data stored on an untrusted data store, which may be publicly known and unencrypted (e.g., plaintext). In one example, a client using a client device may wish to access map data for a particular location without revealing the location to a server. For example, a customer may just land at an airport and wish to retrieve his or her environment map data privately. The PIR routine prevents a server storing map data from knowing which data (i.e., data that reveals the client's location) is retrieved by the client device. In another example, a client may wish to download a video from a server without revealing which video was downloaded. In some embodiments, the PIR routine performs a portion of the computation and communication in an offline manner (i.e., when there is less contention for the resource), thereby reducing the online portion of the computation and communication (i.e., when there is higher contention for the resource).
Referring to fig. 1, in some implementations, an example system 100 includes a user device 10 (also referred to as a client device 10) associated with a respective user or client device 12 and in communication with a remote system 111 via a network 112. The user device 10 may correspond to any computing device, such as a desktop workstation, a laptop workstation, or a mobile device (i.e., a smartphone). The remote system 111 may be a single computer, a plurality of computers, or a distributed system (e.g., a cloud environment) having scalable/resilient computing resources 118 (e.g., data processing hardware) and/or storage resources 116 (e.g., memory hardware). The untrusted data store 150 is overlaid (overlain) on the storage resources 116 to allow one or more client devices or computing resources 118 to use the storage resources 116 telescopically. Untrusted data store 150 is configured to store a plurality of data blocks 152,152 a-n.
For example, the untrusted data store 150 includes n data blocks (B)152 that are publicly known and unencrypted, and allows one or more client devices 10 to use PIRs to skillfully retrieve the data blocks (B)152 to hide the access pattern while preserving search functionality on the data blocks (B)152 by the client devices 10. Thus, the client device 10 may not own the data block 152 and, in some configurations, the contents of the data block 152 are made available to the public. Alternatively, the data block 152 may be specific to a particular client 12, but the client 12 still wishes to hide the access pattern from the untrusted data store 150. A client device 10 (e.g., a computer) associated with a client 12 may include associated memory hardware 122 and associated data processing hardware 124. Each client device 10 may utilize associated memory hardware 122 to hold or store a public key (pK)130 and a secret key (sK)132, as well as instructions executable by the data processing hardware 124 for generating a query 134. In some examples, the data processing hardware 124 executes a compressor 160 for compressing queries 134 issued to a remote system 111, which may also be referred to herein as a server executing in an untrusted environment.
In some examples, the compressor 160 obtains or receives a plaintext query 134 that includes l integers 136 (i.e., a sequence of integers 136 of length l), where l is a number of integers 136 that is equal to or less than the number n of data blocks stored in the untrusted data store 150. For example, if untrusted data store 150 includes one million data blocks 152, query 134 will include one million or fewer integers 136. In some examples, and as discussed in more detail below, integer 136 of query 134 indicates the computation to be performed by server 111 on data chunk 152. That is, each integer 136 of the query 134 corresponds to a data block 152 stored on the untrusted data store 150, and the value of each integer 136 provides the server 111 with a value that is calculated with the corresponding data block 152. The compressor 160 also receives a secret encryption key (sK) 132. (sK)132 may be randomly sampled from the ciphertext space by user device 10.
In some embodiments, compressor 160 implements a polynomial generator 170, and polynomial generator 170 receives query 134 and generates a correlation polynomial 172 having coefficients 173 and an order d. The coefficients 173 of the polynomial 172 include the integers 136 of the query 134. When the number l of integers 136 is less than d-th order, a missing coefficient 173 may be set to zero. Conversely, when the number l of integers 136 is greater than order d, the polynomial generator 170 may generate a plurality of individual polynomials 172 until all integers 136 are included as coefficients 173. In this case, the individual polynomials 172 may be combined and the individual polynomials 172 may be considered as one individual combined polynomial 172. In some examples, polynomial generator 170 uses a ring error with errors (RLWE) method to generate polynomial 172. RLWE is a learning error (LWE) that is specific to polynomial rings over finite fields. LWE is a quantum-resistant cryptographic method based on the difficulty of finding a value where B ═ axs + e, where a and B are known. That is, the LWE method (and thus by the extended RLWE method) relies on a random linear equation that has been perturbed by a small amount of noise e.
In the illustrated example, the compressor 160 further includes an encryptor 180 that receives the polynomial 172 and the secret encryption key (sK) 132. The encryptor 180 encrypts the polynomial 172 using the sK 132, using, for example, a Fully Homomorphic Encryption (FHE) scheme to generate an encrypted polynomial 182. For example, the encryptor 180 may use the Brakerski-Gentry-Vaikunttanathan (BGV) method or the Fan-Vercauteren (FV) method. An FHE is a form of encryption that allows computation on a ciphertext, producing an encrypted result that, when decrypted, matches the result of an operation as if the operation had been performed on the plaintext. Because the encryption operation using FHE is biomimetic (affine) in its input as plaintext, the ciphertext may be represented as the sum of an encryption monomial multiplied by, for example, 0 or 1 (i.e., polynomial 172 with coefficient 173).
Thereafter, the client device 10 sends the encryption polynomial 182 to the server 111, i.e., via the data processing hardware 124. Thus, the compressor 160 compresses the d encryptions into a single encryption. Typical PIR schemes require a separate selection vector to be provided for each encryption. Thus, for example, if d is equal to 1024 or 2048, system 100 may increase communication and/or network costs by a factor of 1024 or 2048, respectively, as compared to such conventional schemes.
With continued reference to fig. 1, in some embodiments, the server 111 (i.e., the remote system 111) executes an expander 200 that receives the encryption polynomial 182 and the public encryption key (pK) 130. When providing the encryption polynomial 182, the client device 10 may provide the pK 130. As explained in more detail below, the expander 200 expands the encryption polynomial 182 to inadvertently retrieve the encrypted integer sequence 210E (sK, x)1),...,E(sK,xl). That is, the expander 200 retrieves the encryption of each integer 136 of the plaintext query 134 from the encryption polynomial 182, wherein each integer 136Has been encrypted by the client device 10 using the sK 132 to form an encrypted integer sequence 210. Because the contents of sK 132 are never revealed to server 111, server 111 does not determine or know the plaintext value (i.e., integer 136) associated with encrypted integer sequence 210.
Referring now to FIG. 2A, optionally, when expanding the encryption polynomial 182, the expander 200 generates a tree data structure 220 having nodes 230, 230 a-n. The encryption polynomial 182 may be set as the root 230R of the tree data structure 220. That is, the expander 200 may operate in a tree-like manner starting from the root 230R. In some examples, the height of the tree (i.e., the number of layers or rows) is log2(d) + 1. For example, a d of order 1024 would result in a height of 10. The "top" (i.e., the last layer) of the tree 220 may include the sequence of encrypted integers 210. Fig. 2B provides an example algorithm 240 for expanding the encryption polynomial 182 into the sequence of encrypted integers 210. In some embodiments, tree data structure 220 takes the form of a two-dimensional array (two-dimensional array) res.
The array res may be populated by a first for loop with index i, which refers to the level (i.e., height) of the tree data structure 220, and a second for loop with index j, which passes through all nodes 230 at level i of the tree 220 (where there are 2 s)i) And (6) iteration. The index of the levels starts from zero, so the first level has 20This is the root 230R, 1 node 230. Each node 230 of the tree 220 is associated with a corresponding value 231, 231 a-n. For non-leaf nodes 230 (i.e., nodes having at least one child node 230), these values 231 are intermediate values 231 used to compute the final extended ciphertext (i.e., the encrypted integer sequence 210). The values 231 associated with each node 230 will be stored in the two-dimensional array res. In particular res [ i ]][j]Refers to the value associated with the leftmost jth node of the ith stage. The innermost loop calculates the values 231 of the two children nodes 230 of the leftmost jth node 230 of the i-th level. The parent node refers to the value of the leftmost jth node of the ith level. In some examples, the left and right fingers add intermediate values 231 for calculating the final values 231 of the left and right child node values 231, respectively (which will be stored in res [ i ] respectively][j]And res [ i][j+2i]In (1). In some embodiments (e.g. in the case of a capsule with a single (or multiple) componentWhen the server 111 is subject to memory-constrained), the intermediate value 231 is deleted after being used in the loop to save memory. For example, after calculating the value of level i, the algorithm 240 of fig. 2B no longer requires the values 231 of levels 0, 1.
In a typical binary tree, nodes 230 are typically placed in consecutive indexes. However, in some examples, expander 200 does not place node 230 in a continuous index. Sum of algorithm 240 uses pK to correctly add two ciphertexts that have been replaced by different powers. After the two cycles are completed, the leaf node 230 (i.e., the highest level of the tree 220) includes the sequence of encrypted integers 210. In the example shown, the leaf node 230 divides by the order d before returning the encrypted integer sequence 210. Optionally, polynomial 172 may be divided by order d prior to encryption. In this case, a smaller parameter (e.g., noise) may be selected to reduce the bandwidth consumed by the communication between user equipment 10 and server 111 at the expense of additional computation by user equipment 10.
Referring back to fig. 1, the server 111 returns the encrypted result 192 to the user device 10 based on the sequence of encrypted integers 210. For example, server 111 may execute calculator 190, calculator 190 receiving encrypted integer 210 and using the encrypted integer to retrieve the block of data from untrusted data store 150. For example, calculator 190 calculates encrypted result 192 based on data block 152 retrieved from untrusted data store 150 and encrypted integer sequence 210.
Referring now to fig. 3, in some examples, calculator 190 calculates encrypted result 192 by determining an inner product 310 (also referred to as a dot product or scalar product) of encrypted integer sequence 210 and data block 152 retrieved from untrusted data store 150. The encrypted result 192 may include an inner product 310. In some embodiments, the user device 10 receives the encrypted results 192 from the server 111 and executes (i.e., via the data processing hardware 124) the decryptor 300 for decrypting the encrypted results 192 using the sK 132. The sK 132 may be stored on the local memory hardware 122, and the decryptor 300 may obtain the sK 132 for decrypting the encrypted result 192. Thus, decryptor 300 outputs a decrypted result 302, the decrypted result 302 representing a result obtained by computing an inner product 310 of the plaintext challenge 134 and the block of data 152, however, the retrieval is imperceptible (oblivious). The decrypted result 302 may correspond to any number of data blocks 152 depending on the query 134 (or queries) sent to the server 111.
Referring now to the schematic view 400 of fig. 4, in some examples, each plaintext integer 136 in the plaintext query 134 corresponds to a selection criterion for a corresponding block of data 152 of the untrusted data store 150. Plaintext query 134 may include a selection vector for selecting a single block of data 152 from untrusted data store 150. For example, the first plaintext query 134a input to the compactor 160 may include a vector of all zeros except for a single (1) at the second position. Here, the decryptor 300 decrypts the encrypted result 192 returned from the first query 134a into a decrypted result 302, the decrypted result 302 including the data block 152 corresponding to the second location of the untrusted data store 150 because the inner product 310 will multiply all data blocks 152 except the second data block by zeros. Since the zero-multiplied data block 152 will be culled (drop out), the summation will result in only the second position data block 152 remaining. Obviously, such a query 134a may be used to imperceptibly select any data chunk 152 from any location (position)/position (location) of the data store 150. However, query 134 may also perform various other functions.
The compression algorithm performed by the compressor 160 goes beyond receiving only the selection vector, but includes receiving a generic vector (i.e., a vector in which each integer 136 may include any integer in the plaintext space). That is, although a typical PIR scheme requires a separate selection vector to be sent to the server 111 for each block of data 152 to be retrieved (each selection vector being equal in length to the number n of blocks of data), the compressor 160 may compress the d encryptions into a single generic vector. For example, the second query 134b input to the compressor 160 sets three integers 136 (i.e., the 2 nd, 3 rd, and/th integers 136) equal to one (1) and sets the remaining integers 136 equal to zero. Here, the second query 134b will return a corresponding encrypted result 192, the encrypted result 192 corresponding to the sum of the values of the 2 nd, 3 rd and l th data blocks 152 of the untrusted data store 150. Query 134 may also retrieve the weighted sum. For example, the third query 134c input to the compressor 160 sets all integers 136 equal to one (1), except that the 3 rd integer 136 is set to the weighting factor α. Thus, the third query 134c will return a corresponding encrypted result 192 corresponding to the weighted sum (i.e., the 3 rd data block will be weighted as α, while the remaining data blocks 152 will be weighted as 1). In yet another example, the server 111 may return an average of the plurality of data chunks 152 in response to a fourth query 134d input to the compressor 160, the fourth query 134d setting all integers 136 equal to one (1). Thus, it can be appreciated that the compressor 160 provides compression on generic vectors (as opposed to just selecting vectors), where the integer 136 may span the entire plaintext space.
In some embodiments, the system 100 distributes computing and/or communications between offline and online periods. An offline period is defined as a time period during which resources (e.g., bandwidth, computation, power, etc.) are relatively cheaper than during an online period. That is, there is less contention for resources during the offline period than during the online period. For example, the user device 10 (fig. 1) may connect to WiFi during the night (offline period) making it relatively cheaper to use mobile data than during the day (online period). The unperceived search has a considerable cost (i.e., resource usage) increase compared to the normal plaintext search due to the multiplication factor (which may be increased by as much as 4 to 5 times in some applications) caused by the extended overhead. Therefore, it is advantageous to take advantage of the cost difference between online and offline cycles. Thus, the system 100 can perform offline computations to reduce costs (i.e., reduce consumed resources) by shifting the expanded overhead to offline periods when it is desired to perform an imperceptible query 134 to an untrusted data store 150.
Referring now to fig. 5a, a diagram 500a illustrates a compressor 160 receiving a randomized plaintext challenge 134R during an offline period. Randomizing plaintext challenge 134R randomizes (e.g., by data processing hardware 124) the setting of each integer 136 is equal to 0 or one (1). In the example shown, the 2 nd, 4 th and 5 th integers 136 are set equal to one (1) and the remaining integers 136 are set equal to 0. As previously described, the query 134R will cause the server 111 to return an encrypted result 192R, the encrypted result 192R being the sum of the data blocks 152 associated with the integer 136 (i.e., the 2 nd, 4 th, and 5 th integers 136) set equal to one (1) in the randomized plaintext query 134R. When query 134R is performed during an offline period, the cost of retrieving the corresponding encrypted results 192R is relatively low. The user device 10 may store (i.e., in the local memory hardware 122) the encrypted result 192R and the randomized plaintext query 134R until the user 12 makes the query 134 within the online period.
In some examples, as user 12 makes query 134 within the online cycle, inverter 530 executing on data processing hardware 124 inverts the single plaintext integer of randomized plaintext query 134R (i.e., selection integer 136M) to form modified query 134M. That is, when the selected integer 136M of the randomized plaintext challenge 134R is set equal to 0, the inverter 530 changes the selected integer 136M from 0 to one (1). On the other hand, when the selected integer 136M of the randomized plaintext challenge 134R is set equal to one (1), the inverter 530 changes the selected integer 136M from one (1) to 0. Inverted integer 136M (e.g., integer 3 136 in FIG. 5A) of modified query 134M corresponds to data block 152 that user 12 wants to retrieve from untrusted data store 150 during the online cycle. Here, inverter 530 sends modified query 134M in the clear (i.e., in the plaintext) to expander 200 of server 111. That is, the encryptor 180 does not encrypt the modified query 134M. Because modified query 134M is not encrypted, it is a binary vector, sized to the number n of data blocks 152 in data store 150, and has no overhead due to encryption. Thus, the bandwidth consumed by the modified query 134M is significantly less than the bandwidth consumed by, for example, the encryption polynomial 182. Because the modified query 134M is uncompressed and therefore does not require expansion (thereby greatly reducing the computation required by the server 111), the calculator 190 of the server 111 receives the modified query 134M directly and calculates the plaintext result 520. That is, the calculation (e.g., dot product) between modified query 134M and data block 152 includes a plaintext result 520, plaintext result 520 being equal to the sum of data blocks 152 selected by modified query 134M. Server 111 may provide clear text results 520 to user device 10.
Referring now to the schematic diagram 500B of fig. 5B, in some examples, the user device 10 (i.e., via the data processing hardware 124) executes the decryptor 300 to decrypt the previously stored encryption result 192R into a corresponding decryption result 302R. Here, the previously stored encryption result 192R corresponds to the randomized plaintext query 134R executed during an offline period as described in fig. 5A. In these examples, the data processing hardware 124 also executes a result calculator 540, the result calculator 540 configured to calculate a result difference 542 between the plaintext result 520 received from the server 111 and the decryption result 302R output from the decryptor 300.
Because the data blocks 152 retrieved by 134M differ only by a single inverted integer 136M in response to the query 134R, the result difference 542 corresponds to the value associated with the inverted integer 136M. Thus, user device 10 retrieves data chunk 152 during the online cycle using minimal resources, while server 111 does not determine which data chunk 152 to retrieve from untrusted data store 150. The encryption of the randomized query 134R ensures that the server 111 cannot determine which integer 136 has been inverted between the randomized query 134R and the modified query 134M. Because the modified query 134M is modified from the randomized query 134R, the server cannot determine information from the modified query 134M, even though the query 134M was sent plaintext (in clear) to the server 111 (i.e., as plaintext). It should be noted, however, that the randomized query 134R and the encrypted result 192R should not be reused to ensure privacy, as reuse would cause the server 111 to determine the differences between the modified query 134M. In some examples, the user device 10 retrieves the plurality of encrypted results 192R from the independent randomized query 134R to establish a "pool" of encrypted results 192R and randomized query 134R for use within the online period. In some embodiments, the randomized query 134R comprises a randomized integer sampled from the plaintext space, rather than a randomized byte vector (bit vector). While this increases the computation, it ensures that data blocks 152 other than the retrieved data block 152 remain hidden from the client 12 (i.e., the inner product 310 does not reveal additional information about the data block 152 to the client 12). This may be advantageous when untrusted data store 150 is private.
FIG. 6 is a flow diagram of an example method 600 for compressing a query to retrieve encrypted results imperceptibly from a server. The method 600 begins at operation 602, where the plaintext query 134 is obtained at the data processing hardware 124 of the user device 10. Query 134 includes a sequence of plaintext integers 136. At operation 604, the method 600 includes generating, by the data processing hardware 124, a polynomial 172 having coefficients 173. Coefficient 173 includes a sequence of plaintext integers 136. At operation 606, the method 600 includes encrypting, by the data processing hardware 124, the polynomial 172 using the secret encryption key 132. The secret encryption key 132 is randomly sampled from the ciphertext space by the data processing hardware 124.
At operation 608, the method 600 includes sending, by the data processing hardware 124, the encryption polynomial 182 to the server 111 in communication with the data processing hardware 124. The server 111 is configured to expand the encryption polynomial 182 using the public encryption key 130 to obtain an encrypted sequence of integers 210. The encrypted integer sequence 210 corresponds to the plaintext integer sequence 136 of the plaintext query 134. At step 610, the method 600 includes receiving the encryption result 192 from the server 111 at the data processing hardware 124. The encryption result 192 is based on the sequence of encrypted integers 210. In some embodiments, the method 600 includes computing the encrypted result 192 based on the untrusted data store 150 (e.g., a database) stored on the server 111 and the sequence of encrypted integers 210, and returning the encrypted result 192 to the user device 10. For example, server 111 may calculate encrypted result 192 by determining inner product 310 of database 150 and encrypted integer sequence 210 stored on server 111.
FIG. 7 is a schematic diagram of an exemplary computing device 700 that may be used to implement the systems and methods described in this document. Computing device 700 is intended to represent various forms of digital computers, such as laptops, desktops, workstations, personal digital assistants, servers, blade servers, mainframes, and other appropriate computers. The components, their connections and relationships, and their functions, as illustrated herein are meant to be exemplary only, and are not meant to limit implementations of the inventions described and/or claimed in this document.
The storage device 730 is capable of providing mass storage for the computing device 700. In some implementations, the storage device 730 is a computer-readable medium. In various different embodiments, the storage device 730 may be or contain a computer-readable medium, such as a floppy disk device, a hard disk device, an optical disk device, or a tape device, a flash memory or other similar solid state memory device, or a group of devices, including devices in a storage area network or other configurations. In a further embodiment, a computer program product is tangibly embodied in an information carrier. The computer program product contains instructions that, when executed, perform one or more methods, such as those described above. The information carrier is a computer-or machine-readable medium, such as the memory 720, the storage device 730, or memory on processor 710.
The high speed controller 740 manages bandwidth-intensive operations for the computing device 700, while the low speed controller 760 manages lower bandwidth-intensive operations. Such allocation of functions is merely exemplary. In some embodiments, high-speed controller 740 is connected to memory 720, display 780 (e.g., through a graphics processor or accelerator), and high-speed expansion interface 750, which may accept a variety of expansion cards (not shown). In some embodiments, low-speed controller 760 is coupled to storage device 730 and low-speed expansion port 790. The low-speed expansion port 790, which includes various communication ports (e.g., USB, bluetooth, ethernet, wireless ethernet), may be connected through, for example, a network adapter to one or more input/output devices, such as a keyboard, a pointing device, a scanner, or a network device, such as a switch or router.
As shown, the computing device 700 may be implemented in a number of different forms. For example, it may be implemented as a standard server 700a or multiple times in a group of such servers 700a as a laptop 700b, or as part of a rack server system 700 c.
Various implementations of the systems and techniques described here can be realized in digital electronic circuitry, integrated circuitry, specially designed ASICs (application specific integrated circuits), computer hardware, firmware, software, and/or combinations thereof. These various implementations can include implementation in one or more computer programs that are executable and/or interpretable on a programmable system including at least one programmable processor, which may be special or general purpose, coupled to receive data and instructions from, and to transmit data and instructions to, a storage system, at least one input device, and at least one output device.
A software application (i.e., a software resource) may refer to computer software that causes a computing device to perform tasks. In some examples, a software application may be referred to as an "application," app, "or" program. Example applications include, but are not limited to, system diagnostics applications, system management applications, system maintenance applications, word processing applications, spreadsheet applications, messaging applications, media streaming applications, social networking applications, and gaming applications.
These computer programs (also known as programs, software applications, or code) include machine instructions for a programmable processor, and may be implemented in a high-level procedural and/or object-oriented programming language, and/or in assembly/machine language. As used herein, the terms "machine-readable medium" and "computer-readable medium" refer to any computer program product, apparatus and/or device (e.g., magnetic discs, optical disks, memory, Programmable Logic Devices (PLDs)) used to provide machine instructions and/or data to a programmable processor, including a machine-readable medium that receives machine instructions as a machine-readable signal.
The processes and logic flows described in this specification can be performed by one or more programmable processors (also known as data processing hardware) executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by, and in particular by, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit). Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. However, a computer need not have such devices. Computer-readable media suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, such as internal hard disks or removable disks; magneto-optical disks; CD ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
To provide for interaction with a user, one or more aspects of the present disclosure may be implemented on a computer having a display device (e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor) for displaying information to the user, a keyboard, and a pointing device (e.g., a mouse or a trackball), by which the user can provide input to the computer. Other types of devices may also be used to provide for interaction with a user; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user may be received in any form, including acoustic, speech, or tactile input. Further, the computer may interact with the user by sending and receiving documents to and from the device used by the user; for example, by sending a web page to a web browser on the user's client device in response to a request received from the web browser.
Various implementations have been described. Nevertheless, it will be understood that various modifications may be made without departing from the spirit and scope of the disclosure. Accordingly, other implementations are within the scope of the following claims.
Claims (22)
1. A method (600), characterized in that the method comprises:
obtaining, at data processing hardware (124) of a user device (10), a plaintext query (134) comprising a sequence of plaintext integers (136);
generating, by the data processing hardware (124), a polynomial (172) having coefficients (173), the coefficients (173) comprising the plaintext integer sequences (136) of the plaintext query (134);
encrypting, by the data processing hardware (124), a polynomial (182) using a secret encryption key (132), the secret encryption key (132) being randomly sampled from a ciphertext space by the data processing hardware (124);
sending, by the data processing hardware (124), an encryption polynomial (182) to a server (111) in communication with the data processing hardware (124), the server (111) configured to expand the encryption polynomial (182) using a public encryption key (130) to obtain an encrypted sequence of integers (210), the encrypted sequence of integers (210) corresponding to the sequence of plaintext integers (136) of the plaintext query (134); and
receiving, at the data processing hardware (124), an encryption result (192) from the server (111), the encryption result (192) being based on the sequence of encrypted integers (210).
2. The method (600) of claim 1, wherein the server (111) is configured to extend the cryptographic polynomial (182) by generating a tree data structure (220), the cryptographic polynomial (182) comprising a root (230R) of the tree data structure (220).
3. The method (600) of claim 2, wherein a top row of the tree data structure (220) comprises the sequence of encrypted integers (210).
4. The method (600) of any of claims 1-3, wherein encrypting the polynomial (182) comprises encrypting the polynomial (182) with a fully homomorphic encryption scheme.
5. The method (600) according to any of claims 1-4, wherein the server (111) is configured to, after expanding the encryption polynomial (182) using the public encryption key (130):
computing the encryption result (192) based on an untrusted data store (150) at the server (111) and the sequence of encrypted integers (210); and
returning the encryption result (192) to the user equipment (10).
6. The method (600) of claim 5, wherein the server (111) is configured to calculate the encryption result (192) by determining an inner product (310) of the untrusted data store (150) and the sequence of encrypted integers (210).
7. The method (600) of claim 5 or 6, further comprising: after receiving the encrypted result (192) from the server (111), decrypting, by the data processing hardware (124), the encrypted result (192) to obtain a decrypted result (302), the decrypted result (302) corresponding to at least one data block (152) of the untrusted data store (150).
8. The method (600) according to any one of claims 1-7, wherein each plaintext integer (136) in the sequence of plaintext integers (136) of the plaintext query (134) corresponds to a selection criterion for a respective block of data (152) of an untrusted data store (150) at the server (111).
9. The method (600) of any of claims 1-8, wherein obtaining the plaintext challenge (134) comprises generating a randomized challenge (134) comprising the sequence of plaintext integers (136).
10. The method (600) of claim 9, comprising:
inverting, by the data processing hardware (124), a selected plaintext integer (136) from the sequence of plaintext integers (136) of the randomized query (134) to form a modified query (134), the selected plaintext integer (136) associated with a respective block of data (152) of the untrusted data store (150) at the server (111); and
sending, by the data processing hardware (124), the modified query (134) to the server (111), the server (111) configured to:
computing an unencrypted result (192) based on an untrusted data store (150) at the server (111) and the modified query (134); and
returning the encryption result (192) to the user equipment (10).
11. The method (600) of claim 10, further comprising: after receiving the encrypted result (192) and the unencrypted result (192) from the server (111), calculating, by the data processing hardware (124), a difference between the encrypted result (192) and the unencrypted result (192) to obtain a value of a respective block of data (152) of the untrusted data store (150), the respective block of data (152) being associated with the selected plaintext integer (136) of the sequence of plaintext integers (136) of the randomized query (134).
12. A system (100), characterized in that the system comprises:
data processing hardware (124); and
memory hardware (122) in communication with the data processing hardware (124) of a user equipment (10), the memory hardware (122) storing instructions that, when executed on the data processing hardware (124), cause the data processing hardware (124) to:
obtaining a plaintext query (134) comprising a sequence of plaintext integers (136);
generating a polynomial (172) having coefficients (173), the coefficients (173) comprising the plaintext integer sequences (136) of the plaintext query (134);
encrypting the polynomial (182) using a secret encryption key (132), the secret encryption key (132) being randomly sampled from a ciphertext space by the data processing hardware (124);
sending an encryption polynomial (182) to a server (111) in communication with the data processing hardware (124), the server (111) configured to expand the encryption polynomial (182) using a public encryption key (130) to obtain a sequence of encrypted integers (210), the sequence of encrypted integers (210) corresponding to the sequence of plaintext integers (136) of the plaintext query (134); and
receiving an encryption result (192) from the server (111), the encryption result (192) being based on the sequence of encrypted integers (210).
13. The system (100) of claim 12, wherein the server (111) is configured to extend the encryption polynomial (182) by generating a tree data structure (220), the encryption polynomial (182) comprising a root (230R) of the tree data structure (220).
14. The system (100) of claim 13, wherein a top row of the tree data structure (220) includes the sequence of encrypted integers (210).
15. The system (100) according to any one of claims 12-14, wherein encrypting the polynomial (182) comprises encrypting the polynomial (182) with a fully homomorphic encryption scheme.
16. The system (100) according to any one of claims 12-15, wherein the server (111) is configured to, after expanding the encryption polynomial (182) using the public encryption key (130):
computing the encryption result (192) based on an untrusted data store (150) at the server (111) and the sequence of encrypted integers (210); and
returning the encryption result (192) to the user equipment (10).
17. The system (100) of claim 16, wherein the server (111) is configured to calculate the encryption result (192) by determining an inner product (310) of the untrusted data store (150) and the sequence of encrypted integers (210) at the server (11).
18. The system (100) of claim 16 or 17, wherein the operations further comprise: after receiving the encrypted result (192) from the server (111), decrypting the encrypted result (192) to obtain a decrypted result (302), the decrypted result (302) corresponding to at least one data block (152) of the untrusted data store (150) at the server (11).
19. The system (100) according to any one of claims 12-18, wherein each plaintext integer (136) in the sequence of plaintext integers (136) of the plaintext query (134) corresponds to a selection criterion for a respective block of data (152) of an untrusted data store (150) at the server (111).
20. The system (100) according to any one of claims 12-19, wherein obtaining the plaintext challenge (134) comprises generating a randomized challenge (134) comprising the sequence of plaintext integers (136).
21. The system (100) of claim 20, wherein the operations further comprise:
inverting a selected plaintext integer (136) from the sequence of plaintext integers (136) of the randomized query (134) to form a modified query (134), the selected plaintext integer (136) associated with a respective data block (152) of the untrusted data store (150) at the server (111); and
sending the modified query (134) to the server (111), the server (111) configured to:
computing an unencrypted result (192) based on an untrusted data store (150) at the server (111) and the modified query (134); and
returning the encryption result (192) to the user equipment (10).
22. The system (100) of claim 21, wherein the operations further comprise: after receiving the encrypted result (192) and the unencrypted result (192) from the server (111), calculating a difference between the encrypted result (192) and the unencrypted result (192) to obtain a value of a respective data block (152) of the untrusted data store (150), the respective data block (152) being associated with the selected plaintext integer (136) of the sequence of plaintext integers (136) of the randomized query (134).
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201962845793P | 2019-05-09 | 2019-05-09 | |
US62/845,793 | 2019-05-09 | ||
PCT/US2019/064334 WO2020226695A1 (en) | 2019-05-09 | 2019-12-03 | Compression and oblivious expansion of rlwe ciphertexts |
Publications (2)
Publication Number | Publication Date |
---|---|
CN114073037A true CN114073037A (en) | 2022-02-18 |
CN114073037B CN114073037B (en) | 2024-05-17 |
Family
ID=
Citations (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN103401871A (en) * | 2013-08-05 | 2013-11-20 | 苏州大学 | Method and system for sequencing ciphertexts orienting to homomorphic encryption |
WO2014100788A2 (en) * | 2012-12-21 | 2014-06-26 | Microsoft Corporation | Managed secure computations on encrypted data |
CN105610793A (en) * | 2015-12-18 | 2016-05-25 | 江苏大学 | Outsourced data encrypted storage and cryptograph query system and application method therefor |
US10075288B1 (en) * | 2014-02-28 | 2018-09-11 | The Governing Council Of The University Of Toronto | Systems, devices, and processes for homomorphic encryption |
EP3419211A1 (en) * | 2017-06-23 | 2018-12-26 | Flytxt B.V. | Privacy preserving computation protocol for data analytics |
Patent Citations (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
WO2014100788A2 (en) * | 2012-12-21 | 2014-06-26 | Microsoft Corporation | Managed secure computations on encrypted data |
CN103401871A (en) * | 2013-08-05 | 2013-11-20 | 苏州大学 | Method and system for sequencing ciphertexts orienting to homomorphic encryption |
US10075288B1 (en) * | 2014-02-28 | 2018-09-11 | The Governing Council Of The University Of Toronto | Systems, devices, and processes for homomorphic encryption |
CN105610793A (en) * | 2015-12-18 | 2016-05-25 | 江苏大学 | Outsourced data encrypted storage and cryptograph query system and application method therefor |
EP3419211A1 (en) * | 2017-06-23 | 2018-12-26 | Flytxt B.V. | Privacy preserving computation protocol for data analytics |
Also Published As
Publication number | Publication date |
---|---|
KR20210152030A (en) | 2021-12-14 |
US11310045B2 (en) | 2022-04-19 |
TW202101936A (en) | 2021-01-01 |
KR102424856B1 (en) | 2022-07-22 |
JP2022531496A (en) | 2022-07-06 |
EP3959841A1 (en) | 2022-03-02 |
TWI730533B (en) | 2021-06-11 |
WO2020226695A1 (en) | 2020-11-12 |
EP3959841B1 (en) | 2022-06-08 |
US20200358610A1 (en) | 2020-11-12 |
JP7212179B2 (en) | 2023-01-24 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
WO2020253234A1 (en) | Data homomorphic encryption and decryption method and apparatus for implementing privacy protection | |
US20210075588A1 (en) | Systems, devices, and processes for homomorphic encryption | |
US9355271B2 (en) | System and method for dynamic, non-interactive, and parallelizable searchable symmetric encryption | |
JP6693508B2 (en) | Secret calculation system, server device, secret calculation method, and program | |
KR101829267B1 (en) | Homomorphic Encryption Method by Which Ciphertext Size Is Reduced | |
CN113906712A (en) | Homomorphic encryption applied to private information retrieval | |
US20140233727A1 (en) | Method for secure substring search | |
CN111026788B (en) | Homomorphic encryption-based multi-keyword ciphertext ordering and retrieving method in hybrid cloud | |
US20140270159A1 (en) | System and method for providing compressed encryption and decryption in homomorphic encryption based on integers | |
CN115694777A (en) | Privacy set intersection method, device, equipment and medium based on homomorphic encryption | |
US10546032B2 (en) | System and method for association rule mining from encrypted databases | |
CN113630250B (en) | Model training method and system based on data encryption | |
JP2006311383A (en) | Data managing method, data management system and data managing device | |
CN111798236B (en) | Transaction data encryption and decryption methods, devices and equipment | |
KR102424856B1 (en) | Compression and indeterminate expansion of RLWE ciphertexts | |
CN116170142B (en) | Distributed collaborative decryption method, device and storage medium | |
CN114073037B (en) | RLWE compression and imperceptible expansion of plaintext | |
US20230327847A1 (en) | Compression of homomorphic ciphertexts | |
JP6693503B2 (en) | Secret search system, server device, secret search method, search method, and program | |
Vo-Huu et al. | EPiC: efficient privacy-preserving counting for MapReduce | |
JP2023529690A (en) | Apparatus and method for performing statistical calculation on isomorphic ciphertext | |
KR101264286B1 (en) | System and method for database encryption | |
CN113158087A (en) | Query method and device for space text | |
Bhat et al. | A novel tamper evident single database information-theoretic private information retrieval for user privacy applications | |
KR20170054696A (en) | Homomorphic encryption apparatus for cluster in cloud, method thereof and computer recordable medium storing the method |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
SE01 | Entry into force of request for substantive examination | ||
GR01 | Patent grant |