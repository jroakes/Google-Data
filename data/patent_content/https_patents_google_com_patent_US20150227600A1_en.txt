US20150227600A1 - Virtual data backup - Google Patents
Virtual data backup Download PDFInfo
- Publication number
- US20150227600A1 US20150227600A1 US14/622,479 US201514622479A US2015227600A1 US 20150227600 A1 US20150227600 A1 US 20150227600A1 US 201514622479 A US201514622479 A US 201514622479A US 2015227600 A1 US2015227600 A1 US 2015227600A1
- Authority
- US
- United States
- Prior art keywords
- data
- storage
- computing device
- computing devices
- virtual
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Abandoned
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/27—Replication, distribution or synchronisation of data between databases or within a distributed database system; Distributed database system architectures therefor
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/07—Responding to the occurrence of a fault, e.g. fault tolerance
- G06F11/14—Error detection or correction of the data by redundancy in operation
- G06F11/1402—Saving, restoring, recovering or retrying
- G06F11/1415—Saving, restoring, recovering or retrying at system level
- G06F11/1435—Saving, restoring, recovering or retrying at system level using file system or storage system metadata
-
- G06F17/30575—
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/07—Responding to the occurrence of a fault, e.g. fault tolerance
- G06F11/14—Error detection or correction of the data by redundancy in operation
- G06F11/1402—Saving, restoring, recovering or retrying
- G06F11/1446—Point-in-time backing up or restoration of persistent data
- G06F11/1448—Management of the data involved in backup or backup restore
- G06F11/1451—Management of the data involved in backup or backup restore by selection of backup contents
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/07—Responding to the occurrence of a fault, e.g. fault tolerance
- G06F11/14—Error detection or correction of the data by redundancy in operation
- G06F11/1402—Saving, restoring, recovering or retrying
- G06F11/1446—Point-in-time backing up or restoration of persistent data
- G06F11/1448—Management of the data involved in backup or backup restore
- G06F11/1453—Management of the data involved in backup or backup restore using de-duplication of the data
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/07—Responding to the occurrence of a fault, e.g. fault tolerance
- G06F11/14—Error detection or correction of the data by redundancy in operation
- G06F11/1402—Saving, restoring, recovering or retrying
- G06F11/1446—Point-in-time backing up or restoration of persistent data
- G06F11/1456—Hardware arrangements for backup
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/07—Responding to the occurrence of a fault, e.g. fault tolerance
- G06F11/14—Error detection or correction of the data by redundancy in operation
- G06F11/1402—Saving, restoring, recovering or retrying
- G06F11/1446—Point-in-time backing up or restoration of persistent data
- G06F11/1458—Management of the backup or restore process
- G06F11/1461—Backup scheduling policy
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/07—Responding to the occurrence of a fault, e.g. fault tolerance
- G06F11/16—Error detection or correction of the data by redundancy in hardware
- G06F11/20—Error detection or correction of the data by redundancy in hardware using active fault-masking, e.g. by switching out faulty elements or by switching in spare elements
- G06F11/2053—Error detection or correction of the data by redundancy in hardware using active fault-masking, e.g. by switching out faulty elements or by switching in spare elements where persistent mass storage functionality or persistent mass storage control functionality is redundant
- G06F11/2094—Redundant storage or storage space
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/23—Updating
- G06F16/2365—Ensuring data consistency and integrity
-
- G06F17/30371—
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F3/00—Input arrangements for transferring data to be processed into a form capable of being handled by the computer; Output arrangements for transferring data from processing unit to output unit, e.g. interface arrangements
- G06F3/06—Digital input from, or digital output to, record carriers, e.g. RAID, emulated record carriers or networked record carriers
- G06F3/0601—Interfaces specially adapted for storage systems
- G06F3/0602—Interfaces specially adapted for storage systems specifically adapted to achieve a particular effect
- G06F3/0604—Improving or facilitating administration, e.g. storage management
- G06F3/0605—Improving or facilitating administration, e.g. storage management by facilitating the interaction with a user or administrator
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F3/00—Input arrangements for transferring data to be processed into a form capable of being handled by the computer; Output arrangements for transferring data from processing unit to output unit, e.g. interface arrangements
- G06F3/06—Digital input from, or digital output to, record carriers, e.g. RAID, emulated record carriers or networked record carriers
- G06F3/0601—Interfaces specially adapted for storage systems
- G06F3/0628—Interfaces specially adapted for storage systems making use of a particular technique
- G06F3/0638—Organizing or formatting or addressing of data
- G06F3/064—Management of blocks
- G06F3/0641—De-duplication techniques
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F3/00—Input arrangements for transferring data to be processed into a form capable of being handled by the computer; Output arrangements for transferring data from processing unit to output unit, e.g. interface arrangements
- G06F3/06—Digital input from, or digital output to, record carriers, e.g. RAID, emulated record carriers or networked record carriers
- G06F3/0601—Interfaces specially adapted for storage systems
- G06F3/0628—Interfaces specially adapted for storage systems making use of a particular technique
- G06F3/0646—Horizontal data movement in storage systems, i.e. moving data in between storage devices or systems
- G06F3/0647—Migration mechanisms
- G06F3/0649—Lifecycle management
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F3/00—Input arrangements for transferring data to be processed into a form capable of being handled by the computer; Output arrangements for transferring data from processing unit to output unit, e.g. interface arrangements
- G06F3/06—Digital input from, or digital output to, record carriers, e.g. RAID, emulated record carriers or networked record carriers
- G06F3/0601—Interfaces specially adapted for storage systems
- G06F3/0668—Interfaces specially adapted for storage systems adopting a particular infrastructure
- G06F3/0671—In-line storage system
- G06F3/0683—Plurality of storage devices
- G06F3/0685—Hybrid storage combining heterogeneous device types, e.g. hierarchical storage, hybrid arrays
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/07—Responding to the occurrence of a fault, e.g. fault tolerance
- G06F11/14—Error detection or correction of the data by redundancy in operation
- G06F11/1479—Generic software techniques for error detection or fault masking
- G06F11/1482—Generic software techniques for error detection or fault masking by means of middleware or OS functionality
- G06F11/1484—Generic software techniques for error detection or fault masking by means of middleware or OS functionality involving virtual machines
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F2201/00—Indexing scheme relating to error detection, to error correction, and to monitoring
- G06F2201/815—Virtual
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F2201/00—Indexing scheme relating to error detection, to error correction, and to monitoring
- G06F2201/84—Using snapshots, i.e. a logical point-in-time copy of the data
Definitions
- the present disclosure relates to data management, specifically to virtual data backup.
- FIG. 1 shows a typical set of data management operations that would be applied to the data of an application such as a database underlying a business service such as payroll management.
- application 102 requires primary data storage 122 with some contracted level of reliability and availability.
- Backups 104 are made to guard against corruption or the primary data storage through hardware or software failure or human error. Typically backups may be made daily or weekly to local disk or tape 124 , and moved less frequently (weekly or monthly) to a remote physically secure location 125 .
- Compliance with legal or voluntary policies 108 may require that some data be retained for safely future access for some number of years; usually data is copied regularly (say, monthly) to a long-term archiving system 128 .
- Disaster Recovery services 110 guard against catastrophic loss of data if systems providing primary business services fail due to some physical disaster.
- Primary data is copied 130 to a physically distinct location as frequently as is feasible given other constraints (such as cost). In the event of a disaster the primary site can be reconstructed and data moved back from the safe copy.
- Business Continuity services 112 provide a facility for ensuring continued business services should the primary site become compromised. Usually this requires a hot copy 132 of the primary data that is in near-lockstep with the primary data, as well as duplicate systems and applications and mechanisms for switching incoming requests to the Business Continuity servers.
- the disclosed subject matter includes a computerized method of creating, in a network, a single instance of deduplicated data across a plurality of end user data, each end user data being associated with a computing device.
- the method includes receiving, by a first computing device, data associated with a plurality of computing devices, the plurality of computing devices being managed by the first computing device.
- the method includes aggregating, by the first computing device, the data associated with each of the plurality of computing devices managed by the first computing device to form an aggregated data set for the plurality of computing devices.
- the method includes deduplicating, by the first computing device, the aggregated data set to form a deduplicated aggregated data set for the plurality of computing devices managed by the first computing device.
- the method includes transmitting, by the first computing device, the deduplicated aggregated data set to a second computing device for further aggregation and deduplication with one or more additional aggregated data sets generated by other computing devices managing respective sets of computing devices, thereby creating a single instance of deduplicated data across a plurality of end user data managed by the first computing device.
- the disclosed subject matter includes a computing system for creating, in a network, a single instance of deduplicated data across a plurality of end user data, each end user data being associated with a computing device.
- the computing system includes a processor and a memory coupled to the processor and including computer-readable instructions that, when executed by the processor, cause the processor to receive data associated with a plurality of computing devices, the plurality of computing devices being managed by the computing system.
- the computer-readable instructions cause the processor to aggregate the data associated with each of the plurality of computing devices managed by the computing system to form an aggregated data set for the plurality of computing devices.
- the computer-readable instructions cause the processor to deduplicate the aggregated data set to form a deduplicated aggregated data set for the plurality of computing devices managed by the computing system.
- the computer-readable instructions cause the processor to transmit the deduplicated aggregated data set to a second computing device for further aggregation and deduplication with one or more additional aggregated data sets generated by other computing devices managing respective sets of computing devices, thereby creating a single instance of deduplicated data across a plurality of end user data managed by the computing system.
- the disclosed subject matter includes a non-transitory computer readable medium having executable instructions operable to cause an apparatus to receive data associated with a plurality of computing devices, the plurality of computing devices being managed by a first computing device.
- the instructions are operable to cause the apparatus to aggregate the data associated with each of the plurality of computing devices managed by the first computing device to form an aggregated data set for the plurality of computing devices.
- the instructions are operable to cause the apparatus to deduplicate the aggregated data set to form a deduplicated aggregated data set for the plurality of computing devices managed by the first computing device.
- the instructions are operable to cause the apparatus to transmit the deduplicated aggregated data set to a second computing device for further aggregation and deduplication with one or more additional aggregated data sets generated by other computing devices managing respective sets of computing devices, thereby creating a single instance of deduplicated data across a plurality of end user data managed by the first computing device.
- the disclosed subject matter includes a computerized method of remotely backing up data associated with a plurality of storage environments.
- the method includes receiving, by a first computing device, a storage type associated with at least one second computing device managed by the first computing device, wherein the at least one second computing device is remotely in communication with the first computing device over a network.
- the method includes configuring, by the first computing device, storage parameters based on the storage type to customize a backup process for the second computing device based on the storage type.
- the method includes protecting, by the first computing device, data associated with the at least one second computing device using the storage parameters, wherein protecting data associated with the at least one second computing device further including copying, by the first computing device, at a first point in time a full copy of data associated with the at least one second computing device, and copying, by the first computing device, changes to the data associated with the at least one second computing device at a set of points in time later than the first point in time, the set of points in time being based on an end-user policy, thereby enabling custom protection of the remote at least one second computing device by the first computing device based on the storage type associated with the at least one second computing device.
- the disclosed subject matter includes a computing system for remotely backing up data associated with a plurality of storage environments.
- the computing system includes a processor and a memory coupled to the processor and including computer-readable instructions that, when executed by the processor, cause the processor to receive a storage type associated with at least one second computing device managed by the computing system, wherein the at least one second computing device is remotely in communication with the computing system over a network.
- the computer-readable instructions cause the processor to configure storage parameters based on the storage type to customize a backup process for the second computing device based on the storage type.
- the computer-readable instructions cause the processor to protect data associated with the at least one second computing device using the storage parameters, wherein protecting data associated with the at least one second computing device further includes copying at a first point in time a full copy of data associated with the at least one second computing device, and copying changes to the data associated with the at least one second computing device at a set of points in time later than the first point in time, the set of points in time being based on an end-user policy, thereby enabling custom protection of the remote at least one second computing device by the computing system based on the storage type associated with the at least one second computing device.
- the disclosed subject matter includes a non-transitory computer readable medium having executable instructions operable to cause an apparatus to receive a storage type associated with at least one second computing device managed by first computing device, wherein the at least one second computing device is remotely in communication with the first computing device over a network.
- the executable instructions are operable to cause an apparatus to configure storage parameters based on the storage type to customize a backup process for the second computing device based on the storage type.
- the executable instructions are operable to cause an apparatus to protect data associated with the at least one second computing device using the storage parameters, wherein protecting data associated with the at least one second computing device further includes copying at a first point in time a full copy of data associated with the at least one second computing device, and copying changes to the data associated with the at least one second computing device at a set of points in time later than the first point in time, the set of points in time being based on an end-user policy, thereby enabling custom protection of the remote at least one second computing device by the first computing device based on the storage type associated with the at least one second computing device.
- the disclosed subject matter includes a computerized method for providing content data storage services to a remote device over the internet to enable access of the remote device in the cloud.
- the method includes receiving, at a content data storage device, data indicative of a subscription to one or more content data storage services from a remote device in communication with the content data storage device over a network.
- the method includes provisioning, by the content data storage device, cloud storage for use by the content data storage device to provide the one or more content data storage services subscribed to by the remote device.
- the method includes replicating, by the content data storage device, data associated with the remote device to the provisioned cloud storage to provide a replicated device in the cloud.
- the method includes receiving, by the content data storage device, data indicative of a request to use the replicated device in the cloud.
- the method includes executing, by the content data storage device, the replicated device in the cloud, thereby providing access of the remote device in the cloud for the remote device.
- the disclosed subject matter includes a computing system for providing content data storage services to a remote device over the internet to enable access of the remote device in the cloud.
- the computing system includes a processor and a memory coupled to the processor and including computer-readable instructions that, when executed by the processor, cause the processor to receive data indicative of a subscription to one or more content data storage services from a remote device in communication with the content data storage device over a network.
- the computer-readable instructions cause the processor to provision cloud storage for use by the content data storage device to provide the one or more content data storage services subscribed to by the remote device.
- the computer-readable instructions cause the processor to replicate data associated with the remote device to the provisioned cloud storage to provide a replicated device in the cloud.
- the computer-readable instructions cause the processor to receive data indicative of a request to use the replicated device in the cloud.
- the computer-readable instructions cause the processor to execute the replicated device in the cloud, thereby providing access of the remote device in the cloud for the remote device.
- the disclosed subject matter includes a non-transitory computer readable medium having executable instructions operable to cause an apparatus to receive data indicative of a subscription to one or more content data storage services from a remote device in communication with the content data storage device over a network.
- the instructions are operable to cause an apparatus to provision cloud storage for use by the content data storage device to provide the one or more content data storage services subscribed to by the remote device.
- the instructions are operable to cause an apparatus to replicate data associated with the remote device to the provisioned cloud storage to provide a replicated device in the cloud.
- the instructions are operable to cause an apparatus to receive data indicative of a request to use the replicated device in the cloud.
- the instructions are operable to cause an apparatus to execute the replicated device in the cloud, thereby providing access of the remote device in the cloud for the remote device.
- FIG. 1 is a simplified diagram of current methods deployed to manage the data lifecycle for a business service.
- FIG. 2 is an overview of the management of data throughout its lifecycle by a single Data Management Virtualization System.
- FIG. 3 is a simplified block diagram of the Data Management Virtualization system.
- FIG. 4 is a view of the Data Management Virtualization Engine.
- FIG. 5 illustrates the Object Management and Data Movement Engine.
- FIG. 6 shows the Storage Pool Manager.
- FIG. 7 shows the decomposition of the Service Level Agreement.
- FIG. 8 illustrates the Application Specific Module.
- FIG. 9 shows the Service Policy Manager.
- FIG. 10 is a flowchart of the Service Policy Scheduler.
- FIG. 11 is a block diagram of the Content Addressable Storage (CAS) provider.
- CAS Content Addressable Storage
- FIG. 12 shows the definition of an object handle within the CAS system.
- FIG. 13 shows the data model and operations for the temporal relationship graph stored for objects within the CAS.
- FIG. 14 is a diagram representing the operation of a garbage collection algorithm in the CAS.
- FIG. 15 is a flowchart for the operation of copying an object into the CAS.
- FIG. 16 is a system diagram of a typical deployment of the Data Management Virtualization system.
- FIG. 17 shows components of a system including a Virtual Copy Data Management Appliance, according to some embodiments of the present disclosure.
- FIGS. 18 a - c are diagrams illustrating 3 deployments of a copy data management system, based on platform optimized storage virtualization layers, according to some embodiments of the present disclosure.
- FIG. 19 shows a diagram of virtual storage resources in a Virtual Copy Data Management Appliance, according to some embodiments of the present disclosure.
- FIG. 20 shows a virtual backup appliance system, according to some embodiments of the present disclosure.
- FIG. 21 shows a flowchart illustrating backup using a virtual backup appliance, according to some embodiments of the present disclosure.
- FIG. 22 shows a cascading deduplication system with virtual backup appliances, according to some embodiments of the present disclosure.
- FIG. 23 shows a flowchart illustrating cascading deduplication with virtual backup appliances, according to some embodiments of the present disclosure.
- FIG. 24 shows an archiving system, according to some embodiments of the present disclosure.
- FIG. 25 shows a disaster recovery and business continuity system in private and public cloud deployments, according to some embodiments of the present disclosure.
- FIG. 26 shows a flowchart illustrating archive and business continuity in the cloud, according to some embodiments of the present disclosure.
- FIG. 27 shows a flowchart illustrating backup as a service, according to some embodiments of the present disclosure.
- Data Management Virtualization Data Management activities, such as Backup, Replication and Archiving are virtualized in that they do not have to be configured and run individually and separately. Instead, the user defines their business requirement with regard to the lifecycle of the data, and the Data Management Virtualization System performs these operations automatically.
- a snapshot is taken from primary storage to secondary storage; this snapshot is then used for a backup operation to other secondary storage. Essentially an arbitrary number of these backups may be made, providing a level of data protection specified by a Service Level Agreement.
- This disclosure also pertains to a method of storing deduplicated images in which a portion of the image is stored in encoded form directly in a hash table, the method comprising organizing unique content of each data object as a plurality of content segments and storing the content segments in a data store; for each data object, creating an organized arrangement of hash structures, wherein each structure, for a subset of the hash structures, includes a field to contain a hash signature for a corresponding content segment and is associated with a reference to the corresponding content segment, wherein the logical organization of the arrangement represents the logical organization of the content segments as they are represented within the data object; receiving content to be included in the deduplicated image of the data object; determining if the received content may be encoded using a predefined non-lossy encoding technique and in which the encoded value would fit within the field for containing a hash signature; if so, placing the encoding in the field and marking the hash structure to indicate that the field contains encoded content for the deduplic
- Data Management Virtualization technology is based on an architecture and implementation based on the following guiding principles.
- SLA Service Level Agreement
- RTO Retention and Recovery Time Objective
- the Data Management Virtualization system achieves these improvements by leveraging extended capabilities of modern storage systems by tracking the portions of the data that have changed over time and by data deduplication and compression algorithms that reduce the amount of data that needs to be copied and moved.
- the Data Management Virtualization System leverages a single copy of the data for multiple purposes. A single instance of the data maintained by the system may serve as the source, from which each data management function may make additional copies as needed. This contrasts with requiring application data to be copied multiple times by multiple independent data management applications in the traditional approach.
- the Data Management Virtualization system allows the user to classify and aggregate different storage media into storage pools, for example, a Quick Recovery Pool, which consists of high speed disks, and a Cost Efficient Long-term Storage Pool, which may be a deduplicated store on high capacity disks, or a tape library.
- the Data Management Virtualization System can move data amongst these pools to take advantage of the unique characteristics of each storage medium.
- the abstraction of Storage Pools provides access independent of the type, physical location or underlying storage technology.
- the Data Management Virtualization System discovers the capabilities of the storage systems that comprise the Storage Pools, and takes advantage of these capabilities to move data efficiently. If the Storage System is a disk array that supports the capability of creating a snapshot or clone of a data volume, the Data Management Virtualization System will take advantage of this capability and use a snapshot to make a copy of the data rather than reading the data from one place and writing it to another. Similarly, if a storage system supports change tracking, the Data Management Virtualization System will update an older copy with just the changes to efficiently create a new copy. When moving data across a network, the Data Management Virtualization system uses a deduplication and compression algorithm that avoids sending data that is already available on the other side of the network.
- a copy of an application that is made today will, in general, have a lot of similarities to the copy of the same application that was made yesterday.
- today's copy of the data could be represented as yesterday's copy with a series of delta transformations, where the size of the delta transformations themselves are usually much smaller than all of the data in the copy itself.
- the Data Management Virtualization system captures and records these transformations in the form of bitmaps or extent lists.
- the underlying storage resources a disk array or server virtualization system—are capable of tracking the changes made to a volume or file; in these environments, the Data Management Virtualization system queries the storage resources to obtain these change lists, and saves them with the data being protected.
- the Data Management Virtualization system there is a mechanism for eavesdropping on the primary data access path of the application, which enables the Data Management Virtualization system to observe which parts of the application data are modified, and to generate its own bitmap of modified data. If, for example, the application modifies blocks 100 , 200 and 300 during a particular period, the Data Management Virtualization system will eavesdrop on these events, and create a bitmap that indicates that these particular blocks were modified. When processing the next copy of application data, the Data Management Virtualization system will only process blocks 100 , 200 and 300 since it knows that these were the only blocks that were modified.
- the Data Management Virtualization system takes advantage of a point-in-time snapshot capability of an underlying storage device to make the initial copy of the data.
- This virtual copy mechanism is a fast, efficient and low-impact technique of creating the initial copy that does not guarantee that all the bits will be copied, or stored together.
- virtual copies are constructed by maintaining metadata and data structures, such as copy-on-write volume bitmaps or extents, that allow the copies to be reconstructed at access time. The copy has a lightweight impact on the application and on the primary storage device.
- the Data Management Virtualization system uses the similar virtual-machine-snapshot capability that is built into the Server Virtualization systems.
- the Data Management Virtualization System may include its own built-in snapshot mechanism.
- the snapshot is possible to use as a data primitive underlying all of the data management functions supported by the system. Because it is lightweight, the snapshot can be used as an internal operation even when the requested operation is not a snapshot per se; it is created to enable and facilitate other operations.
- the preparatory operations may include application quiescence, which includes flushing data caches and freezing the state of the application; it may also include other operations known in the art and other operations useful for retaining a complete image, such as collecting metadata information from the application to be stored with the image.
- FIG. 2 illustrates one way that a Virtualized Data Management system can address the data lifecycle requirements described earlier in accordance with these principles.
- a sequence of efficient snapshots are made within local high-availability storage 202 . Some of these snapshots are used to serve development/test requirements without making another copy.
- a copy is made efficiently into long-term local storage 204 , which in this implementation uses deduplication to reduce repeated copying.
- the copies within long-term storage may be accessed as backups or treated as an archive, depending on the retention policy applied by the SLA.
- a copy of the data is made to remote storage 206 in order to satisfy requirements for remote backup and business continuity—again a single set of copies suffices both purposes.
- a further copy of the data may be made efficiently to a repository 208 hosted by a commercial or private cloud storage provider.
- FIG. 3 illustrates the high level components of the Data Management Virtualization System that implements the above principles.
- the system comprises these basic functional components further described below.
- Application 300 creates and owns the data. This is the software system that has been deployed by the user, as for example, an email system, a database system, or financial reporting system, in order to satisfy some computational need.
- the Application typically runs on a server and utilizes storage. For illustrative purposes, only one application has been indicated. In reality there may be hundreds or even thousands of applications that are managed by a single Data Management Virtualization System.
- Storage Resources 302 is where application data is stored through its lifecycle.
- the Storage Resources are the physical storage assets, including internal disk drives, disk arrays, optical and tape storage libraries and cloud-based storage systems that the user has acquired to address data storage requirements.
- the storage resources consist of Primary Storage 310 , where the online, active copy of the application data is stored, and Secondary Storage 312 where additional copies of the application data are stored for the purposes such as backup, disaster recovery, archiving, indexing, reporting and other uses.
- Secondary storage resources may include additional storage within the same enclosure as the primary storage, as well as storage based on similar or different storage technologies within the same data center, another location or across the internet.
- One or more Management Workstations 308 allow the user to specify a Service Level Agreement (SLA) 304 that defines the lifecycle for the application data.
- SLA Service Level Agreement
- a Management workstation is a desktop or laptop computer or a mobile computing device that is used to configure, monitor and control the Data Management Virtualization System.
- a Service Level Agreement is a detailed specification that captures the detailed business requirements related to the creation, retention and deletion of secondary copies of the application data.
- the SLA is much more than the simple RTO and RPO that are used in traditional data management applications to represent the frequency of copies and the anticipated restore time for a single class of secondary storage.
- the SLA captures the multiple stages in the data lifecycle specification, and allows for non uniform frequency and retention specifications within each class of secondary storage. The SLA is described in greater detail in FIG. 7 .
- Data Management Virtualization Engine 306 manages all of the lifecycle of the application data as specified in SLA. It manages potentially a large number of SLAs for a large number of applications.
- the Data Management Virtualization Engine takes inputs from the user through the Management Workstation and interacts with the applications to discover the applications primary storage resources.
- the Data Management Virtualization Engine makes decisions regarding what data needs to be protected and what secondary storage resources best fulfill the protection needs. For example, if an enterprise designates its accounting data as requiring copies to be made at very short intervals for business continuity purposes as well as for backup purposes, the Engine may decide to create copies of the accounting data at a short interval to a first storage pool, and to also create backup copies of the accounting data to a second storage pool at a longer interval, according to an appropriate set of SLAs. This is determined by the business requirements of the storage application.
- the Engine then makes copies of application data using advanced capabilities of the storage resources as available.
- the Engine may schedule the short-interval business continuity copy using a storage appliance's built-in virtual copy or snapshot capabilities.
- Data Management Virtualization Engine moves the application data amongst the storage resources in order to satisfy the business requirements that are captured in the SLA. The Data Management Virtualization Engine is described in greater detail in FIG. 4 .
- the Data Management Virtualization System as a whole may be deployed within a single host computer system or appliance, or it may be one logical entity but physically distributed across a network of general-purpose and purpose-built systems. Certain components of the system may also be deployed within a computing or storage cloud.
- the Data Management Virtualization Engine largely runs as multiple processes on a fault tolerant, redundant pair of computers. Certain components of the Data Management Virtualization Engine may run close to the application within the application servers. Some other components may run close to the primary and secondary storage, within the storage fabric or in the storage systems themselves.
- the Management stations are typically desktop and laptop computers and mobile devices that connect over a secure network to the Engine.
- FIG. 4 illustrates an architectural overview of the Data Management Virtualization Engine 306 according to certain embodiments of the invention.
- the 306 Engine includes the following modules:
- Application Specific Module 402 This module is responsible for controlling and collecting metadata from the application 300 .
- Application metadata includes information about the application such as the type of application, details about its configuration, location of its datastores, its current operating state. Controlling the operation of the application includes actions such as flushing cached data to disk, freezing and thawing application I/O, rotating or truncating log files, and shutting down and restarting applications.
- the Application Specific module performs these operations and sends and receives metadata in responses to commands from the Service Level Policy Engine 406 , described below. The Application Specific Module is described in more detail in connection with FIG. 8 .
- Service Level Policy Engine 406 acts on the SLA 304 provided by the user to make decisions regarding the creation, movement and deletion of copies of the application data.
- Each SLA describes the business requirements related to protection of one application.
- the Service Level Policy Engine analyzes each SLA and arrives at a series of actions each of which involve the copying of application data from one storage location to another. The Service Level Policy Engine then reviews these actions to determine priorities and dependencies, and schedules and initiates the data movement jobs.
- the Service Level Policy Engine is described in more detail in connection with FIG. 9 .
- Object Manager and Data Movement Engine 410 creates a composite object consisting of the Application data, the Application Metadata and the SLA which it moves through different storage pools per instruction from the Policy Engine.
- the Object Manager receives instructions from the Service Policy Engine 406 in the form of a command to create a copy of application data in a particular pool based on the live primary data 413 belonging to the application 300 , or from an existing copy, e.g., 415 , in another pool.
- the copy of the composite object that is created by the Object Manager and the Data Movement Engine is self contained and self describing in that it contains not only application data, but also application metadata and the SLA for the application.
- the Object Manager and Data Movement Engine are described in more detail in connection with FIG. 5 .
- Storage Pool Manager 412 is a component that adapts and abstracts the underlying physical storage resources 302 and presents them as virtual storage pools 418 .
- the physical storage resources are the actual storage assets, such as disk arrays and tape libraries that the user has deployed for the purpose of supporting the lifecycle of the data of the user's applications. These storage resources might be based on different storage technologies such as disk, tape, flash memory or optical storage. The storage resources may also have different geographic locations, cost and speed attributes, and may support different protocols.
- the role of the Storage Pool Manager is to combine and aggregate the storage resources, and mask the differences between their programming interfaces.
- the Storage Pool Manager presents the physical storage resources to the Object Manager 410 as a set of storage pools that have characteristics that make these pools suitable for particular stages in the lifecycle of application data. The Storage Pool Manager is described in more detail in connection with FIG. 6 .
- FIG. 5 illustrates the Object Manager and Data Movement Engine 410 .
- the Object Manager and Data Movement Engine discovers and uses Virtual Storage Resources 510 presented to it by the Pool Managers 504 . It accepts requests from the Service Level Policy Engine 406 to create and maintain Data Storage Object instances from the resources in a Virtual Storage Pool, and it copies application data among instances of storage objects from the Virtual Storage Pools according to the instructions from the Service Level Policy Engine.
- the target pool selected for the copy implicitly designates the business operation being selected, e.g. backup, replication or restore.
- the Service Level Policy Engine resides either locally to the Object Manager (on the same system) or remotely, and communicates using a protocol over standard networking communication. TCP/IP may be used in a preferred embodiment, as it is well understood, widely available, and allows the Service Level Policy Engine to be located locally to the Object Manager or remotely with little modification.
- the system may deploy the Service Level Policy Engine on the same computer system as the Object Manager for ease of implementation.
- the system may employ multiple systems, each hosting a subset of the components if beneficial or convenient for an application, without changing the design.
- the Object Manager 501 and the Storage Pool Managers 504 are software components that may reside on the computer system platform that interconnects the storage resources and the computer systems that use those storage resources, where the user's application resides.
- the placement of these software components on the interconnect platform is designated as a preferred embodiment, and may provide the ability to connect customer systems to storage via communication protocols widely used for such applications (e.g. Fibre Channel, iSCSI, etc.), and may also provide ease of deployment of the various software components.
- the Object Manager 501 and Storage Pool Manager 504 communicate with the underlying storage virtualization platform via the Application Programming Interfaces made available by the platform. These interfaces allow the software components to query and control the behavior of the computer system and how it interconnects the storage resources and the computer system where the user's Application resides.
- the components apply modularity techniques as is common within the practice to allow replacement of the intercommunication code particular to a given platform.
- the Object Manager and Storage Pool Managers communicate via a protocol. These are transmitted over standard networking protocols, e.g. TCP/IP, or standard Interprocess Communication (IPC) mechanisms typically available on the computer system. This allows comparable communication between the components if they reside on the same computer platform or on multiple computer platforms connected by a network, depending on the particular computer platform.
- TCP/IP standard networking protocols
- IPC Interprocess Communication
- the current configuration has all of the local software components residing on the same computer system for ease of deployment. This is not a strict requirement of the design, as described above, and can be reconfigured in the future as needed.
- Object Manager 501 is a software component for maintaining Data Storage Objects, and provides a set of protocol operations to control it.
- the operations include creation, destruction, duplication, and copying of data among the objects, maintaining access to objects, and in particular allow the specification of the storage pool used to create copies.
- the pools may be remote or local.
- the storage pools are classified according to various criteria, including means by which a user may make a business decision, e.g. cost per gigabyte of storage.
- the particular storage device from which the storage is drawn may be a consideration, as equipment is allocated for different business purposes, along with associated cost and other practical considerations. Some devices may not even be actual hardware but capacity provided as a service, and selection of such a resource can be done for practical business purposes.
- the network topological “proximity” is considered, as near storage is typically connected by low-latency, inexpensive network resources, while distant storage may be connected by high-latency, bandwidth limited expensive network resources; conversely, the distance of a storage pool relative to the source may be beneficial when geographic diversity protects against a physical disaster affecting local resources.
- the amount of storage used and the amount available in a given pool are considered, as there may be benefit to either concentrating or spreading the storage capacity used.
- the Service Level Policy Engine described below, combines the SLA provided by the user with the classification criteria to determine how and when to maintain the application data, and from which storage pools to draw the needed resources to meet the Service Level Agreement (SLA).
- SLA Service Level Agreement
- the object manager 501 creates, maintains and employs a history mechanism to track the series of operations performed on a data object within the performance pools, and to correlate those operations with others that move the object to other storage pools, in particular capacity-optimized ones.
- This series of records for each data object is maintained at the object manager for all data objects in the primary pool, initially correlated by primary data object, then correlated by operation order: a time line for each object and a list of all such time lines.
- Each operation performed exploits underlying virtualization primitives to capture the state of the data object at a given point in time.
- the underlying storage virtualization appliance may be modified to expose and allow retrieval of internal data structures, such as bitmaps, that indicate the modification of portions of the data within the data object.
- data structures are exploited to capture the state of a data object at a point in time: e.g., a snapshot of the data object, and to provide differences between snapshots taken at a specific time, and thereby enables optimal backup and restore. While the particular implementations and data structures may vary among different appliances from different vendors, a data structure is employed to track changes to the data object, and storage is employed to retain the original state of those portions of the object that have changed: indications in the data structure correspond to data retained in the storage.
- a typical data structure employed is a bitmap, where each bit corresponds to a section of the data object. Setting the bit indicates that section has been modified after the point in time of the snapshot operation.
- the underlying snapshot primitive mechanism maintains this for as long as the snapshot object exists.
- the time line described above maintains a list of the snapshot operations against a given primary data object, including the time an operation is started, the time it is stopped (if at all), a reference to the snapshot object, and a reference to the internal data structure (e.g. bitmaps or extent lists), so that it can be obtained from the underlying system. Also maintained is a reference to the result of copying the state of the data object at any given point in time into another pool—as an example, copying the state of a data object into a capacity-optimized pool 407 using content addressing results in an object handle. That object handle corresponds to a given snapshot and is stored with the snapshot operation in the time line. This correlation is used to identify suitable starting points.
- Optimal backup and restore consult the list of operations from a desired starting point to an end point.
- a time ordered list of operations and their corresponding data structures are constructed such that a continuous time series from start to finish is realized: there is no gap between start times of the operations in the series. This ensures that all changes to the data object are represented by the corresponding bitmap data structures. It is not necessary to retrieve all operations from start to finish; simultaneously existing data objects and underlying snapshots overlap in time; it is only necessary that there are no gaps in time where a change might have occurred that was not tracked. As bitmaps indicate that a certain block of storage has changed but not what the change is, the bitmaps may be added or composed together to realize a set of all changes that occurred in the time interval.
- the system instead of using this data structure to access the state at a point in time, the system instead exploits the fact that the data structure represents data modified as time marches forward. Rather, the end state of the data object is accessed at the indicated areas, thus returning the set of changes to the given data object from the given start time to the end time.
- the backup operation exploits this time line, the correlated references, and access to the internal data structures to realize our backup operation. Similarly, it uses the system in a complementary fashion to accomplish our restore operation. The specific steps are described below in the section for “Optimal Backup/Restore.”
- FIG. 5 illustrates several representative storage pool types. Although one primary storage pool and two secondary storage pools are depicted in the figure, many more may be configured in some embodiments.
- Primary Storage Pool 507 contains the storage resources used to create the data objects in which the user Application stores its data. This is in contrast to the other storage pools, which exist to primarily fulfill the operation of the Data Management Virtualization Engine.
- Performance Optimized Pool 508 a virtual storage pool able to provide high performance backup (i.e. point in time duplication, described below) as well as rapid access to the backup image by the user Application
- Capacity Optimized Pool 509 a virtual storage pool that chiefly provides storage of a data object in a highly space-efficient manner by use of deduplication techniques described below.
- the virtual storage pool provides access to the copy of the data object, but does not do so with high performance as its chief aim, in contrast to the Performance Optimized pool above.
- the initial deployments contain storage pools as described above, as a minimal operational set.
- the design fully expects multiple Pools of a variety of types, representing various combinations of the criteria illustrated above, and multiple Pool Managers as is convenient to represent all of the storage in future deployments.
- the tradeoffs illustrated above are typical of computer data storage systems.
- these three pools represent a preferred embodiment, addressing most users requirements in a very simple way. Most users will find that if they have one pool of storage for urgent restore needs, which affords quick recovery, and one other pool that is low cost, so that a large number of images can be retained for a large period of time, almost all of the business requirements for data protection can be met with little compromise.
- the format of data in each pool is dictated by the objectives and technology used within the pool.
- the quick recovery pool is maintained in the form very similar to the original data to minimize the translation required and to improve the speed of recovery.
- the long-term storage pool uses deduplication and compression to reduce the size of the data and thus reduce the cost of storage.
- the Object Manager 501 creates and maintains instances of Data Storage Objects 503 from the Virtual Storage Pools 418 according to the instructions sent to it by the Service Level Policy Engine 406 .
- the Object Manager provides data object operations in five major areas: point-in-time duplication or copying (commonly referred to as “snapshots”), standard copying, object maintenance, mapping and access maintenance, and collections.
- Object Management operations also include a series of Resource Discovery operations for maintaining Virtual Storage Pools themselves and retrieving information about them.
- the Pool Manager 504 ultimately supplies the functionality for these.
- Snapshot operations create a data object instance representing an initial object instance at a specific point in time. More specifically, a snapshot operation creates a complete virtual copy of the members of a collection using the resources of a specified Virtual Storage Pool. This is called a Data Storage Object. Multiple states of a Data Storage Object are maintained over time, such that the state of a Data Storage Object as it existed at a point in time is available.
- a virtual copy is a copy implemented using an underlying storage virtualization API that allows a copy to be created in a lightweight fashion, using copy-on-write or other in-band technologies instead of copying and storing all bits of duplicate data to disk.
- This may be implemented using software modules written to access the capabilities of an off-the-shelf underlying storage virtualization system such as provided by EMC, vmware or IBM in some embodiments. Where such underlying virtualizations are not available, the described system may provide its own virtualization layer for interfacing with unintelligent hardware.
- Snapshot operations require the application to freeze the state of the data to a specific point so that the image data is coherent, and so that the snapshot may later be used to restore the state of the application at the time of the snapshot. Other preparatory steps may also be required. These are handled by the Application-Specific Module 302 , which is described in a subsequent section. For live applications, therefore, the most lightweight operations are desired.
- Snapshot operations are used as the data primitive for all higher-level operations in the system. In effect, they provide access to the state of the data at a particular point in time. As well, since snapshots are typically implemented using copy-on-write techniques that distinguish what has changed from what is resident on disk, these snapshots provide differences that can also be composed or added together to efficiently copy data throughout the system.
- the format of the snapshot may be the format of data that is copied by Data Mover 502 , which is described below.
- a standard copy operation copies all or a subset of a source data object in one storage pool to a data object in another storage pool.
- the result is two distinct objects.
- One type of standard copy operation that may be used is an initial “baseline” copy. This is typically done when data is initially copied from one Virtual Storage Pool into another, such as from a performance-optimized pool to a capacity-optimized storage pool.
- Another type of standard copy operation may be used wherein only changed data or differences are copied to a target storage pool to update the target object. This would occur after an initial baseline copy has previously been performed.
- a complete exhaustive version of an object need not be preserved in the system each time a copy is made, even though a baseline copy is needed when the Data Virtualization System is first initialized. This is because each virtual copy provides access to a complete copy. Any delta or difference can be expressed in relation to a virtual copy instead of in relation to a baseline. This has the positive side effect of virtually eliminating the common step of walking through a series of change lists.
- Standard copy operations are initiated by a series of instructions or requests supplied by the Pool Manager and received by the Data Mover to cause the movement of data among the Data Storage Objects, and to maintain the Data Storage Objects themselves.
- the copy operations allow the creation of copies of the specified Data Storage Objects using the resources of a specified Virtual Storage Pool. The result is a copy of the source Data Object in a target Data Object in the storage pool.
- the Snapshot and Copy operations are each structured with a preparation operation and an activation operation.
- the two steps of prepare and activate allow the long-running resource allocation operations, typical of the prepare phase, to be decoupled from the actuation. This is required by applications that can only be paused for a short while to fulfill the point-in-time characteristics of a snapshot operation, which in reality takes a finite but non-zero amount of time to accomplish.
- this two-step preparation and activation structure allows the Policy Engine to proceed with an operation only if resources for all of the collection members can be allocated.
- Object Maintenance operations are a series of operations for maintaining data objects, including creation, destruction, and duplication.
- the Object Manager and Data Mover use functionality provided by a Pool Request Broker (more below) to implement these operations.
- the data objects may be maintained at a global level, at each Storage Pool, or preferably both.
- Collection operations are auxiliary functions. Collections are abstract software concepts, lists maintained in memory by the object manager. They allow the Policy Engine 206 to request a series of operations over all of the members in a collection, allowing a consistent application of a request to all members.
- the use of collections allows for simultaneous activation of the point-in-time snapshot so that multiple Data Storage Objects are all captured at precisely the same point in time, as this is typically required by the application for a logically correct restore.
- the use of collections allows for convenient request of a copy operation across all members of a collection, where an application would use multiple storage objects as a logical whole.
- the Object Manager discovers Virtual Storage Pools by issuing Object Management Operations 505 to the Pool Manager 504 , and uses the information obtained about each of the pools to select one that meets the required criteria for a given request, or in the case where none match, a default pool is selected, and the Object Manager can then create a data storage object using resources from the selected Virtual Storage Pool.
- the Object Manager also provides sets of Object Management operations to allow and maintain the availability of these objects to external Applications.
- the first set is operations for registering and unregistering the computers where the user's Applications reside.
- the computers are registered by the identities typical to the storage network in use (e.g. Fibre Channel WWPN, iSCSI identity, etc.).
- the second set is “mapping” operations, and when permitted by the storage pool from which an object is created, the Data Storage Object can be “mapped,” that is, made available for use to a computer on which a user Application resides.
- This availability takes a form appropriate to the storage, e.g. a block device presented on a SAN as a Fibre Channel disk or iSCSI device on a network, a filesystem on a file sharing network, etc. and is usable by the operating system on the Application computer.
- an “unmapping” operation reverses the availability of the virtual storage device on the network to a user Application. In this way, data stored for one Application, i.e. a backup, can be made available to another Application on another computer at a later time, i.e. a restore.
- the Data Mover 502 is a software component within the Object Manager and Data Mover that reads and writes data among the various Data Storage Objects 503 according to instructions received from the Object Manager for Snapshot (Point in Time) Copy requests and standard copy requests.
- the Data Mover provides operations for reading and writing data among instances of data objects throughout the system.
- the Data Mover also provides operations that allow querying and maintaining the state of long running operations that the Object Manager has requested for it to perform.
- the Data Mover uses functionality from the Pool Functionality Providers (see FIG. 6 ) to accomplish its operation.
- the Snapshot functionality provider 608 allows creation of a data object instance representing an initial object instance at a specific point in time.
- the Difference Engine functionality provider 614 is used to request a description of the differences between two data objects that are related in a temporal chain. For data objects stored on content-addressable pools, a special functionality is provided that can provide differences between any two arbitrary data objects. This functionality is also provided for performance-optimized pools, in some cases by an underlying storage virtualization system, and in other cases by a module that implements this on top of commodity storage.
- the Data Mover 502 uses the information about the differences to select the set of data that it copies between instances of data objects 503 .
- the Difference Engine Provider provides a specific representation of the differences between two states of a Data Storage Object over time.
- the changes between two points in time are recorded as writes to a given part of the Data Storage Object.
- the difference is represented as a bitmap where each bit corresponds to an ordered list of the Data Object areas, starting at the first and ascending in order to the last, where a set bit indicates a modified area. This bitmap is derived from the copy-on-write bitmaps used by the underlying storage virtualization system.
- the difference may be represented as a list of extents corresponding to changed areas of data.
- the representation is described below, and is used to determine efficiently the parts of two Content Addressable Data Objects that differ.
- the Data Mover uses this information to copy only those sections that differ, so that a new version of a Data Object can be created from an existing version by first duplicating it, obtaining the list of differences, and then moving only the data corresponding to those differences in the list.
- the Data Mover 502 traverses the list of differences, moving the indicated areas from the source Data Object to the target Data Object. (See Optimal Way for Data Backup and Restore.)
- the Object Manager 501 instructs the Data Mover 502 through a series of operations to copy data among the data objects in the Virtual Storage Pools 418 .
- the procedure comprises the following steps, starting at the reception of instructions:
- the collection name from above is used as well as the name of the source Data Object that is to be copied and the name of two antecedents: a Data Object against which differences are to be taken in the source Storage Resource Pool, and a corresponding Data Object in the target Storage Resource Pool. This step is repeated for each source Data Object to be operated on in this set.
- the collection name is supplied as well as a Storage Resource Pool to act as a target.
- the prepare command instructs the Object Manager to contact the Storage Pool Manager to create the necessary target Data Objects, corresponding to each of the sources in the collection.
- the prepare command also supplies the corresponding Data Object in the target Storage Resource Pool to be duplicated, so the Provider can duplicate the provided object and use that as a target object.
- a reference name for the copy request is returned.
- the reference name for the copy request returned above is supplied.
- the Data Mover is instructed to copy a given source object to its corresponding target object.
- Each request includes a reference name as well as a sequence number to describe the overall job (the entire set of source target pairs) as well as a sequence number to describe each individual source-target pair.
- the names of the corresponding antecedents are supplied as part of the Copy instruction.
- the Copy Engine uses the name of the Data Object in the source pool to obtain the differences between the antecedent and the source from the Difference Engine at the source.
- the indicated differences are then transmitted from the source to the target.
- these differences are transmitted as bitmaps and data.
- these differences are transmitted as extent lists and data.
- Data Storage Objects are software constructs that permit the storage and retrieval of Application data using idioms and methods familiar to computer data processing equipment and software. In practice these currently take the form of a SCSI block device on a storage network, e.g. a SCSI LUN, or a content-addressable container, where a designator for the content is constructed from and uniquely identifies the data therein.
- Data Storage Objects are created and maintained by issuing instructions to the Pool Manager. The actual storage for persisting the Application data is drawn from the Virtual Storage Pool from which the Data Storage Object is created.
- the structure of the data storage object varies depending on the storage pool from which it is created.
- the data structure for a given block device Data Object implements a mapping between the Logical Block Address (LBA) of each of the blocks within the Data Object to the device identifier and LBA of the actual storage location.
- LBA Logical Block Address
- the identifier of the Data Object is used to identify the set of mappings to be used.
- the current embodiment relies on the services provided by the underlying physical computer platform to implement this mapping, and relies on its internal data structures, such as bitmaps or extent lists.
- the content signature is used as the identifier, and the Data Object is stored as is described below in the section about deduplication.
- a Pool Manager 504 is a software component for managing virtual storage resources and the associated functionality and characteristics as described below.
- the Object manager 501 and Data Movement Engine 502 communicate with one or more Pool Managers 504 to maintain Data Storage Objects 503 .
- Virtual Storage Resources 510 are various kinds of storage made available to the Pool Manager for implementing storage pool functions, as described below.
- a storage virtualizer is used to present various external Fibre Channel or iSCSI storage LUNs as virtualized storage to the Pool Manager 504 .
- FIG. 6 further illustrates the Storage Pool Manager 504 .
- the purpose of the storage pool manager is to present underlying virtual storage resources to the Object Manager/Data Mover as Storage Resource Pools, which are abstractions of storage and data management functionality with common interfaces that are utilized by other components of the system. These common interfaces typically include a mechanism for identifying and addressing data objects associated with a specific temporal state, and a mechanism for producing differences between data objects in the form of bitmaps or extents.
- the pool manager presents a Primary Storage Pool, a Performance Optimized Pool, and a Capacity Optimized Pool.
- the common interfaces allow the object manager to create and delete Data Storage objects in these pools, either as copies of other data storage objects or as new objects, and the data mover can move data between data storage objects, and can use the results of data object differencing operations.
- the storage pool manager has a typical architecture for implementing a common interface to diverse implementations of similar functionality, where some functionality is provided by “smart” underlying resources, and other functionality must be implemented on top of less functional underlying resources.
- Pool request broker 602 and pool functionality providers 604 are software modules executing in either the same process as the Object Manager/Data Mover, or in another process communicating via a local or network protocol such as TCP.
- the providers comprise a Primary Storage provider 606 , Snapshot provider 608 , Content Addressable provider 610 , and Difference Engine provider 614 , and these are further described below.
- the set of providers may be a superset of those shown here.
- Virtual Storage Resources 510 are the different kinds of storage made available to the Pool Manager for implementing storage pool functions.
- the virtual storage resources comprise sets of SCSI logical units from a storage virtualization system that runs on the same hardware as the pool manager, and accessible (for both data and management operations) through a programmatic interface: in addition to standard block storage functionality additional capabilities are available including creating and deleting snapshots, and tracking changed portions of volumes.
- the virtual resources can be from an external storage system that exposes similar capabilities, or may differ in interface (for example accessed through a file-system, or through a network interface such as CIFS, iSCSI or CDMI), in capability (for example, whether the resource supports an operation to make a copy-on-write snapshot), or in non-functional aspects (for example, high-speed/limited-capacity such as Solid State Disk versus low-speed/high-capacity such as SATA disk).
- interface for example accessed through a file-system, or through a network interface such as CIFS, iSCSI or CDMI
- capability for example, whether the resource supports an operation to make a copy-on-write snapshot
- non-functional aspects for example, high-speed/limited-capacity such as Solid State Disk versus low-speed/high-capacity such as SATA disk).
- the capabilities and interface available determine which providers can consume the virtual storage resources, and which pool functionality needs to be implemented within the pool manager by one or more providers: for example, this implementation of a content addressable storage provider only requires “dumb” storage, and the implementation is entirely within content addressable provider 610 ; an underlying content addressable virtual storage resource could be used instead with a simpler “pass-through” provider. Conversely, this implementation of a snapshot provider is mostly “pass-through” and requires storage that exposes a quick point-in-time copy operation.
- Pool Request Broker 602 is a simple software component that services requests for storage pool specific functions by executing an appropriate set of pool functionality providers against the configured virtual storage resource 510 .
- the requests that can be serviced include, but are not limited to, creating an object in a pool; deleting an object from a pool; writing data to an object; reading data from an object; copying an object within a pool; copying an object between pools; requesting a summary of the differences between two objects in a pool.
- Primary storage provider 606 enables management interfaces (for example, creating and deleting snapshots, and tracking changed portions of files) to a virtual storage resource that is also exposed directly to applications via an interface such as fibre channel, iSCSI, NFS or CIFS.
- management interfaces for example, creating and deleting snapshots, and tracking changed portions of files
- a virtual storage resource that is also exposed directly to applications via an interface such as fibre channel, iSCSI, NFS or CIFS.
- Snapshot provider 608 implements the function of making a point-in-time copy of data from a Primary resource pool. This creates the abstraction of another resource pool populated with snapshots. As implemented, the point-in-time copy is a copy-on-write snapshot of the object from the primary resource pool, consuming a second virtual storage resource to accommodate the copy-on-write copies, since this management functionality is exposed by the virtual storage resources used for primary storage and for the snapshot provider.
- Difference engine provider 614 can satisfy a request for two objects in a pool to be compared that are connected in a temporal chain.
- the difference sections between the two objects are identified and summarized in a provider-specific way, e.g. using bitmaps or extents.
- the difference sections might be represented as a bitmap where each set bit denotes a fixed size region where the two objects differ; or the differences might be represented procedurally as a series of function calls or callbacks.
- a difference engine may produce a result efficiently in various ways.
- a difference engine acting on a pool implemented via a snapshot provider uses the copy-on-write nature of the snapshot provider to track changes to objects that have had snapshots made. Consecutive snapshots of a single changing primary object thus have a record of the differences that is stored alongside them by the snapshot provider, and the difference engine for snapshot pools simply retrieves this record of change.
- a difference engine acting on a pool implemented via a Content Addressable provider uses the efficient tree structure (see below, FIG. 12 ) of the content addressable implementation to do rapid comparisons between objects on demand.
- Content addressable provider 610 implements a write-once content addressable interface to the virtual storage resource it consumes. It satisfies read, write, duplicate and delete operations. Each written or copied object is identified by a unique handle that is derived from its content. The content addressable provider is described further below ( FIG. 11 ).
- the pool request broker 502 accepts requests for data manipulation operations such as copy, snapshot, or delete on a pool or object.
- the request broker determines which provider code from pool 504 to execute by looking at the name or reference to the pool or object.
- the broker then translates the incoming service request into a form that can be handled by the specific pool functionality provider, and invokes the appropriate sequence of provider operations.
- an incoming request could ask to make a snapshot from a volume in a primary storage pool, into a snapshot pool.
- the incoming request identifies the object (volume) in the primary storage pool by name, and the combination of name and operation (snapshot) determines that the snapshot provider should be invoked which can make point-in-time snapshots from the primary pool using the underlying snapshot capability.
- This snapshot provider will translate the request into the exact form required by the native copy-on-write function performed by the underlying storage virtualization appliance, such as bitmaps or extents, and it will translate the result of the native copy-on-write function to a storage volume handle that can be returned to the object manager and used in future requests to the pool manager.
- Optimal Way for Data Backup is a series of operations to make successive versions of Application Data objects over time, while minimizing the amount of data that must be copied by using bitmaps, extents and other temporal difference information stored at the Object Mover. It stores the application data in a data storage object and associates with it the metadata that relates the various changes to the application data over time, such that changes over time can be readily identified.
- the procedure comprises the following steps:
- Each data object within the destination Virtual Storage Pool is complete; that is, it represents the entire data object and allows access to the all of the Application Data at the point in time without requiring external reference to state or representations at other points in time.
- the object is accessible without replaying all deltas from a baseline state to the present state.
- the duplication of initial and subsequent versions of the data object in the destination Virtual Storage Pool does not require exhaustive duplication of the Application Data contents therein.
- to arrive at second and subsequent states requires only the transmission of the changes tracked and maintained, as described above, without exhaustive traversal, transmission or replication of the contents of the data storage object.
- the operation of the Optimal Way for Data Restore is the converse of the Optimal Way for Data Backup.
- the procedure to recreate the desired state of a data object in a destination Virtual Storage Pool at a given point in time comprises the following steps:
- Access to the desired state is complete: it does not require external reference to other containers or other states. Establishing the desired state given a reference state requires neither exhaustive traversal nor exhaustive transmission, only the retrieved changes indicated by the provided representations within the source Virtual Storage Pool.
- FIG. 7 illustrates the Service Level Agreement.
- the Service Level Agreement captures the detailed business requirements with respect to secondary copies of the application data.
- the business requirements define when and how often copies are created, how long they are retained and in what type of storage pools these copies reside. This simplistic description does not capture several aspects of the business requirements.
- the frequency of copy creation for a given type of pool may not be uniform across all hours of the day or across all days of a week. Certain hours of the day, or certain days of a week or month may represent more (or less) critical periods in the application data, and thus may call for more (or less) frequent copies.
- all copies of application data in a particular pool may not be required to be retained for the same length of time. For example, a copy of the application data created at the end of monthly processing may need to be retained for a longer period of time than a copy in the same storage pool created in the middle of a month.
- the Service Level Agreement 304 of certain embodiments has been designed to represent all of these complexities that exist in the business requirements.
- the Service Level Agreement has four primary parts: the name, the description, the housekeeping attributes and a collection of Service Level Policies. As mentioned above, there is one SLA per application.
- the name attribute 701 allows each Service Level Agreement to have a unique name.
- the description attribute 702 is where the user can assign a helpful description for the Service Level Agreement.
- the Service Level agreement also has a number of housekeeping attributes 703 that enable it to be maintained and revised. These attributes include but are not limited to the owner's identity, the dates and times of creation, modification and access, priority, enable/disable flags.
- the Service Level Agreement also contains a plurality of Service Level Policies 705 .
- Some Service level Agreements may have just a single Service Level Policy. More typically, a single SLA may contain tens of policies.
- Each Service Level Policy consists of at least the following, in certain embodiments: the source storage pool location 706 and type 708 ; the target storage pool location 710 and type 712 ; the frequency for the creation of copies 714 , expressed as a period of time; the length of retention of the copy 716 , expressed as a period of time; the hours of operation 718 during the day for this particular Service Level Policy; and the days of the week, month or year 720 on which this Service Level Policy applies.
- Each Service Level Policy specifies a source and target storage pool, and the frequency of copies of application data that are desired between those storage pools. Furthermore, the Service Level Policy specifies its hours of operation and days on which it is applicable. Each Service Level Policy is the representation of one single statement in the business requirements for the protection of application data. For example, if a particular application has a business requirement for an archive copy to be created each month after the monthly close and retained for three years, this might translate to a Service level Policy that requires a copy from the Local Backup Storage Pool into the Long-term Archive Storage Pool at midnight on the last day of the month, with a retention of three years.
- All of the Service Level Policies with a particular combination of source and destination pool and location say for example, source Primary Storage pool and destination local Snapshot pool, when taken together, specify the business requirements for creating copies into that particular destination pool.
- Business requirements may dictate for example that snapshot copies be created every hour during regular working hours, but only once every four hours outside of these times.
- Two Service Level Policies with the same source and target storage pools will effectively capture these requirements in a form that can be put into practice by the Service Policy Engine.
- This form of a Service Level Agreement allows the representation of the schedule of daily, weekly and monthly business activities, and thus captures business requirements for protecting and managing application data much more accurately than traditional RPO and RPO based schemes. By allowing hour of operation and days, weeks, and months of the year, scheduling can occur on a “calendar basis.”
- a combination of Service Level Policies may require a large number of snapshots to be preserved for a short time, such as 10 minutes, and a lesser number of snapshots to be preserved for a longer time, such as 8 hours; this allows a small amount of information that has been accidentally deleted can be reverted to a state not more than 10 minutes before, while still providing substantial data protection at longer time horizons without requiring the storage overhead of storing all snapshots taken every ten minutes.
- the backup data protection function may be given one Policy that operates with one frequency during the work week, and another frequency during the weekend.
- Service Level Policies for all of the different classes of source and destination storage are included, the Service Level Agreement fully captures all of the data protection requirements for the entire application, including local snapshots, local long duration stores, off-site storage, archives, etc.
- a collection of policies within a SLA is capable of expressing when a given function should be performed, and is capable of expressing multiple data management functions that should be performed on a given source of data.
- Service Level Agreements are created and modified by the user through a user interface on a management workstation. These agreements are electronic documents stored by the Service Policy Engine in a structured SQL database or other repository that it manages. The policies are retrieved, electronically analyzed, and acted upon by the Service Policy Engine through its normal scheduling algorithm as described below.
- FIG. 8 illustrates the Application Specific Module 402 .
- the Application Specific module runs close to the Application 300 (as described above), and interacts with the Application and its operating environment to gather metadata and to query and control the Application as required for data management operations.
- the Application Specific Module interacts with various components of the application and its operating environment including Application Service Processes and Daemons 801 , Application Configuration Data 802 , Operating System Storage Services 803 (such as VSS and VDS on Windows), Logical Volume Management and Filesystem Services 804 , and Operating System Drivers and Modules 805 .
- the Application Specific Module performs these operations in response to control commands from the Service Policy Engine 406 .
- Metadata Collection and Application Consistency.
- Metadata Collection is the process by which the Application Specific Module collects metadata about the application.
- metadata includes information such as: configuration parameters for the application; state and status of the application; control files and startup/shutdown scripts for the application; location of the datafiles, journal and transaction logs for the application; and symbolic links, filesystem mount points, logical volume names, and other such entities that can affect the access to application data.
- Metadata is collected and saved along with application data and SLA information. This guarantees that each copy of application data within the system is self contained and includes all of the details required to rebuild the application data.
- Application Consistency is the set of actions that ensure that when a copy of the application data is created, the copy is valid, and can be restored into a valid instance of the application. This is critical when the business requirements dictate that the application be protected while it is live, in its online, operational state. The application may have interdependent data relations within its data stores, and if these are not copied in a consistent state will not provide a valid restorable image.
- the exact process of achieving application consistency varies from application to application. Some applications have a simple flush command that forces cached data to disk. Some applications support a hot backup mode where the application ensures that its operations are journalled in a manner that guarantees consistency even as application data is changing. Some applications require interactions with operating system storage services such as VSS and VDS to ensure consistency.
- the Application Specific Module is purpose-built to work with a particular application and to ensure the consistency of that application. The Application Specific Module interacts with the underlying storage virtualization device and the Object Manager to provide consistent snapshots of application data.
- the preferred embodiment of the Application Specific Module 402 is to run on the same server as Application 300 . This assures the minimum latency in the interactions with the application, and provides access to storage services and filesystems on the application host.
- the application host is typically considered primary storage, which is then snapshotted to a performance-optimized store.
- the Application Specific Module is only triggered to make a snapshot when access to application data is required at a specific time, and when a snapshot for that time does not exist elsewhere in the system, as tracked by the Object Manager.
- the Object Manager is able to fulfill subsequent data requests from the performance-optimized data store, including for satisfying multiple requests for backup and replication which may issue from secondary, capacity-optimized pools.
- the Object Manager may be able to provide object handles to the snapshot in the performance-optimized store, and may direct the performance-optimized store in a native format that is specific to the format of the snapshot, which is dependent on the underlying storage appliance.
- this format may be application data combined with one or more LUN bitmaps indicating which blocks have changed; in other embodiments it may be specific extents.
- the format used for data transfer is thus able to transfer only a delta or difference between two snapshots using bitmaps or extents.
- Metadata such as the version number of the application, may also be stored for each application along with the snapshot.
- application metadata is read and used for the policy. This metadata is stored along with the data objects.
- application metadata will only be read once during the lightweight snapshot operation, and preparatory operations which occur at that time such as flushing caches will only be performed once during the lightweight snapshot operation, even though this copy of application data along with its metadata may be used for multiple data management functions.
- FIG. 9 illustrates the Service Policy Engine 406 .
- the Service Policy Engine contains the Service Policy Scheduler 902 , which examines all of the Service Level Agreements configured by the user and makes scheduling decisions to satisfy Service Level Agreements. It relies on several data stores to capture information and persist it over time, including, in some embodiments, a SLA Store 904 , where configured Service Level Agreements are persisted and updated; a Resource Profile Store 906 , storing Resource Profiles that provide a mapping between logical storage pool names and actual storage pools; Protection Catalog Store 908 , where information is cataloged about previous successful copies created in various pools that have not yet expired; and centralized History Store 910 .
- History Store 910 is where historical information about past activities is saved for the use of all data management applications, including the timestamp, order and hierarchy of previous copies of each application into various storage pools. For example, a snapshot copy from a primary data store to a capacity-optimized data store that is initiated at 1 P.M. and is scheduled to expire at 9 P.M. will be recorded in History Store 910 in a temporal data store that also includes linked object data for snapshots for the same source and target that have taken place at 11 A.M. and 12 P.M.
- These stores are managed by the Service Policy Engine. For example, when the user, through the Management workstation creates a Service Level Agreement, or modifies one of the policies within it, it is the Service Policy Engine that persists this new SLA in its store, and reacts to this modification by scheduling copies as dictated by the SLA. Similarly, when the Service Policy Engine successfully completes a data movement job that results in a new copy of an application in a Storage Pool, the Storage Policy Engine updates the History Store, so that this copy will be factored into future decisions.
- the preferred embodiment of the various stores used by the Service Policy Engine is in the form of tables in a relational database management system in close proximity to the Service Policy Engine. This ensures consistent transactional semantics when querying and updating the stores, and allows for flexibility in retrieving interdependent data.
- the scheduling algorithm for the Service Policy Scheduler 902 is illustrated in FIG. 10 .
- the Service Policy Scheduler decides it needs to make a copy of application data from one storage pool to another, it initiates a Data Movement Requestor and Monitor task, 912 .
- These tasks are not recurring tasks and terminate when they are completed.
- a plurality of these requestors might be operational at the same time.
- the Service Policy Scheduler considers the priorities of Service Level Agreements when determining which additional tasks to undertake. For example, if one Service Level Agreement has a high priority because it specifies the protection for a mission-critical application, whereas another SLA has a lower priority because it specifies the protection for a test database, then the Service Policy Engine may choose to run only the protection for the mission-critical application, and may postpone or even entirely skip the protection for the lower priority application. This is accomplished by the Service Policy Engine scheduling a higher priority SLA ahead of a lower priority SLA. In the preferred embodiment, in such a situation, for auditing purposes, the Service Policy Engine will also trigger a notification event to the management workstation.
- FIG. 10 illustrates the flowchart of the Policy Schedule Engine.
- the Policy Schedule Engine continuously cycles through all the SLAs defined. When it gets to the end of all of the SLAs, it sleeps for a short while, e.g. 10 seconds, and resumes looking through the SLAs again.
- Each SLA encapsulates the complete data protection business requirements for one application; thus all of the SLAs represent all of the applications.
- the schedule engine collects together all of the Service Level Policies that have the same source pool and destination pool 1004 the process state at 1000 and iterates to the next SLA in the set of SLAs in 1002 . Taken together, this subset of the Service Level Policies represent all of the requirements for a copy from that source storage pool to that particular destination storage pool.
- the Service Policy Scheduler discards the policies that are not applicable to today, or are outside their hours of operation. Among the policies that are left, find the policy that has the shortest frequency 1006 , and based on the history data and in history store 910 , the one with the longest retention that needs to be run next 1008 .
- the Scheduler moves to the next Source and Destination pool combination for the same Service Level agreement 1018 . If there are no more distinct combinations, the Scheduler moves on to the next Service Level Agreement 1020 .
- Service Policy Scheduler After the Service Policy Scheduler has been through all source/destination pool combinations of all Service Level Agreements, it pauses for a short period and then resumes the cycle.
- a simple example system with a snapshot store and a backup store, with only 2 policies defined, would interact with the Service Policy Scheduler as follows. Given two policies, one stating “backup every hour, the backup to be kept for 4 hours” and another stating “backup every 2 hours, the backup to be kept for 8 hours,” the result would be a single snapshot taken each hour, the snapshots each being copied to the backup store but retained a different amount of time at both the snapshot store and the backup store. The “backup every 2 hours” policy is scheduled to go into effect at 12:00 P.M by the system administrator.
- the Service Policy Scheduler begins operating at step 1000 , it finds the two policies at step 1002 . (Both policies apply because a multiple of two hours has elapsed since 12:00 P.M.) There is only one source and destination pool combination at step 1004 . There are two frequencies at step 1006 , and the system selects the 1-hour frequency because it is shorter than the 2-hour frequency. There are two operations with different retentions at step 1008 , and the system selects the operation with the 8-hour retention, as it has the longer retention value. Instead of one copy being made to satisfy the 4-hour requirement and another copy being made to satisfy the 8-hour requirement, the two requirements are coalesced into the longer 8-hour requirement, and are satisfied by a single snapshot copy operation.
- the system determines that a copy is due at step 1010 , and checks the relevant objects at the History Store 910 to determine if the copy has already been made at the target (at step 912 ) and at the source (at step 914 ). If these checks are passed, the system initiates the copy at step 916 , and in the process triggers a snapshot to be made and saved at the snapshot store. The snapshot is then copied from the snapshot store to the backup store. The system then goes to sleep 1022 and wakes up again after a short period, such as 10 seconds. The result is a copy at the backup store and a copy at the snapshot store, where every even-hour snapshot lasts for 8 hours, and every odd-hour snapshot lasts 4 hours. The even-hour snapshots at the backup store and the snapshot store are both tagged with the retention period of 8 hours, and will be automatically deleted from the system by another process at that time.
- FIG. 11 is a block diagram of the modules implementing the content addressable store for the Content Addressable Provider 510 .
- the content addressable store 510 implementation provides a storage resource pool that is optimized for capacity rather than for copy-in or copy-out speed, as would be the case for the performance-optimized pool implemented through snapshots, described earlier, and thus is typically used for offline backup, replication and remote backup.
- Content addressable storage provides a way of storing common subsets of different objects only once, where those common subsets may be of varying sizes but typically as small as 4 KiBytes.
- the storage overhead of a content addressable store is low compared to a snapshot store, though the access time is usually higher.
- a content addressable store has no intrinsic relationship to one another, even though they may share a large percentage of their content, though in this implementation a history relationship is also maintained, which is an enabler of various optimizations to be described.
- the content addressable store will store only one copy of a data subset that is repeated multiple times within a single object, whereas a snapshot-based store will store at least one full-copy of any object.
- the content addressable store 510 is a software module that executes on the same system as the pool manager, either in the same process or in a separate process communicating via a local transport such as TCP.
- the content addressable store module runs in a separate process so as to minimize impact of software failures from different components.
- This module's purpose is to allow storage of Data Storage Objects 403 in a highly space-efficient manner by deduplicating content (i.e., ensuring repeated content within single or multiple data objects is stored only once).
- the content addressable store module provides services to the pool manager via a programmatic API. These services comprise the following:
- Object to Handle mapping 1102 an object can be created by writing data into the store via an API; once the data is written completely the API returns an object handle determined by the content of the object. Conversely, data may be read as a stream of bytes from an offset within an object by providing the handle. Details of how the handle is constructed are explained in connection with the description of FIG. 12 .
- Temporal Tree Management 1104 tracks parent/child relationships between data objects stored.
- an API When a data object is written into the store 510 , an API allows it to be linked as a child to a parent object already in the store. This indicates to the content addressable store that the child object is a modification of the parent.
- a single parent may have multiple children with different modifications, as might be the case for example if an application's data were saved into the store regularly for some while; then an early copy were restored and used as a new starting point for subsequent modifications.
- Temporal tree management operations and data models are described in more detail below.
- Difference Engine 1106 can generate a summary of difference regions between two arbitrary objects in the store.
- the differencing operation is invoked via an API specifying the handles of two objects to be compared, and the form of the difference summary is a sequence of callbacks with the offset and size of sequential difference sections.
- the difference is calculated by comparing two hashed representations of the objects in parallel.
- Garbage Collector 1108 is a service that analyzes the store to find saved data that is not referenced by any object handle, and to reclaim the storage space committed to this data. It is the nature of the content addressable store that much data is referenced by multiple object handles, i.e., the data is shared between data objects; some data will be referenced by a single object handle; but data that is referenced by no object handles (as might be the case if an object handle has been deleted from the content addressable system) can be safely overwritten by new data.
- Object Replicator 1110 is a service to duplicate data objects between two different content addressable stores. Multiple content addressable stores may be used to satisfy additional business requirements, such as offline backup or remote backup.
- the Data Hash module 1112 generates fixed length keys for data chunks up to a fixed size limit. For example, in this embodiment the maximum size of chunk that the hash generator will make a key for is 64 KiB.
- the fixed length key is either a hash, tagged to indicate the hashing scheme used, or a non-lossy algorithmic encoding.
- the hashing scheme used in this embodiment is SHA-1, which generates a secure cryptographic hash with a uniform distribution and a probability of hash collision near enough zero that no facility need be incorporated into this system to detect and deal with collisions.
- the Data Handle Cache 1114 is a software module managing an in-memory database that provides ephemeral storage for data and for handle-to-data mappings.
- the Persistent Handle Management Index 1104 is a reliable persistent database of CAH-to-data mappings.
- this embodiment is implemented as a B-tree, mapping hashes from the hash generator to pages in the persistent data store 1118 that contain the data for this hash. Since the full B-tree cannot be held in memory at one time, for efficiency, this embodiment also uses an in-memory bloom filter to avoid expensive B-tree searches for hashes known not to be present.
- the Persistent Data Storage module 1118 stores data and handles to long-term persistent storage, returning a token indicating where the data is stored.
- the handle/token pair is subsequently used to retrieve the data.
- data is written to persistent storage, it passes through a layer of lossless data compression 1120 , in this embodiment implemented using zlib, and a layer of optional reversible encryption 1122 , which is not enabled in this embodiment.
- copying a data object into the content addressable store is an operation provided by the object/handle mapper service, since an incoming object will be stored and a handle will be returned to the requestor.
- the object/handle mapper reads the incoming object, requests hashes to be generated by the Data Hash Generator, stores the data to Persistent Data Storage and the handle to the Persistent Handle Management Index.
- the Data Handle Cache is kept updated for future quick lookups of data for the handle.
- Data stored to Persistent Data Storage is compressed and (optionally) encrypted before being written to disk.
- a request to copy in a data object will also invoke the temporal tree management service to make a history record for the object, and this is also persisted via Persistent Data Storage.
- copying a data object out of the content addressable store given its handle is another operation provided by the object/handle mapper service.
- the handle is looked up in the Data Handle Cache to locate the corresponding data; if the data is missing in the cache the persistent index is used; once the data is located on disk, it is retrieved via persistent data storage module (which decrypts and decompresses the disk data) and then reconstituted to return to the requestor.
- FIG. 12 shows how the handle for a content addressed object is generated.
- the data object manager references all content addressable objects with a content addressable handle.
- This handle is made up of three parts.
- the first part 1201 is the size of the underlying data object the handle immediately points to.
- the second part 1202 is the depth of object it points to.
- the third 1203 is a hash of the object it points to.
- Field 1203 optionally includes a tag indicating that the hash is a non-lossy encoding of the underlying data.
- the tag indicates the encoding scheme used, such as a form of run-length encoding (RLE) of data used as an algorithmic encoding if the data chunk can be fully represented as a short enough RLE. If the underlying data object is too large to be represented as a non-lossy encoding, a mapping from the hash to a pointer or reference to the data is stored separately in the persistent handle management index 1104 .
- RLE run-length
- the data for a content addressable object is broken up into chunks 1204 .
- the size of each chunk must be addressable by one content addressable handle 1205 .
- the data is hashed by the data hash module 1102 , and the hash of the chunk is used to make the handle. If the data of the object fits in one chunk, then the handle created is the final handle of the object. If not, then the handles themselves are grouped together into chunks 1206 and a hash is generated for each group of handles. This grouping of handles continues 1207 until there is only one handle 1208 produced which is then the handle for the object.
- the top level content handle is dereferenced to obtain a list of next-level content handles. These are dereferenced in turn to obtain further lists of content handles until depth-0 handles are obtained. These are expanded to data, either by looking up the handle in the handle management index or cache, or (in the case of an algorithmic hash such as run-length encoding) expanding deterministically to the full content.
- FIG. 13 illustrates the temporal tree relationship created for data objects stored within the content addressable store. This particular data structure is utilized only within the content addressable store.
- the temporal tree management module maintains data structures 1302 in the persistent store that associate each content-addressed data object to a parent (which may be null, to indicate the first in a sequence of revisions).
- the individual nodes of the tree contain a single hash value. This hash value references a chunk of data, if the hash is a depth-0 hash, or a list of other hashes, if the hash is a depth-1 or higher hash.
- the references mapped to a hash value is contained in the Persistent Handle Management Index 1104 .
- the edges of the tree may have weights or lengths, which may be used in an algorithm for finding neighbors.
- the “Add” operation is used whenever an object is copied-in to the CAS from an external pool. If the copy-in is via the Optimal Way for Data Backup, or if the object is originating in a different CAS pool, then it is required that a predecessor object be specified, and the Add operation is invoked to record this predecessor/successor relationship.
- the “Remove” operation is invoked by the object manager when the policy manager determines that an object's retention period has expired. This may lead to data stored in the CAS having no object in the temporal tree referring to it, and therefore a subsequent garbage collection pass can free up the storage space for that data as available for re-use.
- Different CAS pools may be used to accomplish different business objectives such as providing disaster recovery in a remote location.
- the copy may be sent as hashes and offsets, to take advantage of the native deduplication capabilities of the target CAS.
- the underlying data pointed to by any new hashes is also sent on an as-needed basis.
- the temporal tree structure is read or navigated as part of the implementation of various services:
- the CAS difference engine 1106 compares two objects identified by hash values or handles as in FIGS. 11 and 12 , and produces a sequence of offsets and extents within the objects where the object data is known to differ. This sequence is achieved by traversing the two object trees in parallel in the hash data structure of FIG. 12 .
- the tree traversal is a standard depth- or breadth-first traversal. During traversal, the hashes at the current depth are compared. Where the hash of a node is identical between both sides, there is no need to descend the tree further, so the traversal may be pruned. If the hash of a node is not identical, the traversal continues descending into the next lowest level of the tree.
- the traversal reaches a depth-0 hash that is not identical to its counterpart, then the absolute offset into the data object being compared where the non-identical data occurs, together with the data length, is emitted into the output sequence. If one object is smaller in size than another, then its traversal will complete earlier, and all subsequent offsets encountered in the traversal of the other are emitted as differences.
- Garbage Collector is a service that analyzes a particular CAS store to find saved data that is not referenced by any object handle in the CAS store temporal data structure, and to reclaim the storage space committed to this data.
- Garbage collection uses a standard “Mark and Sweep” approach. Since the “mark” phase may be quite expensive, the algorithm used for the mark phase attempts to minimize marking the same data multiple times, even though it may be referenced many times; however the mark phase must be complete, ensuring that no referenced data is left unmarked, as this would result in data loss from the store as, after a sweep phase, unmarked data would later be overwritten by new data.
- the algorithm employed for marking referenced data uses the fact that objects in the CAS are arranged in graphs with temporal relationships using the data structure depicted in FIG. 13 . It is likely that objects that share an edge in these graphs differ in only a small subset of their data, and it is also rare that any new data chunk that appears when an object is created from a predecessor should appear again between any two other objects. Thus, the mark phase of garbage collection processes each connected component of the temporal graph.
- FIG. 14 is an example of garbage collection using temporal relationships in certain embodiments.
- a depth-first search is made, represented by arrows 1402 , of a data structure containing temporal relationships. Take a starting node 1404 from which to begin the tree traversal. Node 1404 is the tree root and references no objects. Node 1406 contains references to objects H 1 and H 2 , denoting a hash value for object 1 and a hash value for object 2. All depth-0, depth-1 and higher data objects that are referenced by node 1406 , here H 1 and H 2 , are enumerated and marked as referenced.
- node 1408 is processed. As it shares an edge with node 1406 , which has been marked, the difference engine is applied to the difference between the object referenced by 1406 and the object referenced by 1408 , obtaining a set of depth-0, depth-1 and higher hashes that exist in the unmarked object but not in the marked object.
- the hash that exists in node 1408 but not in node 1406 is H 3 , so H 3 is marked as referenced. This procedure is continued until all edges are exhausted.
- a comparison of the results produced by a prior art algorithm 1418 and the present embodiment 1420 shows that when node 1408 is processed by the prior art algorithm, previously-seen hashes H 1 and H 2 are emitted into the output stream along with new hash H 3 .
- Present embodiment 1420 does not emit previously seen hashes into the output stream, resulting in only new hashes H 3 , H 4 , H 5 , H 6 , H 7 being emitted into the output stream, with a corresponding improvement in performance. Note that this method does not guarantee that data will not be marked more than once. For example, if hash value H 4 occurs independently in node 1416 , it will be independently marked a second time.
- Copying an object from another pool into the CAS uses the software modules described in FIG. 11 to produce a data structure referenced by an object handle as in FIG. 12 .
- the input to the process is (a) a sequence of chunks of data at specified offsets, sized appropriately for making depth-0 handles, and optionally (b) a previous version of the same object. Implicitly, the new object will be identical to the previous version except where the input data is provided and itself differs from the previous version.
- the algorithm for the copy-in operation is illustrated in a flowchart at FIG. 15 .
- the sequence (a) may be a sparse set of changes from (b).
- this can greatly reduce the amount of data that needs to be copied in, and therefore reduce the computation and i/o activity required. This is the case, for example, when the object is to be copied in via the optimal way for data backup described previously.
- sequence (a) includes sections that are largely unchanged from a predecessor, identifying the predecessor (b) allows the copy-in procedure to do quick checks as to whether the data has indeed changed and therefore to avoid data duplication at a finer level of granularity than might be possible for the difference engine in some other storage pool providing input to a CAS.
- the new object will be identical to the previous version except where the input data is provided and itself differs from the previous version.
- the algorithm for the copy-in operation is illustrated in a flowchart at FIG. 15 .
- the process starts at step 1500 as an arbitrarily-sized data object in the temporal store is provided, and proceeds to 1502 , which enumerates any and all hashes (depth-0 through the highest level) referenced by the hash value in the predecessor object, if such is provided. This will be used as a quick check to avoid storing data that is already contained in the predecessor.
- step 1504 if a predecessor is input, create a reference to a clone of it in the content-addressable data store temporal data structure. This clone will be updated to become the new object. Thus the new object will become a copy of the predecessor modified by the differences copied into the CAS from the copying source pool.
- the Data Mover 502 pushes the data into the CAS.
- the data is accompanied by an object reference and an offset, which is the target location for the data.
- the data may be sparse, as only the differences from the predecessor need to be moved into the new object.
- the incoming data is broken into depth-0 chunks sized small enough that each can be represented by a single depth-0 hash.
- the data hash module generates a hash for each depth-0 chunk.
- step 1512 read the predecessor hash at the same offset. If the hash of the data matches the hash of the predecessor at the same offset, then no data needs to be stored and the depth-1 and higher objects do not need to be updated for this depth-0 chunk. In this case, return to accept the next depth-0 chunk of data.
- This achieves temporal deduplication without having to do expensive global lookups.
- the source system is ideally sending only the differences from the data that has previously been stored in the CAS, this check may be necessary if the source system is performing differencing at a different level of granularity, or if the data is marked as changed but has been changed back to its previously-stored value. Differencing may be performed at a different level of granularity if, for example, the source system is a snapshot pool which creates deltas on a 32 KiB boundary and the CAS store creates hashes on 4 KiB chunks.
- the data may be hashed and stored. Data is written starting at the provided offset and ending once the new data has been exhausted. Once the data has been stored, at step 1516 , if the offset is still contained within the same depth-1 object, then depth-1, depth-2 and all higher objects 1518 are updated, generating new hashes at each level, and the depth-0, depth-1 and all higher objects are stored at step 1514 to a local cache.
- step 1520 if the amount of data to be stored exceeds the depth-1 chunk size and the offset is to be contained in a new depth-1 object, the current depth-1 must be flushed to the store, unless it is determined to be stored there already. First look it up in the global index 1116 . If it is found there, remove the depth-1 and all associated depth-0 objects from the local cache and proceed with the new chunk 1522 .
- step 1524 as a quick check to avoid visiting the global index, for each depth-0, depth-1 and higher object in the local cache, lookup its hash in the local store established in 1502 . Discard any that match.
- step 1526 for each depth-0, depth-1 and higher object in the local cache, lookup its hash in the global index 1116 . Discard any that match. This ensures that data is deduplicated globally.
- step 1528 store all remaining content from the local cache into the persistent store, then continue to process the new chunk.
- Reading an object out of the CAS is a simpler process and is common across many implementations of CAS.
- the handle for the object is mapped to a persistent data object via the global index, and the offset required is read from within this persistent data. In some cases it may be necessary to recurse through several depths in the object handle tree.
- the Replicator 1110 is a service to duplicate data objects between two different content addressable stores.
- the process of replication could be achieved through reading out of one store and writing back into another, but this architecture allows more efficient replication over a limited bandwidth connection such as a local- or wide-area network.
- a replicating system operating on each CAS store uses the difference engine service described above together with the temporal relationship structure as described in FIG. 13 , and additionally stores on a per-object basis in the temporal data structure used by the CAS store a record of what remote store the object has been replicated to. This provides definitive knowledge of object presence at a certain data store.
- the system uses the temporal data structure to determine which objects exist on which data stores. This information is leveraged by the Data Mover and Difference Engine to determine a minimal subset of data to be sent over the network during a copy operation to bring a target data store up to date. For example, if data object 0 has been copied at time T 3 from a server in Boston to a remote server in Seattle, Protection Catalog Store 908 will store that object 0 at time T 3 exists both in Boston and Seattle. At time T 5 , during a subsequent copy from Boston to Seattle, the temporal data structure will be consulted to determine the previous state of object 0 in Seattle that should be used for differencing on the source server in Boston. The Boston server will then take the difference of T 5 and T 3 , and send that difference to the Seattle server.
- the process to replicate an object A is then as follows: Identify an object A 0 that is recorded as having already been replicated to the target store and a near neighbor of A in the local store. If no such object A 0 exists then send A to the remote store and record it locally as having been sent.
- a typical method as embodied here is: send all the hashes and offsets of data chunks within the object; query the remote store as to which hashes represent data that is not present remotely; send the required data to the remote store (sending the data and hashes is implemented in this embodiment by encapsulating them in a TCP data stream).
- a 0 is identified, then run the difference engine to identify data chunks that are in A but not in A 0 . This should be a superset of the data that needs to be sent to the remote store. Send hashes and offsets for chunks that are in A but not in A 0 . Query the remote store as to which hashes represent data that is not present remotely; send the required data to the remote store.
- FIG. 16 shows the software and hardware components that comprise one embodiment of the Data Management Virtualization (DMV) system.
- the software that comprises the system executes as three distributed components:
- the Host Agent software 1602 a , 1602 b , 1602 c implements some of the application-specific module described above. It executes on the same servers 1610 a , 1610 b , 1610 c as the application whose data is under management.
- the DMV server software 1604 a , 1604 b implements the remainder of the system as described here. It runs on a set of Linux servers 1612 , 1614 that also provide highly available virtualized storage services.
- Management Client software 1606 that runs on a desktop or laptop computer 1620 .
- Data Management Virtualization systems communicate with one another between primary site 1622 and data replication (DR) site 1624 over an IP network such as a public internet backbone.
- DR data replication
- the DMV systems at primary and DR sites access one or more SAN storage systems 1616 , 1618 via a fibre-channel network 1626 .
- the servers running primary applications access the storage virtualized by the DMV systems access the storage via fibre-channel over the fibre-channel network, or iSCSI over the IP network.
- the DMV system at the remote DR site runs a parallel instance of DMV server software 1604 c on Linux server 1628 .
- Linux server 1628 may also be an Amazon Web Services EC2 instance or other similar cloud computational resource.
- FIG. 17 shows components of a system including a Virtual Copy Data Management Appliance, according to some embodiments of the present disclosure.
- VCDMA virtual copy data management appliances
- virtual backup appliance or “virtual appliance”
- virtual appliance can be deployed to implement data management functions.
- the virtual appliance provides a platform neutral implementation of the copy data virtualization capabilities by abstracting the hardware layer with a number of software components.
- VCDMA functions include application data protection, data restore, data deduplication and remote replication.
- VCDMA can be a software only solution that is lightweight and can be deployed inside a hypervisor.
- VCDMA can be deployed in a hypervisor 1704 a 1704 b .
- protected applications can run on physical hosts 1610 a 1610 b 1610 c or on virtual machines within a hypervisor 1704 a 1704 b.
- a snapshot can be generated by servers running protected applications either on physical hosts or virtual machines.
- the servers can contain a performance optimized pool with snapshot capability.
- the server can be a VMWare ESX server, or other type of virtual machine.
- a snapshot generated by the virtualization server can include snapshots of each of the virtual machines sitting on the server.
- the VCDMA 1702 a 1702 b can receive the snapshot generated by the server.
- FIGS. 18 a - c are diagrams illustrating 3 deployments of a copy data management system, based on platform optimized storage virtualization layers, according to some embodiments of the present disclosure.
- FIG. 18 a shows copy data virtualization software 1801 , storage virtualization layer 1802 a , and storage 1803 1804 1805 provided by a cloud infrastructure provider sitting in a hypervisor 1830 also provided by a cloud infrastructure provider.
- FIG. 18 b shows the same copy data virtualization software 1801 running inside a data center in a VMWare hypervisor environment 1840 .
- the storage virtualization layer 1802 b in this environment configures one or more storage parameters according to the storage provided by VMWare—Hypervisor 1813 1814 1815 .
- 18 c shows the same copy data virtualization software 1801 running in a more traditional hardware setting without a hypervisor.
- the software 1801 and storage virtualization layer 1802 c adapt to the fact that they are running on real hardware, with physical disks 1823 1824 1825 , to provide predictable performance.
- Copy virtualization software 1801 includes an ability to discover applications inside virtual machines and hosts and to protect the applications using Service Level Agreements (SLAs).
- SLAs define how long the application is retained and how often it is pushed into the deduplication pool and when it is to replicate out to a remote physical and virtual appliance.
- copy virtualization software 1801 functions similarly to the data management virtualization engine as described, for example, in FIGS. 3-5 above.
- the similarity lies in the type of capability provided to perform the above mentioned functions and the ability for an end-user to leverage this capability in a software only model. The details of the virtualization software functions are described in more detail above.
- FIGS. 18 a - c the storage virtualization layer 1802 a - c enables the deployment of the virtual copy data management appliance in a variety of environments.
- FIG. 18 a shows the implementation on cloud storage infrastructure.
- the storage virtualization layer 1802 a is optimized to work with the infrastructure provided by the cloud service provider.
- the virtualization layer 1802 a tunes itself to work with the unique characteristics of the cloud storage type 1803 1804 1805 .
- the storage virtualization layer 1802 c can also work with physical disks 1823 1824 1825 .
- the virtualization layer 1802 c detects that it is dealing with raw disks and optimizes itself to work with this configuration. The optimization and tuning relates to disk latency and throughput.
- Disk latency and throughput are two of the biggest variables in a storage system that affect the overall throughput of the system.
- the storage virtualization layer 1802 a - c has been designed to adapt to this variablity and extract maximum performance out of the storage.
- the physical appliance does not require a storage virtualization software as it is designed to work with the storage provided in the box.
- the hardware is optimized to perform with one type of storage.
- the storage virtualization layer can measure throughput and latency for read operate operations that pass through the layer.
- the storage virtualization layer can write large chunks of sequential blocks optimized for any environment. For example, if there are a lot of small random writes, the storage virtualization layer aggregates the random writes into a log file and then plays out the log file sequentially. This can help to reduce I/O latency and also increase the throughput of the entire platform.
- the storage virtualization layer's performance can be further accelerated by provisioning Solid State Devices (SSDs). SSDs can provide extremely high throughput and low latency access to underlying storage. Augmenting the storage virtualization layer with SSDs can further improve performance. In at least the ways described above, the virtualization layer can help the overall VCDMA run with a predictable performance.
- SSDs Solid State Devices
- storage virtualization layer 1802 a - b also has to account for variations in hypervisors (e.g., 1830 and 1840 ).
- Hypervisors 1830 1840 virtualize hardware CPU, Disk and memory and each hypervisor can do this in a unique way.
- Copy data virtualization software 1801 and the storage virtualization 1802 a - b together have been optimized to perform in these diverse hypervisors 1830 1840 .
- the hypervisors 1830 1840 provide abstract concepts for CPU and Memory and this hides the actual hardware that provides these resources.
- Copy Data Virtualization Software 1801 is highly sensitive to CPU and memory changes in the environment. This software has been tuned to adapt to the amount of CPU and memory available at any given point in time. This helps to keep the performance predictable at all times.
- Storage virtualization layer 1802 a - c can aggregate storage volumes from a hypervisor and presents them as disks to copy data virtualization software.
- a combined file system and logical volume manager can be used for storage virtualization (e.g., ZFS).
- ZFS is a combined file system and logical volume manager designed by Sun Microsystems. The features of ZFS include protection against data corruption, support for high storage capacities, efficient data compression, integration of the concepts of filesystem and volume management, snapshots and copy-on-write clones, continuous integrity checking and automatic repair, RAID-Z and native NFSv4 ACLs.
- Zpools (ZFS Pools) can be created over individual storage volumes presented to the virtual machine.
- ZFS snapshots can also be used for capturing data and presenting mounts back to a host. Unlike traditional file systems which reside on single devices and thus require a volume manager to use more than one device, ZFS filesystems are built on top of virtual storage pools called zpools.
- a zpool is constructed of virtual devices (vdevs), which are themselves constructed of block devices files, hard drive partitions, or entire drives, with the latter being the recommended usage.
- Block devices within a vdev may be configured in different ways, depending on needs and space available: non-redundantly (similar to RAID 0), as a mirror (RAID 1) of two or more devices, as a RAID-Z group of three or more devices, or as a RAID-Z2 (similar to RAID-6) group of four or more devices.
- a zpool (ZFS storage pool) is vaguely similar to a computer's RAM. The total RAM pool capacity depends on the number of RAM memory sticks and the size of each stick.
- a zpool includes one or more vdevs. Each vdev can be viewed as a group of hard disks (or partitions, or files, etc.). ZFS also provides knobs that can be altered based on the environment.
- the storage virtualization layer which embeds ZFS in it can use these knobs to tune the platform for optimal performance.
- the storage virtualization layer can provide capability to provision Solid State Devices for accelerating I/O to the disk. Solid State Devices provide low latency high speed access to data which augments the performance of the Copy Data Virtualization Software.
- the platform also enforces a lot of reliability irrespective of the reliability metrics of the underlying storage.
- ZFS guarantees transactions to disk and also ensures that data is written with the correct atomicity to ensure application consistency.
- ZFS provides the capability to add storage and grow as you go. This alleviates the need for dedicating large volume of storage upfront. This capability helps with efficient data management and also helps cloud service providers allocate resources in a predictable fashion.
- a cloud service provider can now provision storage based on storage rather than pre-allocating a large block which causes a lot of un-used and thus wasted storage.
- Storage can include a plurality of storage volumes 1803 1804 1805 1813 1814 1815 1823 1824 1825 .
- the storage volumes can be presented to the virtual machine. These individual volumes can be aggregated into a zpool. The aggregation can be done to effectively manage a pool of disks as a single logical storage entity. Zpool as described above, enables this capability in an efficient and reliable fashion.
- storage can include many of the same storage pools as in a hardware appliance.
- 1803 1804 1805 1813 1814 1815 1823 1824 1825 all are individual storage devices or virtual devices as described above.
- a virtual appliance with a hardware abstraction layer infrastructure can be deployed in a number of private and public cloud environments.
- the underlying hardware is abstracted by the hypervisor and the virtual appliance is built to run on this hypervisor.
- the hardware abstraction is also built into the platform of the virtual appliance and the platform that comprises of ZFS aggregated disks presented by the hypervisor in a single logical volume.
- the ZFS platform being embedded inside the appliance enables this capability thus making it infrastructure agnostic.
- this capability enables this virtual appliance to be created to hold very small (1 TB) to very large (50 TB) of data.
- This capability also enables deployment in a variety of environments from small remote offices to large data centers and everything in between.
- a virtual appliance also allows for asynchronous data replication for providing a remote copy of data.
- the remote replication can be provided with reduced bandwidth requirements by copying deduplicated differences in business data from a local storage site to a remote, backup storage site.
- FIG. 19 shows virtual storage resources in a Virtual Copy Data Management Appliance, according to some embodiments of the present disclosure.
- FIG. 19 shows a pool manager and pools showing a sample physical separation of virtual pools and storage resources, according to different pool types.
- the primary pool 507 consists of local storage on a host virtualization server 1910
- the performance optimized pool 508 consists of a set of virtual snapshots on the same physical storage, managed by the virtualization server
- the capacity optimized pool 509 consists of a deduplicating content addressable store on a physically separate device 1920 .
- a pool manager can reside in an external virtual machine.
- the pool manager can reside in a data virtual backup appliance.
- the information stored in a pool manager can include data that is deduplicated across all machines.
- the pool allows for data from one machine to be deduplicated against data from a different virtual machine, which can result in a further reduction in data storage.
- a description of how a pool manager and pools interact with other modules in a data management virtualization system is described above, for example, in FIG. 5 .
- virtual storage resources 510 can include virtual storage pools 418 .
- the pool can include primary pool 507 , performance optimized pool 508 and capacity optimized pool 509 .
- storage pools can be hosted on a virtualization server 1910 .
- the storage pools for the VCDMA are provisioned from customer's existing infrastructure. There is no need to purchase any specific type of storage for this appliance.
- a hardware appliance has a smaller compatibility matrix for the storage that can be used while VCDMA works with any and all storage supported by the hypervisor.
- a storage snapshot operation (e.g., as described above) that is a native operation on the virtualization server.
- the representation of differences between this snapshot and a previous snapshot can be an extent list (e.g., as described above), and so the set of operations described above for efficient backup and restore can be applied equally to this embodiment.
- FIG. 20 shows a virtual backup appliance system, according to some embodiments of the present disclosure.
- a virtual backup appliance system can be useful for remote office locations for an enterprise or for service providers whose end-user customers have less than 15 terabytes of total data to be protected. Deploying a physical machine for these scenarios can become untenable from a cost and operations perspective.
- a virtual appliance running on the end-user's existing hardware requires no extra provisioning or other types of requirements (e.g., plug and play installation) and can provide similar capabilities as a physical appliance.
- Virtual backup appliance system 2000 comprises virtual machines 2001 , hosts 2002 , a hypervisor 1704 and at least one backup appliance 1702 2030 .
- a virtual backup appliance 1702 can sit inside a hypervisor 1704 (e.g., vCenter), running on a host 2002 (e.g., an ESX host), protecting virtual machines 2001 and replicating that data to another virtual appliance or to a physical cluster 2030 .
- a hypervisor 1704 e.g., vCenter
- a host 2002 e.g., an ESX host
- hosts 2002 there can be two hosts 2002 (e.g., ESX Hosts) that are running virtual machines 2001 .
- the virtual machines can include a virtual backup appliance 1702 .
- the hosts can be physical servers.
- the virtual machines 2001 can comprise of virtual instances of Windows, Linux or other servers that run Exchange, SQL or other end-user applications.
- Backup appliance 1702 which can also be a virtual machine, can protect 2040 applications and data on end-user virtual machines 2001 or applications and data on physical hosts 2060 .
- End-user virtual machines 2001 being protected can either be on the same host (e.g., ESX host) or on a different host.
- a virtual backup appliance 1702 can replicate 2050 a de-duplicated form of end-user data to a another virtual or physical backup appliance 2030 (e.g., a physical content data storage cluster), such as the data management virtualization system described above.
- the replication 2050 can be done to create an off-site copy that can then be used in disaster recovery scenarios.
- the virtual appliance can back up to a data center with storage of 30 to 50 terabytes.
- FIG. 21 shows a flowchart illustrating backup using a virtual backup appliance, according to some embodiments of the present disclosure.
- virtual backup appliance running inside a hypervisor can discover virtual machines and physical hosts on the network.
- Physical Hosts and Virtual Machines inside a vCenter are protected to one or more backup appliances based on SLAs.
- deduplicated data residing on virtual backup appliances are then replicated to the central Physical CDS or to a larger virtual backup appliance.
- discovering virtual machines and physical hosts on the network includes specifying IP address and user credentials for the physical host and Virtual Administrator console credential for the virtual machines.
- configuring SLAs on the virtual appliance includes receiving backup parameters from a service provider.
- Backup parameters can include the schedule—the window when it is allowed to run, how often to keep a backup and how to move it between the various pools.
- SLA describes the data protection characteristics for each stage of the data lifecycle. Each application may have a different SLA.
- protecting a physical host based on an SLA includes backing up data based on backup parameters associated with an SLA.
- an SLA can specify backing up the data twice a day and moving it to deduplication pool once a day and then replicating it to the remote pool once a day.
- deduplicating data on the virtual backup appliance includes identifying and storing only the unique data blocks for the data that is being de-duplicated.
- Replicating data includes identifying the changes in the deduplicated image between the local deduplication pool and remote deduplication pool and only replicating these changes. Replication is thus very efficient on the network.
- FIG. 22 shows a cascading deduplication system with virtual backup appliances, according to some embodiments of the present disclosure.
- a cascading deduplication can be used to protect data on end user appliances.
- Data Protection creates a backup copy of an end-user's production data. This backup copy is used when the production data is corrupted or destroyed in the event of a disaster or system malfunction.
- a hierarchy of virtual appliances can achieve a cascading deduplication.
- the hierarchy can comprise of end user appliances 2203 , individual virtual appliances 2202 a 2202 b 2202 c , an aggregated deduplication device 2201 , and a central appliance 2200 .
- multiple aggregated deduplication devices can provide data to a central appliance (e.g., 2204 ).
- FIG. 23 shows a flowchart illustrating cascading deduplication with virtual backup appliances, according to some embodiments of the present disclosure.
- virtual backup appliances at the leaf layer aggregate data from the hosts and applications they are protecting and deduplicate the aggregated data.
- aggregator appliances at the next level receive data from the appliances at the leaf layer and further de-duplicate that data.
- central data center receives data from aggregator appliances and performs deduplication on that data set.
- a cascading deduplication can start with virtual appliances 2202 receiving end-user data from the end user appliances.
- End user data can include end-user applications (e.g., virtual machines, Oracle, Windows machines, Linux machines, Exchange, etc.).
- the end-user data received by the virtual appliances comprises only data that was changed since the last replication. For example, when protecting an end-user's virtual environment the virtual appliance only receives the changes from a recent snapshot. This minimizes the amount of data transferred over the network.
- the virtual appliance de-duplicates the incoming data that further reduces the data footprint.
- the virtual appliance then replicates the de-duplicated data to an aggregator appliance further up in the hierarchy. Replication only moves changed data and moves it in the de-duplicated form.
- the next step can include the virtual appliances ( 2202 a , 2202 b , 2202 c ) de-duplicating end-user application data.
- the virtual backup appliance (collection of 2202 a , 2202 b and 2202 c are shown as 2202 ) can reside in any hypervisor (e.g. VMWare, Xen, HyperV, etc.).
- deduplication comprises of a process that reduces the data footprint by only storing the unique blocks. The deduplication process reduces data storage requirements and also increases overall system throughput as systems are now managing smaller chunks of data.
- the next step can include replicating the de-duplicated data from virtual appliances 2202 to an aggregating virtual appliance 2201 .
- the aggregator appliance 2201 can be a larger virtual appliance that receives de-duplicated data from various virtual appliances 2202 and further de-duplicates the data.
- the next step can include replicating the de-duplicated data from an aggregating virtual appliance 2201 to a central appliance 2200 .
- the central appliance can de-duplicate data across data received from all aggregator appliances (e.g., 2201 and 2204 ).
- a second hierarchy of de-duplicating appliances is shown in 2204 .
- a hierarchy of de-duplicating appliances can provide a single instance of data across a wide range of end-user data.
- Data received by a layer from the layer below can be de-duplicated and then replicated to the layer above.
- the layer above can repeat this process further reducing the data footprint.
- This cascading mechanism can progressively reduce the data footprint thus resulting in optimal data storage.
- a cascading hierarchy can go on for many levels as dictated by a customer's deployment.
- the company could deploy virtual appliances at each station and then aggregate a few virtual appliances to a regional aggregator appliance.
- the aggregator appliance will de-duplicate data from all virtual appliances. For instance if each appliance is protecting a Windows operating system, the aggregator appliance will de-duplicate that data and end up with a single instance of the Windows operating system.
- the company can deploy aggregator appliances based on geography and bandwidth requirement at the source and at the aggregator side. For instance all appliances in a metropolitan area network (MAN) can be aggregated to an aggregator appliance.
- MAN metropolitan area network
- the network should have adequate bandwidth to allow the replication of daily changes from the individual virtual appliances.
- These aggregators can further replicate this data to the regional aggregating appliance that in turn can then replicate to a central data center. This mechanism enables the company to optimize storage at each step of the hierarchy and truly single instance the data at the central data center.
- FIG. 24 shows an archiving system, according to some embodiments.
- the archiving system uses a virtual backup appliance 2404 to archive data in private and public cloud deployments 2406 .
- Public cloud infrastructure is fast becoming very affordable and enables offsite storage for organizations very manageable.
- a company that requires long term data retention for archiving purposes can use the public cloud infrastructure to store large amounts of data for long periods time for very low cost.
- the virtual backup appliance 2404 running in a end-user's hypervisor environment 2410 can protect 2402 end-user applications and end-user hosts 2401 .
- the appliance can store end-user application data in a de-duplicated form 2403 .
- the virtual appliance can also be configured to replicate the de-duplicated data 2403 to another appliance 2407 in a public or private cloud infrastructure 2406 .
- This replication 2408 process only moves the changed data in a de-duplicated form and creates another copy of the de-duplicated end-user data 2403 in the cloud.
- the replicated content can be used for longer term data archiving 2405 .
- the virtual backup appliance 2404 can reside in any hypervisor 2408 (e.g. VMWare, Xen, HyperV, etc.) and can protect 2402 end-user applications or the entire end-user host machine 301 like virtual machines (e.g., Oracle, Windows machines, Linux machines, Exchange, etc.).
- the virtual back appliance 2404 can then de-duplicate the application data 2403 before writing the data to disk.
- the virtual backup appliance only stores the unique blocks of end-user data.
- the virtual backup appliance can replicate 2408 the de-duplicated data to another virtual backup application in the cloud 2407 .
- the end-user applications 2401 e.g., Linux, Windows machine, Hypervisor instances, etc.
- the end-user customer can define policies to protect these applications.
- data protection 2402 of applications and hosts involves moving the bits that have changed since the last protection from the application into the virtual backup appliance 2404 .
- the appliance can then de-duplicate this data and writes it to local storage.
- the deduplication process 2403 optimizes capacity by storing only the unique blocks thus reducing the storage requirement inside the virtual appliance.
- replication 2408 involves moving the de-duplicated data 2403 from the primary virtual backup appliance 2404 to another cloud based backup appliance 2407 sitting in a public or private cloud infrastructure 2406 .
- Replication 2408 only moves the changes on the local side into the cloud.
- replicated content 2405 is another copy of de-duplicated data that was replicated 2408 from the de-duplicated store 2403 of the primary virtual backup appliance 2404 on the primary side.
- the replicated content 2405 also includes de-duplicated application and host data.
- public or private cloud infrastructure 2406 is a pool of disk, compute and memory that can be provisioned on demand to host applications and other processing engines.
- AWS from Amazon is one of the largest public cloud infrastructures.
- the system can also replicate data from one geographic location of the public cloud to another. For e.g. when deployed in Amazon Web Services the system can replicate data from a Northern Virginia, U.S. data center to a data center in Singapore.
- a backup cloud appliance 2407 is similar to the virtual backup appliance 2404 but acts as a replication target accepting de-duplicated data for archival purposes.
- FIG. 25 shows a disaster recovery and business continuity system in private and public cloud deployments, according to some embodiments of the present disclosure.
- Public cloud infrastructure is fast becoming very affordable and enables offsite storage for organizations very manageable.
- a company that requires offsite storage for disaster recovery and business continuance can leverage the cloud infrastructure.
- the cloud infrastructure comes at a much lower capital cost.
- a company can deploy a virtual appliance at their primary data center that replicates to another virtual appliance in the cloud. In the event of a disaster on the primary site, the backup appliance in the cloud holding the replicated data can bring back the protected applications and hosts to life in the cloud. This can help the company continue its business in the event of a disaster.
- asynchronous data replication whereby data ingested on the local system is made accessible on the remote system, can provide data available on the remote system in the event of a disaster on the local system. Doing this on a public cloud infrastructure makes this easily consumable by end-users. Resources can be provisioned and consumed on demand in the cloud thus enabling end-users to enable disaster recovery and implement business continuance on the push of a button.
- a virtual backup appliance 2504 can enable data disaster recovery and business continuity in a public or private cloud infrastructure 2506 .
- the backup appliance 2504 protects 2502 applications and hosts 2501 and stores the data in de-duplicated form.
- the virtual appliance then replicates 2503 the de-duplicated content for disaster recovery and business continuance to another virtual backup appliance in the cloud 2505 .
- the cloud based backup appliance 2505 can either run on a public or private cloud infrastructure 2506 .
- applications and hosts 2508 protected by that appliance 2504 can be recovered in the cloud infrastructure 2507 .
- the virtual backup appliance 2504 can reside in any hypervisor (e.g. VMWare, Xen, HyperV, etc.) and can protect 2502 end-user applications 2501 like virtual machines (e.g., Oracle, Windows machines, Linux machines, Exchange etc.). The virtual backup appliance 2504 then de-duplicates the application data before writing them to disk. The virtual backup appliance can replicate 2503 the de-duplicated data to another virtual backup application in the cloud 2505 .
- hypervisor e.g. VMWare, Xen, HyperV, etc.
- the virtual backup appliance 2504 then de-duplicates the application data before writing them to disk.
- the virtual backup appliance can replicate 2503 the de-duplicated data to another virtual backup application in the cloud 2505 .
- the end-user applications 2501 (e.g., Linux, Windows machine, Hypervisor instances, etc.) are protected by one or more virtual backup appliances 2504 .
- the end-user customer can define policies to protect these applications.
- data protection 2502 of applications and hosts involves moving the bits that have changed since the last protection from the application into the virtual backup appliance 2504 .
- the appliance then de-duplicates this data and writes it to local storage.
- the deduplication process optimizes capacity by storing only the unique blocks thus reducing the storage requirement inside the virtual appliance.
- replication 2503 involves moving the de-duplicated data from the primary virtual backup appliance 2504 to another cloud based backup appliance 2505 sitting in a public or private cloud infrastructure 2506 . In some embodiments, replication 2503 only moves the changes on the local side into the cloud.
- public or private cloud infrastructure 2506 is a pool of disk, CPU and memory that can be provisioned on demand to host applications and other processing engines.
- a backup cloud appliance 2505 is similar to the virtual backup appliance 2504 but acts as a replication target accepting de-duplicated data for archival purposes.
- the recovery of applications and hosts 2507 is the process of recovering applications and hosts 2501 protected by virtual backup appliance 2504 in the public cloud infrastructure 2506 .
- applications and hosts 2508 running the cloud are exact replicas of applications and hosts 2501 that were protected by the virtual appliance 2504 .
- a software company has an accounting database that sits on a physical host in the company's data center.
- a virtual appliance protects the database.
- the virtual appliance will then replicate the data to another virtual appliance in a cloud infrastructure.
- the database in the company's data center is corrupted or destroyed, another copy of the database can be created from the replicated copy on virtual appliance in the cloud.
- the company can continue to operate its business from the cloud based database instance until its data center issue is repaired at which the database can be recovered onto its data center (from the cloud).
- data management systems can create backups of application data without backing up all of the application data for each backup.
- the system can take advantage of the data similarity between the two sets of application data.
- the system can take a snapshot of the application data which includes information about the differences between application data at an earlier point in time and a second, current point in time for the snapshot. Therefore, rather than backing up all of the application data for each backup time, the system can back up only the changed data and refer back to the original content for the remaining data.
- a system for backing up data from a first storage pool to a second storage pool using difference information between time states is described in more detail above.
- a virtual backup appliance creates a snapshot of the application data before backing it up and performing subsequent processing.
- the virtual backup appliance can back up data using snapshots that are generated by a system external to the appliance rather than creating snapshots locally in the appliance.
- the appliance can, for instance, rely on external systems to generate snapshots of their data rather than using the appliance to generate the snapshots.
- the appliance can support using such external snapshots in combination with snapshots generated by the appliance (e.g., certain applications can create their own snapshots, while other applications can use the appliance to create the snapshots).
- FIG. 26 shows a flowchart illustrating archive and business continuity in the cloud, according to some embodiments of the present disclosure.
- Virtual Backup Appliance or Physical CDS Cluster protect applications and hosts as configured by an end-use.
- the protected data is deduplicated and then replicated to a Virtual Data Appliance in a public or private cloud.
- Virtual Backup Appliance in the cloud receives virtual images of the applications and hosts replicated to it.
- step 2604 if the primary appliance is destroyed due to a disaster the end-user can quickly bring up the applications in the cloud via the Virtual Backup Appliance running in the cloud. This provides disaster recovery and business continuance for enterprise grade applications.
- configuring the protection of applications includes applying Service Level Agreements (SLAs) to these applications.
- SLAs Service Level Agreements
- replicating to a virtual data appliance in the cloud includes ingesting the application in the virtual appliance's snapshot pool followed by moving the data from the appliance's snapshot pool to the appliance's de-duplcation pool. Data is then replicated from the appliance's deduplication pool to the virtual appliance in the cloud's deduplication pool.
- receiving the replicated data at the cloud includes the virtual appliance in the cloud receiving de-duplicated data from a virtual appliance in the customer's data center.
- bringing up applications in the cloud includes restoring the application data from the virtual appliance in the cloud's deduplication pool.
- FIG. 27 shows a flowchart illustrating backup as a service, according to some embodiments of the present disclosure. It also shows the work flow for delivering the above mentioned capabilities as a service and running a business on top of the service.
- a website can act as a front-end to the service and provide an end-user access to this service.
- These services can be entirely end-user self-serviceable or can be driven via a managed service provider who delivers this service to an end-user.
- the first step is the end-user signing up for the service 2700 and then a portal giving the end-user access to resources for the service 2701 .
- the end-user installs some software 2702 on premise and then connects to the cloud where the resources are auto provisioned by the portal.
- the auto provisioning process uses Representational State Transfer (REST) Application Program Interfaces (APIs) to communicate with the Virtual Copy Data Management Appliance.
- the REST API is used to tell the appliance to begin the configuration process and to also monitor it.
- Tier-0 for the highest priority applications and then go with Tier-1, Tier-2 and Tier-3 for the applications in that priority.
- Tier-4 applications only do vaulting and Tier-5 applications don't replicate this to the cloud.
- a recovery plan can include the order in which systems will come up and the applications they will mount.
- system parameters include Operating System, Memory and CPU to be provisioned for the system that is going to present the application data to the end user in the event of a disaster.
- the recovery plan can be executed either for a disaster recovery audit or for a real disaster recovery 2704 . In both cases the applications as shown in 2705 will be available when the systems specified in the recovery plan are running.
- the end user can then login to these servers and access the application data.
- the portal meters the amount of the time a recovery plan is running and the end-user is billed accordingly.
- a virtual backup appliance can be deployed in a cloud infrastructure thus enabling service providers to provide value added services using this system.
- the deployment of the system in a cloud infrastructure can be fully automated and all of it capabilities can be driven via REST APIs.
- the REST APIs are commands that are passed to the virtual appliance using HTTP protocol.
- the virtual appliance to configure itself in the cloud then executes these commands.
- a template includes an operating system image and associated set of commands that are then executed on the operating system to bring up a custom application.
- a service provider will chose the base operating system of the appliance and then will use the REST API to pass additional commands to the appliance once the operating system has been installed. In some embodiments, this constitutes a template.
- a service provider can enable the capabilities of this system on demand using REST APIs and then use the charge back capabilities built into the system to generate billing reports for their end-users.
- a service provider can use REST APIs to get the amount of storage consumed in the appliance and use that data to bill their end users.
- the appliance provides space consumed by each application enabling fine-grained billing.
- Service Providers can also incrementally add new services as they get familiarized with the user of the system. Most service providers start with Back up as a service wherein they allow end users to back up the end-user's data into the appliance. Once that process has been established they can offer data recovery services, disaster recovery services as well dev-test services.
- the subject matter described herein can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structural means disclosed in this specification and structural equivalents thereof, or in combinations of them.
- the subject matter described herein can be implemented as one or more computer program products, such as one or more computer programs tangibly embodied in an information carrier (e.g., in a machine readable storage device), or embodied in a propagated signal, for execution by, or to control the operation of, data processing apparatus (e.g., a programmable processor, a computer, or multiple computers).
- a computer program (also known as a program, software, software application, or code) can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment.
- a computer program does not necessarily correspond to a file.
- a program can be stored in a portion of a file that holds other programs or data, in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code).
- a computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.
- processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processor of any kind of digital computer.
- a processor will receive instructions and data from a read only memory or a random access memory or both.
- the essential elements of a computer are a processor for executing instructions and one or more memory devices for storing instructions and data.
- a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks.
- Information carriers suitable for embodying computer program instructions and data include all forms of nonvolatile memory, including by way of example semiconductor memory devices, (e.g., EPROM, EEPROM, and flash memory devices); magnetic disks, (e.g., internal hard disks or removable disks); magneto optical disks; and optical disks (e.g., CD and DVD disks).
- semiconductor memory devices e.g., EPROM, EEPROM, and flash memory devices
- magnetic disks e.g., internal hard disks or removable disks
- magneto optical disks e.g., CD and DVD disks
- optical disks e.g., CD and DVD disks.
- the processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
- the subject matter described herein can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, (e.g., a mouse or a trackball), by which the user can provide input to the computer.
- a display device e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor
- a keyboard and a pointing device e.g., a mouse or a trackball
- Other kinds of devices can be used to provide for interaction with a user as well.
- feedback provided to the user can be any form of sensory feedback, (e.g., visual feedback, auditory feedback, or tactile feedback), and input from the user can be received in any form, including acoustic, speech, or tactile input.
- the subject matter described herein can be implemented in a computing system that includes a back end component (e.g., a data server), a middleware component (e.g., an application server), or a front end component (e.g., a client computer having a graphical user interface or a web browser through which a user can interact with an implementation of the subject matter described herein), or any combination of such back end, middleware, and front end components.
- the components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), e.g., the Internet.
- LAN local area network
- WAN wide area network
Abstract
Description
- This application claims the benefit of priority under 35 U.S.C. 119(e) to U.S. Provisional Application No. 61/939,511, filed Feb. 13, 2014, entitled “Virtual Data Backup”, the disclosure of which is hereby incorporated by reference in its entirety.
- This application is related to U.S. patent application Ser. No. ______, entitled “Virtual Data Backup” filed on Feb. 13, 2015, identified as Attorney Docket No. 2203828.00160US1;
- This application is related to U.S. patent application Ser. No. ______, entitled “Virtual Data Backup”, filed on Feb. 13, 2015, identified as Attorney Docket No. 2203828.00161US1; and
- This application is related to International Application No. ______, entitled “Virtual Data Backup”, filed on Feb. 13, 2015, identified as Attorney Docket No., 2203828.00159Wo1, the disclosures of each of which are hereby incorporated by reference in their entirety.
- The present disclosure relates to data management, specifically to virtual data backup.
- The business requirements for managing the lifecycle of application data have been traditionally met by deploying multiple point solutions, each of which addresses a part of the lifecycle. This has resulted in a complex and expensive infrastructure where multiple copies of data are created and moved multiple times to individual storage repositories. The adoption of server virtualization has become a catalyst for simple, agile and low-cost compute infrastructure. This has led to larger deployments of virtual hosts and storage, further exacerbating the gap between the emerging compute models and the current data management implementations.
- Applications that provide business services depend on storage of their data at various stages of its lifecycle.
FIG. 1 shows a typical set of data management operations that would be applied to the data of an application such as a database underlying a business service such as payroll management. In order to provide a business service, application 102 requiresprimary data storage 122 with some contracted level of reliability and availability. -
Backups 104 are made to guard against corruption or the primary data storage through hardware or software failure or human error. Typically backups may be made daily or weekly to local disk ortape 124, and moved less frequently (weekly or monthly) to a remote physicallysecure location 125. - Concurrent development and
test 106 of new applications based on the same database requires a development team to have access to another copy of thedata 126. Such a snapshot might be made weekly, depending on development schedules. - Compliance with legal or
voluntary policies 108 may require that some data be retained for safely future access for some number of years; usually data is copied regularly (say, monthly) to a long-term archiving system 128. -
Disaster Recovery services 110 guard against catastrophic loss of data if systems providing primary business services fail due to some physical disaster. Primary data is copied 130 to a physically distinct location as frequently as is feasible given other constraints (such as cost). In the event of a disaster the primary site can be reconstructed and data moved back from the safe copy. -
Business Continuity services 112 provide a facility for ensuring continued business services should the primary site become compromised. Usually this requires ahot copy 132 of the primary data that is in near-lockstep with the primary data, as well as duplicate systems and applications and mechanisms for switching incoming requests to the Business Continuity servers. - Thus, data management is currently a collection of point applications managing the different parts of the lifecycle. This has been an artifact of evolution of data management solutions over the last two decades.
- The disclosed subject matter includes a computerized method of creating, in a network, a single instance of deduplicated data across a plurality of end user data, each end user data being associated with a computing device. The method includes receiving, by a first computing device, data associated with a plurality of computing devices, the plurality of computing devices being managed by the first computing device. The method includes aggregating, by the first computing device, the data associated with each of the plurality of computing devices managed by the first computing device to form an aggregated data set for the plurality of computing devices. The method includes deduplicating, by the first computing device, the aggregated data set to form a deduplicated aggregated data set for the plurality of computing devices managed by the first computing device. The method includes transmitting, by the first computing device, the deduplicated aggregated data set to a second computing device for further aggregation and deduplication with one or more additional aggregated data sets generated by other computing devices managing respective sets of computing devices, thereby creating a single instance of deduplicated data across a plurality of end user data managed by the first computing device.
- The disclosed subject matter includes a computing system for creating, in a network, a single instance of deduplicated data across a plurality of end user data, each end user data being associated with a computing device. The computing system includes a processor and a memory coupled to the processor and including computer-readable instructions that, when executed by the processor, cause the processor to receive data associated with a plurality of computing devices, the plurality of computing devices being managed by the computing system. The computer-readable instructions cause the processor to aggregate the data associated with each of the plurality of computing devices managed by the computing system to form an aggregated data set for the plurality of computing devices. The computer-readable instructions cause the processor to deduplicate the aggregated data set to form a deduplicated aggregated data set for the plurality of computing devices managed by the computing system. The computer-readable instructions cause the processor to transmit the deduplicated aggregated data set to a second computing device for further aggregation and deduplication with one or more additional aggregated data sets generated by other computing devices managing respective sets of computing devices, thereby creating a single instance of deduplicated data across a plurality of end user data managed by the computing system.
- The disclosed subject matter includes a non-transitory computer readable medium having executable instructions operable to cause an apparatus to receive data associated with a plurality of computing devices, the plurality of computing devices being managed by a first computing device. The instructions are operable to cause the apparatus to aggregate the data associated with each of the plurality of computing devices managed by the first computing device to form an aggregated data set for the plurality of computing devices. The instructions are operable to cause the apparatus to deduplicate the aggregated data set to form a deduplicated aggregated data set for the plurality of computing devices managed by the first computing device. The instructions are operable to cause the apparatus to transmit the deduplicated aggregated data set to a second computing device for further aggregation and deduplication with one or more additional aggregated data sets generated by other computing devices managing respective sets of computing devices, thereby creating a single instance of deduplicated data across a plurality of end user data managed by the first computing device.
- The disclosed subject matter includes a computerized method of remotely backing up data associated with a plurality of storage environments. The method includes receiving, by a first computing device, a storage type associated with at least one second computing device managed by the first computing device, wherein the at least one second computing device is remotely in communication with the first computing device over a network. The method includes configuring, by the first computing device, storage parameters based on the storage type to customize a backup process for the second computing device based on the storage type. The method includes protecting, by the first computing device, data associated with the at least one second computing device using the storage parameters, wherein protecting data associated with the at least one second computing device further including copying, by the first computing device, at a first point in time a full copy of data associated with the at least one second computing device, and copying, by the first computing device, changes to the data associated with the at least one second computing device at a set of points in time later than the first point in time, the set of points in time being based on an end-user policy, thereby enabling custom protection of the remote at least one second computing device by the first computing device based on the storage type associated with the at least one second computing device.
- The disclosed subject matter includes a computing system for remotely backing up data associated with a plurality of storage environments. The computing system includes a processor and a memory coupled to the processor and including computer-readable instructions that, when executed by the processor, cause the processor to receive a storage type associated with at least one second computing device managed by the computing system, wherein the at least one second computing device is remotely in communication with the computing system over a network. The computer-readable instructions cause the processor to configure storage parameters based on the storage type to customize a backup process for the second computing device based on the storage type. The computer-readable instructions cause the processor to protect data associated with the at least one second computing device using the storage parameters, wherein protecting data associated with the at least one second computing device further includes copying at a first point in time a full copy of data associated with the at least one second computing device, and copying changes to the data associated with the at least one second computing device at a set of points in time later than the first point in time, the set of points in time being based on an end-user policy, thereby enabling custom protection of the remote at least one second computing device by the computing system based on the storage type associated with the at least one second computing device.
- The disclosed subject matter includes a non-transitory computer readable medium having executable instructions operable to cause an apparatus to receive a storage type associated with at least one second computing device managed by first computing device, wherein the at least one second computing device is remotely in communication with the first computing device over a network. The executable instructions are operable to cause an apparatus to configure storage parameters based on the storage type to customize a backup process for the second computing device based on the storage type. The executable instructions are operable to cause an apparatus to protect data associated with the at least one second computing device using the storage parameters, wherein protecting data associated with the at least one second computing device further includes copying at a first point in time a full copy of data associated with the at least one second computing device, and copying changes to the data associated with the at least one second computing device at a set of points in time later than the first point in time, the set of points in time being based on an end-user policy, thereby enabling custom protection of the remote at least one second computing device by the first computing device based on the storage type associated with the at least one second computing device.
- The disclosed subject matter includes a computerized method for providing content data storage services to a remote device over the internet to enable access of the remote device in the cloud. The method includes receiving, at a content data storage device, data indicative of a subscription to one or more content data storage services from a remote device in communication with the content data storage device over a network. The method includes provisioning, by the content data storage device, cloud storage for use by the content data storage device to provide the one or more content data storage services subscribed to by the remote device. The method includes replicating, by the content data storage device, data associated with the remote device to the provisioned cloud storage to provide a replicated device in the cloud. The method includes receiving, by the content data storage device, data indicative of a request to use the replicated device in the cloud. The method includes executing, by the content data storage device, the replicated device in the cloud, thereby providing access of the remote device in the cloud for the remote device.
- The disclosed subject matter includes a computing system for providing content data storage services to a remote device over the internet to enable access of the remote device in the cloud. The computing system includes a processor and a memory coupled to the processor and including computer-readable instructions that, when executed by the processor, cause the processor to receive data indicative of a subscription to one or more content data storage services from a remote device in communication with the content data storage device over a network. The computer-readable instructions cause the processor to provision cloud storage for use by the content data storage device to provide the one or more content data storage services subscribed to by the remote device. The computer-readable instructions cause the processor to replicate data associated with the remote device to the provisioned cloud storage to provide a replicated device in the cloud. The computer-readable instructions cause the processor to receive data indicative of a request to use the replicated device in the cloud. The computer-readable instructions cause the processor to execute the replicated device in the cloud, thereby providing access of the remote device in the cloud for the remote device.
- The disclosed subject matter includes a non-transitory computer readable medium having executable instructions operable to cause an apparatus to receive data indicative of a subscription to one or more content data storage services from a remote device in communication with the content data storage device over a network. The instructions are operable to cause an apparatus to provision cloud storage for use by the content data storage device to provide the one or more content data storage services subscribed to by the remote device. The instructions are operable to cause an apparatus to replicate data associated with the remote device to the provisioned cloud storage to provide a replicated device in the cloud. The instructions are operable to cause an apparatus to receive data indicative of a request to use the replicated device in the cloud. The instructions are operable to cause an apparatus to execute the replicated device in the cloud, thereby providing access of the remote device in the cloud for the remote device.
- These and other capabilities of the disclosed subject matter will be more fully understood after a review of the following figures, detailed description, and claims. It is to be understood that the phraseology and terminology employed herein are for the purpose of description and should not be regarded as limiting.
- Various objectives, features, and advantages of the disclosed subject matter can be more fully appreciated with reference to the following detailed description of the disclosed subject matter when considered in connection with the following drawings, in which like reference numerals identify like elements.
-
FIG. 1 is a simplified diagram of current methods deployed to manage the data lifecycle for a business service. -
FIG. 2 is an overview of the management of data throughout its lifecycle by a single Data Management Virtualization System. -
FIG. 3 is a simplified block diagram of the Data Management Virtualization system. -
FIG. 4 is a view of the Data Management Virtualization Engine. -
FIG. 5 illustrates the Object Management and Data Movement Engine. -
FIG. 6 shows the Storage Pool Manager. -
FIG. 7 shows the decomposition of the Service Level Agreement. -
FIG. 8 illustrates the Application Specific Module. -
FIG. 9 shows the Service Policy Manager. -
FIG. 10 is a flowchart of the Service Policy Scheduler. -
FIG. 11 is a block diagram of the Content Addressable Storage (CAS) provider. -
FIG. 12 shows the definition of an object handle within the CAS system. -
FIG. 13 shows the data model and operations for the temporal relationship graph stored for objects within the CAS. -
FIG. 14 is a diagram representing the operation of a garbage collection algorithm in the CAS. -
FIG. 15 is a flowchart for the operation of copying an object into the CAS. -
FIG. 16 is a system diagram of a typical deployment of the Data Management Virtualization system. -
FIG. 17 shows components of a system including a Virtual Copy Data Management Appliance, according to some embodiments of the present disclosure. -
FIGS. 18 a-c are diagrams illustrating 3 deployments of a copy data management system, based on platform optimized storage virtualization layers, according to some embodiments of the present disclosure. -
FIG. 19 shows a diagram of virtual storage resources in a Virtual Copy Data Management Appliance, according to some embodiments of the present disclosure. -
FIG. 20 shows a virtual backup appliance system, according to some embodiments of the present disclosure. -
FIG. 21 shows a flowchart illustrating backup using a virtual backup appliance, according to some embodiments of the present disclosure. -
FIG. 22 shows a cascading deduplication system with virtual backup appliances, according to some embodiments of the present disclosure. -
FIG. 23 shows a flowchart illustrating cascading deduplication with virtual backup appliances, according to some embodiments of the present disclosure. -
FIG. 24 shows an archiving system, according to some embodiments of the present disclosure. -
FIG. 25 shows a disaster recovery and business continuity system in private and public cloud deployments, according to some embodiments of the present disclosure. -
FIG. 26 shows a flowchart illustrating archive and business continuity in the cloud, according to some embodiments of the present disclosure. -
FIG. 27 shows a flowchart illustrating backup as a service, according to some embodiments of the present disclosure. - The present disclosure relates to U.S. patent application Ser. No. 13/920,981, filed on Jun. 18, 2013, entitled “System and method for incrementally backing up out-of-band data,” which is hereby incorporated by reference herein in its entirety.
- In the following description, numerous specific details are set forth regarding the systems and methods of the disclosed subject matter and the environment in which such systems and methods may operate, etc., in order to provide a thorough understanding of the disclosed subject matter. It will be apparent to one skilled in the art, however, that the disclosed subject matter may be practiced without such specific details, and that certain features, which are well known in the art, are not described in detail in order to avoid unnecessary complication of the disclosed subject matter. In addition, it will be understood that the embodiments provided below are exemplary, and that it is contemplated that there are other systems and methods that are within the scope of the disclosed subject matter.
- Current Data Management architecture and implementations such as described above involve multiple applications addressing different parts of data lifecycle management, all of them performing certain common functions: (a) make a copy of application data (the frequency of this action is commonly termed the Recovery Point Objective (RPO)), (b) store the copy of data in an exclusive storage repository, typically in a proprietary format, and (c) retain the copy for certain duration, measured as Retention Time. A primary difference in each of the point solutions is in the frequency of the RPO, the Retention Time, and the characteristics of the individual storage repositories used, including capacity, cost and geographic location.
- This disclosure pertains to Data Management Virtualization. Data Management activities, such as Backup, Replication and Archiving are virtualized in that they do not have to be configured and run individually and separately. Instead, the user defines their business requirement with regard to the lifecycle of the data, and the Data Management Virtualization System performs these operations automatically. A snapshot is taken from primary storage to secondary storage; this snapshot is then used for a backup operation to other secondary storage. Essentially an arbitrary number of these backups may be made, providing a level of data protection specified by a Service Level Agreement.
- This disclosure also pertains to a method of storing deduplicated images in which a portion of the image is stored in encoded form directly in a hash table, the method comprising organizing unique content of each data object as a plurality of content segments and storing the content segments in a data store; for each data object, creating an organized arrangement of hash structures, wherein each structure, for a subset of the hash structures, includes a field to contain a hash signature for a corresponding content segment and is associated with a reference to the corresponding content segment, wherein the logical organization of the arrangement represents the logical organization of the content segments as they are represented within the data object; receiving content to be included in the deduplicated image of the data object; determining if the received content may be encoded using a predefined non-lossy encoding technique and in which the encoded value would fit within the field for containing a hash signature; if so, placing the encoding in the field and marking the hash structure to indicate that the field contains encoded content for the deduplicated image; if not, generating a hash signature for the received content and placing the hash signature in the field and placing the received content in a corresponding content segment in said data store if it is unique.
- Data Management Virtualization technology according to this disclosure is based on an architecture and implementation based on the following guiding principles.
- First, define the business requirements of an application with a Service Level Agreement (SLA) for its entire data lifecycle. The SLA is much more than a single RPO, Retention and Recovery Time Objective (RTO). It describes the data protection characteristics for each stage of the data lifecycle. Each application may have a different SLA.
- Second, provide a unified Data Management Virtualization Engine that manages the data protection lifecycle, moving data across the various storage repositories, with improved storage capacity and network bandwidth. The Data Management Virtualization system achieves these improvements by leveraging extended capabilities of modern storage systems by tracking the portions of the data that have changed over time and by data deduplication and compression algorithms that reduce the amount of data that needs to be copied and moved.
- Third, leverage a single master copy of the application data to be the basis for multiple elements within the lifecycle. Many of the Data Management operations such as backup, archival and replication depend on a stable, consistent copy of the data to be protected. The Data Management Virtualization System leverages a single copy of the data for multiple purposes. A single instance of the data maintained by the system may serve as the source, from which each data management function may make additional copies as needed. This contrasts with requiring application data to be copied multiple times by multiple independent data management applications in the traditional approach.
- Fourth, abstracting physical storage resources into a series of data protection storage pools, which are virtualized out of different classes of storage including local and remote disk, solid state memory, tape and optical media, private, public and/or hybrid storage clouds. The storage pools provide access independent of the type, physical location or underlying storage technology. Business requirements for the lifecycle of data may call for copying the data to different types of storage media at different times. The Data Management Virtualization system allows the user to classify and aggregate different storage media into storage pools, for example, a Quick Recovery Pool, which consists of high speed disks, and a Cost Efficient Long-term Storage Pool, which may be a deduplicated store on high capacity disks, or a tape library. The Data Management Virtualization System can move data amongst these pools to take advantage of the unique characteristics of each storage medium. The abstraction of Storage Pools provides access independent of the type, physical location or underlying storage technology.
- Fifth, improve the movement of the data between storage pools and disaster locations utilizing underlying device capabilities and post-deduplicated application data. The Data Management Virtualization System discovers the capabilities of the storage systems that comprise the Storage Pools, and takes advantage of these capabilities to move data efficiently. If the Storage System is a disk array that supports the capability of creating a snapshot or clone of a data volume, the Data Management Virtualization System will take advantage of this capability and use a snapshot to make a copy of the data rather than reading the data from one place and writing it to another. Similarly, if a storage system supports change tracking, the Data Management Virtualization System will update an older copy with just the changes to efficiently create a new copy. When moving data across a network, the Data Management Virtualization system uses a deduplication and compression algorithm that avoids sending data that is already available on the other side of the network.
- One key aspect of improving data movement is recognizing that application data changes slowly over time. A copy of an application that is made today will, in general, have a lot of similarities to the copy of the same application that was made yesterday. In fact today's copy of the data could be represented as yesterday's copy with a series of delta transformations, where the size of the delta transformations themselves are usually much smaller than all of the data in the copy itself. The Data Management Virtualization system captures and records these transformations in the form of bitmaps or extent lists. In one embodiment of the system, the underlying storage resources—a disk array or server virtualization system—are capable of tracking the changes made to a volume or file; in these environments, the Data Management Virtualization system queries the storage resources to obtain these change lists, and saves them with the data being protected.
- In the preferred embodiment of the Data Management Virtualization system, there is a mechanism for eavesdropping on the primary data access path of the application, which enables the Data Management Virtualization system to observe which parts of the application data are modified, and to generate its own bitmap of modified data. If, for example, the application modifies
blocks blocks - In one embodiment of the system, where the primary storage for the application is a modern disk array or storage virtualization appliance, the Data Management Virtualization system takes advantage of a point-in-time snapshot capability of an underlying storage device to make the initial copy of the data. This virtual copy mechanism is a fast, efficient and low-impact technique of creating the initial copy that does not guarantee that all the bits will be copied, or stored together. Instead, virtual copies are constructed by maintaining metadata and data structures, such as copy-on-write volume bitmaps or extents, that allow the copies to be reconstructed at access time. The copy has a lightweight impact on the application and on the primary storage device. In another embodiment, where the application is based on a Server Virtualization System such as VMware or Xen, the Data Management Virtualization system uses the similar virtual-machine-snapshot capability that is built into the Server Virtualization systems. When a virtual copy capability is not available, the Data Management Virtualization System may include its own built-in snapshot mechanism.
- It is possible to use the snapshot as a data primitive underlying all of the data management functions supported by the system. Because it is lightweight, the snapshot can be used as an internal operation even when the requested operation is not a snapshot per se; it is created to enable and facilitate other operations.
- At the time of creation of a snapshot, there may be certain preparatory operations involved in order to create a coherent snapshot or coherent image, such that the image may be restored to a state that is usable by the application. These preparatory operations need only be performed once, even if the snapshot will be leveraged across multiple data management functions in the system, such as backup copies which are scheduled according to a policy. The preparatory operations may include application quiescence, which includes flushing data caches and freezing the state of the application; it may also include other operations known in the art and other operations useful for retaining a complete image, such as collecting metadata information from the application to be stored with the image.
-
FIG. 2 illustrates one way that a Virtualized Data Management system can address the data lifecycle requirements described earlier in accordance with these principles. - To serve local backup requirements, a sequence of efficient snapshots are made within local high-
availability storage 202. Some of these snapshots are used to serve development/test requirements without making another copy. For longer term retention of local backup, a copy is made efficiently into long-termlocal storage 204, which in this implementation uses deduplication to reduce repeated copying. The copies within long-term storage may be accessed as backups or treated as an archive, depending on the retention policy applied by the SLA. A copy of the data is made toremote storage 206 in order to satisfy requirements for remote backup and business continuity—again a single set of copies suffices both purposes. As an alternative for remote backup and disaster recovery, a further copy of the data may be made efficiently to arepository 208 hosted by a commercial or private cloud storage provider. -
FIG. 3 illustrates the high level components of the Data Management Virtualization System that implements the above principles. Preferably, the system comprises these basic functional components further described below. -
Application 300 creates and owns the data. This is the software system that has been deployed by the user, as for example, an email system, a database system, or financial reporting system, in order to satisfy some computational need. The Application typically runs on a server and utilizes storage. For illustrative purposes, only one application has been indicated. In reality there may be hundreds or even thousands of applications that are managed by a single Data Management Virtualization System. -
Storage Resources 302 is where application data is stored through its lifecycle. The Storage Resources are the physical storage assets, including internal disk drives, disk arrays, optical and tape storage libraries and cloud-based storage systems that the user has acquired to address data storage requirements. The storage resources consist ofPrimary Storage 310, where the online, active copy of the application data is stored, andSecondary Storage 312 where additional copies of the application data are stored for the purposes such as backup, disaster recovery, archiving, indexing, reporting and other uses. Secondary storage resources may include additional storage within the same enclosure as the primary storage, as well as storage based on similar or different storage technologies within the same data center, another location or across the internet. - One or
more Management Workstations 308 allow the user to specify a Service Level Agreement (SLA) 304 that defines the lifecycle for the application data. A Management workstation is a desktop or laptop computer or a mobile computing device that is used to configure, monitor and control the Data Management Virtualization System. A Service Level Agreement is a detailed specification that captures the detailed business requirements related to the creation, retention and deletion of secondary copies of the application data. The SLA is much more than the simple RTO and RPO that are used in traditional data management applications to represent the frequency of copies and the anticipated restore time for a single class of secondary storage. The SLA captures the multiple stages in the data lifecycle specification, and allows for non uniform frequency and retention specifications within each class of secondary storage. The SLA is described in greater detail inFIG. 7 . - Data
Management Virtualization Engine 306 manages all of the lifecycle of the application data as specified in SLA. It manages potentially a large number of SLAs for a large number of applications. The Data Management Virtualization Engine takes inputs from the user through the Management Workstation and interacts with the applications to discover the applications primary storage resources. The Data Management Virtualization Engine makes decisions regarding what data needs to be protected and what secondary storage resources best fulfill the protection needs. For example, if an enterprise designates its accounting data as requiring copies to be made at very short intervals for business continuity purposes as well as for backup purposes, the Engine may decide to create copies of the accounting data at a short interval to a first storage pool, and to also create backup copies of the accounting data to a second storage pool at a longer interval, according to an appropriate set of SLAs. This is determined by the business requirements of the storage application. - The Engine then makes copies of application data using advanced capabilities of the storage resources as available. In the above example, the Engine may schedule the short-interval business continuity copy using a storage appliance's built-in virtual copy or snapshot capabilities. Data Management Virtualization Engine moves the application data amongst the storage resources in order to satisfy the business requirements that are captured in the SLA. The Data Management Virtualization Engine is described in greater detail in
FIG. 4 . - The Data Management Virtualization System as a whole may be deployed within a single host computer system or appliance, or it may be one logical entity but physically distributed across a network of general-purpose and purpose-built systems. Certain components of the system may also be deployed within a computing or storage cloud.
- In one embodiment of the Data Management Virtualization System the Data Management Virtualization Engine largely runs as multiple processes on a fault tolerant, redundant pair of computers. Certain components of the Data Management Virtualization Engine may run close to the application within the application servers. Some other components may run close to the primary and secondary storage, within the storage fabric or in the storage systems themselves. The Management stations are typically desktop and laptop computers and mobile devices that connect over a secure network to the Engine.
-
FIG. 4 illustrates an architectural overview of the DataManagement Virtualization Engine 306 according to certain embodiments of the invention. The 306 Engine includes the following modules: - Application Specific Module 402: This module is responsible for controlling and collecting metadata from the
application 300. Application metadata includes information about the application such as the type of application, details about its configuration, location of its datastores, its current operating state. Controlling the operation of the application includes actions such as flushing cached data to disk, freezing and thawing application I/O, rotating or truncating log files, and shutting down and restarting applications. The Application Specific module performs these operations and sends and receives metadata in responses to commands from the ServiceLevel Policy Engine 406, described below. The Application Specific Module is described in more detail in connection withFIG. 8 . - Service
Level Policy Engine 406 acts on theSLA 304 provided by the user to make decisions regarding the creation, movement and deletion of copies of the application data. Each SLA describes the business requirements related to protection of one application. The Service Level Policy Engine analyzes each SLA and arrives at a series of actions each of which involve the copying of application data from one storage location to another. The Service Level Policy Engine then reviews these actions to determine priorities and dependencies, and schedules and initiates the data movement jobs. The Service Level Policy Engine is described in more detail in connection withFIG. 9 . - Object Manager and
Data Movement Engine 410 creates a composite object consisting of the Application data, the Application Metadata and the SLA which it moves through different storage pools per instruction from the Policy Engine. The Object Manager receives instructions from theService Policy Engine 406 in the form of a command to create a copy of application data in a particular pool based on the liveprimary data 413 belonging to theapplication 300, or from an existing copy, e.g., 415, in another pool. The copy of the composite object that is created by the Object Manager and the Data Movement Engine is self contained and self describing in that it contains not only application data, but also application metadata and the SLA for the application. The Object Manager and Data Movement Engine are described in more detail in connection withFIG. 5 . -
Storage Pool Manager 412 is a component that adapts and abstracts the underlyingphysical storage resources 302 and presents them as virtual storage pools 418. The physical storage resources are the actual storage assets, such as disk arrays and tape libraries that the user has deployed for the purpose of supporting the lifecycle of the data of the user's applications. These storage resources might be based on different storage technologies such as disk, tape, flash memory or optical storage. The storage resources may also have different geographic locations, cost and speed attributes, and may support different protocols. The role of the Storage Pool Manager is to combine and aggregate the storage resources, and mask the differences between their programming interfaces. The Storage Pool Manager presents the physical storage resources to theObject Manager 410 as a set of storage pools that have characteristics that make these pools suitable for particular stages in the lifecycle of application data. The Storage Pool Manager is described in more detail in connection withFIG. 6 . -
FIG. 5 illustrates the Object Manager andData Movement Engine 410. The Object Manager and Data Movement Engine discovers and usesVirtual Storage Resources 510 presented to it by thePool Managers 504. It accepts requests from the ServiceLevel Policy Engine 406 to create and maintain Data Storage Object instances from the resources in a Virtual Storage Pool, and it copies application data among instances of storage objects from the Virtual Storage Pools according to the instructions from the Service Level Policy Engine. The target pool selected for the copy implicitly designates the business operation being selected, e.g. backup, replication or restore. The Service Level Policy Engine resides either locally to the Object Manager (on the same system) or remotely, and communicates using a protocol over standard networking communication. TCP/IP may be used in a preferred embodiment, as it is well understood, widely available, and allows the Service Level Policy Engine to be located locally to the Object Manager or remotely with little modification. - In one embodiment, the system may deploy the Service Level Policy Engine on the same computer system as the Object Manager for ease of implementation. In another embodiment, the system may employ multiple systems, each hosting a subset of the components if beneficial or convenient for an application, without changing the design.
- The
Object Manager 501 and theStorage Pool Managers 504 are software components that may reside on the computer system platform that interconnects the storage resources and the computer systems that use those storage resources, where the user's application resides. The placement of these software components on the interconnect platform is designated as a preferred embodiment, and may provide the ability to connect customer systems to storage via communication protocols widely used for such applications (e.g. Fibre Channel, iSCSI, etc.), and may also provide ease of deployment of the various software components. - The
Object Manager 501 andStorage Pool Manager 504 communicate with the underlying storage virtualization platform via the Application Programming Interfaces made available by the platform. These interfaces allow the software components to query and control the behavior of the computer system and how it interconnects the storage resources and the computer system where the user's Application resides. The components apply modularity techniques as is common within the practice to allow replacement of the intercommunication code particular to a given platform. - The Object Manager and Storage Pool Managers communicate via a protocol. These are transmitted over standard networking protocols, e.g. TCP/IP, or standard Interprocess Communication (IPC) mechanisms typically available on the computer system. This allows comparable communication between the components if they reside on the same computer platform or on multiple computer platforms connected by a network, depending on the particular computer platform. The current configuration has all of the local software components residing on the same computer system for ease of deployment. This is not a strict requirement of the design, as described above, and can be reconfigured in the future as needed.
-
Object Manager 501 is a software component for maintaining Data Storage Objects, and provides a set of protocol operations to control it. The operations include creation, destruction, duplication, and copying of data among the objects, maintaining access to objects, and in particular allow the specification of the storage pool used to create copies. There is no common subset of functions supported by all pools; however, in a preferred embodiment, primary pools may be performance-optimized, i.e. lower latency, whereas backup or replication pools may be capacity-optimized, supporting larger quantities of data and content-addressable. The pools may be remote or local. The storage pools are classified according to various criteria, including means by which a user may make a business decision, e.g. cost per gigabyte of storage. - First, the particular storage device from which the storage is drawn may be a consideration, as equipment is allocated for different business purposes, along with associated cost and other practical considerations. Some devices may not even be actual hardware but capacity provided as a service, and selection of such a resource can be done for practical business purposes.
- Second, the network topological “proximity” is considered, as near storage is typically connected by low-latency, inexpensive network resources, while distant storage may be connected by high-latency, bandwidth limited expensive network resources; conversely, the distance of a storage pool relative to the source may be beneficial when geographic diversity protects against a physical disaster affecting local resources.
- Third, storage optimization characteristics are considered, where some storage is optimized for space-efficient storage, but requires computation time and resources to analyze or transform the data before it can be stored, while other storage by comparison is “performance optimized,” taking more storage resources by comparison but using comparatively little computation time or resource to transform the data, if at all.
- Fourth, “speed of access” characteristics are considered, where some resources intrinsic to a storage computer platform are readily and quickly made available to the user's Application, e.g. as a virtual SCSI block device, while some can only be indirectly used. These ease and speed of recovery is often governed by the kind of storage used, and this allows it to be suitably classified.
- Fifth, the amount of storage used and the amount available in a given pool are considered, as there may be benefit to either concentrating or spreading the storage capacity used.
- The Service Level Policy Engine, described below, combines the SLA provided by the user with the classification criteria to determine how and when to maintain the application data, and from which storage pools to draw the needed resources to meet the Service Level Agreement (SLA).
- The
object manager 501 creates, maintains and employs a history mechanism to track the series of operations performed on a data object within the performance pools, and to correlate those operations with others that move the object to other storage pools, in particular capacity-optimized ones. This series of records for each data object is maintained at the object manager for all data objects in the primary pool, initially correlated by primary data object, then correlated by operation order: a time line for each object and a list of all such time lines. Each operation performed exploits underlying virtualization primitives to capture the state of the data object at a given point in time. - Additionally, the underlying storage virtualization appliance may be modified to expose and allow retrieval of internal data structures, such as bitmaps, that indicate the modification of portions of the data within the data object. These data structures are exploited to capture the state of a data object at a point in time: e.g., a snapshot of the data object, and to provide differences between snapshots taken at a specific time, and thereby enables optimal backup and restore. While the particular implementations and data structures may vary among different appliances from different vendors, a data structure is employed to track changes to the data object, and storage is employed to retain the original state of those portions of the object that have changed: indications in the data structure correspond to data retained in the storage. When accessing the snapshot, the data structure is consulted and for portions that have been changed, the preserved data is accessed rather than the current data, as the data object has been modified at the areas so indicated. A typical data structure employed is a bitmap, where each bit corresponds to a section of the data object. Setting the bit indicates that section has been modified after the point in time of the snapshot operation. The underlying snapshot primitive mechanism maintains this for as long as the snapshot object exists.
- The time line described above maintains a list of the snapshot operations against a given primary data object, including the time an operation is started, the time it is stopped (if at all), a reference to the snapshot object, and a reference to the internal data structure (e.g. bitmaps or extent lists), so that it can be obtained from the underlying system. Also maintained is a reference to the result of copying the state of the data object at any given point in time into another pool—as an example, copying the state of a data object into a capacity-optimized pool 407 using content addressing results in an object handle. That object handle corresponds to a given snapshot and is stored with the snapshot operation in the time line. This correlation is used to identify suitable starting points.
- Optimal backup and restore consult the list of operations from a desired starting point to an end point. A time ordered list of operations and their corresponding data structures (bitmaps) are constructed such that a continuous time series from start to finish is realized: there is no gap between start times of the operations in the series. This ensures that all changes to the data object are represented by the corresponding bitmap data structures. It is not necessary to retrieve all operations from start to finish; simultaneously existing data objects and underlying snapshots overlap in time; it is only necessary that there are no gaps in time where a change might have occurred that was not tracked. As bitmaps indicate that a certain block of storage has changed but not what the change is, the bitmaps may be added or composed together to realize a set of all changes that occurred in the time interval. Instead of using this data structure to access the state at a point in time, the system instead exploits the fact that the data structure represents data modified as time marches forward. Rather, the end state of the data object is accessed at the indicated areas, thus returning the set of changes to the given data object from the given start time to the end time.
- The backup operation exploits this time line, the correlated references, and access to the internal data structures to realize our backup operation. Similarly, it uses the system in a complementary fashion to accomplish our restore operation. The specific steps are described below in the section for “Optimal Backup/Restore.”
-
FIG. 5 illustrates several representative storage pool types. Although one primary storage pool and two secondary storage pools are depicted in the figure, many more may be configured in some embodiments. -
Primary Storage Pool 507—contains the storage resources used to create the data objects in which the user Application stores its data. This is in contrast to the other storage pools, which exist to primarily fulfill the operation of the Data Management Virtualization Engine. - Performance Optimized
Pool 508—a virtual storage pool able to provide high performance backup (i.e. point in time duplication, described below) as well as rapid access to the backup image by the user Application - Capacity Optimized
Pool 509—a virtual storage pool that chiefly provides storage of a data object in a highly space-efficient manner by use of deduplication techniques described below. The virtual storage pool provides access to the copy of the data object, but does not do so with high performance as its chief aim, in contrast to the Performance Optimized pool above. - The initial deployments contain storage pools as described above, as a minimal operational set. The design fully expects multiple Pools of a variety of types, representing various combinations of the criteria illustrated above, and multiple Pool Managers as is convenient to represent all of the storage in future deployments. The tradeoffs illustrated above are typical of computer data storage systems.
- From a practical point of view, these three pools represent a preferred embodiment, addressing most users requirements in a very simple way. Most users will find that if they have one pool of storage for urgent restore needs, which affords quick recovery, and one other pool that is low cost, so that a large number of images can be retained for a large period of time, almost all of the business requirements for data protection can be met with little compromise.
- The format of data in each pool is dictated by the objectives and technology used within the pool. For example, the quick recovery pool is maintained in the form very similar to the original data to minimize the translation required and to improve the speed of recovery. The long-term storage pool, on the other hand, uses deduplication and compression to reduce the size of the data and thus reduce the cost of storage.
- The
Object Manager 501 creates and maintains instances ofData Storage Objects 503 from theVirtual Storage Pools 418 according to the instructions sent to it by the ServiceLevel Policy Engine 406. The Object Manager provides data object operations in five major areas: point-in-time duplication or copying (commonly referred to as “snapshots”), standard copying, object maintenance, mapping and access maintenance, and collections. - Object Management operations also include a series of Resource Discovery operations for maintaining Virtual Storage Pools themselves and retrieving information about them. The
Pool Manager 504 ultimately supplies the functionality for these. - Snapshot operations create a data object instance representing an initial object instance at a specific point in time. More specifically, a snapshot operation creates a complete virtual copy of the members of a collection using the resources of a specified Virtual Storage Pool. This is called a Data Storage Object. Multiple states of a Data Storage Object are maintained over time, such that the state of a Data Storage Object as it existed at a point in time is available. As described above, a virtual copy is a copy implemented using an underlying storage virtualization API that allows a copy to be created in a lightweight fashion, using copy-on-write or other in-band technologies instead of copying and storing all bits of duplicate data to disk. This may be implemented using software modules written to access the capabilities of an off-the-shelf underlying storage virtualization system such as provided by EMC, vmware or IBM in some embodiments. Where such underlying virtualizations are not available, the described system may provide its own virtualization layer for interfacing with unintelligent hardware.
- Snapshot operations require the application to freeze the state of the data to a specific point so that the image data is coherent, and so that the snapshot may later be used to restore the state of the application at the time of the snapshot. Other preparatory steps may also be required. These are handled by the Application-
Specific Module 302, which is described in a subsequent section. For live applications, therefore, the most lightweight operations are desired. - Snapshot operations are used as the data primitive for all higher-level operations in the system. In effect, they provide access to the state of the data at a particular point in time. As well, since snapshots are typically implemented using copy-on-write techniques that distinguish what has changed from what is resident on disk, these snapshots provide differences that can also be composed or added together to efficiently copy data throughout the system. The format of the snapshot may be the format of data that is copied by
Data Mover 502, which is described below. - When a copy operation is not a snapshot, it may be considered a standard copy operation. A standard copy operation copies all or a subset of a source data object in one storage pool to a data object in another storage pool. The result is two distinct objects. One type of standard copy operation that may be used is an initial “baseline” copy. This is typically done when data is initially copied from one Virtual Storage Pool into another, such as from a performance-optimized pool to a capacity-optimized storage pool. Another type of standard copy operation may be used wherein only changed data or differences are copied to a target storage pool to update the target object. This would occur after an initial baseline copy has previously been performed.
- A complete exhaustive version of an object need not be preserved in the system each time a copy is made, even though a baseline copy is needed when the Data Virtualization System is first initialized. This is because each virtual copy provides access to a complete copy. Any delta or difference can be expressed in relation to a virtual copy instead of in relation to a baseline. This has the positive side effect of virtually eliminating the common step of walking through a series of change lists.
- Standard copy operations are initiated by a series of instructions or requests supplied by the Pool Manager and received by the Data Mover to cause the movement of data among the Data Storage Objects, and to maintain the Data Storage Objects themselves. The copy operations allow the creation of copies of the specified Data Storage Objects using the resources of a specified Virtual Storage Pool. The result is a copy of the source Data Object in a target Data Object in the storage pool.
- The Snapshot and Copy operations are each structured with a preparation operation and an activation operation. The two steps of prepare and activate allow the long-running resource allocation operations, typical of the prepare phase, to be decoupled from the actuation. This is required by applications that can only be paused for a short while to fulfill the point-in-time characteristics of a snapshot operation, which in reality takes a finite but non-zero amount of time to accomplish. Similarly for copy and snapshot operations, this two-step preparation and activation structure allows the Policy Engine to proceed with an operation only if resources for all of the collection members can be allocated.
- Object Maintenance operations are a series of operations for maintaining data objects, including creation, destruction, and duplication. The Object Manager and Data Mover use functionality provided by a Pool Request Broker (more below) to implement these operations. The data objects may be maintained at a global level, at each Storage Pool, or preferably both.
- Collection operations are auxiliary functions. Collections are abstract software concepts, lists maintained in memory by the object manager. They allow the
Policy Engine 206 to request a series of operations over all of the members in a collection, allowing a consistent application of a request to all members. The use of collections allows for simultaneous activation of the point-in-time snapshot so that multiple Data Storage Objects are all captured at precisely the same point in time, as this is typically required by the application for a logically correct restore. The use of collections allows for convenient request of a copy operation across all members of a collection, where an application would use multiple storage objects as a logical whole. - The Object Manager discovers Virtual Storage Pools by issuing
Object Management Operations 505 to thePool Manager 504, and uses the information obtained about each of the pools to select one that meets the required criteria for a given request, or in the case where none match, a default pool is selected, and the Object Manager can then create a data storage object using resources from the selected Virtual Storage Pool. - The Object Manager also provides sets of Object Management operations to allow and maintain the availability of these objects to external Applications. The first set is operations for registering and unregistering the computers where the user's Applications reside. The computers are registered by the identities typical to the storage network in use (e.g. Fibre Channel WWPN, iSCSI identity, etc.). The second set is “mapping” operations, and when permitted by the storage pool from which an object is created, the Data Storage Object can be “mapped,” that is, made available for use to a computer on which a user Application resides.
- This availability takes a form appropriate to the storage, e.g. a block device presented on a SAN as a Fibre Channel disk or iSCSI device on a network, a filesystem on a file sharing network, etc. and is usable by the operating system on the Application computer. Similarly, an “unmapping” operation reverses the availability of the virtual storage device on the network to a user Application. In this way, data stored for one Application, i.e. a backup, can be made available to another Application on another computer at a later time, i.e. a restore.
- The
Data Mover 502 is a software component within the Object Manager and Data Mover that reads and writes data among the variousData Storage Objects 503 according to instructions received from the Object Manager for Snapshot (Point in Time) Copy requests and standard copy requests. The Data Mover provides operations for reading and writing data among instances of data objects throughout the system. The Data Mover also provides operations that allow querying and maintaining the state of long running operations that the Object Manager has requested for it to perform. - The Data Mover uses functionality from the Pool Functionality Providers (see
FIG. 6 ) to accomplish its operation. TheSnapshot functionality provider 608 allows creation of a data object instance representing an initial object instance at a specific point in time. The DifferenceEngine functionality provider 614 is used to request a description of the differences between two data objects that are related in a temporal chain. For data objects stored on content-addressable pools, a special functionality is provided that can provide differences between any two arbitrary data objects. This functionality is also provided for performance-optimized pools, in some cases by an underlying storage virtualization system, and in other cases by a module that implements this on top of commodity storage. TheData Mover 502 uses the information about the differences to select the set of data that it copies between instances of data objects 503. - For a given Pool, the Difference Engine Provider provides a specific representation of the differences between two states of a Data Storage Object over time. For a Snapshot provider the changes between two points in time are recorded as writes to a given part of the Data Storage Object. In one embodiment, the difference is represented as a bitmap where each bit corresponds to an ordered list of the Data Object areas, starting at the first and ascending in order to the last, where a set bit indicates a modified area. This bitmap is derived from the copy-on-write bitmaps used by the underlying storage virtualization system. In another embodiment, the difference may be represented as a list of extents corresponding to changed areas of data. For a Content
Addressable storage provider 610, the representation is described below, and is used to determine efficiently the parts of two Content Addressable Data Objects that differ. - The Data Mover uses this information to copy only those sections that differ, so that a new version of a Data Object can be created from an existing version by first duplicating it, obtaining the list of differences, and then moving only the data corresponding to those differences in the list. The
Data Mover 502 traverses the list of differences, moving the indicated areas from the source Data Object to the target Data Object. (See Optimal Way for Data Backup and Restore.) - The
Object Manager 501 instructs theData Mover 502 through a series of operations to copy data among the data objects in theVirtual Storage Pools 418. The procedure comprises the following steps, starting at the reception of instructions: - First, create Collection request. A name for the collection is returned.
- Second, add Object to Collection. The collection name from above is used as well as the name of the source Data Object that is to be copied and the name of two antecedents: a Data Object against which differences are to be taken in the source Storage Resource Pool, and a corresponding Data Object in the target Storage Resource Pool. This step is repeated for each source Data Object to be operated on in this set.
- Third, prepare Copy Request. The collection name is supplied as well as a Storage Resource Pool to act as a target. The prepare command instructs the Object Manager to contact the Storage Pool Manager to create the necessary target Data Objects, corresponding to each of the sources in the collection. The prepare command also supplies the corresponding Data Object in the target Storage Resource Pool to be duplicated, so the Provider can duplicate the provided object and use that as a target object. A reference name for the copy request is returned.
- Fourth, activate Copy Request. The reference name for the copy request returned above is supplied. The Data Mover is instructed to copy a given source object to its corresponding target object. Each request includes a reference name as well as a sequence number to describe the overall job (the entire set of source target pairs) as well as a sequence number to describe each individual source-target pair. In addition to the source-target pair, the names of the corresponding antecedents are supplied as part of the Copy instruction.
- Fifth, the Copy Engine uses the name of the Data Object in the source pool to obtain the differences between the antecedent and the source from the Difference Engine at the source. The indicated differences are then transmitted from the source to the target. In one embodiment, these differences are transmitted as bitmaps and data. In another embodiment, these differences are transmitted as extent lists and data.
- Data Storage Objects are software constructs that permit the storage and retrieval of Application data using idioms and methods familiar to computer data processing equipment and software. In practice these currently take the form of a SCSI block device on a storage network, e.g. a SCSI LUN, or a content-addressable container, where a designator for the content is constructed from and uniquely identifies the data therein. Data Storage Objects are created and maintained by issuing instructions to the Pool Manager. The actual storage for persisting the Application data is drawn from the Virtual Storage Pool from which the Data Storage Object is created.
- The structure of the data storage object varies depending on the storage pool from which it is created. For the objects that take the form of a block device on a storage network, the data structure for a given block device Data Object implements a mapping between the Logical Block Address (LBA) of each of the blocks within the Data Object to the device identifier and LBA of the actual storage location. The identifier of the Data Object is used to identify the set of mappings to be used. The current embodiment relies on the services provided by the underlying physical computer platform to implement this mapping, and relies on its internal data structures, such as bitmaps or extent lists.
- For objects that take the form of a Content Addressable Container, the content signature is used as the identifier, and the Data Object is stored as is described below in the section about deduplication.
- A
Pool Manager 504 is a software component for managing virtual storage resources and the associated functionality and characteristics as described below. TheObject manager 501 andData Movement Engine 502 communicate with one ormore Pool Managers 504 to maintainData Storage Objects 503. -
Virtual Storage Resources 510 are various kinds of storage made available to the Pool Manager for implementing storage pool functions, as described below. In this embodiment, a storage virtualizer is used to present various external Fibre Channel or iSCSI storage LUNs as virtualized storage to thePool Manager 504. -
FIG. 6 further illustrates theStorage Pool Manager 504. The purpose of the storage pool manager is to present underlying virtual storage resources to the Object Manager/Data Mover as Storage Resource Pools, which are abstractions of storage and data management functionality with common interfaces that are utilized by other components of the system. These common interfaces typically include a mechanism for identifying and addressing data objects associated with a specific temporal state, and a mechanism for producing differences between data objects in the form of bitmaps or extents. In this embodiment, the pool manager presents a Primary Storage Pool, a Performance Optimized Pool, and a Capacity Optimized Pool. The common interfaces allow the object manager to create and delete Data Storage objects in these pools, either as copies of other data storage objects or as new objects, and the data mover can move data between data storage objects, and can use the results of data object differencing operations. - The storage pool manager has a typical architecture for implementing a common interface to diverse implementations of similar functionality, where some functionality is provided by “smart” underlying resources, and other functionality must be implemented on top of less functional underlying resources.
-
Pool request broker 602 andpool functionality providers 604 are software modules executing in either the same process as the Object Manager/Data Mover, or in another process communicating via a local or network protocol such as TCP. In this embodiment the providers comprise aPrimary Storage provider 606,Snapshot provider 608,Content Addressable provider 610, andDifference Engine provider 614, and these are further described below. In another embodiment the set of providers may be a superset of those shown here. -
Virtual Storage Resources 510 are the different kinds of storage made available to the Pool Manager for implementing storage pool functions. In this embodiment, the virtual storage resources comprise sets of SCSI logical units from a storage virtualization system that runs on the same hardware as the pool manager, and accessible (for both data and management operations) through a programmatic interface: in addition to standard block storage functionality additional capabilities are available including creating and deleting snapshots, and tracking changed portions of volumes. In another embodiment the virtual resources can be from an external storage system that exposes similar capabilities, or may differ in interface (for example accessed through a file-system, or through a network interface such as CIFS, iSCSI or CDMI), in capability (for example, whether the resource supports an operation to make a copy-on-write snapshot), or in non-functional aspects (for example, high-speed/limited-capacity such as Solid State Disk versus low-speed/high-capacity such as SATA disk). The capabilities and interface available determine which providers can consume the virtual storage resources, and which pool functionality needs to be implemented within the pool manager by one or more providers: for example, this implementation of a content addressable storage provider only requires “dumb” storage, and the implementation is entirely within contentaddressable provider 610; an underlying content addressable virtual storage resource could be used instead with a simpler “pass-through” provider. Conversely, this implementation of a snapshot provider is mostly “pass-through” and requires storage that exposes a quick point-in-time copy operation. -
Pool Request Broker 602 is a simple software component that services requests for storage pool specific functions by executing an appropriate set of pool functionality providers against the configuredvirtual storage resource 510. The requests that can be serviced include, but are not limited to, creating an object in a pool; deleting an object from a pool; writing data to an object; reading data from an object; copying an object within a pool; copying an object between pools; requesting a summary of the differences between two objects in a pool. -
Primary storage provider 606 enables management interfaces (for example, creating and deleting snapshots, and tracking changed portions of files) to a virtual storage resource that is also exposed directly to applications via an interface such as fibre channel, iSCSI, NFS or CIFS. -
Snapshot provider 608 implements the function of making a point-in-time copy of data from a Primary resource pool. This creates the abstraction of another resource pool populated with snapshots. As implemented, the point-in-time copy is a copy-on-write snapshot of the object from the primary resource pool, consuming a second virtual storage resource to accommodate the copy-on-write copies, since this management functionality is exposed by the virtual storage resources used for primary storage and for the snapshot provider. -
Difference engine provider 614 can satisfy a request for two objects in a pool to be compared that are connected in a temporal chain. The difference sections between the two objects are identified and summarized in a provider-specific way, e.g. using bitmaps or extents. For example, the difference sections might be represented as a bitmap where each set bit denotes a fixed size region where the two objects differ; or the differences might be represented procedurally as a series of function calls or callbacks. - Depending on the virtual storage resource on which the pool is based, or on other providers implementing the pool, a difference engine may produce a result efficiently in various ways. As implemented, a difference engine acting on a pool implemented via a snapshot provider uses the copy-on-write nature of the snapshot provider to track changes to objects that have had snapshots made. Consecutive snapshots of a single changing primary object thus have a record of the differences that is stored alongside them by the snapshot provider, and the difference engine for snapshot pools simply retrieves this record of change. Also as implemented, a difference engine acting on a pool implemented via a Content Addressable provider uses the efficient tree structure (see below,
FIG. 12 ) of the content addressable implementation to do rapid comparisons between objects on demand. - Content
addressable provider 610 implements a write-once content addressable interface to the virtual storage resource it consumes. It satisfies read, write, duplicate and delete operations. Each written or copied object is identified by a unique handle that is derived from its content. The content addressable provider is described further below (FIG. 11 ). - In operation, the
pool request broker 502 accepts requests for data manipulation operations such as copy, snapshot, or delete on a pool or object. The request broker determines which provider code frompool 504 to execute by looking at the name or reference to the pool or object. The broker then translates the incoming service request into a form that can be handled by the specific pool functionality provider, and invokes the appropriate sequence of provider operations. - For example, an incoming request could ask to make a snapshot from a volume in a primary storage pool, into a snapshot pool. The incoming request identifies the object (volume) in the primary storage pool by name, and the combination of name and operation (snapshot) determines that the snapshot provider should be invoked which can make point-in-time snapshots from the primary pool using the underlying snapshot capability. This snapshot provider will translate the request into the exact form required by the native copy-on-write function performed by the underlying storage virtualization appliance, such as bitmaps or extents, and it will translate the result of the native copy-on-write function to a storage volume handle that can be returned to the object manager and used in future requests to the pool manager.
- Optimal Way for Data Backup is a series of operations to make successive versions of Application Data objects over time, while minimizing the amount of data that must be copied by using bitmaps, extents and other temporal difference information stored at the Object Mover. It stores the application data in a data storage object and associates with it the metadata that relates the various changes to the application data over time, such that changes over time can be readily identified.
- In a preferred embodiment, the procedure comprises the following steps:
-
- 1. The mechanism provides an initial reference state, e.g. T0, of the Application Data within a Data Storage Object.
- 2. Subsequent instances (versions) are created on demand over time of the Data Storage Object in a Virtual Storage Pool that has a Difference Engine Provider.
- 3. Each successive version, e.g. T4, T5, uses the Difference Engine Provider for the Virtual Storage Pool to obtain the difference between it and the instance created prior to it, so that T5 is stored as a reference to T4 and a set of differences between T5 and T4.
- 4. The Copy Engine receives a request to copy data from one data object (the source) to another data object (the destination).
- 5. If the Virtual Storage Pool in which the destination object will be created contains no other objects created from prior versions of the source data object, then a new object is created in the destination Virtual Storage Pool and the entire contents of the source data object are copied to the destination object; the procedure is complete. Otherwise the next steps are followed.
- 6. If the Virtual Storage Pool in which the destination object is created contains objects created from prior versions of the source data object, a recently created prior version in the destination Virtual Storage Pool is selected for which there exists a corresponding prior version in the Virtual Storage Pool of the source data object. For example, if a copy of T5 is initiated from a snapshot pool, and an object created at time T3 is the most recent version available at the target, T3 is selected as the prior version.
- 7. Construct a time-ordered list of the versions of the source data object, beginning with an initial version identified in the previous step, and ending with the source data object that is about to be copied. In the above example, at the snapshot pool, all states of the object are available, but only the states including and following T3 are of interest: T3, T4, T5.
- 8. Construct a corresponding list of the differences between each successive version in the list such that all of the differences, from the beginning version of the list to the end are represented. Difference both, identify which portion of data has changed and includes the new data for the corresponding time. This creates a set of differences from the target version to the source version, e.g. the difference between T3 and T5.
- 9. Create the destination object by duplicating the prior version of the object identified in Step 6 in the destination Virtual Storage Pool, e.g. object T3 in the target store.
- 10. Copy the set of differences identified in the list created in
Step 8 from the source data object to the destination object; the procedure is complete.
- Each data object within the destination Virtual Storage Pool is complete; that is, it represents the entire data object and allows access to the all of the Application Data at the point in time without requiring external reference to state or representations at other points in time. The object is accessible without replaying all deltas from a baseline state to the present state. Furthermore, the duplication of initial and subsequent versions of the data object in the destination Virtual Storage Pool does not require exhaustive duplication of the Application Data contents therein. Finally, to arrive at second and subsequent states requires only the transmission of the changes tracked and maintained, as described above, without exhaustive traversal, transmission or replication of the contents of the data storage object.
- Intuitively, the operation of the Optimal Way for Data Restore is the converse of the Optimal Way for Data Backup. The procedure to recreate the desired state of a data object in a destination Virtual Storage Pool at a given point in time comprises the following steps:
-
- 1. Identify a version of the data object in another Virtual Storage Pool that has a Difference Engine Provider, corresponding to the desired state to be recreated. This is the source data object in the source Virtual Storage Pool.
- 2. Identify a preceding version of the data object to be recreated in the destination Virtual Storage Pool.
- 3. If no version of the data object is identified in
Step 2, then create a new destination object in the destination Virtual Storage Pool and copy the data from the source data object to the destination data object. The procedure is complete. Otherwise, proceed with the following steps. - 4. If a version of the data object is identified in
Step 2, then identify a data object in the source Virtual Storage Pool corresponding to the data object identified inStep 2. - 5. If no data object is identified in Step 4, then create a new destination object in the destination Virtual Storage Pool and copy the data from the source data object to the destination data object. The procedure is complete. Otherwise, proceed with the following steps.
- 6. Create a new destination data object in the Destination Virtual Storage Pool by duplicating the data object identified in
Step 2. - 7. Employ the Difference Engine Provider for the source Virtual Storage Pool to obtain the set of differences between the data object identified in
Step 1 and the data object identified in Step 4. - 8. Copy the data identified by the list created in Step 7 from the source data object to the destination data object. The procedure is complete.
- Access to the desired state is complete: it does not require external reference to other containers or other states. Establishing the desired state given a reference state requires neither exhaustive traversal nor exhaustive transmission, only the retrieved changes indicated by the provided representations within the source Virtual Storage Pool.
-
FIG. 7 illustrates the Service Level Agreement. The Service Level Agreement captures the detailed business requirements with respect to secondary copies of the application data. In the simplest description, the business requirements define when and how often copies are created, how long they are retained and in what type of storage pools these copies reside. This simplistic description does not capture several aspects of the business requirements. The frequency of copy creation for a given type of pool may not be uniform across all hours of the day or across all days of a week. Certain hours of the day, or certain days of a week or month may represent more (or less) critical periods in the application data, and thus may call for more (or less) frequent copies. Similarly, all copies of application data in a particular pool may not be required to be retained for the same length of time. For example, a copy of the application data created at the end of monthly processing may need to be retained for a longer period of time than a copy in the same storage pool created in the middle of a month. - The
Service Level Agreement 304 of certain embodiments has been designed to represent all of these complexities that exist in the business requirements. The Service Level Agreement has four primary parts: the name, the description, the housekeeping attributes and a collection of Service Level Policies. As mentioned above, there is one SLA per application. - The
name attribute 701 allows each Service Level Agreement to have a unique name. - The
description attribute 702 is where the user can assign a helpful description for the Service Level Agreement. - The Service Level agreement also has a number of housekeeping attributes 703 that enable it to be maintained and revised. These attributes include but are not limited to the owner's identity, the dates and times of creation, modification and access, priority, enable/disable flags.
- The Service Level Agreement also contains a plurality of
Service Level Policies 705. Some Service level Agreements may have just a single Service Level Policy. More typically, a single SLA may contain tens of policies. - Each Service Level Policy consists of at least the following, in certain embodiments: the source
storage pool location 706 andtype 708; the targetstorage pool location 710 andtype 712; the frequency for the creation ofcopies 714, expressed as a period of time; the length of retention of thecopy 716, expressed as a period of time; the hours ofoperation 718 during the day for this particular Service Level Policy; and the days of the week, month oryear 720 on which this Service Level Policy applies. - Each Service Level Policy specifies a source and target storage pool, and the frequency of copies of application data that are desired between those storage pools. Furthermore, the Service Level Policy specifies its hours of operation and days on which it is applicable. Each Service Level Policy is the representation of one single statement in the business requirements for the protection of application data. For example, if a particular application has a business requirement for an archive copy to be created each month after the monthly close and retained for three years, this might translate to a Service level Policy that requires a copy from the Local Backup Storage Pool into the Long-term Archive Storage Pool at midnight on the last day of the month, with a retention of three years.
- All of the Service Level Policies with a particular combination of source and destination pool and location, say for example, source Primary Storage pool and destination local Snapshot pool, when taken together, specify the business requirements for creating copies into that particular destination pool. Business requirements may dictate for example that snapshot copies be created every hour during regular working hours, but only once every four hours outside of these times. Two Service Level Policies with the same source and target storage pools will effectively capture these requirements in a form that can be put into practice by the Service Policy Engine.
- This form of a Service Level Agreement allows the representation of the schedule of daily, weekly and monthly business activities, and thus captures business requirements for protecting and managing application data much more accurately than traditional RPO and RPO based schemes. By allowing hour of operation and days, weeks, and months of the year, scheduling can occur on a “calendar basis.”
- Taken together, all of the Service Level Policies with one particular combination of source and destinations, for example, “source: local primary and destination: local performance optimized”, captures the non-uniform data protection requirements for one type of storage. A single RPO number, on the other hand, forces a single uniform frequency of data protection across all times of day and all days. For example, a combination of Service Level Policies may require a large number of snapshots to be preserved for a short time, such as 10 minutes, and a lesser number of snapshots to be preserved for a longer time, such as 8 hours; this allows a small amount of information that has been accidentally deleted can be reverted to a state not more than 10 minutes before, while still providing substantial data protection at longer time horizons without requiring the storage overhead of storing all snapshots taken every ten minutes. As another example, the backup data protection function may be given one Policy that operates with one frequency during the work week, and another frequency during the weekend.
- When Service Level Policies for all of the different classes of source and destination storage are included, the Service Level Agreement fully captures all of the data protection requirements for the entire application, including local snapshots, local long duration stores, off-site storage, archives, etc. A collection of policies within a SLA is capable of expressing when a given function should be performed, and is capable of expressing multiple data management functions that should be performed on a given source of data.
- Service Level Agreements are created and modified by the user through a user interface on a management workstation. These agreements are electronic documents stored by the Service Policy Engine in a structured SQL database or other repository that it manages. The policies are retrieved, electronically analyzed, and acted upon by the Service Policy Engine through its normal scheduling algorithm as described below.
-
FIG. 8 illustrates theApplication Specific Module 402. The Application Specific module runs close to the Application 300 (as described above), and interacts with the Application and its operating environment to gather metadata and to query and control the Application as required for data management operations. - The Application Specific Module interacts with various components of the application and its operating environment including Application Service Processes and
Daemons 801, Application Configuration Data 802, Operating System Storage Services 803 (such as VSS and VDS on Windows), Logical Volume Management andFilesystem Services 804, and Operating System Drivers andModules 805. - The Application Specific Module performs these operations in response to control commands from the
Service Policy Engine 406. There are two purposes for these interactions with the application: Metadata Collection and Application Consistency. - Metadata Collection is the process by which the Application Specific Module collects metadata about the application. In some embodiments, metadata includes information such as: configuration parameters for the application; state and status of the application; control files and startup/shutdown scripts for the application; location of the datafiles, journal and transaction logs for the application; and symbolic links, filesystem mount points, logical volume names, and other such entities that can affect the access to application data.
- Metadata is collected and saved along with application data and SLA information. This guarantees that each copy of application data within the system is self contained and includes all of the details required to rebuild the application data.
- Application Consistency is the set of actions that ensure that when a copy of the application data is created, the copy is valid, and can be restored into a valid instance of the application. This is critical when the business requirements dictate that the application be protected while it is live, in its online, operational state. The application may have interdependent data relations within its data stores, and if these are not copied in a consistent state will not provide a valid restorable image.
- The exact process of achieving application consistency varies from application to application. Some applications have a simple flush command that forces cached data to disk. Some applications support a hot backup mode where the application ensures that its operations are journalled in a manner that guarantees consistency even as application data is changing. Some applications require interactions with operating system storage services such as VSS and VDS to ensure consistency. The Application Specific Module is purpose-built to work with a particular application and to ensure the consistency of that application. The Application Specific Module interacts with the underlying storage virtualization device and the Object Manager to provide consistent snapshots of application data.
- For efficiency, the preferred embodiment of the
Application Specific Module 402 is to run on the same server asApplication 300. This assures the minimum latency in the interactions with the application, and provides access to storage services and filesystems on the application host. The application host is typically considered primary storage, which is then snapshotted to a performance-optimized store. - In order to minimize interruption of a running application, including minimizing preparatory steps, the Application Specific Module is only triggered to make a snapshot when access to application data is required at a specific time, and when a snapshot for that time does not exist elsewhere in the system, as tracked by the Object Manager. By tracking which times snapshots have been made, the Object Manager is able to fulfill subsequent data requests from the performance-optimized data store, including for satisfying multiple requests for backup and replication which may issue from secondary, capacity-optimized pools. The Object Manager may be able to provide object handles to the snapshot in the performance-optimized store, and may direct the performance-optimized store in a native format that is specific to the format of the snapshot, which is dependent on the underlying storage appliance. In some embodiments this format may be application data combined with one or more LUN bitmaps indicating which blocks have changed; in other embodiments it may be specific extents. The format used for data transfer is thus able to transfer only a delta or difference between two snapshots using bitmaps or extents.
- Metadata, such as the version number of the application, may also be stored for each application along with the snapshot. When a SLA policy is executed, application metadata is read and used for the policy. This metadata is stored along with the data objects. For each SLA, application metadata will only be read once during the lightweight snapshot operation, and preparatory operations which occur at that time such as flushing caches will only be performed once during the lightweight snapshot operation, even though this copy of application data along with its metadata may be used for multiple data management functions.
-
FIG. 9 illustrates theService Policy Engine 406. The Service Policy Engine contains theService Policy Scheduler 902, which examines all of the Service Level Agreements configured by the user and makes scheduling decisions to satisfy Service Level Agreements. It relies on several data stores to capture information and persist it over time, including, in some embodiments, aSLA Store 904, where configured Service Level Agreements are persisted and updated; aResource Profile Store 906, storing Resource Profiles that provide a mapping between logical storage pool names and actual storage pools;Protection Catalog Store 908, where information is cataloged about previous successful copies created in various pools that have not yet expired; andcentralized History Store 910. -
History Store 910 is where historical information about past activities is saved for the use of all data management applications, including the timestamp, order and hierarchy of previous copies of each application into various storage pools. For example, a snapshot copy from a primary data store to a capacity-optimized data store that is initiated at 1 P.M. and is scheduled to expire at 9 P.M. will be recorded inHistory Store 910 in a temporal data store that also includes linked object data for snapshots for the same source and target that have taken place at 11 A.M. and 12 P.M. - These stores are managed by the Service Policy Engine. For example, when the user, through the Management workstation creates a Service Level Agreement, or modifies one of the policies within it, it is the Service Policy Engine that persists this new SLA in its store, and reacts to this modification by scheduling copies as dictated by the SLA. Similarly, when the Service Policy Engine successfully completes a data movement job that results in a new copy of an application in a Storage Pool, the Storage Policy Engine updates the History Store, so that this copy will be factored into future decisions.
- The preferred embodiment of the various stores used by the Service Policy Engine is in the form of tables in a relational database management system in close proximity to the Service Policy Engine. This ensures consistent transactional semantics when querying and updating the stores, and allows for flexibility in retrieving interdependent data.
- The scheduling algorithm for the
Service Policy Scheduler 902 is illustrated inFIG. 10 . When the Service Policy Scheduler decides it needs to make a copy of application data from one storage pool to another, it initiates a Data Movement Requestor and Monitor task, 912. These tasks are not recurring tasks and terminate when they are completed. Depending on the way that Service Level Policies are specified, a plurality of these requestors might be operational at the same time. - The Service Policy Scheduler considers the priorities of Service Level Agreements when determining which additional tasks to undertake. For example, if one Service Level Agreement has a high priority because it specifies the protection for a mission-critical application, whereas another SLA has a lower priority because it specifies the protection for a test database, then the Service Policy Engine may choose to run only the protection for the mission-critical application, and may postpone or even entirely skip the protection for the lower priority application. This is accomplished by the Service Policy Engine scheduling a higher priority SLA ahead of a lower priority SLA. In the preferred embodiment, in such a situation, for auditing purposes, the Service Policy Engine will also trigger a notification event to the management workstation.
-
FIG. 10 illustrates the flowchart of the Policy Schedule Engine. The Policy Schedule Engine continuously cycles through all the SLAs defined. When it gets to the end of all of the SLAs, it sleeps for a short while, e.g. 10 seconds, and resumes looking through the SLAs again. Each SLA encapsulates the complete data protection business requirements for one application; thus all of the SLAs represent all of the applications. - For each SLA, the schedule engine collects together all of the Service Level Policies that have the same source pool and
destination pool 1004 the process state at 1000 and iterates to the next SLA in the set of SLAs in 1002. Taken together, this subset of the Service Level Policies represent all of the requirements for a copy from that source storage pool to that particular destination storage pool. - Among this subset of Service Level Policies, the Service Policy Scheduler discards the policies that are not applicable to today, or are outside their hours of operation. Among the policies that are left, find the policy that has the
shortest frequency 1006, and based on the history data and inhistory store 910, the one with the longest retention that needs to be run next 1008. - Next, there are a series of checks 1010-1014 which rule out making a new copy of application data at this time—because the new copy is not yet due, because a copy is already in progress or because there is not new data to copy. If any of these conditions apply, the Service Policy Scheduler moves to the next combination of source and destination pools 1004. If none of these conditions apply, a new copy is initiated. The copy is executed as specified in the corresponding service level policy within this
SLA 1016. - Next, the Scheduler moves to the next Source and Destination pool combination for the same
Service Level agreement 1018. If there are no more distinct combinations, the Scheduler moves on to the nextService Level Agreement 1020. - After the Service Policy Scheduler has been through all source/destination pool combinations of all Service Level Agreements, it pauses for a short period and then resumes the cycle.
- A simple example system with a snapshot store and a backup store, with only 2 policies defined, would interact with the Service Policy Scheduler as follows. Given two policies, one stating “backup every hour, the backup to be kept for 4 hours” and another stating “backup every 2 hours, the backup to be kept for 8 hours,” the result would be a single snapshot taken each hour, the snapshots each being copied to the backup store but retained a different amount of time at both the snapshot store and the backup store. The “backup every 2 hours” policy is scheduled to go into effect at 12:00 P.M by the system administrator.
- At 4:00 P.M., when the Service Policy Scheduler begins operating at
step 1000, it finds the two policies atstep 1002. (Both policies apply because a multiple of two hours has elapsed since 12:00 P.M.) There is only one source and destination pool combination atstep 1004. There are two frequencies atstep 1006, and the system selects the 1-hour frequency because it is shorter than the 2-hour frequency. There are two operations with different retentions atstep 1008, and the system selects the operation with the 8-hour retention, as it has the longer retention value. Instead of one copy being made to satisfy the 4-hour requirement and another copy being made to satisfy the 8-hour requirement, the two requirements are coalesced into the longer 8-hour requirement, and are satisfied by a single snapshot copy operation. The system determines that a copy is due atstep 1010, and checks the relevant objects at theHistory Store 910 to determine if the copy has already been made at the target (at step 912) and at the source (at step 914). If these checks are passed, the system initiates the copy at step 916, and in the process triggers a snapshot to be made and saved at the snapshot store. The snapshot is then copied from the snapshot store to the backup store. The system then goes tosleep 1022 and wakes up again after a short period, such as 10 seconds. The result is a copy at the backup store and a copy at the snapshot store, where every even-hour snapshot lasts for 8 hours, and every odd-hour snapshot lasts 4 hours. The even-hour snapshots at the backup store and the snapshot store are both tagged with the retention period of 8 hours, and will be automatically deleted from the system by another process at that time. - Note that there is no reason to take two snapshots or make two backup copies at 2 o'clock, even though both policies apply, because both policies are satisfied by a single copy. Combining and coalescing these snapshots results in the reduction of unneeded operations, while retaining the flexibility of multiple separate policies. As well, it may be helpful to have two policies active at the same time for the same target with different retention. In the example given, there are more hourly copies kept than two-hour copies, resulting in more granularity for restore at times that are closer to the present. For example, in the previous system, if at 7:30 P.M. damage is discovered from earlier in the afternoon, a backup will be available for every hour for the past four hours: 4, 5, 6, 7 P.M. As well, two more backups will have been retained from 2 P.M. and 12 P.M.
-
FIG. 11 is a block diagram of the modules implementing the content addressable store for theContent Addressable Provider 510. - The content
addressable store 510 implementation provides a storage resource pool that is optimized for capacity rather than for copy-in or copy-out speed, as would be the case for the performance-optimized pool implemented through snapshots, described earlier, and thus is typically used for offline backup, replication and remote backup. Content addressable storage provides a way of storing common subsets of different objects only once, where those common subsets may be of varying sizes but typically as small as 4 KiBytes. The storage overhead of a content addressable store is low compared to a snapshot store, though the access time is usually higher. Generally objects in a content addressable store have no intrinsic relationship to one another, even though they may share a large percentage of their content, though in this implementation a history relationship is also maintained, which is an enabler of various optimizations to be described. This contrasts with a snapshot store where snapshots intrinsically form a chain, each storing just deltas from a previous snapshot or baseline copy. In particular, the content addressable store will store only one copy of a data subset that is repeated multiple times within a single object, whereas a snapshot-based store will store at least one full-copy of any object. - The content
addressable store 510 is a software module that executes on the same system as the pool manager, either in the same process or in a separate process communicating via a local transport such as TCP. In this embodiment, the content addressable store module runs in a separate process so as to minimize impact of software failures from different components. - This module's purpose is to allow storage of Data Storage Objects 403 in a highly space-efficient manner by deduplicating content (i.e., ensuring repeated content within single or multiple data objects is stored only once).
- The content addressable store module provides services to the pool manager via a programmatic API. These services comprise the following:
- Object to Handle mapping 1102: an object can be created by writing data into the store via an API; once the data is written completely the API returns an object handle determined by the content of the object. Conversely, data may be read as a stream of bytes from an offset within an object by providing the handle. Details of how the handle is constructed are explained in connection with the description of
FIG. 12 . -
Temporal Tree Management 1104 tracks parent/child relationships between data objects stored. When a data object is written into thestore 510, an API allows it to be linked as a child to a parent object already in the store. This indicates to the content addressable store that the child object is a modification of the parent. A single parent may have multiple children with different modifications, as might be the case for example if an application's data were saved into the store regularly for some while; then an early copy were restored and used as a new starting point for subsequent modifications. Temporal tree management operations and data models are described in more detail below. -
Difference Engine 1106 can generate a summary of difference regions between two arbitrary objects in the store. The differencing operation is invoked via an API specifying the handles of two objects to be compared, and the form of the difference summary is a sequence of callbacks with the offset and size of sequential difference sections. The difference is calculated by comparing two hashed representations of the objects in parallel. -
Garbage Collector 1108 is a service that analyzes the store to find saved data that is not referenced by any object handle, and to reclaim the storage space committed to this data. It is the nature of the content addressable store that much data is referenced by multiple object handles, i.e., the data is shared between data objects; some data will be referenced by a single object handle; but data that is referenced by no object handles (as might be the case if an object handle has been deleted from the content addressable system) can be safely overwritten by new data. -
Object Replicator 1110 is a service to duplicate data objects between two different content addressable stores. Multiple content addressable stores may be used to satisfy additional business requirements, such as offline backup or remote backup. - These services are implemented using the functional modules shown in
FIG. 11 . TheData Hash module 1112 generates fixed length keys for data chunks up to a fixed size limit. For example, in this embodiment the maximum size of chunk that the hash generator will make a key for is 64 KiB. The fixed length key is either a hash, tagged to indicate the hashing scheme used, or a non-lossy algorithmic encoding. The hashing scheme used in this embodiment is SHA-1, which generates a secure cryptographic hash with a uniform distribution and a probability of hash collision near enough zero that no facility need be incorporated into this system to detect and deal with collisions. - The
Data Handle Cache 1114 is a software module managing an in-memory database that provides ephemeral storage for data and for handle-to-data mappings. - The Persistent
Handle Management Index 1104 is a reliable persistent database of CAH-to-data mappings. In this embodiment it is implemented as a B-tree, mapping hashes from the hash generator to pages in thepersistent data store 1118 that contain the data for this hash. Since the full B-tree cannot be held in memory at one time, for efficiency, this embodiment also uses an in-memory bloom filter to avoid expensive B-tree searches for hashes known not to be present. - The Persistent
Data Storage module 1118 stores data and handles to long-term persistent storage, returning a token indicating where the data is stored. The handle/token pair is subsequently used to retrieve the data. As data is written to persistent storage, it passes through a layer oflossless data compression 1120, in this embodiment implemented using zlib, and a layer of optional reversible encryption 1122, which is not enabled in this embodiment. - For example, copying a data object into the content addressable store is an operation provided by the object/handle mapper service, since an incoming object will be stored and a handle will be returned to the requestor. The object/handle mapper reads the incoming object, requests hashes to be generated by the Data Hash Generator, stores the data to Persistent Data Storage and the handle to the Persistent Handle Management Index. The Data Handle Cache is kept updated for future quick lookups of data for the handle. Data stored to Persistent Data Storage is compressed and (optionally) encrypted before being written to disk. Typically a request to copy in a data object will also invoke the temporal tree management service to make a history record for the object, and this is also persisted via Persistent Data Storage.
- As another example, copying a data object out of the content addressable store given its handle is another operation provided by the object/handle mapper service. The handle is looked up in the Data Handle Cache to locate the corresponding data; if the data is missing in the cache the persistent index is used; once the data is located on disk, it is retrieved via persistent data storage module (which decrypts and decompresses the disk data) and then reconstituted to return to the requestor.
-
FIG. 12 shows how the handle for a content addressed object is generated. The data object manager references all content addressable objects with a content addressable handle. This handle is made up of three parts. Thefirst part 1201 is the size of the underlying data object the handle immediately points to. Thesecond part 1202 is the depth of object it points to. The third 1203 is a hash of the object it points to.Field 1203 optionally includes a tag indicating that the hash is a non-lossy encoding of the underlying data. The tag indicates the encoding scheme used, such as a form of run-length encoding (RLE) of data used as an algorithmic encoding if the data chunk can be fully represented as a short enough RLE. If the underlying data object is too large to be represented as a non-lossy encoding, a mapping from the hash to a pointer or reference to the data is stored separately in the persistenthandle management index 1104. - The data for a content addressable object is broken up into
chunks 1204. The size of each chunk must be addressable by one contentaddressable handle 1205. The data is hashed by thedata hash module 1102, and the hash of the chunk is used to make the handle. If the data of the object fits in one chunk, then the handle created is the final handle of the object. If not, then the handles themselves are grouped together intochunks 1206 and a hash is generated for each group of handles. This grouping of handles continues 1207 until there is only onehandle 1208 produced which is then the handle for the object. - When an object is to be reconstituted from a content handle (the copy-out operation for the storage resource pool), the top level content handle is dereferenced to obtain a list of next-level content handles. These are dereferenced in turn to obtain further lists of content handles until depth-0 handles are obtained. These are expanded to data, either by looking up the handle in the handle management index or cache, or (in the case of an algorithmic hash such as run-length encoding) expanding deterministically to the full content.
-
FIG. 13 illustrates the temporal tree relationship created for data objects stored within the content addressable store. This particular data structure is utilized only within the content addressable store. The temporal tree management module maintainsdata structures 1302 in the persistent store that associate each content-addressed data object to a parent (which may be null, to indicate the first in a sequence of revisions). The individual nodes of the tree contain a single hash value. This hash value references a chunk of data, if the hash is a depth-0 hash, or a list of other hashes, if the hash is a depth-1 or higher hash. The references mapped to a hash value is contained in the PersistentHandle Management Index 1104. In some embodiments the edges of the tree may have weights or lengths, which may be used in an algorithm for finding neighbors. - This is a standard tree data structure and the module supports standard manipulation operations, in particular: 1310 Add: adding a leaf below a parent, which results in a change to the tree as between
initial state 1302 and after-add state 1304; and 1312 Remove: removing a node (and reparenting its children to its parent), which results in a change to the tree as between after-add state 1304 and after-remove state 1306. - The “Add” operation is used whenever an object is copied-in to the CAS from an external pool. If the copy-in is via the Optimal Way for Data Backup, or if the object is originating in a different CAS pool, then it is required that a predecessor object be specified, and the Add operation is invoked to record this predecessor/successor relationship.
- The “Remove” operation is invoked by the object manager when the policy manager determines that an object's retention period has expired. This may lead to data stored in the CAS having no object in the temporal tree referring to it, and therefore a subsequent garbage collection pass can free up the storage space for that data as available for re-use.
- Note that it is possible for a single predecessor to have multiple successors or child nodes. For example, this may occur if an object is originally created at time T1 and modified at time T2, the modifications are rolled back via a restore operation, and subsequent modifications are made at time T3. In this example, state T1 has two children, state T2 and state T3.
- Different CAS pools may be used to accomplish different business objectives such as providing disaster recovery in a remote location. When copying from one CAS to another CAS, the copy may be sent as hashes and offsets, to take advantage of the native deduplication capabilities of the target CAS. The underlying data pointed to by any new hashes is also sent on an as-needed basis.
- The temporal tree structure is read or navigated as part of the implementation of various services:
-
- Garbage Collection navigates the tree in order to reduce the cost of the “mark” phase, as described below
- Replication to a different CAS pool finds a set of near-neighbors in the temporal tree that are also known to have been transferred already to the other CAS pool, so that only a small set of differences need to be transferred additionally
- Optimal-Way for data restore uses the temporal tree to find a predecessor that can be used as a basis for the restore operation. In the CAS temporal tree data structure, children are subsequent versions, e.g., as dictated by archive policy. Multiple children are supported on the same parent node; this case may arise when a parent node is changed, then used as the basis for a restore, and subsequently changed again.
- The
CAS difference engine 1106 compares two objects identified by hash values or handles as inFIGS. 11 and 12 , and produces a sequence of offsets and extents within the objects where the object data is known to differ. This sequence is achieved by traversing the two object trees in parallel in the hash data structure ofFIG. 12 . The tree traversal is a standard depth- or breadth-first traversal. During traversal, the hashes at the current depth are compared. Where the hash of a node is identical between both sides, there is no need to descend the tree further, so the traversal may be pruned. If the hash of a node is not identical, the traversal continues descending into the next lowest level of the tree. If the traversal reaches a depth-0 hash that is not identical to its counterpart, then the absolute offset into the data object being compared where the non-identical data occurs, together with the data length, is emitted into the output sequence. If one object is smaller in size than another, then its traversal will complete earlier, and all subsequent offsets encountered in the traversal of the other are emitted as differences. - As described under
FIG. 11 , Garbage Collector is a service that analyzes a particular CAS store to find saved data that is not referenced by any object handle in the CAS store temporal data structure, and to reclaim the storage space committed to this data. Garbage collection uses a standard “Mark and Sweep” approach. Since the “mark” phase may be quite expensive, the algorithm used for the mark phase attempts to minimize marking the same data multiple times, even though it may be referenced many times; however the mark phase must be complete, ensuring that no referenced data is left unmarked, as this would result in data loss from the store as, after a sweep phase, unmarked data would later be overwritten by new data. - The algorithm employed for marking referenced data uses the fact that objects in the CAS are arranged in graphs with temporal relationships using the data structure depicted in
FIG. 13 . It is likely that objects that share an edge in these graphs differ in only a small subset of their data, and it is also rare that any new data chunk that appears when an object is created from a predecessor should appear again between any two other objects. Thus, the mark phase of garbage collection processes each connected component of the temporal graph. -
FIG. 14 is an example of garbage collection using temporal relationships in certain embodiments. A depth-first search is made, represented byarrows 1402, of a data structure containing temporal relationships. Take astarting node 1404 from which to begin the tree traversal.Node 1404 is the tree root and references no objects.Node 1406 contains references to objects H1 and H2, denoting a hash value forobject 1 and a hash value forobject 2. All depth-0, depth-1 and higher data objects that are referenced bynode 1406, here H1 and H2, are enumerated and marked as referenced. - Next,
node 1408 is processed. As it shares an edge withnode 1406, which has been marked, the difference engine is applied to the difference between the object referenced by 1406 and the object referenced by 1408, obtaining a set of depth-0, depth-1 and higher hashes that exist in the unmarked object but not in the marked object. In the figure, the hash that exists innode 1408 but not innode 1406 is H3, so H3 is marked as referenced. This procedure is continued until all edges are exhausted. - A comparison of the results produced by a
prior art algorithm 1418 and the present embodiment 1420 shows that whennode 1408 is processed by the prior art algorithm, previously-seen hashes H1 and H2 are emitted into the output stream along with new hash H3. Present embodiment 1420 does not emit previously seen hashes into the output stream, resulting in only new hashes H3, H4, H5, H6, H7 being emitted into the output stream, with a corresponding improvement in performance. Note that this method does not guarantee that data will not be marked more than once. For example, if hash value H4 occurs independently innode 1416, it will be independently marked a second time. - Copy an Object into the CAS
- Copying an object from another pool into the CAS uses the software modules described in
FIG. 11 to produce a data structure referenced by an object handle as inFIG. 12 . The input to the process is (a) a sequence of chunks of data at specified offsets, sized appropriately for making depth-0 handles, and optionally (b) a previous version of the same object. Implicitly, the new object will be identical to the previous version except where the input data is provided and itself differs from the previous version. The algorithm for the copy-in operation is illustrated in a flowchart atFIG. 15 . - If a previous version (b) is provided, then the sequence (a) may be a sparse set of changes from (b). In the case that the object to be copied and is known to differ from a previous object at only a few points, this can greatly reduce the amount of data that needs to be copied in, and therefore reduce the computation and i/o activity required. This is the case, for example, when the object is to be copied in via the optimal way for data backup described previously.
- Even if the sequence (a) includes sections that are largely unchanged from a predecessor, identifying the predecessor (b) allows the copy-in procedure to do quick checks as to whether the data has indeed changed and therefore to avoid data duplication at a finer level of granularity than might be possible for the difference engine in some other storage pool providing input to a CAS.
- Implicitly then, the new object will be identical to the previous version except where the input data is provided and itself differs from the previous version. The algorithm for the copy-in operation is illustrated in a flowchart at
FIG. 15 . - The process starts at step 1500 as an arbitrarily-sized data object in the temporal store is provided, and proceeds to 1502, which enumerates any and all hashes (depth-0 through the highest level) referenced by the hash value in the predecessor object, if such is provided. This will be used as a quick check to avoid storing data that is already contained in the predecessor.
- At
step 1504, if a predecessor is input, create a reference to a clone of it in the content-addressable data store temporal data structure. This clone will be updated to become the new object. Thus the new object will become a copy of the predecessor modified by the differences copied into the CAS from the copying source pool. - At
steps Data Mover 502 pushes the data into the CAS. The data is accompanied by an object reference and an offset, which is the target location for the data. The data may be sparse, as only the differences from the predecessor need to be moved into the new object. At this point the incoming data is broken into depth-0 chunks sized small enough that each can be represented by a single depth-0 hash. - At
step 1510, the data hash module generates a hash for each depth-0 chunk. - At
step 1512, read the predecessor hash at the same offset. If the hash of the data matches the hash of the predecessor at the same offset, then no data needs to be stored and the depth-1 and higher objects do not need to be updated for this depth-0 chunk. In this case, return to accept the next depth-0 chunk of data. This achieves temporal deduplication without having to do expensive global lookups. Even though the source system is ideally sending only the differences from the data that has previously been stored in the CAS, this check may be necessary if the source system is performing differencing at a different level of granularity, or if the data is marked as changed but has been changed back to its previously-stored value. Differencing may be performed at a different level of granularity if, for example, the source system is a snapshot pool which creates deltas on a 32 KiB boundary and the CAS store creates hashes on 4 KiB chunks. - If a match is not found, the data may be hashed and stored. Data is written starting at the provided offset and ending once the new data has been exhausted. Once the data has been stored, at
step 1516, if the offset is still contained within the same depth-1 object, then depth-1, depth-2 and allhigher objects 1518 are updated, generating new hashes at each level, and the depth-0, depth-1 and all higher objects are stored atstep 1514 to a local cache. - However, at
step 1520, if the amount of data to be stored exceeds the depth-1 chunk size and the offset is to be contained in a new depth-1 object, the current depth-1 must be flushed to the store, unless it is determined to be stored there already. First look it up in theglobal index 1116. If it is found there, remove the depth-1 and all associated depth-0 objects from the local cache and proceed with thenew chunk 1522. - At
step 1524, as a quick check to avoid visiting the global index, for each depth-0, depth-1 and higher object in the local cache, lookup its hash in the local store established in 1502. Discard any that match. - At
step 1526, for each depth-0, depth-1 and higher object in the local cache, lookup its hash in theglobal index 1116. Discard any that match. This ensures that data is deduplicated globally. - At step 1528: store all remaining content from the local cache into the persistent store, then continue to process the new chunk.
- Reading an object out of the CAS is a simpler process and is common across many implementations of CAS. The handle for the object is mapped to a persistent data object via the global index, and the offset required is read from within this persistent data. In some cases it may be necessary to recurse through several depths in the object handle tree.
- As described under
FIG. 11 , theReplicator 1110 is a service to duplicate data objects between two different content addressable stores. The process of replication could be achieved through reading out of one store and writing back into another, but this architecture allows more efficient replication over a limited bandwidth connection such as a local- or wide-area network. - A replicating system operating on each CAS store uses the difference engine service described above together with the temporal relationship structure as described in
FIG. 13 , and additionally stores on a per-object basis in the temporal data structure used by the CAS store a record of what remote store the object has been replicated to. This provides definitive knowledge of object presence at a certain data store. - Using the temporal data structure, it is possible for the system to determine which objects exist on which data stores. This information is leveraged by the Data Mover and Difference Engine to determine a minimal subset of data to be sent over the network during a copy operation to bring a target data store up to date. For example, if data object 0 has been copied at time T3 from a server in Boston to a remote server in Seattle,
Protection Catalog Store 908 will store thatobject 0 at time T3 exists both in Boston and Seattle. At time T5, during a subsequent copy from Boston to Seattle, the temporal data structure will be consulted to determine the previous state ofobject 0 in Seattle that should be used for differencing on the source server in Boston. The Boston server will then take the difference of T5 and T3, and send that difference to the Seattle server. - The process to replicate an object A is then as follows: Identify an object A0 that is recorded as having already been replicated to the target store and a near neighbor of A in the local store. If no such object A0 exists then send A to the remote store and record it locally as having been sent. To send a local object to the remote store, a typical method as embodied here is: send all the hashes and offsets of data chunks within the object; query the remote store as to which hashes represent data that is not present remotely; send the required data to the remote store (sending the data and hashes is implemented in this embodiment by encapsulating them in a TCP data stream).
- Conversely, if A0 is identified, then run the difference engine to identify data chunks that are in A but not in A0. This should be a superset of the data that needs to be sent to the remote store. Send hashes and offsets for chunks that are in A but not in A0. Query the remote store as to which hashes represent data that is not present remotely; send the required data to the remote store.
-
FIG. 16 shows the software and hardware components that comprise one embodiment of the Data Management Virtualization (DMV) system. The software that comprises the system executes as three distributed components: - The
Host Agent software same servers - The
DMV server software Linux servers - The system is controlled by
Management Client software 1606 that runs on a desktop orlaptop computer 1620. - These software components communicate with one another via network connections over an
IP network 1608. Data Management Virtualization systems communicate with one another betweenprimary site 1622 and data replication (DR)site 1624 over an IP network such as a public internet backbone. - The DMV systems at primary and DR sites access one or more
SAN storage systems channel network 1626. The servers running primary applications access the storage virtualized by the DMV systems access the storage via fibre-channel over the fibre-channel network, or iSCSI over the IP network. The DMV system at the remote DR site runs a parallel instance ofDMV server software 1604 c onLinux server 1628.Linux server 1628 may also be an Amazon Web Services EC2 instance or other similar cloud computational resource. -
FIG. 17 shows components of a system including a Virtual Copy Data Management Appliance, according to some embodiments of the present disclosure. Instead of deploying physical appliances at client sites, virtual copy data management appliances (VCDMA, or also referred to herein as “virtual backup appliance” or “virtual appliance”) 1702 a 1702 b can be deployed to implement data management functions. The virtual appliance provides a platform neutral implementation of the copy data virtualization capabilities by abstracting the hardware layer with a number of software components. VCDMA functions include application data protection, data restore, data deduplication and remote replication. As opposed toFIG. 16 , VCDMA can be a software only solution that is lightweight and can be deployed inside a hypervisor. When there are no hardware components, there is no need for additional infrastructure like power and cooling to deploy a VCDMA. VCDMA can be deployed in ahypervisor 1704 a 1704 b. As explained in more detail below, protected applications can run onphysical hosts 1610 a 1610b 1610 c or on virtual machines within ahypervisor 1704 a 1704 b. - In some embodiments, a snapshot can be generated by servers running protected applications either on physical hosts or virtual machines. The servers can contain a performance optimized pool with snapshot capability. For example, the server can be a VMWare ESX server, or other type of virtual machine. A snapshot generated by the virtualization server can include snapshots of each of the virtual machines sitting on the server. When a snapshot exists on the server, the
VCDMA 1702 a 1702 b can receive the snapshot generated by the server. -
FIGS. 18 a-c are diagrams illustrating 3 deployments of a copy data management system, based on platform optimized storage virtualization layers, according to some embodiments of the present disclosure.FIG. 18 a shows copydata virtualization software 1801,storage virtualization layer 1802 a, andstorage 1803 1804 1805 provided by a cloud infrastructure provider sitting in ahypervisor 1830 also provided by a cloud infrastructure provider.FIG. 18 b shows the same copydata virtualization software 1801 running inside a data center in aVMWare hypervisor environment 1840. Thestorage virtualization layer 1802 b in this environment configures one or more storage parameters according to the storage provided by VMWare—Hypervisor 1813 1814 1815.FIG. 18 c shows the same copydata virtualization software 1801 running in a more traditional hardware setting without a hypervisor. Thesoftware 1801 andstorage virtualization layer 1802 c adapt to the fact that they are running on real hardware, withphysical disks 1823 1824 1825, to provide predictable performance. -
Copy virtualization software 1801 includes an ability to discover applications inside virtual machines and hosts and to protect the applications using Service Level Agreements (SLAs). The SLAs define how long the application is retained and how often it is pushed into the deduplication pool and when it is to replicate out to a remote physical and virtual appliance. In some embodiments,copy virtualization software 1801 functions similarly to the data management virtualization engine as described, for example, inFIGS. 3-5 above. The similarity lies in the type of capability provided to perform the above mentioned functions and the ability for an end-user to leverage this capability in a software only model. The details of the virtualization software functions are described in more detail above. - As seen in
FIGS. 18 a-c the storage virtualization layer 1802 a-c enables the deployment of the virtual copy data management appliance in a variety of environments.FIG. 18 a shows the implementation on cloud storage infrastructure. Thestorage virtualization layer 1802 a is optimized to work with the infrastructure provided by the cloud service provider. Thevirtualization layer 1802 a tunes itself to work with the unique characteristics of thecloud storage type 1803 1804 1805. Thestorage virtualization layer 1802 c can also work withphysical disks 1823 1824 1825. Thevirtualization layer 1802 c detects that it is dealing with raw disks and optimizes itself to work with this configuration. The optimization and tuning relates to disk latency and throughput. Disk latency and throughput are two of the biggest variables in a storage system that affect the overall throughput of the system. The storage virtualization layer 1802 a-c has been designed to adapt to this variablity and extract maximum performance out of the storage. As opposed to the storage virtualization layer, the physical appliance does not require a storage virtualization software as it is designed to work with the storage provided in the box. The hardware is optimized to perform with one type of storage. - In some embodiments, the storage virtualization layer can measure throughput and latency for read operate operations that pass through the layer. The storage virtualization layer can write large chunks of sequential blocks optimized for any environment. For example, if there are a lot of small random writes, the storage virtualization layer aggregates the random writes into a log file and then plays out the log file sequentially. This can help to reduce I/O latency and also increase the throughput of the entire platform. The storage virtualization layer's performance can be further accelerated by provisioning Solid State Devices (SSDs). SSDs can provide extremely high throughput and low latency access to underlying storage. Augmenting the storage virtualization layer with SSDs can further improve performance. In at least the ways described above, the virtualization layer can help the overall VCDMA run with a predictable performance.
- In some embodiments, storage virtualization layer 1802 a-b also has to account for variations in hypervisors (e.g., 1830 and 1840). Hypervisors 1830 1840 virtualize hardware CPU, Disk and memory and each hypervisor can do this in a unique way. Copy
data virtualization software 1801 and the storage virtualization 1802 a-b together have been optimized to perform in thesediverse hypervisors 1830 1840. Thehypervisors 1830 1840 provide abstract concepts for CPU and Memory and this hides the actual hardware that provides these resources. CopyData Virtualization Software 1801 is highly sensitive to CPU and memory changes in the environment. This software has been tuned to adapt to the amount of CPU and memory available at any given point in time. This helps to keep the performance predictable at all times. - Storage virtualization layer 1802 a-c can aggregate storage volumes from a hypervisor and presents them as disks to copy data virtualization software. In some embodiments, a combined file system and logical volume manager can be used for storage virtualization (e.g., ZFS). ZFS is a combined file system and logical volume manager designed by Sun Microsystems. The features of ZFS include protection against data corruption, support for high storage capacities, efficient data compression, integration of the concepts of filesystem and volume management, snapshots and copy-on-write clones, continuous integrity checking and automatic repair, RAID-Z and native NFSv4 ACLs. Zpools (ZFS Pools) can be created over individual storage volumes presented to the virtual machine. ZFS snapshots can also be used for capturing data and presenting mounts back to a host. Unlike traditional file systems which reside on single devices and thus require a volume manager to use more than one device, ZFS filesystems are built on top of virtual storage pools called zpools. A zpool is constructed of virtual devices (vdevs), which are themselves constructed of block devices files, hard drive partitions, or entire drives, with the latter being the recommended usage. Block devices within a vdev may be configured in different ways, depending on needs and space available: non-redundantly (similar to RAID 0), as a mirror (RAID 1) of two or more devices, as a RAID-Z group of three or more devices, or as a RAID-Z2 (similar to RAID-6) group of four or more devices. Thus, a zpool (ZFS storage pool) is vaguely similar to a computer's RAM. The total RAM pool capacity depends on the number of RAM memory sticks and the size of each stick. Likewise, a zpool includes one or more vdevs. Each vdev can be viewed as a group of hard disks (or partitions, or files, etc.). ZFS also provides knobs that can be altered based on the environment. It also provides capabilities to adapt to the storage environment it is living in. The storage virtualization layer which embeds ZFS in it can use these knobs to tune the platform for optimal performance. For instance the storage virtualization layer can provide capability to provision Solid State Devices for accelerating I/O to the disk. Solid State Devices provide low latency high speed access to data which augments the performance of the Copy Data Virtualization Software. The platform also enforces a lot of reliability irrespective of the reliability metrics of the underlying storage. ZFS guarantees transactions to disk and also ensures that data is written with the correct atomicity to ensure application consistency. In cloud environments ZFS provides the capability to add storage and grow as you go. This alleviates the need for dedicating large volume of storage upfront. This capability helps with efficient data management and also helps cloud service providers allocate resources in a predictable fashion. A cloud service provider can now provision storage based on storage rather than pre-allocating a large block which causes a lot of un-used and thus wasted storage.
- Storage can include a plurality of
storage volumes 1803 1804 1805 1813 1814 1815 1823 1824 1825. The storage volumes can be presented to the virtual machine. These individual volumes can be aggregated into a zpool. The aggregation can be done to effectively manage a pool of disks as a single logical storage entity. Zpool as described above, enables this capability in an efficient and reliable fashion. As described in more detail below, storage can include many of the same storage pools as in a hardware appliance. 1803 1804 1805 1813 1814 1815 1823 1824 1825 all are individual storage devices or virtual devices as described above. - In some embodiments, a virtual appliance with a hardware abstraction layer infrastructure can be deployed in a number of private and public cloud environments. The underlying hardware is abstracted by the hypervisor and the virtual appliance is built to run on this hypervisor. The hardware abstraction is also built into the platform of the virtual appliance and the platform that comprises of ZFS aggregated disks presented by the hypervisor in a single logical volume. With this capability the virtual appliance can run on any hypervisor infrastructure. The ZFS platform being embedded inside the appliance enables this capability thus making it infrastructure agnostic. As described in more detail below, this capability enables this virtual appliance to be created to hold very small (1 TB) to very large (50 TB) of data. This capability also enables deployment in a variety of environments from small remote offices to large data centers and everything in between. This also enables a variety of deployment scenarios where a number of smaller sized virtual appliances can replicate into a medium sized virtual appliance and a number of medium sized appliances can replicate into a larger appliance. Each layer of replication offers additional incremental deduplication thereby the data is in the most optimal form when it reaches the large virtual appliance in a data center. A virtual appliance also allows for asynchronous data replication for providing a remote copy of data. The remote replication can be provided with reduced bandwidth requirements by copying deduplicated differences in business data from a local storage site to a remote, backup storage site.
-
FIG. 19 shows virtual storage resources in a Virtual Copy Data Management Appliance, according to some embodiments of the present disclosure.FIG. 19 shows a pool manager and pools showing a sample physical separation of virtual pools and storage resources, according to different pool types. - For example in some embodiments, the
primary pool 507 consists of local storage on ahost virtualization server 1910, the performance optimizedpool 508 consists of a set of virtual snapshots on the same physical storage, managed by the virtualization server, and the capacity optimizedpool 509 consists of a deduplicating content addressable store on a physicallyseparate device 1920. In some embodiments, a pool manager can reside in an external virtual machine. In some embodiments, the pool manager can reside in a data virtual backup appliance. The information stored in a pool manager can include data that is deduplicated across all machines. For example, the pool allows for data from one machine to be deduplicated against data from a different virtual machine, which can result in a further reduction in data storage. A description of how a pool manager and pools interact with other modules in a data management virtualization system is described above, for example, inFIG. 5 . - Referring back to
FIG. 5 ,virtual storage resources 510 can include virtual storage pools 418. The pool can includeprimary pool 507, performance optimizedpool 508 and capacity optimizedpool 509. In a Virtual Copy Data Management Appliance, storage pools can be hosted on avirtualization server 1910. The storage pools for the VCDMA are provisioned from customer's existing infrastructure. There is no need to purchase any specific type of storage for this appliance. A hardware appliance has a smaller compatibility matrix for the storage that can be used while VCDMA works with any and all storage supported by the hypervisor. - In some embodiments of this invention, such as where the architecture is as described in
FIG. 17 , and the pools laid out inFIG. 19 , there can be a storage snapshot operation (e.g., as described above) that is a native operation on the virtualization server. The representation of differences between this snapshot and a previous snapshot can be an extent list (e.g., as described above), and so the set of operations described above for efficient backup and restore can be applied equally to this embodiment. -
FIG. 20 shows a virtual backup appliance system, according to some embodiments of the present disclosure. In some embodiments, a virtual backup appliance system can be useful for remote office locations for an enterprise or for service providers whose end-user customers have less than 15 terabytes of total data to be protected. Deploying a physical machine for these scenarios can become untenable from a cost and operations perspective. A virtual appliance running on the end-user's existing hardware requires no extra provisioning or other types of requirements (e.g., plug and play installation) and can provide similar capabilities as a physical appliance. - Virtual backup appliance system 2000 comprises
virtual machines 2001, hosts 2002, ahypervisor 1704 and at least onebackup appliance 1702 2030. Avirtual backup appliance 1702 can sit inside a hypervisor 1704 (e.g., vCenter), running on a host 2002 (e.g., an ESX host), protectingvirtual machines 2001 and replicating that data to another virtual appliance or to aphysical cluster 2030. - In some embodiments, there can be two hosts 2002 (e.g., ESX Hosts) that are running
virtual machines 2001. The virtual machines can include avirtual backup appliance 1702. In some embodiments, the hosts can be physical servers. - In some embodiments, the
virtual machines 2001 can comprise of virtual instances of Windows, Linux or other servers that run Exchange, SQL or other end-user applications. -
Backup appliance 1702, which can also be a virtual machine, can protect 2040 applications and data on end-uservirtual machines 2001 or applications and data onphysical hosts 2060. End-uservirtual machines 2001 being protected can either be on the same host (e.g., ESX host) or on a different host. - In some embodiments, a
virtual backup appliance 1702 can replicate 2050 a de-duplicated form of end-user data to a another virtual or physical backup appliance 2030 (e.g., a physical content data storage cluster), such as the data management virtualization system described above. Thereplication 2050 can be done to create an off-site copy that can then be used in disaster recovery scenarios. In some embodiments, the virtual appliance can back up to a data center with storage of 30 to 50 terabytes. -
FIG. 21 shows a flowchart illustrating backup using a virtual backup appliance, according to some embodiments of the present disclosure. Atstep 2101, virtual backup appliance running inside a hypervisor can discover virtual machines and physical hosts on the network. At step 2102, configure SLAs on the virtual appliance to protect discovered virtual and physical machine. Atstep 2103, Physical Hosts and Virtual Machines inside a vCenter are protected to one or more backup appliances based on SLAs. At step 2104, deduplicated data residing on virtual backup appliances are then replicated to the central Physical CDS or to a larger virtual backup appliance. - Referring to step 2101, discovering virtual machines and physical hosts on the network includes specifying IP address and user credentials for the physical host and Virtual Administrator console credential for the virtual machines.
- Referring to step 2102, configuring SLAs on the virtual appliance includes receiving backup parameters from a service provider. Backup parameters can include the schedule—the window when it is allowed to run, how often to keep a backup and how to move it between the various pools. As explained in more detail above, SLA describes the data protection characteristics for each stage of the data lifecycle. Each application may have a different SLA.
- Referring to step 2103, protecting a physical host based on an SLA includes backing up data based on backup parameters associated with an SLA. For example, an SLA can specify backing up the data twice a day and moving it to deduplication pool once a day and then replicating it to the remote pool once a day.
- Referring to step 2104, deduplicating data on the virtual backup appliance includes identifying and storing only the unique data blocks for the data that is being de-duplicated. Replicating data includes identifying the changes in the deduplicated image between the local deduplication pool and remote deduplication pool and only replicating these changes. Replication is thus very efficient on the network.
-
FIG. 22 shows a cascading deduplication system with virtual backup appliances, according to some embodiments of the present disclosure. - In some embodiments, a cascading deduplication can be used to protect data on end user appliances. Data Protection creates a backup copy of an end-user's production data. This backup copy is used when the production data is corrupted or destroyed in the event of a disaster or system malfunction.
- In some embodiments, a hierarchy of virtual appliances can achieve a cascading deduplication. The hierarchy can comprise of
end user appliances 2203, individualvirtual appliances 2202 a 2202b 2202 c, an aggregateddeduplication device 2201, and acentral appliance 2200. In some embodiments, multiple aggregated deduplication devices can provide data to a central appliance (e.g., 2204). -
FIG. 23 shows a flowchart illustrating cascading deduplication with virtual backup appliances, according to some embodiments of the present disclosure. Atstep 2301, virtual backup appliances at the leaf layer aggregate data from the hosts and applications they are protecting and deduplicate the aggregated data. Atstep 2302, aggregator appliances at the next level receive data from the appliances at the leaf layer and further de-duplicate that data. Atstep 2303, central data center receives data from aggregator appliances and performs deduplication on that data set. - Referring to step 2301, a cascading deduplication can start with
virtual appliances 2202 receiving end-user data from the end user appliances. End user data can include end-user applications (e.g., virtual machines, Oracle, Windows machines, Linux machines, Exchange, etc.). In some embodiments, the end-user data received by the virtual appliances comprises only data that was changed since the last replication. For example, when protecting an end-user's virtual environment the virtual appliance only receives the changes from a recent snapshot. This minimizes the amount of data transferred over the network. The virtual appliance de-duplicates the incoming data that further reduces the data footprint. The virtual appliance then replicates the de-duplicated data to an aggregator appliance further up in the hierarchy. Replication only moves changed data and moves it in the de-duplicated form. - In some embodiments, the next step can include the virtual appliances (2202 a, 2202 b, 2202 c) de-duplicating end-user application data. In some embodiments, the virtual backup appliance (collection of 2202 a, 2202 b and 2202 c are shown as 2202) can reside in any hypervisor (e.g. VMWare, Xen, HyperV, etc.). In some embodiments, deduplication comprises of a process that reduces the data footprint by only storing the unique blocks. The deduplication process reduces data storage requirements and also increases overall system throughput as systems are now managing smaller chunks of data.
- Referring to step 2302, the next step can include replicating the de-duplicated data from
virtual appliances 2202 to an aggregatingvirtual appliance 2201. In some embodiments, theaggregator appliance 2201 can be a larger virtual appliance that receives de-duplicated data from variousvirtual appliances 2202 and further de-duplicates the data. - Referring to step 2303, the next step can include replicating the de-duplicated data from an aggregating
virtual appliance 2201 to acentral appliance 2200. The central appliance can de-duplicate data across data received from all aggregator appliances (e.g., 2201 and 2204). A second hierarchy of de-duplicating appliances is shown in 2204. - In some embodiments, a hierarchy of de-duplicating appliances can provide a single instance of data across a wide range of end-user data. Data received by a layer from the layer below can be de-duplicated and then replicated to the layer above. The layer above can repeat this process further reducing the data footprint. This cascading mechanism can progressively reduce the data footprint thus resulting in optimal data storage. In some embodiments, a cascading hierarchy can go on for many levels as dictated by a customer's deployment.
- Consider the case of a company that has hundreds of stations all over Texas. Each station has about 1 TB of data. The company could deploy virtual appliances at each station and then aggregate a few virtual appliances to a regional aggregator appliance. The aggregator appliance will de-duplicate data from all virtual appliances. For instance if each appliance is protecting a Windows operating system, the aggregator appliance will de-duplicate that data and end up with a single instance of the Windows operating system. The company can deploy aggregator appliances based on geography and bandwidth requirement at the source and at the aggregator side. For instance all appliances in a metropolitan area network (MAN) can be aggregated to an aggregator appliance. The network should have adequate bandwidth to allow the replication of daily changes from the individual virtual appliances. These aggregators can further replicate this data to the regional aggregating appliance that in turn can then replicate to a central data center. This mechanism enables the company to optimize storage at each step of the hierarchy and truly single instance the data at the central data center.
-
FIG. 24 shows an archiving system, according to some embodiments. In some embodiments, the archiving system uses avirtual backup appliance 2404 to archive data in private andpublic cloud deployments 2406. - Public cloud infrastructure is fast becoming very affordable and enables offsite storage for organizations very manageable. A company that requires long term data retention for archiving purposes can use the public cloud infrastructure to store large amounts of data for long periods time for very low cost. A company can repurpose expensive on-site hardware for more critical needs and does not need to worry about very old data that is very in-frequently accessed.
- The
virtual backup appliance 2404, running in a end-user'shypervisor environment 2410 can protect 2402 end-user applications and end-user hosts 2401. The appliance can store end-user application data in a de-duplicated form 2403. The virtual appliance can also be configured to replicate the de-duplicated data 2403 to anotherappliance 2407 in a public orprivate cloud infrastructure 2406. Thisreplication 2408 process only moves the changed data in a de-duplicated form and creates another copy of the de-duplicated end-user data 2403 in the cloud. The replicated content can be used for longerterm data archiving 2405. - In some embodiments, the
virtual backup appliance 2404 can reside in any hypervisor 2408 (e.g. VMWare, Xen, HyperV, etc.) and can protect 2402 end-user applications or the entire end-user host machine 301 like virtual machines (e.g., Oracle, Windows machines, Linux machines, Exchange, etc.). Thevirtual back appliance 2404 can then de-duplicate the application data 2403 before writing the data to disk. With thededuplication operation 2404, the virtual backup appliance only stores the unique blocks of end-user data. The virtual backup appliance can replicate 2408 the de-duplicated data to another virtual backup application in thecloud 2407. - In some embodiments, the end-user applications 2401 (e.g., Linux, Windows machine, Hypervisor instances, etc.) are protected by one or more virtual
backup appliances 2404. The end-user customer can define policies to protect these applications. - In some embodiments,
data protection 2402 of applications and hosts involves moving the bits that have changed since the last protection from the application into thevirtual backup appliance 2404. The appliance can then de-duplicate this data and writes it to local storage. - In some embodiments, the deduplication process 2403 optimizes capacity by storing only the unique blocks thus reducing the storage requirement inside the virtual appliance.
- In some embodiments,
replication 2408 involves moving the de-duplicated data 2403 from the primaryvirtual backup appliance 2404 to another cloud basedbackup appliance 2407 sitting in a public orprivate cloud infrastructure 2406.Replication 2408 only moves the changes on the local side into the cloud. - In some embodiments, replicated
content 2405 is another copy of de-duplicated data that was replicated 2408 from the de-duplicated store 2403 of the primaryvirtual backup appliance 2404 on the primary side. The replicatedcontent 2405 also includes de-duplicated application and host data. - In some embodiments, public or
private cloud infrastructure 2406 is a pool of disk, compute and memory that can be provisioned on demand to host applications and other processing engines. AWS from Amazon is one of the largest public cloud infrastructures. The system can also replicate data from one geographic location of the public cloud to another. For e.g. when deployed in Amazon Web Services the system can replicate data from a Northern Virginia, U.S. data center to a data center in Singapore. - In some embodiments, a
backup cloud appliance 2407 is similar to thevirtual backup appliance 2404 but acts as a replication target accepting de-duplicated data for archival purposes. -
FIG. 25 shows a disaster recovery and business continuity system in private and public cloud deployments, according to some embodiments of the present disclosure. - Public cloud infrastructure is fast becoming very affordable and enables offsite storage for organizations very manageable. A company that requires offsite storage for disaster recovery and business continuance can leverage the cloud infrastructure. The cloud infrastructure comes at a much lower capital cost. A company can deploy a virtual appliance at their primary data center that replicates to another virtual appliance in the cloud. In the event of a disaster on the primary site, the backup appliance in the cloud holding the replicated data can bring back the protected applications and hosts to life in the cloud. This can help the company continue its business in the event of a disaster. In some embodiments, asynchronous data replication, whereby data ingested on the local system is made accessible on the remote system, can provide data available on the remote system in the event of a disaster on the local system. Doing this on a public cloud infrastructure makes this easily consumable by end-users. Resources can be provisioned and consumed on demand in the cloud thus enabling end-users to enable disaster recovery and implement business continuance on the push of a button.
- In some embodiments, a
virtual backup appliance 2504 can enable data disaster recovery and business continuity in a public orprivate cloud infrastructure 2506. Thebackup appliance 2504 protects 2502 applications and hosts 2501 and stores the data in de-duplicated form. The virtual appliance then replicates 2503 the de-duplicated content for disaster recovery and business continuance to another virtual backup appliance in thecloud 2505. The cloud basedbackup appliance 2505 can either run on a public orprivate cloud infrastructure 2506. In the event of a disaster at the primaryvirtual backup appliance 2504, applications and hosts 2508 protected by thatappliance 2504 can be recovered in thecloud infrastructure 2507. - In some embodiments, the
virtual backup appliance 2504 can reside in any hypervisor (e.g. VMWare, Xen, HyperV, etc.) and can protect 2502 end-user applications 2501 like virtual machines (e.g., Oracle, Windows machines, Linux machines, Exchange etc.). Thevirtual backup appliance 2504 then de-duplicates the application data before writing them to disk. The virtual backup appliance can replicate 2503 the de-duplicated data to another virtual backup application in thecloud 2505. - In some embodiments, the end-user applications 2501 (e.g., Linux, Windows machine, Hypervisor instances, etc.) are protected by one or more virtual
backup appliances 2504. The end-user customer can define policies to protect these applications. - In some embodiments,
data protection 2502 of applications and hosts involves moving the bits that have changed since the last protection from the application into thevirtual backup appliance 2504. The appliance then de-duplicates this data and writes it to local storage. - In some embodiments, the deduplication process optimizes capacity by storing only the unique blocks thus reducing the storage requirement inside the virtual appliance.
- In some embodiments,
replication 2503 involves moving the de-duplicated data from the primaryvirtual backup appliance 2504 to another cloud basedbackup appliance 2505 sitting in a public orprivate cloud infrastructure 2506. In some embodiments,replication 2503 only moves the changes on the local side into the cloud. - In some embodiments, public or
private cloud infrastructure 2506 is a pool of disk, CPU and memory that can be provisioned on demand to host applications and other processing engines. - In some embodiments, a
backup cloud appliance 2505 is similar to thevirtual backup appliance 2504 but acts as a replication target accepting de-duplicated data for archival purposes. - In some embodiments, the recovery of applications and hosts 2507 is the process of recovering applications and hosts 2501 protected by
virtual backup appliance 2504 in thepublic cloud infrastructure 2506. - In some embodiments, applications and hosts 2508 running the cloud are exact replicas of applications and hosts 2501 that were protected by the
virtual appliance 2504. - For example, say a software company has an accounting database that sits on a physical host in the company's data center. A virtual appliance protects the database. The virtual appliance will then replicate the data to another virtual appliance in a cloud infrastructure. In the event, the database in the company's data center is corrupted or destroyed, another copy of the database can be created from the replicated copy on virtual appliance in the cloud. The company can continue to operate its business from the cloud based database instance until its data center issue is repaired at which the database can be recovered onto its data center (from the cloud).
- In some embodiments, data management systems can create backups of application data without backing up all of the application data for each backup. When application data from a first time point shares similarities with application from a second time point, the system can take advantage of the data similarity between the two sets of application data. In some embodiments, the system can take a snapshot of the application data which includes information about the differences between application data at an earlier point in time and a second, current point in time for the snapshot. Therefore, rather than backing up all of the application data for each backup time, the system can back up only the changed data and refer back to the original content for the remaining data. A system for backing up data from a first storage pool to a second storage pool using difference information between time states is described in more detail above.
- In some embodiments, a virtual backup appliance creates a snapshot of the application data before backing it up and performing subsequent processing. In some embodiments, the virtual backup appliance can back up data using snapshots that are generated by a system external to the appliance rather than creating snapshots locally in the appliance. The appliance can, for instance, rely on external systems to generate snapshots of their data rather than using the appliance to generate the snapshots. The appliance can support using such external snapshots in combination with snapshots generated by the appliance (e.g., certain applications can create their own snapshots, while other applications can use the appliance to create the snapshots).
-
FIG. 26 shows a flowchart illustrating archive and business continuity in the cloud, according to some embodiments of the present disclosure. In step 2601, Virtual Backup Appliance or Physical CDS Cluster protect applications and hosts as configured by an end-use. Instep 2602, the protected data is deduplicated and then replicated to a Virtual Data Appliance in a public or private cloud. Instep 2603, Virtual Backup Appliance in the cloud receives virtual images of the applications and hosts replicated to it. In step 2604, if the primary appliance is destroyed due to a disaster the end-user can quickly bring up the applications in the cloud via the Virtual Backup Appliance running in the cloud. This provides disaster recovery and business continuance for enterprise grade applications. - Referring to step 2601, configuring the protection of applications includes applying Service Level Agreements (SLAs) to these applications.
- Referring to step 2602, replicating to a virtual data appliance in the cloud includes ingesting the application in the virtual appliance's snapshot pool followed by moving the data from the appliance's snapshot pool to the appliance's de-duplcation pool. Data is then replicated from the appliance's deduplication pool to the virtual appliance in the cloud's deduplication pool.
- Referring to step 2603, receiving the replicated data at the cloud includes the virtual appliance in the cloud receiving de-duplicated data from a virtual appliance in the customer's data center.
- Referring to step 2604, bringing up applications in the cloud includes restoring the application data from the virtual appliance in the cloud's deduplication pool.
-
FIG. 27 shows a flowchart illustrating backup as a service, according to some embodiments of the present disclosure. It also shows the work flow for delivering the above mentioned capabilities as a service and running a business on top of the service. In some embodiments, a website can act as a front-end to the service and provide an end-user access to this service. These services can be entirely end-user self-serviceable or can be driven via a managed service provider who delivers this service to an end-user. As shown in the work flow—the first step is the end-user signing up for theservice 2700 and then a portal giving the end-user access to resources for theservice 2701. The end-user installs somesoftware 2702 on premise and then connects to the cloud where the resources are auto provisioned by the portal. In some embodiments, the auto provisioning process uses Representational State Transfer (REST) Application Program Interfaces (APIs) to communicate with the Virtual Copy Data Management Appliance. The REST API is used to tell the appliance to begin the configuration process and to also monitor it. - Once the configuration process completes the system notifies the end user of the service availability. The end user meanwhile has installed the VCDMA on their local data center and can now connect that to the cloud.
- The end-user then discovers applications in their environment and applies protection to these applications using Service Level Agreements. The SLAs will replicate data to the cloud. There are different levels of service agreements that are offered by this service and the customer can pick Tier-0 for the highest priority applications and then go with Tier-1, Tier-2 and Tier-3 for the applications in that priority. Each Tier provides a certain level of resiliency the lower the tier the higher the resiliency level. Tier-4 applications only do vaulting and Tier-5 applications don't replicate this to the cloud.
- Once the applications are replicated to the cloud the end user can login to the website and create recovery plans 2703. A recovery plan can include the order in which systems will come up and the applications they will mount. In some embodiments, system parameters include Operating System, Memory and CPU to be provisioned for the system that is going to present the application data to the end user in the event of a disaster. The recovery plan can be executed either for a disaster recovery audit or for a
real disaster recovery 2704. In both cases the applications as shown in 2705 will be available when the systems specified in the recovery plan are running. The end user can then login to these servers and access the application data. The portal meters the amount of the time a recovery plan is running and the end-user is billed accordingly. - In some embodiments, a virtual backup appliance can be deployed in a cloud infrastructure thus enabling service providers to provide value added services using this system. The deployment of the system in a cloud infrastructure can be fully automated and all of it capabilities can be driven via REST APIs. The REST APIs are commands that are passed to the virtual appliance using HTTP protocol. The virtual appliance to configure itself in the cloud then executes these commands. This enables a service provider to create a template for automatically deploying this system. A template includes an operating system image and associated set of commands that are then executed on the operating system to bring up a custom application. In this case a service provider will chose the base operating system of the appliance and then will use the REST API to pass additional commands to the appliance once the operating system has been installed. In some embodiments, this constitutes a template. Once deployed a service provider can enable the capabilities of this system on demand using REST APIs and then use the charge back capabilities built into the system to generate billing reports for their end-users. A service provider can use REST APIs to get the amount of storage consumed in the appliance and use that data to bill their end users. The appliance provides space consumed by each application enabling fine-grained billing. Service Providers can also incrementally add new services as they get familiarized with the user of the system. Most service providers start with Back up as a service wherein they allow end users to back up the end-user's data into the appliance. Once that process has been established they can offer data recovery services, disaster recovery services as well dev-test services.
- The subject matter described herein can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structural means disclosed in this specification and structural equivalents thereof, or in combinations of them. The subject matter described herein can be implemented as one or more computer program products, such as one or more computer programs tangibly embodied in an information carrier (e.g., in a machine readable storage device), or embodied in a propagated signal, for execution by, or to control the operation of, data processing apparatus (e.g., a programmable processor, a computer, or multiple computers). A computer program (also known as a program, software, software application, or code) can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file. A program can be stored in a portion of a file that holds other programs or data, in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.
- The processes and logic flows described in this specification, including the method steps of the subject matter described herein, can be performed by one or more programmable processors executing one or more computer programs to perform functions of the subject matter described herein by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus of the subject matter described herein can be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit).
- Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processor of any kind of digital computer. Generally, a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks. Information carriers suitable for embodying computer program instructions and data include all forms of nonvolatile memory, including by way of example semiconductor memory devices, (e.g., EPROM, EEPROM, and flash memory devices); magnetic disks, (e.g., internal hard disks or removable disks); magneto optical disks; and optical disks (e.g., CD and DVD disks). The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
- To provide for interaction with a user, the subject matter described herein can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, (e.g., a mouse or a trackball), by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well. For example, feedback provided to the user can be any form of sensory feedback, (e.g., visual feedback, auditory feedback, or tactile feedback), and input from the user can be received in any form, including acoustic, speech, or tactile input.
- The subject matter described herein can be implemented in a computing system that includes a back end component (e.g., a data server), a middleware component (e.g., an application server), or a front end component (e.g., a client computer having a graphical user interface or a web browser through which a user can interact with an implementation of the subject matter described herein), or any combination of such back end, middleware, and front end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), e.g., the Internet.
- It is to be understood that the disclosed subject matter is not limited in its application to the details of construction and to the arrangements of the components set forth in the following description or illustrated in the drawings. The disclosed subject matter is capable of other embodiments and of being practiced and carried out in various ways. Also, it is to be understood that the phraseology and terminology employed herein are for the purpose of description and should not be regarded as limiting.
- As such, those skilled in the art will appreciate that the conception, upon which this disclosure is based, may readily be utilized as a basis for the designing of other structures, methods, and systems for carrying out the several purposes of the disclosed subject matter. It is important, therefore, that the claims be regarded as including such equivalent constructions insofar as they do not depart from the spirit and scope of the disclosed subject matter.
- Although the disclosed subject matter has been described and illustrated in the foregoing exemplary embodiments, it is understood that the present disclosure has been made only by way of example, and that numerous changes in the details of implementation of the disclosed subject matter may be made without departing from the spirit and scope of the disclosed subject matter.
Claims (15)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US14/622,479 US20150227600A1 (en) | 2014-02-13 | 2015-02-13 | Virtual data backup |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201461939511P | 2014-02-13 | 2014-02-13 | |
US14/622,479 US20150227600A1 (en) | 2014-02-13 | 2015-02-13 | Virtual data backup |
Publications (1)
Publication Number | Publication Date |
---|---|
US20150227600A1 true US20150227600A1 (en) | 2015-08-13 |
Family
ID=53775103
Family Applications (3)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US14/622,487 Abandoned US20150227601A1 (en) | 2014-02-13 | 2015-02-13 | Virtual data backup |
US14/622,479 Abandoned US20150227600A1 (en) | 2014-02-13 | 2015-02-13 | Virtual data backup |
US14/622,492 Abandoned US20150227602A1 (en) | 2014-02-13 | 2015-02-13 | Virtual data backup |
Family Applications Before (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US14/622,487 Abandoned US20150227601A1 (en) | 2014-02-13 | 2015-02-13 | Virtual data backup |
Family Applications After (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US14/622,492 Abandoned US20150227602A1 (en) | 2014-02-13 | 2015-02-13 | Virtual data backup |
Country Status (2)
Country | Link |
---|---|
US (3) | US20150227601A1 (en) |
WO (1) | WO2015123537A1 (en) |
Cited By (19)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20160170837A1 (en) * | 2014-06-30 | 2016-06-16 | International Business Machines Corporation | Use of replicated copies to improve database backup performance |
US20160283506A1 (en) * | 2015-03-24 | 2016-09-29 | Datos IO Inc. | ON-THE-FLY DEDUPLICATION DURING DATA MOVEMENT FOR NoSQL DATA STORES |
US20170192857A1 (en) * | 2015-12-30 | 2017-07-06 | Emc Corporation | Creating replicas at user-defined points in time |
US9811281B2 (en) | 2016-04-07 | 2017-11-07 | International Business Machines Corporation | Multi-tenant memory service for memory pool architectures |
US10191685B2 (en) * | 2014-06-11 | 2019-01-29 | Hitachi, Ltd. | Storage system, storage device, and data transfer method |
WO2019183423A1 (en) * | 2018-03-23 | 2019-09-26 | Veritas Technologies Llc | Systems and methods for backing-up an eventually-consistent database in a production cluster |
US10437817B2 (en) | 2016-04-19 | 2019-10-08 | Huawei Technologies Co., Ltd. | Concurrent segmentation using vector processing |
US10459961B2 (en) | 2016-04-19 | 2019-10-29 | Huawei Technologies Co., Ltd. | Vector processing for segmentation hash values calculation |
US10459883B1 (en) | 2015-12-30 | 2019-10-29 | EMC IP Holding Company LLC | Retention policies for unscheduled replicas in backup, snapshots, and remote replication |
WO2019209392A1 (en) * | 2018-04-24 | 2019-10-31 | Pure Storage, Inc. | Hybrid data tiering |
JP2020506462A (en) * | 2017-01-06 | 2020-02-27 | オラクル・インターナショナル・コーポレイション | Cloud migration of file system data tier |
CN111355705A (en) * | 2020-02-08 | 2020-06-30 | 西安电子科技大学 | Data auditing and safety duplicate removal cloud storage system and method based on block chain |
US10936238B2 (en) | 2017-11-28 | 2021-03-02 | Pure Storage, Inc. | Hybrid data tiering |
US10990282B1 (en) | 2017-11-28 | 2021-04-27 | Pure Storage, Inc. | Hybrid data tiering with cloud storage |
WO2021158710A1 (en) * | 2020-02-04 | 2021-08-12 | Grav1Ty Inc. | Selective synchronization of database objects |
US11144572B2 (en) * | 2018-07-30 | 2021-10-12 | Hewlett Packard Enterprise Development Lp | Centralized configuration database cache |
US11392553B1 (en) | 2018-04-24 | 2022-07-19 | Pure Storage, Inc. | Remote data management |
US11436344B1 (en) | 2018-04-24 | 2022-09-06 | Pure Storage, Inc. | Secure encryption in deduplication cluster |
EP4280077A1 (en) * | 2022-05-18 | 2023-11-22 | Snowflake Inc. | Data ingestion replication and disaster recovery |
Families Citing this family (227)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8307177B2 (en) | 2008-09-05 | 2012-11-06 | Commvault Systems, Inc. | Systems and methods for management of virtualization data |
US11449394B2 (en) | 2010-06-04 | 2022-09-20 | Commvault Systems, Inc. | Failover systems and methods for performing backup operations, including heterogeneous indexing and load balancing of backup and indexing resources |
US10155168B2 (en) | 2012-05-08 | 2018-12-18 | Snap Inc. | System and method for adaptable avatars |
US9223597B2 (en) | 2012-12-21 | 2015-12-29 | Commvault Systems, Inc. | Archiving virtual machines in a data storage system |
US9740702B2 (en) | 2012-12-21 | 2017-08-22 | Commvault Systems, Inc. | Systems and methods to identify unprotected virtual machines |
US20140196039A1 (en) | 2013-01-08 | 2014-07-10 | Commvault Systems, Inc. | Virtual machine categorization system and method |
US10439972B1 (en) | 2013-05-30 | 2019-10-08 | Snap Inc. | Apparatus and method for maintaining a message thread with opt-in permanence for entries |
US9705831B2 (en) | 2013-05-30 | 2017-07-11 | Snap Inc. | Apparatus and method for maintaining a message thread with opt-in permanence for entries |
US9053216B1 (en) | 2013-08-09 | 2015-06-09 | Datto, Inc. | CPU register assisted virtual machine screenshot capture timing apparatuses, methods and systems |
US20150074536A1 (en) | 2013-09-12 | 2015-03-12 | Commvault Systems, Inc. | File manager integration with virtualization in an information management system, including user control and storage management of virtual machines |
US9563518B2 (en) | 2014-04-02 | 2017-02-07 | Commvault Systems, Inc. | Information management by a media agent in the absence of communications with a storage manager |
US9892001B2 (en) * | 2014-04-30 | 2018-02-13 | Actian Corporation | Customizing backup and restore of databases |
US9276886B1 (en) | 2014-05-09 | 2016-03-01 | Snapchat, Inc. | Apparatus and method for dynamically configuring application component tiles |
US9537811B2 (en) | 2014-10-02 | 2017-01-03 | Snap Inc. | Ephemeral gallery of ephemeral messages |
US9396354B1 (en) | 2014-05-28 | 2016-07-19 | Snapchat, Inc. | Apparatus and method for automated privacy protection in distributed images |
US9594636B2 (en) | 2014-05-30 | 2017-03-14 | Datto, Inc. | Management of data replication and storage apparatuses, methods and systems |
US9113301B1 (en) | 2014-06-13 | 2015-08-18 | Snapchat, Inc. | Geo-location based event gallery |
US9613053B1 (en) * | 2014-06-30 | 2017-04-04 | EMC IP Holding Company LLC | Techniques for providing access to a virtualized block storage device over a file-based network storage protocol |
US20160019317A1 (en) | 2014-07-16 | 2016-01-21 | Commvault Systems, Inc. | Volume or virtual machine level backup and generating placeholders for virtual machine files |
US10824654B2 (en) | 2014-09-18 | 2020-11-03 | Snap Inc. | Geolocation-based pictographs |
US10284508B1 (en) | 2014-10-02 | 2019-05-07 | Snap Inc. | Ephemeral gallery of ephemeral messages with opt-in permanence |
US10033803B1 (en) * | 2014-10-31 | 2018-07-24 | Amazon Technologies, Inc. | Data volume auto-repair based on volume degradation level |
US10776209B2 (en) | 2014-11-10 | 2020-09-15 | Commvault Systems, Inc. | Cross-platform virtual machine backup and replication |
US9983936B2 (en) | 2014-11-20 | 2018-05-29 | Commvault Systems, Inc. | Virtual machine change block tracking |
CN105701116A (en) * | 2014-11-27 | 2016-06-22 | 英业达科技有限公司 | Data synchronization system |
US10311916B2 (en) | 2014-12-19 | 2019-06-04 | Snap Inc. | Gallery of videos set to an audio time line |
US9385983B1 (en) | 2014-12-19 | 2016-07-05 | Snapchat, Inc. | Gallery of messages from individuals with a shared interest |
US9754355B2 (en) | 2015-01-09 | 2017-09-05 | Snap Inc. | Object recognition based photo filters |
US10133705B1 (en) | 2015-01-19 | 2018-11-20 | Snap Inc. | Multichannel system |
US9294425B1 (en) | 2015-02-06 | 2016-03-22 | Snapchat, Inc. | Storage and processing of ephemeral messages |
US9830091B2 (en) * | 2015-02-20 | 2017-11-28 | Netapp, Inc. | Policy-based data tiering using a cloud architecture |
KR102217723B1 (en) | 2015-03-18 | 2021-02-19 | 스냅 인코포레이티드 | Geo-fence authorization provisioning |
US9639701B1 (en) * | 2015-03-31 | 2017-05-02 | EMC IP Holding Company LLC | Scheduling data protection operations based on data activity |
US10409781B2 (en) | 2015-04-29 | 2019-09-10 | Box, Inc. | Multi-regime caching in a virtual file system for cloud-based shared content |
US10135949B1 (en) | 2015-05-05 | 2018-11-20 | Snap Inc. | Systems and methods for story and sub-story navigation |
CN115412385A (en) | 2015-05-06 | 2022-11-29 | 斯纳普公司 | System and method for transient group chat |
US10496626B2 (en) * | 2015-06-11 | 2019-12-03 | EB Storage Systems Ltd. | Deduplication in a highly-distributed shared topology with direct-memory-access capable interconnect |
US9906479B1 (en) | 2015-06-16 | 2018-02-27 | Snap Inc. | Storage management for ephemeral messages |
US10503264B1 (en) | 2015-06-16 | 2019-12-10 | Snap Inc. | Radial gesture navigation |
US10318183B1 (en) * | 2015-06-30 | 2019-06-11 | EMC IP Holding Company LLC | Storage management system and method |
US10616162B1 (en) | 2015-08-24 | 2020-04-07 | Snap Inc. | Systems devices and methods for automatically selecting an ephemeral message availability |
US11121997B1 (en) | 2015-08-24 | 2021-09-14 | Snap Inc. | Systems, devices, and methods for determining a non-ephemeral message status in a communication system |
US10157333B1 (en) | 2015-09-15 | 2018-12-18 | Snap Inc. | Systems and methods for content tagging |
CN106557265B (en) * | 2015-09-25 | 2019-08-23 | 伊姆西公司 | Method, equipment and the medium of the operating characteristics of managed data object |
US10120766B2 (en) * | 2015-10-16 | 2018-11-06 | Business Objects Software Limited | Model-based system and method for undoing actions in an application |
US9652896B1 (en) | 2015-10-30 | 2017-05-16 | Snap Inc. | Image based tracking in augmented reality systems |
US9477555B1 (en) | 2015-11-16 | 2016-10-25 | International Business Machines Corporation | Optimized disaster-recovery-as-a-service system |
US11119628B1 (en) | 2015-11-25 | 2021-09-14 | Snap Inc. | Dynamic graphical user interface modification and monitoring |
US9984499B1 (en) | 2015-11-30 | 2018-05-29 | Snap Inc. | Image and point cloud based tracking and in augmented reality systems |
US10354425B2 (en) | 2015-12-18 | 2019-07-16 | Snap Inc. | Method and system for providing context relevant media augmentation |
US10067837B1 (en) * | 2015-12-28 | 2018-09-04 | EMC IP Holding Company LLC | Continuous data protection with cloud resources |
WO2017116264A1 (en) * | 2015-12-29 | 2017-07-06 | Emc Corporation | Efficient deduplication of logical units |
US10394659B2 (en) * | 2016-01-13 | 2019-08-27 | Acronis International Gmbh | System and method for providing comprehensive backup of modular mobile devices |
US10565067B2 (en) * | 2016-03-09 | 2020-02-18 | Commvault Systems, Inc. | Virtual server cloud file system for virtual machine backup from cloud operations |
US10530731B1 (en) | 2016-03-28 | 2020-01-07 | Snap Inc. | Systems and methods for chat with audio and video elements |
US10270839B2 (en) | 2016-03-29 | 2019-04-23 | Snap Inc. | Content collection navigation and autoforwarding |
US10346252B1 (en) * | 2016-03-30 | 2019-07-09 | EMC IP Holding Company LLC | Data protection in a multi-site cloud computing environment |
US10339365B2 (en) | 2016-03-31 | 2019-07-02 | Snap Inc. | Automated avatar generation |
US10686899B2 (en) | 2016-04-06 | 2020-06-16 | Snap Inc. | Messaging achievement pictograph display system |
US9813642B1 (en) | 2016-05-06 | 2017-11-07 | Snap Inc. | Dynamic activity-based image generation |
US10474353B2 (en) | 2016-05-31 | 2019-11-12 | Snap Inc. | Application control using a gesture based trigger |
US10067874B2 (en) | 2016-06-07 | 2018-09-04 | International Business Machines Corporation | Optimizing the management of cache memory |
US9681265B1 (en) | 2016-06-28 | 2017-06-13 | Snap Inc. | System to track engagement of media items |
US11507977B2 (en) | 2016-06-28 | 2022-11-22 | Snap Inc. | Methods and systems for presentation of media collections with automated advertising |
US10387453B1 (en) * | 2016-06-29 | 2019-08-20 | EMC IP Holding Company LLC | Database views for graphs using dynamic subgraphs |
US10182047B1 (en) | 2016-06-30 | 2019-01-15 | Snap Inc. | Pictograph password security system |
US11334768B1 (en) | 2016-07-05 | 2022-05-17 | Snap Inc. | Ephemeral content management |
US10552968B1 (en) | 2016-09-23 | 2020-02-04 | Snap Inc. | Dense feature scale detection for image matching |
US10417102B2 (en) | 2016-09-30 | 2019-09-17 | Commvault Systems, Inc. | Heartbeat monitoring of virtual machines for initiating failover operations in a data storage management system, including virtual machine distribution logic |
US10609036B1 (en) | 2016-10-10 | 2020-03-31 | Snap Inc. | Social media post subscribe requests for buffer user accounts |
US10432559B2 (en) | 2016-10-24 | 2019-10-01 | Snap Inc. | Generating and displaying customized avatars in electronic messages |
US10162528B2 (en) | 2016-10-25 | 2018-12-25 | Commvault Systems, Inc. | Targeted snapshot based on virtual machine location |
WO2018085426A1 (en) | 2016-11-01 | 2018-05-11 | Snap Inc. | Systems and methods for fast video capture and sensor adjustment |
US10346062B2 (en) | 2016-11-16 | 2019-07-09 | International Business Machines Corporation | Point-in-time backups via a storage controller to an object storage cloud |
US10678758B2 (en) | 2016-11-21 | 2020-06-09 | Commvault Systems, Inc. | Cross-platform virtual machine data and memory backup and replication |
US10740939B1 (en) | 2016-12-09 | 2020-08-11 | Snap Inc. | Fast image style transfers |
US10319149B1 (en) | 2017-02-17 | 2019-06-11 | Snap Inc. | Augmented reality anamorphosis system |
US10074381B1 (en) | 2017-02-20 | 2018-09-11 | Snap Inc. | Augmented reality speech balloon system |
US11019001B1 (en) | 2017-02-20 | 2021-05-25 | Snap Inc. | Selective presentation of group messages |
US10374993B2 (en) | 2017-02-20 | 2019-08-06 | Snap Inc. | Media item attachment system |
US10878837B1 (en) | 2017-03-01 | 2020-12-29 | Snap Inc. | Acoustic neural network scene detection |
US20180276022A1 (en) | 2017-03-24 | 2018-09-27 | Commvault Systems, Inc. | Consistent virtual machine replication |
US10581782B2 (en) | 2017-03-27 | 2020-03-03 | Snap Inc. | Generating a stitched data stream |
US10582277B2 (en) | 2017-03-27 | 2020-03-03 | Snap Inc. | Generating a stitched data stream |
US10387073B2 (en) | 2017-03-29 | 2019-08-20 | Commvault Systems, Inc. | External dynamic virtual machine synchronization |
US11170393B1 (en) | 2017-04-11 | 2021-11-09 | Snap Inc. | System to calculate an engagement score of location based media content |
US10387730B1 (en) | 2017-04-20 | 2019-08-20 | Snap Inc. | Augmented reality typography personalization system |
CN110945555A (en) | 2017-04-27 | 2020-03-31 | 斯纳普公司 | Region-level representation of user locations on a social media platform |
US11893647B2 (en) | 2017-04-27 | 2024-02-06 | Snap Inc. | Location-based virtual avatars |
US10212541B1 (en) | 2017-04-27 | 2019-02-19 | Snap Inc. | Selective location-based identity communication |
US10382372B1 (en) | 2017-04-27 | 2019-08-13 | Snap Inc. | Processing media content based on original context |
US10943255B1 (en) | 2017-04-28 | 2021-03-09 | Snap Inc. | Methods and systems for interactive advertising with media collections |
US11893265B2 (en) * | 2017-05-02 | 2024-02-06 | Google Llc | Garbage collection for data storage |
US10679428B1 (en) | 2017-05-26 | 2020-06-09 | Snap Inc. | Neural network-based image stream modification |
US10788900B1 (en) | 2017-06-29 | 2020-09-29 | Snap Inc. | Pictorial symbol prediction |
US10929210B2 (en) | 2017-07-07 | 2021-02-23 | Box, Inc. | Collaboration system protocol processing |
US11470131B2 (en) | 2017-07-07 | 2022-10-11 | Box, Inc. | User device processing of information from a network-accessible collaboration system |
US10983908B1 (en) * | 2017-07-13 | 2021-04-20 | EMC IP Holding Company LLC | Method and system for garbage collection of data protection virtual machines in cloud computing networks |
US11301487B1 (en) * | 2017-07-21 | 2022-04-12 | EMC IP Holding Company LLC | Automated server discovery |
US11477280B1 (en) * | 2017-07-26 | 2022-10-18 | Pure Storage, Inc. | Integrating cloud storage services |
US11216517B1 (en) | 2017-07-31 | 2022-01-04 | Snap Inc. | Methods and systems for selecting user generated content |
US11323398B1 (en) | 2017-07-31 | 2022-05-03 | Snap Inc. | Systems, devices, and methods for progressive attachments |
CN107402852B (en) * | 2017-08-16 | 2020-11-27 | 苏州浪潮智能科技有限公司 | Remote copying method with self-adaptive change volume |
US11164376B1 (en) | 2017-08-30 | 2021-11-02 | Snap Inc. | Object modeling using light projection |
JP6782362B2 (en) | 2017-08-30 | 2020-11-11 | 株式会社Ｋｏｋｕｓａｉ Ｅｌｅｃｔｒｉｃ | Manufacturing method of protective plate, substrate processing device and semiconductor device |
US9980100B1 (en) | 2017-08-31 | 2018-05-22 | Snap Inc. | Device location based on machine learning classifications |
US10685010B2 (en) | 2017-09-11 | 2020-06-16 | Amazon Technologies, Inc. | Shared volumes in distributed RAID over shared multi-queue storage devices |
US10681129B1 (en) * | 2017-09-12 | 2020-06-09 | Veritas Technologies Llc | Systems and methods for recovering data |
US10740974B1 (en) | 2017-09-15 | 2020-08-11 | Snap Inc. | Augmented reality system |
US10474900B2 (en) | 2017-09-15 | 2019-11-12 | Snap Inc. | Real-time tracking-compensated image effects |
JP6916766B2 (en) | 2018-08-27 | 2021-08-11 | 株式会社Ｋｏｋｕｓａｉ Ｅｌｅｃｔｒｉｃ | Manufacturing method of substrate processing equipment and semiconductor equipment |
US10891723B1 (en) | 2017-09-29 | 2021-01-12 | Snap Inc. | Realistic neural network based image style transfer |
US10872292B1 (en) | 2017-10-09 | 2020-12-22 | Snap Inc. | Compact neural networks using condensed filters |
US10599289B1 (en) | 2017-11-13 | 2020-03-24 | Snap Inc. | Interface to display animated icon |
US11551059B1 (en) | 2017-11-15 | 2023-01-10 | Snap Inc. | Modulated image segmentation |
US10885564B1 (en) | 2017-11-28 | 2021-01-05 | Snap Inc. | Methods, system, and non-transitory computer readable storage medium for dynamically configurable social media platform |
US10217488B1 (en) | 2017-12-15 | 2019-02-26 | Snap Inc. | Spherical video editing |
US11017173B1 (en) | 2017-12-22 | 2021-05-25 | Snap Inc. | Named entity recognition visual context and caption data |
US10523606B2 (en) | 2018-01-02 | 2019-12-31 | Snap Inc. | Generating interactive messages with asynchronous media content |
CN110058962B (en) * | 2018-01-18 | 2023-05-23 | 伊姆西Ip控股有限责任公司 | Method, apparatus and computer program product for determining consistency level of virtual machine snapshots |
US10482565B1 (en) | 2018-02-12 | 2019-11-19 | Snap Inc. | Multistage neural network processing using a graphics processor |
US10726603B1 (en) | 2018-02-28 | 2020-07-28 | Snap Inc. | Animated expressive icon |
US10885136B1 (en) | 2018-02-28 | 2021-01-05 | Snap Inc. | Audience filtering system |
US10327096B1 (en) | 2018-03-06 | 2019-06-18 | Snap Inc. | Geo-fence selection system |
US10877928B2 (en) | 2018-03-07 | 2020-12-29 | Commvault Systems, Inc. | Using utilities injected into cloud-based virtual machines for speeding up virtual machine backup operations |
US11310176B2 (en) | 2018-04-13 | 2022-04-19 | Snap Inc. | Content suggestion system |
US20190042294A1 (en) * | 2018-04-13 | 2019-02-07 | Intel Corporation | System and method for implementing virtualized network functions with a shared memory pool |
EP3782124A1 (en) | 2018-04-18 | 2021-02-24 | Snap Inc. | Augmented expression system |
US10831609B2 (en) * | 2018-04-30 | 2020-11-10 | EMC IP Holding Company LLC | Data storage system with LUN snapshot shipping using volume-to-object translation |
US11487501B2 (en) | 2018-05-16 | 2022-11-01 | Snap Inc. | Device control using audio data |
US10997760B2 (en) | 2018-08-31 | 2021-05-04 | Snap Inc. | Augmented reality anthropomorphization system |
US10754569B2 (en) | 2018-09-06 | 2020-08-25 | Oracle International Corporation | Methods to reduce storage capacity |
US10963436B2 (en) * | 2018-10-31 | 2021-03-30 | EMC IP Holding Company LLC | Deduplicating data at sub-block granularity |
EP3866016A4 (en) * | 2018-11-20 | 2021-11-10 | Huawei Technologies Co., Ltd. | Method and apparatus for deleting index entry in memory |
US11200124B2 (en) | 2018-12-06 | 2021-12-14 | Commvault Systems, Inc. | Assigning backup resources based on failover of partnered data storage servers in a data storage management system |
USD886143S1 (en) | 2018-12-14 | 2020-06-02 | Nutanix, Inc. | Display screen or portion thereof with a user interface for database time-machine |
US10817157B2 (en) | 2018-12-20 | 2020-10-27 | Nutanix, Inc. | User interface for database management services |
US11010336B2 (en) | 2018-12-27 | 2021-05-18 | Nutanix, Inc. | System and method for provisioning databases in a hyperconverged infrastructure system |
US11816066B2 (en) | 2018-12-27 | 2023-11-14 | Nutanix, Inc. | System and method for protecting databases in a hyperconverged infrastructure system |
US11245761B2 (en) | 2018-12-28 | 2022-02-08 | Alibaba Group Holding Limited | Method, apparatus, and computer-readable storage medium for network optimization of cloud storage service |
CN109828868B (en) * | 2019-01-04 | 2023-02-03 | 新华三技术有限公司成都分公司 | Data storage method, device, management equipment and double-active data storage system |
US10976950B1 (en) * | 2019-01-15 | 2021-04-13 | Twitter, Inc. | Distributed dataset modification, retention, and replication |
US11113270B2 (en) | 2019-01-24 | 2021-09-07 | EMC IP Holding Company LLC | Storing a non-ordered associative array of pairs using an append-only storage medium |
US11442642B2 (en) * | 2019-01-29 | 2022-09-13 | Dell Products L.P. | Method and system for inline deduplication using erasure coding to minimize read and write operations |
US20200241781A1 (en) | 2019-01-29 | 2020-07-30 | Dell Products L.P. | Method and system for inline deduplication using erasure coding |
US10768971B2 (en) | 2019-01-30 | 2020-09-08 | Commvault Systems, Inc. | Cross-hypervisor live mount of backed up virtual machine data |
US11297027B1 (en) | 2019-01-31 | 2022-04-05 | Snap Inc. | Automated image processing and insight presentation |
US11972529B2 (en) | 2019-02-01 | 2024-04-30 | Snap Inc. | Augmented reality system |
US11119912B2 (en) * | 2019-03-25 | 2021-09-14 | International Business Machines Corporation | Ordering data updates for improving garbage collection being performed while performing the set of data updates |
US10795699B1 (en) * | 2019-03-28 | 2020-10-06 | Cohesity, Inc. | Central storage management interface supporting native user interface versions |
US11531712B2 (en) * | 2019-03-28 | 2022-12-20 | Cohesity, Inc. | Unified metadata search |
WO2020223099A2 (en) | 2019-04-30 | 2020-11-05 | Clumio, Inc. | Cloud-based data protection service |
US11134036B2 (en) | 2019-07-05 | 2021-09-28 | Snap Inc. | Event planning in a content sharing platform |
WO2021012162A1 (en) * | 2019-07-22 | 2021-01-28 | 华为技术有限公司 | Method and apparatus for data compression in storage system, device, and readable storage medium |
US11609820B2 (en) | 2019-07-31 | 2023-03-21 | Dell Products L.P. | Method and system for redundant distribution and reconstruction of storage metadata |
US11328071B2 (en) | 2019-07-31 | 2022-05-10 | Dell Products L.P. | Method and system for identifying actor of a fraudulent action during legal hold and litigation |
US11372730B2 (en) | 2019-07-31 | 2022-06-28 | Dell Products L.P. | Method and system for offloading a continuous health-check and reconstruction of data in a non-accelerator pool |
US11775193B2 (en) | 2019-08-01 | 2023-10-03 | Dell Products L.P. | System and method for indirect data classification in a storage system operations |
US11812347B2 (en) | 2019-09-06 | 2023-11-07 | Snap Inc. | Non-textual communication and user states management |
US11265374B2 (en) * | 2019-10-15 | 2022-03-01 | EMC IP Holding Company LLC | Cloud disaster recovery |
US11316806B1 (en) | 2020-01-28 | 2022-04-26 | Snap Inc. | Bulk message deletion |
US11265281B1 (en) | 2020-01-28 | 2022-03-01 | Snap Inc. | Message deletion policy selection |
US11467753B2 (en) | 2020-02-14 | 2022-10-11 | Commvault Systems, Inc. | On-demand restore of virtual machine data |
US11301327B2 (en) | 2020-03-06 | 2022-04-12 | Dell Products L.P. | Method and system for managing a spare persistent storage device and a spare node in a multi-node data cluster |
US11416357B2 (en) | 2020-03-06 | 2022-08-16 | Dell Products L.P. | Method and system for managing a spare fault domain in a multi-fault domain data cluster |
US11281535B2 (en) | 2020-03-06 | 2022-03-22 | Dell Products L.P. | Method and system for performing a checkpoint zone operation for a spare persistent storage |
US11442768B2 (en) | 2020-03-12 | 2022-09-13 | Commvault Systems, Inc. | Cross-hypervisor live recovery of virtual machines |
US11294776B2 (en) | 2020-03-24 | 2022-04-05 | Verizon Patent And Licensing Inc. | Systems and methods for remote-initiated device backup |
US11099956B1 (en) | 2020-03-26 | 2021-08-24 | Commvault Systems, Inc. | Snapshot-based disaster recovery orchestration of virtual machine failover and failback operations |
US11625873B2 (en) | 2020-03-30 | 2023-04-11 | Snap Inc. | Personalized media overlay recommendation |
KR20220157502A (en) * | 2020-03-31 | 2022-11-29 | 스냅 인코포레이티드 | Augmented Reality Beauty Product Tutorials |
US11700225B2 (en) | 2020-04-23 | 2023-07-11 | Snap Inc. | Event overlay invite messaging system |
US11599546B2 (en) | 2020-05-01 | 2023-03-07 | EMC IP Holding Company LLC | Stream browser for data streams |
US11604759B2 (en) | 2020-05-01 | 2023-03-14 | EMC IP Holding Company LLC | Retention management for data streams |
US11500669B2 (en) | 2020-05-15 | 2022-11-15 | Commvault Systems, Inc. | Live recovery of virtual machines in a public cloud computing environment |
US11418326B2 (en) | 2020-05-21 | 2022-08-16 | Dell Products L.P. | Method and system for performing secure data transactions in a data cluster |
US11843574B2 (en) | 2020-05-21 | 2023-12-12 | Snap Inc. | Featured content collection interface |
US11687513B2 (en) | 2020-05-26 | 2023-06-27 | Molecula Corp. | Virtual data source manager of data virtualization-based architecture |
US11960616B2 (en) | 2020-05-26 | 2024-04-16 | Molecula Corp. | Virtual data sources of data virtualization-based architecture |
US11263026B2 (en) * | 2020-05-26 | 2022-03-01 | Molecula Corp. | Software plugins of data virtualization-based architecture |
US11334497B2 (en) | 2020-06-05 | 2022-05-17 | Vmware, Inc. | Efficient segment cleaning employing local copying of data blocks in log-structured file systems of distributed data systems |
US11144394B1 (en) * | 2020-06-05 | 2021-10-12 | Vmware, Inc. | Storing B-tree pages in capacity tier for erasure-coded storage in distributed data systems |
US11507544B2 (en) | 2020-06-05 | 2022-11-22 | Vmware, Inc. | Efficient erasure-coded storage in distributed data systems |
CN115885247A (en) | 2020-06-10 | 2023-03-31 | 斯纳普公司 | Visual search for launching applications |
US11423652B2 (en) | 2020-06-10 | 2022-08-23 | Snap Inc. | Adding beauty products to augmented reality tutorials |
US11899905B2 (en) | 2020-06-30 | 2024-02-13 | Snap Inc. | Selectable items providing post-viewing context actions |
US11599420B2 (en) | 2020-07-30 | 2023-03-07 | EMC IP Holding Company LLC | Ordered event stream event retention |
WO2022036372A1 (en) | 2020-08-13 | 2022-02-17 | Snap Inc. | User interface for pose driven virtual effects |
US11604705B2 (en) | 2020-08-14 | 2023-03-14 | Nutanix, Inc. | System and method for cloning as SQL server AG databases in a hyperconverged system |
US11907167B2 (en) | 2020-08-28 | 2024-02-20 | Nutanix, Inc. | Multi-cluster database management services |
US11567665B2 (en) * | 2020-08-31 | 2023-01-31 | Micron Technology, Inc. | Data dispersion-based memory management |
US11513871B2 (en) | 2020-09-30 | 2022-11-29 | EMC IP Holding Company LLC | Employing triggered retention in an ordered event stream storage system |
US11755555B2 (en) | 2020-10-06 | 2023-09-12 | EMC IP Holding Company LLC | Storing an ordered associative array of pairs using an append-only storage medium |
US11599293B2 (en) | 2020-10-14 | 2023-03-07 | EMC IP Holding Company LLC | Consistent data stream replication and reconstruction in a streaming data storage platform |
US11809910B2 (en) | 2020-10-14 | 2023-11-07 | Bank Of America Corporation | System and method for dynamically resizing computational infrastructure to accommodate unexpected demands |
US11640340B2 (en) | 2020-10-20 | 2023-05-02 | Nutanix, Inc. | System and method for backing up highly available source databases in a hyperconverged system |
US11656951B2 (en) | 2020-10-28 | 2023-05-23 | Commvault Systems, Inc. | Data loss vulnerability detection |
KR20220060385A (en) * | 2020-11-04 | 2022-05-11 | 에스케이하이닉스 주식회사 | Storage device and operating method thereof |
US11604806B2 (en) | 2020-12-28 | 2023-03-14 | Nutanix, Inc. | System and method for highly available database service |
US11816065B2 (en) | 2021-01-11 | 2023-11-14 | EMC IP Holding Company LLC | Event level retention management for data streams |
US20220291858A1 (en) * | 2021-03-15 | 2022-09-15 | Pure Storage, Inc. | Utilizing programming page size granularity to optimize data segment storage in a storage system |
US11892918B2 (en) | 2021-03-22 | 2024-02-06 | Nutanix, Inc. | System and method for availability group database patching |
US11775197B2 (en) * | 2021-03-25 | 2023-10-03 | Kyocera Document Solutions Inc. | Single command for reading then clearing dynamic random access memory |
US11740828B2 (en) * | 2021-04-06 | 2023-08-29 | EMC IP Holding Company LLC | Data expiration for stream storages |
US11740821B2 (en) * | 2021-04-12 | 2023-08-29 | EMC IP Holding Company LLC | Cost-aware garbage collection for cloud storage |
US11954537B2 (en) | 2021-04-22 | 2024-04-09 | EMC IP Holding Company LLC | Information-unit based scaling of an ordered event stream |
US11681460B2 (en) | 2021-06-03 | 2023-06-20 | EMC IP Holding Company LLC | Scaling of an ordered event stream based on a writer group characteristic |
US11513720B1 (en) * | 2021-06-11 | 2022-11-29 | Western Digital Technologies, Inc. | Data storage device having predictive analytics |
US11972028B2 (en) * | 2021-06-11 | 2024-04-30 | EMC IP Holding Company LLC | Method and system for managing data protection feature compatibility |
US11543993B1 (en) * | 2021-06-17 | 2023-01-03 | Western Digital Technologies, Inc. | Fast garbage collection in zoned namespaces SSDs |
US11735282B2 (en) | 2021-07-22 | 2023-08-22 | EMC IP Holding Company LLC | Test data verification for an ordered event stream storage system |
US11733893B2 (en) * | 2021-07-28 | 2023-08-22 | International Business Machines Corporation | Management of flash storage media |
US11907564B2 (en) * | 2021-08-03 | 2024-02-20 | Yadro International Ltd. | Method of and system for initiating garbage collection requests |
CN113821376B (en) * | 2021-08-19 | 2023-11-28 | 广东电力信息科技有限公司 | Cloud disaster recovery-based integrated backup disaster recovery method and system |
US11922047B2 (en) * | 2021-09-16 | 2024-03-05 | EMC IP Holding Company LLC | Using RPO as an optimization target for DataDomain garbage collection |
JP2023044330A (en) * | 2021-09-17 | 2023-03-30 | キオクシア株式会社 | Memory system and control method |
US11847334B2 (en) * | 2021-09-23 | 2023-12-19 | EMC IP Holding Company LLC | Method or apparatus to integrate physical file verification and garbage collection (GC) by tracking special segments |
US11803368B2 (en) | 2021-10-01 | 2023-10-31 | Nutanix, Inc. | Network learning to control delivery of updates |
US11971850B2 (en) | 2021-10-15 | 2024-04-30 | EMC IP Holding Company LLC | Demoted data retention via a tiered ordered event stream data storage system |
US20230195351A1 (en) * | 2021-12-17 | 2023-06-22 | Samsung Electronics Co., Ltd. | Automatic deletion in a persistent storage device |
US20230280926A1 (en) * | 2022-03-03 | 2023-09-07 | Western Digital Technologies, Inc. | Data Relocation With Protection For Open Relocation Destination Blocks |
US11886735B2 (en) * | 2022-03-22 | 2024-01-30 | Micron Technology, Inc. | Data movement based on address table activity |
US11941297B2 (en) | 2022-04-11 | 2024-03-26 | Netapp, Inc. | Garbage collection and bin synchronization for distributed storage architecture |
US11934656B2 (en) * | 2022-04-11 | 2024-03-19 | Netapp, Inc. | Garbage collection and bin synchronization for distributed storage architecture |
US11947452B2 (en) * | 2022-06-01 | 2024-04-02 | Micron Technology, Inc. | Controlling variation of valid data counts in garbage collection source blocks |
US11973730B2 (en) | 2022-06-02 | 2024-04-30 | Snap Inc. | External messaging function for an interaction system |
US20240012579A1 (en) * | 2022-07-06 | 2024-01-11 | Samsung Electronics Co., Ltd. | Systems, methods, and apparatus for data placement in a storage device |
Citations (6)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20130013865A1 (en) * | 2011-07-07 | 2013-01-10 | Atlantis Computing, Inc. | Deduplication of virtual machine files in a virtualized desktop environment |
US8396841B1 (en) * | 2010-11-30 | 2013-03-12 | Symantec Corporation | Method and system of multi-level and multi-mode cloud-based deduplication |
US8650159B1 (en) * | 2010-08-26 | 2014-02-11 | Symantec Corporation | Systems and methods for managing data in cloud storage using deduplication techniques |
US20140181236A1 (en) * | 2012-12-21 | 2014-06-26 | Atlantis Computing, Inc. | Systems and apparatuses for aggregating nodes to form an aggregated virtual storage for a virtualized desktop environment |
US20140196037A1 (en) * | 2013-01-09 | 2014-07-10 | The Research Foundation For The State University Of New York | Gang migration of virtual machines using cluster-wide deduplication |
US8898114B1 (en) * | 2010-08-27 | 2014-11-25 | Dell Software Inc. | Multitier deduplication systems and methods |
Family Cites Families (7)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8209506B2 (en) * | 2007-09-05 | 2012-06-26 | Emc Corporation | De-duplication in a virtualized storage environment |
US7937371B2 (en) * | 2008-03-14 | 2011-05-03 | International Business Machines Corporation | Ordering compression and deduplication of data |
US8898078B2 (en) * | 2010-05-21 | 2014-11-25 | Microsoft Corporation | Scalable billing with de-duplication in aggregator |
US9304867B2 (en) * | 2010-09-28 | 2016-04-05 | Amazon Technologies, Inc. | System and method for providing flexible storage and retrieval of snapshot archives |
US8402004B2 (en) * | 2010-11-16 | 2013-03-19 | Actifio, Inc. | System and method for creating deduplicated copies of data by tracking temporal relationships among copies and by ingesting difference data |
US8904126B2 (en) * | 2010-11-16 | 2014-12-02 | Actifio, Inc. | System and method for performing a plurality of prescribed data management functions in a manner that reduces redundant access operations to primary storage |
US9110604B2 (en) * | 2012-09-28 | 2015-08-18 | Emc Corporation | System and method for full virtual machine backup using storage system functionality |
-
2015
- 2015-02-13 US US14/622,487 patent/US20150227601A1/en not_active Abandoned
- 2015-02-13 US US14/622,479 patent/US20150227600A1/en not_active Abandoned
- 2015-02-13 WO PCT/US2015/015845 patent/WO2015123537A1/en active Application Filing
- 2015-02-13 US US14/622,492 patent/US20150227602A1/en not_active Abandoned
Patent Citations (6)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8650159B1 (en) * | 2010-08-26 | 2014-02-11 | Symantec Corporation | Systems and methods for managing data in cloud storage using deduplication techniques |
US8898114B1 (en) * | 2010-08-27 | 2014-11-25 | Dell Software Inc. | Multitier deduplication systems and methods |
US8396841B1 (en) * | 2010-11-30 | 2013-03-12 | Symantec Corporation | Method and system of multi-level and multi-mode cloud-based deduplication |
US20130013865A1 (en) * | 2011-07-07 | 2013-01-10 | Atlantis Computing, Inc. | Deduplication of virtual machine files in a virtualized desktop environment |
US20140181236A1 (en) * | 2012-12-21 | 2014-06-26 | Atlantis Computing, Inc. | Systems and apparatuses for aggregating nodes to form an aggregated virtual storage for a virtualized desktop environment |
US20140196037A1 (en) * | 2013-01-09 | 2014-07-10 | The Research Foundation For The State University Of New York | Gang migration of virtual machines using cluster-wide deduplication |
Cited By (38)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US10191685B2 (en) * | 2014-06-11 | 2019-01-29 | Hitachi, Ltd. | Storage system, storage device, and data transfer method |
US10078557B2 (en) | 2014-06-30 | 2018-09-18 | International Business Machines Corporation | Use of replicated copies to improve database backup performance |
US10108496B2 (en) | 2014-06-30 | 2018-10-23 | International Business Machines Corporation | Use of replicated copies to improve database backup performance |
US20160170837A1 (en) * | 2014-06-30 | 2016-06-16 | International Business Machines Corporation | Use of replicated copies to improve database backup performance |
US20160283506A1 (en) * | 2015-03-24 | 2016-09-29 | Datos IO Inc. | ON-THE-FLY DEDUPLICATION DURING DATA MOVEMENT FOR NoSQL DATA STORES |
US10459883B1 (en) | 2015-12-30 | 2019-10-29 | EMC IP Holding Company LLC | Retention policies for unscheduled replicas in backup, snapshots, and remote replication |
US20170192857A1 (en) * | 2015-12-30 | 2017-07-06 | Emc Corporation | Creating replicas at user-defined points in time |
US10496672B2 (en) * | 2015-12-30 | 2019-12-03 | EMC IP Holding Company LLC | Creating replicas at user-defined points in time |
US10997209B2 (en) | 2015-12-30 | 2021-05-04 | EMC IP Holding Company LLC | Creating replicas at user-defined points in time |
US9811281B2 (en) | 2016-04-07 | 2017-11-07 | International Business Machines Corporation | Multi-tenant memory service for memory pool architectures |
US10409509B2 (en) | 2016-04-07 | 2019-09-10 | International Business Machines Corporation | Multi-tenant memory service for memory pool architectures |
US10459961B2 (en) | 2016-04-19 | 2019-10-29 | Huawei Technologies Co., Ltd. | Vector processing for segmentation hash values calculation |
US10437817B2 (en) | 2016-04-19 | 2019-10-08 | Huawei Technologies Co., Ltd. | Concurrent segmentation using vector processing |
JP7113016B2 (en) | 2017-01-06 | 2022-08-04 | オラクル・インターナショナル・コーポレイション | File system data hierarchy cloud migration |
US11334528B2 (en) | 2017-01-06 | 2022-05-17 | Oracle International Corporation | ZFS block-level deduplication and duplication at cloud scale |
JP2020506461A (en) * | 2017-01-06 | 2020-02-27 | オラクル・インターナショナル・コーポレイション | File system hierarchy mirroring across cloud data stores |
US11755535B2 (en) | 2017-01-06 | 2023-09-12 | Oracle International Corporation | Consistent file system semantics with cloud object storage |
US11436195B2 (en) | 2017-01-06 | 2022-09-06 | Oracle International Corporation | Guaranteed file system hierarchy data integrity in cloud object stores |
US11422974B2 (en) | 2017-01-06 | 2022-08-23 | Oracle International Corporation | Hybrid cloud mirroring to facilitate performance, migration, and availability |
US11442898B2 (en) | 2017-01-06 | 2022-09-13 | Oracle International Corporation | File system hierarchies and functionality with cloud object storage |
JP2020506462A (en) * | 2017-01-06 | 2020-02-27 | オラクル・インターナショナル・コーポレイション | Cloud migration of file system data tier |
US11714784B2 (en) | 2017-01-06 | 2023-08-01 | Oracle International Corporation | Low-latency direct cloud access with file system hierarchies and semantics |
JP7098628B2 (en) | 2017-01-06 | 2022-07-11 | オラクル・インターナショナル・コーポレイション | File system hierarchy mirroring across cloud data stores |
US11308033B2 (en) | 2017-01-06 | 2022-04-19 | Oracle International Corporation | File system hierarchy mirroring across cloud data stores |
US11604583B2 (en) | 2017-11-28 | 2023-03-14 | Pure Storage, Inc. | Policy based data tiering |
US10990282B1 (en) | 2017-11-28 | 2021-04-27 | Pure Storage, Inc. | Hybrid data tiering with cloud storage |
US10936238B2 (en) | 2017-11-28 | 2021-03-02 | Pure Storage, Inc. | Hybrid data tiering |
US11609825B1 (en) | 2018-03-23 | 2023-03-21 | Veritas Technologies Llc | Systems and methods for backing-up an eventually-consistent database in a production cluster |
WO2019183423A1 (en) * | 2018-03-23 | 2019-09-26 | Veritas Technologies Llc | Systems and methods for backing-up an eventually-consistent database in a production cluster |
CN111771193A (en) * | 2018-03-23 | 2020-10-13 | 华睿泰科技有限责任公司 | System and method for backing up eventual consistent databases in a production cluster |
WO2019209392A1 (en) * | 2018-04-24 | 2019-10-31 | Pure Storage, Inc. | Hybrid data tiering |
US11436344B1 (en) | 2018-04-24 | 2022-09-06 | Pure Storage, Inc. | Secure encryption in deduplication cluster |
US11392553B1 (en) | 2018-04-24 | 2022-07-19 | Pure Storage, Inc. | Remote data management |
US11144572B2 (en) * | 2018-07-30 | 2021-10-12 | Hewlett Packard Enterprise Development Lp | Centralized configuration database cache |
US11709862B2 (en) | 2020-02-04 | 2023-07-25 | Grav1Ty Inc. | Selective synchronization of database objects |
WO2021158710A1 (en) * | 2020-02-04 | 2021-08-12 | Grav1Ty Inc. | Selective synchronization of database objects |
CN111355705A (en) * | 2020-02-08 | 2020-06-30 | 西安电子科技大学 | Data auditing and safety duplicate removal cloud storage system and method based on block chain |
EP4280077A1 (en) * | 2022-05-18 | 2023-11-22 | Snowflake Inc. | Data ingestion replication and disaster recovery |
Also Published As
Publication number | Publication date |
---|---|
WO2015123537A1 (en) | 2015-08-20 |
US20150227602A1 (en) | 2015-08-13 |
US20150227601A1 (en) | 2015-08-13 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US20150227600A1 (en) | Virtual data backup | |
US9384207B2 (en) | System and method for creating deduplicated copies of data by tracking temporal relationships among copies using higher-level hash structures | |
US9372758B2 (en) | System and method for performing a plurality of prescribed data management functions in a manner that reduces redundant access operations to primary storage | |
US9772916B2 (en) | Resiliency director | |
US10275474B2 (en) | System and method for managing deduplicated copies of data using temporal relationships among copies | |
US9372866B2 (en) | System and method for creating deduplicated copies of data by sending difference data between near-neighbor temporal states | |
US9880756B2 (en) | Successive data fingerprinting for copy accuracy assurance | |
US8299944B2 (en) | System and method for creating deduplicated copies of data storing non-lossy encodings of data directly in a content addressable store | |
US9858155B2 (en) | System and method for managing data with service level agreements that may specify non-uniform copying of data | |
US8788769B2 (en) | System and method for performing backup or restore operations utilizing difference information and timeline state information | |
US8396905B2 (en) | System and method for improved garbage collection operations in a deduplicated store by tracking temporal relationships among copies | |
US9563683B2 (en) | Efficient data replication | |
US20150161194A1 (en) | System and method for rapid estimation of data similarity | |
CA2817592A1 (en) | Systems and methods for data management virtualization |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: HERCULES TECHNOLOGY GROWTH CAPITAL, INC., AS AGENT, CALIFORNIAFree format text: SECURITY INTEREST;ASSIGNOR:ACTIFIO, INC.;REEL/FRAME:036106/0004Effective date: 20150714Owner name: HERCULES TECHNOLOGY GROWTH CAPITAL, INC., AS AGENTFree format text: SECURITY INTEREST;ASSIGNOR:ACTIFIO, INC.;REEL/FRAME:036106/0004Effective date: 20150714 |
|
AS | Assignment |
Owner name: SILICON VALLEY BANK, MASSACHUSETTSFree format text: SECURITY AGREEMENT;ASSIGNOR:ACTIFIO, INC.;REEL/FRAME:036113/0970Effective date: 20150714 |
|
AS | Assignment |
Owner name: ACTIFIO, INC., MASSACHUSETTSFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:RAMU, ASHOK;WOODWARD, MARK L.;ABERCROMBIE, PHILLIP J.;AND OTHERS;SIGNING DATES FROM 20160830 TO 20161105;REEL/FRAME:041240/0083 |
|
AS | Assignment |
Owner name: ACTIFIO, INC., MASSACHUSETTSFree format text: RELEASE BY SECURED PARTY;ASSIGNOR:HERCULES CAPITAL, INC. (FORMERLY KNOWN AS HERCULES TECHNOLOGY GROWTH CAPITAL, INC.);REEL/FRAME:042415/0395Effective date: 20170505Owner name: ACTIFIO, INC., MASSACHUSETTSFree format text: RELEASE BY SECURED PARTY;ASSIGNOR:SILICON VALLEY BANK;REEL/FRAME:042415/0317Effective date: 20170505 |
|
AS | Assignment |
Owner name: CRESTLINE DIRECT FINANCE, L.P., AS ADMINISTRATIVE AGENT, COLLATERAL AGENT AND SOLE LEAD ARRANGER, TEXASFree format text: SECURITY INTEREST;ASSIGNOR:ACTIFIO, INC.;REEL/FRAME:046702/0543Effective date: 20180802Owner name: CRESTLINE DIRECT FINANCE, L.P., AS ADMINISTRATIVEFree format text: SECURITY INTEREST;ASSIGNOR:ACTIFIO, INC.;REEL/FRAME:046702/0543Effective date: 20180802 |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: DOCKETED NEW CASE - READY FOR EXAMINATION |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: NON FINAL ACTION MAILED |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: RESPONSE TO NON-FINAL OFFICE ACTION ENTERED AND FORWARDED TO EXAMINER |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: FINAL REJECTION MAILED |
|
AS | Assignment |
Owner name: ACTIFIO, INC., MASSACHUSETTSFree format text: RELEASE BY SECURED PARTY;ASSIGNOR:CRESTLINE DIRECT FINANCE, L.P., AS COLLATERAL AGENT;REEL/FRAME:053483/0084Effective date: 20200522 |
|
STCB | Information on status: application discontinuation |
Free format text: ABANDONED -- FAILURE TO RESPOND TO AN OFFICE ACTION |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:ACTIFIO, INC.;REEL/FRAME:056911/0517Effective date: 20210316 |