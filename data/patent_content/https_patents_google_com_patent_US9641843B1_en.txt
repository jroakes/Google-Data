CROSS-REFERENCE TO RELATED APPLICATION(S)
This application is a continuation of U.S. patent application Ser. No. 14/293,304, filed Jun. 2, 2014, the content of which is incorporated herein in its entirety by reference.
BACKGROUND
Digital video streams typically represent video using a sequence of frames or still images. Each frame can include a number of blocks, which in turn may contain information describing the value of color, brightness or other attributes for pixels. The amount of data in a typical video stream is large, and transmission and storage of video can use significant computing or communications resources. Various approaches have been proposed to reduce the amount of data in video streams, including compression and other encoding techniques. Real-time video streaming, multi-point video conferencing or video broadcasting are examples of applications that employ video stream encoding including compression. In addition to the resources required for storage and transmission of encoded video streams, the encoding itself can require computing resources.
SUMMARY
This disclosure relates in general to encoding and decoding visual data, such as video stream data using adaptive source variance based partitioning. One method taught herein describes receiving a partitioned current frame from an encoded bitstream, and decoding the partitioned current frame. The partitioned current frame is generated by source difference variance based partitioning comprising, for blocks of a current frame used to generate the partitioned current frame, partitioning a block into first partitioned blocks having a first partition size, the block having a size at least as large as the first partition size and the first partition size corresponding to one of at least two available partition sizes, and, for a first partitioned block having the first partition size, calculating a variance value based on differences between pixels of a first partitioned block and pixels of a spatially correspondent block in a previous frame, if the variance value for the first partitioned block is within a first defined range, selecting the first partition size for the pixels of the first partitioned block, and if the variance value for the first partitioned block is outside the first defined range, selecting a smaller partition size than the first partition size for the pixels of the first partitioned block. The partitioned current frame is generated by partitioning the current frame according to one or more selected partition sizes for the blocks of the current frame.
An apparatus described herein includes a memory and a processor. According to one implementation, the processor is configured to execute instructions stored in the memory to receive a partitioned current frame from an encoded bitstream, the partitioned current frame generated by source difference variance based partitioning, and decode the partitioned current frame. The source difference variance based partitioning includes, for blocks of a current frame used to generate the partitioned current frame, partitioning a block into first partitioned blocks having a first partition size, the block having a size at least as large as the first partition size and the first partition size corresponding to one of at least two available partition sizes, and, for a first partitioned block having the first partition size, calculating a variance value based on differences between pixels of a first partitioned block and pixels of a spatially correspondent block in a previous frame, if the variance value for the first partitioned block is within a first defined range, selecting the first partition size for the pixels of the first partitioned block, and if the variance value for the first partitioned block is outside the first defined range, selecting a smaller partition size than the first partition size for the pixels of the first partitioned block. The partitioned current frame is generated by partitioning the current frame according to one or more selected partition sizes for the blocks of the current frame.
According to another implementation of an apparatus described herein, the processor is configured to execute instructions stored in the memory to receive a partitioned current frame from an encoded bitstream, the partitioned current frame generated by source difference variance based partitioning of a current frame, and decoding the partitioned current frame. The source difference variance based partitioning includes partitioning a block of the current frame into first partitioned blocks having a first partition size, the block having a size at least as large as the first partition size and the first partition size corresponding to one of at least two available partition sizes, calculating a variance value for a first partitioned block based on differences between pixels of the first partitioned block and pixels of a spatially correspondent block in a previous frame, selecting the first partition size for the first partitioned block if the variance value is within a first defined range and no larger partition size that the first partition size is available, selecting the first partition size for the first partitioned block if the variance value is outside of the first defined range and no smaller partition size that the first partition size is available, partitioning the block using a larger partition size than the first partition size if the variance value is within the first defined range and the larger partition size is available, and partitioning the block using a smaller partition size than the first partition size if the variance value is outside of the first defined range and the smaller partition size is available.
Variations in these and other aspects of this disclosure will be described in additional detail hereafter.
BRIEF DESCRIPTION OF THE DRAWINGS
The description herein makes reference to the accompanying drawings wherein like reference numerals refer to like parts throughout the several views unless otherwise noted
FIG. 1 is a schematic of a video encoding and decoding system.
FIG. 2 is a block diagram of an exemplary computing device that can implement a transmitting station or a receiving station.
FIG. 3 is a diagram of a typical video stream to be encoded and subsequently decoded.
FIG. 4 is a block diagram of a video compression system in according to an aspect of the teachings herein.
FIG. 5 is a block diagram of a video decompression system according to another aspect of the teachings herein.
FIG. 6 is a diagram showing partitions of video data used to explain the teachings herein.
FIG. 7 is a flowchart diagram of a process for partitioning video frames of a video stream for encoding using adaptive source variance-based partitioning.
FIG. 8 is a flowchart diagram of a process for partitioning blocks of a video frame according to an aspect of the teachings herein.
FIG. 9 is a flowchart diagram of a process for partitioning blocks of a video frame according to another aspect of the teachings herein.
FIG. 10 is a flowchart diagram of a process for partitioning blocks of a video frame according to another aspect of the teachings herein.
DETAILED DESCRIPTION
A video stream may be compressed by a variety of techniques to reduce bandwidth required transmit or store the video stream. A video stream can be encoded into a bitstream, which can involve compression, and then transmitted to a decoder that can decode or decompress the video stream to prepare it for viewing or further processing. Encoding a video stream can involve parameters that make trade-offs between video quality and bitstream size, where increasing the perceived quality of a decoded video stream can increase the number of bits required to transmit or store the bitstream.
A video frame can be partitioned into rectangular or square partitions or blocks as part of the encoding process. FIG. 6 is a diagram of a portion 600 of a video frame partitioned into smaller blocks. In this example, portion 600 forms a block with dimensions of 64 pixels by 64 pixels. Portion 600 as shown is partitioned into one 32×32 block 602, two 32×16 blocks 604, two 16×32 blocks 606, two 16×16 blocks 608, two 16×8 blocks 610 and two 8×8 blocks 612 and eight 4×4 blocks 614. “Partitioning” may be defined as dividing a subset of the pixels of a video frame into an arrangement of blocks of possibly varying sizes such that the blocks tile the video frame with contiguous, non-overlapping blocks that include all of the subset of pixels.
Determination of the optimal partitioning scheme for a video frame can be a computationally-intensive process. For example, an encoder may use a rate/distortion (RD) loop that determines a trade-off between video quality and bitstream size by forming all possible partitioning schemes, encoding each and calculating a “rate” or bitstream size of each with an associated level of “distortion” or error in video quality. The partitioning scheme that results in best video quality at a given compression rate is generally selected from the available partitioning schemes. This process may consume up to 50% of the computing time required to encode a video stream. As such, it is not generally suitable for real-time situations such as video conferencing and live streaming, where low-latency, fast encoding is critical.
Fixed partitioning, i.e., where the same size blocks are always used, is an option for real-time coding, but fixed partitioning does not always give the best encoding result since any individual partition may have pixels exhibiting static or slow-motion as well as pixels exhibiting fast-motion. An alternative option is to reduce the amount of time spent in the partitioning process while still attempting to obtain some of the benefits of partitioning. For example, the RD loop may not be performed for every frame. The last frame's partitioning may be copied and used for the current frame in one such case. This technique can result in imprecise partitioning when the current frame has different motion from the last frame. In a different technique, the current frame may be compared with a reconstructed last frame to decide partitioning. Where the reconstructed last frame is used as a reference frame in encoding, it is convenient to use it for the partitioning decision. However, the reconstructed frame possesses encoding errors due to the, e.g. lossy, compression used in its encoding. The differences between it and the current frame are attributable to both motion and encoding errors, and therefore do not provide a correct indicator of the actual motion in the current frame.
In contrast, the teachings herein describe a novel adaptive partitioning that is based on the variance of a source difference. Broadly, variances are measured between the current raw or unencoded video frame and a temporally nearby raw or unencoded video frame on a block-by-block basis to determine a partition scheme for blocks of a frame. The result is improved real-time encoding performance over existing techniques that achieves the goals of fast encoding and good compressed video quality. Further details are described after an initial discussion of the environment in which the teachings herein may be used.
FIG. 1 is a schematic of a video encoding and decoding system 100. An exemplary transmitting station 112 can be, for example, a computer having an internal configuration of hardware such as that described in FIG. 2. However, other suitable implementations of transmitting station 112 are possible. For example, the processing of transmitting station 112 can be distributed among multiple devices.
A network 128 can connect transmitting station 112 and a receiving station 130 for encoding and decoding of the video stream. Specifically, the video stream can be encoded in transmitting station 112 and the encoded video stream can be decoded in receiving station 130. Network 128 can be, for example, the Internet. Network 128 can also be a local area network (LAN), wide area network (WAN), virtual private network (VPN), cellular telephone network or any other means of transferring the video stream from transmitting station 112 to, in this example, receiving station 130.
Receiving station 130, in one example, can be a computer having an internal configuration of hardware such as that described in FIG. 2. However, other suitable implementations of receiving station 130 are possible. For example, the processing of receiving station 130 can be distributed among multiple devices.
Other implementations of video encoding and decoding system 100 are possible. For example, an implementation can omit network 128. In another implementation, a video stream can be encoded and then stored for transmission at a later time to receiving station 130 or any other device having memory. In one implementation, receiving station 130 receives (e.g., via network 128, a computer bus, and/or some communication pathway) the encoded video stream and stores the video stream for later decoding. In an exemplary implementation, a real-time transport protocol (RTP) is used for transmission of the encoded video over network 128. In another implementation, a transport protocol other than RTP may be used, e.g., an HTTP-based video streaming protocol.
When used in a video conferencing system, for example, transmitting station 112 and/or receiving station 130 may include the ability to both encode and decode a video stream as described below. For example, receiving station 130 could be a video conference participant who receives an encoded video bitstream from a video conference server (e.g., transmitting station 112) to decode and view and further encodes and transmits its own video bitstream to the video conference server for decoding and viewing by other participants.
FIG. 2 is a block diagram of an exemplary computing device 200 that can implement a transmitting station or a receiving station. For example, computing device 200 can implement one or both of transmitting station 112 and receiving station 130 of FIG. 1. Computing device 200 can be in the form of a computing system including multiple computing devices, or in the form of a single computing device, for example, a mobile phone, a tablet computer, a laptop computer, a notebook computer, a desktop computer, and the like.
A CPU 224 in computing device 200 can be a conventional central processing unit. Alternatively, CPU 224 can be any other type of device, or multiple devices, capable of manipulating or processing information now-existing or hereafter developed. Although the disclosed implementations can be practiced with a single processor as shown, e.g., CPU 224, advantages in speed and efficiency can be achieved using more than one processor.
A memory 226 in computing device 200 can be a read only memory (ROM) device or a random access memory (RAM) device in an implementation. Any other suitable type of storage device can be used as memory 226. Memory 226 can include code and data 227 that is accessed by CPU 224 using a bus 230. Memory 226 can further include an operating system 232 and application programs 234, the application programs 234 including at least one program that permits CPU 224 to perform the methods described here. For example, application programs 234 can include applications 1 through N, which further include a video coding application that performs the methods described here. Computing device 200 can also include a secondary storage 236, which can, for example, be a memory card used with a mobile computing device 200. Because the video communication sessions may contain a significant amount of information, they can be stored in whole or in part in secondary storage 236 and loaded into memory 226 as needed for processing.
Computing device 200 can also include one or more output devices, such as a display 228. Display 228 may be, in one example, a touch sensitive display that combines a display with a touch sensitive element that is operable to sense touch inputs. Display 228 can be coupled to CPU 224 via bus 230. Other output devices that permit a user to program or otherwise use computing device 200 can be provided in addition to or as an alternative to display 228. When the output device is or includes a display, the display can be implemented in various ways, including by a liquid crystal display (LCD), a cathode-ray tube (CRT) display or light emitting diode (LED) display, such as an OLED display.
Computing device 200 can also include or be in communication with an image-sensing device 238, for example a camera, or any other image-sensing device 238 now existing or hereafter developed that can sense an image such as the image of a user operating computing device 200. Image-sensing device 238 can be positioned such that it is directed toward the user operating computing device 200. In an example, the position and optical axis of image-sensing device 238 can be configured such that the field of vision includes an area that is directly adjacent to display 228 and from which display 228 is visible.
Computing device 200 can also include or be in communication with a sound-sensing device 240, for example a microphone, or any other sound-sensing device now existing or hereafter developed that can sense sounds near computing device 200. Sound-sensing device 240 can be positioned such that it is directed toward the user operating computing device 200 and can be configured to receive sounds, for example, speech or other utterances, made by the user while the user operates computing device 200.
Although FIG. 2 depicts CPU 224 and memory 226 of computing device 200 as being integrated into a single unit, other configurations can be utilized. The operations of CPU 224 can be distributed across multiple machines (each machine having one or more of processors) that can be coupled directly or across a local area or other network. Memory 226 can be distributed across multiple machines such as a network-based memory or memory in multiple machines performing the operations of computing device 200. Although depicted here as a single bus, bus 230 of computing device 200 can be composed of multiple buses. Further, secondary storage 236 can be directly coupled to the other components of computing device 200 or can be accessed via a network and can comprise a single integrated unit such as a memory card or multiple units such as multiple memory cards. Computing device 200 can thus be implemented in a wide variety of configurations.
FIG. 3 is a diagram of an example of a video stream 350 to be encoded and subsequently decoded. Video stream 350 includes a video sequence 352. At the next level, video sequence 352 includes a number of adjacent frames 354. While three frames are depicted as adjacent frames 354, video sequence 352 can include any number of adjacent frames 354. Adjacent frames 354 can then be further subdivided into individual frames, e.g., a single frame 356. At the next level, a single frame 356 can be divided into a series of segments or planes 358. Segments (or planes) 358 can be subsets of frames that permit parallel processing, for example. Segments 358 can also be subsets of frames that can separate the video data into separate colors. For example, a frame 356 of color video data can include a luminance plane and two chrominance planes. Segments 358 may be sampled at different resolutions.
Whether or not frame 356 is divided into segments 358, frame 356 may be further subdivided into blocks 360, which can contain data corresponding to, for example, 16×16 pixels in frame 356. Blocks 360 can also be arranged to include data from one or more planes of pixel data. Blocks 360 can also be of any other suitable size such as 4×4 pixels, 8×8 pixels, 16×8 pixels, 8×16 pixels, 16×16 pixels or larger. Unless otherwise noted, the terms block and macroblock are used interchangeably herein. Frame 356 may be partitioned according to the teachings herein as discussed in more detail below.
FIG. 4 is a block diagram of an encoder 470 in accordance with an implementation. Encoder 470 can be implemented, as described above, in transmitting station 112 such as by providing a computer software program stored in memory, for example, memory 226. The computer software program can include machine instructions that, when executed by a processor such as CPU 224, cause transmitting station 112 to encode video data in the manner described in FIG. 4. Encoder 470 can also be implemented as specialized hardware included in, for example, transmitting station 112. Encoder 470 has the following stages to perform the various functions in a forward path (shown by the solid connection lines) to produce an encoded or compressed bitstream 488 using input video stream 350: an intra/inter prediction stage 472, a transform stage 474, a quantization stage 476, and an entropy encoding stage 478. Encoder 470 may also include a reconstruction path (shown by the dotted connection lines) to reconstruct a frame for encoding of future blocks. In FIG. 4, encoder 470 has the following stages to perform the various functions in the reconstruction path: a dequantization stage 480, an inverse transform stage 482, a reconstruction stage 484, and a loop filtering stage 486. Other structural variations of encoder 470 can be used to encode video stream 350.
When video stream 350 is presented for encoding, each frame 356 can be processed in units of blocks. At intra/inter prediction stage 472, each block can be encoded using intra-frame prediction (also called intra prediction) or inter-frame prediction (also called inter prediction). In any case, a prediction block can be formed. In the case of intra-prediction, a prediction block may be formed from samples in the current frame that have been previously encoded and reconstructed. In the case of inter-prediction, a prediction block may be formed from samples in one or more previously constructed reference frames. The blocks are predicted as partitioned according to the teachings herein in a separate process before the prediction of inter/intra prediction stage 472 and may be performed within the inter/inter prediction stage 472.
Next, still referring to FIG. 4, the prediction block can be subtracted from the current block at intra/inter prediction stage 472 to produce a residual block (also called a residual). Transform stage 474 transforms the residual into transform coefficients in, for example, the frequency domain. Examples of block-based transforms include the Karhunen-Loève Transform (KLT), the Discrete Cosine Transform (DCT), the Singular Value Decomposition Transform (SVD) and the Asymmetric Discrete Sine Transform (ADST). In one example, the DCT transforms the block into the frequency domain. In the case of DCT, the transform coefficient values are based on spatial frequency, with the lowest frequency (DC) coefficient at the top-left of the matrix and the highest frequency coefficient at the bottom-right of the matrix. Note that the size of the prediction block may be different from the size of the transform block.
Quantization stage 476 converts the transform coefficients into discrete quantum values, which are referred to as quantized transform coefficients, using a quantizer value or a quantization level. For example, the transform coefficients may be divided by the quantizer value and truncated. The quantized transform coefficients are then entropy encoded by entropy encoding stage 478 as discussed in additional detail herein. The entropy-encoded coefficients, together with other information used to decode the block, which may include for example the type of prediction used, motion vectors and quantizer value, are then output to the compressed bitstream 488. Compressed bitstream 488 can be formatted using various techniques, such as variable length coding (VLC) or arithmetic coding. Compressed bitstream 488 can also be referred to as an encoded video stream or encoded video bitstream, and the terms will be used interchangeably herein.
The reconstruction path in FIG. 4 (shown by the dotted connection lines) can be used to ensure that both encoder 470 and a decoder 500 (described below) use the same reference frames to decode compressed bitstream 488. The reconstruction path performs functions that are similar to functions that take place during the decoding process that are discussed in more detail below, including dequantizing the quantized transform coefficients at dequantization stage 480 and inverse transforming the dequantized transform coefficients at inverse transform stage 482 to produce a derivative residual block (also called a derivative residual). At reconstruction stage 484, the prediction block that was predicted at intra/inter prediction stage 472 can be added to the derivative residual to create a reconstructed block. Loop filtering stage 486 can be applied to the reconstructed block to reduce distortion such as blocking artifacts.
Other variations of encoder 470 can be used to encode compressed bitstream 488. For example, a non-transform based encoder 470 can quantize the residual signal directly without transform stage 474 for certain blocks or frames. In another implementation, an encoder 470 can have quantization stage 476 and dequantization stage 480 combined into a single stage.
FIG. 5 is a block diagram of a decoder 500 in accordance with another implementation. Decoder 500 can be implemented in receiving station 130, for example, by providing a computer software program stored in memory 226. The computer software program can include machine instructions that, when executed by a processor such as CPU 224, cause receiving station 130 to decode video data in the manner described in FIG. 5. Decoder 500 can also be implemented in hardware included in, for example, transmitting station 112 or receiving station 130. Decoder 500, similar to the reconstruction path of encoder 470 discussed above, includes in one example the following stages to perform various functions to produce an output video stream 516 from compressed bitstream 488: an entropy decoding stage 502, a dequantization stage 504, an inverse transform stage 506, an intra/inter prediction stage 508, a reconstruction stage 510, a loop filtering stage 512 and a deblocking filtering stage 514. Other structural variations of decoder 500 can be used to decode compressed bitstream 488.
When compressed bitstream 488 is presented for decoding, the data elements within compressed bitstream 488 can be decoded by entropy decoding stage 502 as discussed in additional detail herein to produce a set of quantized transform coefficients. Dequantization stage 504 dequantizes the quantized transform coefficients (e.g., by multiplying the quantized transform coefficients by the quantizer value), and inverse transform stage 506 inverse transforms the dequantized transform coefficients to produce a derivative residual that can be identical to that created by inverse transform stage 482 in encoder 470. Using header information decoded from compressed bitstream 488, decoder 500 can use intra/inter prediction stage 508 to create the same prediction block as was created in encoder 470, e.g., at intra/inter prediction stage 472. At reconstruction stage 510, the prediction block can be added to the derivative residual to create a reconstructed block. Loop filtering stage 512 can be applied to the reconstructed block to reduce blocking artifacts. Other filtering can be applied to the reconstructed block. In this example, deblocking filtering stage 514 is applied to the reconstructed block to reduce blocking distortion, and the result is output as output video stream 516. Output video stream 516 can also be referred to as a decoded video stream, and the terms will be used interchangeably herein.
Other variations of decoder 500 can be used to decode compressed bitstream 488. For example, decoder 500 can produce output video stream 516 without deblocking filtering stage 514.
As mentioned above, partitioning large blocks of a video frame into smaller blocks of different dimensions may result in fast, efficient encoding with good image quality. The strategies to partition the frame herein are initially described with respect to a specific example, but are not limited thereto. Generally, the determination of the partitioning scheme for the current frame starts with comparing a block of a current video frame with a corresponding block from a previous video frame. Each of these frames may be referred to as source frames as they include raw, unencoded data—not reconstructed data generated from previously-encoded frames. For purposes of explanation, a block is referred to as a superblock herein when it has a block size of 64×64 pixels. The partitioning may be decided at more than one block size level. The block levels may be selected based on the minimum partition size and the maximum partition size. For example, where the frame is processed by groups of pixels forming superblocks, and the smallest partition is 8×8 pixels, the partitioning may be decided at three block size levels: 16×16 pixels, 32×32 pixels and 64×64 pixels. As described in additional detail hereinafter, the variances of the source differences at the different block size levels are compared to thresholds to decide whether the superblock is formed of 8×8 partitions, 16×16 partitions, 32×32 partitions and/or a 64×64 partition. The thresholds may be based on the noise level in the source video and selected such that smaller variances result in larger partitions. This is referred to as source difference variance based partitioning hereinafter and is described in additional detail below.
Source difference variance based partitioning can improve encoder performance if there is at least one relatively large static or slow motion area in a frame. If, however, there is no such area, the source difference variance based partitioning will result in using small partition sizes most of the time. The encoder performance will not be improved to any significant degree over using a fixed small partition size such as 16×16. Accordingly, an adaptive partitioning method that switches between fixed partitioning and source difference variance based partitioning is described with reference to FIG. 7.
FIG. 7 is a flowchart diagram of a process 700 for partitioning video frames of a video stream for encoding using adaptive source variance-based partitioning. Process 700 can be implemented in a system such as computing device 200 to aid the encoding of a video stream. Process 700 can be implemented, for example, as a software program that is executed by a computing device such as transmitting station 112 or receiving station 130. The software program can include machine-readable instructions that are stored in a memory such as memory 226 that, when executed by a processor such as CPU 224, cause the computing device to perform process 700. Process 700 can also be implemented using hardware in whole or in part. As explained above, some computing devices may have multiple memories and multiple processors, and the steps of process 700 may in such cases be distributed using different processors and memories. Use of the terms “processor” and “memory” in the singular herein encompasses computing devices that have only one processor or one memory as well as devices having multiple processors or memories that may each be used in the performance of some but not necessarily all recited steps.
For simplicity of explanation, process 700 is depicted and described as a series of steps. However, steps in accordance with this disclosure can occur in various orders and/or concurrently. Additionally, steps in accordance with this disclosure may occur with other steps not presented and described herein. Furthermore, not all illustrated steps may be required to implement a method in accordance with the disclosed subject matter. Process 700 assumes that a previous unencoded frame of video data is available in addition to the current unencoded frame of video data. Process 700 uses these unencoded or source frames in order to obtain an accurate measure of the variance. As mentioned briefly above, encoding a frame followed by decoding can create an approximation of the original frame that may alter the video data enough to cause the variance measure to become less indicative of the contents of the video frame than source original unencoded data.
Process 700 receives frames of video data from a video stream in the order in which they occur in the video stream. Some frames are processed using full source difference partitioning and some frames are processed using partition information from a previous frame. Broadly, as long as the previous frame was partitioned into at least a minimum number (e.g., s percentage) of relatively large blocks, the current frame is processed using source difference variance based partitioning. Where the previous frame was partitioned into fewer than the minimum percentage of relatively large blocks (e.g., many small blocks are in the partitioning), fixed partitioning is used for the current frame without calculating the variances. Process 700 also periodically forces frames at a frame interval n to undergo source difference variance based partitioning. In this way, process 700 switches between fixed partitioning and source difference variance based partitioning adaptively according to how large the static or slow motion areas are in a frame. Moreover, parts of a video sequence may contain fast motion, while others contain slow motion. Different partitioning methods are thus desirably applied to different parts of the video. Re-evaluating motion every n frames addresses such a concern. Process 700 performs this process by using a modulo function as described hereinafter. However, this is only one example of a technique to achieve the goal of partitioning frames in a video stream using source difference variance based partitioning to improve encoder performance without calculating variances for every frame.
At the start of process 700, initialization occurs. During initialization, frame interval n may be set. Frame interval n is a positive integer and may be as small as 1. A more desirable value is, for example, 10 and could depend on the expected motion within the frame. Video streams with a lot of motion may desirably use lower values of frame interval n than video streams with little motion. In addition, a variable referred to herein as LARGE_PARTITION_USE, which stores the percentage of blocks in a frame that use partition sizes that are larger than a minimum partition size can be defined and initialized. This variable accumulates a count equal to the number of blocks of a frame determined to use a large partition size by the source difference variance based partitioning described in detail below with respect to FIGS. 8, 9 and 10. It is compared to another variable, threshold T, described in more detail below. LARGE_PARTITION_USE may be initialized to zero at the beginning of processing a video stream. Finally, a successive integer i is assigned to each video frame of a video stream by process 700 as it is received. This index i keeps track of the frame interval for motion checking. By performing a source difference variance based partitioning at fixed intervals, process 700 can accommodate motion in the input video frames while avoiding having to check for motion in every frame, which can take additional processing time without providing further encoding efficiencies.
At step 702, a current frame of video data with index i is selected from a video stream. Process 700 as shown assumes that index i is greater than 0. At step 704, the value 1 is subtracted from index i, and the modulus of i−1 with respect to frame interval n is formed. If (i−1) mod n=0, then the current frame index minus 1 is an integer multiple of n. Process 700 advances to step 706 to perform source difference variance based partitioning at described in more detail with respect to FIGS. 8, 9 and 10. The blocks that use partition sizes of equal to or greater than a relatively large partition size, for example partition sizes equal to or greater than 32×32 pixels when the frame is processed in units of superblocks, are accumulated to set the value LARGE_PARTITION_USE at step 708, replacing any previous value.
If, at step 704, i−1 mod n≠0, then i−1 mod n≧0 at step 710. Process 700 advances to step 712 to compare LARGE_PARTITION_USE to threshold T. If LARGE_PARTITION_USE is greater than or equal to threshold T, process 700 branches to step 706 to perform source difference variance based partitioning. If LARGE_PARTITION_USE is less than threshold T at step 712, process 700 advances to step 714. The current frame (index i) is partitioned using fixed partitioning. For example, superblocks of a frame comprising 64×64 pixels may each be partitioned into sub-blocks of the same dimensions, such 16×16 pixels. Another option is to use the partitions generated for the most recent previous frame by the source difference variance based partitioning for the superblocks of the current frame. Threshold T can be selected to balance processing time against increased coding efficiency due to better partitioning based on experience or experimentation. One possible value of threshold T is 15%.
Whether a frame is subjected to source difference variance based partitioning in step 706 or to fixed partitioning in step 714, process 700 checks to see whether the current frame is the last frame of the video stream at step 716. If not, process 700 repeats for the next frame by incrementing i at step 718 and selecting the next frame i as the current frame. If the current frame is the last frame at step 716, process 700 ends. Either after or concurrently with process 700, each frame after partitioning is encoded into a bitstream, such as compressed bitstream 488, for storage or transmission as described above. Namely, the partitions may be inter- or intra-predicted to generate respective prediction blocks. The resulting residuals are then transformed and quantized, or quantized only, before being provided to entropy coding stage 478 of encoder 470 for coding into bitstream 488.
The source difference variance based partitioning of step 706 is next described with respect to FIGS. 8, 9 and 10. Each is a flowchart diagram of a respective process 800, 900, 1000 for partitioning blocks of a video frame according to aspects of the teachings herein. These figures collectively provide an example of processing a basic encoding unit of 64 pixels×64 pixels, herein referred to as a superblock, using source difference variance based partitioning. In this example, processes 800, 900 and 1000 are nested loops whereby process 800 is called at step 906 of process 900, and process 900 is called at step 1002 of process 1000 to partition a frame. This is not required, however. Process 800 may occur before the start of process 900, and process 900 may occur before the start of process 1000, with the results stored and updated for each subsequent process before encoding an entire frame. Accordingly, references to first, second and third partitioned blocks and first, second and third partition sizes are intended to distinguish one reference from the others for clarity and are not intended to refer to any sequence in processing or to any particular size value. Moreover, not all of processes 800, 900 and 1000 may need to be performed, or one or more of processes 800, 900 and 1000 may need to be repeated, when using a different basic encoding unit or a smaller minimum partition size as discussed in more detail below.
Referring first to FIG. 8, process 800 can be implemented, for example, as a software program that is executed by a computing device such as transmitting station 112 or receiving station 130. The software program can include machine-readable instructions that are stored in a memory such as memory 226 that, when executed by a processor such as CPU 224, cause the computing device to perform process 800. Process 800 can also be implemented using hardware in whole or in part. As explained above, some computing devices may have multiple memories and multiple processors, and the steps of process 800 may in such cases be distributed using different processors and memories.
At step 802, process 800 partitions blocks of the current frame (e.g., from step 706 of FIG. 7) into a first partition size and initializes an index (or count) for the first partitioned blocks. The first partition size may be a size larger than the minimum partition size for a block. In this example, the minimum partition size is 8×8 pixels, so the partition size is 16×16 pixels. Further, since process 800 is a step within process 900 in this example, it partitions only a single 32×32-pixel block and is repeated each time called within process 900. Variations are possible. For example, if there were only two partition sizes, only process 800 would be used with a first partition size equal to the largest partition (i.e., the size of the basic encoding unit). During this process, and the subsequent encoding of the current frame, the last source (i.e., unencoded frame) needs to be available. Accordingly, it is desirable to create, in or in communication with the encoder, a 2-frame circular buffer to store the last source frame and the current source frame. The current frame, when read in the buffer, would overwrite the frame before the last frame instead of the last frame. This makes the last (or previous) source frame available during encoding of the current frame.
At step 804, the index value index_16×16 is queried to see if all four first partitioned blocks have been tested. If index_16×16 is four or more, process 800 exits or ends because all blocks of the first partition process have been considered. Where process 800 is nested in process 900, control passes back to process 900. Otherwise, process 800 advances to step 806 to determine whether the current partitioned block may be partitioned using a smaller partition size. At step 806, the variance for the current block, variance_16×16, can be calculated using a spatially-correspondent block from a previous video frame. The previous video frame is desirably the temporally adjacent previous frame to the current frame. The variance of a block may be calculated using pixel-by-pixel differences between spatially-correspondent pixels of the two blocks. For example, the variance of an M×M block is calculated as
where SSD is the sum of squared source differences and Mean is the average of the source differences. However, any measure of dispersion applied to the difference between the blocks can be used.
At step 808, the calculated variance_16×16 is compared to a first range. Here, since the variance is always a positive value, the range is represented by a comparison to a threshold T1. If variance_16×16 is less than the first threshold T1, the partition size is set to (maintained at) 16×16 in step 810, otherwise the 16×16 block can be partitioned into four 8×8 blocks. The partition size is set to the smaller partition size at step 812. Regardless of whether the partition size is set at step 810 or step 812, process 800 advances to step 814 to increment index_16×16 to repeat steps 804-812 for the next one of the first partitioned blocks.
Process 900, like process 800, can be implemented as a software program that is executed by a computing device such as transmitting station 112 or receiving station 130. The software program can include machine-readable instructions that are stored in a memory such as memory 226 that, when executed by a processor such as CPU 224, cause the computing device to perform process 900. Process 900 can also be implemented using hardware in whole or in part. The steps of process 900 may be distributed using different processors and memories.
At step 902, process 900 partitions blocks of the current frame (e.g., from step 706 of FIG. 7) into a second partition size that is the next larger available partition size than the first partition size and initializes an index (or count) for the second partitioned blocks. In this example, the second partition size is 32×32 pixels. Since process 900 is a step within process 1000 in this example, it partitions only a single 64×64-pixel block and is repeated each time called within process 1000. Variations are possible. For example, if there were only three partition sizes, only processes 800 and 900 would be used with the second partition size equal to the largest partition (i.e., the size of the basic encoding unit) and the first partition size equal to the next smaller available partition size. For example, if the basic encoding unit were 32×32 pixels, process 900 could be performed for each 32×32-pixel block of the current frame (i.e., not just four at step 904) without performing process 1000. In another example, if the basic encoding unit were 16×16 pixels, and partition sizes of 4×4 pixels and 8×8 pixels were available, process 800 could be performed with a first partition size of 8×8 pixels (and smaller partition size 4×4 pixels at step 812) with an appropriate value to check the index and process 900 could be performed with a second partition size of 16×16 pixels with an appropriate value to check the index.
At step 904, the value of index_32×32 is queried to see if it is less than four, where the first of the four partitioned 32×32-pixel blocks is identified with index_32×32=0. If not, process 900 ends or exits. In this example, control passes to back to step 1004 of FIG. 10. If the value is less than four, process 900 calls process 800 at step 906. At the end of step 906, process 800 has generated variance values for all 16×16-pixel blocks forming the current partitioned block of 32×32 pixels. At step 908, these values are compared to a second range, here a second threshold T2 due to the positive values for the variances. If any of the variance values are greater than threshold T2, process 900 takes no action for the current partitioned block and advances to step 912 to increment index_32×32 to start process 900 for the next partitioned block. Essentially, this leaves the partition sizes selected in process 800 unchanged for the current block of 32×32 pixels.
In contrast, if all of the 16×16 variance values are less than threshold T2, process 900 advances to step 910. At step 910, the partition size is set to 32×32 for the current block of 32×32 pixels. In other words, the partition size(s) for the blocks that result from process 800 are replaced with a single partition. This may be considered to be combining the smaller partitioned blocks into one larger partition to form a larger static or slow motion area in the video. The second range should be tighter than the first range. In this example, the per-pixel variance reflected by the value of threshold T2 should be lower than that reflected by the value of threshold T1.
If process 900 is not the larger process in the partitioning (i.e., process 900 is not performed for the largest available partition size), the variance value for the current 32×32-pixel block can be determined from the four 16×16 variances of the 16×16 blocks that comprise the 32×32 block, thereby saving calculation time and resources. This value variance_32×32 would be used for the next partitioning process, here process 1000. Following step 910, process 900 advances to step 912 to increment index_32×32 to begin process 900 for the next block, if any. In this example, once all four 32×32-pixel blocks of a 64×64-pixel superblock have been processed, process 900 ends by exiting to step 1004 of process 1000.
Process 1000, like processes 800 and 900, can be implemented as a software program that is executed by a computing device such as transmitting station 112 or receiving station 130. The software program can include machine-readable instructions that are stored in a memory such as memory 226 that, when executed by a processor such as CPU 224, cause the computing device to perform process 1000. Process 1000 can also be implemented using hardware in whole or in part. The steps of process 1000 may be distributed using different processors and memories.
Process 1000 is run for each superblock of the current frame to make the final determination as to what partition size(s) to use for the superblock. Although not shown as such for simplicity, process 1000 could thus be considered to include a step of partitioning blocks of the current frame (e.g., from step 706 of FIG. 7) into a third partition size that is the largest available partition size (i.e., the size of the basic encoding unit).
At step 1002, process 1000 calls process 900 (FIG. 9) to determine the partitioning of the four 32×32-pixel blocks of the superblock. Following the return of process 900 to step 1004, process 1000 compares the variance values for the 32×32-pixel blocks to a third range, here a threshold T3. If variance_32×32 for each 32×32-pixel block of the current superblock is less than threshold T3, process 1000 selects a partition size of 64×64 for the current superblock at step 1006. In other words, the 32×32-pixels blocks are combined into a 64×64 superblock. Otherwise, process 1000 exits without changing the one or more partitions sizes (in this example, 8×8, 8×8 and 16×16, 16×16, 16×16 and 32×32, or 32×32) selected for the 32×32-pixel blocks by the completion of process 900.
Desirably, the third range is tighter than the second range. That is, the per-pixel variance reflected by the value of threshold T3 should be lower than that reflected by the value of threshold T2, which is still lower than that reflected by the value of threshold T1. The selection of thresholds may depend on the noise level in the source video. Smaller ranges and thresholds would be desirable for video streams with a relatively low noise level, with larges ranges or thresholds assigned to video streams with more noise. In one implementation, T1=10000, T2=360 and T3=720.
The teachings above describe a partitioning process that eliminates the common extensive partitioning search method that is very time-consuming and processing-intensive and not generally suitable for video conferencing and live streaming. The process provides reduced encoding time over such techniques while providing a more efficient result than fixed partitioning alone.
The aspects of encoding and decoding described above illustrate some exemplary encoding and decoding techniques. However, it is to be understood that encoding and decoding, as those terms are used in the claims, could mean compression, decompression, transformation, or any other processing or change of data.
The words “example” or “exemplary” are used herein to mean serving as an example, instance, or illustration. Any aspect or design described herein as “example” or “exemplary” is not necessarily to be construed as preferred or advantageous over other aspects or designs. Rather, use of the words “example” or “exemplary” is intended to present concepts in a concrete fashion. As used in this application, the term “or” is intended to mean an inclusive “or” rather than an exclusive “or”. That is, unless specified otherwise, or clear from context, “X includes A or B” is intended to mean any of the natural inclusive permutations. That is, if X includes A; X includes B; or X includes both A and B, then “X includes A or B” is satisfied under any of the foregoing instances. In addition, the articles “a” and “an” as used in this application and the appended claims should generally be construed to mean “one or more” unless specified otherwise or clear from context to be directed to a singular form. Moreover, use of the term “an implementation” or “one implementation” throughout is not intended to mean the same embodiment or implementation unless described as such.
Implementations of transmitting station 112 and/or receiving station 130 (and the algorithms, methods, instructions, etc., stored thereon and/or executed thereby, including by encoder 470 and decoder 500) can be realized in hardware, software, or any combination thereof. The hardware can include, for example, computers, intellectual property (IP) cores, application-specific integrated circuits (ASICs), programmable logic arrays, optical processors, programmable logic controllers, microcode, microcontrollers, servers, microprocessors, digital signal processors or any other suitable circuit. In the claims, the term “processor” should be understood as encompassing any of the foregoing hardware, either singly or in combination. The terms “signal” and “data” are used interchangeably. Further, portions of transmitting station 112 and receiving station 130 do not necessarily have to be implemented in the same manner.
Further, in one aspect, for example, transmitting station 112 or receiving station 130 can be implemented using a general purpose computer or general purpose processor with a computer program that, when executed, carries out any of the respective methods, algorithms and/or instructions described herein. In addition or alternatively, for example, a special purpose computer/processor can be utilized which can contain other hardware for carrying out any of the methods, algorithms, or instructions described herein.
Transmitting station 112 and receiving station 130 can, for example, be implemented on computers in a video conferencing system. Alternatively, transmitting station 112 can be implemented on a server and receiving station 130 can be implemented on a device separate from the server, such as a hand-held communications device. In this instance, transmitting station 112 can encode content using an encoder 470 into an encoded video signal and transmit the encoded video signal to the communications device. In turn, the communications device can then decode the encoded video signal using a decoder 500. Alternatively, the communications device can decode content stored locally on the communications device, for example, content that was not transmitted by transmitting station 112. Other suitable transmitting station 112 and receiving station 130 implementation schemes are available. For example, receiving station 130 can be a generally stationary personal computer rather than a portable communications device and/or a device including an encoder 470 may also include a decoder 500.
Further, all or a portion of implementations of the present invention can take the form of a computer program product accessible from, for example, a tangible computer-usable or computer-readable medium. A computer-usable or computer-readable medium can be any device that can, for example, tangibly contain, store, communicate, or transport the program for use by or in connection with any processor. The medium can be, for example, an electronic, magnetic, optical, electromagnetic, or a semiconductor device. Other suitable mediums are also available.
The above-described embodiments, implementations and aspects have been described in order to allow easy understanding of the present invention and do not limit the present invention. On the contrary, the invention is intended to cover various modifications and equivalent arrangements included within the scope of the appended claims, which scope is to be accorded the broadest interpretation so as to encompass all such modifications and equivalent structure as is permitted under the law.