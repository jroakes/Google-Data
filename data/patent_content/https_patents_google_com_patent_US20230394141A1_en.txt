US20230394141A1 - Indexing Software Packages and Detecting Malicious or Potentially Harmful Code using API-call N-Grams - Google Patents
Indexing Software Packages and Detecting Malicious or Potentially Harmful Code using API-call N-Grams Download PDFInfo
- Publication number
- US20230394141A1 US20230394141A1 US18/031,443 US202018031443A US2023394141A1 US 20230394141 A1 US20230394141 A1 US 20230394141A1 US 202018031443 A US202018031443 A US 202018031443A US 2023394141 A1 US2023394141 A1 US 2023394141A1
- Authority
- US
- United States
- Prior art keywords
- api
- grams
- call
- call graphs
- potentially harmful
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
- 238000000034 method Methods 0.000 claims abstract description 62
- 230000006870 function Effects 0.000 claims description 39
- 230000007704 transition Effects 0.000 claims description 21
- 238000009833 condensation Methods 0.000 claims description 13
- 230000005494 condensation Effects 0.000 claims description 13
- 230000004931 aggregating effect Effects 0.000 claims description 2
- 230000006399 behavior Effects 0.000 description 31
- 238000010586 diagram Methods 0.000 description 23
- 238000004891 communication Methods 0.000 description 15
- 238000013473 artificial intelligence Methods 0.000 description 11
- 230000001360 synchronised effect Effects 0.000 description 7
- 238000011144 upstream manufacturing Methods 0.000 description 5
- 230000003068 static effect Effects 0.000 description 4
- 238000013459 approach Methods 0.000 description 2
- 239000000470 constituent Substances 0.000 description 2
- 230000003993 interaction Effects 0.000 description 2
- 238000013507 mapping Methods 0.000 description 2
- 230000002093 peripheral effect Effects 0.000 description 2
- 238000012545 processing Methods 0.000 description 2
- 230000008859 change Effects 0.000 description 1
- 239000012634 fragment Substances 0.000 description 1
- 239000011159 matrix material Substances 0.000 description 1
- 238000005259 measurement Methods 0.000 description 1
- 238000002360 preparation method Methods 0.000 description 1
- 230000008569 process Effects 0.000 description 1
- 230000004044 response Effects 0.000 description 1
- 238000012360 testing method Methods 0.000 description 1
- 230000009466 transformation Effects 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/50—Monitoring users, programs or devices to maintain the integrity of platforms, e.g. of processors, firmware or operating systems
- G06F21/55—Detecting local intrusion or implementing counter-measures
- G06F21/56—Computer malware detection or handling, e.g. anti-virus arrangements
- G06F21/562—Static detection
- G06F21/563—Static detection by source code analysis
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/50—Monitoring users, programs or devices to maintain the integrity of platforms, e.g. of processors, firmware or operating systems
- G06F21/55—Detecting local intrusion or implementing counter-measures
- G06F21/554—Detecting local intrusion or implementing counter-measures involving event detection and direct action
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/50—Monitoring users, programs or devices to maintain the integrity of platforms, e.g. of processors, firmware or operating systems
- G06F21/55—Detecting local intrusion or implementing counter-measures
- G06F21/56—Computer malware detection or handling, e.g. anti-virus arrangements
- G06F21/562—Static detection
- G06F21/564—Static detection by virus signature recognition
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F2221/00—Indexing scheme relating to security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F2221/03—Indexing scheme relating to G06F21/50, monitoring users, programs or devices to maintain the integrity of platforms
- G06F2221/033—Test or assess software
Definitions
- Static analysis is a technique to improve computer security where an executable file or shared library file is tested for the presence of malicious or potentially harmful code (collectively referred to as “potentially harmful code” in this document) without running the file.
- potentially harmful code include attempts to exploit known vulnerabilities in an operating system.
- Many techniques to identify potentially harmful code do not scale well for analyzing a large number of software packages and struggle to keep up with a continually changing landscape of potentially harmful software.
- some current approaches match each signature (e.g., API-call sequences) against each graph (e.g., API-call graph) for a software package.
- the process generally includes one graph per binary, with potentially multiple binaries per executable file or shared library file in the software package.
- the collection of software packages on a user device can result in millions to hundreds of millions of graphs. Therefore, current approaches can take several days to determine whether the collection of software packages includes potentially harmful code, often resulting in too many false positives or false negatives to be useful.
- a computing device generates API-call graphs from binaries.
- the computing device computes n-grams from the API-call graphs and adds them to an inverted index, which maps the n-grams to a respective identifier.
- the computing device identifies, using a signature that represents the behavior of the potentially harmful code, a set of candidate API-call graphs.
- the computing device can then compare, using a matching algorithm, the set of candidate API-call graphs to a non-deterministic finite automaton representation of the potentially harmful code. In this way, the described systems and techniques can use API-call n-grams to efficiently identify whether the software package includes a file that matches the behavior of potentially harmful code.
- the described systems and techniques generate API-call graphs from binaries of a software package, which can include executable files or shared library files.
- the systems and techniques compute n-grams from the API-call graphs and add the n-grams to an inverted index, which maps each of the n-grams to a respective identifier of the API-call graph.
- the systems and techniques can identify a set of candidate API-call graphs that match a signature.
- the signature represents behavior of potentially harmful code.
- the systems and techniques can retrieve the set of candidate API-call graphs from the inverted index.
- the systems and techniques then compare the set of candidate API-call graphs to a non-deterministic finite automaton (NFA) representing the behavior of the potentially harmful code.
- the comparison is effective to detect whether the set of candidate API-call graphs includes a binary that matches the behavior of the potentially harmful code.
- This document also describes other methods, configurations, and systems, for indexing software packages and detecting potentially harmful code using API-call n-grams.
- FIG. 1 illustrates an example computing environment for indexing a software package and detecting potentially harmful code.
- FIG. 2 illustrates an example flow diagram for indexing a software package using API-call n-grams.
- FIG. 3 illustrates an example flow diagram for generating API-call graphs for executable files or shared library files of a software package.
- FIG. 4 illustrates an example flow diagram for computing n-grams from API-call graphs.
- FIG. 5 illustrates an example flow diagram for detecting potentially harmful code in a software package using API-call n-grams.
- FIG. 6 illustrates an example flow diagram for identifying a set of candidate API-call graphs.
- FIG. 7 illustrates example operations to index a software package and detect potentially harmful code using API-call n-grams.
- FIG. 8 illustrates an example device diagram of a user device for which indexing a software package and detecting potentially harmful code using API-call n-grams can be implemented.
- Static analysis is a technique to improve computer security by testing executables files or shared library files for the presence of potentially harmful code without running the executable. Examples of potentially harmful code include attempts to exploit known vulnerabilities in an operating system.
- Some static-analysis techniques attempt to match API-call sequences (referred to as “signatures” in this document) of potentially harmful behavior against API-call graphs of a software package. These techniques check the executable files for a matching signature.
- a software package can include one API-call graph per executable file, with many files per software package.
- a collection of software packages on a computing device can result in millions to hundreds of millions of API-call graphs. Adding a new signature can trigger a multi-day scan of API-call graphs for the collection of software packages, which may result in too many false positives or false negatives for the signature to be useful in detecting potentially harmful code.
- the described systems and techniques utilize signatures that represent the behavior of potentially harmful code to effectively detect executable files with similar potentially harmful behavior and efficiently identify potentially harmful code within an inverted index.
- the described systems and techniques use API-call n-grams to index signatures for a software package, which allows security engineers to find signatures containing n-grams of interest efficiently. Security engineers can then use the inverted index to efficiently retrieve signatures that contain paths matching classes of NFAs with epsilon-moves used in potentially harmful code. In this way, security engineers can scan a collection of software packages for a new signature in several minutes, as opposed to several days, using the described systems and techniques.
- the described systems and techniques also allow security engineers to run ad-hoc queries in a software package to develop new signatures of potentially harmful behavior.
- the described systems and techniques generate API-call graphs from binaries of a software package.
- the systems and techniques compute n-grams from the API-call graphs and add the n-grams to an inverted index.
- the inverted index maps each of the n-grams to a respective identifier of the API-call graphs to enable efficient locating of individual API-call graphs.
- the systems and techniques identify, from among the API-call graphs, a set of candidate API-call graphs that match a signature.
- the signature represents behavior of potentially harmful code.
- the systems and techniques retrieve the set of candidate API-call graphs from the inverted index and compare them to an NFA using a matching algorithm.
- the NFA represents the potentially harmful code. The comparison is effective in detecting whether a file within the software package matches the behavior of potentially harmful code.
- This example is just one illustration of how the described indexing of a software package and detecting potentially harmful code using API-call n-grams can improve the security of computer systems.
- Other example configurations and methods are described throughout this document.
- This document now describes additional example methods, configurations, and components for the described indexing and detecting of potentially harmful code using API-call n-grams.
- FIG. 1 illustrates an example computing environment 100 for indexing a software package 108 and detecting potentially harmful code 114 .
- the computing environment 100 includes a computing device 102 .
- the computing device 102 can be a variety of computing devices used by security engineers to index the software package 108 and detect the potentially harmful code 114 .
- the computing device 102 can be a laptop computer 102 - 1 , a desktop computer 102 - 2 , or a server 102 - 3 .
- the computing device 102 can include one or more processors 104 and computer-readable storage media (CRM) 106 .
- the processor 104 can be a single-core processor or a multiple-core processor.
- the processor 104 functions as a central processor for the computing device 102 .
- the processor 104 can include other components, such as communication units (e.g., modems), input/output controllers, sensor hubs, system interfaces, and the like.
- the CRM 106 includes any suitable non-transitory storage device (e.g., random-access memory (RAM), static RAM (SRAM), dynamic RAM (DRAM), non-volatile RAM (NVRAM), read-only memory (ROM), Flash memory) to store device data of the computing device 102 .
- the device data can include user data, multimedia data, an operating system, and applications of the computing device 102 , which are executable by the processor(s) 104 to enable communications and user interaction with the computing device 102 .
- the CRM 106 can include the software package 108 and an inverted index 116 .
- the software package 108 can be, for example, a collection of applications available for download to user devices (e.g., a mobile phone, a tablet device, a laptop computer, a desktop computer).
- the software package 108 can include millions to hundreds of millions of files, including executable files 110 and shared library files 112 .
- the executable files 110 when executed, can cause a computing device (e.g., a user device) to perform specific tasks according to instructions encoded therein.
- the shared library files 112 generally contain code that one or more executable files 110 can simultaneously use while executing.
- the software package 108 can also include the potentially harmful code 114 .
- the executable files 110 and the shared library files 112 can include indicators of potentially harmful code or code that can potentially perform unwanted behavior on a user device.
- the computing device 102 uses the systems and techniques described in this document to generate the inverted index 116 of the executable files 110 and the shared library files 112 in the software package 108 .
- the inverted index 116 assists security engineers to detect, using a signature analysis module 118 , the potentially harmful code 114 .
- the inverted index 116 includes a mapping of n-grams to respective API-call graphs of the executable files 110 and the shared library files 112 .
- the signature analysis module 118 can then use the inverted index 116 to identify API-call graphs that match the behavior of the potentially harmful code 114 .
- FIG. 2 illustrates an example flow diagram 200 for indexing the software package 108 using API-call n-grams.
- the operations and outputs of the flow diagram 200 are described in the context of the computing device 102 of FIG. 1 .
- the computing device 102 indexes the software package 108 to assist in the identification of potentially harmful code 114 .
- the operations of the flow diagram 200 may be performed in a different order or with additional or fewer operations.
- the computing device 102 generates API-call graphs 204 from binary files of the executable files 110 and the shared library files 112 of the software package 108 .
- the API-call graphs 204 represent an abstraction of the executable files 110 and the shared library files 112 .
- the API-call graphs 204 can represent a sequence of API calls made by an executable file 110 or a shared library file 112 .
- the operation 202 is described in further detail with respect to FIG. 3 .
- the computing device 102 computes n-grams 208 from the API-call graphs 204 .
- N-grams are often used in document processing to summarize the content of a document as a set of text fragments.
- the API-call graphs 204 have document-like content, which is referred to in this document as a grammar.
- a grammar Given a loop in an executable file 110 , a grammar can represent a set of execution traces with an arbitrary number of iterations of the loop.
- the grammar is generally limited to a finite number of n-grams 208 of a given length—S N , where S is the number of symbols in the grammar, and N is the length of the n-grams 208 .
- An artificial intelligence (AI) integrator can use a library to extract the n-grams 208 from the API-call graphs 204 contained in the executable files 110 and the shared library files 112 .
- the computed n-grams 208 can be of a customizable length (e.g., one-gram, two-gram).
- the operation 206 is described in further detail with respect to FIG. 4 .
- the computing device 102 adds the n-grams 208 to the inverted index 116 .
- the inverted index 116 maps the n-grams 208 to identifiers of respective API-call graphs 204 containing the n-grams 208 .
- the inverted index 116 can be used by security engineers or security applications on the computing device 102 to perform queries to identify API-call graphs 204 that contain particular n-grams 208 or combinations thereof. In this way, the computing device 102 can index the executable files 110 and the shared library files 112 of the software package 108 as non-linear or graph-based data.
- the computing device 102 determines whether there are additional or new executable files 110 or shared library files 112 in the software package 108 that are not indexed. If there are additional files, the computing device 102 returns to operation 202 . If there are no additional files, the computing device 102 terminates the operations of the flow diagram 200 . In other implementations, the computind device 102 can wait for additional files to become available (e.g., from a new submission to a software distribution service) and continually update the inverted index 116 .
- FIG. 3 illustrates an example flow diagram 202 for generating the API-call graphs 204 for the executable files 110 or the shared library files 112 of the software package 108 .
- the operations of the flow diagram 202 are described in the context of the computing device 102 of FIG. 1 .
- the operations of the flow diagram 202 may be performed in a different order or with additional or fewer operations.
- the computing device 102 can convert a binary of an executable file 110 or a shared library file 112 into a control flow graph 302 .
- the control flow graph 302 represents, using graph notation, paths that might be traversed during the execution of the executable file 110 or the shared library file 112 .
- the computing device 102 computes a condensation 306 of the control flow graph 302 .
- the condensation 306 converts mutually-recursive functions into single graph nodes, resulting in a directed acyclic graph for the binary.
- Each node in the directed acyclic graph includes a unique identifier.
- the computing device 102 can also topologically order the condensation 306 .
- each recursive-function group the computing device 102 tracks completed functions.
- the computing device 102 can also track the recursive-function groups that include each completed function.
- a function is complete when the functions in the recursive-function group are complete.
- Each recursive-function group tracks the identifiers of nodes it contains.
- the topological ordering of the condensation 306 assures that calls to upstream functions (which are incomplete) do not occur, while downstream functions are complete. As a result, only functions within the current node are potentially incomplete but callable.
- the computing device 102 iterates through the nodes of the condensation 306 .
- the computing device 102 can start by setting the node-id to a most-downstream node.
- the computing device 102 creates a new recursive-function group for the current node and populates the recursive-function group with new entry nodes and exit nodes for each function.
- a subgraph is created for each basic block, linking the functions with epsilon transitions based on the control flow.
- an epsilon (c) transition is a no-operations transition, which occurs, in the sense of automata theory, without consuming an input symbol.
- the control flow is sequential, except in the case of function calls.
- the computing device 102 translates instructions within the basic blocks to transitions as follows: (1) map an assembly-level API-call instruction to the corresponding API call; (2) map a function call through a procedure-linkage table to an API-call based on the name of the imported function; (3) map a function-call instruction to the subgraph corresponding to its target; and (4) convert all other instructions to ⁇ -transitions or omit them altogether.
- the computing device 102 can map function-call instructions to subgraphs as follows: (a) if a function is in the current recursive-function group, add an ⁇ -transition to its entry node and from its exit node; or (b) treat the called function as inlined by making a copy of its recursive-function group in the current recursive-function group. The copy is linked-in with an ⁇ -transition added to its entry node and from its exit node.
- the computing device 102 After processing the functions in the node, the computing device 102 adds the functions to a mapping of recursive-function groups. At 316 , the computing device 102 increments the node-id to the immediately-upstream node, and, if nodes remain at 318 , iterates through the remaining nodes.
- an upstream node corresponds to a node that is not downstream.
- a control flow graph 302 with node a that has two child-nodes b and c, resulting in a topological order of [a, b, c].
- a movement from node c to node b is considered an upstream movement, even though nodes b and c are siblings in the graph-theoretic sense.
- the computing device 102 creates the API-call graphs 204 for output.
- the computing device 102 can also output a set of potential asynchronous entry points into the API-call graphs 204 .
- the computing device 102 moves each recursive-function group into the respective API-call graphs 204 by moving the transitions and each of the function entry nodes to the entry points of the respective API-call graph 204 .
- a function can only call other functions that are either within the same node or in more-downstream nodes.
- functions can have their respective API-call graph 204 inlined into upstream callers, which effectively provides return-address tracing and produces a more-accurate API-call graph 204 .
- the computing device 102 can efficiently assign new node identifiers with a single update pass over the transitions.
- FIG. 4 illustrates an example flow diagram 206 for computing the n-grams 208 from the API-call graphs 204 .
- the operations of the flow diagram 206 are described in the context of the computing device 102 of FIG. 1 .
- the computing device 102 can use an AI integrator to extract the n-grams 208 from the API-call graphs 204 contained in the executable files 110 and the shared library files 112 .
- the operations of the flow diagram 206 may be performed in a different order or with additional or fewer operations.
- the AI integrator can use a recursive algorithm to annotate each node of the API-call graphs 204 with their incoming n-grams using dynamic programming and graph traversals.
- the algorithm merges strongly-E-connected components to make an ⁇ -subgraph acyclic graph 404 .
- the AI integrator can topologically order and invert the nodes of the E-subgraph acyclic graph 404 to obtain an ordered acyclic graph 408 .
- the ordered acyclic graph 408 maps a node to its non-E predecessors (e.g., the source node and API call).
- the AI integrator can use the operations 402 and 406 as preparation steps for utilizing the recursive algorithm.
- the AI integrator annotates each node with a set containing the empty 0-gram. Otherwise, the AI integrator annotates each node with its incoming (n ⁇ 1)-grams. The AI integrator then annotates each source node and destination node with an array of n-grams, including non-c predecessors and c successors.
- the AI integrator aggregates the n-grams 208 for each API-call graph 204 .
- the AI integrator can write the n-grams 208 to memory.
- the AI integrator can then directly output the n-grams 208 or output them as a set of string features in word form.
- FIG. 5 illustrates an example flow diagram 500 for detecting the potentially harmful code 114 in the software package 108 using API-call n-grams.
- the operations of the flow diagram 500 are described in the context of the computing device 102 and the software package 108 of FIG. 1 .
- the computing device 102 can identify a set of candidate API-call graphs 506 from among the API-call graphs 204 .
- the computing device 102 uses one or more heuristics and the n-grams 208 , identifies the set of candidate API-call graphs 506 as API-call graphs that potentially contain a path matching a signature 502 .
- the signature 502 can be an arbitrary NFA with epsilon-moves, which represents potentially harmful behavior (e.g., an exploit of a system or software vulnerability).
- the identification of the set of candidate API-call graphs 506 is described in more detail with respect to FIG. 6 .
- the computing device 102 can retrieve the set of candidate API-call graphs 506 from the inverted index 116 .
- the computing device 102 compares, using a matching algorithm, the set of candidate API-call graphs 506 to an NFA 510 that represents the behavior of potentially harmful code.
- the comparison allows the computing device 102 to detect whether the set of candidate API-call graphs 506 includes an executable file 110 or a shared library file 112 within the software package 108 that contains the potentially harmful code 114 .
- the computing device 102 can compute respective products of the NFA and each API-call graph 204 of the set of candidate API-call graphs 506 .
- the computing device 102 can then determine, using a graph traversal (e.g., a breadth-first search or a depth-first search), whether the respective products indicate that the set of candidate API-call graphs 506 include a file that matches the behavior of the potentially harmful code 114 .
- a graph traversal e.g., a breadth-first search or a depth-first search
- the computing device 102 To determine a match between an API-call graph 204 of the set of candidate API-call graphs 506 and the NFA 510 , the computing device 102 considers the API-call graph 204 as an NFA with all states accepting. The computing device 102 computes a synchronized product of the two NFAs, which is defined such that determining a match of the API-call graph 204 to the NFA 510 is equivalent to determining whether the synchronized product has a non-empty acceptance set. In this manner, matching the API-call graph 204 to the NFA 510 is reduced to a simple reachability problem solvable in linear time and space, for example, using a breadth-first or depth-first search.
- the NFA is represented as a five-tuple (Q1, ⁇ , ⁇ 1, q1, F1) illustrated in Equation 1:
- API-call graph 204 is represented by another NFA, which is denoted (Q 2 , ⁇ , ⁇ 2 , q 2 ,F 2 ).
- the synchronized product of the two NFAs is defined as an NFA which shares the alphabet of the constituent NFAs, whose set of states is the Cartesian product of the two constituent NFAs, and which has a transition function as defined in Equation 2:
- the synchronized product of two NFAs is a restriction of their Cartesian product such that only transitions where both automata recognize the same input symbol are allowed.
- the first two components of ⁇ ′ allow each of the two NFAs to make an epsilon-move independently, while the third component allows the NFAs to recognize the same symbol in lockstep.
- ⁇ ′ uses
- the computing device 102 can, therefore, compute the synchronized product on the fly, ensuring that only necessary states and transitions are computed.
- the computing device 102 uses one automaton to support efficiently finding the outgoing transitions from its states.
- the other automaton similarly supports finding the outgoing transitions from a state with a given label.
- the computing device 102 can compute transitions from a state (s 1 , s 2 ) as shown in Equation 3 below:
- On-the-fly computation of the synchronized product enables not only finite-state but also some infinite-state systems to be processed in finite time.
- NFAs with finite branching e.g., where ⁇ 1 (s) is finite for all states reachable from q 1 , make progress, and a breadth-first search enables accepting states to be found in finite time if a finite string is accepted.
- the alphabet ⁇ need not be finite, e.g., ⁇ is a set of Unicode Transformation Format-8 (UTF-8) strings (not characters).
- Compute-intensive and explicit representation of ⁇ 2 (s, a), e.g., with an adjacency matrix, is obviated.
- the ability of one of the automata to efficiently and on-the-fly compute ⁇ 2 (s, a) using ⁇ 2 (s, a) ⁇ t 2
- (s, a, t 2 ) ⁇ 2 ⁇ enables the computing device 102 to efficiently operate on and represent other abstractions such as counter-extended NFAs.
- the counter-extended NFAs enable the computing device 102 to efficiently match bounded repetitions, including the regular expression (regex) operator ⁇ m,n ⁇ , which matches a regular expression at least m, but no more than n, times.
- the computing device 102 traditionally performs this matching by creating an automaton with n subunits corresponding to the repeated expression. With on-the-fly computation, the computing device 102 represents the operator symbolically and generates the states only if needed. For example, traditional regex engines can take a long time to compile a ⁇ 2,1000000000 ⁇ , even for matching short strings such as b, a, and aaa. With the described techniques, the computing device 102 performs checking in time and space proportional to the length of the string.
- the computing device 102 determines whether there are additional or new signatures 502 . If there are additional signatures, the computing device 102 returns to the operation 504 . If there are no additional signatures, the computing device 102 terminates the operations of the flow diagram 500 .
- FIG. 6 illustrates an example flow diagram 504 for identifying the set of candidate API-call graphs 506 .
- the operations of the flow diagram 504 are described in the context of the computing device 102 of FIG. 1 .
- the operations of the flow diagram 504 may be performed in a different order or with additional or fewer operations.
- the computing device 102 computes a set of relevant n-grams and a Boolean formula as a representation of the potentially-harmful behavior.
- the computing device 102 uses a heuristic 604 to compute the set of relevant n-grams and the Boolean formula.
- the heuristic 604 can be a sequence-of-calls heuristic 606 , which utilizes a sequence of calls, potentially in a loop, to generate the Boolean formula that contains a set of relevant n-grams.
- the set of relevant n-grams represent the sequence of calls in the signature 502 .
- each of the n-grams in the signature 502 must be present.
- the computing device 102 can determine whether the set of relevant n-grams are present using a sliding window. As an example, if the signature 502 is the expression “(abc) ⁇ 2+ ⁇ ,” the Boolean formula for a 2-gram system is “ab AND be AND ca.”
- the heuristic 604 can be a sequence-of-options heuristic 608 , which utilizes a sequence of options in a loop. Each option can be satisfied by one or, in some situations, none of a set of specified calls.
- the computing device 102 computes the outgoing optional n-grams and combines them together in a disjunctive (OR) function.
- the computing device 102 then combines the formulas of each element in a conjunctive (AND) function with any relevant n-grams. For example, if the signature 502 is the expression “(a(b
- heuristics 604 can be developed for specific cases and can be defined using n-grams.
- a nodal heuristic 610 can be used.
- the signature 502 can be treated as an API-call graph, and the computing device 102 computes the n-grams going into a node and/or out of a node.
- the computing device 102 searches for a set of n-grams entering an entry node and a set of n-grams exiting an exit node and computes the set of candidate API-call graphs 506 by determining the API-call graphs 204 that contain at least one of the n-grams entering the entry node and at least one of the n-grams exiting the exit node.
- the computing device 102 fetches the candidate set of API-call graphs 506 from the inverted index 116 by determining the API-call graphs 204 that match the Boolean formula.
- FIG. 7 is a flowchart 700 illustrating example operations to index a software package and detect potentially harmful code using API-call n-grams.
- the operations of the flowchart 700 are described in the context of the computing device 102 of FIG. 1 .
- the operations of the flowchart 700 may be performed in a different order or with additional or fewer operations.
- API-calls are generated from binaries of a software package.
- the computing device 102 generates the API-call graphs 204 from binaries of the executable files 110 and the shared library files 112 in the software package 108 .
- n-grams are computed from the API-call graphs.
- the computing device 102 computes the n-grams 208 from the API-call graphs 204 .
- the n-grams are added to an inverted index that maps each of the n-grams to a respective identifier of the API-call graphs to enable locating of individual API-call graphs.
- the computing device 102 adds the n-grams 208 to the inverted index 116 .
- the inverted index 116 maps the n-grams 208 to a respective identifier of the API-call graphs 204 in which the n-grams 208 can be found.
- the inverted index 116 enables locating of individual API-call graphs 204 based on a query using the n-grams 208 .
- a set of candidate API-call graphs, from among the API-call graphs, that match a signature are identified.
- the signature represents behavior of potentially harmful code.
- the computing device 102 identifies, from among the API-call graphs 204 , the set of candidate API-call graphs 506 that match the signature 502 .
- the signature 502 represents behavior of potentially harmful code.
- the set of candidate API-call graphs is retrieved from the inverted index.
- the computing device 102 retrieves the set of candidate API-call graphs 506 from the inverted index 116 .
- the set of candidate API-call graphs is compared, using a matching algorithm, to a non-deterministic finite automaton (NFA) to detect whether a file within the software package matches the behavior of potentially harmful code.
- the NFA represents the behavior of potentially harmful code.
- the computing device 102 compares the set of candidate API-call graphs 506 to the NFA 510 to detect whether a file within the software package 108 matches the behavior of potentially harmful code 114 .
- the NFA 510 represents the behavior of potentially harmful code 114 .
- FIG. 8 illustrates an example device diagram 800 of a user device 802 for which indexing the software package 108 and detecting potentially harmful code using API-call n-grams can be implemented.
- the user device 802 may include additional functions and interfaces omitted from FIG. 8 for the sake of clarity.
- the user device 802 can be a variety of consumer electronic devices.
- the user device 802 can be a mobile phone 802 - 1 , a tablet device 802 - 2 , a laptop computer 802 - 3 , a desktop computer 802 - 4 , a computerized watch 802 - 5 , a wearable computer 802 - 6 , or a voice-assistant system 802 - 7 .
- the user device 802 includes one or more processors 804 and computer-readable storage media 806 .
- the processor 804 can be a single-core processor or a multiple-core processor.
- the processor 804 functions as a central processor for the user device 802 .
- the processor 804 can include other components, such as communication units (e.g., modems), input/output controllers, sensor hubs, system interfaces, and the like.
- the CRM 806 includes any suitable storage device (e.g., random-access memory (RAM), static RAM (SRAM), dynamic RAM (DRAM), non-volatile RAM (NVRAM), read-only memory (ROM), Flash memory) to store device data of the user device 802 .
- the device data can include user data, multimedia data, an operating system, and applications of the user device 802 , which are executable by the processor 804 to enable communications and user interaction with the user device 802 .
- the CRM 806 also includes the software package 108 .
- the software package 108 can be, for example, a collection of applications available for download to the user device 802 .
- the software package 108 includes the executable files 110 and the shared library files 112 .
- the software package 108 can also include the potentially harmful code 114 .
- the executable files 110 or the shared library files 112 can include indicators of potentially harmful code or code that can potentially perform unwanted behavior on the user device 802 .
- security engineers can index the software package 108 and detect the potentially harmful code 114 using API-call n-grams.
- updates, patches, or other measurements via communication and input/output (I/O) components 808 , can be taken to remove or address the potentially harmful code 114 or its malicious, unwanted, or potentially harmful behavior.
- the processor 804 is operatively coupled to the one or more communication and I/O components 808 .
- the communication and I/O components 808 include data network interfaces that provide connection or communication links between the user device 802 and other data networks, devices, or remote systems (e.g., servers).
- the communication and I/O component 808 can couple the user device 802 to a variety of different types of components, peripherals, or accessory devices.
- Data input ports of the communication and I/O components 808 receive data, including image data, user inputs, communication data, audio data, video data, and the like.
- the communication and I/O components 808 can also enable wired or wireless communicating of device data between the user device 802 and other devices (e.g., the computing device 102 ), computing systems, and networks.
- the one or more communication and I/O components 808 can include a display.
- the one or more communication and I/O components 808 can also include one or more sensors, for example, embedded within the display or as a separate component of the user device 802 .
- the communication and I/O components 808 provide connectivity between the user device 802 , a user, and other devices and peripherals in the outside world.
- Example 1 A method comprising: generating API-call graphs from binaries of a software package; computing n-grams from the API-call graphs; adding the n-grams to an index that maps each of the n-grams to a respective identifier of the API-call graphs to enable locating of individual API-call graphs; identifying, from among the API-call graphs, a set of candidate API-call graphs that match a signature, the signature representing behavior of potentially harmful code; retrieving the set of candidate API-call graphs from the index; and comparing, using a matching algorithm, the set of candidate API-call graphs to a non-deterministic finite automaton (NFA) representing the behavior of potentially harmful code to detect whether a file within the software package matches the behavior of potentially harmful code.
- NFA non-deterministic finite automaton
- Example 2 The method of example 1, wherein generating the API-call graphs from the binaries of the software package comprises: computing a respective condensation of a control flow graph of each of the binaries to convert mutually-recursive functions into nodes of a directed acyclic graph; topologically ordering the nodes of the condensation; iterating through a most-downstream node of the nodes for the condensation; creating a recursive-function group for each of the nodes, the recursive-function group comprising at least one entry node and at least one exit node for each of one or more functions in the recursive-function group; creating a subgraph for each of the one or more functions in the recursive-function group, the subgraph linking basic blocks of the one or more functions to epsilon transitions; adding each of the one or more functions in the recursive-function group to a map of recursive-function groups for the nodes; and outputting an API-call graph comprising the recursive-function group for each of
- Example 3 The method of any preceding example, wherein computing the n-grams from the API-call graphs comprises: merging strongly-epsilon-connected components of a respective API-call graph of the API-call graphs to generate an epsilon-subgraph acyclic graph of nodes of the API-call graph; topologically ordering the nodes according to an order of the nodes in the epsilon-subgraph acyclic graph; inverting the epsilon-subgraph acyclic graph from the nodes to respective non-epsilon predecessors; annotating, using a recursive algorithm, the nodes with an array of n-grams, including the non-epsilon predecessors and epsilon successors; aggregating the n-grams; and outputting a set of n-grams for the respective API-call graph.
- Example 4 The method of any preceding example, wherein the n-grams comprise n-grams of a customizable length and the index comprises an inverted index.
- Example 5 The method of any preceding example, wherein the n-grams comprise at least one of a one-gram and a two-gram.
- Example 6 The method of any preceding example, wherein the signature represents an arbitrary NFA with epsilon-moves.
- Example 7 The method of any of examples 1 through 5, wherein: the signature comprises a set of n-grams that represents a sequence of calls; and identifying the set of candidate API-call graphs comprises determining the API-call graphs that include the set of n-grams.
- Example 8 The method of any of examples 1 through 5, wherein: the signature comprises a set of optional n-grams and relevant n-grams that represents a sequence of options in a loop; and identifying the set of candidate API-call graphs comprises determining the API-call graphs that include at least one of the optional n-grams and each of the relevant n-grams.
- Example 9 The method of any of examples 1 through 5, wherein: the signature comprises a set of n-grams entering an entry node and n-grams exiting an exit node; and identifying the set of candidate API-call graphs comprises determining the API-call graphs that include at least one of the n-grams entering the entry node and at least one of the n-grams exiting the exit node.
- Example 10 The method of any preceding example, wherein the set of candidate API-call graphs comprises NFAs with all states accepting.
- Example 11 The method of example 10, wherein comparing the set of candidate API-call graphs to the NFA comprises: computing respective products of the NFA and each NFA with all states accepting of the set of candidate API-call graphs; and determining, using a graph traversal, whether the respective products indicate that the NFAs with all states accepting include a binary that matches the behavior of potentially harmful code.
- Example 12 The method of any preceding example, wherein the binaries comprise executable files, shared library files, or a combination thereof.
- Example 13 A system comprising means for performing the method of any of the preceding examples.
- Example 14 A non-transitory computer-readable storage medium comprising instructions that, when executed, configure a processor of a computing device to perform the method of any of examples 1 through 12.
Abstract
This document describes systems and techniques for indexing binaries of a software package and detecting potentially harmful code within the software package using API-call n-grams. A computing device generates API-call graphs from binaries. The computing device computes n-grams from the API-call graphs and adds them to an inverted index, which maps the n-grams to a respective identifier. The computing device identifies, using a signature that represents the behavior of the potentially harmful code, a set of candidate API-call graphs. The computing device can then compare, using a matching algorithm, the set of candidate API-call graphs to a non-deterministic finite automaton representation of the potentially harmful code. In this way, the described systems and techniques can use API-call n-grams to efficiently identify whether the software package includes a file that matches the behavior of potentially harmful code.
Description
- Static analysis is a technique to improve computer security where an executable file or shared library file is tested for the presence of malicious or potentially harmful code (collectively referred to as “potentially harmful code” in this document) without running the file. Examples of potentially harmful code include attempts to exploit known vulnerabilities in an operating system. Many techniques to identify potentially harmful code do not scale well for analyzing a large number of software packages and struggle to keep up with a continually changing landscape of potentially harmful software. As an example, some current approaches match each signature (e.g., API-call sequences) against each graph (e.g., API-call graph) for a software package. The process generally includes one graph per binary, with potentially multiple binaries per executable file or shared library file in the software package. The collection of software packages on a user device can result in millions to hundreds of millions of graphs. Therefore, current approaches can take several days to determine whether the collection of software packages includes potentially harmful code, often resulting in too many false positives or false negatives to be useful.
- This document describes systems and techniques for indexing binaries of a software package and detecting potentially harmful code using API-call n-grams. A computing device generates API-call graphs from binaries. The computing device computes n-grams from the API-call graphs and adds them to an inverted index, which maps the n-grams to a respective identifier. The computing device identifies, using a signature that represents the behavior of the potentially harmful code, a set of candidate API-call graphs. The computing device can then compare, using a matching algorithm, the set of candidate API-call graphs to a non-deterministic finite automaton representation of the potentially harmful code. In this way, the described systems and techniques can use API-call n-grams to efficiently identify whether the software package includes a file that matches the behavior of potentially harmful code.
- For example, the described systems and techniques generate API-call graphs from binaries of a software package, which can include executable files or shared library files. The systems and techniques compute n-grams from the API-call graphs and add the n-grams to an inverted index, which maps each of the n-grams to a respective identifier of the API-call graph. From among the API-call graphs, the systems and techniques can identify a set of candidate API-call graphs that match a signature. The signature represents behavior of potentially harmful code. The systems and techniques can retrieve the set of candidate API-call graphs from the inverted index. Using a matching algorithm, the systems and techniques then compare the set of candidate API-call graphs to a non-deterministic finite automaton (NFA) representing the behavior of the potentially harmful code. The comparison is effective to detect whether the set of candidate API-call graphs includes a binary that matches the behavior of the potentially harmful code.
- This document also describes other methods, configurations, and systems, for indexing software packages and detecting potentially harmful code using API-call n-grams.
- This Summary is provided to introduce simplified concepts of indexing software packages and detecting potentially harmful code using API-call n-grams, which is further described below in the Detailed Description and Drawings. This Summary is not intended to identify essential features of the claimed subject matter, nor is it intended for use in determining the scope of the claimed subject matter.
- The details of one or more aspects of indexing software packages and detecting potentially harmful code using API-call n-grams are described in this document with reference to the following drawings. The same numbers are used throughout multiple drawings to reference like features and components.
-
FIG. 1 illustrates an example computing environment for indexing a software package and detecting potentially harmful code. -
FIG. 2 illustrates an example flow diagram for indexing a software package using API-call n-grams. -
FIG. 3 illustrates an example flow diagram for generating API-call graphs for executable files or shared library files of a software package. -
FIG. 4 illustrates an example flow diagram for computing n-grams from API-call graphs. -
FIG. 5 illustrates an example flow diagram for detecting potentially harmful code in a software package using API-call n-grams. -
FIG. 6 illustrates an example flow diagram for identifying a set of candidate API-call graphs. -
FIG. 7 illustrates example operations to index a software package and detect potentially harmful code using API-call n-grams. -
FIG. 8 illustrates an example device diagram of a user device for which indexing a software package and detecting potentially harmful code using API-call n-grams can be implemented. - Overview
- This document describes indexing a software package and detecting potentially harmful code within the software package using API-call n-grams. Static analysis is a technique to improve computer security by testing executables files or shared library files for the presence of potentially harmful code without running the executable. Examples of potentially harmful code include attempts to exploit known vulnerabilities in an operating system.
- Some static-analysis techniques attempt to match API-call sequences (referred to as “signatures” in this document) of potentially harmful behavior against API-call graphs of a software package. These techniques check the executable files for a matching signature. A software package can include one API-call graph per executable file, with many files per software package. As an example, a collection of software packages on a computing device can result in millions to hundreds of millions of API-call graphs. Adding a new signature can trigger a multi-day scan of API-call graphs for the collection of software packages, which may result in too many false positives or false negatives for the signature to be useful in detecting potentially harmful code.
- Other techniques allow security engineers to detect potentially harmful code in a software package by using minhashes and nearest-neighbor lookups. These techniques search for a matching code structure rather than similar behavior. Because code variants, trivial code changes, or compiler-version changes for an executable file can change the structure of the code, but not its behavior, these techniques generally fail to keep up with a continually changing landscape of potentially harmful files.
- In contrast, the described systems and techniques utilize signatures that represent the behavior of potentially harmful code to effectively detect executable files with similar potentially harmful behavior and efficiently identify potentially harmful code within an inverted index. The described systems and techniques use API-call n-grams to index signatures for a software package, which allows security engineers to find signatures containing n-grams of interest efficiently. Security engineers can then use the inverted index to efficiently retrieve signatures that contain paths matching classes of NFAs with epsilon-moves used in potentially harmful code. In this way, security engineers can scan a collection of software packages for a new signature in several minutes, as opposed to several days, using the described systems and techniques. The described systems and techniques also allow security engineers to run ad-hoc queries in a software package to develop new signatures of potentially harmful behavior.
- As a non-limiting example, the described systems and techniques generate API-call graphs from binaries of a software package. The systems and techniques compute n-grams from the API-call graphs and add the n-grams to an inverted index. The inverted index maps each of the n-grams to a respective identifier of the API-call graphs to enable efficient locating of individual API-call graphs. The systems and techniques identify, from among the API-call graphs, a set of candidate API-call graphs that match a signature. The signature represents behavior of potentially harmful code. The systems and techniques retrieve the set of candidate API-call graphs from the inverted index and compare them to an NFA using a matching algorithm. The NFA represents the potentially harmful code. The comparison is effective in detecting whether a file within the software package matches the behavior of potentially harmful code.
- This example is just one illustration of how the described indexing of a software package and detecting potentially harmful code using API-call n-grams can improve the security of computer systems. Other example configurations and methods are described throughout this document. This document now describes additional example methods, configurations, and components for the described indexing and detecting of potentially harmful code using API-call n-grams.
- Example Devices
-
FIG. 1 illustrates anexample computing environment 100 for indexing asoftware package 108 and detecting potentiallyharmful code 114. Thecomputing environment 100 includes acomputing device 102. - The
computing device 102 can be a variety of computing devices used by security engineers to index thesoftware package 108 and detect the potentiallyharmful code 114. As non-limiting examples, thecomputing device 102 can be a laptop computer 102-1, a desktop computer 102-2, or a server 102-3. Thecomputing device 102 can include one ormore processors 104 and computer-readable storage media (CRM) 106. Theprocessor 104 can be a single-core processor or a multiple-core processor. Theprocessor 104 functions as a central processor for thecomputing device 102. Theprocessor 104 can include other components, such as communication units (e.g., modems), input/output controllers, sensor hubs, system interfaces, and the like. - The
CRM 106 includes any suitable non-transitory storage device (e.g., random-access memory (RAM), static RAM (SRAM), dynamic RAM (DRAM), non-volatile RAM (NVRAM), read-only memory (ROM), Flash memory) to store device data of thecomputing device 102. The device data can include user data, multimedia data, an operating system, and applications of thecomputing device 102, which are executable by the processor(s) 104 to enable communications and user interaction with thecomputing device 102. - For example, the
CRM 106 can include thesoftware package 108 and aninverted index 116. Thesoftware package 108 can be, for example, a collection of applications available for download to user devices (e.g., a mobile phone, a tablet device, a laptop computer, a desktop computer). Thesoftware package 108 can include millions to hundreds of millions of files, includingexecutable files 110 and shared library files 112. Theexecutable files 110, when executed, can cause a computing device (e.g., a user device) to perform specific tasks according to instructions encoded therein. The shared library files 112 generally contain code that one or moreexecutable files 110 can simultaneously use while executing. - Among the
executable files 110 and the shared library files 112, thesoftware package 108 can also include the potentiallyharmful code 114. In particular, one or more of theexecutable files 110 and the shared library files 112 can include indicators of potentially harmful code or code that can potentially perform unwanted behavior on a user device. - The
computing device 102 uses the systems and techniques described in this document to generate theinverted index 116 of theexecutable files 110 and the shared library files 112 in thesoftware package 108. Theinverted index 116 assists security engineers to detect, using asignature analysis module 118, the potentiallyharmful code 114. As described in greater detail forFIG. 2 , theinverted index 116 includes a mapping of n-grams to respective API-call graphs of theexecutable files 110 and the shared library files 112. Thesignature analysis module 118 can then use theinverted index 116 to identify API-call graphs that match the behavior of the potentiallyharmful code 114. -
FIG. 2 illustrates an example flow diagram 200 for indexing thesoftware package 108 using API-call n-grams. The operations and outputs of the flow diagram 200 are described in the context of thecomputing device 102 ofFIG. 1 . Thecomputing device 102 indexes thesoftware package 108 to assist in the identification of potentiallyharmful code 114. The operations of the flow diagram 200 may be performed in a different order or with additional or fewer operations. - At 202, the
computing device 102 generates API-call graphs 204 from binary files of theexecutable files 110 and the shared library files 112 of thesoftware package 108. The API-call graphs 204 represent an abstraction of theexecutable files 110 and the shared library files 112. For example, the API-call graphs 204 can represent a sequence of API calls made by anexecutable file 110 or a sharedlibrary file 112. Theoperation 202 is described in further detail with respect toFIG. 3 . - At 206, the
computing device 102 computes n-grams 208 from the API-call graphs 204. N-grams are often used in document processing to summarize the content of a document as a set of text fragments. The API-call graphs 204 have document-like content, which is referred to in this document as a grammar. Given a loop in anexecutable file 110, a grammar can represent a set of execution traces with an arbitrary number of iterations of the loop. The grammar is generally limited to a finite number of n-grams 208 of a given length—SN, where S is the number of symbols in the grammar, and N is the length of the n-grams 208. An artificial intelligence (AI) integrator can use a library to extract the n-grams 208 from the API-call graphs 204 contained in theexecutable files 110 and the shared library files 112. The computed n-grams 208 can be of a customizable length (e.g., one-gram, two-gram). Theoperation 206 is described in further detail with respect toFIG. 4 . - At 210, the
computing device 102 adds the n-grams 208 to theinverted index 116. Theinverted index 116 maps the n-grams 208 to identifiers of respective API-call graphs 204 containing the n-grams 208. Theinverted index 116 can be used by security engineers or security applications on thecomputing device 102 to perform queries to identify API-call graphs 204 that contain particular n-grams 208 or combinations thereof. In this way, thecomputing device 102 can index theexecutable files 110 and the shared library files 112 of thesoftware package 108 as non-linear or graph-based data. - At 212, the
computing device 102 determines whether there are additional or newexecutable files 110 or shared library files 112 in thesoftware package 108 that are not indexed. If there are additional files, thecomputing device 102 returns tooperation 202. If there are no additional files, thecomputing device 102 terminates the operations of the flow diagram 200. In other implementations, thecomputind device 102 can wait for additional files to become available (e.g., from a new submission to a software distribution service) and continually update theinverted index 116. -
FIG. 3 illustrates an example flow diagram 202 for generating the API-call graphs 204 for theexecutable files 110 or the shared library files 112 of thesoftware package 108. The operations of the flow diagram 202 are described in the context of thecomputing device 102 ofFIG. 1 . The operations of the flow diagram 202 may be performed in a different order or with additional or fewer operations. - The
computing device 102 can convert a binary of anexecutable file 110 or a sharedlibrary file 112 into acontrol flow graph 302. Thecontrol flow graph 302 represents, using graph notation, paths that might be traversed during the execution of theexecutable file 110 or the sharedlibrary file 112. - At 304, the
computing device 102 computes acondensation 306 of thecontrol flow graph 302. Thecondensation 306 converts mutually-recursive functions into single graph nodes, resulting in a directed acyclic graph for the binary. Each node in the directed acyclic graph includes a unique identifier. Thecomputing device 102 can also topologically order thecondensation 306. - Within each recursive-function group, the
computing device 102 tracks completed functions. Thecomputing device 102 can also track the recursive-function groups that include each completed function. A function is complete when the functions in the recursive-function group are complete. Each recursive-function group tracks the identifiers of nodes it contains. - The topological ordering of the
condensation 306 assures that calls to upstream functions (which are incomplete) do not occur, while downstream functions are complete. As a result, only functions within the current node are potentially incomplete but callable. - At 308, the
computing device 102 iterates through the nodes of thecondensation 306. Thecomputing device 102 can start by setting the node-id to a most-downstream node. At 310, thecomputing device 102 creates a new recursive-function group for the current node and populates the recursive-function group with new entry nodes and exit nodes for each function. - At 312, for each function in the node, a subgraph is created for each basic block, linking the functions with epsilon transitions based on the control flow. In this context, an epsilon (c) transition is a no-operations transition, which occurs, in the sense of automata theory, without consuming an input symbol. Within a basic block, the control flow is sequential, except in the case of function calls.
- The
computing device 102 translates instructions within the basic blocks to transitions as follows: (1) map an assembly-level API-call instruction to the corresponding API call; (2) map a function call through a procedure-linkage table to an API-call based on the name of the imported function; (3) map a function-call instruction to the subgraph corresponding to its target; and (4) convert all other instructions to ε-transitions or omit them altogether. Thecomputing device 102 can map function-call instructions to subgraphs as follows: (a) if a function is in the current recursive-function group, add an ε-transition to its entry node and from its exit node; or (b) treat the called function as inlined by making a copy of its recursive-function group in the current recursive-function group. The copy is linked-in with an ε-transition added to its entry node and from its exit node. - At 314, after processing the functions in the node, the
computing device 102 adds the functions to a mapping of recursive-function groups. At 316, thecomputing device 102 increments the node-id to the immediately-upstream node, and, if nodes remain at 318, iterates through the remaining nodes. - In this context, an upstream node corresponds to a node that is not downstream. For example, consider a
control flow graph 302 with node a that has two child-nodes b and c, resulting in a topological order of [a, b, c]. A movement from node c to node b is considered an upstream movement, even though nodes b and c are siblings in the graph-theoretic sense. - At 320, when the nodes of the
condensation 306 are exhausted, thecomputing device 102 creates the API-call graphs 204 for output. Thecomputing device 102 can also output a set of potential asynchronous entry points into the API-call graphs 204. Thecomputing device 102 moves each recursive-function group into the respective API-call graphs 204 by moving the transitions and each of the function entry nodes to the entry points of the respective API-call graph 204. As a result of thecondensation 306, a function can only call other functions that are either within the same node or in more-downstream nodes. In this way, functions can have their respective API-call graph 204 inlined into upstream callers, which effectively provides return-address tracing and produces a more-accurate API-call graph 204. By keeping track of node identifiers within recursive-function groups, thecomputing device 102 can efficiently assign new node identifiers with a single update pass over the transitions. -
FIG. 4 illustrates an example flow diagram 206 for computing the n-grams 208 from the API-call graphs 204. The operations of the flow diagram 206 are described in the context of thecomputing device 102 ofFIG. 1 . Thecomputing device 102 can use an AI integrator to extract the n-grams 208 from the API-call graphs 204 contained in theexecutable files 110 and the shared library files 112. The operations of the flow diagram 206 may be performed in a different order or with additional or fewer operations. - At 402, the AI integrator can use a recursive algorithm to annotate each node of the API-
call graphs 204 with their incoming n-grams using dynamic programming and graph traversals. The algorithm merges strongly-E-connected components to make an ε-subgraphacyclic graph 404. - At 406, the AI integrator can topologically order and invert the nodes of the E-subgraph
acyclic graph 404 to obtain an orderedacyclic graph 408. The orderedacyclic graph 408 maps a node to its non-E predecessors (e.g., the source node and API call). The AI integrator can use theoperations - At 410, for the recursive base case (e.g., if n=0), the AI integrator annotates each node with a set containing the empty 0-gram. Otherwise, the AI integrator annotates each node with its incoming (n−1)-grams. The AI integrator then annotates each source node and destination node with an array of n-grams, including non-c predecessors and c successors.
- At 412, the AI integrator aggregates the n-
grams 208 for each API-call graph 204. The AI integrator can write the n-grams 208 to memory. The AI integrator can then directly output the n-grams 208 or output them as a set of string features in word form. -
FIG. 5 illustrates an example flow diagram 500 for detecting the potentiallyharmful code 114 in thesoftware package 108 using API-call n-grams. The operations of the flow diagram 500 are described in the context of thecomputing device 102 and thesoftware package 108 ofFIG. 1 . - At 504, the
computing device 102 can identify a set of candidate API-call graphs 506 from among the API-call graphs 204. Thecomputing device 102, using one or more heuristics and the n-grams 208, identifies the set of candidate API-call graphs 506 as API-call graphs that potentially contain a path matching asignature 502. Thesignature 502 can be an arbitrary NFA with epsilon-moves, which represents potentially harmful behavior (e.g., an exploit of a system or software vulnerability). The identification of the set of candidate API-call graphs 506 is described in more detail with respect toFIG. 6 . - At 508, the
computing device 102 can retrieve the set of candidate API-call graphs 506 from theinverted index 116. Thecomputing device 102 then compares, using a matching algorithm, the set of candidate API-call graphs 506 to anNFA 510 that represents the behavior of potentially harmful code. The comparison allows thecomputing device 102 to detect whether the set of candidate API-call graphs 506 includes anexecutable file 110 or a sharedlibrary file 112 within thesoftware package 108 that contains the potentiallyharmful code 114. To perform the comparison, thecomputing device 102 can compute respective products of the NFA and each API-call graph 204 of the set of candidate API-call graphs 506. Thecomputing device 102 can then determine, using a graph traversal (e.g., a breadth-first search or a depth-first search), whether the respective products indicate that the set of candidate API-call graphs 506 include a file that matches the behavior of the potentiallyharmful code 114. - To determine a match between an API-
call graph 204 of the set of candidate API-call graphs 506 and theNFA 510, thecomputing device 102 considers the API-call graph 204 as an NFA with all states accepting. Thecomputing device 102 computes a synchronized product of the two NFAs, which is defined such that determining a match of the API-call graph 204 to theNFA 510 is equivalent to determining whether the synchronized product has a non-empty acceptance set. In this manner, matching the API-call graph 204 to theNFA 510 is reduced to a simple reachability problem solvable in linear time and space, for example, using a breadth-first or depth-first search. - The NFA is represented as a five-tuple (Q1, Σ, Δ1, q1, F1) illustrated in Equation 1:
-
(Q 1,Σ,Δ1 ,q 1 ,F 1), where (1) -
- Q1 is the set of states of the
NFA 510; - Σ is the set of input symbols to the NFA 510 (e.g., the alphabet);
- Δ1 is a transition function between states of the NFA 510:
- Δ1: Q1×(Σ∪{ϵ})→2Q1, ϵ being the empty string;
- q1∈Q1 is an initial start state of the
NFA 510; and - F1⊆Q1 is a set of accepting states of the
NFA 510.
- Q1 is the set of states of the
- Similarly, the API-
call graph 204 is represented by another NFA, which is denoted (Q2, Σ, Δ2, q2,F2). - The synchronized product of the two NFAs is defined as an NFA which shares the alphabet of the constituent NFAs, whose set of states is the Cartesian product of the two constituent NFAs, and which has a transition function as defined in Equation 2:
-
Synchronized product of (Q 1,Σ,Δ1 ,q 1 ,F 1) and(Q 2,Σ,Δ2 ,q 2 ,F 2)=(Q 1 ×Q 2,Σ,Δ′,(q 1 ,q 2),F 1 ×F 2), where (2) -
- Δ′={((s1, s2), ϵ, (t1, s2))|s2∈Q2∧(s1, ϵ, t1)∈Δ1}∪{((s1, s2), ϵ, (s1, t2))|s1∈Q1∧(s2, ϵ, t2)∈Δ2}∪{((s1, s2), a, (t1, t2))|a≠ϵ∧(s1, a, t1)∈Δ1∧(s2, a, t2)∈Δ2}.
- The synchronized product of two NFAs is a restriction of their Cartesian product such that only transitions where both automata recognize the same input symbol are allowed. The first two components of Δ′ allow each of the two NFAs to make an epsilon-move independently, while the third component allows the NFAs to recognize the same symbol in lockstep.
- Explicit computation of Δ′ uses |Q1|×|Q2| states and up to |Δ1|×|Δ2| transitions. In practice, many of these states and transitions are unreachable. The
computing device 102 can, therefore, compute the synchronized product on the fly, ensuring that only necessary states and transitions are computed. To efficiently compute the transitions outgoing from a state pair, thecomputing device 102 uses one automaton to support efficiently finding the outgoing transitions from its states. Thus, thecomputing device 102 efficiently computes Δ1(s) on the fly as Δ1(s)={(a1, t1)|(s, a1, t1)∈Δ1}. The other automaton similarly supports finding the outgoing transitions from a state with a given label. Thus, thecomputing device 102 efficiently computes Δ2(s, a) on the fly as Δ2(s, a)={t2|(s, a, t2)∈Δ2}. In this manner, thecomputing device 102 can compute transitions from a state (s1, s2) as shown in Equation 3 below: -
for each (a 1 ,t 1)∈Δ1(s 1): (3) -
- if a1=ϵ, then ((s1, s2), ϵ, (t1, s2)) is a transition.
- if a1≠ϵ, then for each
- t2∈Δ2(s2, a1): ((s1, s2), a1, (t1, t2)) is a transition;
- t2∈Δ2 (s2, ϵ): ((s1, s2), ϵ, (s1, t2)) is a transition.
- On-the-fly computation of the synchronized product enables not only finite-state but also some infinite-state systems to be processed in finite time. For example, NFAs with finite branching, e.g., where Δ1(s) is finite for all states reachable from q1, make progress, and a breadth-first search enables accepting states to be found in finite time if a finite string is accepted. Another implication is that the alphabet Σ need not be finite, e.g., Σ is a set of Unicode Transformation Format-8 (UTF-8) strings (not characters).
- Compute-intensive and explicit representation of Δ2(s, a), e.g., with an adjacency matrix, is obviated. The ability of one of the automata to efficiently and on-the-fly compute Δ2(s, a) using Δ2(s, a)={t2|(s, a, t2)∈Δ2} enables the
computing device 102 to efficiently operate on and represent other abstractions such as counter-extended NFAs. The counter-extended NFAs enable thecomputing device 102 to efficiently match bounded repetitions, including the regular expression (regex) operator {m,n}, which matches a regular expression at least m, but no more than n, times. Thecomputing device 102 traditionally performs this matching by creating an automaton with n subunits corresponding to the repeated expression. With on-the-fly computation, thecomputing device 102 represents the operator symbolically and generates the states only if needed. For example, traditional regex engines can take a long time to compile a {2,1000000000}, even for matching short strings such as b, a, and aaa. With the described techniques, thecomputing device 102 performs checking in time and space proportional to the length of the string. - At 512, the
computing device 102 determines whether there are additional ornew signatures 502. If there are additional signatures, thecomputing device 102 returns to theoperation 504. If there are no additional signatures, thecomputing device 102 terminates the operations of the flow diagram 500. -
FIG. 6 illustrates an example flow diagram 504 for identifying the set of candidate API-call graphs 506. The operations of the flow diagram 504 are described in the context of thecomputing device 102 ofFIG. 1 . The operations of the flow diagram 504 may be performed in a different order or with additional or fewer operations. - At 602, given the
signature 502, thecomputing device 102 computes a set of relevant n-grams and a Boolean formula as a representation of the potentially-harmful behavior. Thecomputing device 102 uses a heuristic 604 to compute the set of relevant n-grams and the Boolean formula. - As an example, the heuristic 604 can be a sequence-of-calls heuristic 606, which utilizes a sequence of calls, potentially in a loop, to generate the Boolean formula that contains a set of relevant n-grams. The set of relevant n-grams represent the sequence of calls in the
signature 502. For a file to match a formula generated using the sequence-of-calls heuristic 606, each of the n-grams in thesignature 502 must be present. Thecomputing device 102 can determine whether the set of relevant n-grams are present using a sliding window. As an example, if thesignature 502 is the expression “(abc){2+},” the Boolean formula for a 2-gram system is “ab AND be AND ca.” - As another example, the heuristic 604 can be a sequence-of-options heuristic 608, which utilizes a sequence of options in a loop. Each option can be satisfied by one or, in some situations, none of a set of specified calls. For each element in the sequence, the
computing device 102 computes the outgoing optional n-grams and combines them together in a disjunctive (OR) function. Thecomputing device 102 then combines the formulas of each element in a conjunctive (AND) function with any relevant n-grams. For example, if thesignature 502 is the expression “(a(b|c)d){2+},” the Boolean formula for a 2-gram system is “(ab OR ac) AND (bd OR cd) AND da.” -
Other heuristics 604 can be developed for specific cases and can be defined using n-grams. In other implementations, a nodal heuristic 610 can be used. In thenodal heuristic 610, thesignature 502 can be treated as an API-call graph, and thecomputing device 102 computes the n-grams going into a node and/or out of a node. In such a situation, thecomputing device 102 searches for a set of n-grams entering an entry node and a set of n-grams exiting an exit node and computes the set of candidate API-call graphs 506 by determining the API-call graphs 204 that contain at least one of the n-grams entering the entry node and at least one of the n-grams exiting the exit node. - At 612, the
computing device 102 fetches the candidate set of API-call graphs 506 from theinverted index 116 by determining the API-call graphs 204 that match the Boolean formula. - Example Methods
-
FIG. 7 is aflowchart 700 illustrating example operations to index a software package and detect potentially harmful code using API-call n-grams. The operations of theflowchart 700 are described in the context of thecomputing device 102 ofFIG. 1 . The operations of theflowchart 700 may be performed in a different order or with additional or fewer operations. - At 702, API-calls are generated from binaries of a software package. For example, the
computing device 102 generates the API-call graphs 204 from binaries of theexecutable files 110 and the shared library files 112 in thesoftware package 108. - At 704, n-grams are computed from the API-call graphs. For example, the
computing device 102 computes the n-grams 208 from the API-call graphs 204. - At 706, the n-grams are added to an inverted index that maps each of the n-grams to a respective identifier of the API-call graphs to enable locating of individual API-call graphs. For example, the
computing device 102 adds the n-grams 208 to theinverted index 116. Theinverted index 116 maps the n-grams 208 to a respective identifier of the API-call graphs 204 in which the n-grams 208 can be found. Theinverted index 116 enables locating of individual API-call graphs 204 based on a query using the n-grams 208. - At 708, a set of candidate API-call graphs, from among the API-call graphs, that match a signature are identified. The signature represents behavior of potentially harmful code. For example, the
computing device 102 identifies, from among the API-call graphs 204, the set of candidate API-call graphs 506 that match thesignature 502. Thesignature 502 represents behavior of potentially harmful code. - At 710, the set of candidate API-call graphs is retrieved from the inverted index. For example, the
computing device 102 retrieves the set of candidate API-call graphs 506 from theinverted index 116. - At 712, the set of candidate API-call graphs is compared, using a matching algorithm, to a non-deterministic finite automaton (NFA) to detect whether a file within the software package matches the behavior of potentially harmful code. The NFA represents the behavior of potentially harmful code. For example, the
computing device 102 compares the set of candidate API-call graphs 506 to theNFA 510 to detect whether a file within thesoftware package 108 matches the behavior of potentiallyharmful code 114. TheNFA 510 represents the behavior of potentiallyharmful code 114. -
FIG. 8 illustrates an example device diagram 800 of a user device 802 for which indexing thesoftware package 108 and detecting potentially harmful code using API-call n-grams can be implemented. The user device 802 may include additional functions and interfaces omitted fromFIG. 8 for the sake of clarity. - The user device 802 can be a variety of consumer electronic devices. As non-limiting examples, the user device 802 can be a mobile phone 802-1, a tablet device 802-2, a laptop computer 802-3, a desktop computer 802-4, a computerized watch 802-5, a wearable computer 802-6, or a voice-assistant system 802-7.
- The user device 802 includes one or
more processors 804 and computer-readable storage media 806. Theprocessor 804 can be a single-core processor or a multiple-core processor. Theprocessor 804 functions as a central processor for the user device 802. Theprocessor 804 can include other components, such as communication units (e.g., modems), input/output controllers, sensor hubs, system interfaces, and the like. - The
CRM 806 includes any suitable storage device (e.g., random-access memory (RAM), static RAM (SRAM), dynamic RAM (DRAM), non-volatile RAM (NVRAM), read-only memory (ROM), Flash memory) to store device data of the user device 802. The device data can include user data, multimedia data, an operating system, and applications of the user device 802, which are executable by theprocessor 804 to enable communications and user interaction with the user device 802. - The
CRM 806 also includes thesoftware package 108. As described above, thesoftware package 108 can be, for example, a collection of applications available for download to the user device 802. Thesoftware package 108 includes theexecutable files 110 and the shared library files 112. - Among the
executable files 110 and the shared library files 112, thesoftware package 108 can also include the potentiallyharmful code 114. For example, one or more of theexecutable files 110 or the shared library files 112 can include indicators of potentially harmful code or code that can potentially perform unwanted behavior on the user device 802. As described above, security engineers can index thesoftware package 108 and detect the potentiallyharmful code 114 using API-call n-grams. In response to identifying the potentiallyharmful code 114, updates, patches, or other measurements, via communication and input/output (I/O)components 808, can be taken to remove or address the potentiallyharmful code 114 or its malicious, unwanted, or potentially harmful behavior. - The
processor 804 is operatively coupled to the one or more communication and I/O components 808. The communication and I/O components 808 include data network interfaces that provide connection or communication links between the user device 802 and other data networks, devices, or remote systems (e.g., servers). The communication and I/O component 808 can couple the user device 802 to a variety of different types of components, peripherals, or accessory devices. Data input ports of the communication and I/O components 808 receive data, including image data, user inputs, communication data, audio data, video data, and the like. The communication and I/O components 808 can also enable wired or wireless communicating of device data between the user device 802 and other devices (e.g., the computing device 102), computing systems, and networks. - The one or more communication and I/
O components 808 can include a display. The one or more communication and I/O components 808 can also include one or more sensors, for example, embedded within the display or as a separate component of the user device 802. The communication and I/O components 808 provide connectivity between the user device 802, a user, and other devices and peripherals in the outside world. - In the following section, examples are provided.
- Example 1: A method comprising: generating API-call graphs from binaries of a software package; computing n-grams from the API-call graphs; adding the n-grams to an index that maps each of the n-grams to a respective identifier of the API-call graphs to enable locating of individual API-call graphs; identifying, from among the API-call graphs, a set of candidate API-call graphs that match a signature, the signature representing behavior of potentially harmful code; retrieving the set of candidate API-call graphs from the index; and comparing, using a matching algorithm, the set of candidate API-call graphs to a non-deterministic finite automaton (NFA) representing the behavior of potentially harmful code to detect whether a file within the software package matches the behavior of potentially harmful code.
- Example 2: The method of example 1, wherein generating the API-call graphs from the binaries of the software package comprises: computing a respective condensation of a control flow graph of each of the binaries to convert mutually-recursive functions into nodes of a directed acyclic graph; topologically ordering the nodes of the condensation; iterating through a most-downstream node of the nodes for the condensation; creating a recursive-function group for each of the nodes, the recursive-function group comprising at least one entry node and at least one exit node for each of one or more functions in the recursive-function group; creating a subgraph for each of the one or more functions in the recursive-function group, the subgraph linking basic blocks of the one or more functions to epsilon transitions; adding each of the one or more functions in the recursive-function group to a map of recursive-function groups for the nodes; and outputting an API-call graph comprising the recursive-function group for each of the nodes.
- Example 3: The method of any preceding example, wherein computing the n-grams from the API-call graphs comprises: merging strongly-epsilon-connected components of a respective API-call graph of the API-call graphs to generate an epsilon-subgraph acyclic graph of nodes of the API-call graph; topologically ordering the nodes according to an order of the nodes in the epsilon-subgraph acyclic graph; inverting the epsilon-subgraph acyclic graph from the nodes to respective non-epsilon predecessors; annotating, using a recursive algorithm, the nodes with an array of n-grams, including the non-epsilon predecessors and epsilon successors; aggregating the n-grams; and outputting a set of n-grams for the respective API-call graph.
- Example 4: The method of any preceding example, wherein the n-grams comprise n-grams of a customizable length and the index comprises an inverted index.
- Example 5: The method of any preceding example, wherein the n-grams comprise at least one of a one-gram and a two-gram.
- Example 6: The method of any preceding example, wherein the signature represents an arbitrary NFA with epsilon-moves.
- Example 7: The method of any of examples 1 through 5, wherein: the signature comprises a set of n-grams that represents a sequence of calls; and identifying the set of candidate API-call graphs comprises determining the API-call graphs that include the set of n-grams.
- Example 8: The method of any of examples 1 through 5, wherein: the signature comprises a set of optional n-grams and relevant n-grams that represents a sequence of options in a loop; and identifying the set of candidate API-call graphs comprises determining the API-call graphs that include at least one of the optional n-grams and each of the relevant n-grams.
- Example 9: The method of any of examples 1 through 5, wherein: the signature comprises a set of n-grams entering an entry node and n-grams exiting an exit node; and identifying the set of candidate API-call graphs comprises determining the API-call graphs that include at least one of the n-grams entering the entry node and at least one of the n-grams exiting the exit node.
- Example 10: The method of any preceding example, wherein the set of candidate API-call graphs comprises NFAs with all states accepting.
- Example 11: The method of example 10, wherein comparing the set of candidate API-call graphs to the NFA comprises: computing respective products of the NFA and each NFA with all states accepting of the set of candidate API-call graphs; and determining, using a graph traversal, whether the respective products indicate that the NFAs with all states accepting include a binary that matches the behavior of potentially harmful code.
- Example 12: The method of any preceding example, wherein the binaries comprise executable files, shared library files, or a combination thereof.
- Example 13: A system comprising means for performing the method of any of the preceding examples.
- Example 14: A non-transitory computer-readable storage medium comprising instructions that, when executed, configure a processor of a computing device to perform the method of any of examples 1 through 12.
- While various configurations and methods for indexing and detecting potentially harmful code using API-call n-grams have been described in language specific to features and/or methods, it is to be understood that the subject of the appended claims is not necessarily limited to the specific features or methods described. Rather, the specific features and methods are disclosed as non-limiting examples of indexing and detecting potentially harmful code using API-call n-grams.
Claims (14)
1. A method comprising:
generating API-call graphs from binaries of a software package;
computing n-grams from the API-call graphs;
adding the n-grams to an index that maps each of the n-grams to a respective identifier of the API-call graphs to enable locating of individual API-call graphs;
identifying, from among the API-call graphs, a set of candidate API-call graphs that match a signature, the signature representing behavior of potentially harmful code;
retrieving the set of candidate API-call graphs from the index; and
comparing, using a matching algorithm, the set of candidate API-call graphs to a non-deterministic finite automaton (NFA) representing the behavior of potentially harmful code to detect whether a file within the software package matches the behavior of potentially harmful code.
2. The method of claim 1 , wherein generating the API-call graphs from the binaries of the software package comprises:
computing a respective condensation of a control flow graph of each of the binaries to convert mutually-recursive functions into nodes of a directed acyclic graph;
topologically ordering the nodes of the condensation;
iterating through a most-downstream node of the nodes for the condensation;
creating a recursive-function group for each of the nodes, the recursive-function group comprising at least one entry node and at least one exit node for each of one or more functions in the recursive-function group;
creating a subgraph for each of the one or more functions in the recursive-function group, the subgraph linking basic blocks of the one or more functions to epsilon transitions;
adding each of the one or more functions in the recursive-function group to a map of recursive-function groups for the nodes; and
outputting an API-call graph comprising the recursive-function group for each of the nodes.
3. The method of claim 1 , wherein computing the n-grams from the API-call graphs comprises:
merging strongly-epsilon-connected components of a respective API-call graph of the API-call graphs to generate an epsilon-subgraph acyclic graph of nodes of the API-call graph;
topologically ordering the nodes according to an order of the nodes in the epsilon-subgraph acyclic graph;
inverting the epsilon-subgraph acyclic graph from the nodes to respective non-epsilon predecessors;
annotating, using a recursive algorithm, the nodes with an array of n-grams, including the non-epsilon predecessors and epsilon successors;
aggregating the n-grams; and
outputting a set of n-grams for the respective API-call graph.
4. The method of claim 1 , wherein the n-grams comprise n-grams of a customizable length and the index comprises an inverted index.
5. The method of claim 1 , wherein the n-grams comprise at least one of a one-gram and a two-gram.
6. The method of claim 1 , wherein the signature represents an arbitrary NFA with epsilon-moves.
7. The method of claim 1 , wherein:
the signature comprises a set of n-grams that represents a sequence of calls; and
identifying the set of candidate API-call graphs comprises determining the API-call graphs that include the set of n-grams.
8. The method of claim 1 , wherein:
the signature comprises a set of optional n-grams and relevant n-grams that represents a sequence of options in a loop; and
identifying the set of candidate API-call graphs comprises determining the API-call graphs that include at least one of the optional n-grams and each of the relevant n-grams.
9. The method of claim 1 , wherein:
the signature comprises a set of n-grams entering an entry node and n-grams exiting an exit node; and
identifying the set of candidate API-call graphs comprises determining the API-call graphs that include at least one of the n-grams entering the entry node and at least one of the n-grams exiting the exit node.
10. The method of claim 1 , wherein the set of candidate API-call graphs comprises NFAs with all states accepting.
11. The method of claim 10 , wherein comparing the set of candidate API-call graphs to the NFA comprises:
computing respective products of the NFA and each NFA with all states accepting of the set of candidate API-call graphs; and
determining, using a graph traversal, whether the respective products indicate that the NFAs with all states accepting include a binary that matches the behavior of potentially harmful code.
12. The method of claim 1 , wherein the binaries comprise executable files, shared library files, or a combination thereof.
13. A computing device comprising a processor configured to:
generate API-call graphs from binaries of a software package;
compute n-grams from the API-call graphs;
add the n-grams to an index that maps each of the n-grams to a respective identifier of the API-call graphs to enable locating of individual API-call graphs;
identify, from among the API-call graphs, a set of candidate API-call graphs that match a signature, the signature representing behavior of potentially harmful code;
retrieve the set of candidate API-call graphs from the index; and
compare, using a matching algorithm, the set of candidate API-call graphs to a non-deterministic finite automaton (NFA) representing the behavior of potentially harmful code to detect whether a file within the software package matches the behavior of potentially harmful code.
14. A non-transitory computer-readable storage medium comprising instructions that, when executed, configure a processor of a computing device to:
generate API-call graphs from binaries of a software package;
compute n-grams from the API-call graphs;
add the n-grams to an index that maps each of the n-grams to a respective identifier of the API-call graphs to enable locating of individual API-call graphs;
identify, from among the API-call graphs, a set of candidate API-call graphs that match a signature, the signature representing behavior of potentially harmful code;
retrieve the set of candidate API-call graphs from the index; and
compare, using a matching algorithm, the set of candidate API-call graphs to a non-deterministic finite automaton (NFA) representing the behavior of potentially harmful code to detect whether a file within the software package matches the behavior of potentially harmful code.
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
PCT/US2020/055191 WO2022081122A1 (en) | 2020-10-12 | 2020-10-12 | Indexing software packages and detecting malicious or potentially harmful code using api-call n-grams |
Publications (1)
Publication Number | Publication Date |
---|---|
US20230394141A1 true US20230394141A1 (en) | 2023-12-07 |
Family
ID=73038460
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US18/031,443 Pending US20230394141A1 (en) | 2020-10-12 | 2020-10-12 | Indexing Software Packages and Detecting Malicious or Potentially Harmful Code using API-call N-Grams |
Country Status (2)
Country | Link |
---|---|
US (1) | US20230394141A1 (en) |
WO (1) | WO2022081122A1 (en) |
Family Cites Families (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US7854002B2 (en) * | 2007-04-30 | 2010-12-14 | Microsoft Corporation | Pattern matching for spyware detection |
US20160057159A1 (en) * | 2014-08-22 | 2016-02-25 | Syracuse University | Semantics-aware android malware classification |
-
2020
- 2020-10-12 WO PCT/US2020/055191 patent/WO2022081122A1/en active Application Filing
- 2020-10-12 US US18/031,443 patent/US20230394141A1/en active Pending
Also Published As
Publication number | Publication date |
---|---|
WO2022081122A1 (en) | 2022-04-21 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
Wang et al. | Hyperscan: A fast multi-pattern regex matcher for modern {CPUs} | |
David et al. | Neural reverse engineering of stripped binaries using augmented control flow graphs | |
US10044750B2 (en) | Code labeling based on tokenized code samples | |
JP5579922B2 (en) | Double DFA decomposition for large-scale regular expression matching | |
US9680847B2 (en) | Structural recognition of malicious code patterns | |
US11481494B2 (en) | System and method for identifying and comparing code by semantic abstractions | |
US10983995B2 (en) | Information retrieval using automata | |
US10546002B2 (en) | Multiple sub-string searching | |
US9244679B1 (en) | Systems and methods for automatically identifying changes in deliverable files | |
US11093534B2 (en) | System and method for keyword searching using both static and dynamic dictionaries | |
US11386135B2 (en) | System and method for maintaining a dynamic dictionary | |
Rajasekaran et al. | An error correcting parser for context free grammars that takes less than cubic time | |
US20230394141A1 (en) | Indexing Software Packages and Detecting Malicious or Potentially Harmful Code using API-call N-Grams | |
McLaughlin et al. | Regulator: Dynamic Analysis to Detect {ReDoS} | |
US20100205411A1 (en) | Handling complex regex patterns storage-efficiently using the local result processor | |
Xiao et al. | Embedding code contexts for cryptographic api suggestion: New methodologies and comparisons | |
CN115729797A (en) | Code similarity function detection method and device, electronic equipment and storage medium | |
US10789067B2 (en) | System and method for identifying open source usage | |
Davis | On the impact and defeat of regular expression denial of service | |
Rong et al. | Int egrity: Finding Integer Errors by Targeted Fuzzing | |
Chitrakar et al. | CRBP-OpType: A constrained approximate search algorithm for detecting similar attack patterns | |
Li | Learning program-wide code representations for binary diffing | |
JP7424393B2 (en) | Estimation system, estimation method and estimation program | |
Forman | Petri—a UNIX tool for the analysis of Petri nets | |
Zhang et al. | Exploiting Structure in Regular Expression Queries |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:BOULGAKOV, ALEXANDRE;REEL/FRAME:063382/0089Effective date: 20201002 |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: DOCKETED NEW CASE - READY FOR EXAMINATION |