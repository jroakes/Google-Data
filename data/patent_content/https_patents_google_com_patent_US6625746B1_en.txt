US6625746B1 - Microprocessor instruction buffer redundancy scheme - Google Patents
Microprocessor instruction buffer redundancy scheme Download PDFInfo
- Publication number
- US6625746B1 US6625746B1 US09/594,632 US59463200A US6625746B1 US 6625746 B1 US6625746 B1 US 6625746B1 US 59463200 A US59463200 A US 59463200A US 6625746 B1 US6625746 B1 US 6625746B1
- Authority
- US
- United States
- Prior art keywords
- entries
- predetermined number
- operational status
- instruction
- microprocessor
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Lifetime, expires
Links
- 239000000872 buffer Substances 0.000 title claims abstract description 144
- 238000012360 testing method Methods 0.000 claims abstract description 65
- 230000002950 deficient Effects 0.000 claims abstract description 37
- 230000007246 mechanism Effects 0.000 claims abstract description 26
- 238000012545 processing Methods 0.000 claims description 34
- 238000000034 method Methods 0.000 claims description 26
- 230000003213 activating effect Effects 0.000 claims 1
- 238000004519 manufacturing process Methods 0.000 abstract description 31
- 238000003860 storage Methods 0.000 description 27
- 238000013461 design Methods 0.000 description 14
- 230000006870 function Effects 0.000 description 9
- 238000007667 floating Methods 0.000 description 7
- 238000010586 diagram Methods 0.000 description 5
- 238000013507 mapping Methods 0.000 description 4
- 238000006467 substitution reaction Methods 0.000 description 4
- 230000008901 benefit Effects 0.000 description 3
- 238000004891 communication Methods 0.000 description 3
- 230000007423 decrease Effects 0.000 description 3
- 238000005516 engineering process Methods 0.000 description 3
- 238000012986 modification Methods 0.000 description 3
- 230000004048 modification Effects 0.000 description 3
- 230000008569 process Effects 0.000 description 3
- 102100034033 Alpha-adducin Human genes 0.000 description 2
- 102100024348 Beta-adducin Human genes 0.000 description 2
- 102100034004 Gamma-adducin Human genes 0.000 description 2
- 101000799076 Homo sapiens Alpha-adducin Proteins 0.000 description 2
- 101000689619 Homo sapiens Beta-adducin Proteins 0.000 description 2
- 101000799011 Homo sapiens Gamma-adducin Proteins 0.000 description 2
- 101000629598 Rattus norvegicus Sterol regulatory element-binding protein 1 Proteins 0.000 description 2
- 230000002860 competitive effect Effects 0.000 description 2
- 230000007547 defect Effects 0.000 description 2
- 238000012795 verification Methods 0.000 description 2
- 238000013459 approach Methods 0.000 description 1
- 238000003491 array Methods 0.000 description 1
- 238000007664 blowing Methods 0.000 description 1
- 239000003990 capacitor Substances 0.000 description 1
- 230000015556 catabolic process Effects 0.000 description 1
- 239000007795 chemical reaction product Substances 0.000 description 1
- 238000013500 data storage Methods 0.000 description 1
- 238000006731 degradation reaction Methods 0.000 description 1
- 230000000694 effects Effects 0.000 description 1
- 230000003116 impacting effect Effects 0.000 description 1
- 238000010926 purge Methods 0.000 description 1
- 230000004044 response Effects 0.000 description 1
- 238000012546 transfer Methods 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/38—Concurrent instruction execution, e.g. pipeline, look ahead
- G06F9/3802—Instruction prefetching
- G06F9/3814—Implementation provisions of instruction buffers, e.g. prefetch buffer; banks
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/38—Concurrent instruction execution, e.g. pipeline, look ahead
- G06F9/3802—Instruction prefetching
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/38—Concurrent instruction execution, e.g. pipeline, look ahead
- G06F9/3836—Instruction issuing, e.g. dynamic instruction scheduling or out of order instruction execution
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/38—Concurrent instruction execution, e.g. pipeline, look ahead
- G06F9/3836—Instruction issuing, e.g. dynamic instruction scheduling or out of order instruction execution
- G06F9/3838—Dependency mechanisms, e.g. register scoreboarding
- G06F9/384—Register renaming
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/38—Concurrent instruction execution, e.g. pipeline, look ahead
- G06F9/3854—Instruction completion, e.g. retiring, committing or graduating
- G06F9/3856—Reordering of instructions, e.g. using queues or age tags
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/38—Concurrent instruction execution, e.g. pipeline, look ahead
- G06F9/3854—Instruction completion, e.g. retiring, committing or graduating
- G06F9/3858—Result writeback, i.e. updating the architectural state or memory
Definitions
- the present invention relates to improving manufacturing yield for microprocessor chips by providing redundant, or spare instruction buffer entries and accurately identifying those entries which are available for use. More particularly, the present invention includes a technique that tests the instruction buffer circuitry and stores the results of these tests in order to ensure that a sufficient number of buffer entries are available to meet the baseline specification of the microprocessor.
- Manufacturing yield is essentially the percentage of ICs that meet the design specification relative to the total number of chips produced.
- the manufacturing yield usually decreases.
- per chip costs often decrease as the fabrication process is tuned and optimized.
- it is often necessary, if not critical, to increase manufacturing yields especially during the early stages of chip production when the manufacturing costs are highest.
- Modem microprocessors capable of out-of-order execution make use of large numbers of dataflow-oriented instruction buffers for holding instructions while their operands develop.
- the instruction buffers accept new instructions from the dispatch logic, and coordinate the issue of instructions to various execution units based on operand availability, instruction age and other mechanisms.
- these instruction buffers contain content addressable memory (CAM) oriented circuitry that detects when required operand values are available, and either captures a copy of the operand data or sets a flag to indicate that the data is not available in subsequent stages of the execution pipeline (i.e. in a register file that will be accessed as the instruction is allowed to progress).
- CAM content addressable memory
- instructions are provided to the instruction buffer, they are allocated into unused entries. That is, each entry is the same as every other entry such that a particular instruction can be allocated to any entry in the instruction buffer.
- the instruction buffers are “self allocating”, i.e. the instruction is presented to the group of instruction buffer entries and the dataflow-oriented logic surrounding the entries automatically coordinates which of the available entries will receive the instruction.
- instructions leave the instruction buffer as their dependencies are resolved (independent of their position in the buffer or age) and are “issued” to an execution unit (actually, it is common practice to allow them to linger in the instruction buffer entry for a fixed number of cycles beyond the issue point so that if the instruction is “rejected”, it can easily be reissued without having to be re-fetched and re-dispatched).
- Dataflow instruction processing refers to a microprocessor technology wherein resolution of the dependencies associated with the instruction being executed occurs in a continuous manner with a reduced need for pipeline stages, as commonly used in microprocessor technologies.
- logic is provided which corresponds to an individual instruction being processed, rather than a functional pipeline stage.
- instruction processing focuses more on the individual instruction than a particular pipeline stage.
- the scope of the present invention contemplates all types of microprocessors, microcontrollers, embedded controllers, digital signal processors and the like including those having distinct pipeline stages.
- register allocation/deallocation logic examines the state of the physical register pool, and selects a register that is currently not active, and then marks it as “in use”. Later, when the instruction is either completed (or purged), the register deallocation logic frees the register again for future use.
- rename buffers or registers.
- rename registers and “rename buffers” will be used interchangeably herein. These rename buffers act as temporary storage for instructions that have not completed and as write-back buffers for those that have.
- rename registers are provided for storing instruction results before they are completed and committed to the architected registers.
- GPRs general purpose registers
- rename registers may also be provided for other architected registers, such as two rename buffers for the floating point registers (FPR) and eight rename registers for the condition register (CR).
- the dispatch unit when the dispatch unit provides an instruction to the appropriate execution unit (i.e. the integer unit (IU), floating point unit (FPU), load/store unit (L/S), or the like), it allocates a rename register for the results of that instruction.
- the dispatch unit also provides a tag to the execution unit identifying the result that should be used as the operand.
- the proper result is returned to the rename buffer it is provided to the execution unit, which begins execution of the instruction. Instruction results are not transferred from the rename registers to the architected registers until any speculative branch conditions are resolved and the instruction itself is retired without exceptions. If a speculatively executed branch is found to have been incorrectly predicted, the speculatively executed instructions following the branch are flushed and the results of those instructions are flushed from the rename registers.
- the appropriate execution unit i.e. the integer unit (IU), floating point unit (FPU), load/store unit (L/S), or the like
- IU integer unit
- FPU
- register renaming minimizes architectural resource dependencies, namely the output and anti dependencies, that would otherwise limit opportunities for out-of-order execution.
- a GPR rename buffer entry is allocated when an instruction that modifies a GPR is dispatched. This entry is marked as allocated but not valid. When the instruction executes, it writes its results to the entry and sets the valid bit. When the instruction completes, its result is copied from the rename buffer entry to the GPR and the entry is freed for reallocation. For load with update instructions that modify two GPRs, one for load data and another for address, two rename buffer entries are allocated.
- An instruction that modifies a GPR is assigned one of the twelve positions in the GPR rename buffer. Load with update instructions get two positions since they update two registers. When the GPR rename buffer is full, the dispatch unit stalls when it encounters the first instructions that need an entry. A rename buffer entry becomes available in one cycle after the result is written to the GPR.
- Operation of rename buffers associated with other register files function in a similar manner.
- Redundancy and sparing are methods that are known in the art. These techniques supply additional circuit elements, beyond those required for the baseline specification of the IC, to act as spares in the event that certain ones of the original elements prove to be defective.
- the use of redundancy in caches has been common for some time, but due to complexity and cycle time considerations has not been used for other structures in microprocessors.
- the present invention relates to providing redundancy in the instruction buffer file circuitry which, due in part to the data flow oriented trend, is becoming a larger portion of the microprocessor core in terms of physical area and importance.
- fuses are provided that are associated with each cache line. As the cache is tested, those fuses associated with lines that test bad can be blown, or opened, and the array access decoder circuitry is modified to note the state of these fuses. The decoder circuitry then “decodes around” any bad entries by recognizing an address to a bad cache line and substituting a functional cache line, while maintaining a record of this substitution.
- the problem with this traditional scheme is that a significant amount of complexity is required in the cache array circuitry provide the address substitution and tracking mechanism. This is undesirable not only in the amount of additional logic circuitry that is required to be implemented in the chip, but also in the amount of cycle time that is required.
- decode logic each time the processor tries to access the portion of the cache that tested bad, decode logic must identify the request as being to the bad address and provide a substitute address to a spare cache location where the data can be stored. This decoding and address substitution occurs continuously during the operation of the data processing system. Thus, it can be seen that a significant amount of cycle time can be consumed over and over during system operations as access attempts to bad cache locations are continually processed.
- the instruction buffer circuitry is usually considered a critical path, which is very sensitive to cycle time pressure.
- the conventional cache redundancy decode scheme cannot be applied to an instruction buffer circuitry environment to solve the problem addressed by the present invention which provides redundant instruction buffer entries without adding complexity or negatively impacting cycle time.
- the present invention is a mechanism for providing redundancy in the instruction buffer of a microprocessor such that entries which test bad during manufacturing can be tolerated and the baseline specification of the microprocessor can be met.
- the present invention utilizes the ability of a content addressable memory (CAM) to individually access the entries in a microprocessor instruction buffer to allow additional entries, beyond those called for in the specification to be provided.
- CAM content addressable memory
- the entries are tested and those found “bad” are identified and avoided by updating instruction allocation logic with a list of the test status of each entry, or setting a “manufactured good” bit in the entry itself.
- the present invention involves a modification to the instruction buffer allocation function (which can either be discrete logic outside the buffer, or dataflow-oriented logic built directly into the buffer (“manufactured good bit”).
- the modification allows the allocation function to note that one or more entries are “physically bad” and cannot be used for any instruction.
- One way of providing this information to the allocation function is by a list corresponding to the state of a set of fuses that can be set during the manufacturing test process which essentially involves running a set of test patterns that identify which instruction buffer entries are bad and blowing the fuses associated with those entries.
- a corresponding bit in a scannable latch is then set such that a bit vector having an indicator of the tested state of each instruction buffer entry can then be generated and used to update the instruction allocation logic to prevent any instruction from be provided to a defective instruction buffer entry.
- Other testing schemes may also be used to build the list of buffer entries, such as power on self test (POST), built in self test (BIST), or the like.
- POST power on self test
- BIST built in self test
- the instruction buffer would be built with more physical entries than required by the design specification of the microprocessor so that, if needed, several buffer entries can be used as spares without affecting the end product performance.
- the present invention contemplates a “manufactured good” bit (M) in each entry in the instruction buffer.
- Each of the entries also includes a “valid” bit (V) which informs the microprocessor when the entry is valid, i.e. available for use because the instruction previously in that entry has been processed (executed, flushed or the like).
- V valid bit
- control logic will check the “valid bit” and the “manufactured good” of the entries in the buffer and when both bits indicate that the entry has tested as being operational (M bit) and ready to accept a new instruction (V bit), then the instruction is placed by allocation logic in an available buffer entry
- the present invention uses existing instruction allocation functionality to prevent an instruction buffer entry that was manufactured bad to ever be included in a list of entries that are available to receive microprocessor instructions. In this manner redundant or spare entries, above the baseline specification of the microprocessor, can be provided to account for any faulty buffer entries that are present due to a less than 100% instruction buffer manufacturing yield.
- existing logic to prevent those entries that test bad from ever being used, an instruction buffer having sufficient entries to meet the microprocessor specification is ensured, without the adding costly and complex control logic, or requiring sorting of the chips to find those which happen to have been manufactured with instruction buffer entries that comply with the specification.
- FIG. 1 is a block diagram of an overall computer system that may include a microprocessor capable of implementing the instruction buffer entry redundancy scheme of the present invention
- FIG. 2 is another block diagram of a prior art cache redundancy system to be contrasted with the buffer entry redundancy of the present invention
- FIG. 3 represents a first preferred embodiment showing the elements of a microprocessor which implements the redundant instruction buffer entry scheme of the present invention
- FIG. 4 shows a physical register pool that is defined as the architected register file for a particular microprocessor
- FIG. 5 is a diagram showing the relationship of the status of instruction buffer entries and bit vector fields in a first preferred embodiment of the present invention
- FIG. 6 illustrates another preferred embodiment of the present invention having an instruction buffer entry including a manufactured good bit in accordance with the present invention.
- a central processing unit (CPU) 10 may include a PowerPC microprocessor, commercially available from the IBM Corporation or a Pentium class microprocessor, available from Intel Corporation interconnected to the various other system components by a system bus 12 .
- Read only memory (ROM) 16 is connected to CPU 10 via bus 12 and includes the basic input/output system (BIOS) that controls the basic computer functions.
- RAM random access memory
- I/O adapter 18 may be a small computer system interface (SCSI) adapter that communicates with a disk storage device 20 .
- SCSI small computer system interface
- Communications adapter 34 may be a network card that interconnects bus 12 with an outside network. Adapter 34 may also include an I/O port that allows a connection to be made, through a modem 40 , or the like to enable the data processing system to communicate with other such systems via the Internet, or other communications network (LAN, WAN).
- User input/output devices are also connected to system bus 12 via user interface adapter 22 and display adapter 36 .
- Keyboard 24 , track ball 32 , mouse 26 and speaker 28 are all interconnected to bus 12 via user interface adapter 22 .
- Display monitor 38 is connected to system bus 12 by display adapter 36 . In this manner, a user is capable of inputting to the system through keyboard 24 , trackball 32 or mouse 26 and receiving output from the system via speaker 28 and display 38 .
- an operating system (OS) 39 such as the DOS, OS/ 2 , Windows operating system, or the like is shown running on CPU 10 and used to coordinate the functions of the various components shown in FIG. 1 .
- FIG. 2 a block diagram is provided that illustrates an example of redundancy as used in a cache memory system.
- Traditional cache redundancy schemes rely on the index-based decoder circuitry to steer around bad rows/columns in the cache.
- the instruction buffers are used in a different manner, as they are accessed by a CAM-based mechanism and is distinguished from the traditional cache redundancy scheme.
- Bus 12 connects central processing unit 10 to a cache controller 50 which, for the purposes of this description is considered as included in RAM 14 shown in FIG. 1 .
- Cache controller 50 includes a directory, associated tags and comparator that determine, among other things, when data is present in a cache memory array 54 .
- cache controller 50 determines whether a cache “hit” (data is present in the cache) or “miss” (data is not present in the cache) occurs. Further, cache controller 50 will control all accesses to cache memory array 54 by CPU 10 or another bus master device connected to system bus 12 . Cache accesses will include read operations which retrieve data from array 54 that is to be processed and write operations that place data into the cache for future use.
- Cache memory array 54 is depicted as an array of storage elements 53 which maintain the state of a binary value, i.e. a logical 1 (voltage) or a logical 0 (ground, or reference potential).
- Various types of circuits can be used to store these values, including two inverters each having their outputs connected to the input of the other inverter, capacitors that store a charge and maintain a voltage thereacross, or the like.
- These storage elements store a bit of data and are configured in an array of multiples rows and columns. The rows of storage elements will combine to form data bytes, words, double words, quad words, and the like. Each bit of data in a row is accessed by identifying its position in the array through a row access identifier and column access identifier.
- each column position may be C 0 , C 1 , C 2 , C 3 . . . Cn and each row position may be R 0 , R 1 , R 2 , R 3 . . . Rm. Therefore, each storage element 53 will have a defined location in the array 54 . For example, the leftmost storage element in the top row will be at location R 0 C 0 while the storage element in the second column from the left in the third row from the top will be at R 2 C 1 , and so forth. It should be noted that FIG. 2 shows an array with a variable number of columns and rows since the size of cache arrays used can vary greatly.
- CPU 10 will send a read request, or the like, to cache controller 50 including an address corresponding to the requested data.
- Cache controller 50 must then determine the physical location in array 54 where the requested data is located.
- a decoding operation then occurs wherein the read request is decoded by row decode unit 51 and column decode unit 52 to determine the coordinates in array 54 where the requested data is located.
- CPU 10 when CPU 10 requires a certain byte of data, it may request the byte stored at, for example, the storage elements located in array 54 at locations R 1 C 0 , R 1 C 1 . . . R 1 C 7 to obtain this information.
- row decode unit 51 determined from the read request that the requested byte was somewhere in row 1
- column decode 52 determined that the byte was located in the first 8 columns of the array, i.e. columns 0-7. Combining this information it can be seen that the requested byte is in the first 8 columns of the second row of array 54 .
- FIG. 2 shows two additional columns (n+1, n+2) and two additional rows (m+1, m+2) included for redundancy.
- the number of extra columns and rows can vary depending on such factors as the size of the cache, implementation, manufacturing process, and the like.
- row decode logic 51 will cause the transaction address to be interpreted as row Rm+1 for the bit of data that would have been stored at R 1 C 2 . That is, the transaction address will be decoded to include Rm+1, C 2 on each occasion when the storage element 53 at location R 1 C 2 is called for by the transaction. It should be noted that the system will continually attempt to access location R 1 C 2 and each time, row decode logic 51 will have to map the request to the redundant location, Rm+1, C 2 .
- This increased cycle time for a cache access will also occur when column redundancy is used. For example, if the spare storage element at R 1 , Cn+1 is used to store the bit of data that would have been located at R 1 C 2 , then column decode 52 will have to decode every access attempt to row R 1 , C 0 -C 7 to substitute R 1 , Cn+1 for R 1 C 2 . Again an unacceptably high increase in cycle time will occur since the decode logic must interpret all cache access transaction to actually include the redundant location, i.e. R 1 , Cn+1. It also should be noted that attempts to access storage elements at a given cache location will occur very frequently and cause the decode logic to direct the transaction to the “good” storage elements for each attempt. Thus, the performance is continually impacted for each attempt to a particular storage element.
- microprocessor 11 that is capable of implementing the novel redundancy scheme of the present invention is shown.
- microprocessor as used herein will refer to the basic instruction processing and execution unit(s) and can be considered a subset of a CPU which may include additional data processing functions, e.g. I/O.
- Register renaming is a technique that is relatively common in many of today's speculative, out of order microprocessors.
- the PowerPC 604 microprocessor commercially available from IBM
- Pentium II microprocessor from the Intel Corp. are examples of processors that utilize register renaming.
- register renaming operates to build operand data into a mapper, that is a portion of the overall renaming logic.
- the mapper then keeps track of the logical register set and its correspondence to the physical register file.
- a microprocessor may have 32 architected registers in the general purpose register (GPR) file, each of which is 32 bits wide, and twelve 32 bit rename registers. These registers make up the logical general purpose register set for this processor.
- GPR general purpose register
- the base line specification for this processor calls for 32 architecturally defined general purpose registers and 12 rename registers. This number of registers will be needed for this particular microprocessor to meet its intended design criteria. It can be seen that for this implementation 44 physical registers will be needed to account for the GPRs and rename registers.
- a microprocessor design may also have a baseline specification which calls a certain number of instruction buffer entries.
- Mapper 140 will operate to control the allocation of physical registers for use as either architected or rename registers in accordance with the microprocessor design specification, while instruction allocation logic 103 will control the allocation of instruction buffer entries for use by instructions waiting for their operands to develop. This will ensure that a sufficient number of registers and instruction buffer entries are provided in accordance with the microprocessor design specification.
- modem microprocessors often include instruction buffers in the dispatch stage that provide a storage location for the instructions to wait while their operands develop.
- Instruction buffer allocation logic is provided that determines when a fetched instruction can be provided to one of the entries in the instruction buffer.
- a design specification may call for 12, 36 or more buffer entries for a particular microprocessor to meet its baseline specification. Again, with smaller line geometries occurring with greater frequency, manufacturing yield is very important. Therefore, it would be advantageous to be able to include a number of extra buffer entries to compensate for any entries that may test bad during post manufacturing testing.
- a fetch unit 100 is shown that will retrieve the microprocessor instructions to be executed from a data cache, or the like (not shown). The fetched instructions are then latched into latch 101 prior to entering the decode stage. Instruction buffer 110 is then provided to store the instructions during the decode process and prior to their dispatch to the microprocessor execution units. It can be seen that instruction buffer 110 includes buffer entries 113 and multiple redundant entries 112 , which will be discussed in greater detail below in conjunction with FIG. 7 .
- bit vector 111 is shown in FIG. 3 which is used to provide an indication of the state of each entry 113 in buffer 110 . That is, a bit is provided which corresponds to each entry 113 to indicate whether that entry was tested “good”. More particularly, a manufacturing test can be performed which will determine if the entry will store the correct instructions and data. If so, in this preferred embodiment, the corresponding bit will be a logical 0, while an entry which tests bad will be designated by the corresponding bit in vector 111 by a logical 1. Of course, those skilled in the art will understand how a logical “1” could be used to designate “good” bits with a logical “0” corresponding to bits which test “bad”.
- one type of test logic that may be used in conjunction with the present invention generates a pattern of binary values (1's and 0's) and write the pattern to the storage location being tested. The pattern is then read back and compared to the generated pattern. If the retrieved pattern matches the generated pattern, then the storage location will be considered as having a functional operational status, i.e. “good” and the logical 0 will remain in the corresponding bit. However, if the patterns do not match, the corresponding bit will be set to a logical 1, indicating that the entry has a defective operational status, i.e. tested “bad”.
- Instruction allocation logic 103 is also shown in FIG. 3 and is used by microprocessor 11 to assign the fetched instructions to one of the multiple entries 113 in instruction buffer 110 . Once the bit vector is generated, it is provided to instruction allocation logic 103 . Logic 103 can then use various mechanisms for designating which entries are functional and which are defective. For example, a “manufactured good” bit in the instruction buffer entry itself could be set in accordance with the indicator in bit vector 111 . Of course other methods could be used to designate the operational status of the various entries, such as using a tag, pointer, mapping table, link, flag, or the like.
- the fetched instruction can be allocated to only those entries 113 which have tested “good” as indicated by, for example, a corresponding “0” in bit vector 111 .
- This enables spare, or redundant entries 112 to be considered for use by allocation logic 103 . Therefore, should one of the entries 113 that make up the microprocessor baseline specification test “defective”, then allocation logic 103 can assign the fetched instruction to a redundant entry 112 which has tested “functional”.
- redundant instruction buffer entries can be introduced to the microprocessor design at a critical path without any performance degradation.
- register file 130 is shown as being coupled with instruction buffer 110 , latch 115 and write back unit 122 . Redundant registers are also included and shown by reference numeral 131 .
- register file 130 will include both rename registers and general purpose registers. While a specific number of registers are shown in FIG. 3, those skilled in the art will understand that many different configurations of register files are possible, including general purpose registers files including 80 or more logical registers.
- Mapper 140 is also shown and includes register allocate/deallocate logic that matches instructions with available registers in register file 130 .
- Freelist 144 is provided and operates in conjunction with the register allocate/deallocate logic of mapper 140 and maintains a list of registers that are available for use, i.e. to be matched with a fetched instruction.
- the instructions are provided to latch 115 in the execute stage.
- the decode stage it is determined what type of instruction is to be executed, which will govern whether the instruction should be provided to a particular execution unit.
- modern microprocessors normally include multiple execution units, such as an integer unit, floating point unit, load/store unit, branch processing unit, or the like.
- a floating point ADD instruction will be provided to the floating point unit
- a COMPARE instruction will normally be provided to the integer unit, and so forth.
- These instructions will normally require data to complete their operation. This data will usually be provided from the register file 130 , after having been placed in a particular register by execution of a previous instructions or during the write back stage.
- the results are placed in latch 121 for entry to the write back stage.
- Write back occurs when a result is written from the rename registers into the architectural registers (GPRs). Results are written back at completion time or are moved into the write-back buffer.
- Write back unit 122 will provide results back to the designated rename registers in register file 130 so that these results can then be used as data operands for subsequent instructions.
- a completion unit 124 is provided that generally includes a completion buffer and associated logic that compares the program number of the results of the executed instructions and places the results in sequential order in the buffer, prior to the results being written back and committed to the architecture. Latch 123 is used to store the results prior to entering the complete stage. Subsequent to completion, the register allocated to the instruction that was executed is released and added to freelist 144 as one that is available for allocation to another instruction being processed.
- Freelist 144 receives the location of available physical registers from completion unit 124 after the results from these registers are committed to the architecture. A first-in-first-out algorithm, or the like is then be used to maintain the registers available for allocation in freelist 144 . When the available registers are ready to be allocated their address is provided to mapper 140 for assignment to the next instruction being dispatched as a destination register for associated operand data.
- Modern microprocessors may avoid contention for a given register location by providing rename registers for storing instruction results before the completion unit commits them to the architected register(s), i.e. the 32 general purpose registers.
- the dispatch unit dispatches an instruction to its execution unit, it allocates a rename register for the results of that instruction.
- the dispatch unit also provides a tag to the execution unit identifying the result that should be used as the operand.
- the proper result is returned to the rename buffer it is latched into the reservation station (buffer between dispatch and execute stages). When all operands are available in the reservation station, execution can begin.
- the completion unit does not transfer instruction results from the rename registers to the architected registers until any preceding speculative branch conditions in the completion queue are resolved and the instruction itself is retired from the completion queue without exceptions. If a speculatively executed branch is found to have been incorrectly predicted, the speculatively executed instructions following the branch are flushed from the completion queue and the results of those instructions are flushed from the rename registers.
- a mechanism for determining which ones, if any, of the registers in register file 130 test bad during manufacturing testing.
- electronic fuses 152 are wired to a test port 150 and connected to scannable latch 154 .
- the corresponding fuse can be blown and an associated bit set in scannable latch 154 .
- an indicator is provided for each register that is determined to be defective during testing.
- POST power on self test
- bit vector 142 can be generated having entries that correspond to each register in register file 130 . This information can then be provided to mapper 140 and used to allocate only functional registers in file 130 to instructions during dispatch such that the registers which tested bad are never considered for allocation.
- BIST built in self test
- the present invention essentially operates to build a list of registers which are available for allocation. Once this list-is built, there are no additional re-decoding activities, register reassignment procedures, or the like to be implemented beyond the register allocation that normally occurs during renaming operations.
- the first instruction adds the contents of register R 0 and register R 1 and places the result in register R 31 .
- mapper 140 will select the next available physical register from freelist 144 and map the logical destination register R 31 to this physical register.
- the allocated physical register is R 49 from FIG. 5 .
- a mapping table is set up to track the allocation of physical registers to logical registers. For more details see FIGS. 7.52 and 7.53 on page 252 of the Advanced Computer Architectures text.
- the ADD 2 instruction places the sum of registers R 31 (R 49 physical register) and R 0 in register R 20 .
- the operand data from instruction (1) is still being utilized such that physical register R 49 remains allocated as the destination register of instruction (1).
- the assigned physical register must have another value written to it, i.e. the data that was the result of the assigned instruction is not longer present in the register; and second, there are no previous instructions that are using that value, i.e. no previously dispatched instructions are using the data stored in the registers by the assigned instruction.
- the allocate logic uses the assigned register for the life of the value originally placed therein.
- the register is allocated when first needed as a target destination for holding intermediate results and deallocated when the logical (architected) register is reused, i.e. a different value for another instruction is stored to the same logical register.
- physical register R 49 is allocated by the dispatch unit as the destination register for the operand data of instruction (1).
- the contents of physical register R 49 (linked to logical register R 31 ) are then used by instruction (2).
- Instruction ADD 3 then places the results of the addition of registers R 2 and R 3 into logical register R 31 (physical register R 49 ).
- instruction (3) places a new value in logical register R 31 such that one of the conditions for deallocation is met.
- physical register R 49 is deallocated and returned to freelist 144 .
- mapper 140 will allocate a new register (for example R 48 ) from register pool 130 and assign it as the destination register for the results of this ADD instruction. In this manner, physical registers in register pool 130 are allocated and deallocated by mapper 140 such that register renaming is implemented.
- R 48 a new register
- mapper 140 will also have an assigned physical register from freelist 144 , and the number and types of instructions will be very complex and diverse.
- the present invention is being described in the context of a general purpose register file, it should be understood that the scope of the present invention contemplates use in a floating point register file, condition register file or any set of physical registers which are mapped to logical registers.
- register renaming is a mechanism which tracks the usage of various physical registers and maps this usage to a logical, or architected register that is recognized by the software.
- the register renaming logic is modified to prevent any physical registers in the microprocessor from being used which test bad during manufacturing testing, POST and/or BIST.
- the register set 130 shown in FIG. 5 includes 50 (R 0 -R 49 ) physical registers.
- a microprocessor may have 32 registers to be used as the architected general purpose register file 133 of FIG. 4 and 12 registers for use as the rename register file 132 .
- many types of microprocessors are available with different GPR and renaming register configurations.
- fuses 152 in fuse block 150 will be used as the mechanism to build bit vector 111 . Once a particular lot of microprocessors 11 is fabricated they will undergo testing to determine whether the functional units included therein are operating normally. As noted above, with the smaller line geometries (e.g. 0.18 and even 0.13 micron line width) the yield may be lower than needed to economically manufacture the processor. Therefore, the critical elements, such as instruction buffer 110 are tested to ensure they will accurately store the desired binary value which represent an instruction and corresponding data to be processed.
- a corresponding fuse 152 is blown and an associated bit is set in scannable latch 154 .
- the information in latch 154 is then used to build vector bit 111 .
- FIG. 5 shows how bit vector 111 is input to instruction allocation logic 103 where a mapping table included therein is updated.
- the present invention ensures that entries (3) and (10) will never be used as the destination buffer entry of an instruction being processed in the dispatch stage.
- This allows redundant, or spare entries to be provided which can be used in place of the defective entries (3) and (10).
- 12 entries are needed for the system to meet its baseline specification.
- four 4 spare entries are provided giving a total of 16 .
- allocation logic 103 could utilize entries (14) and (15) in place of entries (3) and (10) to provide the actual buffer entries needed to meet the system specification.
- bit vector 111 is input to instruction allocation logic 103 only once such that only “good” entries are considered to receive instructions in the dispatch stage and there is no increased cycle time in the critical path of the microprocessor.
- a 12 entry instruction buffer with 4 spare entries is provided herein to assist in the explanation of the present invention and should not be construed as a limitation. As such, other sizes and configurations of instruction buffers are contemplated by the scope of the present invention.
- allocation logic 103 when an instruction is ready to be provided to an instruction buffer entry, allocation logic 103 will consider only entries (1), (2), (4)-(9), (11), (12) and (14)-(16) as candidates for receiving the instruction. It should be noted in this preferred embodiment that instructions are essentially broadcast to buffer 110 such that the next available entry having its valid bit (V) set and which corresponds to a bit vector field that indicates the entry has tested “good” will receive the instruction.
- allocation logic 103 is updated with bit vector 111 , there will be no additional decode function required to ensure that instructions are assigned to only entries which are operational. Therefore, no increased cycle time is associated with use of the present invention. That is, in a first preferred embodiment existing instruction allocation logic is used by the present invention as a mechanism to track and control the availability and status of entries in instruction buffer 110 , as shown in FIG. 5 . Thus, instruction allocation is used non-conventional manner to prevent those entries in buffer 110 that test bad from ever being used. Further, there is no impact on cycle time performance during decode/dispatch since the instruction allocation logic is permanently updated at initialization with those entries in instruction buffer 110 that are defective. In this manner a mapping table or other mechanism is used to relate, or establish a link between allocation logic 103 and the “good” instruction buffer entries such that only functional entries will be considered for allocation.
- FIG. 6 shows a detailed view of the information included in an entry 113 of buffer 110 .
- instruction buffer 110 includes various control logic that is associated with each entry 113 and 112 . This data flow oriented processing allows instructions to be processed more independently and minimizes the amount of pipelining that occurs.
- instruction buffer 110 is structured as a content addressable memory (CAM) which allows specific information to be placed in, and retrieved from individual instruction buffer entries. More particularly, a CAM is an associative memory where a part of the data itself is stored in the memory. To read information from the CAM, a section of the information in question is input into the CAM (instruction buffer 110 in the present invention) and compared with a section of information already stored therein. If a match occurs, the CAM returns the information associated with that section of information. In the context of the instruction buffer 110 of the present invention, allocation logic 103 will essentially broadcast information to each entry 113 , 112 .
- CAM content addressable memory
- Each entry 113 and 112 has an associated comparator and if a match occurs the information is then used to update the matching entry.
- specific operand data is returned from the data cache, registers, or the like, it is broadcast from logic 103 to each entry in buffer 110 and matched with the appropriate instruction.
- the CAM structure of the instruction buffer not only allows information to be selectively provided to individual buffer entries, but also provides for the individual retrieval of information from a single entry.
- FIG. 6 illustrates the types of information that may be included in an instruction buffer entry 113 .
- buffer 110 will include multiple entries 113 to 113 n , as shown in FIG. 6, and in accordance with the present invention, spare entries 112 will also be provided that are structured identically to entries 113 .
- Entries 113 , 112 will include a great deal of digital information may be on the order of 128 bits wide.
- the instruction operation code (op code) will be included that identifies the type of instruction to be executed, e.g. ADD, COMPARE, LOAD.
- Operand data register address fields such as Ra, Rb are included where various data to be manipulated by the instruction is stored.
- a target register address is provided that will indicate the location where the results of the data manipulation is to be stored.
- Each of these register address fields has an associated “operand ready” bit to indicate whether the data is available to be manipulated by the instruction and/or the results ready to be stored in the target register.
- valid bit “V” is provided that indicates when the entry is available for use by a new instruction awaiting execution.
- an age tag is provided to indicate, for instruction ordering purposes, how long an instruction has been in buffer 110 . While, these fields have been described to aid in the understanding of the present invention there are many other fields typically included in an instruction buffer entry.
- manufactured good bit “M” is provided in each buffer entry 113 , 112 .
- This bit is set in response to one of the manufacturing or self tests (POST, BIST) that are run subsequent to the fabrication of the integrated circuit. If the test results show that a particular entry 113 , 112 returns incorrect data, then that entry is considered “bad” and the M bit is set accordingly.
- POST manufacturing or self tests
- BIST manufacturing or self tests
- Allocation control logic 103 normally looks at the valid bit “V” for each buffer entry to determine when various entries are available to receive a new instruction for processing. Again, for the purpose of describing the present invention a valid bit set to logical “1” will indicate that the entry is available for an awaiting instruction and a logical “0” means the entry is being used, or otherwise unavailable. Additional logic is provided to associate the manufacture good bit and valid bit such that if an entry has been tested good and it is available to receive a new microprocessor instruction, then a control signal will be provided to allocation logic 103 such that the awaiting instruction is then provided to buffer 110 .
- this additional logic could be the use of AND gate 702 which determines when both the valid bit and the manufactured good bit indicate that the entry can receive an instruction, and the entry has tested good.
- each entry in the buffer will include an AND gate that uses the valid bit and manufactured good bit as inputs.
- the remaining entries 113 n and spare entries 112 will include an AND gate shown by reference numeral 704 .
- the output of the AND gates are then provided as inputs to an OR gate 706 which then provides the control signal back to allocation control logic 103 . In this case, when both the valid bit and manufactured good bits are set (logical 1), then a logical 1 is provided to OR gate 706 .
- an indication (logical 1 in this example) will be provided to allocation logic 103 from OR gate 706 that indicates at least one entry is available and the awaiting instruction is then broadcast to instruction buffer 110 .
- the broadcast instruction will then be received by the first individual entry that is ready.
- multiple redundant, or spare entries 112 can be provided in the instruction buffer 110 such that those entries 113 or 112 that test as having been manufactured bad will not indicate their availability and never receive an instruction. Conversely, those entries which test as having a functional status will allow allocation control logic to broadcast an awaiting instruction to buffer 110 wherein only the entries that test good will be used and the bad entries are entirely avoided.
- bit vector 111 could be generated by test/verification control logic to intentionally label various ones of the entries in buffer 110 as “bad”. Accordingly, the allocation logic will not use those entries and system operation/performance can be verified with only a predefined number of instruction buffer entries being operational.
- the bit vector can then be altered to test various buffer entry configurations where different ones of the entries in buffer 110 may be designated as functional or defective.
- Benchmark tests can then be run to determine system performance when different register configurations are set.
- the “manufactured good” bit (M) can be set to indicate that a particular buffer entry is defective. Tests can then be performed to verify system performance under various conditions where certain ones of the instruction buffer entries are designated as functional or defective.
Abstract
Description
Claims (39)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US09/594,632 US6625746B1 (en) | 2000-06-15 | 2000-06-15 | Microprocessor instruction buffer redundancy scheme |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US09/594,632 US6625746B1 (en) | 2000-06-15 | 2000-06-15 | Microprocessor instruction buffer redundancy scheme |
Publications (1)
Publication Number | Publication Date |
---|---|
US6625746B1 true US6625746B1 (en) | 2003-09-23 |
Family
ID=28042267
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US09/594,632 Expired - Lifetime US6625746B1 (en) | 2000-06-15 | 2000-06-15 | Microprocessor instruction buffer redundancy scheme |
Country Status (1)
Country | Link |
---|---|
US (1) | US6625746B1 (en) |
Cited By (9)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20010054138A1 (en) * | 2000-05-24 | 2001-12-20 | Mitsuharu Kawaguchi | Instruction buffer and buffer queue control method |
US20040015901A1 (en) * | 2001-05-29 | 2004-01-22 | Ibm | Compiling method and storage medium therefor |
US20080263331A1 (en) * | 2007-04-18 | 2008-10-23 | Le Hung Q | Universal Register Rename Mechanism for Instructions with Multiple Targets in a Microprocessor |
US20080263321A1 (en) * | 2007-04-18 | 2008-10-23 | Le Hung Q | Universal Register Rename Mechanism for Targets of Different Instruction Types in a Microprocessor |
US20090150649A1 (en) * | 2007-12-10 | 2009-06-11 | Jaume Abella | Capacity register file |
US20110307681A1 (en) * | 2010-06-15 | 2011-12-15 | Frederic Claude Marie Piry | Apparatus and method for mapping architectural registers to physical registers |
US20130283248A1 (en) * | 2012-04-18 | 2013-10-24 | International Business Machines Corporation | Method, apparatus and product for porting applications to embedded platforms |
US9436402B1 (en) * | 2011-04-18 | 2016-09-06 | Micron Technology, Inc. | Methods and apparatus for pattern matching |
US10007521B1 (en) * | 2012-12-20 | 2018-06-26 | Marvell International Ltd. | Banked physical register data flow architecture in out-of-order processors |
Citations (11)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4691279A (en) * | 1984-03-02 | 1987-09-01 | Unisys Corporation | Instruction buffer for a digital data processing system |
US4791560A (en) * | 1985-07-31 | 1988-12-13 | Unisys Corporation | Macro level control of an activity switch in a scientific vector processor which processor requires an external executive control program |
US4805093A (en) * | 1986-10-14 | 1989-02-14 | Ward Calvin B | Content addressable memory |
US5574875A (en) * | 1992-03-13 | 1996-11-12 | Inmos Limited | Cache memory system including a RAM for storing data and CAM cell arrays for storing virtual and physical addresses |
US5621739A (en) * | 1996-05-07 | 1997-04-15 | Intel Corporation | Method and apparatus for buffer self-test and characterization |
US5819308A (en) * | 1997-02-27 | 1998-10-06 | Industrial Technology Research Institute | Method for buffering and issuing instructions for use in high-performance superscalar microprocessors |
US5881265A (en) * | 1989-02-24 | 1999-03-09 | Advanced Micro Devices, Inc. | Computer processor with distributed pipeline control that allows functional units to complete operations out of order while maintaining precise interrupts |
US6122444A (en) * | 1996-11-27 | 2000-09-19 | Intel Corporation | Method and apparatus for manipulation of digital data in multiple parallel but incongruent buffers |
US6470443B1 (en) * | 1996-12-31 | 2002-10-22 | Compaq Computer Corporation | Pipelined multi-thread processor selecting thread instruction in inter-stage buffer based on count information |
US6539469B1 (en) * | 1999-10-12 | 2003-03-25 | Intel Corporation | Rotator circular buffer with entries to store divided bundles of instructions from each cache line for optimized instruction supply |
US6550034B1 (en) * | 2000-02-17 | 2003-04-15 | Hewlett Packard Development Company, L.P. | Built-in self test for content addressable memory |
-
2000
- 2000-06-15 US US09/594,632 patent/US6625746B1/en not_active Expired - Lifetime
Patent Citations (11)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4691279A (en) * | 1984-03-02 | 1987-09-01 | Unisys Corporation | Instruction buffer for a digital data processing system |
US4791560A (en) * | 1985-07-31 | 1988-12-13 | Unisys Corporation | Macro level control of an activity switch in a scientific vector processor which processor requires an external executive control program |
US4805093A (en) * | 1986-10-14 | 1989-02-14 | Ward Calvin B | Content addressable memory |
US5881265A (en) * | 1989-02-24 | 1999-03-09 | Advanced Micro Devices, Inc. | Computer processor with distributed pipeline control that allows functional units to complete operations out of order while maintaining precise interrupts |
US5574875A (en) * | 1992-03-13 | 1996-11-12 | Inmos Limited | Cache memory system including a RAM for storing data and CAM cell arrays for storing virtual and physical addresses |
US5621739A (en) * | 1996-05-07 | 1997-04-15 | Intel Corporation | Method and apparatus for buffer self-test and characterization |
US6122444A (en) * | 1996-11-27 | 2000-09-19 | Intel Corporation | Method and apparatus for manipulation of digital data in multiple parallel but incongruent buffers |
US6470443B1 (en) * | 1996-12-31 | 2002-10-22 | Compaq Computer Corporation | Pipelined multi-thread processor selecting thread instruction in inter-stage buffer based on count information |
US5819308A (en) * | 1997-02-27 | 1998-10-06 | Industrial Technology Research Institute | Method for buffering and issuing instructions for use in high-performance superscalar microprocessors |
US6539469B1 (en) * | 1999-10-12 | 2003-03-25 | Intel Corporation | Rotator circular buffer with entries to store divided bundles of instructions from each cache line for optimized instruction supply |
US6550034B1 (en) * | 2000-02-17 | 2003-04-15 | Hewlett Packard Development Company, L.P. | Built-in self test for content addressable memory |
Cited By (23)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US7257698B2 (en) * | 2000-05-24 | 2007-08-14 | Nec Corporation | Instruction buffer and method of controlling the instruction buffer where buffer entries are issued in a predetermined order |
US20010054138A1 (en) * | 2000-05-24 | 2001-12-20 | Mitsuharu Kawaguchi | Instruction buffer and buffer queue control method |
US8671399B2 (en) | 2001-05-29 | 2014-03-11 | International Business Machines Corporation | Systems and methods for efficiently using stack registers and storage medium therefor |
US8161467B2 (en) | 2001-05-29 | 2012-04-17 | International Business Machines Corporation | Compiling method and storage medium therefor |
US20080059955A1 (en) * | 2001-05-29 | 2008-03-06 | International Business Machines Corporation | Compiling method and storage medium therefor |
US20080141216A1 (en) * | 2001-05-29 | 2008-06-12 | International Business Machines Corporation | Compiling method and storage medium therefor |
US7331044B2 (en) * | 2001-05-29 | 2008-02-12 | International Business Machines Corporation | Compiling method and storage medium therefor |
US20040015901A1 (en) * | 2001-05-29 | 2004-01-22 | Ibm | Compiling method and storage medium therefor |
US20080263331A1 (en) * | 2007-04-18 | 2008-10-23 | Le Hung Q | Universal Register Rename Mechanism for Instructions with Multiple Targets in a Microprocessor |
US7765384B2 (en) * | 2007-04-18 | 2010-07-27 | International Business Machines Corporation | Universal register rename mechanism for targets of different instruction types in a microprocessor |
US7809929B2 (en) * | 2007-04-18 | 2010-10-05 | International Business Machines Corporation | Universal register rename mechanism for instructions with multiple targets in a microprocessor |
US20080263321A1 (en) * | 2007-04-18 | 2008-10-23 | Le Hung Q | Universal Register Rename Mechanism for Targets of Different Instruction Types in a Microprocessor |
US20090150649A1 (en) * | 2007-12-10 | 2009-06-11 | Jaume Abella | Capacity register file |
US10020037B2 (en) * | 2007-12-10 | 2018-07-10 | Intel Corporation | Capacity register file |
US20110307681A1 (en) * | 2010-06-15 | 2011-12-15 | Frederic Claude Marie Piry | Apparatus and method for mapping architectural registers to physical registers |
US8578136B2 (en) * | 2010-06-15 | 2013-11-05 | Arm Limited | Apparatus and method for mapping architectural registers to physical registers |
US9311088B2 (en) | 2010-06-15 | 2016-04-12 | Arm Limited | Apparatus and method for mapping architectural registers to physical registers |
US9436402B1 (en) * | 2011-04-18 | 2016-09-06 | Micron Technology, Inc. | Methods and apparatus for pattern matching |
US10089359B2 (en) * | 2011-04-18 | 2018-10-02 | Micron Technology, Inc. | Memory devices for pattern matching |
US10776362B2 (en) | 2011-04-18 | 2020-09-15 | Micron Technology, Inc. | Memory devices for pattern matching |
US9009684B2 (en) * | 2012-04-18 | 2015-04-14 | International Business Machines Corporation | Method, apparatus and product for porting applications to embedded platforms |
US20130283248A1 (en) * | 2012-04-18 | 2013-10-24 | International Business Machines Corporation | Method, apparatus and product for porting applications to embedded platforms |
US10007521B1 (en) * | 2012-12-20 | 2018-06-26 | Marvell International Ltd. | Banked physical register data flow architecture in out-of-order processors |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US6748519B1 (en) | Method and apparatus for utilizing renamed registers based upon a functional or defective operational status of the register | |
US6049672A (en) | Microprocessor with circuits, systems, and methods for operating with patch micro-operation codes and patch microinstruction codes stored in multi-purpose memory structure | |
US8117403B2 (en) | Transactional memory system which employs thread assists using address history tables | |
US20180011748A1 (en) | Post-retire scheme for tracking tentative accesses during transactional execution | |
US7725662B2 (en) | Hardware acceleration for a software transactional memory system | |
US5950012A (en) | Single chip microprocessor circuits, systems, and methods for self-loading patch micro-operation codes and patch microinstruction codes | |
US8321637B2 (en) | Computing system with optimized support for transactional memory | |
US9009452B2 (en) | Computing system with transactional memory using millicode assists | |
US5907860A (en) | System and method of retiring store data from a write buffer | |
US7024545B1 (en) | Hybrid branch prediction device with two levels of branch prediction cache | |
US6651163B1 (en) | Exception handling with reduced overhead in a multithreaded multiprocessing system | |
KR101025354B1 (en) | Global overflow method for virtualized transactional memory | |
US8095750B2 (en) | Transactional memory system with fast processing of common conflicts | |
KR100708010B1 (en) | Store buffer which forwards data based on index and optional way match | |
US5392410A (en) | History table for prediction of virtual address translation for cache access | |
US6963964B2 (en) | Method and apparatus for detecting pipeline address conflict using parallel compares of multiple real addresses | |
US6631460B1 (en) | Advanced load address table entry invalidation based on register address wraparound | |
EP0709770A2 (en) | Apparatus to control load/store instructions | |
KR20000076584A (en) | Methods and apparatus for reordering load operations in a computer processing system | |
US20080127197A1 (en) | Method and system for on-demand scratch register renaming | |
US20070033385A1 (en) | Call return stack way prediction repair | |
US7996833B2 (en) | Method and system for replacing instructions and instruction blocks in computer code | |
EP0651331B1 (en) | A write buffer for a superpipelined, superscalar microprocessor | |
US6516395B1 (en) | System and method for controlling access to a privilege-partitioned address space with a fixed set of attributes | |
US6625746B1 (en) | Microprocessor instruction buffer redundancy scheme |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: INTERNATIONAL BUSINESS MACHINES CORPORATION, NEW YFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:MOORE, CHARLES R.;REEL/FRAME:010934/0427Effective date: 20000612 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
FPAY | Fee payment |
Year of fee payment: 4 |
|
REMI | Maintenance fee reminder mailed | ||
FPAY | Fee payment |
Year of fee payment: 8 |
|
SULP | Surcharge for late payment |
Year of fee payment: 7 |
|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:INTERNATIONAL BUSINESS MACHINES CORPORATION;REEL/FRAME:026664/0866Effective date: 20110503 |
|
FPAY | Fee payment |
Year of fee payment: 12 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044127/0735Effective date: 20170929 |