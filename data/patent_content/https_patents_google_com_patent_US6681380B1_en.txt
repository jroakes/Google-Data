US6681380B1 - Aggregating constraints and/or preferences using an inference engine and enhanced scripting language - Google Patents
Aggregating constraints and/or preferences using an inference engine and enhanced scripting language Download PDFInfo
- Publication number
- US6681380B1 US6681380B1 US09/504,209 US50420900A US6681380B1 US 6681380 B1 US6681380 B1 US 6681380B1 US 50420900 A US50420900 A US 50420900A US 6681380 B1 US6681380 B1 US 6681380B1
- Authority
- US
- United States
- Prior art keywords
- value
- fact
- rules
- block
- rule
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Lifetime
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/30—Creation or generation of source code
- G06F8/31—Programming languages or programming paradigms
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/44—Arrangements for executing specific programs
- G06F9/445—Program loading or initiating
- G06F9/44505—Configuring for program initiating, e.g. using registry, configuration files
Definitions
- the present invention relates to a computer system, and deals more particularly with a method, system, and computer program product for using an inference engine, along with an enhanced scripting language, to aggregate constraints and/or preferences that are to be applied to affect program execution.
- Web content is created for a generic audience, without regard to the limitations that might be preferable for different target audiences.
- a Web document may contain relatively large embedded objects such as sound files, images, video, etc., or may contain links that will automatically retrieve objects of this type.
- the target device is a relatively powerful machine with a large storage capacity such as a desktop computer connected over a local area network (LAN), then downloading this type of document content is unlikely to create problems.
- LAN local area network
- Such devices referred to commonly as “constrained devices”, also typically have low power CPUs and are capable of supporting only low bandwidth connections, therefore resulting in high network latency.
- constrained device When a document requester is using this type of constrained device, then there may not be sufficient space for receiving and storing large Web documents on the device. In addition, the processing capabilities of a constrained device may be insufficient for a document created without regard to the limitations of these devices. Furthermore, users of constrained devices typically connect to a network using relatively expensive wireless connections, and/or connections with limited bandwidth. In such cases, the cost of receiving data content can be prohibitive, and it becomes imperative that only content which is important and necessary be sent to the end user, and that this content be sent in a format appropriate for the user's device.
- Constrained devices that are commonly used in Internet communication include cellular phones, screenphones, pagers, and laptop computers.
- An example of this type of device is the Nokia 7110, a cellular phone with a maximum display area of 6 lines of text.
- Another example device is the WorkPad available from the International Business Machines Corporation (“IBM”). This device is a handheld computer typically configured with several megabytes of storage, where that storage is provided as Random Access Memory (“RAM”) to avoid the system overhead associated with other types of storage such as disk drives. (“WorkPad” is a registered trademark of IBM.)
- conditional logic is used to tailor the execution of a software program based on factors that may vary in value (such as those which have been described above), where the conditional logic is coded as an integral part of the software and accounts for expected values of predetermined factors.
- this approach has a number of disadvantages.
- programming skill is required to include the conditional logic within the program.
- the programmer must write code to handle every expected factor, and every expected value of those factors.
- the values of the various factors may come from different sources.
- the user agent type for example, is typically found in the header of the document request message.
- the identification of the user, used to locate user preferences may come from this header or may be determined in another manner (such as by using information from the header to consult an index of users or employees).
- the program must contain code to locate the values of each factor for which conditional logic will be executed, and thus needs to be modified to account for any new sources that may become available.
- conditional logic approach which may have to account for many values of many factors as well as interrelationships between them, makes the resulting program much more complicated and thus harder to write, debug, and maintain. The program may also execute more slowly due to the complicated conditional logic.
- conditional logic within the code which uses the result of the logic is not an optimal design strategy.
- the core function of the code, which merely needs to use the result of the conditional logic, may be obscured due to the added complexity introduced by the code which determines the conditional result.
- time of day and day of the week may influence the cost of data transmission, or a user's network subscription service may have graduated pricing based upon usage.
- time of day and day of the week may influence the cost of data transmission, or a user's network subscription service may have graduated pricing based upon usage.
- the complexity of determining the result increases substantially.
- using conditional logic coded directly into an application program is an unsatisfactory technique for performing the aggregation.
- An object of the present invention is to provide an improved technique for tailoring the execution of a software program based upon an aggregation of information.
- Another object of the present invention is to provide this technique using an inference engine and an enhanced scripting language.
- Still another object of the present invention is to provide this technique where the inference engine uses backward chaining.
- Yet another object of the present invention is to provide an alternative where the inference engine uses forward chaining.
- the present invention provides a computer program product, a system, and a method for tailoring execution of a software program based on aggregated information.
- This technique comprises: transforming one or more rules expressed in an enhanced scripting language into rules expressed in an existing scripting language; executing an inference engine; and using the aggregated result in the software program.
- Executing the inference engine further comprises: processing the one or more rules expressed in the existing scripting language;
- each of the values may express a constraint value or a preference value; and determining an aggregated result using the processed rules and the evaluated values.
- the enhanced scripting language preferably comprises the existing scripting language with an additional notational element added, and the transformation further preferably comprises: locating each of the notational elements in each of the rules being transformed; replacing the located notational elements with a value-searching syntax when the located notation element was in a premise of the rule being transformed; and replacing the located notational elements with a value-setting syntax when the located notation element was in a conclusion of the rule being transformed.
- the notational element is preferably a character not normally used in the scripting language as an operator or to begin an identifier, such as the “@” character.
- the technique may further comprise compiling the transformed rules prior to execution of the inference engine.
- the existing scripting language may be NetRexx.
- the inference engine may be a backward chaining inference engine, or a forward chaining inference engine.
- FIG. 1 is a block diagram of a computer workstation environment in which the present invention may be practiced
- FIG. 2 is a diagram of a networked computing environment in which the present invention may be practiced
- FIG. 3 illustrates the components involved in operating a preferred embodiment of the present invention
- FIGS. 4 through 16 illustrate flow charts which set forth the logic which may be used to implement a preferred embodiment of the present invention.
- FIG. 17 illustrates an example of factors and values which is used in describing the preferred embodiment.
- FIG. 1 illustrates a representative workstation hardware environment in which the present invention may be practiced.
- the environment of FIG. 1 comprises a representative single user computer workstation 10 , such as a personal computer, including related peripheral devices.
- the workstation 10 includes a microprocessor 12 and a bus 14 employed to connect and enable communication between the microprocessor 12 and the components of the workstation 10 in accordance with known techniques.
- the workstation 10 typically includes a user interface adapter 16 , which connects the microprocessor 12 via the bus 14 to one or more interface devices, such as a keyboard 18 , mouse 20 , and/or other interface devices 22 , which can be any user interface device, such as a touch sensitive screen, digitized entry pad, etc.
- the bus 14 also connects a display device 24 , such as an LCD screen or monitor, to the microprocessor 12 via a display adapter 26 .
- the bus 14 also connects the microprocessor 12 to memory 28 and long-term storage 30 which can include a hard drive, diskette drive, tape drive, etc.
- the workstation 10 may communicate with other computers or networks of computers, for example via a communications channel or modem 32 .
- the workstation 10 may communicate using a wireless interface at 32 , such as a CDPD (cellular digital packet data) card.
- CDPD cellular digital packet data
- the workstation 10 may be associated with such other computers in a LAN or a wide area network (WAN), or the workstation 10 can be a client in a client/server arrangement with another computer, etc. All of these configurations, as well as the appropriate communications hardware and software, are known in the art.
- FIG. 2 illustrates a data processing network 40 in which the present invention may be practiced.
- the data processing network 40 may include a plurality of individual networks, such as wireless network 42 and network 44 , each of which may include a plurality of individual workstations 10 .
- one or more LANs may be included (not shown), where a LAN may comprise a plurality of intelligent workstations coupled to a host processor.
- the networks 42 and 44 may also include mainframe computers or servers, such as a gateway computer 46 or application server 47 (which may access a data repository 48 ).
- a gateway computer 46 serves as a point of entry into each network 44 .
- the gateway 46 may be preferably coupled to another network 42 by means of a communications link 50 a .
- the gateway 46 may also be directly coupled to one or more workstations 10 using a communications link 50 b , 50 c .
- the gateway computer 46 may be implemented utilizing an Enterprise Systems Architecture/370 available from IBM, an Enterprise Systems Architecture/390 computer, etc.
- a midrange computer such as an Application System/400 (also known as an AS/400) may be employed.
- Application System/400 also known as an AS/400
- the gateway computer 46 may also be coupled 49 to a storage device (such as data repository 48 ). Further, the gateway 46 may be directly or indirectly coupled to one or more workstations 10 .
- the gateway computer 46 may be located a great geographic distance from the network 42 , and similarly, the workstations 10 may be located a substantial distance from the networks 42 and 44 .
- the network 42 may be located in California, while the gateway 46 may be located in Texas, and one or more of the workstations 10 may be located in New York.
- the workstations 10 may connect to the wireless network 42 using a networking protocol such as the Transmission Control Protocol/Internet Protocol (“TCP/IP”) over a number of alternative connection media, such as cellular phone, radio frequency networks, satellite networks, etc.
- TCP/IP Transmission Control Protocol/Internet Protocol
- the wireless network 42 preferably connects to the gateway 46 using a network connection 50 a such as TCP or UDP (User Datagram Protocol) over IP, X.25, Frame Relay, ISDN (Integrated Services Digital Network), PSTN (Public Switched Telephone Network), etc.
- the workstations 10 may alternatively connect directly to the gateway 46 using dial connections 50 b or 50 c .
- the wireless network 42 and network 44 may connect to one or more other networks (not shown), in an analogous manner to that depicted in FIG. 2 .
- Software programming code which embodies the present invention is typically accessed by the microprocessor 12 of the server 47 or gateway 46 (or of the workstation 10 , when the workstation is capable of executing the present invention) from long-term storage media 30 of some type, such as a CD-ROM drive or hard drive.
- the software programming code may be embodied on any of a variety of known media for use with a data processing system, such as a diskette, hard drive, or CD-ROM.
- the code may be distributed on such media, or may be distributed to users from the memory or storage of one computer system over a network of some type to other computer systems for use by users of such other systems.
- the programming code may be embodied in the memory 28 , and accessed by the microprocessor 12 using the bus 14 .
- the techniques and methods for embodying software programming code in memory, on physical media, and/or distributing software code via networks are well known and will not be further discussed herein.
- a user of the present invention may connect his computer to a server using a wireline connection, or a wireless connection.
- the present invention may be used in a stand-alone mode without having a network connection, whereby operation in this stand-alone mode prepares one or more documents for subsequent transmission.
- Wireline connections are those that use physical media such as cables and telephone lines, whereas wireless connections use media such as satellite links, radio frequency waves, and infrared waves.
- Many connection techniques can be used with these various media, such as: using the computer's modem to establish a connection over a telephone line; using a LAN card such as Token Ring or Ethernet; using a cellular modem to establish a wireless connection; etc.
- the user's computer may be any type of computer processor, including laptop, handheld or mobile computers; vehicle-mounted devices; desktop computers; mainframe computers; etc., having processing and communication capabilities.
- the remote server similarly, can be one of any number of different types of computer which have processing and communication capabilities. These techniques are well known in the art, and the hardware devices and software which enable their use are readily available.
- the user's computer will be referred to equivalently as a “workstation”, “device”, or “computer”, and use of any of these terms or the term “server” refers to any of the types of computing devices described above.
- the present invention provides an advantageous technique for aggregating information (such as constraints and/or preferences) to dynamically affect program execution, while avoiding the previously discussed problems that may be encountered when attempting to use traditional statically coded conditional logic for this purpose.
- the present invention is implemented as one or more computer software programs.
- the implementation of the software of the present invention may operate on a server or intermediary device in a network, as one or more modules (also referred to as code subroutines, or “objects” in object-oriented programming).
- the software may operate on a user's workstation.
- the software may execute on multiple devices in a distributed manner, without deviating from the inventive concepts disclosed herein.
- An implementation of the present invention may be executing in a Web environment, for example for dynamically aggregating information to transform Web pages for delivery through the Internet.
- an implementation of the present invention may be executing in a corporate intranet or extranet, or in any other network environment.
- the present invention may be used in a disconnected (stand-alone) mode. Configurations for the environment include a client/server network, as well as a multi-tier environment. These environments and configurations are well known in the art.
- the present invention uses a rule-based system for aggregating information, and uses that aggregated information to tailor program execution.
- Rule-based systems are well suited to the type of complex problem solving which has been discussed, wherein factors having a number of potential values must be aggregated, and where the factors and values thereof are subject to ongoing revision and expansion.
- Rule-based systems employ an inference engine that operates upon a set of facts and a set of rules. The sets of facts and rules may vary from having a few entries to having hundreds or thousands of entries. Such systems are able to perform efficiently because they are designed specifically for applying rules to facts and are therefore optimized for this task.
- an enhanced scripting language is used, according to the present invention, for specifying the rules to be used in the aggregation process.
- This combination of a rule-based system and an enhanced scripting language offers a number of advantages over a traditional statically coded logic approach to aggregation.
- the logic is easy to modify and to extend by system users in the approach adopted by the present invention.
- the decisions embodied in the rules may be altered simply by changing the affected rules or by adding new rules, without changing the program that will use the result of the decision. For example, if a new device type becomes available, device-specific rules can be added to the rules base using simply a text editor (or perhaps a tool adapted to rule-creation).
- Scripting languages are typically less complex and therefore simpler to understand than programming languages, yet they typically provide very powerful constructs.
- the preferred embodiment enables system users to construct their own rules to embody complicated decision-making without requiring those users to have sophisticated programming skills.
- Many system users will already be familiar with one or more scripting languages, and thus will only be required to learn the simple syntax extension (described in detail below) which is defined for the preferred embodiment.
- Another advantage of the present invention is that, because of the manner in which a rule-based system (including the system defined herein) automatically accounts for interrelationships among the conditions and values that go into the aggregation process, the complex conditional logic that arises when using conventional programming languages for this purpose is avoided.
- Yet another advantage of the present invention is that additional sources for the values to be aggregated may be easily accommodated in the rule-based system.
- an existing rule aggregates values using input from two sources to determine a transcoding process to apply to images to be transmitted over a network, where the two sources may be the type of network connection to the requester and the type of device which will receive the transmission.
- An additional factor such as the image-receiving preferences of a particular user can easily be factored into the aggregation process using the present invention.
- the present invention enables accounting for the additional information in the aggregation result by modifying one or more existing rules (or perhaps by adding new rules).
- Style sheets are one such technique.
- this approach requires a user to understand the complex style sheet notation in order to extend the aggregation process to account for new information sources and values.
- style sheets suffer from the same disadvantage as conventional programming languages when complex interrelationships among information sources and values must be represented: that is, the expression of the interrelationships becomes very complicated and is therefore more error-prone and more difficult to create, debug, and maintain.
- FIG. 3 illustrates, at a high level, the components involved in operating a preferred embodiment of the present invention.
- Rules 305 expressed in an enhanced scripting language are processed by a translation or parsing process 310 , creating script statements 315 which express rules using an existing scripting language syntax. A preferred embodiment of this translation is described in detail below, with reference to FIGS. 4-7.
- the script statements 315 are then compiled as shown at 320 , creating executable rules 325 .
- An interpreted scripting language may be used alternatively, in which case script statements 315 are the executable rules 325 without requiring a compilation step.
- Preferences or profiles for one or more different source types 330 , 331 are used as input to an inference engine 335 , along with the executable rules 325 and facts 341 from a fact database 340 .
- the inference engine 335 of the present invention enables making queries which causes the rules 325 to be evaluated against the facts 341 in the fact database 340 to attempt to provide answers to the queries.
- the inference engine 335 contains logic to continually evaluate the rules (because evaluation of rules may generate more facts) until the query is solved, or until it can be determined that the query cannot be solved with the given set of rules and facts.
- a simple rule-based language syntax consists of statements of the form:
- This type of predicate-conclusion syntax may be used for setting variables or properties to particular values.
- Combining rules with a scripting language for aggregation enables creating a powerful and expressive rules language which takes advantage of the power and complexity of the underlying scripting language.
- a scripting language such as NetRexx, which is used as the scripting language of the preferred embodiment, is that it allows use of typeless variables to form expressions. That is, values are normally treated as strings, but if a variable is used in an arithmetic expression then it is automatically converted from string form to numeric form. For example, if the variable A has the value 2 , then the expression “A+1” is evaluated by converting the string “1” to the number 1 , adding this to the number 2 , and then converting the resulting value “3” back to a string.
- scripting languages such as NetRexx have many useful built-in functions.
- the “POS” which is an abbreviation for “position”
- the function returns either (1) a the position within the source string where the target string was located, or (2) a zero otherwise.
- POS which is an abbreviation for “position”
- the present invention defines a notational key to denote reference to a fact within a script language statement.
- the character “@” is used as the notational key, and is prepended to the name of facts within rules.
- This “@” character is a scripting language enhancement defined by the present invention, and thus it can be seen that a user who is already familiar with the syntax of the scripting language can easily learn to create rules using this syntax enhancement. Using this syntax extension to express rules to be processed by the present invention yields rules 305 , 306 of the form:
- each premise may specify a Boolean expression using a variable name and each conclusion may assign a value to a variable name.
- each premise and conclusion may also specify one or more built-in functions of the underlying scripting language, as discussed above.
- Each variable name which is to use a matching fact in the facts database as the input value for the variable (in the case of premises) or which is to set a value of a fact in the facts database (in the case of conclusions) is of the form “@factName”, as illustrated at element 306 of FIG. 3 .
- an input rule may be written as:
- Clues may be used in making this determination, such as whether the user agent is a Mozilla agent.
- a rule to express this may be represented as:
- variable browserType is to be set to the string “powerful”.
- the application using this decision then presumably operates, differently based upon whether the browserType is set to “powerful” or to some other value.
- the input rules 305 are first parsed 310 into script statements 315 , 316 in a syntax which is supported directly by the scripting language.
- functions having names such as “getFact” and “setFact” are defined, where the getFact function has the signature “getFact (ExpressionContext context, String name)” and the setFact function has the signature “setFact (ExpressionContext context, String name, Object value)”. Accordingly, the rules described above are then translated to the syntax:
- the getFact and setFact functions are implemented as preference value lookup code and preference value setting code, respectively.
- the getFact function uses the input parameters to determine which preference value to retrieve from the fact database, and the setFact function uses its additional third parameter to set the specified preference value in the fact database.
- the enhancements defined herein for a scripting language may be used as enhancements to either an interpreted script language or a compiled script language.
- the NetRexx language is used, which compiles a form of the REXX scripting language directly into JavaTM bytecodes. Rules languages are known which are built upon interpreted languages such as Prolog, LISP, or Scheme. However, these interpreted languages are not available on all platforms, or when available, may have performance issues.
- the NetRexx language avoids these problems and also provides the advantageous type-independent features described above. (“Java” is a trademark of Sun Microsystems, Inc.)
- Values of many factors may be used in the aggregation process described herein. When used for tailoring document delivery in a network environment, these factors include, but are not limited to, one or more of: the capabilities of the client device; the connection type over which the content will be delivered; the network bandwidth of the connection; the type of user agent operating on the client device; preferences of a particular user; preferences set by a systems administrator or other such person (or preferences generated in an automated manner); preferences for a particular application executing in a particular domain; etc.
- these values are represented as name/value pairs which are stored as preference sets or profiles (such as elements 330 , 331 of FIG. 3 and the examples depicted in FIG. 17 ).
- profiles may be stored in many different forms without deviating from the scope of the present invention, such as: properties of an object; attributes in a database; attributes of a structured document such as an Extensible Markup Language (XML) document; etc.
- XML Extensible Markup Language
- Profile 1700 contains fifteen different key/value pairs
- profile 1760 contains eight key/value pairs
- profiles 1720 and 1740 each contain three key/value pairs.
- Profile 1700 represents typical preferences and values that may be applicable for transforming Web document content for delivery to a device using a Netscape browser.
- Profiles 1720 and 1740 represent preference information that may be applicable for transforming content to be transmitted across a wireless link or a LAN connection, respectively. (Note that the three preference names in these profiles 1720 , 1740 are identical, yet are not required to appear in the same order in each profile.
- profile 1760 represents preference information that may be applicable for transforming content destined for a constrained device such as a WAP (Wireless Application Protocol) client which uses the Wireless Markup Language (“WML”).
- WAP Wireless Application Protocol
- WML Wireless Markup Language
- Profiles for use with the present invention may be created using, for example, a simple text editor. (“Netscape” is a registered trademark of Netscape Communications Corporation.)
- Another obvious way to access the values in the source files is an optimization of the first. That is, assuming the source files are somewhat static (i.e. are not continuously changing), the source files can be read at initialization time of the rules system (and when notified of updates), and rules can then be generated based on the values read. (It will be obvious to one of ordinary skill in the art how this generation process may be implemented.) That is, given that the Netscape.profile has been read and the value of criticalInformation is found to be 1 (for example), it is known that this source file contains a value for criticalInformation and the value is also known. Thus, the aforementioned rule can be optimized to the following:
- an inference engine such as engine 335 operates on facts 340 and rules 325 , and attempts to solve rules by issuing queries against the set of available facts. Rules have conclusions which may set more facts. These new facts can then be used to solve more rules, in an iterative manner.
- the facts 341 in the fact database 340 are simply preference names and their associated values.
- the particular facts 341 included in the fact database 340 during an invocation of the present invention are created by selecting particular preferences and values from the preference profiles 330 , 331 according to execution of the rules 325 .
- the facts may be represented as name/value pairs which delimit the name from the value using an alternative syntax such as a comma.
- the facts may be stored using other equivalent representations such as tables, tuples in a database, etc.
- inference engine 335 is defined herein for use with the preferred embodiment; however, an appropriate commercially available inference engine may be substituted without deviating from the scope of the present invention.
- FIGS. 4 through 16 illustrate logic that may be used to implement a preferred embodiment of the present invention.
- FIGS. 4 through 7 represent the processing of component 310 of FIG. 3, and
- FIG. 8 represents an optional additional process that may be used at this point (as will be described below).
- FIGS. 9 through 16 illustrate the processing used by the inference engine 335 .
- FIG. 4 illustrates the top-level processing logic with which the preferred embodiment of the present invention may be implemented, and begins the parsing or translation process whereby the rules written by a system user are transformed into rules in a conventional scripting language. Depending on how often new rules are created, this parsing process may be invoked each time the present invention operates to perform an aggregation of information, or it may be invoked less often (for example, only when new rules have been created, or at predetermined periodic intervals, etc.).
- the rules available to the system are initialized to an empty list of rules.
- the list of rules is represented as rule objects, where each rule object comprises a premise list and a conclusions list.
- Block 405 reads the next input rule from a storage repository such as file 305 into which rules have been entered.
- the input rules are of the form “IF (premise_ 1 ) . . . THEN (conclusion_ 1 ) . . . ”, where the fact names within the premises and conclusions have a prepended “@” character.)
- Block 410 checks to see if this rule is null. If so, this indicates that all the rules in the input have been processed, and control transfers to Block 425 . If Block 410 has a negative result, however, there are still more input rules, and processing continues at Block 415 .
- Block 415 passes the input rule as a parameter to the ParseRule function depicted in FIG. 5, which parses the rule and returns it as a rule comprised of a premise list and a conclusion list. This returned rule is added to the list of available rules by Block 420 , after which control returns to Block 405 to process the next input rule.
- Block 425 asks whether a backward chaining approach is being used. If so, then the AddRule function depicted in FIG. 8 is invoked at Block 430 to further process each rule which has been added to the rule base by the processing of FIG. 4 .
- Rule based systems are categorized as either forward chaining or backward chaining. Either type may, be used with the present invention, although backward chaining is preferred in environments where many rules are needed. Both solutions are described herein, as each may be used advantageously in appropriate environments. (As will be obvious to one of skill in the art, an implementation of the present invention will typically support only one approach, and the test in Block 425 has been shown in FIG. 4 to emphasize the choices available.
- this test is preferably omitted. If the implementation uses forward chaining, then the logic of FIGS. 8 and 11 - 16 is preferably omitted as well. If the implementation uses backward chaining, then the logic of FIG. 8 may be invoked immediately following the positive result at Block 410 , and the logic of FIGS. 9 and 10 is preferably omitted.)
- Backward chaining begins with a hypothesis for reaching a conclusion, and works backward to attempt to find rules to support that conclusion.
- the conclusion to be reached is a value for y.
- the other rule can be evaluated, and will set a value for y.
- a backward chaining system applies only those rules that may possibly lead to the desired conclusion, whereas a forward chaining system may apply every rule in the rule base.
- a backward chaining implementation offers a distinct performance advantage in attempting only those rules which may lead to the desired conclusion.
- FIG. 5 illustrates a preferred embodiment of the ParseRule function which was invoked from Block 415 of FIG. 4 .
- Block 500 begins by initializing a premise list and a conclusion list to empty lists.
- Block 505 locates the next premise in the IF part of the rule which was passed as the input parameter.
- Each rule contains at least one premise. According to the preferred it embodiment, when more than one premise appears, each is preferably evaluated as having an implied AND relationship to the others. (Alternatively, a notation may be used which supports explicit Boolean operators, provided that appropriate modifications are made to the logic depicted for the preferred embodiment. However, because a rule based system provides support for OR conditions in premises by simply writing additional rules for each such premise, where each additional rule has a duplicate conclusion, it is not anticipated that such alternative notations are necessary.)
- Block 510 checks to see if the premise is null, indicating that the last premise for this rule has already been processed. If so, control transfers to Block 525 ; otherwise, Blocks 515 and 520 are invoked to process the premise and add it to the premise list for this rule, respectively.
- the premise is processed (Block 515 ) by invoking the ParsePremise function depicted in FIG. 6 . After adding this parsed premise to the premise list (Block 520 ), control returns to Block 505 to begin processing the next (if any) premise for this rule.
- Block 525 Upon reaching Block 525 , all the premises for this rule have been processed. Block 525 then finds the next conclusion in the THEN part of the input rule. Multiple conclusions may be present in each rule. In this situation, when the premise of the rule is satisfied during execution, each conclusion in the rule will be executed (fired) in turn. Block 530 tests to see if the conclusion is null, indicating that the end of the conclusion list for this input rule has been reached. If Block 530 has a positive result, Block 535 returns the rule object which has been created to the invoking logic. Otherwise, Block 540 invokes the ParseConcl function depicted in FIG. 7 . Block 545 then adds this conclusion to the conclusion list for this rule, and returns control to Block 525 to begin processing the next (if any) conclusion.
- FIG. 6 illustrates a preferred embodiment of the logic which may be used to implement the ParsePremise function which is invoked from Block 515 of FIG. 5 .
- the string i.e. the input premise
- Block 605 locates the next token from this list.
- Block 610 checks to see if the token list is at the end (i.e. the token retrieved by Block 605 is null). If so, Block 615 concatenates the tokens which are in the token list into an expression, and Block 620 returns this expression to the invoking logic.
- Block 610 If Block 610 has a negative result, then there is another token to process in the input premise.
- Block 625 checks to see if this token begins with the special character “@” defined by the preferred embodiment as indicating the start of a preference or fact name. (If an alternative character or character sequence is used as an alternative, then Block 625 is modified accordingly.) If the special character is detected, Block 630 modifies the token by removing this character and replacing it with the invocation syntax of the function or method which will retrieve a fact from the fact database at execution time.
- this syntax is “getFact (context, “token”)” where “context” is the name of a context object containing the fact database to be searched, and where “token” is the name of the fact (expressed in quotations within the getFact invocation syntax, to prevent its being interpreted as a variable name) to be used in the search.
- This context object includes all the facts which the expression being evaluated needs to reference. Each expression thus has its own context object, which is built as the expression is being evaluated according to the logic described herein.)
- an implementation of the present invention may enable users to write input rules where Boolean equality is represented in expressions using the syntax TRUE or FALSE.
- tokens having these values will preferably be changed to 1 and 0, respectively, for later use during expression evaluation.
- an implementation may require that the user specify the values 1 and 0 in the input rules, in which case it is not necessary to search for or change them.
- Block 630 After operation of Block 630 , or when Block 625 has a negative result, control returns to Block 605 to process the next token from the input premise.
- Block 600 creates a list of five tokens (, @networkSpeed, ,>, 14400, ) from this premise. After operation of Block 630 , this list is:
- Block 615 concatenates these elements into the expression “(getFact (context, “networkSpeed”) ⁇ 14400)” and returns this expression (Block 620 ) to the invoker.
- FIG. 7 illustrates a preferred embodiment of the logic which may be used to implement the ParseConcl (i.e. parse conclusion) function which is invoked from Block 540 of FIG. 5 .
- the string i.e. the input conclusion
- the string passed as the input parameter is tokenized, creating a list of tokens.
- a closeParen flag is initialized to False.
- Block 705 locates the next token from this list.
- Block 710 checks to see if the token list is at the end (i.e. the token retrieved by Block 705 is null).
- Block 710 When Block 710 has a negative result, then there is another token to process in the input conclusion.
- Block 735 checks to see if this token begins with the special character “@” defined by the preferred embodiment as indicating the start of a preference or fact name. (As stated previously, if an alternative character or character sequence is used, then Block 735 is modified accordingly.) If the special character is detected, then it must be modified.
- this syntax is “setFact (context, “token”,” where “context” is the name of a context object containing the fact database to be used, and where “token” is the name of the fact (in quotations, to prevent its being interpreted as a variable name) which is to be set.
- the values 1 and 0 are substituted, respectively.
- Block 745 sets the closeParen flag to True, indicating that a closing parenthesis is needed after the token specifying the value ha been processed.
- Block 750 modifies the token in the same manner which has been described for Block 630 of FIG. 6 .
- Block 710 When Block 710 has a positive result, indicating that all the tokens in the input conclusion have been processed, Block 715 checks to see if the closeParen flag has been set to True. If so, Block 720 adds a closing parenthesis token to the token list. Following Block 720 , or when Block 715 has a negative result, Block 725 concatenates the tokens which are in the token list into an expression, and Block 730 returns this expression to the invoking logic.
- Block 720 adds a closing parenthesis to this list, after which Block 725 concatenates these elements into the expression “(setFact (context, “criticalInformationOnly”, 1))” and returns this expression (Block 730 ) to the invoker.
- FIG. 8 illustrates the logic used by the preferred embodiment to further process the rules to be used in a backward chaining approach to inferencing.
- the logic of FIGS. 11-16 then uses these processed rules, as will be described below.
- the logic of this process enables quickly finding, at execution time, those rules which set a value for a particular variable (i.e. a particular fact name).
- a backward chaining approach searches for rules which set the value of x and attempts to fire those rules.
- the output of the processing of FIG. 8 is a list of the rules that set each variable. These lists can then be consulted at run-time, in effect functioning as an index into the total set of rules, to more efficiently resolve conclusions by quickly locating those rules that may lead to a particular desired result.
- Block 800 The processing of FIG. 8 begins at Block 800 , where a list is created from the conclusions in the rule passed as the input parameter (in Block 430 of FIG. 4, according to the preferred embodiment).
- Block 805 retrieves the next element from this list, and Block 810 checks to see if the list has been completely processed (i.e. if the retrieved element is null). If so, control returns (Block 815 ) to the invoking logic; otherwise processing continues at Block 820 .
- Block 820 retrieves the variable name which is set by the conclusion being processed. Block 825 then searches for the list of rules pertaining to this variable name. If such a rule list is not located (i.e. a negative result at Block 830 ), then Block 835 creates a new rule list for the variable. Block 840 adds this rule to the rule list for the variable, after which control returns to Block 805 to begin processing the next conclusion.
- FIGS. 9 through 16 depict the logic which may be used by the inference engine 335 of FIG. 3 at run-time to aggregate values.
- FIGS. 9 and 10 are used in a forward chaining solution
- FIGS. 11-16 are used in a backward chaining solution.
- the preferred embodiment On receiving a request for processing, such as a request for downloading a document in a Web environment, the preferred embodiment preferably determines which preference sources are to be used in the aggregation decision (for example, which of profiles such as 1700 , 1720 , 1740 , 1760 are pertinent) and then sets initial facts using that information.
- the UserAgent field of a HypertextTransfer Protocol (HTTP) request for a document can be consulted, for example, to determine what type of user agent or browser was used to create the request. Then, the appropriate profile can be located.
- HTTP HypertextTransfer Protocol
- the preference sources to be considered in this process are application-dependent, and may include the user's identification or name; device type; connection type; etc. Code to locate the desired information is therefore also application-dependent, and it will be obvious to one of ordinary skill in the art how to construct this logic.
- the facts database is initialized to empty following each such determination of applicable sources (for example, each time a new session is begun with a particular Web document requester), such that the facts set from the source information (i.e.
- FIG. 9 illustrates a preferred embodiment of the logic which may be used to solve for a variable “v” (where the variable is passed as an input parameter) in a forward chaining inference approach when a preference value is needed (and the input parameter uses the name of the preference). Invocation of this function is preferably preceded by first checking to see whether the desired fact already exists in the database, and invoking this function when the fact is not found.
- a changes flag is initialized to false. This flag is used to control the iterations through the rules database, and provides for repeating the iteration only if new facts have been added during a prior iteration.
- An UnsolvedRules list is then created, initially representing the entire set of rules in the rule base.
- Block 905 then retrieves the next rule from the UnsolvedRules list, and Block 910 checks to see if this rule is null (indicating the end of the rules list). If so, Block 915 checks to see if this iteration set the changes flag. If so, control returns to Block 900 to retry the rules which remain using the now-extended facts database; otherwise, no further information can be gained by performing another iteration, and thus Block 930 returns the current value of variable “v” to the invoking logic.
- the ProcessRule function depicted in FIG. 10 is invoked, passing this rule as the input parameter.
- FIG. 10 returns a Boolean value which is used to set the flag “factWasSet”.
- Block 925 then checks to see if the variable “v” now has a value in the fact database. When this test has a positive result, the value is returned to the invoking logic (Block 930 ). (Note that the variable “v” may have had a value before invoking the ProcessRule function, and/or the ProcessRule function may have set a value for “v”.) The processing of FIG. 9 for this invocation then ends.
- Block 935 tests to see if the factWasSet flag is True. If so, Block 940 sets the changes flag to true and marks the current rule as having been solved. Following operation of Block 940 , and when Block 935 has a negative result, control returns to Block 905 to attempt to solve the next rule from the unsolved rules list.
- Processing of the logic in FIG. 9 repeats until either a result is found for the input variable, or until no more facts are set during an iteration through the rules (indicating that no result will be found).
- FIG. 10 depicts a preferred embodiment of the logic which may be used to implement the ProcessRule function invoked from Block 920 of FIG. 9 .
- Block 1000 initializes a facts list “fList” to a new list, and initializes a result variable to null.
- Block 1005 locates all the fact names in the premise of the rule passed as input, and adds these fact names to the facts list in fList. (Note that a set is preferably used for fList, to avoid duplicate entries.)
- Block 1010 then locates all the fact names in the conclusion of the input rule, and adds these names to the fList as well.
- GetPremiseNames comprises simply a tokenizing process which then eliminates constants and special characters to yield a list of tokens which are variable names.
- GetConclNames creates a list of tokens and then finds those tokens which are variable names appearing on the right-hand side of an assignment expression. (Thus, it will be obvious to one of ordinary skill in the art how this logic may be implemented.)
- Block 1015 retrieves the next fact name from the list created by Blocks 1005 and 1010 , and Block 1020 checks to see if this fact name is null. If so, then all the fact names for the input rule have been processed, and control transfers to Block 1025 . Otherwise, Block 1050 tests to see if this fact name is present in a key/value pair in the fact database. If it is not, then it is not possible to solve this rule, and therefore the Boolean value FALSE (indicating that no new facts were set) is returned to the invoking logic by Block 1055 . When the fact name is present in the fact database, then it is still possible that this rule may be solvable, so control returns to Block 1015 where the next fact name is retrieved from fList.
- FALSE indicating that no new facts were set
- Block 1025 When all the fact names in the premise and in the conclusion have been determined to he present in at least one fact in the fact database, indicating that the input rule can be evaluated.
- Block 1025 evaluates the premise or premises of the rule, treating multiple premises as being ANDed together as previously discussed.
- Block 1030 checks whether this yields the Boolean value TRUE (i.e. whether the condition part of the rule has been satisfied). If not, then the Boolean FALSE is returned to the invoking logic at Block 1035 . Otherwise, Block 1040 executes the conclusion or conclusions of the input rule, which results in setting new facts.
- Block 1045 returns the Boolean TRUE to the invoking logic, indicating that new facts have been set.
- FIG. 11 illustrates a preferred embodiment of the top-level processing logic which may be used to resolve the value of a variable “v” (where the variable is passed as an input parameter) in this backward chaining inference approach when a preference value is needed (and the input parameter uses the name of the preference).
- v the variable
- the invoking code needs to know whether to suppress images in a WML document that is being processed for transmission through a network.
- the rules and facts used by the aggregation process of the present invention may account for many different conditions in resolving this decision, where the result may be a Boolean value.
- Block 1100 initializes a “factsChain” variable to an empty FactsChain.
- a FactsChain is preferably structured as a list of temporary fact databases, and may also include (1) one or more fact names and values and/or (2) one or more rules.
- Temporary fact databases are used in the backward chaining solution because a set of rules that are fired when attempting to resolve a variable may set one or more facts; however, if this set of rules eventually fails to yield the desired result, the facts which have been set must be backed out before a new set of rules for resolving the variable can be attempted.
- Block 1105 sets a variable “result” by invoking the Unify function depicted in FIG. 12 .
- the parameters passed on this invocation are the variable “v”, for which a solution is being attempted, and the factsChain structure. (This factsChain will be passed among the various functions as an input/output parameter to enable adding new temporary facts as rules are fired.)
- Block 1110 Upon returning from the Unify function, Block 1110 checks to see whether the result variable has a null value. If so, then it was not possible to resolve the value of variable v, and Block 1115 therefore returns the null result to the invoking code. Otherwise, processing continues at Block 1120 .
- Block 1120 begins an iterative process of copying any facts which have been created in the temporary facts database(s) on the facts chain into the main facts database.
- the main fact, database will be referred to hereinafter as “FDB”, and is preferably available to the logic of FIGS. 11-16 as a global variable. (Alternatively, the FDB may be passed as an additional input parameter to the functions of these figures.)
- the next temporary facts database (“tfDB”) on the facts chain is located at Block 1120 , and Block 1125 then checks to see if this tfDB is null.
- Block 1130 the result variable set by the Unify invocation in Block 1105 is returned to the invoking code. Otherwise, there are more tfDBs to process, and processing continues to Block 1135 .
- Block 1135 retrieves the next fact “f” from the current tfDB.
- Block 1140 checks to see if this retrieved fact is null. If so, then the current tfDB has been completely processed, and control returns to Block 1120 to get the next tfDB from the facts chain. When Block 1140 has a negative result, indicating that the retrieved fact was not null, Block 1145 concatenates (or otherwise adds) this fact to the main facts database. Control then returns to Block 1135 to retrieve the next fact.
- the processing of Blocks 1120 , 1125 , 1135 , 1140 , and 1145 continues until Block 1125 has a positive result, after which control returns (Block 1130 ) to the invoking logic.
- the Unify function depicted in FIG. 12 is invoked from Block 1105 of FIG. 11, and represents the preferred embodiment of the logic which begins a unification process (i.e. attempting to bind a value to a variable by pattern matching).
- the Unify function takes as input parameters the variable to be resolved and a facts chain (which is used to build the temporary fact databases that are created during the current invocation of the Resolve function).
- Block 1210 sets a result variable to this value of variable v, if any, in the main facts database.
- Block 1215 then checks to see if this yields a null result. If not, then the variable being resolved already appears in a fact within the FDB, and it is not necessary to attempt firing any rules. The value is simply returned to the invoking code at Block 1220 , and the processing of FIG. 12 then ends.
- Block 1225 when the value of the variable to be resolved did not already exist in a fact.
- Block 1225 sets the variable “relevantRules” to those rules which set values for v. (These are the rules which have the variable v in a conclusion, and which were preferably identified by the processing of FIG. 8.)
- Block 1230 reads the next rule from this list and assigns it to the variable “R”.
- Block 1235 checks to see if (1) a rule was retrieved and (2) there is not yet a result for resolving the value of v. When both of these conditions are true, Block 1240 invokes the function UnifyRule which is depicted in detail in FIG. 13 .
- the input parameters on the invocation are the variable v to be resolved, the current rule R, and the current factsChain.
- control Upon returning from this invocation, control returns to Block 1230 to retrieve the next rule from the relevantRules list.
- Block 1235 When there are no more rules that can set variable v, or when a result for the value of v has been resolved, Block 1235 has a negative result. Block 1245 then returns a null value (in the former case) or the resolved value (in the latter case) to the invoking logic.
- FIG. 13 illustrates a preferred embodiment of the logic used to implement the UnifyRule function which was invoked from Block 1240 of FIG. 12 (and which may also be recursively invoked from Block 1680 of FIG. 16 ).
- the input parameters as previously stated, are a variable to be resolved, a rule to be evaluated in attempting the resolution, and the current factsChain.
- the process begins (Block 1300 ) by initializing a result variable to null, creating a new temporary facts database tFDB, and pushing the input rule R and this new tFDB onto the input facts chain.
- Block 1305 sets a variable “proof” to the result of invoking the function CanProve, which is illustrated in FIG. 14 .
- the parameters on this invocation are the rule R and the current factsChain, as modified by Block 1300 .
- Block 1310 tests the result of the CanProve invocation. If this test has a negative result, then the rule R cannot be used to resolve the variable v because the premise(s) for R cannot be satisfied. Block 1315 will then pop off any temporary facts from the facts chain that were set as rule R was being evaluated, including facts set by any rules that were fired while attempting to set the premise(s) for R (where these rules may have also caused other rules to be fired in a recursive backtracking manner, as is known in the art for backward chaining rule evaluation). Block 1325 then pops the rule R off the facts chain, restoring the facts chain to the same contents it had on entry into this function. Block 1330 returns the value of the result variable, which has a null value when Block 1315 is executed, to the invoking logic.
- Block 1310 has a positive result when it is determined that the premise(s) of the current rule R can be satisfied (and thus that rule R can be used to resolve variable v).
- Block 1320 sets the result variable to the value of v which now exists (as a result of executing the logic of FIGS. 14-16, and thereby firing rules that set new facts) in the tFDB on the facts chain.
- Block 1325 pops rule R off the facts chain, and Block 1330 returns the (non-null) value of v to the invoking code.
- FIG. 14 illustrates a preferred embodiment of the logic of the CanProve function, which is invoked from Block 1305 of FIG. 13 .
- the input parameters are a rule R to be evaluated, and a facts chain to be used in this evaluation process.
- Block 1400 begins by initializing a facts list “fList” to a new (empty) list, setting a success flag to true, and creating a copy of the premise(s) in the input rule as the value of variable “copyP”.
- Block 1405 sets the value of variable “premise” to the next premise from this list in copyP.
- Block 1410 checks to see if the premise was null. If so, then control transfers to Block 1420 ; otherwise, Block 1415 invokes the TryProof function shown in FIG. 15 .
- the parameters on this invocation are the current premise, the remaining premises (if any), and the current facts chain.
- the success flag is set to the result of the TryProof invocation, where this TryProof function determines whether each premise in rule R can
- Block 1420 tests the value of the success flag. Control reaches Block 1420 when the premise from rule R was null (in which case success remains set to true from execution of Block 1400 ), and following evaluation of the non-null premise(s) at Block 1415 . If the success flag has been set to false, then this rule R cannot be used to resolve variable v because the rule's premises cannot be met, and thus Block 1425 returns the Boolean FALSE to the invoking code. Otherwise, processing continues at Block 1430 .
- Block 1430 it is known that the fact value(s) required by the premise(s) of the current rule R can be supplied so that all the premise(s) in R can be evaluated, and therefore firing R may lead to a value for variable v.
- Blocks 1430 through 1450 iteratively fire (i.e. process) each conclusion in the rule.
- a variable “concl” is set to the next conclusion in rule R at Block 1430 .
- Block 1435 then tests to see if this conclusion is null, indicating that all the conclusions have been processed. If so, Block 1440 returns the Boolean value TRUE.
- Block 1445 sets variable “n” to the fact set by this conclusion, evaluates the conclusion, and sets variable “val” to the value for n that is produced by the evaluation.
- n is set to “criticalInformationOnly” and value is set to “1” during execution of Block 1445 .
- FIG. 15 illustrates a preferred embodiment of the TryProof function which was invoked from Block 1415 of FIG. 14 (and which may also be invoked from Block 1625 of FIG. 16 ).
- the input parameters to this function are a premise to be evaluated, the remaining premises (if any) from the rule currently being evaluated, and the current facts chain.
- Block 1500 initializes variables “fList” and “namesAndRules” to new (empty) lists, and a result variable to false.
- “namesAndRules” contains fact names and either (1) a list of the rules which may set this fact, or (2) the fact in (name, value) form once it is resolved.
- Block 1505 extracts the fact names from the current premise and adds these fact names to fList. (As described above with reference to the processing of Block 1005 , a set is preferably used for fList, to avoid duplicate entries.)
- Block 1510 retrieves the next name from fList, and Block 1515 then checks to see if this name is null.
- Block 1520 invokes the UnifyExpr function illustrated in FIG. 16 to set the result variable.
- the parameters passed on this invocation are the input premise, the current namesAndRules list, the current facts chain, and the remaining premises of the current rule (in copyP).
- UnifyExpr the result of the invocation is returned (Block 1525 ) to the code from which TryProof was invoked.
- Block 1530 a test is made to determine whether the current fact name exists in the current facts chain or in the main FDB (as an already-resolved name, value pair). If this test has a positive result, the fact name and its value are added (Block 1535 ) to the namesAndRules list, after which control returns to Block 1510 to process the next fact name (if any). Otherwise, when the fact has not already been resolved, Block 1540 sets the variable “relevantRules” to the list of rules (preferably created according to the logic depicted in FIG. 8) which have conclusions that set this fact name.
- Block 1545 then removes from this list those rules which have already been attempted and thus are already on the fact chain (in order to avoid creating an endless loop of rule attempts).
- Block 1550 adds the current fact name and the modified list of relevantRules to the namesAndRules list, and control returns to Block 1510 to process the next fact name from the premise.
- the namesAndRules list is created to contain the name and value for any facts which are already resolved (Block 1535 ), and for those facts which are not yet resolved, the fact name and the rules that will potentially lead to resolving that fact (Blocks 1540 through 1550 ).
- This namesAndRules list is passed to UnifyExpr at Block 1520 , as discussed above.
- FIG. 16 A preferred embodiment of the logic used to implement the UnifyExpr function is shown in FIG. 16 .
- This function is invoked from Block 1520 of FIG. 15, and may also be invoked recursively from Block 1675 .
- the in put parameters to this invocation are a premise to be evaluated, a namesAndRules list, the current facts chain, and the remaining premises (if any) in the rule being evaluated.
- the namesAndRules list as described above, contains an entry for each fact name in the input premise, and for each of these names further contains either a value or a list of rules that may be fired in an attempt to resolve a value for that fact name.
- Block 1600 begins this process by initializing a result variable to false, and setting a variable “nameAndRulesOrFact” to the next entry from the input namesAndRules list.
- Block 1605 tests whether this nameAndRulesOrFact variable is null, indicating that all the entries in the list have been processed. If so, control transfers to Block 1610 ; otherwise, processing continues at Block 1640 .
- Block 1610 Upon reaching Block 1610 , all fact names in the current (input) premise have been processed. The result variable is then set to the result of evaluating this premise using the fact values in the main FDB and the current facts chain. If this premise evaluates to TRUE and there are more premises of the rule being evaluated which need to be processed, then Block 1615 has a positive result and control transfers to Block 1620 . Otherwise, when either (or both) the result of evaluating the current premise is FALSE, and there are no more premises to be evaluated, Block 1615 has a negative result and the value of result is returned to the invoking logic at Block 1635 .
- Block 1620 retrieves the next premise from the list passed as input.
- Block 1625 sets the result variable by invoking the function TryProof (see FIG. 15 ), passing as input parameters this new premise, the remaining premise(s) for the current rule, and the current facts chain.
- Block 1630 restores the premise which was just processed by Blocks 1620 and 1625 to the front of the copyP list (in case this function is invoked recursively).
- Block 1635 then returns the result of the TryProof invocation (from Block 1625 ) to the invoking code.
- Block 1640 there is an entry from the namesAndRules list to be processed (where this entry is the current value of nameAndRulesOrFact).
- each entry from namesAndRules comprises a fact name and either a list of rules that can be used to resolve that fact, or if it has already been resolved, the fact in a name, value form.
- Block 1640 retrieves the list of rules or the resolved fact from this entry, and stores that as the value of “rulesOrFact”, and also retrieves the fact name from the entry and stores the fact name as the value of “name”.
- Block 1645 stores a copy of the top tfDB on the facts chain as the variable “origFacts”.
- this copy may be made by popping off the top tfDB to store as origFacts, after which the tfDB is then pushed back onto the facts chain.
- Block 1650 checks to see if both of two conditions are true, where those conditions are (1) the rulesOrFact entry is not empty, and (2) the result variable is set to false. If both conditions are true, processing continues at Block 1660 . When one or both of these conditions is false, then it is not productive to evaluate the information stored in rulesOrFact, so processing continues in this case at Block 1655 where the nameAndRulesOrFact information is put back at the front of the namesAndRules list (so that the entry is restored to the namesAndRules list in case this function is invoked recursively). Processing then continues at Block 1630 , which puts the current premise back onto the front of the premise list in copyP, as has been described.
- Control reaches Block 1660 from Block 1650 when there is something in rulesOrFact and result is still set to false.
- the next element of the rulesOrFact entry where this element is either the single fact in rulesOrFact or a rule from a list of rules, is set to the variable “ruleOrFact” at Block 1660 .
- Block 1665 then asks whether this is a rule. If it was, processing continues at Block 1680 . Otherwise, when it is a fact, processing continues at Block 1670 .
- Block 1670 sets variable “value” to the value part of the fact. (Preferably, this value variable is part of a premise object, where this object is used when the variable “premise” is referred to herein during the discussion of the flowcharts.)
- Block 1675 then recursively invokes the processing of UnifyExpr, passing as input parameters the current premise, the current namesAndRules list, the current facts chain, and the remaining premises in copyP.
- Block 1690 Upon returning from this function invocation, the value which was added to the current context object at Block 1670 or Block 1680 is removed at Block 1677 .
- Block 1690 then tests the value that has been set as the result variable. If result is false, Block 1695 pops all the temporary facts from the facts chain through (and including) the entry origFacts (a copy of which was saved at Block 1645 ). Control then returns to Block 1660 to begin processing another rule. When the result tested at Block 1690 is true, processing transfers to Block 1630 .
- Block 1680 begins the processing of a rule from the namesAndRules list.
- the UnifyRule function (see FIG. 13) is invoked to attempt unification of this rule, passing as input parameters the current fact name, the rule (from ruleOrFact) to be used in evaluating this fact name, and the current facts chain. Upon returning from this invocation, the value which was returned is then added to the current context object. Block 1685 checks the value which was returned. If the value is null, then it is not possible to resolve this fact name, and control transfers to Block 1630 . Otherwise, control transfers to Block 1675 which attempts unification of the expression in the premise, as has been described above.
- the present invention provides an advantageous technique for combining an enhanced scripting language and a rule-based system for creating and evaluating rules to dynamically aggregate values of one or more factors. This result is then made available to an application program, which will use it to tailor the processing of the application. This technique avoids having to change the software process itself as new values and/or new factors are deemed to be important to the aggregation result.
- the determination of the value is separated from the process logic which makes use of the value.
- Increasingly complex logic can be used to resolve the values from multiple sources, without creating complicated and hard-to-maintain statically coded logic as is required in prior art approaches. And, the logic can be easily changed by system users, administrators, or others without requiring them to understand a complicated programming language.
Abstract
Description
( | ||
getFact (context, “networkSpeed”) | ||
< | ||
14400 | ||
) | ||
( | ||
setFact (context, “criticalInformationOnly”, | ||
1 | ||
) | ||
Claims (24)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US09/504,209 US6681380B1 (en) | 2000-02-15 | 2000-02-15 | Aggregating constraints and/or preferences using an inference engine and enhanced scripting language |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US09/504,209 US6681380B1 (en) | 2000-02-15 | 2000-02-15 | Aggregating constraints and/or preferences using an inference engine and enhanced scripting language |
Publications (1)
Publication Number | Publication Date |
---|---|
US6681380B1 true US6681380B1 (en) | 2004-01-20 |
Family
ID=30001052
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US09/504,209 Expired - Lifetime US6681380B1 (en) | 2000-02-15 | 2000-02-15 | Aggregating constraints and/or preferences using an inference engine and enhanced scripting language |
Country Status (1)
Country | Link |
---|---|
US (1) | US6681380B1 (en) |
Cited By (47)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20020001295A1 (en) * | 2000-06-26 | 2002-01-03 | Woo-Kyeong Park | System and method for providing wireless application protocol service through internet |
US20020046295A1 (en) * | 2000-10-18 | 2002-04-18 | Nec Corporation | Object filtering method and client device using the same |
US20030163787A1 (en) * | 1999-12-24 | 2003-08-28 | Hay Brian Robert | Virtual token |
US20030220989A1 (en) * | 2002-05-23 | 2003-11-27 | Michael Tsuji | Method and system for client browser update |
US20040019851A1 (en) * | 2002-07-23 | 2004-01-29 | Xerox Corporation | Constraint-optimization system and method for document component layout generation |
US20040034613A1 (en) * | 2002-07-23 | 2004-02-19 | Xerox Corporation | System and method for dynamically generating a style sheet |
US20040088198A1 (en) * | 2002-10-31 | 2004-05-06 | Childress Allen B. | Method of modifying a business rule while tracking the modifications |
US20040088278A1 (en) * | 2002-10-30 | 2004-05-06 | Jp Morgan Chase | Method to measure stored procedure execution statistics |
US20040103199A1 (en) * | 2002-11-22 | 2004-05-27 | Anthony Chao | Method and system for client browser update from a lite cache |
US20040107183A1 (en) * | 2002-12-03 | 2004-06-03 | Jp Morgan Chase Bank | Method for simplifying databinding in application programs |
US20040176930A1 (en) * | 2003-03-03 | 2004-09-09 | Microsoft Corporation | System and method for statically checking source code |
US20040205472A1 (en) * | 2002-07-23 | 2004-10-14 | Xerox Corporation | System and method for constraint-based document generation |
US20040254824A1 (en) * | 2003-01-07 | 2004-12-16 | Alex Loucaides | System and method for process scheduling |
US20050065965A1 (en) * | 2003-09-19 | 2005-03-24 | Ziemann David M. | Navigation of tree data structures |
US20050182957A1 (en) * | 2004-02-16 | 2005-08-18 | Microsoft Corporation | Security scopes and profiles |
US20050193202A1 (en) * | 2004-02-26 | 2005-09-01 | Microsoft Corporation | Digests to identify elements in a signature process |
US20050222990A1 (en) * | 2004-04-06 | 2005-10-06 | Milne Kenneth T | Methods and systems for using script files to obtain, format and disseminate database information |
US20060053369A1 (en) * | 2004-09-03 | 2006-03-09 | Henri Kalajian | System and method for managing template attributes |
US20060059210A1 (en) * | 2004-09-16 | 2006-03-16 | Macdonald Glynne | Generic database structure and related systems and methods for storing data independent of data type |
US20060080255A1 (en) * | 1999-02-09 | 2006-04-13 | The Chase Manhattan Bank | System and method for back office processing of banking transactions using electronic files |
US7065745B2 (en) | 2002-12-16 | 2006-06-20 | Sun Microsystems, Inc. | System and method for evaluating and executing hierarchies of rules |
US7069539B1 (en) * | 2001-12-10 | 2006-06-27 | Cisco Technology, Inc | Approach for implementing policy constraints in applications |
US20060200508A1 (en) * | 2003-08-08 | 2006-09-07 | Jp Morgan Chase Bank | System for archive integrity management and related methods |
US20070154926A1 (en) * | 1996-05-03 | 2007-07-05 | Applera Corporation | Methods of analyzing polynucleotides employing energy transfer dyes |
US7328211B2 (en) | 2000-09-21 | 2008-02-05 | Jpmorgan Chase Bank, N.A. | System and methods for improved linguistic pattern matching |
US20090006140A1 (en) * | 2007-06-29 | 2009-01-01 | Wait Julian F | Claims processing hierarchy for insured |
US20090006137A1 (en) * | 2007-06-04 | 2009-01-01 | Wait Julian F | Claims processing hierarchy for designee |
US20090030670A1 (en) * | 2007-07-25 | 2009-01-29 | International Business Machines Corporation | Real-time multi-lingual adaptation of manufacturing instructions in a manufacturing management system |
US20090132466A1 (en) * | 2004-10-13 | 2009-05-21 | Jp Morgan Chase Bank | System and method for archiving data |
US7571107B1 (en) * | 2000-06-23 | 2009-08-04 | Computer Sciences Corporation | System and method for externalization of rules for assessing damages |
US20090276419A1 (en) * | 2008-05-01 | 2009-11-05 | Chacha Search Inc. | Method and system for improvement of request processing |
US7676387B2 (en) | 2002-10-31 | 2010-03-09 | Computer Sciences Corporation | Graphical display of business rules |
US7689442B2 (en) | 2002-10-31 | 2010-03-30 | Computer Science Corporation | Method of generating a graphical display of a business rule with a translation |
US7895064B2 (en) | 2003-09-02 | 2011-02-22 | Computer Sciences Corporation | Graphical input display in an insurance processing system |
US7991630B2 (en) | 2008-01-18 | 2011-08-02 | Computer Sciences Corporation | Displaying likelihood values for use in settlement |
US8010390B2 (en) | 2007-06-04 | 2011-08-30 | Computer Sciences Corporation | Claims processing of information requirements |
US8010389B2 (en) | 2007-06-04 | 2011-08-30 | Computer Sciences Corporation | Multiple policy claims processing |
US8065606B1 (en) | 2005-09-16 | 2011-11-22 | Jpmorgan Chase Bank, N.A. | System and method for automating document generation |
US8104076B1 (en) | 2006-11-13 | 2012-01-24 | Jpmorgan Chase Bank, N.A. | Application access control system |
US20140173557A1 (en) * | 2008-09-30 | 2014-06-19 | Ics Triplex Isagraf Inc. | Multi language editor |
US20140324753A1 (en) * | 2013-04-29 | 2014-10-30 | The Research Foundation for the State University of New York | Method and system that provides efficient index-based retrieval of rules |
US8914524B1 (en) * | 2011-03-16 | 2014-12-16 | Amazon Technologies, Inc. | Load time adapted network page(s) |
US9038177B1 (en) | 2010-11-30 | 2015-05-19 | Jpmorgan Chase Bank, N.A. | Method and system for implementing multi-level data fusion |
US9292588B1 (en) | 2011-07-20 | 2016-03-22 | Jpmorgan Chase Bank, N.A. | Safe storing data for disaster recovery |
US10402450B2 (en) * | 2016-05-13 | 2019-09-03 | Google Llc | Personalized and contextualized audio briefing |
US10535343B2 (en) | 2016-05-10 | 2020-01-14 | Google Llc | Implementations for voice assistant on devices |
US10540373B1 (en) | 2013-03-04 | 2020-01-21 | Jpmorgan Chase Bank, N.A. | Clause library manager |
Citations (15)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5159687A (en) * | 1989-11-14 | 1992-10-27 | Caseworks, Inc. | Method and apparatus for generating program code files |
US5687378A (en) * | 1995-06-07 | 1997-11-11 | Motorola, Inc. | Method and apparatus for dynamically reconfiguring a parser |
US5701400A (en) * | 1995-03-08 | 1997-12-23 | Amado; Carlos Armando | Method and apparatus for applying if-then-else rules to data sets in a relational data base and generating from the results of application of said rules a database of diagnostics linked to said data sets to aid executive analysis of financial data |
US5734798A (en) * | 1995-12-01 | 1998-03-31 | Hewlett-Packard Co. | Method and apparatus for extracting a gate modeled circuit from a fet modeled circuit |
US5778231A (en) * | 1995-12-20 | 1998-07-07 | Sun Microsystems, Inc. | Compiler system and method for resolving symbolic references to externally located program files |
US5966540A (en) * | 1997-02-06 | 1999-10-12 | International Business Machines Corp. | Hosted machine code installation |
US6094221A (en) * | 1997-01-02 | 2000-07-25 | Andersion; Eric C. | System and method for using a scripting language to set digital camera device features |
US6237144B1 (en) * | 1998-09-21 | 2001-05-22 | Microsoft Corporation | Use of relational databases for software installation |
US6256635B1 (en) * | 1998-05-08 | 2001-07-03 | Apple Computer, Inc. | Method and apparatus for configuring a computer using scripting |
US6266811B1 (en) * | 1997-12-31 | 2001-07-24 | Network Associates | Method and system for custom computer software installation using rule-based installation engine and simplified script computer program |
US6269480B1 (en) * | 1999-03-29 | 2001-07-31 | International Business Machines Corporation | Cross platform installer-with the ability to create platform independent variables of specific operating system variables from a scripting language |
US6311320B1 (en) * | 1998-12-07 | 2001-10-30 | Lsi Logic Corporation | Alterable scripting tool and method |
US6314416B1 (en) * | 1998-11-17 | 2001-11-06 | Interface & Control Systems, Inc. | Reconfigurable expert rule processing system |
US6330711B1 (en) * | 1998-07-30 | 2001-12-11 | International Business Machines Corporation | Method and apparatus for dynamic application and maintenance of programs |
US6353925B1 (en) * | 1999-09-22 | 2002-03-05 | Compaq Computer Corporation | System and method for lexing and parsing program annotations |
-
2000
- 2000-02-15 US US09/504,209 patent/US6681380B1/en not_active Expired - Lifetime
Patent Citations (15)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5159687A (en) * | 1989-11-14 | 1992-10-27 | Caseworks, Inc. | Method and apparatus for generating program code files |
US5701400A (en) * | 1995-03-08 | 1997-12-23 | Amado; Carlos Armando | Method and apparatus for applying if-then-else rules to data sets in a relational data base and generating from the results of application of said rules a database of diagnostics linked to said data sets to aid executive analysis of financial data |
US5687378A (en) * | 1995-06-07 | 1997-11-11 | Motorola, Inc. | Method and apparatus for dynamically reconfiguring a parser |
US5734798A (en) * | 1995-12-01 | 1998-03-31 | Hewlett-Packard Co. | Method and apparatus for extracting a gate modeled circuit from a fet modeled circuit |
US5778231A (en) * | 1995-12-20 | 1998-07-07 | Sun Microsystems, Inc. | Compiler system and method for resolving symbolic references to externally located program files |
US6094221A (en) * | 1997-01-02 | 2000-07-25 | Andersion; Eric C. | System and method for using a scripting language to set digital camera device features |
US5966540A (en) * | 1997-02-06 | 1999-10-12 | International Business Machines Corp. | Hosted machine code installation |
US6266811B1 (en) * | 1997-12-31 | 2001-07-24 | Network Associates | Method and system for custom computer software installation using rule-based installation engine and simplified script computer program |
US6256635B1 (en) * | 1998-05-08 | 2001-07-03 | Apple Computer, Inc. | Method and apparatus for configuring a computer using scripting |
US6330711B1 (en) * | 1998-07-30 | 2001-12-11 | International Business Machines Corporation | Method and apparatus for dynamic application and maintenance of programs |
US6237144B1 (en) * | 1998-09-21 | 2001-05-22 | Microsoft Corporation | Use of relational databases for software installation |
US6314416B1 (en) * | 1998-11-17 | 2001-11-06 | Interface & Control Systems, Inc. | Reconfigurable expert rule processing system |
US6311320B1 (en) * | 1998-12-07 | 2001-10-30 | Lsi Logic Corporation | Alterable scripting tool and method |
US6269480B1 (en) * | 1999-03-29 | 2001-07-31 | International Business Machines Corporation | Cross platform installer-with the ability to create platform independent variables of specific operating system variables from a scripting language |
US6353925B1 (en) * | 1999-09-22 | 2002-03-05 | Compaq Computer Corporation | System and method for lexing and parsing program annotations |
Non-Patent Citations (4)
Title |
---|
"NetRexx 2", retrieved from http://www2.hursley.ibm.com/netrexx/nrwhat.html on Jun. 6, 2002. * |
Bowen, Barry D., "The elephant is dancing nicely with Java", Jul. 1997, retrieved from http://www.javaworld.com/jw-07-1997/jw-07-ibm_p.html, on Jun. 6, 2002.* * |
Cowlishaw, Mike, "NetRexx language quick start", retrieved from http://www2.hursley.ibm.com/netrexx/netrexx0.html on Jun. 6, 2002.* * |
Cowlishaw, Mike, "NetRexx-an alternative for writing Java classes", IBM UK Laboratories, retrieved from IEEE database Jun. 6, 2002.* * |
Cited By (83)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20070154926A1 (en) * | 1996-05-03 | 2007-07-05 | Applera Corporation | Methods of analyzing polynucleotides employing energy transfer dyes |
US10467688B1 (en) | 1999-02-09 | 2019-11-05 | Jpmorgan Chase Bank, N.A. | System and method for back office processing of banking transactions using electronic files |
US20060080255A1 (en) * | 1999-02-09 | 2006-04-13 | The Chase Manhattan Bank | System and method for back office processing of banking transactions using electronic files |
US8600893B2 (en) | 1999-02-09 | 2013-12-03 | Jpmorgan Chase Bank, National Association | System and method for back office processing of banking transactions using electronic files |
US8370232B2 (en) | 1999-02-09 | 2013-02-05 | Jpmorgan Chase Bank, National Association | System and method for back office processing of banking transactions using electronic files |
US20030163787A1 (en) * | 1999-12-24 | 2003-08-28 | Hay Brian Robert | Virtual token |
US8037193B2 (en) * | 1999-12-24 | 2011-10-11 | Telstra Corporation Limited | Virtual token |
US7571107B1 (en) * | 2000-06-23 | 2009-08-04 | Computer Sciences Corporation | System and method for externalization of rules for assessing damages |
US20020001295A1 (en) * | 2000-06-26 | 2002-01-03 | Woo-Kyeong Park | System and method for providing wireless application protocol service through internet |
US6937588B2 (en) * | 2000-06-26 | 2005-08-30 | Samsung Electronics Co., Ltd. | System and method for providing wireless application protocol service through internet |
US7328211B2 (en) | 2000-09-21 | 2008-02-05 | Jpmorgan Chase Bank, N.A. | System and methods for improved linguistic pattern matching |
US7756927B2 (en) * | 2000-10-18 | 2010-07-13 | Nec Corporation | Object filtering method and client device using the same |
US20020046295A1 (en) * | 2000-10-18 | 2002-04-18 | Nec Corporation | Object filtering method and client device using the same |
US7069539B1 (en) * | 2001-12-10 | 2006-06-27 | Cisco Technology, Inc | Approach for implementing policy constraints in applications |
US7987246B2 (en) | 2002-05-23 | 2011-07-26 | Jpmorgan Chase Bank | Method and system for client browser update |
US20030220989A1 (en) * | 2002-05-23 | 2003-11-27 | Michael Tsuji | Method and system for client browser update |
US20040205472A1 (en) * | 2002-07-23 | 2004-10-14 | Xerox Corporation | System and method for constraint-based document generation |
US7107525B2 (en) * | 2002-07-23 | 2006-09-12 | Xerox Corporation | Method for constraint-based document generation |
US7487445B2 (en) | 2002-07-23 | 2009-02-03 | Xerox Corporation | Constraint-optimization system and method for document component layout generation |
US20040034613A1 (en) * | 2002-07-23 | 2004-02-19 | Xerox Corporation | System and method for dynamically generating a style sheet |
US20040019851A1 (en) * | 2002-07-23 | 2004-01-29 | Xerox Corporation | Constraint-optimization system and method for document component layout generation |
US20040088278A1 (en) * | 2002-10-30 | 2004-05-06 | Jp Morgan Chase | Method to measure stored procedure execution statistics |
US20040088198A1 (en) * | 2002-10-31 | 2004-05-06 | Childress Allen B. | Method of modifying a business rule while tracking the modifications |
US7676387B2 (en) | 2002-10-31 | 2010-03-09 | Computer Sciences Corporation | Graphical display of business rules |
US7689442B2 (en) | 2002-10-31 | 2010-03-30 | Computer Science Corporation | Method of generating a graphical display of a business rule with a translation |
US20040103199A1 (en) * | 2002-11-22 | 2004-05-27 | Anthony Chao | Method and system for client browser update from a lite cache |
US20040107183A1 (en) * | 2002-12-03 | 2004-06-03 | Jp Morgan Chase Bank | Method for simplifying databinding in application programs |
US7065745B2 (en) | 2002-12-16 | 2006-06-20 | Sun Microsystems, Inc. | System and method for evaluating and executing hierarchies of rules |
US10692135B2 (en) | 2003-01-07 | 2020-06-23 | Jpmorgan Chase Bank, N.A. | System and method for process scheduling |
US20040254824A1 (en) * | 2003-01-07 | 2004-12-16 | Alex Loucaides | System and method for process scheduling |
US8032439B2 (en) | 2003-01-07 | 2011-10-04 | Jpmorgan Chase Bank, N.A. | System and method for process scheduling |
US20040176930A1 (en) * | 2003-03-03 | 2004-09-09 | Microsoft Corporation | System and method for statically checking source code |
US6873935B2 (en) * | 2003-03-03 | 2005-03-29 | Microsoft Corporation | System and method for statically checking source code |
US20060200508A1 (en) * | 2003-08-08 | 2006-09-07 | Jp Morgan Chase Bank | System for archive integrity management and related methods |
US7617261B2 (en) | 2003-08-08 | 2009-11-10 | Jp Morgan Chase Bank | System for archive integrity management and related methods |
US7895064B2 (en) | 2003-09-02 | 2011-02-22 | Computer Sciences Corporation | Graphical input display in an insurance processing system |
US20050065965A1 (en) * | 2003-09-19 | 2005-03-24 | Ziemann David M. | Navigation of tree data structures |
US7516139B2 (en) | 2003-09-19 | 2009-04-07 | Jp Morgan Chase Bank | Processing of tree data structures |
US7716728B2 (en) | 2004-02-16 | 2010-05-11 | Microsoft Corproation | Security scopes and profiles |
US20050182957A1 (en) * | 2004-02-16 | 2005-08-18 | Microsoft Corporation | Security scopes and profiles |
US20050193202A1 (en) * | 2004-02-26 | 2005-09-01 | Microsoft Corporation | Digests to identify elements in a signature process |
US7873831B2 (en) | 2004-02-26 | 2011-01-18 | Microsoft Corporation | Digests to identify elements in a signature process |
US8725776B2 (en) | 2004-02-26 | 2014-05-13 | Microsoft Corporation | Digests to identify elements in a signature process |
US20110078212A1 (en) * | 2004-02-26 | 2011-03-31 | Microsoft Corporation | Digests to Identify Elements in a Signature Process |
US20050222990A1 (en) * | 2004-04-06 | 2005-10-06 | Milne Kenneth T | Methods and systems for using script files to obtain, format and disseminate database information |
US20060053369A1 (en) * | 2004-09-03 | 2006-03-09 | Henri Kalajian | System and method for managing template attributes |
US7366974B2 (en) | 2004-09-03 | 2008-04-29 | Jp Morgan Chase Bank | System and method for managing template attributes |
US20060059210A1 (en) * | 2004-09-16 | 2006-03-16 | Macdonald Glynne | Generic database structure and related systems and methods for storing data independent of data type |
US20090132466A1 (en) * | 2004-10-13 | 2009-05-21 | Jp Morgan Chase Bank | System and method for archiving data |
US8065606B1 (en) | 2005-09-16 | 2011-11-22 | Jpmorgan Chase Bank, N.A. | System and method for automating document generation |
US8732567B1 (en) | 2005-09-16 | 2014-05-20 | Jpmorgan Chase Bank, N.A. | System and method for automating document generation |
US8104076B1 (en) | 2006-11-13 | 2012-01-24 | Jpmorgan Chase Bank, N.A. | Application access control system |
US8010389B2 (en) | 2007-06-04 | 2011-08-30 | Computer Sciences Corporation | Multiple policy claims processing |
US8010390B2 (en) | 2007-06-04 | 2011-08-30 | Computer Sciences Corporation | Claims processing of information requirements |
US8000986B2 (en) | 2007-06-04 | 2011-08-16 | Computer Sciences Corporation | Claims processing hierarchy for designee |
US20090006137A1 (en) * | 2007-06-04 | 2009-01-01 | Wait Julian F | Claims processing hierarchy for designee |
US8010391B2 (en) | 2007-06-29 | 2011-08-30 | Computer Sciences Corporation | Claims processing hierarchy for insured |
US20090006140A1 (en) * | 2007-06-29 | 2009-01-01 | Wait Julian F | Claims processing hierarchy for insured |
US9164986B2 (en) | 2007-07-25 | 2015-10-20 | International Business Machines Corporation | Real-time multi-lingual adaptation of manufacturing instructions in a manufacturing management system |
US20090030670A1 (en) * | 2007-07-25 | 2009-01-29 | International Business Machines Corporation | Real-time multi-lingual adaptation of manufacturing instructions in a manufacturing management system |
US8219424B2 (en) | 2008-01-18 | 2012-07-10 | Computer Sciences Corporation | Determining amounts for claims settlement using likelihood values |
US8244558B2 (en) | 2008-01-18 | 2012-08-14 | Computer Sciences Corporation | Determining recommended settlement amounts by adjusting values derived from matching similar claims |
US7991630B2 (en) | 2008-01-18 | 2011-08-02 | Computer Sciences Corporation | Displaying likelihood values for use in settlement |
US20090276419A1 (en) * | 2008-05-01 | 2009-11-05 | Chacha Search Inc. | Method and system for improvement of request processing |
US8719256B2 (en) * | 2008-05-01 | 2014-05-06 | Chacha Search, Inc | Method and system for improvement of request processing |
US20140173557A1 (en) * | 2008-09-30 | 2014-06-19 | Ics Triplex Isagraf Inc. | Multi language editor |
US9696969B2 (en) * | 2008-09-30 | 2017-07-04 | Rockwell Automation Canada Ltd. | Multi language editor |
US9038177B1 (en) | 2010-11-30 | 2015-05-19 | Jpmorgan Chase Bank, N.A. | Method and system for implementing multi-level data fusion |
US8914524B1 (en) * | 2011-03-16 | 2014-12-16 | Amazon Technologies, Inc. | Load time adapted network page(s) |
US9894135B1 (en) * | 2011-03-16 | 2018-02-13 | Amazon Technologies, Inc. | Load time adapted network pages |
US9292588B1 (en) | 2011-07-20 | 2016-03-22 | Jpmorgan Chase Bank, N.A. | Safe storing data for disaster recovery |
US9971654B2 (en) | 2011-07-20 | 2018-05-15 | Jpmorgan Chase Bank, N.A. | Safe storing data for disaster recovery |
US10540373B1 (en) | 2013-03-04 | 2020-01-21 | Jpmorgan Chase Bank, N.A. | Clause library manager |
US9367807B2 (en) * | 2013-04-29 | 2016-06-14 | Vulcan, Inc. | Method and system that provides efficient index-based retrieval of rules |
US20140324753A1 (en) * | 2013-04-29 | 2014-10-30 | The Research Foundation for the State University of New York | Method and system that provides efficient index-based retrieval of rules |
US10535343B2 (en) | 2016-05-10 | 2020-01-14 | Google Llc | Implementations for voice assistant on devices |
US10861461B2 (en) | 2016-05-10 | 2020-12-08 | Google Llc | LED design language for visual affordance of voice user interfaces |
US11341964B2 (en) | 2016-05-10 | 2022-05-24 | Google Llc | Voice-controlled media play in smart media environment |
US11355116B2 (en) | 2016-05-10 | 2022-06-07 | Google Llc | Implementations for voice assistant on devices |
US11922941B2 (en) | 2016-05-10 | 2024-03-05 | Google Llc | Implementations for voice assistant on devices |
US11935535B2 (en) | 2016-05-10 | 2024-03-19 | Google Llc | Implementations for voice assistant on devices |
US10402450B2 (en) * | 2016-05-13 | 2019-09-03 | Google Llc | Personalized and contextualized audio briefing |
US11860933B2 (en) | 2016-05-13 | 2024-01-02 | Google Llc | Personalized and contextualized audio briefing |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US6681380B1 (en) | Aggregating constraints and/or preferences using an inference engine and enhanced scripting language | |
Carzaniga et al. | Designing distributed applications with mobile code paradigms | |
US6279030B1 (en) | Dynamic JAVA™ class selection and download based on changeable attributes | |
US6463440B1 (en) | Retrieval of style sheets from directories based upon partial characteristic matching | |
US6324681B1 (en) | Automated development system for developing applications that interface with both distributed component object model (DCOM) and enterprise server environments | |
US7296297B2 (en) | System and method for using web-based applications to validate data with validation functions | |
US7640347B1 (en) | Method and system for inserting POST data into the GET request to apply normal caching rules | |
US6031977A (en) | Object-oriented distributed communications directory service | |
EP1461928B1 (en) | Method and system for network caching | |
US6519617B1 (en) | Automated creation of an XML dialect and dynamic generation of a corresponding DTD | |
US8032586B2 (en) | Method and system for caching message fragments using an expansion attribute in a fragment link tag | |
US5548726A (en) | System for activating new service in client server network by reconfiguring the multilayer network protocol stack dynamically within the server node | |
US7987239B2 (en) | Method and system for caching role-specific fragments | |
US7134076B2 (en) | Method and apparatus for portable universal resource locator and coding across runtime environments | |
US7636770B2 (en) | System, method and computer program product for publishing interactive web content as a statically linked web hierarchy | |
US7457815B2 (en) | Method and apparatus for automatically providing network services | |
US20130254258A1 (en) | Offloading application components to edge servers | |
US20060085461A1 (en) | System & method for using web based applications to manipulate data with manipulation functions | |
US20030188021A1 (en) | Method and system for processing multiple fragment requests in a single message | |
US20040236824A1 (en) | Post-cache substitution | |
US20200057617A1 (en) | Software code optimizer and method | |
US20040117350A1 (en) | Apparatus and method for optimizing schema definitions for an LDAP directory | |
US7392313B2 (en) | Method and apparatus for partitioned environment for web application servers | |
US20070043717A1 (en) | Relevancy association architecture | |
US20100011411A1 (en) | Policy-Based Usage of Computing Assets |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: IBM CORPORATION, NEW YORKFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:BRITTON, KATHRYN H.;SEEKAMP, CHRISTOPHER R.;REEL/FRAME:010621/0407;SIGNING DATES FROM 20000202 TO 20000205 |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
FPAY | Fee payment |
Year of fee payment: 4 |
|
REMI | Maintenance fee reminder mailed | ||
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:INTERNATIONAL BUSINESS MACHINES CORPORATION;REEL/FRAME:026894/0001Effective date: 20110817 |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
SULP | Surcharge for late payment |
Year of fee payment: 7 |
|
FPAY | Fee payment |
Year of fee payment: 12 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044127/0735Effective date: 20170929 |