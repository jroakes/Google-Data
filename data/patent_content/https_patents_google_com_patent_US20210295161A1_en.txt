US20210295161A1 - Training neural networks represented as computational graphs - Google Patents
Training neural networks represented as computational graphs Download PDFInfo
- Publication number
- US20210295161A1 US20210295161A1 US17/221,305 US202117221305A US2021295161A1 US 20210295161 A1 US20210295161 A1 US 20210295161A1 US 202117221305 A US202117221305 A US 202117221305A US 2021295161 A1 US2021295161 A1 US 2021295161A1
- Authority
- US
- United States
- Prior art keywords
- control flow
- computational graph
- node
- neural network
- nodes
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
- 238000013528 artificial neural network Methods 0.000 title claims abstract description 116
- 238000012549 training Methods 0.000 title claims abstract description 78
- 230000006870 function Effects 0.000 claims abstract description 40
- 238000000034 method Methods 0.000 claims abstract description 37
- 238000010801 machine learning Methods 0.000 claims abstract description 21
- 238000004422 calculation algorithm Methods 0.000 claims abstract description 18
- 230000003190 augmentative effect Effects 0.000 claims abstract description 17
- 238000012545 processing Methods 0.000 claims description 25
- 238000012544 monitoring process Methods 0.000 claims description 10
- 230000000306 recurrent effect Effects 0.000 claims description 4
- 238000004590 computer program Methods 0.000 description 14
- 230000008569 process Effects 0.000 description 14
- 230000015654 memory Effects 0.000 description 12
- 239000011159 matrix material Substances 0.000 description 11
- 238000004891 communication Methods 0.000 description 6
- 230000004069 differentiation Effects 0.000 description 5
- 238000010586 diagram Methods 0.000 description 4
- 230000003287 optical effect Effects 0.000 description 4
- 230000004044 response Effects 0.000 description 4
- 230000008901 benefit Effects 0.000 description 3
- 230000003993 interaction Effects 0.000 description 2
- 238000005192 partition Methods 0.000 description 2
- 230000000644 propagated effect Effects 0.000 description 2
- 238000013515 script Methods 0.000 description 2
- 238000000926 separation method Methods 0.000 description 2
- 230000009118 appropriate response Effects 0.000 description 1
- 238000003491 array Methods 0.000 description 1
- 230000005540 biological transmission Effects 0.000 description 1
- 238000010276 construction Methods 0.000 description 1
- 238000012804 iterative process Methods 0.000 description 1
- 239000004973 liquid crystal related substance Substances 0.000 description 1
- 238000013507 mapping Methods 0.000 description 1
- 238000005457 optimization Methods 0.000 description 1
- 229920001690 polydopamine Polymers 0.000 description 1
- 239000004065 semiconductor Substances 0.000 description 1
- 230000001953 sensory effect Effects 0.000 description 1
- 238000000638 solvent extraction Methods 0.000 description 1
- 239000000758 substrate Substances 0.000 description 1
- 238000012546 transfer Methods 0.000 description 1
- 230000000007 visual effect Effects 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/46—Multiprogramming arrangements
- G06F9/50—Allocation of resources, e.g. of the central processing unit [CPU]
- G06F9/5005—Allocation of resources, e.g. of the central processing unit [CPU] to service a request
- G06F9/5027—Allocation of resources, e.g. of the central processing unit [CPU] to service a request the resource being a machine, e.g. CPUs, Servers, Terminals
- G06F9/5038—Allocation of resources, e.g. of the central processing unit [CPU] to service a request the resource being a machine, e.g. CPUs, Servers, Terminals considering the execution order of a plurality of tasks, e.g. taking priority or time dependency constraints into consideration
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/46—Multiprogramming arrangements
- G06F9/50—Allocation of resources, e.g. of the central processing unit [CPU]
- G06F9/5005—Allocation of resources, e.g. of the central processing unit [CPU] to service a request
- G06F9/5011—Allocation of resources, e.g. of the central processing unit [CPU] to service a request the resources being hardware resources other than CPUs, Servers and Terminals
- G06F9/5016—Allocation of resources, e.g. of the central processing unit [CPU] to service a request the resources being hardware resources other than CPUs, Servers and Terminals the resource being the memory
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/46—Multiprogramming arrangements
- G06F9/50—Allocation of resources, e.g. of the central processing unit [CPU]
- G06F9/5005—Allocation of resources, e.g. of the central processing unit [CPU] to service a request
- G06F9/5027—Allocation of resources, e.g. of the central processing unit [CPU] to service a request the resource being a machine, e.g. CPUs, Servers, Terminals
- G06F9/5044—Allocation of resources, e.g. of the central processing unit [CPU] to service a request the resource being a machine, e.g. CPUs, Servers, Terminals considering hardware capabilities
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/044—Recurrent networks, e.g. Hopfield networks
-
- G06N3/0445—
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/045—Combinations of networks
-
- G06N3/0454—
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
- G06N3/084—Backpropagation, e.g. using gradient descent
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F2209/00—Indexing scheme relating to G06F9/00
- G06F2209/50—Indexing scheme relating to G06F9/50
- G06F2209/509—Offload
Definitions
- This specification relates to processing computational graphs representing neural networks.
- Neural networks are machine learning models that employ one or more layers of models to generate an output, e.g., one or more classifications, for a received input.
- Some neural networks include one or more hidden layers in addition to an output layer. The output of each hidden layer is used as input to the next layer in the network, i.e., the next hidden layer or the output layer of the network.
- Each layer of the network generates an output from a received input in accordance with current values of a respective set of parameters for the layer.
- the layers of a neural network are processed by an individual device.
- the device can have a processor that performs operations, e.g., generating outputs at a layer from inputs, and stores outputs from the operations in memory. Due to the large number and size of operations generally required to generate the outputs in the neural network, one device can take a significant amount of time to process the layers of the neural network.
- This specification describes a system implemented as computer programs on one or more computers in one or more locations that trains a neural network represented by a computational graph.
- the computational graph includes nodes, connector directed edges, and parameter directed edges.
- Each node represents a respective operation performed by the neural network as part of determining a neural network output from a neural network input
- each connector directed edge connects a respective first node to a respective second node that represents an operation that receives, as input, an output of an operation represented by the respective first node
- each parameter directed edge connects into a respective node and represents a flow of one or more parameters of the neural network as input to the operation represented by the respective node.
- one innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of obtaining data representing the computational graph; augmenting the computational graph to generate a training computational graph for training the neural network using a machine learning training algorithm that includes computing a gradient of an objective function with respect to each of the parameters of the neural network, comprising: inserting a plurality of gradient nodes and training edges into the computational graph to generate a backward path through the computational graph that represents operations for computing the gradients of the objective function with respect to parameters flowing along a respective parameter directed edge in the computational graph; and training the neural network using the machine learning training algorithm by executing the training computational graph.
- the system trains the neural network using the machine learning training algorithm by executing the training computational graph.
- the system may, as part of augmenting the computational graph, generate multiple instances of the computational graph that includes the backward path to generate a final training computational graph.
- the system may then allocate the nodes in the final training computational graph across a plurality of devices; and cause each of the devices to perform the operations represented by the nodes allocated to the device. Processing a computational graph in a distributed manner is described in more detail in U.S. patent application Ser. No. 15/337,744, entitled PROCESSING COMPUTATIONAL GRAPHS, filed on Oct. 28, 2016, and U.S. patent application Ser. No. 15/338,225, entitled MODIFYING COMPUTATIONAL GRAPHS, filed on Oct. 28, 2016, the contents of each which are hereby incorporated by reference herein in their entirety.
- inventions of this aspect include corresponding computer systems, apparatus, and computer programs recorded on one or more computer storage devices, each configured to perform the actions of the methods.
- a system of one or more computers to be configure to perform particular operations or actions means that the system has installed on it software, firmware, hardware, or a combination of them that in operation cause the system to perform the operations or actions.
- one or more computer programs to be configured to perform particular operations or actions means that the one or more programs include instructions that, when executed by data processing apparatus, cause the apparatus to perform the operations or actions.
- the system may identify one or more control flow nodes in the computational graph.
- Each control flow node represents a control flow operation that causes operations represented by one or more other nodes in the computational graph to be conditionally or iteratively performed during execution of the computational graph.
- the system inserts a corresponding backward path control flow node along the backward path through the computational graph.
- Each backward path control flow node adjusts control flow along the backward path to account for the control flow operation represented by the corresponding control flow node.
- the one or more control flow nodes may include a switch control flow node.
- the backward path control flow node corresponding to the switch control flow node is a merge backward control flow node.
- the one or more control flow nodes may include a merge control flow node.
- the backward path control flow node corresponding to the merge control flow node is a switch backward control flow node.
- the one or more control flow nodes may include an enter control flow node.
- the backward path control flow node corresponding to the enter control flow node is an exit backward control flow node.
- the one or more control flow nodes may include an exit control flow node.
- the backward path control flow node corresponding to the exit control flow node is an enter backward control flow node.
- the one or more control flow nodes may include an iteration counter control flow node.
- the backward path control flow node corresponding to the iteration counter control flow node is an iteration counter backward control flow node.
- Multiple iterations of one or more particular operations represented by one or more particular nodes in the computational graph may be performed during execution of the computational graph.
- One or more monitoring nodes may be inserted into the computational graph that represent operations, which, during the execution of the training computational graph, monitor a number of iterations of the particular operations that are performed, and for each performed iteration of each of the particular operations, stores the output of the particular operation represented by the node during the iteration.
- the neural network may be a recurrent neural network that receives a respective neural network input at each of a plurality of time steps and generates a respective neural network at each of the plurality of time steps.
- the operations represented by each of the particular nodes may generate a respective node output for each of the plurality of time steps, and the monitoring nodes may store the respective node outputs for each of the plurality of time steps.
- Storing the output of the particular operation represented by the node during the iteration may include asynchronously sending the data from a device on which it was produced to a central processing unit for storage after the data was produced and asynchronously retrieving the data from the center processing unit for use on the device in the backward path through the computational graph that represents operations for computing the gradients of the objective function with respect to the parameters of the neural network.
- Training the neural network using the machine learning training algorithm by executing the training computational graph may comprise allocating the nodes in the training computational graph across a plurality of devices and causing each of the devices to perform the operations represented by the nodes allocated to the device.
- An example implementation is advantageous because it allows a backward path to be generated from a forward propagation path that includes cyclical control flow constructs.
- An example system obtains data representing the computational graph and augments the computational graph to generate a training computational graph for training the neural network using a machine learning training algorithm that includes computing a gradient of an objective function, e.g., a cost function or a loss function, with respect to each of the parameters of the neural network, e.g., as in stochastic gradient descent.
- an objective function e.g., a cost function or a loss function
- FIG. 1A illustrates an example computational graph system for training neural networks represented as computational graphs.
- FIG. 1B is a conceptual diagram for an exemplary framework for distributing operations and values for neural networks represented as computational graphs in a system.
- FIG. 2 is a flow diagram of an example process for augmenting a computational graph to generate a training computational graph for training a neural network.
- FIG. 3 illustrates an example computational graph that includes forward and backward propagation paths.
- FIG. 4A illustrates an example of control flow operations in a forward propagation of a computational graph.
- FIG. 4B illustrates an example of control flow operations in a backward propagation of a computational graph that correspond to the control flow operations of the forward propagation illustrated in FIG. 4A .
- This specification generally describes a computational graph system that performs operations represented by a computational graph in a distributed manner.
- this specification describes techniques for augmenting a computational graph to generate a training computational graph for training a neural network using a machine learning training algorithm. More particularly, such techniques describe computing a gradient of an objective function with respect to each of the parameters of the neural network when the objective function contains cyclical control flow constructs.
- An example algorithm uses backward propagation of errors, known as backward propagation, in conjunction with an optimization method to compute these gradients. Backward propagation requires differentiation of an objective function, e.g., a cost function or a loss function, with respect to each of the parameters of a neural network that can be complicated when the objective function contains control flow constructs.
- a computational dataflow graph expresses computations of a machine learning model with nodes representing operations and directed edges representing data dependency between operations.
- An incoming edge to a node represents a flow of an input into the node, i.e., an input argument to the operation represented by the node. If all arguments required for an operation are available to the operation node, the node is enabled and can be executed.
- An outgoing edge from a node represents a flow of an output of the operation represented by the node to be used as an input to an operation represented by another node.
- a directed edge connecting a first node in the graph to a second node in the graph indicates that an output generated by the operation represented by the first node is used as an input to the operation represented by the second node.
- a tensor is a multidimensional array of numeric values or other values, e.g., strings, having a specific order that corresponds to the dimensionality of the array.
- a scalar value is a 0th-order tensor
- a vector of numeric values is a 1st-order tensor
- a matrix is a 2nd-order tensor.
- the operations represented in the computational graph are neural network operations or operations for a different kind of machine learning model.
- a neural network is a machine learning model that employs one or more layers of nonlinear units to predict an output for a received input.
- Some neural networks are deep neural networks that include one or more hidden layers in addition to an output layer. The output of each hidden layer is used as input to another layer in the network, i.e., another hidden layer, the output layer, or both.
- Some layers of the network generate an output from a received input in accordance with current values of a respective set of parameters, while other layers of the network may not have parameters.
- the operations represented by the computational graph may be operations necessary for the neural network to compute an inference, i.e., to process an input through the layers of the neural network to generate a neural network output for the input.
- the operations represented by the computational graph may be operations necessary to train the neural network by performing a neural network training procedure to adjust the values of the parameters of the neural network, e.g., to determine trained values of parameters from initial values of the parameters.
- the operations represented by the computational graph can include operations performed by multiple replicas of the neural network.
- a neural network layer that receives an input from a previous layer can use a parameter matrix to perform a matrix multiplication between the parameter matrix and the input.
- this matrix multiplication can be represented as multiple nodes in the computational graph.
- a matrix multiplication can be divided into multiple multiplication and addition operations, and each operation can be represented by a different node in the computational graph.
- the operation represented by each node can generate a respective output, which flows on a directed edge to a subsequent node.
- the result flows, on a directed edge, to another node.
- the result is equivalent to an output of the neural network layer that performs the matrix multiplication.
- the matrix multiplication is represented as one node in the graph.
- the operations represented by the node can receive, as inputs, an input tensor on a first directed edge and a weight tensor, e.g., a parameter matrix, on a second directed edge.
- the node can process, e.g., perform a matrix multiplication of, the input and weight tensors to output, on a third directed edge, an output tensor, which is equivalent to an output of the neural network layer.
- mathematical operations e.g., subtraction, division, and gradient computations
- array operations e.g., concatenate, splice, split, or rank
- neural network building block operations e.g., softmax, Sigmoid, rectified linear unit (ReLU), or convolutions.
- one or more sets of nodes in the computational graph may represent operations that control the dataflow through a computational graph.
- the one or more sets of nodes may, for instance, represent conditional, recursive, and/or iterative control flow statements including: if statements, while loops, do-while loops, for loops, for-each loops, or nested control flow statements that include a combination of these statements.
- Such control flow statements may, for example, be represented by a combination of primitive data flow operations.
- Switch For example, operations that are referenced in this specification as “Switch,” “Merge,” “Enter,” “Exit,” and “Iteration Counter,” may be included in a combination to control conditional, recursive, or iterative execution of a computational graph.
- a “Switch” operation takes in an input value, d, and forwards the input value to one of its outputs depending on the value of a received control value, p.
- the control value is a Boolean value that is either true or false at the time the control computation is executed. That is, a switch switches between providing one of two outputs using the value of the control value it receives.
- a switch operation requires both the input value and the control input value to be present in order to enable the switch for execution.
- a “Merge” operation receives input and forwards values in its input to its output.
- An example merge operation is enabled for execution when the value of any of its inputs is present.
- merge is defined to take an additional control input that controls which input to use, similar to the switch operation.
- values can be uniquely tagged so that preserving order when merging is unnecessary.
- An “Enter” operation represents an entry into a loop or other execution frame that is uniquely identified by a given name. This operation may, for instance, serve to create or find a child frame that is identified by the name.
- An example system can instantiate a new execution frame during runtime when the first “Enter” operation to the frame is executed.
- frames may include instruction templates that are allocated to support execution frames.
- such frames described within this specification may include those which are allocated under any conventional dynamic dataflow machine architecture.
- An “Enter” operation may be used to pass a data structure, such as a tensor, in one execution frame to a child execution frame. There can be multiple “Enter” operations to the same child execution frame, each making a data structure asynchronously available in the child execution frame.
- An “Enter” operation is enabled for execution when its input is available.
- An “Exit” operation represents an exit from a loop or other execution frame. This operation forwards a value from the execution frame to its parent execution frame. This “Exit” operation is used to return computations in a child execution frame back to its parent frame. The operation may return a data structure, such as a tensor, computed in the child execution. There can be multiple “Exit” operations to a parent frame from a child frame, each asynchronously passing a data structure back to the parent frame. An “Exit” operation is enabled when its input is available.
- An “Iteration Counter” operation maintains a counter of the number of iterations of a given loop and increments the counter upon input to the operation. This operation allows different invocations of the same node in a recursive or iterative processes to be uniquely identified.
- the system obtains data representing the computational graph and augments the computational graph to generate a training computational graph for training the neural network using a machine learning training algorithm that includes computing a gradient of an objective function, e.g., a cost function or a loss function, with respect to each of the parameters of the neural network, e.g., as in stochastic gradient descent.
- the system augments the computational graph by inserting gradient nodes and training edges into the computational graph to generate a backward path through the computational graph that represents operations for computing the gradients of the objective function with respect to the parameters of the neural network.
- Each gradient node represents a respective gradient function that computes a gradient of the objective function with respect to parameters flowing along a respective parameter directed edge in the computational graph.
- An example system modifies a backpropagation process to handle the cycles created by executing control flow operations.
- Each control flow operation in the forward propagation path of the computational graph has a corresponding operation in the backward propagation path.
- a “Switch” operation corresponds to a “Iteration Counter” operation followed by a “Merge” operation
- a “Merge” operation corresponds to a “Switch” operation
- an “Enter” operation corresponds to an “Exit” operation
- an “Exit” operation corresponds to an “Enter” operation
- a “Iteration Counter” stays the same.
- the example system automatically rewrites computational graphs containing while loops to record the number of iterations the graph performs and all the “history” tensors that are needed for backward propagation.
- the number of iterations that the forward propagation performs is used to control the number of iterations that the backward propagation performs.
- Representing a neural network as a computational graph provides a flexible and granular way to efficiently implement the neural network, especially if the operations for the neural network are distributed across multiple devices with different hardware profiles.
- FIG. 1A illustrates an example computational graph system 100 for augmenting the computational graph to generate a training computational graph for training the neural network using a machine learning training algorithm that includes computing a gradient of an objective function with respect to each of the parameters of the neural network.
- the system 100 is an example of a system implemented as computer programs on one or more computers in one or more locations, in which the systems, components, and techniques described below can be implemented.
- a user of a client 102 can request operations be performed on a computational graph representing a neural network.
- the client 102 can be an application running on a computer.
- the client 102 provides data identifying a computational graph to the system 100 and specifies types of operations to be performed on the computational graph.
- the request can identify a computational graph representing an inference for a particular neural network and can identify an input on which the inference should be performed.
- the request can identify a computational graph representing a neural network to be trained and an input, such as training data, on which the training should be performed.
- the system 100 in response to receiving the request, can augment the computational graph to generate a training graph. Augmenting the graph is described in more detail below.
- the system 100 performs the operations to generate the particular output by partitioning the operations represented by the computational graph across multiple devices 116 - 122 .
- the system 100 partitions the operations to the multiple devices 116 - 122 over a data communication network 114 , e.g., local area network (LAN) or wide area network (WAN).
- the devices 116 - 122 perform the operations and, if applicable, return a respective output or indication to the system 100 , which can return the requested output or indication to the client 102 .
- any devices performing neural network operations can include a memory, e.g., a random access memory (RAM), for storing instructions and data and a processor for executing stored instructions.
- each device is a hardware resource that performs operations independent of other devices.
- each device can have its own processing unit.
- the devices can be graphical processing units (GPUs) central processing units (CPUs), field programmable gate arrays (FPGAs), application specific integrated circuits (ASICs), or neural network specific processors.
- GPUs graphical processing units
- CPUs central processing units
- FPGAs field programmable gate arrays
- ASICs application specific integrated circuits
- one machine can host one or more devices, e.g., multiple CPUs, GPUs, FPGAs, ASICs, or neural network specific processors. Examples of such devices and machines can be seen in FIG. 1B .
- FIG. 1B is a conceptual diagram for an exemplary framework for distributing operations for neural networks represented as computational graphs in the system 100 .
- examples of machines may include a computing device 126 , personal computer 128 , mobile device 130 , and server 132 .
- Each machine may, for example, include one or more devices, such as GPU 117 and CPU 119 , or FPGAs, ASICs, and neural network specific processors.
- Each device can also have a respective computational capability. That is, devices can have different amount of memories, processing speed, or other architectural characteristics. Thus, some devices can perform operations that other devices cannot. For example, some operations require a certain amount of memory that only particular devices have, or some devices are configured to only perform a particular type of operation, e.g., inference operations.
- a session manager 104 in the system 100 may receive a request from the client 102 to start a session during which operations of the computational graph are performed.
- the session manager 104 manages the set of devices, e.g., devices 116 - 122 , that can perform operations of the computational graph, and can provide a placer 108 with the set of devices that are available to perform operations.
- the placer 108 determines, for each operation to be performed in the computational graph, a respective target device, e.g., device 116 , that performs the operation, and in some implementations, a time for the respective target device to perform the operation.
- a respective target device e.g., device 116
- Some operations can be performed in parallel while other operations require prior operations in the computational graph to be completed, e.g., the other operations process, as inputs, outputs of the prior operations.
- the executor 106 can retrieve the outputs.
- the executor 106 can generate an appropriate response to the request, e.g., an output or an indication that the processing has been completed. Then, the executor 106 can return the response to the client 102 .
- the session manager 104 also provides sets of operations to be performed in the computational graph to the executor 106 .
- the executor 106 periodically retrieves runtime statistics from the devices 116 - 122 related to graph execution of operations.
- the executor 106 provides the runtime statistics to the placer 108 , which can re-optimize placement and scheduling of further operations.
- the system 100 may receive a request from a client 102 to process a computational graph.
- the request can be a request to perform a neural network inference represented by the computational graph on a specified input, a request to perform neural network training operations represented by the computational graph on a specified set of training data, or a request to perform other neural network operations represented by the computational graph, as described above.
- the system 100 may obtain data representing the computational graph.
- the data is sent with the request from the client.
- the request identifies the computational graph and the system 100 retrieves the data representing the identified graph from memory.
- the data representing the graph can be an array of the nodes in the graph. Each node can contain information specifying an operation type, a name, and a list of incoming and outgoing edges to the node.
- the system 100 may then augment the computational graph with nodes and edges to generate a backward propagation that includes operations for the neural network to generate a gradient output for the input.
- the system 100 may identify multiple available devices for performing the requested operation.
- a device may be considered busy if the device is currently performing other operations and cannot be assigned further operations or is otherwise unavailable to perform graph processing operations.
- the device may be considered available if the device can be assigned further operations, e.g., the further operations can be queued for operation by the device.
- the system 100 may partition the computational graph into multiple subgraphs. Each subgraph includes one or more nodes in the computational graph.
- the system 100 may, in some examples, obtain these subgraphs by breaking up pairs of nodes in the computational graph that are adjacent to each other, but are assigned to different devices.
- the system 100 may assign, for each subgraph, the operations represented by the one or more nodes in the subgraph to a respective available device. In some implementations, the system 100 may assign each subgraph to a device having a computational capability necessary to perform the operations represented by the nodes in the subgraph. In some implementations, the request from the client includes data specified by a user that identifies a particular type of device to perform operations for particular nodes.
- the system 100 generates an allocation of the computational graph across multiple devices that assigns each node in the computational graph to a respective device of the multiple devices.
- Each subgraph includes a given group of one or more nodes in the computational graph which, as described above, may be assigned to the same device.
- An exemplary subgraph to device mapping can be seen in FIG. 1B .
- exemplary subgraphs 140 A and 140 B of computational graph 140 may be allocated to GPU 116 and CPU 118 , respectively.
- GPU 116 and CPU 118 may reside in a different or a same one of machines 126 - 132 .
- GPU 116 and CPU 118 may perform the operations represented by the nodes included in the subgraph that the system 100 has assigned to them.
- computational graphs may also be allocated to FPGAs, ASICs, or neural network specific processors.
- the system 100 may cause the devices to perform the operations of the nodes included in the subgraphs respectively assigned to the devices.
- the system 100 may send each device a request to start the operations of the nodes included in the subgraph assigned to the respective device.
- each device may proceed to perform the operations of the nodes included in the subgraph assigned to the device.
- FIG. 2 is a flow diagram of an example process 200 for augmenting a computational graph to generate a training computational graph for training a neural network.
- the process 200 will be described as being performed by a system of one or more computers, located in one or more locations, and programmed appropriately in accordance with this specification.
- an example computational graph system 100 of FIG. 1A appropriately programmed, can perform the process 200 .
- the system obtains data representing a computational graph comprising nodes and directed edges ( 202 ).
- the system augments the computational graph to generate a training computational graph for training the neural network using a machine learning algorithm that includes computing a gradient of an objective function with respect to each parameter of the neural network ( 204 ).
- the system inserts a plurality of gradient nodes and training edges into the computational graph to generate a backward path through the computational graph that represents operations for computing the gradients of the objective function with respect to the parameters of the neural network.
- Each gradient node represents a gradient function that computes a gradient of the objective function with respect to parameters flowing along a respective parameter directed edge in the computational graph.
- the system augments the graph by inserting operations in a backward propagation path that are differentiated operations corresponding to the operations in the forward propagation path.
- the system begins a backward propagation path with the last operation node in the forward path.
- the system then adds the differentiated operations of the forward propagation path in reverse order to the backward propagation path until the system reaches the first node of the forward propagation path. For example, if a forward propagation path includes operations A, B, and C, the backward propagation will include C′, B′, and finally A′.
- the system 100 may identify one or more control flow nodes in the computational graph.
- Each control flow node represents a control flow operation that causes operations represented by one or more other nodes in the computational graph to be conditionally or iteratively performed during execution of the computational graph.
- the system 100 inserts a corresponding backward path control flow node along the backward path through the computational graph.
- the backward path control flow node is the differentiation of the corresponding forward path control flow node.
- Each control flow operation in the forward propagation path of the computational graph has a corresponding operation in the backward propagation path.
- the system inserts a corresponding “Merge” operation in the backward propagation. If the system encounters a “Merge” operation, the system inserts a corresponding “Switch” operation in the backward path. The system inserts “Exit” operations when it finds “Enter” operations in the forward propagation path and “Enter” operations” when it finds “Exit” operations in the forward propagation path. When the system encounters an “Iteration Counter” operation, the system just inserts an “Iteration Counter” operation in the backward propagation path.
- Each backward path control flow node adjusts control flow along the backward path to account for the control flow operation represented by the corresponding control flow node.
- the system then trains the neural network using the machine learning training algorithm by executing the training computational graph ( 206 ).
- FIG. 3 illustrates an example computational graph that includes a forward propagation path 300 and backward propagation path 301 .
- computation of a neural network is expressed as a data flow graph.
- An example system generates a forward propagation path 300 that includes the operations necessary for the neural network to compute an inference, i.e., to process an input through the layers of the neural network to generate a neural network output for the input.
- An example system then augments the computational graph with a backward propagation path 301 that includes the operations necessary for the neural network to generate a gradient output for the input.
- the output of the backward propagation is a gradient of an objective function, e.g., a cost function or a loss function, with respect to each of the parameters of the neural network.
- an example system automatically differentiates each node in the forward propagation of the computational graph, A-D.
- an operation in the backward propagation requires a value from the corresponding forward operation in order to execute.
- an operation in the forward propagation, B may compute the square of a number such as x 2 , where x is a number to be squared. The differentiation of this operation is a 2 ⁇ operation, which is added to the back propagation operations as B′. In order to compute the value of 2 ⁇ , the number x should be given to B′ in the backward propagation.
- FIG. 3 illustrates providing an edge 302 between B and B′ that sends the value needed from the forward propagation to the backward propagation.
- FIG. 4A illustrates an example of control flow operations in a forward propagation of a computational graph.
- This example represents the conditional computation: if p(x) then f (x) else g(x).
- G(p) 402 , G(f) 404 , and G(g) 406 denote graphs for p, f, and g, respectively.
- P(x) is the control computation that results in either a true or false output at the time of execution.
- the conditional computation is represented in the computational dataflow graph by a “Switch” operation 408 and a “Merge” operation 410 .
- the conditional computation first calculates the value of a control computation, G(p) 402 .
- the value of the control computation is input into the “Switch” operation 408 along with an input value. If the value of the control computation is true, the “Switch” operation 408 sends its input value to its output corresponding to the true value. If the value of the control computation is false, the “Switch” operation 408 sends its input value to its output corresponding to the false value.
- the example computational dataflow graph enables the subgraph, G(f) 404 , or G(g) 406 depending on where the output of the “Switch” operation 408 is located, either the output representing the true branch or the output representing the false branch.
- the enabled operation is performed and merged by the “Merge” operation 410 .
- the “Merge” operation 410 is essentially a placeholder for naming the output of a conditional.
- FIG. 4B illustrates an example of control flow operations in a backward propagation of a computational graph that correspond to the control flow operations of the forward propagation illustrated in FIG. 4A .
- the example system encounters a “Switch” operation in the forward propagation 408 , the system adds the corresponding operation to the backward propagation.
- a “Switch” operation 408 corresponds to a “Merge” operation 412 , which is then added to the backward propagation.
- the system adds the corresponding operation, a “Switch” operation 414 to the backward propagation.
- the system also adds the differentiation operations for all operations in the forward propagation path.
- the system in addition to inserting a “Merge” operation 412 corresponding to the “Switch” operation 408 of the forward propagation path and a “Switch” operation 414 corresponding to the “Merge” operation 410 , the system also inserts differentiation operations corresponding to every operation in the forward propagation path.
- the system inserts, into the backward propagation path G′(g) 416 corresponding to G(g) 406 , and G′(f) 418 corresponding to G(f) 404 .
- the system uses the same Boolean-value, control computation, G(p) 402 in the backward propagation path as the forward.
- the system determines that multiple iterations of one or more particular operations represented by one or more particular nodes in the computational graph are performed during execution of the computational graph.
- the system can analyze the computational graph to identify one or more control flow nodes in the computational graph that cause the particular operations represented by the one or more particular nodes in the computational graph to be performed multiple times.
- the neural network may be a recurrent neural network that receives a respective neural network input at each of multiple time steps and generates a respective neural network at each of the multiple time steps.
- the system then inserts one or more monitoring nodes into the computational graph.
- the monitoring nodes represent operations that, during the execution of the training computational graph, monitor a number of iterations of the particular operations that are performed, and for each performed iteration of each of the particular operations, stores the output of the particular operation represented by the node during the iteration for use in the gradient computations during the backward path.
- the operations represented by each of the particular nodes generate a respective node output for each of the time steps
- the monitoring nodes store the respective node outputs for each of the time steps, i.e., so that the outputs of the operations of the particular nodes for all of the time steps are available when the backward pass begins after the neural network output for the last time step is computed.
- the example system detects, during the construction of the backpropagation path, the forward values that are needed in the backpropagation.
- the system For each forward value, the system introduces a stack and adds nodes, such as “Iteration Counter” operations, in the forward propagation path to save the forward values at each iteration to the stack.
- nodes such as “Iteration Counter” operations
- the backpropagation path uses these values from the stack in reverse order.
- respective nodes outputs may be produced on a device, such as a GPU, with limited memory. Storing respective node outputs for each time step may lead to numerous values being stored on a stack, reducing the amount of device memory available for other things. Furthermore, old values are stored the longest since backpropagation uses values in reverse order of the forward propagation.
- an example system may swap memory from the device to another device, such as a CPU. This swapping may be asynchronous with the system sending a value from the device to the CPU sometime after the value is produced and the system retrieving the value back into the device sometime before it is needed. The system obtains values as they are needed based on the operational order and control defined in the dataflow graph.
- Generated computational graphs representing forward and backward propagation paths can be allocated to multiple devices for processing in numerous ways including allocation detailed in U.S. patent application Ser. No. 15/337,744, entitled PROCESSING COMPUTATIONAL GRAPHS, which was filed on Oct. 28, 2016, and which is incorporated here by reference.
- Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, in tangibly-embodied computer software or firmware, in computer hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them.
- Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions encoded on a tangible non transitory program carrier for execution by, or to control the operation of, data processing apparatus.
- the program instructions can be encoded on an artificially generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus.
- the computer storage medium can be a machine-readable storage device, a machine-readable storage substrate, a random or serial access memory device, or a combination of one or more of them. The computer storage medium is not, however, a propagated signal.
- data processing apparatus encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers.
- the apparatus can include special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit).
- the apparatus can also include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them.
- a computer program (which may also be referred to or described as a program, software, a software application, a module, a software module, a script, or code) can be written in any form of programming language, including compiled or interpreted languages, or declarative or procedural languages, and it can be deployed in any form, including as a stand alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment.
- a computer program may, but need not, correspond to a file in a file system.
- a program can be stored in a portion of a file that holds other programs or data, e.g., one or more scripts stored in a markup language document, in a single file dedicated to the program in question, or in multiple coordinated files, e.g., files that store one or more modules, sub programs, or portions of code.
- a computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
- an “engine,” or “software engine,” refers to a software implemented input/output system that provides an output that is different from the input.
- An engine can be an encoded block of functionality, such as a library, a platform, a software development kit (“SDK”), or an object.
- SDK software development kit
- Each engine can be implemented on any appropriate type of computing device, e.g., servers, mobile phones, tablet computers, notebook computers, music players, e-book readers, laptop or desktop computers, PDAs, smart phones, or other stationary or portable devices, that includes one or more processors and computer readable media. Additionally, two or more of the engines may be implemented on the same computing device, or on different computing devices.
- the processes and logic flows described in this specification can be performed by one or more programmable computers executing one or more computer programs to perform functions by operating on input data and generating output.
- the processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit).
- special purpose logic circuitry e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit).
- Computers suitable for the execution of a computer program include, by way of example, can be based on general or special purpose microprocessors or both, or any other kind of central processing unit.
- a central processing unit will receive instructions and data from a read only memory or a random access memory or both.
- the essential elements of a computer are a central processing unit for performing or executing instructions and one or more memory devices for storing instructions and data.
- a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks.
- mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks.
- a computer need not have such devices.
- a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device, e.g., a universal serial bus (USB) flash drive, to name just a few.
- PDA personal digital assistant
- GPS Global Positioning System
- USB universal serial bus
- Computer readable media suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto optical disks; and CD ROM and DVD-ROM disks.
- semiconductor memory devices e.g., EPROM, EEPROM, and flash memory devices
- magnetic disks e.g., internal hard disks or removable disks
- magneto optical disks e.g., CD ROM and DVD-ROM disks.
- the processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
- a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer.
- a display device e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor
- keyboard and a pointing device e.g., a mouse or a trackball
- Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.
- a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a
- Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back end, middleware, or front end components.
- the components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), e.g., the Internet.
- LAN local area network
- WAN wide area network
- the computing system can include clients and servers.
- a client and server are generally remote from each other and typically interact through a communication network.
- the relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
Abstract
Systems and Methods for training a neural network represented as a computational graph are disclosed. An example method begins with obtaining data representing a computational graph. The computational graph is then augmented to generate a training computational graph for training the neural network using a machine learning training algorithm that includes computing a gradient of an objective function with respect to each of the parameters of the neural network. Augmenting the computational graph includes inserting a plurality of gradient nodes and training edges into the computational graph to generate a backward path through the computational graph that represents operations for computing the gradients of the objective function with respect to the parameters of the neural network. The neural network is trained using the machine learning training algorithm by executing the training computational graph.
Description
- This application is a continuation of U.S. application Ser. No. 15/347,618 filed on Nov. 9, 2016, which claims the benefit of U.S. Provisional Patent Application No. 62/253,057 filed on Nov. 9, 2015, each of which are incorporated by reference herein.
- This specification relates to processing computational graphs representing neural networks.
- Neural networks are machine learning models that employ one or more layers of models to generate an output, e.g., one or more classifications, for a received input. Some neural networks include one or more hidden layers in addition to an output layer. The output of each hidden layer is used as input to the next layer in the network, i.e., the next hidden layer or the output layer of the network. Each layer of the network generates an output from a received input in accordance with current values of a respective set of parameters for the layer.
- In some existing systems, the layers of a neural network are processed by an individual device. The device can have a processor that performs operations, e.g., generating outputs at a layer from inputs, and stores outputs from the operations in memory. Due to the large number and size of operations generally required to generate the outputs in the neural network, one device can take a significant amount of time to process the layers of the neural network.
- This specification describes a system implemented as computer programs on one or more computers in one or more locations that trains a neural network represented by a computational graph.
- The computational graph includes nodes, connector directed edges, and parameter directed edges. Each node represents a respective operation performed by the neural network as part of determining a neural network output from a neural network input, each connector directed edge connects a respective first node to a respective second node that represents an operation that receives, as input, an output of an operation represented by the respective first node, and each parameter directed edge connects into a respective node and represents a flow of one or more parameters of the neural network as input to the operation represented by the respective node.
- In general, one innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of obtaining data representing the computational graph; augmenting the computational graph to generate a training computational graph for training the neural network using a machine learning training algorithm that includes computing a gradient of an objective function with respect to each of the parameters of the neural network, comprising: inserting a plurality of gradient nodes and training edges into the computational graph to generate a backward path through the computational graph that represents operations for computing the gradients of the objective function with respect to parameters flowing along a respective parameter directed edge in the computational graph; and training the neural network using the machine learning training algorithm by executing the training computational graph.
- The system trains the neural network using the machine learning training algorithm by executing the training computational graph. In particular, the system may, as part of augmenting the computational graph, generate multiple instances of the computational graph that includes the backward path to generate a final training computational graph. The system may then allocate the nodes in the final training computational graph across a plurality of devices; and cause each of the devices to perform the operations represented by the nodes allocated to the device. Processing a computational graph in a distributed manner is described in more detail in U.S. patent application Ser. No. 15/337,744, entitled PROCESSING COMPUTATIONAL GRAPHS, filed on Oct. 28, 2016, and U.S. patent application Ser. No. 15/338,225, entitled MODIFYING COMPUTATIONAL GRAPHS, filed on Oct. 28, 2016, the contents of each which are hereby incorporated by reference herein in their entirety.
- Other embodiments of this aspect include corresponding computer systems, apparatus, and computer programs recorded on one or more computer storage devices, each configured to perform the actions of the methods. For a system of one or more computers to be configure to perform particular operations or actions means that the system has installed on it software, firmware, hardware, or a combination of them that in operation cause the system to perform the operations or actions. For one or more computer programs to be configured to perform particular operations or actions means that the one or more programs include instructions that, when executed by data processing apparatus, cause the apparatus to perform the operations or actions.
- The foregoing and other embodiments can each optionally include one or more of the following features, alone or in combination. In particular, one embodiment includes all the following features in combination. As part of augmenting the computational graph, the system may identify one or more control flow nodes in the computational graph. Each control flow node represents a control flow operation that causes operations represented by one or more other nodes in the computational graph to be conditionally or iteratively performed during execution of the computational graph. For each identified control flow node, the system inserts a corresponding backward path control flow node along the backward path through the computational graph. Each backward path control flow node adjusts control flow along the backward path to account for the control flow operation represented by the corresponding control flow node.
- For example, the one or more control flow nodes may include a switch control flow node. In this case, the backward path control flow node corresponding to the switch control flow node is a merge backward control flow node.
- For example, the one or more control flow nodes may include a merge control flow node. In this case, the backward path control flow node corresponding to the merge control flow node is a switch backward control flow node.
- For example, the one or more control flow nodes may include an enter control flow node. In this case, the backward path control flow node corresponding to the enter control flow node is an exit backward control flow node.
- For example, the one or more control flow nodes may include an exit control flow node. In this case, the backward path control flow node corresponding to the exit control flow node is an enter backward control flow node.
- For example, the one or more control flow nodes may include an iteration counter control flow node. In this case, the backward path control flow node corresponding to the iteration counter control flow node is an iteration counter backward control flow node. Multiple iterations of one or more particular operations represented by one or more particular nodes in the computational graph may be performed during execution of the computational graph. One or more monitoring nodes may be inserted into the computational graph that represent operations, which, during the execution of the training computational graph, monitor a number of iterations of the particular operations that are performed, and for each performed iteration of each of the particular operations, stores the output of the particular operation represented by the node during the iteration. During execution of the backward path in the training computational graph, outputs stored by the one or more monitoring nodes may be provided as input to the gradient functions represented by one or more of the gradient nodes. Determining that multiple iterations of one or more particular operations represented by one or more particular nodes in the computational graph are performed during execution of the computational graph may comprise analyzing the computational graph to identify one or more control flow nodes in the computational graph that cause the particular operations represented by the one or more particular nodes in the computational graph to be performed multiple times. The neural network may be a recurrent neural network that receives a respective neural network input at each of a plurality of time steps and generates a respective neural network at each of the plurality of time steps. The operations represented by each of the particular nodes may generate a respective node output for each of the plurality of time steps, and the monitoring nodes may store the respective node outputs for each of the plurality of time steps. Storing the output of the particular operation represented by the node during the iteration may include asynchronously sending the data from a device on which it was produced to a central processing unit for storage after the data was produced and asynchronously retrieving the data from the center processing unit for use on the device in the backward path through the computational graph that represents operations for computing the gradients of the objective function with respect to the parameters of the neural network. Training the neural network using the machine learning training algorithm by executing the training computational graph may comprise allocating the nodes in the training computational graph across a plurality of devices and causing each of the devices to perform the operations represented by the nodes allocated to the device.
- The subject matter described in this specification can be implemented in particular embodiments so as to realize one or more of the following advantages. An example implementation is advantageous because it allows a backward path to be generated from a forward propagation path that includes cyclical control flow constructs. An example system obtains data representing the computational graph and augments the computational graph to generate a training computational graph for training the neural network using a machine learning training algorithm that includes computing a gradient of an objective function, e.g., a cost function or a loss function, with respect to each of the parameters of the neural network, e.g., as in stochastic gradient descent.
- The details of one or more embodiments of the subject matter of this specification are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the subject matter will become apparent from the description, the drawings, and the claims.
-
FIG. 1A illustrates an example computational graph system for training neural networks represented as computational graphs. -
FIG. 1B is a conceptual diagram for an exemplary framework for distributing operations and values for neural networks represented as computational graphs in a system. -
FIG. 2 is a flow diagram of an example process for augmenting a computational graph to generate a training computational graph for training a neural network. -
FIG. 3 illustrates an example computational graph that includes forward and backward propagation paths. -
FIG. 4A illustrates an example of control flow operations in a forward propagation of a computational graph. -
FIG. 4B illustrates an example of control flow operations in a backward propagation of a computational graph that correspond to the control flow operations of the forward propagation illustrated inFIG. 4A . - Like reference numbers and designations in the various drawings indicate like elements.
- This specification generally describes a computational graph system that performs operations represented by a computational graph in a distributed manner. Particularly, this specification describes techniques for augmenting a computational graph to generate a training computational graph for training a neural network using a machine learning training algorithm. More particularly, such techniques describe computing a gradient of an objective function with respect to each of the parameters of the neural network when the objective function contains cyclical control flow constructs. An example algorithm uses backward propagation of errors, known as backward propagation, in conjunction with an optimization method to compute these gradients. Backward propagation requires differentiation of an objective function, e.g., a cost function or a loss function, with respect to each of the parameters of a neural network that can be complicated when the objective function contains control flow constructs.
- A computational dataflow graph expresses computations of a machine learning model with nodes representing operations and directed edges representing data dependency between operations. An incoming edge to a node represents a flow of an input into the node, i.e., an input argument to the operation represented by the node. If all arguments required for an operation are available to the operation node, the node is enabled and can be executed.
- An outgoing edge from a node represents a flow of an output of the operation represented by the node to be used as an input to an operation represented by another node. Thus, a directed edge connecting a first node in the graph to a second node in the graph indicates that an output generated by the operation represented by the first node is used as an input to the operation represented by the second node.
- Generally, the input and outputs flowing along directed edges in the computational graph are tensors. A tensor is a multidimensional array of numeric values or other values, e.g., strings, having a specific order that corresponds to the dimensionality of the array. For example, a scalar value is a 0th-order tensor, a vector of numeric values is a 1st-order tensor, and a matrix is a 2nd-order tensor.
- In some implementations, the operations represented in the computational graph are neural network operations or operations for a different kind of machine learning model. A neural network is a machine learning model that employs one or more layers of nonlinear units to predict an output for a received input. Some neural networks are deep neural networks that include one or more hidden layers in addition to an output layer. The output of each hidden layer is used as input to another layer in the network, i.e., another hidden layer, the output layer, or both. Some layers of the network generate an output from a received input in accordance with current values of a respective set of parameters, while other layers of the network may not have parameters.
- For example, the operations represented by the computational graph may be operations necessary for the neural network to compute an inference, i.e., to process an input through the layers of the neural network to generate a neural network output for the input. As another example, the operations represented by the computational graph may be operations necessary to train the neural network by performing a neural network training procedure to adjust the values of the parameters of the neural network, e.g., to determine trained values of parameters from initial values of the parameters. In some cases, e.g., during training of the neural network, the operations represented by the computational graph can include operations performed by multiple replicas of the neural network.
- By way of illustration, a neural network layer that receives an input from a previous layer can use a parameter matrix to perform a matrix multiplication between the parameter matrix and the input. In some cases, this matrix multiplication can be represented as multiple nodes in the computational graph. For example, a matrix multiplication can be divided into multiple multiplication and addition operations, and each operation can be represented by a different node in the computational graph. The operation represented by each node can generate a respective output, which flows on a directed edge to a subsequent node. After the operation represented by a final node generates a result of the matrix multiplication, the result flows, on a directed edge, to another node. The result is equivalent to an output of the neural network layer that performs the matrix multiplication.
- In some other cases, the matrix multiplication is represented as one node in the graph. The operations represented by the node can receive, as inputs, an input tensor on a first directed edge and a weight tensor, e.g., a parameter matrix, on a second directed edge. The node can process, e.g., perform a matrix multiplication of, the input and weight tensors to output, on a third directed edge, an output tensor, which is equivalent to an output of the neural network layer.
- Other neural network operations that may be represented by nodes in the computational graph include other mathematical operations, e.g., subtraction, division, and gradient computations; array operations, e.g., concatenate, splice, split, or rank; and neural network building block operations, e.g., softmax, Sigmoid, rectified linear unit (ReLU), or convolutions.
- In an example system, one or more sets of nodes in the computational graph may represent operations that control the dataflow through a computational graph. The one or more sets of nodes may, for instance, represent conditional, recursive, and/or iterative control flow statements including: if statements, while loops, do-while loops, for loops, for-each loops, or nested control flow statements that include a combination of these statements. Such control flow statements may, for example, be represented by a combination of primitive data flow operations.
- For example, operations that are referenced in this specification as “Switch,” “Merge,” “Enter,” “Exit,” and “Iteration Counter,” may be included in a combination to control conditional, recursive, or iterative execution of a computational graph.
- A “Switch” operation takes in an input value, d, and forwards the input value to one of its outputs depending on the value of a received control value, p. The control value is a Boolean value that is either true or false at the time the control computation is executed. That is, a switch switches between providing one of two outputs using the value of the control value it receives. A switch operation requires both the input value and the control input value to be present in order to enable the switch for execution.
- A “Merge” operation receives input and forwards values in its input to its output. An example merge operation is enabled for execution when the value of any of its inputs is present. Typically, merge is defined to take an additional control input that controls which input to use, similar to the switch operation. However, in an example system, values can be uniquely tagged so that preserving order when merging is unnecessary.
- An “Enter” operation represents an entry into a loop or other execution frame that is uniquely identified by a given name. This operation may, for instance, serve to create or find a child frame that is identified by the name. An example system can instantiate a new execution frame during runtime when the first “Enter” operation to the frame is executed. In this context, frames may include instruction templates that are allocated to support execution frames. In some examples, such frames described within this specification may include those which are allocated under any conventional dynamic dataflow machine architecture. An “Enter” operation may be used to pass a data structure, such as a tensor, in one execution frame to a child execution frame. There can be multiple “Enter” operations to the same child execution frame, each making a data structure asynchronously available in the child execution frame. An “Enter” operation is enabled for execution when its input is available.
- An “Exit” operation represents an exit from a loop or other execution frame. This operation forwards a value from the execution frame to its parent execution frame. This “Exit” operation is used to return computations in a child execution frame back to its parent frame. The operation may return a data structure, such as a tensor, computed in the child execution. There can be multiple “Exit” operations to a parent frame from a child frame, each asynchronously passing a data structure back to the parent frame. An “Exit” operation is enabled when its input is available.
- An “Iteration Counter” operation maintains a counter of the number of iterations of a given loop and increments the counter upon input to the operation. This operation allows different invocations of the same node in a recursive or iterative processes to be uniquely identified.
- To train the neural network, the system obtains data representing the computational graph and augments the computational graph to generate a training computational graph for training the neural network using a machine learning training algorithm that includes computing a gradient of an objective function, e.g., a cost function or a loss function, with respect to each of the parameters of the neural network, e.g., as in stochastic gradient descent. In particular, the system augments the computational graph by inserting gradient nodes and training edges into the computational graph to generate a backward path through the computational graph that represents operations for computing the gradients of the objective function with respect to the parameters of the neural network. Each gradient node represents a respective gradient function that computes a gradient of the objective function with respect to parameters flowing along a respective parameter directed edge in the computational graph.
- An example system modifies a backpropagation process to handle the cycles created by executing control flow operations. Each control flow operation in the forward propagation path of the computational graph has a corresponding operation in the backward propagation path. For example, a “Switch” operation corresponds to a “Iteration Counter” operation followed by a “Merge” operation, a “Merge” operation corresponds to a “Switch” operation, an “Enter” operation corresponds to an “Exit” operation, an “Exit” operation corresponds to an “Enter” operation, and a “Iteration Counter” stays the same. To handle while loops, the example system automatically rewrites computational graphs containing while loops to record the number of iterations the graph performs and all the “history” tensors that are needed for backward propagation. The number of iterations that the forward propagation performs is used to control the number of iterations that the backward propagation performs.
- Representing a neural network as a computational graph provides a flexible and granular way to efficiently implement the neural network, especially if the operations for the neural network are distributed across multiple devices with different hardware profiles.
-
FIG. 1A illustrates an examplecomputational graph system 100 for augmenting the computational graph to generate a training computational graph for training the neural network using a machine learning training algorithm that includes computing a gradient of an objective function with respect to each of the parameters of the neural network. Thesystem 100 is an example of a system implemented as computer programs on one or more computers in one or more locations, in which the systems, components, and techniques described below can be implemented. - A user of a
client 102 can request operations be performed on a computational graph representing a neural network. Theclient 102 can be an application running on a computer. - As part of the request, the
client 102 provides data identifying a computational graph to thesystem 100 and specifies types of operations to be performed on the computational graph. - For example, the request can identify a computational graph representing an inference for a particular neural network and can identify an input on which the inference should be performed.
- As another example, the request can identify a computational graph representing a neural network to be trained and an input, such as training data, on which the training should be performed.
- In this example, in response to receiving the request, the
system 100 can augment the computational graph to generate a training graph. Augmenting the graph is described in more detail below. - The
system 100 performs the operations to generate the particular output by partitioning the operations represented by the computational graph across multiple devices 116-122. Thesystem 100 partitions the operations to the multiple devices 116-122 over adata communication network 114, e.g., local area network (LAN) or wide area network (WAN). The devices 116-122 perform the operations and, if applicable, return a respective output or indication to thesystem 100, which can return the requested output or indication to theclient 102. - Any devices performing neural network operations, e.g., devices 116-122, can include a memory, e.g., a random access memory (RAM), for storing instructions and data and a processor for executing stored instructions. Generally, each device is a hardware resource that performs operations independent of other devices. For example, each device can have its own processing unit. The devices can be graphical processing units (GPUs) central processing units (CPUs), field programmable gate arrays (FPGAs), application specific integrated circuits (ASICs), or neural network specific processors. By way of illustration, one machine can host one or more devices, e.g., multiple CPUs, GPUs, FPGAs, ASICs, or neural network specific processors. Examples of such devices and machines can be seen in
FIG. 1B . -
FIG. 1B is a conceptual diagram for an exemplary framework for distributing operations for neural networks represented as computational graphs in thesystem 100. Referring now toFIG. 1B , examples of machines may include acomputing device 126,personal computer 128,mobile device 130, andserver 132. Each machine may, for example, include one or more devices, such as GPU 117 and CPU 119, or FPGAs, ASICs, and neural network specific processors. - Each device can also have a respective computational capability. That is, devices can have different amount of memories, processing speed, or other architectural characteristics. Thus, some devices can perform operations that other devices cannot. For example, some operations require a certain amount of memory that only particular devices have, or some devices are configured to only perform a particular type of operation, e.g., inference operations.
- Referring again to
FIG. 1A , asession manager 104 in thesystem 100 may receive a request from theclient 102 to start a session during which operations of the computational graph are performed. Thesession manager 104 manages the set of devices, e.g., devices 116-122, that can perform operations of the computational graph, and can provide aplacer 108 with the set of devices that are available to perform operations. - The
placer 108 determines, for each operation to be performed in the computational graph, a respective target device, e.g.,device 116, that performs the operation, and in some implementations, a time for the respective target device to perform the operation. Some operations can be performed in parallel while other operations require prior operations in the computational graph to be completed, e.g., the other operations process, as inputs, outputs of the prior operations. - After the devices perform the operations allocated by the
placer 108 to generate outputs, theexecutor 106 can retrieve the outputs. Theexecutor 106 can generate an appropriate response to the request, e.g., an output or an indication that the processing has been completed. Then, theexecutor 106 can return the response to theclient 102. - The
session manager 104 also provides sets of operations to be performed in the computational graph to theexecutor 106. Theexecutor 106 periodically retrieves runtime statistics from the devices 116-122 related to graph execution of operations. Theexecutor 106 provides the runtime statistics to theplacer 108, which can re-optimize placement and scheduling of further operations. - In operation, the
system 100 may receive a request from aclient 102 to process a computational graph. For example, the request can be a request to perform a neural network inference represented by the computational graph on a specified input, a request to perform neural network training operations represented by the computational graph on a specified set of training data, or a request to perform other neural network operations represented by the computational graph, as described above. - Upon receipt of the request, the
system 100 may obtain data representing the computational graph. In some cases, the data is sent with the request from the client. In other cases, the request identifies the computational graph and thesystem 100 retrieves the data representing the identified graph from memory. By way of illustration, the data representing the graph can be an array of the nodes in the graph. Each node can contain information specifying an operation type, a name, and a list of incoming and outgoing edges to the node. - The
system 100 may then augment the computational graph with nodes and edges to generate a backward propagation that includes operations for the neural network to generate a gradient output for the input. - The
system 100 may identify multiple available devices for performing the requested operation. A device may be considered busy if the device is currently performing other operations and cannot be assigned further operations or is otherwise unavailable to perform graph processing operations. The device may be considered available if the device can be assigned further operations, e.g., the further operations can be queued for operation by the device. - The
system 100 may partition the computational graph into multiple subgraphs. Each subgraph includes one or more nodes in the computational graph. Thesystem 100 may, in some examples, obtain these subgraphs by breaking up pairs of nodes in the computational graph that are adjacent to each other, but are assigned to different devices. - The
system 100 may assign, for each subgraph, the operations represented by the one or more nodes in the subgraph to a respective available device. In some implementations, thesystem 100 may assign each subgraph to a device having a computational capability necessary to perform the operations represented by the nodes in the subgraph. In some implementations, the request from the client includes data specified by a user that identifies a particular type of device to perform operations for particular nodes. - Thus, the
system 100 generates an allocation of the computational graph across multiple devices that assigns each node in the computational graph to a respective device of the multiple devices. Each subgraph includes a given group of one or more nodes in the computational graph which, as described above, may be assigned to the same device. An exemplary subgraph to device mapping can be seen inFIG. 1B . In this example,exemplary subgraphs computational graph 140 may be allocated toGPU 116 andCPU 118, respectively.GPU 116 andCPU 118 may reside in a different or a same one of machines 126-132. In operation,GPU 116 andCPU 118 may perform the operations represented by the nodes included in the subgraph that thesystem 100 has assigned to them. As described above, computational graphs may also be allocated to FPGAs, ASICs, or neural network specific processors. - The
system 100 may cause the devices to perform the operations of the nodes included in the subgraphs respectively assigned to the devices. In some implementations, thesystem 100 may send each device a request to start the operations of the nodes included in the subgraph assigned to the respective device. In response to receiving such a request from thesystem 100, each device may proceed to perform the operations of the nodes included in the subgraph assigned to the device. -
FIG. 2 is a flow diagram of anexample process 200 for augmenting a computational graph to generate a training computational graph for training a neural network. For convenience, theprocess 200 will be described as being performed by a system of one or more computers, located in one or more locations, and programmed appropriately in accordance with this specification. For example, an examplecomputational graph system 100 ofFIG. 1A , appropriately programmed, can perform theprocess 200. - The system obtains data representing a computational graph comprising nodes and directed edges (202).
- The system augments the computational graph to generate a training computational graph for training the neural network using a machine learning algorithm that includes computing a gradient of an objective function with respect to each parameter of the neural network (204).
- To augment the computational graph, the system inserts a plurality of gradient nodes and training edges into the computational graph to generate a backward path through the computational graph that represents operations for computing the gradients of the objective function with respect to the parameters of the neural network. Each gradient node represents a gradient function that computes a gradient of the objective function with respect to parameters flowing along a respective parameter directed edge in the computational graph.
- In particular, the system augments the graph by inserting operations in a backward propagation path that are differentiated operations corresponding to the operations in the forward propagation path. The system begins a backward propagation path with the last operation node in the forward path. The system then adds the differentiated operations of the forward propagation path in reverse order to the backward propagation path until the system reaches the first node of the forward propagation path. For example, if a forward propagation path includes operations A, B, and C, the backward propagation will include C′, B′, and finally A′.
- As part of augmenting the computational graph, the
system 100 may identify one or more control flow nodes in the computational graph. Each control flow node represents a control flow operation that causes operations represented by one or more other nodes in the computational graph to be conditionally or iteratively performed during execution of the computational graph. For each identified control flow node, thesystem 100 inserts a corresponding backward path control flow node along the backward path through the computational graph. As described above, the backward path control flow node is the differentiation of the corresponding forward path control flow node. Each control flow operation in the forward propagation path of the computational graph has a corresponding operation in the backward propagation path. If the example system encounters a “Switch” operation in the forward propagation of the computational graph, the system inserts a corresponding “Merge” operation in the backward propagation. If the system encounters a “Merge” operation, the system inserts a corresponding “Switch” operation in the backward path. The system inserts “Exit” operations when it finds “Enter” operations in the forward propagation path and “Enter” operations” when it finds “Exit” operations in the forward propagation path. When the system encounters an “Iteration Counter” operation, the system just inserts an “Iteration Counter” operation in the backward propagation path. - Each backward path control flow node adjusts control flow along the backward path to account for the control flow operation represented by the corresponding control flow node.
- The system then trains the neural network using the machine learning training algorithm by executing the training computational graph (206).
-
FIG. 3 illustrates an example computational graph that includes aforward propagation path 300 and backward propagation path 301. As described, computation of a neural network is expressed as a data flow graph. An example system generates aforward propagation path 300 that includes the operations necessary for the neural network to compute an inference, i.e., to process an input through the layers of the neural network to generate a neural network output for the input. An example system then augments the computational graph with a backward propagation path 301 that includes the operations necessary for the neural network to generate a gradient output for the input. The output of the backward propagation is a gradient of an objective function, e.g., a cost function or a loss function, with respect to each of the parameters of the neural network. To generate a backward propagation 301 from theforward propagation 300, an example system automatically differentiates each node in the forward propagation of the computational graph, A-D. - In some instances, an operation in the backward propagation requires a value from the corresponding forward operation in order to execute. For example, an operation in the forward propagation, B, may compute the square of a number such as x2, where x is a number to be squared. The differentiation of this operation is a 2× operation, which is added to the back propagation operations as B′. In order to compute the value of 2×, the number x should be given to B′ in the backward propagation.
FIG. 3 illustrates providing an edge 302 between B and B′ that sends the value needed from the forward propagation to the backward propagation. -
FIG. 4A illustrates an example of control flow operations in a forward propagation of a computational graph. This example represents the conditional computation: if p(x) then f (x) else g(x). In this example, G(p) 402, G(f) 404, and G(g) 406 denote graphs for p, f, and g, respectively. P(x) is the control computation that results in either a true or false output at the time of execution. - The conditional computation is represented in the computational dataflow graph by a “Switch” operation 408 and a “Merge” operation 410. The conditional computation first calculates the value of a control computation, G(p) 402. The value of the control computation is input into the “Switch” operation 408 along with an input value. If the value of the control computation is true, the “Switch” operation 408 sends its input value to its output corresponding to the true value. If the value of the control computation is false, the “Switch” operation 408 sends its input value to its output corresponding to the false value. The example computational dataflow graph enables the subgraph, G(f) 404, or G(g) 406 depending on where the output of the “Switch” operation 408 is located, either the output representing the true branch or the output representing the false branch. The enabled operation is performed and merged by the “Merge” operation 410. The “Merge” operation 410 is essentially a placeholder for naming the output of a conditional.
-
FIG. 4B illustrates an example of control flow operations in a backward propagation of a computational graph that correspond to the control flow operations of the forward propagation illustrated inFIG. 4A . As illustrated, when the example system encounters a “Switch” operation in the forward propagation 408, the system adds the corresponding operation to the backward propagation. In this case, a “Switch” operation 408 corresponds to a “Merge” operation 412, which is then added to the backward propagation. When the system encounters a “Merge” operation 410 in the forward propagation, the system adds the corresponding operation, a “Switch” operation 414 to the backward propagation. The system also adds the differentiation operations for all operations in the forward propagation path. For example, in addition to inserting a “Merge” operation 412 corresponding to the “Switch” operation 408 of the forward propagation path and a “Switch” operation 414 corresponding to the “Merge” operation 410, the system also inserts differentiation operations corresponding to every operation in the forward propagation path. In this example, the system inserts, into the backward propagation path G′(g) 416 corresponding to G(g) 406, and G′(f) 418 corresponding to G(f) 404. However, the system uses the same Boolean-value, control computation, G(p) 402 in the backward propagation path as the forward. - In some implementations, as part of augmenting the computational graph, the system determines that multiple iterations of one or more particular operations represented by one or more particular nodes in the computational graph are performed during execution of the computational graph.
- In particular, the system can analyze the computational graph to identify one or more control flow nodes in the computational graph that cause the particular operations represented by the one or more particular nodes in the computational graph to be performed multiple times. For example, the neural network may be a recurrent neural network that receives a respective neural network input at each of multiple time steps and generates a respective neural network at each of the multiple time steps.
- The system then inserts one or more monitoring nodes into the computational graph. The monitoring nodes represent operations that, during the execution of the training computational graph, monitor a number of iterations of the particular operations that are performed, and for each performed iteration of each of the particular operations, stores the output of the particular operation represented by the node during the iteration for use in the gradient computations during the backward path. For example, where the neural network is a recurrent neural network, the operations represented by each of the particular nodes generate a respective node output for each of the time steps, and the monitoring nodes store the respective node outputs for each of the time steps, i.e., so that the outputs of the operations of the particular nodes for all of the time steps are available when the backward pass begins after the neural network output for the last time step is computed. In other words, to reuse forward values in the backward propagation path, the example system detects, during the construction of the backpropagation path, the forward values that are needed in the backpropagation. For each forward value, the system introduces a stack and adds nodes, such as “Iteration Counter” operations, in the forward propagation path to save the forward values at each iteration to the stack. The backpropagation path uses these values from the stack in reverse order.
- These respective nodes outputs may be produced on a device, such as a GPU, with limited memory. Storing respective node outputs for each time step may lead to numerous values being stored on a stack, reducing the amount of device memory available for other things. Furthermore, old values are stored the longest since backpropagation uses values in reverse order of the forward propagation. In order to preserve memory on a device, an example system may swap memory from the device to another device, such as a CPU. This swapping may be asynchronous with the system sending a value from the device to the CPU sometime after the value is produced and the system retrieving the value back into the device sometime before it is needed. The system obtains values as they are needed based on the operational order and control defined in the dataflow graph.
- Generated computational graphs representing forward and backward propagation paths can be allocated to multiple devices for processing in numerous ways including allocation detailed in U.S. patent application Ser. No. 15/337,744, entitled PROCESSING COMPUTATIONAL GRAPHS, which was filed on Oct. 28, 2016, and which is incorporated here by reference.
- Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, in tangibly-embodied computer software or firmware, in computer hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions encoded on a tangible non transitory program carrier for execution by, or to control the operation of, data processing apparatus. Alternatively or in addition, the program instructions can be encoded on an artificially generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. The computer storage medium can be a machine-readable storage device, a machine-readable storage substrate, a random or serial access memory device, or a combination of one or more of them. The computer storage medium is not, however, a propagated signal.
- The term “data processing apparatus” encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers. The apparatus can include special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit). The apparatus can also include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them.
- A computer program (which may also be referred to or described as a program, software, a software application, a module, a software module, a script, or code) can be written in any form of programming language, including compiled or interpreted languages, or declarative or procedural languages, and it can be deployed in any form, including as a stand alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data, e.g., one or more scripts stored in a markup language document, in a single file dedicated to the program in question, or in multiple coordinated files, e.g., files that store one or more modules, sub programs, or portions of code. A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
- As used in this specification, an “engine,” or “software engine,” refers to a software implemented input/output system that provides an output that is different from the input. An engine can be an encoded block of functionality, such as a library, a platform, a software development kit (“SDK”), or an object. Each engine can be implemented on any appropriate type of computing device, e.g., servers, mobile phones, tablet computers, notebook computers, music players, e-book readers, laptop or desktop computers, PDAs, smart phones, or other stationary or portable devices, that includes one or more processors and computer readable media. Additionally, two or more of the engines may be implemented on the same computing device, or on different computing devices.
- The processes and logic flows described in this specification can be performed by one or more programmable computers executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit).
- Computers suitable for the execution of a computer program include, by way of example, can be based on general or special purpose microprocessors or both, or any other kind of central processing unit. Generally, a central processing unit will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a central processing unit for performing or executing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device, e.g., a universal serial bus (USB) flash drive, to name just a few.
- Computer readable media suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto optical disks; and CD ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
- To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input. In addition, a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a web browser on a user's client device in response to requests received from the web browser.
- Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back end, middleware, or front end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), e.g., the Internet.
- The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
- While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any invention or of what may be claimed, but rather as descriptions of features that may be specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.
- Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system modules and components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
- Particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. For example, the actions recited in the claims can be performed in a different order and still achieve desirable results. As one example, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In certain implementations, multitasking and parallel processing may be advantageous.
Claims (21)
1. A method for training a neural network represented as a computational graph, wherein the computational graph comprises a plurality of nodes, a plurality of connector directed edges, and a plurality of parameter directed edges, wherein each node represents a respective operation performed by the neural network as part of determining a neural network output from a neural network input, wherein each connector directed edge connects a respective first node to a respective second node that represents an operation that receives, as input, an output of an operation represented by the respective first node, and wherein each parameter directed edge connects into a respective node and represents a flow of one or more parameters of the neural network as input to the operation represented by the respective node, the method comprising:
obtaining data representing the computational graph;
augmenting the computational graph to generate a training computational graph for training the neural network using a machine learning training algorithm that includes computing a gradient of an objective function with respect to each of the parameters of the neural network, comprising:
inserting a plurality of gradient nodes and training edges into the computational graph to generate a backward path through the computational graph that represents operations for computing the gradients of the objective function with respect to the parameters of the neural network, wherein each gradient node represents a gradient function that computes a gradient of the objective function with respect to parameters flowing along a respective parameter directed edge in the computational graph; and
training the neural network using the machine learning training algorithm by executing the training computational graph.
2. The method of claim 1 , wherein augmenting the computational graph further comprises:
identifying one or more control flow nodes in the computational graph, wherein each control flow node represents a control flow operation that causes operations represented by one or more other nodes in the computational graph to be conditionally or iteratively performed during execution of the computational graph; and
inserting, for each identified control flow node, a corresponding backward path control flow node along the backward path through the computational graph, wherein each backward path control flow node adjusts control flow along the backward path to account for the control flow operation represented by the corresponding control flow node.
3. The method of claim 2 , wherein the one or more control flow nodes include a switch control flow node, and wherein the backward path control flow node corresponding to the switch control flow node is a merge backward control flow node.
4. The method of claim 2 , wherein the one or more control flow nodes include a merge control flow node, and wherein the backward path control flow node corresponding to the merge control flow node is a switch backward control flow node.
5. The method of claim 2 , wherein the one or more control flow nodes include an enter control flow node, and wherein the backward path control flow node corresponding to the enter control flow node is an exit backward control flow node.
6. The method of claim 2 , wherein the one or more control flow nodes include an exit control flow node, and wherein the backward path control flow node corresponding to the exit control flow node is an enter backward control flow node.
7. The method of claim 2 , wherein the one or more control flow nodes include an iteration counter control flow node, and wherein the backward path control flow node corresponding to the iteration counter control flow node is an iteration counter backward control flow node.
8. The method of claim 1 , wherein augmenting the computational graph further comprises:
determining that multiple iterations of one or more particular operations represented by one or more particular nodes in the computational graph are performed during execution of the computational graph; and
inserting one or more monitoring nodes into the computational graph, the monitoring nodes representing operations that, during the execution of the training computational graph, monitor a number of iterations of the particular operations that are performed, and for each performed iteration of each of the particular operations, stores the output of the particular operation represented by the node during the iteration.
9. The method of claim 8 , wherein, during execution of the backward path in the training computational graph, the outputs stored by the one or more monitoring nodes are provided as input to the gradient functions represented by one or more of the gradient nodes.
10. The method of claim 8 , wherein determining that multiple iterations of one or more particular operations represented by one or more particular nodes in the computational graph are performed during execution of the computational graph comprises:
analyzing the computational graph to identify one or more control flow nodes in the computational graph that cause the particular operations represented by the one or more particular nodes in the computational graph to be performed multiple times.
11. The method of claim 8 , wherein the neural network is a recurrent neural network that receives a respective neural network input at each of a plurality of time steps and generates a respective neural network at each of the plurality of time steps, wherein the operations represented by each of the particular nodes generate a respective node output for each of the plurality of time steps, and wherein the monitoring nodes store the respective node outputs for each of the plurality of time steps.
12. The method of claim 8 , wherein storing the output of the particular operation represented by the node during the iteration includes:
asynchronously sending the data from a device on which it was produced to a central processing unit for storage after the data was produced; and
asynchronously retrieving the data from the central processing unit for use on the device in the backward path through the computational graph that represents operations for computing the gradients of the objective function with respect to the parameters of the neural network.
13. The method of claim 1 , wherein training the neural network using the machine learning training algorithm by executing the training computational graph comprises:
allocating the nodes in the training computational graph across a plurality of devices; and
causing each of the devices to perform the operations represented by the nodes allocated to the device.
14. A system for training a neural network represented as a computational graph, wherein the computational graph comprises a plurality of nodes, a plurality of connector directed edges, and a plurality of parameter directed edges, wherein each node represents a respective operation performed by the neural network as part of determining a neural network output from a neural network input, wherein each connector directed edge connects a respective first node to a respective second node that represents an operation that receives, as input, an output of an operation represented by the respective first node, and wherein each parameter directed edge connects into a respective node and represents a flow of one or more parameters of the neural network as input to the operation represented by the respective node, the system comprising:
one or more computers; and
one or more storage devices storing instructions that are operable, when executed by the one or more computers, to cause the one or more computers to perform operations comprising:
obtaining data representing the computational graph;
augmenting the computational graph to generate a training computational graph for training the neural network using a machine learning training algorithm that includes computing a gradient of an objective function with respect to each of the parameters of the neural network, comprising:
inserting a plurality of gradient nodes and training edges into the computational graph to generate a backward path through the computational graph that represents operations for computing the gradients of the objective function with respect to the parameters of the neural network, wherein each gradient node represents a gradient function that computes a gradient of the objective function with respect to parameters flowing along a respective parameter directed edge in the computational graph; and
training the neural network using the machine learning training algorithm by executing the training computational graph.
15. The system of claim 14 , wherein augmenting the computational graph further comprises:
identifying one or more control flow nodes in the computational graph, wherein each control flow node represents a control flow operation that causes operations represented by one or more other nodes in the computational graph to be conditionally or iteratively performed during execution of the computational graph; and
inserting, for each identified control flow node, a corresponding backward path control flow node along the backward path through the computational graph, wherein each backward path control flow node adjusts control flow along the backward path to account for the control flow operation represented by the corresponding control flow node.
16. The system of claim 15 , wherein the one or more control flow nodes include a switch control flow node, and wherein the backward path control flow node corresponding to the switch control flow node is a merge backward control flow node.
17. The system of claim 15 , wherein the one or more control flow nodes include a merge control flow node, and wherein the backward path control flow node corresponding to the merge control flow node is a switch backward control flow node.
18. The system of claim 15 , wherein the one or more control flow nodes include an enter control flow node, and wherein the backward path control flow node corresponding to the enter control flow node is an exit backward control flow node.
19. The system of claim 15 , wherein the one or more control flow nodes include an exit control flow node, and wherein the backward path control flow node corresponding to the exit control flow node is an enter backward control flow node.
20. The system of claim 15 , wherein the one or more control flow includes an iteration counter control flow node, and wherein the backward path control flow node corresponding to the iteration counter control flow nodes is an iteration counter backward control flow node.
21-39. (canceled)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US17/221,305 US20210295161A1 (en) | 2015-11-09 | 2021-04-02 | Training neural networks represented as computational graphs |
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201562253057P | 2015-11-09 | 2015-11-09 | |
US15/347,618 US10970628B2 (en) | 2015-11-09 | 2016-11-09 | Training neural networks represented as computational graphs |
US17/221,305 US20210295161A1 (en) | 2015-11-09 | 2021-04-02 | Training neural networks represented as computational graphs |
Related Parent Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US15/347,618 Continuation US10970628B2 (en) | 2015-11-09 | 2016-11-09 | Training neural networks represented as computational graphs |
Publications (1)
Publication Number | Publication Date |
---|---|
US20210295161A1 true US20210295161A1 (en) | 2021-09-23 |
Family
ID=57910102
Family Applications (2)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US15/347,618 Active 2038-05-13 US10970628B2 (en) | 2015-11-09 | 2016-11-09 | Training neural networks represented as computational graphs |
US17/221,305 Pending US20210295161A1 (en) | 2015-11-09 | 2021-04-02 | Training neural networks represented as computational graphs |
Family Applications Before (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US15/347,618 Active 2038-05-13 US10970628B2 (en) | 2015-11-09 | 2016-11-09 | Training neural networks represented as computational graphs |
Country Status (4)
Country | Link |
---|---|
US (2) | US10970628B2 (en) |
EP (2) | EP4202782A1 (en) |
CN (1) | CN108292374B (en) |
WO (1) | WO2017083399A2 (en) |
Families Citing this family (73)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US11615285B2 (en) * | 2017-01-06 | 2023-03-28 | Ecole Polytechnique Federale De Lausanne (Epfl) | Generating and identifying functional subnetworks within structural networks |
CN107239315B (en) * | 2017-04-11 | 2019-11-15 | 赛灵思公司 | Programming model towards neural network heterogeneous computing platforms |
US11288575B2 (en) * | 2017-05-18 | 2022-03-29 | Microsoft Technology Licensing, Llc | Asynchronous neural network training |
US10333961B2 (en) * | 2017-06-27 | 2019-06-25 | Intel Corporation | Malware detection system attack prevention |
US11138516B2 (en) * | 2017-06-30 | 2021-10-05 | Visa International Service Association | GPU enhanced graph model build and scoring engine |
EP3428746B1 (en) * | 2017-07-14 | 2021-06-02 | Siemens Aktiengesellschaft | A method and apparatus for providing an adaptive self-learning control program for deployment on a target field device |
EP3682379A1 (en) * | 2017-09-15 | 2020-07-22 | Google LLC | Augmenting neural networks |
US11003992B2 (en) * | 2017-10-16 | 2021-05-11 | Facebook, Inc. | Distributed training and prediction using elastic resources |
CN109841220B (en) | 2017-11-24 | 2022-09-13 | 深圳市腾讯计算机系统有限公司 | Speech signal processing model training method and device, electronic equipment and storage medium |
US10818082B2 (en) * | 2018-03-05 | 2020-10-27 | Vivacity Inc. | Method and system for parametrically creating an optimal three dimensional building structure |
WO2019182590A1 (en) * | 2018-03-21 | 2019-09-26 | Visa International Service Association | Automated machine learning systems and methods |
CN109643229B (en) * | 2018-04-17 | 2022-10-04 | 深圳鲲云信息科技有限公司 | Application development method and platform of network model and computer readable storage medium |
US11715002B2 (en) * | 2018-05-10 | 2023-08-01 | Microsoft Technology Licensing, Llc | Efficient data encoding for deep neural network training |
US11972343B2 (en) | 2018-06-11 | 2024-04-30 | Inait Sa | Encoding and decoding information |
US10956132B1 (en) * | 2018-06-11 | 2021-03-23 | Amazon Technologies, Inc. | Unified code and data management for model development |
US11663478B2 (en) | 2018-06-11 | 2023-05-30 | Inait Sa | Characterizing activity in a recurrent artificial neural network |
US11893471B2 (en) | 2018-06-11 | 2024-02-06 | Inait Sa | Encoding and decoding information and artificial neural networks |
US11238368B2 (en) * | 2018-07-02 | 2022-02-01 | Paypal, Inc. | Machine learning and security classification of user accounts |
WO2020041026A1 (en) * | 2018-08-23 | 2020-02-27 | D5Ai Llc | Efficently building deep neural networks |
US11037059B2 (en) * | 2018-08-31 | 2021-06-15 | D5Ai Llc | Self-supervised back propagation for deep learning |
EP3629246B1 (en) * | 2018-09-27 | 2022-05-18 | Swisscom AG | Systems and methods for neural architecture search |
US11531902B2 (en) | 2018-11-13 | 2022-12-20 | International Business Machines Corporation | Generating and managing deep tensor neural networks |
CN109597965B (en) * | 2018-11-19 | 2023-04-18 | 深圳力维智联技术有限公司 | Data processing method, system, terminal and medium based on deep neural network |
US20200175361A1 (en) * | 2018-11-30 | 2020-06-04 | Alibaba Group Holding Limited | Partitioning of deep learning inference with dynamic offloading |
WO2020113437A1 (en) * | 2018-12-04 | 2020-06-11 | 区链通网络有限公司 | Graph structure processing method and system, network device and storage medium |
CN111340175B (en) * | 2018-12-18 | 2023-12-26 | 赛灵思公司 | Graph rewriting processing method and device, computing equipment and readable medium |
CN109740751B (en) * | 2018-12-24 | 2020-04-14 | 中科寒武纪科技股份有限公司 | Architecture fusion method of neural network model and related device |
US11373233B2 (en) | 2019-02-01 | 2022-06-28 | Target Brands, Inc. | Item recommendations using convolutions on weighted graphs |
CN111563584B (en) * | 2019-02-14 | 2022-12-09 | 上海寒武纪信息科技有限公司 | Splitting method of neural network model and related product |
CN111667060B (en) * | 2019-03-08 | 2022-12-09 | 上海寒武纪信息科技有限公司 | Deep learning algorithm compiling method and device and related products |
US11652603B2 (en) | 2019-03-18 | 2023-05-16 | Inait Sa | Homomorphic encryption |
US11569978B2 (en) | 2019-03-18 | 2023-01-31 | Inait Sa | Encrypting and decrypting information |
US20200302250A1 (en) * | 2019-03-22 | 2020-09-24 | Nvidia Corporation | Iterative spatial graph generation |
CN110008028B (en) * | 2019-04-10 | 2021-08-06 | 北京旷视科技有限公司 | Computing resource allocation method and device, computer equipment and storage medium |
US11556756B2 (en) * | 2019-04-25 | 2023-01-17 | Alibaba Group Holding Limited | Computation graph mapping in heterogeneous computer system |
CN111915002B (en) * | 2019-05-09 | 2023-12-19 | 中科寒武纪科技股份有限公司 | Operation method, device and related product |
CN110163372B (en) * | 2019-05-31 | 2020-04-21 | 中科寒武纪科技股份有限公司 | Operation method, device and related product |
CN110162337B (en) * | 2019-05-31 | 2020-07-03 | 中科寒武纪科技股份有限公司 | Operation method, device and related product |
CN110210614B (en) * | 2019-05-31 | 2020-08-25 | 中科寒武纪科技股份有限公司 | Operation method, device and related product |
CN114008594A (en) | 2019-07-17 | 2022-02-01 | 谷歌有限责任公司 | Scheduling operations on a computational graph |
US11694075B2 (en) * | 2019-09-05 | 2023-07-04 | Alibaba Group Holding Limited | Partitioning control dependency edge in computation graph |
WO2021052391A1 (en) | 2019-09-18 | 2021-03-25 | 华为技术有限公司 | Method for constructing intermediate representation, compiler and server |
CN110689116B (en) * | 2019-09-24 | 2022-12-27 | 安徽寒武纪信息科技有限公司 | Neural network pruning method and device, computer equipment and storage medium |
CN114365147A (en) * | 2019-10-22 | 2022-04-15 | 深圳鲲云信息科技有限公司 | Neural network calculation compression method, system and storage medium |
WO2021077282A1 (en) * | 2019-10-22 | 2021-04-29 | 深圳鲲云信息科技有限公司 | Neural network model conversion method and apparatus, server, and storage medium |
US20210133591A1 (en) * | 2019-11-04 | 2021-05-06 | Baidu Usa Llc | Reducing training times of deep neural networks through efficient hybrid parallelism |
CN110942147B (en) * | 2019-11-28 | 2021-04-20 | 支付宝(杭州)信息技术有限公司 | Neural network model training and predicting method and device based on multi-party safety calculation |
CN111160551B (en) * | 2019-12-04 | 2023-09-29 | 上海寒武纪信息科技有限公司 | Calculation map execution method, computer device, and storage medium |
CN111158901B (en) * | 2019-12-09 | 2023-09-08 | 爱芯元智半导体(宁波)有限公司 | Optimization method, optimization device, computer equipment and storage medium for calculation graph |
US11797827B2 (en) | 2019-12-11 | 2023-10-24 | Inait Sa | Input into a neural network |
US11651210B2 (en) | 2019-12-11 | 2023-05-16 | Inait Sa | Interpreting and improving the processing results of recurrent neural networks |
US11816553B2 (en) | 2019-12-11 | 2023-11-14 | Inait Sa | Output from a recurrent neural network |
US11580401B2 (en) | 2019-12-11 | 2023-02-14 | Inait Sa | Distance metrics and clustering in recurrent neural networks |
CN113011577B (en) * | 2019-12-20 | 2024-01-05 | 阿里巴巴集团控股有限公司 | Processing unit, processor core, neural network training machine and method |
CN111309479B (en) * | 2020-02-14 | 2023-06-06 | 北京百度网讯科技有限公司 | Method, device, equipment and medium for realizing task parallel processing |
CN110929870B (en) * | 2020-02-17 | 2020-06-12 | 支付宝(杭州)信息技术有限公司 | Method, device and system for training neural network model |
CN111882054B (en) * | 2020-05-27 | 2024-04-12 | 杭州中奥科技有限公司 | Method for cross training of encryption relationship network data of two parties and related equipment |
CN111753983A (en) * | 2020-06-22 | 2020-10-09 | 深圳鲲云信息科技有限公司 | Method, system, device and storage medium for customizing neural network model |
CN111723935A (en) * | 2020-06-24 | 2020-09-29 | 湖北亿咖通科技有限公司 | Neural network computation graph processing method, computer storage medium and electronic device |
CN112070213A (en) * | 2020-08-28 | 2020-12-11 | Oppo广东移动通信有限公司 | Neural network model optimization method, device, equipment and storage medium |
CN114169491A (en) * | 2020-09-10 | 2022-03-11 | 阿里巴巴集团控股有限公司 | Model processing method, device, equipment and computer readable storage medium |
CN114556364A (en) * | 2020-09-18 | 2022-05-27 | 百度时代网络技术（北京）有限公司 | Neural architecture search based on similarity operator ordering |
CN112465116B (en) * | 2020-11-25 | 2022-12-09 | 安徽寒武纪信息科技有限公司 | Compiling method, operation method, electronic device, and storage medium |
US20220180243A1 (en) * | 2020-12-08 | 2022-06-09 | Atlantic Technical Organization | System and method of suggesting machine learning workflows through machine learning |
US20220345535A1 (en) * | 2021-04-26 | 2022-10-27 | Nokia Solutions And Networks Oy | Distribution of machine learning workflows on webscale infrastructures |
CN117501245A (en) * | 2021-06-25 | 2024-02-02 | 华为技术有限公司 | Neural network model training method and device, and data processing method and device |
CN113553175B (en) * | 2021-07-08 | 2024-04-16 | 浙江工业大学 | Optimal sorting algorithm selection method for traffic data flow |
WO2023129762A2 (en) * | 2021-08-16 | 2023-07-06 | The Regents Of The University Of California | A design automation methodology based on graph neural networks to model integrated circuits and mitigate hardware security threats |
DE102021210846A1 (en) | 2021-09-28 | 2023-03-30 | Robert Bosch Gesellschaft mit beschränkter Haftung | Method for generating a graph structure for training a graph neural network |
CN116204847A (en) * | 2021-11-29 | 2023-06-02 | 华为技术有限公司 | Calculation graph optimization method, device and equipment |
US20230177385A1 (en) * | 2021-12-08 | 2023-06-08 | International Business Machines Corporation | Federated machine learning based on partially secured spatio-temporal data |
CN114860443A (en) * | 2022-05-06 | 2022-08-05 | 北京灵汐科技有限公司 | Mapping method, electronic device and computer-readable storage medium |
US20240104341A1 (en) * | 2022-09-27 | 2024-03-28 | Zhejiang Lab | Memory optimization method and apparatus for neural network compilation |
Family Cites Families (9)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6128606A (en) | 1997-03-11 | 2000-10-03 | At&T Corporation | Module for constructing trainable modular network in which each module inputs and outputs data structured as a graph |
US8826255B1 (en) * | 2007-06-18 | 2014-09-02 | The Mathworks, Inc. | Restructuring control flow graphs generated from a model |
CN102184454B (en) * | 2011-05-26 | 2014-05-07 | 浙江迦南科技股份有限公司 | Granulator formula generation method based on neural network system |
CN104620236B (en) * | 2012-03-15 | 2019-02-15 | 高通股份有限公司 | The device and method based on label for neural network |
US9424079B2 (en) | 2013-06-27 | 2016-08-23 | Microsoft Technology Licensing, Llc | Iteration support in a heterogeneous dataflow engine |
GB201402736D0 (en) | 2013-07-26 | 2014-04-02 | Isis Innovation | Method of training a neural network |
US10282228B2 (en) * | 2014-06-26 | 2019-05-07 | Amazon Technologies, Inc. | Log-based transaction constraint management |
US9495633B2 (en) * | 2015-04-16 | 2016-11-15 | Cylance, Inc. | Recurrent neural networks for malware analysis |
US10467528B2 (en) * | 2015-08-11 | 2019-11-05 | Oracle International Corporation | Accelerated TR-L-BFGS algorithm for neural network |
-
2016
- 2016-11-09 EP EP22210927.4A patent/EP4202782A1/en active Pending
- 2016-11-09 WO PCT/US2016/061151 patent/WO2017083399A2/en active Application Filing
- 2016-11-09 CN CN201680065507.2A patent/CN108292374B/en active Active
- 2016-11-09 US US15/347,618 patent/US10970628B2/en active Active
- 2016-11-09 EP EP16831657.8A patent/EP3374933A2/en not_active Ceased
-
2021
- 2021-04-02 US US17/221,305 patent/US20210295161A1/en active Pending
Also Published As
Publication number | Publication date |
---|---|
US10970628B2 (en) | 2021-04-06 |
CN108292374B (en) | 2022-04-15 |
EP3374933A2 (en) | 2018-09-19 |
WO2017083399A2 (en) | 2017-05-18 |
US20170132513A1 (en) | 2017-05-11 |
CN108292374A (en) | 2018-07-17 |
EP4202782A1 (en) | 2023-06-28 |
WO2017083399A3 (en) | 2017-06-22 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US20210295161A1 (en) | Training neural networks represented as computational graphs | |
US11769061B2 (en) | Processing computational graphs | |
US11087216B2 (en) | Modifying computational graphs | |
US20220027202A1 (en) | Stream-based accelerator processing of computational graphs | |
CN108460458B (en) | Method, system and storage medium for executing computation graph on graphic processing unit | |
US11763146B1 (en) | Processing loops in computational graphs | |
EP3682379A1 (en) | Augmenting neural networks | |
US20240160948A1 (en) | Processing computational graphs |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:YU, YUAN;VENKATAKRISHNA, MANJUNATH KUDLUR;SIGNING DATES FROM 20151210 TO 20160103;REEL/FRAME:055810/0704 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:GOOGLE INC.;REEL/FRAME:056697/0649Effective date: 20170930 |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: DOCKETED NEW CASE - READY FOR EXAMINATION |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: NON FINAL ACTION MAILED |