KR20190061078A - Establish a link between identifiers without disclosing specific identification information - Google Patents
Establish a link between identifiers without disclosing specific identification information Download PDFInfo
- Publication number
- KR20190061078A KR20190061078A KR1020197013590A KR20197013590A KR20190061078A KR 20190061078 A KR20190061078 A KR 20190061078A KR 1020197013590 A KR1020197013590 A KR 1020197013590A KR 20197013590 A KR20197013590 A KR 20197013590A KR 20190061078 A KR20190061078 A KR 20190061078A
- Authority
- KR
- South Korea
- Prior art keywords
- pii
- data structure
- server
- data
- entry
- Prior art date
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/60—Protecting data
- G06F21/62—Protecting access to data via a platform, e.g. using keys or access control rules
- G06F21/6218—Protecting access to data via a platform, e.g. using keys or access control rules to a system of files or objects, e.g. local or distributed file system or database
- G06F21/6227—Protecting access to data via a platform, e.g. using keys or access control rules to a system of files or objects, e.g. local or distributed file system or database where protection concerns the structure of data, e.g. records, types, queries
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/22—Indexing; Data structures therefor; Storage structures
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/60—Protecting data
- G06F21/62—Protecting access to data via a platform, e.g. using keys or access control rules
- G06F21/6218—Protecting access to data via a platform, e.g. using keys or access control rules to a system of files or objects, e.g. local or distributed file system or database
- G06F21/6245—Protecting personal data, e.g. for financial or medical purposes
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/06—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols the encryption apparatus using shift registers or memories for block-wise or stream coding, e.g. DES systems or RC4; Hash functions; Pseudorandom sequence generators
- H04L9/0643—Hash functions, e.g. MD5, SHA, HMAC or f9 MAC
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/32—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols including means for verifying the identity or authority of a user of the system or for message authentication, e.g. authorization, entity authentication, data integrity or data verification, non-repudiation, key authentication or verification of credentials
- H04L9/3236—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols including means for verifying the identity or authority of a user of the system or for message authentication, e.g. authorization, entity authentication, data integrity or data verification, non-repudiation, key authentication or verification of credentials using cryptographic hash functions
- H04L9/3239—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols including means for verifying the identity or authority of a user of the system or for message authentication, e.g. authorization, entity authentication, data integrity or data verification, non-repudiation, key authentication or verification of credentials using cryptographic hash functions involving non-keyed hash functions, e.g. modification detection codes [MDCs], MD5, SHA or RIPEMD
Abstract
사용자 식별자들을 연결하는 방법이 개시된다. 상기 방법은 엔트리들을 포함하는 제1 데이터 구조를, 연결 서버에 의해 그리고 회사 서버로부터 수신하는 단계를 포함한다. 각 엔트리는 사용자 태그, 제1 해시된 사용자 정보 및 제2 해시된 사용자 정보를 포함한다. 상기 방법은, 엔트리들을 포함하는 제2 데이터 구조를, 연결 서버에 의해 그리고 파트너 서버로부터 수신하는 단계를 포함한다. 각 엔트리는 브리지 태그, 제1 해시된 브리지 정보 및 제2 해시된 브리지 정보를 포함한다. 상기 방법은, 상기 엔트리들 중 제1 엔트리를, 상기 연결 서버에 의해 그리고 상기 제1 데이터 구조로부터 검색하는 단계 및 상기 엔트리들 중 제1 엔트리를, 상기 연결 서버에 의해 그리고 상기 제2 데이터 구조로부터 검색하는 단계를 포함한다. 상기 방법은, 제1 링크를 발생시키기 위해 상기 제1 데이터 구조의 제1 엔트리의 사용자 태그와 상기 제2 데이터 구조의 제1 엔트리의 브리지 태그를 링크시키는 단계를 포함한다.A method for linking user identifiers is disclosed. The method includes receiving, by a connection server and from a corporate server, a first data structure comprising entries. Each entry includes a user tag, a first hashed user information, and a second hashed user information. The method includes receiving from a connection server and from a partner server a second data structure comprising entries. Each entry includes a bridge tag, a first hashed bridge information, and a second hashed bridge information. The method comprising: retrieving a first one of the entries from the connection server and from the first data structure; and retrieving a first one of the entries from the connection server and from the second data structure . The method includes linking a user tag of a first entry of the first data structure and a bridge tag of a first entry of the second data structure to generate a first link.
Description
본 출원은 2017년 1월 30일자로 출원된 미국 특허 출원 제15/419,726호, "집합적 사용자 세션 데이터를 이용한 비디오들의 주석"이라는 우선권을 주장하며, 그 전체 내용이 본 명세서에 참고로 포함된다.This application claims priority to U.S. Patent Application No. 15 / 419,726, filed January 30, 2017, entitled " Annotations of Videos Using Aggregated User Session Data ", the entire contents of which are incorporated herein by reference .
본 개시의 양상들은 일반적으로 개체들 간의 특정 식별 정보의 맵핑에 관한 것이다.Aspects of the present disclosure generally relate to the mapping of specific identification information between entities.
많은 사업체들 또는 개체들은, 사용자 로그인 및 암호 세부 정보, 개인 식별 정보(단독으로 또는 다른 정보와 결합된 정보는 문맥상 개인을 식별하는 데 사용할 수 있고, "기밀 개인 정보"라고도 언급됨), 의료 기록 등과 같은 기밀 정보를 보유한다. 인터넷 관련 서비스들 및 제품들을 제공하는 개체들은, 클라이언트 컴퓨팅 장치들에서 수집한 웹 데이터를 캡처, 구성 및 분석할 수 있다. 웹 데이터에는 사업체들이 보호된 데이터베이스들에 저장하는 사용자 식별 정보가 포함될 수 있다.Many businesses or entities may use user login and password details, personally identifiable information (information alone or in combination with other information may be used to identify an individual in context, also referred to as " confidential personal information "), Confidential information such as records. Entities that provide Internet-related services and products can capture, organize, and analyze web data collected by client computing devices. Web data may include user identification information that businesses store in protected databases.
여기에서 개시된 일 구현은 사용자 식별자들을 링크하는 방법이다. 상기 방법은, 엔트리들을 포함하는 제1 데이터 구조를, 연결 서버에 의해 그리고 회사 서버로부터 수신하는 단계를 포함한다. 각 엔트리는 사용자 태그, 제1 해시된 사용자 정보 및 제2 해시된 사용자 정보를 포함하고, 각 엔트리는 대응하는 클라이언트 디바이스와 관련된다. 상기 방법은 엔트리들을 포함하는 제2 데이터 구조를, 연결 서버에 의해 그리고 파트너 서버로부터 수신하는 단계를 포함하고, 각 엔트리는 브리지 태그, 제1 해시된 브리지 정보 및 제2 해시된 브리지 정보를 포함하고, 각 엔트리는 대응하는 클라이언트 디바이스와 관련된다. 상기 방법은, 또한, 상기 제1 데이터 구조의 엔트리들 중 제1 엔트리를, 상기 연결 서버에 의해 그리고 상기 제1 데이터 구조로부터 검색하는 단계를 포함한다. 상기 방법은 상기 제2 데이터 구조의 엔트리들 중 제1 엔트리를, 상기 연결 서버에 의해 그리고 상기 제2 데이터 구조로부터 검색하는 단계를 포함한다. 상기 방법은, 상기 연결 서버에 의해, 상기 제1 데이터 구조의 제1 엔트리의 제1 해시된 사용자 정보를 상기 제2 데이터 구조의 제1 엔트리의 제1 해시된 브리지 정보와 비교하는 단계를 포함한다. 상기 방법은, 상기 연결 서버에 의해 그리고 매칭을 결정하는 것에 응답하여, 제1 링크를 발생시키기 위해 상기 제1 데이터 구조의 제1 엔트리의 사용자 태그와 상기 제2 데이터 구조의 제1 엔트리의 브리지 태그를 링크시키는 단계를 포함한다.One implementation disclosed herein is a method of linking user identifiers. The method includes receiving a first data structure comprising entries from a connection server and from a corporate server. Each entry includes a user tag, a first hashed user information, and a second hashed user information, wherein each entry is associated with a corresponding client device. The method includes receiving a second data structure comprising entries from and by a connection server, each entry including a bridge tag, a first hashed bridge information and a second hashed bridge information , Each entry is associated with a corresponding client device. The method also includes retrieving, by the connection server and from the first data structure, a first one of the entries of the first data structure. The method includes retrieving, from the connection server and from the second data structure, a first entry of entries in the second data structure. The method includes comparing, by the connection server, first hashed user information of a first entry of the first data structure with first hashed bridge information of a first entry of the second data structure . The method further comprising: in response to determining by the connection server and in response to determining a match, associating a user tag of a first entry of the first data structure with a bridge tag of a first entry of the second data structure, Linking.
일부 구현들에서, 상기 비교하는 단계는, 상기 제1 데이터 구조의 제1 엔트리의 제1 해시된 사용자 정보를 제1 세트의 문자들로, 상기 연결 서버에 의해 파싱하는 단계를 포함한다. 일부 구현들에서, 상기 방법은 상기 제2 데이터 구조의 제1 엔트리의 제1 해시된 브리지 정보를 제2 세트의 문자들로, 상기 연결 서버에 의해 파싱하는 단계를 포함한다. 일부 구현들에서, 상기 연결 서버에 의해, 상기 제1 세트의 문자들 중 하나의 문자를 상기 제2 세트의 문자들 중 하나의 문자와 비교하는 단계를 포함한다.In some implementations, the comparing includes parsing the first hashed user information of the first entry of the first data structure into a first set of characters by the connection server. In some implementations, the method includes parsing the first hashed bridge information of a first entry of the second data structure with a second set of characters by the connection server. In some implementations, the method comprises comparing, by the connection server, one character of the first set of characters with one character of the second set of characters.
일부 구현들에서, 상기 방법은, 상기 연결 서버에 의해, 상기 제1 링크를 상기 회사 서버에 제공하는 단계를 포함한다. 일부 구현들에서, 상기 연결 서버는 클린 룸 환경 내에 존재하고, 상기 회사 서버는 상기 클린 룸 환경 외부에 존재하며, 그리고 상기 파트너 서버는 상기 클린 룸 환경 외부에 존재한다.In some implementations, the method includes providing, by the connection server, the first link to the company server. In some implementations, the connection server is in a clean room environment, the company server is outside the clean room environment, and the partner server is outside the clean room environment.
일부 구현들에서, 상기 방법은, 상기 연결 서버에 의해, 상기 제1 데이터 구조의 제1 엔트리 및 상기 제2 데이터 구조의 제1 엔트리를 제거하는 단계를 포함한다. 일부 구현들에서, 상기 방법은, 상기 엔트리들 중 제2 엔트리를, 상기 연결 서버에 의해 그리고 상기 제1 데이터 구조로부터 검색하는 단계와; 상기 엔트리들 중 제2 엔트리를, 상기 연결 서버에 의해 그리고 상기 제2 데이터 구조로부터 검색하는 단계와; 그리고 상기 연결 서버에 의해, 상기 제1 데이터 구조의 제2 엔트리의 제1 해시된 사용자 정보를 상기 제2 데이터 구조의 제2 엔트리의 제1 해시된 브리지 정보와 비교하는 단계를 포함한다.In some implementations, the method includes removing, by the connection server, a first entry of the first data structure and a first entry of the second data structure. In some implementations, the method further comprises: retrieving, by the connection server and from the first data structure, a second entry of the entries; Retrieving a second one of the entries from the connection server and from the second data structure; And comparing, by the connection server, the first hashed user information of the second entry of the first data structure with the first hashed bridge information of the second entry of the second data structure.
일부 구현들에서, 상기 방법은, 상기 연결 서버에 의해, 상기 제1 데이터 구조의 제2 엔트리의 제1 해시된 사용자 정보와 상기 제2 데이터 구조의 제2 엔트리의 제1 해시된 브리지 정보 간의 미스매칭을 결정하는 단계와; 그리고 상기 연결 서버에 의해, 상기 제1 데이터 구조의 제2 엔트리의 제2 해시된 사용자 정보를 상기 제2 데이터 구조의 제2 엔트리의 제2 해시된 브리지 정보와 비교하는 단계를 포함한다.In some implementations, the method further comprises, by the connection server, generating a miss between the first hashed user information of the second entry of the first data structure and the first hashed bridge information of the second entry of the second data structure, Determining a match; And comparing, by the connection server, second hashed user information of a second entry of the first data structure to second hashed bridge information of a second entry of the second data structure.
일부 구현들에서, 상기 방법은, 상기 연결 서버에 의해, 상기 제1 데이터 구조의 제1 엔트리의 제1 해시된 사용자 정보와 상기 제2 데이터 구조의 제1 엔트리의 제1 해시된 브리지 정보 간의 미스매칭을 결정하는 단계를 포함한다. 일부 구현들에서, 상기 방법은, 상기 엔트리들 중 제2 엔트리를, 상기 연결 서버에 의해 그리고 상기 제2 데이터 구조로부터 검색하는 단계를 포함한다. 일부 구현들에서, 상기 연결 서버에 의해, 상기 제1 데이터 구조의 제1 엔트리의 제1 해시된 사용자 정보를 상기 제2 데이터 구조의 제2 엔트리의 제1 해시된 브리지 정보와 비교하는 단계를 포함한다.In some implementations, the method further comprises, by the connection server, generating a miss between the first hashed user information of the first entry of the first data structure and the first hashed bridge information of the first entry of the second data structure, And determining matching. In some implementations, the method includes retrieving a second one of the entries from the connection server and from the second data structure. In some implementations, the method includes comparing, by the connection server, first hashed user information of a first entry of the first data structure with first hashed bridge information of a second entry of the second data structure do.
일부 구현들에서, 상기 방법은, 상기 연결 서버에 의해, 상기 제1 데이터 구조의 제1 엔트리의 제2 해시된 사용자 정보를 상기 제2 데이터 구조의 제2 엔트리의 제2 해시된 브리지 정보와 비교하는 단계를 포함한다. 일부 구현들에서, 상기 방법은, 상기 연결 서버에 의해 그리고 매칭을 결정하는 것에 응답하여, 제1 링크를 발생시키기 위해 상기 제1 데이터 구조의 제1 엔트리의 사용자 태그와 상기 제2 데이터 구조의 제1 엔트리의 브리지 태그를 링크시키는 단계를 포함한다. 일부 구현들에서, 상기 방법은, 상기 연결 서버에 의해, 상기 제1 링크를 상기 회사 서버에 제공하는 단계를 포함한다. In some implementations, the method further comprises: comparing, by the connection server, second hashed user information of a first entry of the first data structure with second hashed bridge information of a second entry of the second data structure . In some implementations, the method further comprises: in response to determining by the connection server and in response to determining a match, associating a user tag of a first entry of the first data structure with a user tag of a
다른 양태에서, 본 발명은 사용자 식별자들을 링크하는 시스템에 관한 것이다. 상기 시스템은 연결 서버를 포함하고, 상기 연결 서버는 엔트리들을 포함하는 제1 데이터 구조를 회사 서버로부터 수신한다. 각 엔트리는 사용자 태그, 제1 해시된 사용자 정보 및 제2 해시된 사용자 정보를 포함한다. 각 엔트리는 클라이언트 디바이스의 사용자와 관련된다.In another aspect, the invention relates to a system for linking user identifiers. The system includes a connection server, and the connection server receives a first data structure including entries from a company server. Each entry includes a user tag, a first hashed user information, and a second hashed user information. Each entry is associated with a user of the client device.
일부 구현들에서, 상기 시스템은 엔트리들을 포함하는 제2 데이터 구조를 파트너 서버로부터 수신하도록 구성되는 연결 서버를 포함한다. 각 엔트리는 브리지 태그, 제1 해시된 브리지 정보 및 제2 해시된 브리지 정보를 포함한다. 각 엔트리는 클라이언트 디바이스의 사용자와 관련된다. In some implementations, the system includes a connection server configured to receive a second data structure comprising entries from a partner server. Each entry includes a bridge tag, a first hashed bridge information, and a second hashed bridge information. Each entry is associated with a user of the client device.
일부 구현들에서, 상기 시스템은 상기 제1 데이터 구조의 엔트리들 중 제1 엔트리를 상기 제1 데이터 구조로부터 검색하도록 구성되는 연결 서버를 포함한다. 일부 구현들에서, 상기 시스템은 상기 제2 데이터 구조의 엔트리들 중 제1 엔트리를 상기 제2 데이터 구조로부터 검색하도록 구성되는 연결 서버를 포함한다. 일부 구현들에서, 상기 시스템은 상기 제1 데이터 구조의 제1 엔트리의 제1 해시된 사용자 정보를 상기 제2 데이터 구조의 제1 엔트리의 제1 해시된 브리지 정보와 비교하도록 구성되는 연결 서버를 포함한다. 일부 구현들에서, 상기 시스템은, 매칭을 결정하는 것에 응답하여, 제1 링크를 발생시키기 위해 상기 제1 데이터 구조의 제1 엔트리의 사용자 태그와 상기 제2 데이터 구조의 제1 엔트리의 브리지 태그를 링크시키도록 구성되는 연결 서버를 포함한다. In some implementations, the system includes a connection server configured to retrieve a first one of the entries of the first data structure from the first data structure. In some implementations, the system includes a connection server configured to retrieve a first one of the entries of the second data structure from the second data structure. In some implementations, the system includes a connection server configured to compare first hashed user information of a first entry of the first data structure to first hashed bridge information of a first entry of the second data structure do. In some implementations, the system, in response to determining a match, generates a bridge tag of a first entry of the second data structure and a user tag of a first entry of the first data structure to generate a first link And a link server configured to link the link server.
일부 구현들에서, 상기 시스템은, 상기 제1 데이터 구조의 제1 엔트리의 제1 해시된 사용자 정보를 제1 세트의 문자들로 파싱하도록 구성되는 연결 서버를 포함한다. 일부 구현들에서, 상기 시스템은 상기 제2 데이터 구조의 제1 엔트리의 제1 해시된 브리지 정보를 제2 세트의 문자들로 파싱하도록 구성되는 연결 서버를 포함한다. 일부 구현들에서, 상기 시스템은 상기 제1 세트의 문자들 중 하나의 문자를 상기 제2 세트의 문자들 중 하나의 문자와 비교하도록 구성된다. In some implementations, the system includes a connection server configured to parse the first hashed user information of the first entry of the first data structure into a first set of characters. In some implementations, the system includes a connection server configured to parse the first hashed bridge information of a first entry of the second data structure into a second set of characters. In some implementations, the system is configured to compare one character of the first set of characters to one character of the second set of characters.
일부 구현들에서, 상기 시스템은 상기 제1 링크를 상기 회사 서버에 제공하도록 구성되는 연결 서버를 포함한다. 일부 구현들에서, 상기 연결 서버는 클린 룸 환경 내에 존재한다. 일부 구현들에서, 상기 회사 서버는 상기 클린 룸 환경 외부에 존재한다. 일부 구현들에서, 상기 파트너 서버는 상기 클린 룸 환경 외부에 존재한다. In some implementations, the system includes a connection server configured to provide the first link to the corporate server. In some implementations, the connection server is in a clean room environment. In some implementations, the company server is external to the clean room environment. In some implementations, the partner server is external to the clean room environment.
일부 구현들에서, 상기 시스템은 상기 제1 데이터 구조의 제1 엔트리 및 상기 제2 데이터 구조의 제1 엔트리를 제거하도록 구성되는 연결 서버를 포함한다. 일부 구현들에서, 상기 시스템은 상기 엔트리들 중 제2 엔트리를 상기 제1 데이터 구조로부터 검색하도록 구성되는 연결 서버를 포함한다. 일부 구현들에서, 상기 시스템은 상기 엔트리들 중 제2 엔트리를 상기 제2 데이터 구조로부터 검색하도록 구성되는 연결 서버를 포함한다. 일부 구현들에서, 상기 시스템은, 상기 제1 데이터 구조의 제2 엔트리의 제1 해시된 사용자 정보를 상기 제2 데이터 구조의 제2 엔트리의 제1 해시된 브리지 정보와 비교하도록 구성되는 연결 서버를 포함한다.In some implementations, the system includes a connection server configured to remove a first entry of the first data structure and a first entry of the second data structure. In some implementations, the system includes a connection server configured to retrieve a second entry of the entries from the first data structure. In some implementations, the system includes a connection server configured to retrieve a second entry of the entries from the second data structure. In some implementations the system further comprises a connection server configured to compare the first hashed user information of the second entry of the first data structure with the first hashed bridge information of the second entry of the second data structure .
일부 구현들에서, 상기 시스템은 상기 제1 데이터 구조의 제2 엔트리의 제1 해시된 사용자 정보와 상기 제2 데이터 구조의 제2 엔트리의 제1 해시된 브리지 정보 간의 미스매칭을 결정하도록 구성되는 연결 서버를 포함한다. 일부 구현들에서, 상기 시스템은 상기 제1 데이터 구조의 제2 엔트리의 제2 해시된 사용자 정보를 상기 제2 데이터 구조의 제2 엔트리의 제2 해시된 브리지 정보와 비교하도록 구성되는 연결 서버를 포함한다. 일부 구현들에서, 상기 시스템은 상기 제1 데이터 구조의 제1 엔트리의 제1 해시된 사용자 정보와 상기 제2 데이터 구조의 제1 엔트리의 제1 해시된 브리지 정보 간의 미스매칭을 결정하도록 구성되는 연결 서버를 포함한다. 일부 구현들에서, 상기 시스템은 상기 제2 데이터 구조의 엔트리들 중 제2 엔트리를 상기 제2 데이터 구조로부터 검색하도록 구성되는 연결 서버를 포함한다. 일부 구현들에서, 상기 시스템은 상기 제1 데이터 구조의 제1 엔트리의 제1 해시된 사용자 정보를 상기 제2 데이터 구조의 제2 엔트리의 제1 해시된 브리지 정보와 비교하도록 구성되는 연결 서버를 포함한다.In some implementations, the system includes a connection configured to determine a mismatch between first hashed user information of a second entry of the first data structure and first hashed bridge information of a second entry of the second data structure, Server. In some implementations, the system includes a connection server configured to compare second hashed user information of a second entry of the first data structure to second hashed bridge information of a second entry of the second data structure do. In some implementations, the system includes a connection configured to determine a mismatch between first hashed user information of a first entry of the first data structure and first hashed bridge information of a first entry of the second data structure Server. In some implementations, the system includes a connection server configured to retrieve a second one of the entries of the second data structure from the second data structure. In some implementations, the system includes a connection server configured to compare first hashed user information of a first entry of the first data structure to first hashed bridge information of a second entry of the second data structure do.
일부 구현들에서, 상기 시스템은 상기 제1 데이터 구조의 제1 엔트리의 제2 해시된 사용자 정보를 상기 제2 데이터 구조의 제2 엔트리의 제2 해시된 브리지 정보와 비교하도록 구성되는 연결 서버를 포함한다. 일부 구현들에서, 상기 시스템은 매칭을 결정하는 것에 응답하여, 제1 링크를 발생시키기 위해 상기 제1 데이터 구조의 제1 엔트리의 사용자 태그와 상기 제2 데이터 구조의 제1 엔트리의 브리지 태그를 링크시키도록 구성되는 연결 서버를 포함한다. 일부 구현들에서, 상기 시스템은 상기 제1 링크를 상기 회사 서버에 제공하도록 구성되는 연결 서버를 포함한다.In some implementations, the system includes a connection server configured to compare second hashed user information of a first entry of the first data structure to second hashed bridge information of a second entry of the second data structure do. In some implementations, the system, in response to determining a match, links a user tag of a first entry of the first data structure and a bridge tag of a first entry of the second data structure to a link And a connection server configured to make the connection request. In some implementations, the system includes a connection server configured to provide the first link to the corporate server.
다른 양태에서, 본 발명은 사용자 식별자들을 링크하는 방법에 관한 것이다. 상기 방법은 엔트리들을 포함하는 제1 데이터 구조를, 연결 서버에 의해 그리고 회사 서버로부터 수신하는 단계를 포함한다. 각 엔트리는 사용자 태그, 제1 해시된 사용자 정보 및 제2 해시된 사용자 정보를 포함하고, 각 엔트리는 클라이언트 디바이스와 관련된다. In another aspect, the invention relates to a method of linking user identifiers. The method includes receiving, by a connection server and from a corporate server, a first data structure comprising entries. Each entry includes a user tag, a first hashed user information, and a second hashed user information, wherein each entry is associated with a client device.
일부 구현들에서, 상기 방법은 엔트리들을 포함하는 제2 데이터 구조를, 연결 서버에 의해 그리고 파트너 서버로부터 수신하는 단계를 포함한다. 각 엔트리는 브리지 태그, 제1 해시된 브리지 정보 및 제2 해시된 브리지 정보를 포함한다. 각 엔트리는 클라이언트 디바이스와 관련된다.In some implementations, the method includes receiving by a connection server and from a partner server a second data structure comprising entries. Each entry includes a bridge tag, a first hashed bridge information, and a second hashed bridge information. Each entry is associated with a client device.
일부 구현들에서, 상기 방법은 상기 제1 데이터 구조 및 상기 제2 데이터 구조에 기초하여 제3 데이터 구조를, 상기 연결 서버에 의해 생성하는 단계를 포함한다. 일부 구현들에서, 상기 방법은 상기 연결 서버에 의해, 상기 제3 데이터 구조를 상기 회사 서버에 제공하는 단계를 포함한다.In some implementations, the method includes generating, by the connection server, a third data structure based on the first data structure and the second data structure. In some implementations, the method includes providing, by the connection server, the third data structure to the company server.
일부 구현들에서, 상기 제1 데이터 구조는 클라이언트 디바이스와 연관된 제1 이메일 주소 및 상기 클라이언트 디바이스와 연관된 제1 전화 번호를 포함한다. 일부 구현들에서, 상기 제2 데이터 구조는 상기 클라이언트 디바이스와 연관된 제2 이메일 주소 및 상기 클라이언트 디바이스와 연관된 제2 전화 번호를 포함한다.In some implementations, the first data structure includes a first email address associated with the client device and a first telephone number associated with the client device. In some implementations, the second data structure includes a second email address associated with the client device and a second telephone number associated with the client device.
다른 양태에서, 본 발명은 사용자 식별자들을 링크하는 시스템에 관한 것이다. 상기 시스템은 연결 서버를 포함하고, 상기 연결 서버는: 엔트리들을 포함하는 제1 데이터 구조를 회사 서버로부터 수신하고, 각 엔트리는 사용자 태그, 제1 해시된 사용자 정보 및 제2 해시된 사용자 정보를 포함하고, 각 엔트리는 클라이언트 디바이스의 사용자와 관련되며; 엔트리들을 포함하는 제2 데이터 구조를 파트너 서버로부터 수신하고, 각 엔트리는 브리지 태그, 제1 해시된 브리지 정보 및 제2 해시된 브리지 정보를 포함하고, 각 엔트리는 클라이언트 디바이스의 사용자와 관련되며; 상기 제1 데이터 구조 및 상기 제2 데이터 구조에 기초하여 제3 데이터 구조를 생성하며; 그리고 상기 제3 데이터 구조를 상기 회사 서버에 제공하도록 구성된다.In another aspect, the invention relates to a system for linking user identifiers. The system comprising a connection server, the connection server comprising: a first data structure comprising: entries from the company server, each entry including a user tag, a first hashed user information and a second hashed user information Each entry associated with a user of the client device; A second data structure comprising entries, each entry comprising a bridge tag, a first hashed bridge information and a second hashed bridge information, each entry being associated with a user of the client device; Generate a third data structure based on the first data structure and the second data structure; And to provide the third data structure to the company server.
일 구현에서, 상기 제1 데이터 구조는 클라이언트 디바이스와 연관된 제1 이메일 주소 및 상기 클라이언트 디바이스와 연관된 제1 전화 번호를 포함하고 그리고 상기 제2 데이터 구조는 상기 클라이언트 디바이스와 연관된 제2 이메일 주소 및 상기 클라이언트 디바이스와 연관된 제2 전화 번호를 포함한다.In one implementation, the first data structure includes a first email address associated with a client device and a first telephone number associated with the client device, and the second data structure includes a second email address associated with the client device, And a second telephone number associated with the device.
또 다른 양태에서, 본 발명은 데이터 파트너 서버에 의해 수행되는 방법에 관한 것이다. 데이터 파트너 서버는 데이터 파트너 암호화 키(X)를 사용하여 PII 요소들을 암호화하고 데이터 쌍들을 회사 서버에 전송한다. 데이터 쌍들은 브리지 태그와 대응하는 암호화된 PII 요소의 쌍들이다. 데이터 파트너 서버는 회사 서버로부터 제1 세트의 이중 암호화된 데이터를 수신하고, 상기 제1 세트의 이중 암호화된 데이터는, 데이터 파트너 서버가 회사 서버로 전송한 브리지 태그들을 암호화하기 위해 제1 회사 암호화 키를 사용함으로써 그리고 데이터 파트너 서버가 회사 서버로 전송한 암호화된 PII 요소들을 암호화하기 위해 제2의 상이한 회사 암호화 키를 사용함으로써 생성한 것이다. 또한, 데이터 파트너 서버는 회사 서버에서 회사 서버의 PII 요소들을 수신하고, 회사 서버는 제1 및 제2 회사 암호화 키들 (또는 그에 따라 파생된 키들)를 사용하여 암호화하고; 예를 들어, 예를 들어, 회사 서버는 제1 회사 암호화 키 또는 그로부터 파생된 키를 사용하여 내부 사용자 태그들을 암호화할 수 있고, 제2 회사 암호화 키 또는 그로부터 파생된 키를 사용하여 암호화된 회사 PII 요소들을 가질 수있다. 이후, 데이터 파트너 서버는 데이터 서버 암호화 키를 사용하여 암호화된 회사 PII 요소를 암호화하여 제2 세트의 이중 암호화된 데이터 세트를 제공한다. 이후, 데이터 파트너 서버는 매칭하는 암호화 된 PII 요소들과 연관된 암호화된 브리지 태그와 암호화된 사용자 태그의 쌍들을 식별하기 위해 제1 세트 및 제2 세트의 이중 암호화된 데이터를 비교할 수 있다. 브릿지 태그와 사용자 태그가 둘 다 회사 서버의 암호화 키에 의해 암호화되었기 때문에, 데이터 파트너 서버는 원래 브리지 태그 또는 데이터 태그를 복구할 수 없으므로 PII 요소들과 연관된 개인을 식별할 수 없다. 일 구현에서 데이터 파트너 서버는 매칭하는 암호화된 PII 요소들과 연관된 암호화된 브리지 태그들 및 암호화된 사용자 태그들의 세부 정보들을 회사 서버에 보낼 수 있다. 이 양태의 수정에서 회사 서버 및 데이터 파트너 서버의 역할이 상호 교환될 수 있다. 즉, 회사 서버는 회사 요소들만 암호화할 수 있고, 데이터 파트너 서버에 암호화되지 않은 사용자 태그들 및 암호화된 PII 요소 쌍들을 전송할 수 있다.In another aspect, the invention relates to a method performed by a data partner server. The data partner server encrypts the PII elements using the data partner encryption key (X) and sends the data pairs to the corporate server. The data pairs are pairs of bridge tags and corresponding encrypted PII elements. The data partner server receives a first set of double encrypted data from a company server and the first set of dual encrypted data is encrypted with a first company encryption key to encrypt bridge tags transmitted by the data partner server to the corporate server, And by using a second, different company encryption key to encrypt the encrypted PII elements that the data partner server sent to the corporate server. Also, the data partner server receives the PII elements of the corporate server at the corporate server, and the corporate server encrypts using the first and second corporate encryption keys (or derived keys); For example, for example, a company server may encrypt internal user tags using a first company encryption key or a key derived therefrom, and may use a second corporate encryption key, or a key derived therefrom, Elements. The data partner server then encrypts the encrypted company PII element using the data server encryption key to provide a second set of double encrypted data sets. The data partner server may then compare the first set and the second set of double encrypted data to identify pairs of encrypted bridge tags and encrypted user tags associated with the matching encrypted PII elements. Because both the bridge tag and the user tag are encrypted by the corporate server's encryption key, the data partner server can not identify the individual associated with the PII elements because it can not recover the original bridge tag or data tag. In one implementation, the data partner server may send details of the encrypted bridge tags and encrypted user tags associated with the matching encrypted PII elements to the corporate server. In the modification of this aspect, the roles of the company server and the data partner server can be interchanged. That is, the company server can only encrypt company elements and can transmit unencrypted user tags and encrypted PII element pairs to the data partner server.
또 다른 양태에서, 본 발명은 하나 이상의 프로세서에 의해 실행될 때, 하나 이상의 프로세서가 여기에서 서술된 어떤 양태 또는 구현에 따라 방법을 수행하도록 하는 명령어들을 포함하는 컴퓨터 판독가능한 매체(이 양태는 이를 요구하지는 않지만 비 일시적인 컴퓨터 판독가능한 매체일 수 있다)에 관한 것이다. In another aspect, the invention features a computer-readable medium having instructions that, when executed by one or more processors, cause one or more processors to perform the method in accordance with any aspect or implementation described herein, But may be non-transitory computer readable media).
하나 이상의 구현의 세부 사항들은 첨부된 도면들 및 이하의 설명에서 서술된다. 본 개시의 다른 특징들, 양상들 및 장점들은 상세한 설명, 도면들 및 청구 범위로부터 명백해질 것이다.
도 1은 데이터 클린 룸을 사용하여 두 당사자들의 사용자 ID 들 간의 링크를 설정하기 위한 환경의 일 구현의 블록도이다.
도 2는 당사자들이 클라이언트 디바이스로부터 개인 식별 정보(PII) 데이터를 수집하기 위한 환경의 일 구현을 도시한 블록도이다.
도 3a는 일 구현에 따른 클라이언트 디바이스의 블록도이다.
도 3b는 일 구현에 따른 PII 서버의 블록도이다.
도 3c는 일 구현에 따른 연결 서버의 블록도이다.
도 4는 PII 데이터를 수집하는 프로세스의 일부 구현들에서 PII 서버 및 클라이언트 디바이스(들)에 의해 취해진 동작들의 흐름도이다.
도 5는 사용자 태그들 및 브리지 태그들을 링크하기 위한 프로세스의 일부 구현들에서 연결 서버 및 PII 서버에 의해 취해진 동작의 흐름도이다.
도 6은 사용자 태그들 및 브리지 태그들을 링크하는 프로세스의 일부 구현들에서 연결 서버 및 PII 서버에 의해 취해진 동작의 흐름도이다.
도 7은 클린 룸 환경을 사용하지 않고 사용자 태그들 및 브리지 태그들을 링크하는 프로세스의 일부 구현들에서 PII 서버들에 의해 취해진 동작들의 흐름도이다.
다양한 도면들에서 동일한 참조 번호들 및 명칭들은 동일한 요소들을 나타낸다.The details of one or more implementations are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the present disclosure will become apparent from the description, drawings, and claims.
1 is a block diagram of one implementation of an environment for establishing a link between user identities of two parties using a data clean room.
2 is a block diagram illustrating one implementation of an environment for parties to collect personally identifiable information (PII) data from a client device.
3A is a block diagram of a client device in accordance with one implementation.
3B is a block diagram of a PII server according to one implementation.
3C is a block diagram of a connection server according to one implementation.
4 is a flow diagram of the operations taken by the PII server and client device (s) in some implementations of the process of collecting PII data.
5 is a flow diagram of operations taken by the connection server and the PII server in some implementations of the process for linking user tags and bridge tags.
6 is a flow diagram of operations taken by the connection server and the PII server in some implementations of the process of linking user tags and bridge tags.
Figure 7 is a flow diagram of operations taken by PII servers in some implementations of the process of linking user tags and bridge tags without using a clean room environment.
In the various figures, like reference numerals and names denote like elements.
본 발명의 실시예들은, 예컨대 컨텐츠를 보거나 거래를 행하기 위해 비지니스 웹 사이트를 방문하는 사용자들에 의해 공유되는 개인 식별 정보(PII)를 저장하는 예들을 참조하여 설명될 것이다. 기업은 이 정보를 다른 사용자들과 구별되는 사용자 식별자들에 맵핑한다. 일부 경우들에서, 기업은 동일한 사용자에 대한 다른 비즈니스의 PII 데이터에도 액세스할 수 있다. 예를 들어, 자동차 제조업체("회사")는 모회사(parent company)의 웹 사이트에 자동차를 홍보하거나 자회사(subsidiary company)의 웹 사이트에 트럭들을 홍보할 수 있다. 모회사 웹 사이트를 방문하는 사용자는 PII 데이터(예를 들어, 이메일 주소, 전화 번호 등)를 웹 사이트와 공유할 수 있고, 이 웹 사이트에서는 PII 데이터를 여기에서 "사용자 태그(user tag)"로 지칭되는 사용자 식별자에 할당한다. 이 같은 사용자는 트럭들을 홍보하는 제3자 회사("데이터 파트너(data partner")의 웹 사이트를 방문할 수도 있다. 마찬가지로, 데이터 파트너는 사용자의 PII 데이터를 수신하여 여기에서 "브리지 태그(bridge tag)"라고 하는 사용자 식별자에 할당한다. 회사의 사용자 태그와 데이터 파트너의 브리지 태그 사이에 연결을 설정하는 것이 좋다. 그러나, 본 발명은 특히 PII 데이터에 한정되지 않고 다른 유형들의 기밀 정보에도 적용될 수 있다. 예를 들어, 두 조직이 동일한 개인 그룹에 대한 의료 데이터를 보유하고있는 경우, 한 조직이 보유한 데이터와 다른 조직이 보유한 데이터를 연결하는 것이 바람직할 수 있다.Embodiments of the present invention will be described with reference to examples that store personal identification information (PII) that is shared, for example, by users visiting a business web site to view content or conduct transactions. The enterprise maps this information to user identities that are distinct from other users. In some cases, an enterprise may also have access to PII data of other businesses for the same user. For example, a car manufacturer (a "company") can advertise cars on its parent company's website or promote trucks on a subsidiary company's website. A user visiting the parent company website may share PII data (e.g., email address, phone number, etc.) with the website, where the PII data is referred to herein as " user tag " To the user identifier. Such a user may visit a third party company (also referred to as a " data partner ") that promotes trucks. Similarly, the data partner receives the user ' s PII data, ) &Quot;. It is better to establish a connection between the company's user tag and the bridge tag of the data partner. However, the present invention is not limited to PII data in particular, but can be applied to other types of confidential information For example, if two organizations have medical data for the same individual group, it may be desirable to link the data held by one organization with the data held by another organization.
연결을 설정하는 한 가지 방법은, 해시된 PII 데이터와 쌍을 이루는 브리지 태그를 데이터 파트너가 회사에 제공하는 것이다. 암호 해싱 함수들을 포함하는 많은 해싱 함수들은, 해시된 데이터가 반드시 해당 입력 데이터를 소유하지 않도록 실질적으로 반전 불가능(즉, 비가역적)하도록 설계된다. 해시된 PII 데이터는 해시 함수를 PII 데이터에 적용한 결과로, PII 데이터 자체를 드러내지 않고도 PII 데이터 요소를 비교할 수 있다. 일부 구현들에서, 데이터 파트너는 사용자를 식별하는 브리지 태그 및 사용자의 이메일 주소의 해시된 값을 제공할 수 있다. 회사는 데이터 파트너의 해시된 PII 데이터를 회사의 해쉬된 PII 데이터와 비교하여 사용자 태그와 브리지 태그 사이에 링크를 설정한다. 이 접근법은 사용자의 이메일 주소에만 기반하여 사용자 태그와 브리지 태그를 일치시키는 경우와 같이 단일 PII 데이터 요소만 사용할 때 잘 작동한다. One way to establish a connection is for a data partner to provide the company with a bridge tag that pairs with the hashed PII data. Many hashing functions, including cryptographic hashing functions, are designed to be substantially non-reversible (i.e., irreversible) such that the hashed data does not necessarily possess the corresponding input data. The hashed PII data is the result of applying the hash function to the PII data, so that the PII data elements can be compared without revealing the PII data itself. In some implementations, the data partner may provide a hashed value of the user ' s email address and a bridge tag that identifies the user. The company compares the hashed PII data of the data partner with the hashed PII data of the company and establishes a link between the user tag and the bridge tag. This approach works well when using only a single PII data element, such as matching a user tag with a bridge tag based solely on the user's email address.
그러나, 다수의 PII 데이터 요소들(예를 들어, 사용자의 이메일 및 전화 번호)를 일치시키려면 데이터 파트너가 해시된 이메일과 해시된 전화 번호와 쌍을 이루는 브리지 태그를 회사에 제공해야 한다. 결과적으로, 이는 회사 내부의 데이터 연결이 드러나게 한다. 즉, 이는 데이터 파트너의 이메일 주소를 데이터 파트너의 사용자들에 대한 전화 번호 링크로 나타낸다. 이러한 방식으로, 여러 PII 데이터를 일치시키기 위해 회사와 데이터 파트너 간에 정보를 공유하면, PII 데이터에 링크 된 특정 사용자의 신원을 나타낼 수 있는 충분한 정보를 얻을 수 있다.However, to match a number of PII data elements (e.g., a user's email and phone number), the data partner must provide the company with a bridge tag that pairs the hashed email with the hashed phone number. As a result, this exposes the data connection inside the company. That is, it represents the email address of the data partner as a phone number link to the users of the data partner. In this way, sharing information between a company and a data partner to match multiple PII data can provide enough information to represent the identity of a particular user linked to the PII data.
따라서, 본 발명은, 한 당사자의 PII 데이터 맵을 다른 당사자에게 공개하지 않고, 두 당사자들의 사용자 ID들 사이에 링크를 설정하는 (예를 들어, 회사의 사용자 태그와 데이터 파트너의 브리지 태그 사이의 링크를 설정하는) 시스템 및 방법에 관한 것이다. 시스템 및 방법은 PII 데이터가 다중 PII 데이터 요소를 포함하는 경우뿐만 아니라 PII 데이터가 단일 PII 데이터 요소를 포함하는 경우에도 적용될 수 있다. 일부 구현들에서, 서술된 시스템들 및 방법들은 독립적인 또는 중립적인 중재자, 예를 들어 클린 룸 또는 클린 룸 환경에서 작동하는 하나 이상의 서버들을 사용한다. 일부 구현들에서, 서술된 시스템들 및 방법들은 반드시 클린 룸을 통해 라우팅되는 것은 아니라 암호화된 피어-투-피어 통신과 같은 암호화된 직접 통신들을 사용한다.Therefore, the present invention is not limited to a method of establishing a link between user IDs of two parties without disclosing the PII data map of one party to the other party (for example, linking between a user tag of a company and a bridge tag of a data partner To a system and method. The system and method may be applied not only where the PII data includes multiple PII data elements but also where the PII data includes a single PII data element. In some implementations, the described systems and methods use an independent or neutral mediator, e.g., one or more servers operating in a clean room or clean room environment. In some implementations, the described systems and methods are not necessarily routed through a clean room, but rather use encrypted direct communications such as encrypted peer-to-peer communications.
도 1은 데이터 클린 룸을 사용하여 두 당사자들의 사용자 아이디(ID) 간의 링크를 설정하기 위한 환경(100)의 일 구현을 도시한 블록도이다. 일반적으로, 여기에서 논의된 시스템 및 방법은 두 당사자들(예를 들어, 회사 및 데이터 파트너)이 각각의 사용자 ID-PII 데이터 맵을 "클린 룸(clean room)" 환경으로 지칭되는 데이터 환경에서 독립적으로 작동하는 서버와 공유하게 한다. 클린 룸 환경은 당사자들의 활동으로부터 격리된 별도의 물리적이며 안전한 장소이며, 인가된 개인들(당사자 중 어느 한 곳과도 관련되지 않음)만이 민감한 데이터 또는 당사자들로부터 받은 정보를 처리할 수 있다. 이 구현에서 각 사용자의 신원을 더 보호하기 위해, 당사자들은 사용자 ID-PII 맵들을 데이터 클린 룸 환경과 공유하기 전에 각 사용자와 연관된 PII 데이터를 해시한다. 클린 룸의 제3자 서버는 회사 사용자 태그들과 데이터 파트너의 브리지 태그들 사이에 링크를 설정하여 일반 사용자를 식별하도록 회사 사용자들의 해시된 PII 데이터를 데이터 파트너의 사용자들의 해시된 PII 데이터와 매칭한다. 클린 룸 환경은 당사자들의 활동들 분리되어 있으므로, 클린 룸의 제3자 서버는 데이터 파트너 및 회사(데이터 파트너 서버 및 회사 서버)의 제어 및 운영과 독립적이다. 일 구현에서, 회사는 회사 웹 사이트를 방문한 사용자들과 관련된 이메일 주소들 및 전화 번호들을 수집하여 콘텐츠를 보거나 회사 물품들을 구매할 수 있다. 마찬가지로, 데이터 파트너는 비슷한 이유들로 같은 웹 사이트를 방문하는 사용자들과 관련된 이메일 주소들 및 전화 번호들을 수집할 수 있다. 이후, 제3자 서버가, 예를 들어, 워터폴 접근법(waterfall approach)에 기초하여 공통 사용자들을 식별하고, 각 공통 사용자에 대해 회사의 사용자 ID("사용자 태그")와 데이터 파트너의 사용자 ID("브리지 태그")를 링크하며 그리고 데이터 파트너의 PII 연결(예를 들어, 특정 이메일 주소와 특정 전화 번호의 연결)을 회사에 공개하지 않고 회사에 연결을 제공하는, 데이터 클린 룸으로 제3자는 수집된 PII 데이터를 보낸다. 일부 구현들에서, 링크들이 회사 및 데이터 파트너에게 제공된다. 일부 구현들에서, 링크들이 클린 룸에 저장되고 그리고 당사자들은 링크들을 검색하기 위해 물리적으로 클린 룸에 방문해야 한다.1 is a block diagram illustrating one implementation of an
보다 상세하게는, 환경(100)은 회사(116), 데이터 파트너(132) 및 클린 룸(102)을 포함한다. 회사(116)는 사용자 태그(UT) PII 맵핑(122)을 클린 룸(102)의 시스템들(예를 들어, 연결 서버(104))에 전달하기 위한 PII 서버(118a)("회사 서버"로 언급됨)을 포함한다. 회사(116)는 또한 UT PII 맵핑(122)을 저장하기 위한 UT PII 맵핑 스토리지(120)를 포함한다. 데이터 파트너(132)는, 클린 룸(102) 내의 시스템들(예컨대, 연결 서버(104))에 브리지 태그들(BT) PII 맵핑(144)을 전달하기위한 PII 서버(118)("파트너 서버") 및 BT PII 맵핑(144)을 저장하기 위한 BT PII 맵핑 스토리지(134)를 포함한다. More specifically, the
클린 룸(102)은, (1) UT PII 맵핑(122) 및 BT PII 맵핑(144)에 기초하여 링크들(124)을 생성하고, 그리고 (2) 링크들(124)을 회사(116)에 제공하기 위한 연결 서버(104)를 포함한다. 클린 룸(102)은 또한 UT PII 맵핑(122) 및 BT PII 맵핑(144) 모두를 저장하기 위한 PII 맵핑 저장 장치(106)를 포함한다. 클린 룸(102)은 또한 링크들(124)을 저장하기 위한 연결 저장 장치(108)를 포함한다. 환경(100)은 하나 이상의 PII 서버들(118a)을 갖는 다수의 회사들(116), 하나 이상의 PII 서버들(118b)을 갖는 다수의 데이터 파트너들(132) 및 하나 이상의 연결 서버들(104)을 갖는 다수의 클린 룸들(102)을 포함할 수 있다. 도시되지는 않았지만, 일부 구현들에서, 회사(116) 및 데이터 파트너(132)는 네트워크 게이트웨이, 네트워크 라우터, 네트워크 방화벽, 네트워크 스위치, 네트워크 가속기, Wi-Fi 액세스 포인트들 또는 핫 스폿들, 또는 다른 디바이스들을 통해 클린 룸(102)과 통신한다.The clean room 102 is configured to generate links 124 based on (1) UT PII mapping 122 and BT PII mapping 144 and (2) link 124 to company 116 And a connection server 104 for providing the connection request. The clean room 102 also includes a
PII 서버들(118a, 118b)은 하나 이상의 클라이언트 디바이스의 사용자와 관련된 개인 식별가능한 정보(PII)를 수집할 수 있다. 일 구현들에서, PII 데이터는 사용자의 이름, 이메일 주소, 전화 번호, 청구서 정보, 주소, 시민권, 생체 인식, 재정 정보, 운전 면허증 및 기타 정부 식별 번호들, 생일, 출생지, 고용 기록, 가족력, 병력, 지리적 이력, 사회 보장 번호들, 세금 식별 번호들, 의료 식별 번호들 및 디바이스 정보(예를 들어, MAC(Media Access Control) 주소, 장치 ID(314), 세션 ID(316), 및 도 3에 도시된 수집 에이전트(312)에 의해 인터셉트될 수 있는 임의의 다른 정보)로 부터 선택된, 2개 이상의 PII 데이터 요소들(또는 원칙적으로 하나의 PII 데이터 요소)를 포함할 수 있다. PII 서버들(118a, 118b)은 클라이언트 디바이스의 각각의 식별된 사용자에게 사용자 식별자를 할당할 수 있다. 일 구현에서, PII 서버(118a)는 컴퓨팅 디바이스들, 서버들, 디스크 드라이브들, 또는 회사 (116)에 의해 소유, 운영 또는 제휴된 웹 페이지들에 접속하거나 통신하는 클라이언트 디바이스의 각 사용자에게 "사용자 태그(user tag)"를 할당한다. 유사하게, PII 서버(118b)는 컴퓨팅 디바이스들, 서버들, 디스크 드라이브들, 또는 데이터 파트너(132)에 의해 소유, 운영 또는 제휴된 웹 페이지들에 접속하거나 통신하는 클라이언트 디바이스의 각 사용자에게 "브리지 태그(bridge tag)"를 할당한다.The
일부 구현들에서, 사용자 ID(예를 들어, 사용자 태그 또는 브리지 태그)에 할당된 사용자는 둘 이상의 클라이언트 디바이스와 연관될 수 있다. 일부 구현들에서, 사용자 ID에 할당된 사용자는 단일 클라이언트 장치에만 연관될 수 있다. PII 서버들(118a, 118b)은 주기적으로 사용자 태그 및 브리지 태그를 검토하여 클라이언트 장치의 비활성 또는 감소된 활동에 기초하여 클라이언트 디바이스의 사용자로부터 사용자 태그 및 브리지 태그의 할당 해제 여부를 액세스할 수 있다. 일 구현에서, PII 서버(118a)는 미리 결정된 양의 시간보다 길게 PII 서버(118a)와 통신하지 않은 클라이언트 디바이스로부터 사용자 태그를 할당 해제할 수 있다.In some implementations, a user assigned to a user ID (e.g., a user tag or a bridge tag) may be associated with more than one client device. In some implementations, a user assigned to a user ID may only be associated with a single client device. The
PII 서버(118a)는 데이터 구조(126)에 의해 예시된 바와 같이 데이터 구조 포맷으로 사용자 태그(UT) PII 맵핑 저장 장치(120)에 각 사용자에 대한 수집된 PII 데이터 및 대응하는 사용자 태그들을 저장한다. 데이터 구조(126)는 PII 데이터에 대한 사용자 태그들의 맵핑을 도시한다. 각 엔트리(127, 128, 129, 130, 131)는 하나 이상의 클라이언트 디바이스들에 대한 상이한 사용자를 나타낸다. "맵핑(mapping) #"이라는 칼럼은 각 항목의 번호를 나타내고, "사용자 태그(user tag)"라는 칼럼은 PII 서버(118a)가 그 특정 사용자에게 할당한 사용자 태그를 나타내고, "이메일 주소(email address)"라는 칼럼은 특정 사용자에 대한 이메일 주소를 나타내며, 그리고 "전화(phone) #"이라는 칼럼은 특정 사용자에 대한 전화 번호를 나타낸다. 2개의 PII 데이터 칼럼들(예를 들어, 이메일 주소 및 전화 #) 및 5 개의 엔트리들(즉, 5명의 사용자를 나타냄)로만 도시되었지만, 데이터 구조(126)는 임의의 수의 PII 데이터 칼럼들 및 임의의 번호 엔트리들을 포함할 수 있다.
PII 서버(118b)는 데이터 구조(136)에 의해 예시된 바와 같은 데이터 구조 포맷으로 브리지 태그(BT) PII 맵핑 저장 장치(134)에 각 사용자에 대한 수집된 PII 데이터 및 대응하는 브리지 태그를 저장한다. 데이터 구조(136)는 PII 데이터에 대한 브리지 태그들의 맵핑을 도시한다. 각 엔트리(138, 139, 140, 141, 142)는 하나 이상의 클라이언트 디바이스들에 대한 상이한 사용자를 나타낸다. "맵핑 #"이라는 칼럼은 각 엔트리의 번호를 나타내고, "브리지 태그"라는 칼럼은 PII 서버( 118b)가 특정 사용자에게 할당한 브리지 태그를 나타내고, "이메일 주소"라는 칼럼은 특정 사용자의 이메일 주소를 나타내고, 그리고 "전화 #"이라는 칼럼은 특정 사용자의 전화 번호를 나타낸다. 단지 2개의 PII 칼럼들(예를 들어, 이메일 주소 및 전화 #) 및 5개의 엔트리들(즉, 5명의 사용자를 나타냄)로 도시되어 있지만, 데이터 구조(136)는 임의의 수의 PII 데이터 칼럼들 및 임의의 수의 사용자들을 포함할 수 있다. 또한, 비록 데이터 구조들(126 및 136)이 서로 동일한 데이터 요소들을 갖는 것으로 도시되어 있지만, 데이터 구조(136)는 데이터 구조들이 하나 이상의 요소를 공유하는 경우 데이터 구조(126)와 동일한 데이터 요소를 가질 필요는 없다.
PII 서버들(118a, 118b)은 회사(116)의 사용자들 및 데이터 파트너(132)의 사용자들의 프라이버시를 보호하기 위한 단계들을 행할 수 있다. 일부 구현들에서, PII 서버들(118a, 118b)은 각각 그들의 각각의 사용자들과 관련된 수집된 PII 데이터에 암호화 해싱 함수를 적용한다. 일 구현에서, PII 서버(118a)는 데이터 구조 (126)의 엔트리(127)에 맵핑된 이메일 주소를 (예를 들어, UT PII 맵핑 저장 장치(120)로부터)검색하고, 검색된 값을 해시하며, 그리고 저장된 이메일 주소를 해시 값 등가물로 덮어쓸 수 있다. 이후, PII 서버(118a)는 데이터 구조(126)의 엔트리(127)에 맵핑된 전화 번호를 (예를 들어, UT PII 맵핑 저장 장치(120)로부터) 검색하고, 검색된 값을 해시하며, 그리고 저장된 전화 번호를 해시 값 등가물로 덮어쓸 수 있다. PII 서버(118a)는 UT PII 맵핑 스토리지(120) 내의 각 엔트리에 대한 프로세스를 반복할 수 있다. PII 서버(118b)는 BT PII 맵핑 저장 장치(134)에 저장된 데이터에 대해 동일한 해싱 루틴을 실행할 수 있다. 일부 구현들에서, PII 서버들(118a, 118b)은 암호화 해싱 함수들을 지원한다. 일부 구현들에서, PII 서버들(118a, 118b)은 예를 들어 HMAC, SHA-1, SHA-2, SHA-3, MD2, MD4 및 MD5를 포함하는 다양한 해시 함수 알고리즘을 지원한다. 연결 서버(104)가 공통 사용자를 식별할 수 있도록, 회사(116) 및 데이터 파트너(132)는 각 데이터의 각각을 해시하기 위해 동일한 해싱 함수를 사용한다. 일부 구현들에서, 당사자들은 업계에서 일반적으로 허용되는 기본 해싱 함수를 사용한다. 일부 구현들에서, 당사자들(예를 들어, 회사(116) 및 데이터 파트너(132))은 연결 서버(104)와 그들의 데이터를 공유하기 전에 사용할 특정 해싱 함수에 동의하기 위해 서로 통신한다.The
PII 서버(118a)는 수집된 PII 데이터 및 대응하는 사용자 태그들을 회사(116)로부터 클린 룸(102)으로 전달하기 위해 클린 룸(102)(예를 들어, 연결 서버(104)) 내의 시스템으로부터 요청을 수신할 수 있다. 요청에 응답하여, PII 서버(118a)는 UT PII 맵핑 저장 장치(120)로부터 데이터 구조(126)를 검색하고 검색된 데이터(예를 들어, UT PII 맵핑(122))를 연결 서버(104)로 전송한다. 일부 구현들에서, PII 서버(118a)는 UT PII 맵핑(122)을 PII 맵핑 저장 장치(106)에 전달할 수 있다. 일부 구현들에서, PII 서버(118a)는 연결 서버(104)로부터의 요청을 수신하지 않고 UT PII 맵핑(122)을 연결 서버(104)에 주기적으로 (예를 들어 매분, 시간, 일, 주, 월 또는 이들의 조합으로) 송신한다.The
PII 서버(118b)는 수집된 PII 데이터 및 대응하는 브리지 태그들을 데이터 파트너(132)로부터 클린 룸(102)으로 전달하기 위해 클린 룸(예를 들어, 연결 서버(104)) 내의 시스템으로부터 요청을 수신할 수 있다. 요청에 응답하여, PII 서버 (118b)는 BT PII 맵핑 저장 장치(134)로부터 데이터 구조(136)를 검색하고 그리고 검색된 데이터(예를 들어, BT PII 맵핑(144))를 연결 서버(104)로 전송한다. 일부 구현들에서, PII 서버(118b)는 BT PII 맵핑(144)을 PII 맵핑 저장 장치(106)에 전달할 수 있다. 일부 구현들에서, PII 서버(118b)는 연결 서버(104)로부터의 요청을 수신하지 않고 BT PII 맵핑(144)을 연결 서버(104)에 주기적으로 (예를 들어 매분, 시간, 일, 주, 월 또는 이들의 조합으로) 송신한다.
연결 서버(104)는 워터폴 접근법을 이용하여 사용자 태그들과 브리지 태그들 사이의 링크들을 설정한다. 워터폴 접근법은 먼저 UT PII 맵핑(122)의 각 사용자와 연관된 제1 유형(예를 들어, 이메일 어드레스)의 해시된 PII 데이터를 BT PII 맵핑 (144)의 각 사용자와 연관된 동일한 유형(예를 들어, 이메일 어드레스)의 해싱된 PII 데이터와 비교한다. 연결 서버(104)는 사용자 태그들 및 브리지 태그들을 데이터베이스(예를 들어, 링크 저장 장치(108))에 저장함으로써 매칭하는 PII 데이터와 연관된 사용자 태그들 및 브리지 태그들을 링크한다. 매치를 식별하는 것에 응답하여, 연결 서버(104)는 (PII 맵핑 저장 장치(106)로부터) 사용자 태그 및 모든 관련 PII 데이터 및 브리지 태그 및 모든 관련된 PII 데이터를 제거한다. 연결 서버(104)가 특정 유형(예를 들어, 이메일 주소)의 모든 해싱된 PII 데이터를 비교한 후, 연결 서버(104)는 UT PII 맵핑(122)의 각 사용자와 연관된 제2 유형(예를 들어, 전화 번호)의 해싱된 PII 데이터를 BT PII 맵핑(144)의 각 사용자와 연관된 동일한 유형(예: 전화 번호)의 해싱된 PII 데이터와 비교한다. 연결 서버(104)는 모든 PII 유형들이 비교될 때까지 비교 및 제거 프로세스를 계속한다. 워터폴 접근법은 모든 유형의 PII 데이터를 임의의 순서로 비교할 수 있다. 일 구현에서, 연결 서버(104)는 해시된 이메일 주소, 이후 해시된 전화 번호들, 그리고 이후 해시된 사회 보장 번호들을 비교할 수 있다. 일 구현에서, 연결 서버(104)는 해시된 전화 번호들, 이후 해시된 사회 보장 번호들 그리고 이후 해시된 이메일 주소들을 비교할 수 있다. 일부 구현들에서, 워터폴 접근법은 미가공의 해쉬되지 않은 PII 데이터를 비교할 수 있다. 일부 구현들에서, 워터폴 접근법은 암호화된 PII 데이터를 비교할 수 있다. PII 데이터는, 예를 들어, 트리플 DES(Data Encryption Standard), RSA, 블로피시(blowfish), 투피쉬(twofish) 또는 AES(Advanced Encryption Standard)와 같은 암호화 알고리즘의 버전을 사용하여 암호화될 수 있다.Connection server 104 establishes links between user tags and bridge tags using a waterfall approach. The waterfall approach first associates the hashed PII data of the first type (e.g., e-mail address) associated with each user of the UT PII mapping 122 with the same type associated with each user of the BT PII mapping 144 , E-mail address). Connection server 104 links user tags and bridge tags associated with matching PII data by storing user tags and bridge tags in a database (e.g., link storage device 108). In response to identifying the match, connection server 104 removes (from PII mapping storage device 106) the user tag and all associated PII data and bridge tags and all associated PII data. After the connection server 104 compares all hashed PII data of a particular type (e. G., E-mail address), the connection server 104 sends a second type (E.g., telephone number) of hashed PII data of the same type (e.g., telephone number) associated with each user of the BT PII mapping 144. Connection server 104 continues the comparison and removal process until all PII types are compared. The waterfall approach can compare any type of PII data in any order. In one implementation, the connection server 104 may compare the hashed email address, the hashed phone numbers thereafter, and the hashed social security numbers thereafter. In one implementation, connection server 104 may compare hashed phone numbers, then hashed social security numbers, and then hashed email addresses. In some implementations, the waterfall approach may compare raw unshielded PII data. In some implementations, the waterfall approach may compare encrypted PII data. PII data may be encrypted using a version of a cryptographic algorithm such as, for example, a Triple DES (Data Encryption Standard), RSA, Blowfish, Twofish, or Advanced Encryption Standard (AES).
워터폴 접근법은 도 1의 데이터 구조들(110, 126, 136)을 참조함으로서 보다 상세하게 서술될 수 있다. 일 구현에서, 연결 서버(104)는, 데이터 구조(126) 내의 제1 사용자에 대응하는 엔트리(127)로부터의 해싱된 이메일 주소(예를 들어, cat@email.com) 및 데이터 구조(136)의 제1 사용자에 대응하는 엔트리(138)로부터의 해싱된 이메일 주소(예를 들어, snake@email.com)를 검색한다. 연결 서버(104)는 검색된 해싱된 값을 비교하여 검색된 값이 매칭하는지를 결정한다. cat@email.com은 snake@email.com과 일치하지 않기 때문에, 연결 서버(104)는 데이터 구조(136) 내의 제2 사용자에 대응하는 엔트리(139)로부터 해시된 이메일 주소 (예를 들어, bird@email.com)를 검색한다. 검색된 값들을 비교함으로써, 연결 서버 (104)는 cat@email.com이 bird@email.com과 매칭하지 않는다고 결정한다. 미스매칭에 응답하여, 연결 서버(104)는 데이터 구조(136)의 제3 사용자에 대응하는 엔트리 (140)로부터 해싱된 이메일 주소(예를 들어, cat@email.com)를 검색한다. 연결 서버(104)는 두 값들을 비교하여 매칭을 결정하고, 그리고 그 매칭에 응답하여, 연결 서버(104)는 데이터 구조(126) 내의 제1 사용자에 대응하는 엔트리(127) 내의 사용자 태그(예컨대, 9288)와 데이터 구조(136) 내의 제3 사용자에 대응하는 엔트리 (140) 내의 사용자 태그(예를 들어, 4263) 사이의 링크를 설정한다. 연결 서버(104)는 데이터 구조(110)를 생성하고 그리고 데이터 구조(110)를 링크 저장 장치(108)에 저장함으로써 링크를 설정한다.The waterfall approach can be described in more detail by referring to the
일단 연결 서버(104)가 해시된 이메일 주소에 기초하여 데이터 구조(126)의 모든 엔트리들을 데이터 구조(136)와 비교(및 매칭을 시도)하면, 연결 서버는 해시 된 전화 번호와 같은 다른 데이터 요소를 사용하여 비교/매칭 프로세스를 반복한다. 일 구현에서, 연결 서버(104)는, 데이터 구조(126) 내의 제2 사용자에 대응하는 엔트리(128)로부터 해시된 전화 번호(예를 들어, 555-0140) 및 데이터 구조(136) 내의 제1 사용자에 대응하는 엔트리(138)로부터 해시된 전화 번호(예를 들어, 555-9160)를 검색한다. 연결 서버(104)는 각 검색된 해싱된 값을 비교하여 검색된 값이 매칭하는지를 결정한다. '555-0140'이 '555-9106'과 매칭하지 않았기 때문에, 연결 서버(104)는 데이터 구조(136)의 엔트리(139)로부터 다음 해시된 전화 번호(예를 들어, 555-8136)를 검색한다. 결국, 연결 서버는 데이터 구조(126)의 제2 사용자에 대응하는 엔트리(128)와 데이터 구조(136)의 제5 사용자에 대응하는 엔트리(142) 사이의 매칭을 발견한다. 각 사용자와 관련된 다수의 PII 데이터를 비교함으로써, 연결 서버(104)는 모든 공통 사용자들을 성공적으로 식별한다. 일 구현에서, 연결 서버(104)는 이 사용자가 2개의 상이한 이메일 주소(예를 들어, dogl@email.com 및 dog2@email.com)를 갖는 것처럼 보이기 때문에 데이터 구조(126)의 제2 사용자 및 데이터 구조(136)의 제5 사용자가 참으로 동일한 사용자임을 발견하지 못했다. 그러나 연결 서버(104)는 각 사용자에 대한 다중 PII 데이터(이메일 주소 및 전화 번호)를 비교할 때 성공적으로 매칭한다.Once the connection server 104 has compared (and attempted to match) all the entries of the
연결 서버(104)는 데이터 구조 포맷(예를 들어, 데이터 구조(110))으로 링크들(124)을 생성하고 링크 저장 장치(108)에 저장함으로써 회사(116) 및 데이터 파트너(132)의 사용자 신원들을 링크한다. 일 구현에서, 데이터 구조(110)는 회사(116)의 사용자 태그들 및 데이터 파트너(132)의 브리지 태그들의 맵핑을 도시한다. 각 엔트리(111, 112, 113, 114, 115)는 하나 이상의 클라이언트 디바이스들에 대한 상이한 사용자를 나타낸다. "linkage #"이라는 칼럼은 각 항목의 번호를 나타내고, "사용자 태그(user tag)"라는 칼럼은 PII 서버(118a)가 그 특정 사용자에게 할당한 사용자 태그를 나타내며, "브리지 태그"라는 칼럼은 PII 서버(118b)가 그 특정 사용자에게 할당한 브리지 태그를 나타낸다. 단지 2개의 사용자 식별 칼럼들 (예를 들어, 사용자 태그 및 브리지 태그) 및 5개의 엔트리들(즉, 5명의 사용자)로 도시되었지만, 데이터 구조(110)는 임의의 수의 사용자 식별 칼럼들(즉, 다수의 데이터 파트너들(132) 및 다수의 회사들(116)로부터의 사용자 식별들의 매칭을 나타냄) 및 임의의 수의 엔트리들을 포함할 수 있다.Connection server 104 creates links 124 in a data structure format (e.g., data structure 110) and stores them in
연결 서버(104)는 링크들(124)을 회사(116)로 보낸다. 링크(124)가 사용자 태그들을 브리지 태그들과 일치시키는 것을 나타내지만, 데이터 파트너의 PII 연결들(예를 들어, 이메일 주소를 전화 번호로, 이메일 주소를 세금 ID, 전화 번호를 사회 보장 번호로)을 회사(116)에 공개하지 않는다. 일부 구현들에서, 회사(116)는 데이터 파트너(132)의 PII 링크들을 나타내기 위해 링크들(124)을 암호화 해제할 수 있다. 일부 구현들에서, 연결 서버(104)는 링크들(124)을 회사(116) 및 데이터 파트너(132)에 전송한다. 일부 구현들에서, 연결 서버(104)는 링크들(124) 만을 링크 저장 장치(108)에 저장한다. 일부 구현들에서, 연결 서버(104)가 링크들(124)을 적절한 당사자(예를 들어, 회사(116), 데이터 파트너(132) 또는 둘 모두)에 전송한 후, 연결 서버(104)는 링크 저장 장치(108) 및 PII 맵핑 저장 장치(106)로부터 모든 콘텐츠를 삭제한다.The connection server 104 sends the links 124 to the company 116. Although link 124 indicates matching user tags with bridge tags, PII connections (e.g., email address to phone number, email address to tax ID, phone number to social security number) To the company (116). In some implementations, the company 116 may decrypt the links 124 to represent the PII links of the data partner 132. In some implementations, connection server 104 sends links 124 to company 116 and data partner 132. In some implementations, the connection server 104 stores only the links 124 in the
일부 구현들에서, PII 서버들(118a, 118b) 및 연결 서버(104)는, 어레이, 링크된 목록, 레코드, 공용체(union), 태그가 지정된 공용체, 클래스, 트리 및 큐와 같은 대체 데이터 구조 유형을 사용하여 각각의 데이터 구조들(110, 126, 136)을 생성한다. 따라서, 연결 서버(104)는 이들 데이터 구조 유형들 중 임의의 것을 사용하여 회사(116)의 사용자 태그와 데이터 파트너(132)의 브리지 태그들 사이에 링크를 설정할 수 있다.In some implementations, the
도 2는 클라이언트 디바이스로부터 PII 데이터를 수집하는 당사자를 위한 환경(200)의 일 구현의 블록도이다. 환경(200)은, 네트워크(202), 예를 들어, 클라이언트 디바이스(204)를 회사(116) 및 데이터 파트너(132)와 연결하는 근거리 통신망 (LAN), 광역 네트워크(WAN), 인터넷, 블루투스 네트워크, 또는 이들 또는 다른 네트워크들의 조합을 포함할 수 있다. 일부 구현들에서, 데이터는 예를 들어 개방 시스템 상호 접속("OSI") 계층에 따른 데이터 패킷들의 형태로 데이터 패킷의 흐름으로서 소스 노드에서 목적지 노드로 네트워크(202)를 통해 흐른다. 패킷들의 흐름은, 인터넷 프로토콜("IP"), 예컨대 IPv4 또는 IPv6과 같은 OSI 계층-3 네트워크 프로토콜을 통해 계층화된 네트워크(202)를 통해 전송되는, 예를 들어, 사용자 데이터그램 프로토콜("UDP"), 전송 제어 프로토콜("TCP") 또는 스트림 제어 전송 프로토콜 ("SCTP")과 같은 OSI 계층-4 전송 프로토콜을 사용할 수 있다. 환경(200)은, 예를 들어, 클라이언트 디바이스들(204), 회사들(116) 및 데이터 파트너들(132)을 포함하는 수천 개의 노드들을 포함할 수 있다. 도시되지는 않았지만, 많은 구현들에서, 네트워크(202)는 게이트웨이들, 라우터들, 방화벽들, 스위치들, 네트워크 가속기들, Wi-Fi 액세스 포인트 또는 핫 스폿들, 또는 다른 디바이스들을 포함하는 하나 이상의 중간 디바이스들을 포함할 수 있다.2 is a block diagram of one implementation of an
클라이언트 디바이스(204)는 사용자의 제어하에 있고 개인 식별 정보(PII)에 대한 요청들을 수신할 수 있고 네트워크(202)를 통해 PII 데이터를 송신할 수 있는 전자 디바이스이다. 클라이언트 디바이스(204)는, 개인용 컴퓨터, 랩톱 컴퓨터, 데스크탑 컴퓨터, 모바일 컴퓨터, 태블릿 컴퓨터, 스마트폰, 디지털 비디오 레코더, 텔레비전 용 셋톱 박스, 비디오 게임 콘솔, 또는 임의의 다른 유형 및 형태의 컴퓨팅 디바이스 또는 디바이스들의 조합들을 포함하는(이에 제한되지는 않음) 네트워크(202)를 통해 통신하도록 구성된 임의의 수의 상이한 유형들의 사용자 전자 디바이스들일 수 있다. 일부 구현들에서, 클라이언트 디바이스(204)의 유형은 모바일 디바이스, 데스크탑 디바이스, 고정된 상태로 유지되는 디바이스, 로컬 영역 네트워크(예를 들어, 네트워크(202))를 통해 네트워크에 주로 액세스하도록 구성된 디바이스, 또는 미디어 소비 디바이스와 같은 전자 장치의 또 다른 카테고리로 카테고리화될 수 있다. 클라이언트 디바이스(204)는 네트워크(202)를 통해 데이터의 송신 및 수신을 용이하게하기 위해 사용자 애플리케이션, 예를 들어, 웹 브라우저를 포함한다.The client device 204 is an electronic device under the control of the user and capable of receiving requests for personal identification information (PII) and transmitting PII data over the
도 3a는 클라이언트의 클라이언트 디바이스(204)의 일 구현의 블록도이다. 클라이언트 디바이스(204)는 프로세서(306) 및 메모리(302)를 포함한다. 메모리 (302)는, 프로세서(306)에 의해 실행될 때, 프로세서(306)로 하여금 여기에 서술된 하나 이상의 동작을 수행하도록 하는 기계 명령어들을 저장할 수 있다. 프로세서 (306)는 마이크로 프로세서, ASIC, FPGA 등, 또는 이들의 조합을 포함할 수 있다. 많은 구현들에서, 프로세서(306)는 멀티 코어 프로세서 또는 프로세서들의 어레이일 수 있다. 메모리(302)는 전자, 광학, 자기 또는 프로세서(306)에 프로그램 명령어들을 제공할 수 있는 임의의 다른 저장 장치를 포함할 수 있지만, 이에 한정되는 것은 아니다. 메모리(302)는 플로피 디스크, CD-ROM, DVD, 자기 디스크, 메모리 칩, ROM, RAM, EEPROM, EPROM, 플래시 메모리, 광학 매체 또는 프로세서(306)가 명령어들을 판독할 수 있는 임의의 다른 적절한 메모리를 포함할 수 있다. 명령어들은 C, C++, C#, Java, JavaScript, Perl, HTML, XML, Python 및 Visual Basic과 같은 적합한 컴퓨터 프로그래밍 언어(이에 제한되지 않음)의 코드가 포함될 수 있다.FIG. 3A is a block diagram of one implementation of a client device 204 of a client. The client device 204 includes a
클라이언트 디바이스(204)는 하나 이상의 네트워크 인터페이스들(308)을 포함할 수 있다. 네트워크 인터페이스(308)는, 10 Base T, 100 Base T 또는 1000 Base T("기가비트")를 포함한 이더넷; 802.11a, 802.11b, 802.11g, 802.11n 또는 802.11lac과 같은 802.11 무선들 중 임의의 것; CDMA, LTE, 3G 또는 4G 셀룰러를 포함한 셀룰러; 블루투스 또는 기타 단거리 무선 연결; 또는 네트워크 또는 다른 컴퓨팅 디바이스들과 통신하기 위한 이들 또는 다른 인터페이스들의 임의의 조합을 포함하는 임의의 유형 및 형태의 인터페이스를 포함할 수 있다. 많은 구현들에서, 클라이언트 디바이스(204)는 상이한 서브-네트워크들을 통해 근거리 통신망 또는 인터넷을 포함하는 광역 통신망과 같은 다양한 네트워크들로의 접속을 허용하면서, 상이한 유형들의 복수의 네트워크 인터페이스들(308)을 포함할 수 있다.The client device 204 may include one or more network interfaces 308.
클라이언트 디바이스(204)는 하나 이상의 사용자 인터페이스(304)를 포함할 수 있다. 사용자 인터페이스(304)는 감각 정보(예를 들어, 디스플레이상의 시각화, 하나 이상의 사운드들, 촉각 피드백 등)를 생성함으로써 사용자에게 데이터를 전달하고 그리고/또는 사용자로부터 수신된 감각 정보를 전자 신호로 변환하는 임의의 전자 디바이스(예를 들어, 키보드, 마우스, 포인팅 디바이스, 터치 스크린 디스플레이, 마이크로폰 등)일 수 있다. 하나 이상의 사용자 인터페이스는, 다양한 구현들에 따라, 내장형 디스플레이, 터치 스크린, 마이크로폰 등과 같은 클라이언트 디바이스(204)의 하우징 내부에 있을 수 있거나, 또는 클라이언트 디바이스(204)에 연결된 모니터, 클라이언트 디바이스(204)에 연결된 스피커 등과 같은 클라이언트 디바이스(204)의 하우징 외부에 있을 수 있다.The client device 204 may include one or
클라이언트 디바이스(204)는 메모리(302)에 애플리케이션(310)을 포함할 수 있거나 프로세서(306)로 애플리케이션(310)을 실행할 수 있다. 애플리케이션(310)은 콘텐트를 수신하고 응답들, 명령들 또는 다른 데이터를 전송하기 위한 애플리케이션, 애플릿, 스크립트, 서비스, 데몬, 루틴, 또는 다른 실행 가능 논리일 수 있다. 일 구현에서, 애플리케이션(310)은 웹 브라우저일 수 있는 반면, 다른 구현에서, 애플리케이션(310)은 미디어 프리젠 테이션 애플리케이션일 수 있다. 애플리케이션(310)은 네트워크 인터페이스(308)를 통해 수신되거나 그리고/또는 프로세서(306)에 의해 국부적으로 생성된 컨텐츠를 디스플레이하고, 그리고 웹 사이트들에 대한 요청들, 설문 응답 옵션들의 선택들, 입력 텍스트 스트링들 등과 같은 사용자 인터페이스(304)를 통해 수신된 상호 작용들을 전송하는 기능을 포함할 수 있다.The client device 204 may include the
일부 구현들에서, 애플리케이션(310)은 수집 에이전트(312)를 포함할 수 있다. 수집 에이전트(312)는 애플리케이션(310)에 의해 처리된 데이터를 수집하고 그리고/또는 사용자 인터페이스(304)와의 사용자 상호 작용을 모니터링하기 위한 애플리케이션 플러그-인, 애플리케이션 확장, 서브 루틴, 브라우저 툴바, 데몬 또는 다른 실행 가능 로직을 포함할 수 있다. 일부 구현들에서, 수집 에이전트(312)는 애플리케이션(310)과 분리된 별도의 애플리케이션, 서비스, 데몬, 루틴, 또는 다른 실행 가능 로직일 수 있지만, 스크린 스크랩퍼, 패킷 인터셉터, API(Application Programming Interface) 후킹(hooking) 프로세스 또는 기타 이와 같은 애플리케이션과 같은 애플리케이션(310)에 의해 처리된 데이터를 인터셉트하고 그리고/또는 수집하도록 구성된다. 수집 에이전트(312)는, 마우스 클릭들, 스크롤 휠 이동들, 제스처들(예를 들어, 스와이프들, 핀치들 또는 터치들) 또는 임의의 다른 상호 작용들을 포함하는 사용자 인터페이스(304)를 통해 입력된 데이터와 함께, 키보드 키 스트로크들을 포함하는 애플리케이션(310)에 의해 수신되고 처리되는 데이터를 인터셉트하거나 수신하도록 구성될 수 있다.In some implementations, the
클라이언트 디바이스(204)는 디바이스 식별자(314)(디바이스 ID(314)로서 도 3a에 도시됨)를 포함할 수 있거나 또는 식별될 수 있다. 디바이스 식별자들(314)은, 미디어 액세스 제어(MAC) 어드레스, 텍스트 및/또는 숫자 데이터 스트링, 사용자 이름, 암호 공개 키, 쿠키들, 디바이스 일련 번호들, 사용자 프로필 데이터, 네트워크 어드레스들, 또는 클라이언트 디바이스(204)를 다른 클라이언트 디바이스들(204)과 구별하기 위해 사용될 수 있는 임의의 다른 그러한 식별자를 포함하는(이에 제한되지는 않음) 임의의 타입 및 형태의 식별을 포함할 수 있다. 일부 구현들에서, 디바이스 식별자(314)는 하나 이상의 다른 디바이스 식별자(314)(예를 들어, 이동 장치용 디바이스 식별자, 가정용 컴퓨터용 디바이스 식별자 등)와 관련 될 수 있다. 많은 구현들에서, 프라이버시를 유지하기 위해, 디바이스 식별자(314)는 암호로 생성되거나, 암호화되거나 또는 다른 방법으로 난독화될 수 있다. 일부 구현들에서, 클라이언트 디바이스(204)는, 디바이스 식별자(314)와 유사할 수 있지만, 매시간, 매일, 애플리케이션(310)이 활성화할 때 또는 임의의 다른 그러한 기간과 같이 더 빈번하게 생성될 수 있는 세션 식별자(316)(도 3a에 세션 ID(316)로서 도시됨)을 포함할 수 있다. 세션 식별자(316)는 클라이언트 디바이스(204)에 의해 생성되거나 서버 또는 다른 디바이스로부터 수신될 수 있다. 세션 식별자(316)는 익명성을 증가시키기 위해 디바이스 식별자들(314) 대신에 사용될 수 있거나, 또는 하나의 세션의 상호 작용들을 다른 세션의 상호 작용들과 구별하기 위해 디바이스 식별자들(314)과 관련하여 사용될 수 있다.The client device 204 may include or be identified with a device identifier 314 (shown in Figure 3A as the device ID 314). The device identifiers 314 may include media access control (MAC) addresses, text and / or numeric data strings, user names, cryptographic public keys, cookies, device serial numbers, user profile data, network addresses, (Including, but not limited to) any other such identifiers that can be used to distinguish client device 204 from other client devices 204. In one embodiment, In some implementations, the device identifier 314 may be associated with one or more other device identifiers 314 (e.g., mobile device identifiers, home computer device identifiers, etc.). In many implementations, to maintain privacy, the device identifier 314 may be generated with a cipher, encrypted, or otherwise obfuscated. In some implementations, the client device 204 may be similar to the device identifier 314, but may be generated more frequently, such as every hour, every day, when the
클라이언트 디바이스(204)는, 디바이스 식별자들(314), 세션 식별자들(316), 및 수집 에이전트(312)에 의해 수집된 임의의 다른 PII 데이터를 서버(예를 들어, PII 서버(118a), 서버(104)를 연결하는 PII 서버(118b))와 같은 컴퓨팅 디바이스에 전달하기 위해 요청들을 수신하도록 구성될 수 있다. 일 구현에서, 클라이언트 디바이스(204)는 클라이언트 디바이스(204)와 관련된 PII 데이터의 하나 이상의 아이템들을 전달하기 위해 PII 서버(118a)로부터 요청을 수신할 수 있다. 상기 요청에 응답하여, 수집 에이전트(312)는, 모든 PII 데이터에 대한 클라이언트 디바이스(204)의 모든 소프트웨어(예를 들어, 브라우저들에 의해 저장된 쿠키들) 및 하드웨어 컴포넌트들(예를 들어, 네트워크 인터페이스(308)에 연결된 디바이스들, 사용자 인터페이스(304)에 연결된 디바이스들, 프로세서(306)의 캐시 영역들 및 메모리(302))를 탐색한다. 일부 구현들에서, 수집 에이전트(312)는 클라이언트 디바이스(204) 상에 아직 저장되지 않은 새로운 PII 데이터에 대해 애플리케이션(310)에 질의할 수 있다. 일 구현에서, 수집 에이전트(312)는, 추가적인 사용자 정보를 요청하는 팝업 윈도우를 갖는 클라이언트 디바이스(204)의 사용자에게 촉구하는 요청을, 인터넷 브라우저에 보낼 수 있다. 클라이언트 디바이스(204)의 사용자는 PII 수집을 위해 수집 에이전트(312)에 이용 가능하게 하도록 팝업 윈도우에 요청된 정보를 입력함으로써 응답할 수 있다. 클라이언트 디바이스(204)는, 식별자들(314), 세션 식별자들(316) 및 수집 에이전트(312)에 의해 수집된 임의의 다른 PII 데이터를 요청 서버(예를 들어, PII 서버(118a), PII 서버(118b), 연결 서버(104))에 제공한다. 일부 구현들에서, 클라이언트 디바이스(204)는 요청한 서버로 전송하기 전에 수집된 PII 데이터를 압축한다(예를 들어, .bz2, .F, .gz, .lz, .lzma, .lzo, .rz, .sfark, .sz, .xz, .z, Z). 일부 구현들에서, 클라이언트 디바이스(204)는 PII 데이터를 아카이브 파일(예를 들어, .7z, .apk, .bl, .ba, .cab, .cfs, .ear, jar, .zip)로 패키징한다. 일부 구현들에서, 클라이언트 디바이스(204)는 요청을 수신할 필요없이 PII 데이터를 서버에 주기적으로 송신한다.The client device 204 may send the device identifiers 314,
도 3b는 도 1의 PII 서버들(118a, 118b)(집합적으로 PII 서버(118)라고 함)과 같은 일 구현에 따른 개인 식별가능한 정보(PII) 서버(118)의 블록도이다. 클라이언트 디바이스(204)에서와 같이, PII 서버(118)는 하나 이상의 프로세서들(306), 메모리들(302), 네트워크 인터페이스들(308) 및 사용자 인터페이스들(304)을 포함할 수 있다. 헤드리스 서버들로 지칭되는 일부 구현들에서, PII 서버(118)는 사용자 인터페이스(304)를 포함하지 않을 수 있지만, 네트워크를 통해 사용자 인터페이스(304)와 클라이언트 디바이스들(204)을 통신할 수 있다. 메모리(302)는 PII 서버 (118)가 PII 데이터를 사용자 태그 또는 브리지 태그에 맵핑하기 전에 클라이언트 디바이스(204)로부터 수신된 PII 데이터를 저장하기 위한 PII 데이터 저장 장치(326)를 포함할 수 있다. 일부 구현들에서, 메모리(302)는, 파일 전송 프로토콜(FTP) 서버들, 웹 서버들, 메일 서버들, 파일 공유 서버들, 피어 투 피어 서버(peer-to-peer server)들을 포함하는 PII 서버(118)의 프로세서(306)에 의해 실행하기 위한 하나 이상의 애플리케이션(310)(도시되지 않음) 또는 클라이언트 디바이스들(204)로부터 클라이언트 PII 데이터 저장장치(320)에 저장된 PII 데이터를 수신하고, PII 데이터(예를 들어, UT PII 맵핑(122), BT PII 맵핑(144))를 전달하며, 그리고 링크들(124)을 수신하는 다른 그러한 애플리케이션들을 저장할 수 있다. 3B is a block diagram of a personally identifiable information (PII) server 118 according to one implementation, such as
PII 서버(118)는 PII 수집 엔진(324)을 포함할 수 있다. PII 수집 엔진 (324)은 애플리케이션, 서비스, 루틴, 서버, 데몬, 또는 도 4에 도시된 프로세스 (400)를 실행함으로써 하나 이상의 클라이언트 디바이스들(204)로부터 PII 데이터를 수집하는 다른 실행 가능한 로직(logic)을 포함할 수 있다. 일부 구현들에서, 애플리케이션, 서비스, 루틴, 서버, 데몬 또는 다른 실행가능한 로직은, 데이터(예를 들어, UT PII 맵핑(122), BT PII 맵핑(144))를 준비하여 연결 서버(104)에 전달하고 그리고 연결 서버(104)로부터(예를 들어, 링크(124)) 데이터를 수신하기 위해, 도 5에 도시된 프로세스(500)를 실행한다. 일부 구현들에서, 애플리케이션, 서비스, 루틴, 서버, 데몬 또는 다른 실행가능한 로직은, 데이터(예를 들어, UT PII 맵핑(122), BT PII 맵핑(144))를 준비하여 연결 서버(104)에 전달하고 그리고 연결 서버(104)로부터(예를 들어, 링크(124)) 데이터를 수신하기 위해, 도 6에 도시된 프로세스(600)를 실행한다. The PII server 118 may include a PII collection engine 324. The PII collection engine 324 may include other executable logic to collect PII data from one or more client devices 204 by executing an application, service, routine, server, daemon, ). In some implementations, an application, service, routine, server, daemon, or other executable logic may prepare data (e.g., UT PII mapping 122, BT PII mapping 144) And executes the
도 3c는 도 1의 연결 서버(104)와 같은 일 구현에 따른 사용자 식별(UI) 연결 서버의 블록도이다. 클라이언트 디바이스(204)와 마찬가지로, 연결 서버(104)는 하나 이상의 프로세서들(306), 메모리들(302), 네트워크 인터페이스들(308) 및 사용자 인터페이스들(304)을 포함할 수 있다. 헤드리스 서버들로 지칭되는 일부 구현들에서, 연결 서버(104)는 사용자 인터페이스(304)를 포함하지 않을 수 있지만, 네트워크를 통해 사용자 인터페이스(304)와 클라이언트 디바이스(204)는 통신할 수 있다. 메모리(302)는 외부 저장 장치에 저장하는 것과 비교하여 더 빠른 판독 및 기록 액세스를 위해 PII 맵핑 데이터(예를 들어, UT PII 맵핑(122), BT PII 맵핑 (144))를 저장하기 위한 PII 맵핑 데이터 저장 장치(352)를 포함할 수 있다. 일부 구현들에서, 메모리(302)는, 파일 전송 프로토콜(FTP) 서버들, 웹 서버들, 메일 서버들, 파일 공유 서버들, 피어 투 피어 서버들을 포함하는 연결 서버(104)의 프로세서(306)에 의해 실행하기 위한 하나 이상의 애플리케이션(310)(도시되지 않음) 또는 PII 서버들(108)로부터 PII 맵핑 데이터(예를 들어, UT PII 맵핑(122), BT PII 맵핑(144))를 수신하고 그리고 PII 서버들(118)에 링크(124)를 전달하는 다른 애플리케이션을 포함한다.3C is a block diagram of a user identification (UI) connection server according to one implementation, such as connection server 104 of FIG. As with client device 204, connection server 104 may include one or
연결 서버(104)는 연결 엔진(354)을 포함할 수 있다. 연결 엔진(354)은 애플리케이션, 서비스, 루틴, 서버, 데몬, 또는 도 5에 도시된 프로세스(500)를 실행함으로써 사용자 ID들(예를 들어, 사용자 태그, 브리지 태그) 사이의 링크를 설정하기 위한 다른 실행가능한 로직을 포함할 수 있다. 일부 구현들에서, 애플리케이션, 서비스, 루틴, 서버, 데몬 또는 다른 실행 가능 로직은 도 6에 도시된 프로세스(600)를 실행함으로써 사용자 ID들(예를 들어, 사용자 태그, 브리지 태그) 사이의 링크를 설정한다.The connection server 104 may include a connection engine 354. Connection engine 354 may be used to establish a link between user IDs (e.g., user tags, bridge tags) by executing an application, service, routine, server, daemon, or
도 4는 PII 데이터를 수집하기 위한 프로세스(400)의 일부 구현들에서 PII 서버 및 클라이언트 디바이스(들)에 의해 취해진 동작들의 흐름도이다. 일부 구현들에서, 프로세스(400)는 도 1의 PII 서버들(118a, 118b) 및 도 2의 하나 이상의 클라이언트 디바이스(204)에 의해 수행될 수 있다. 특히, 연결 서버(104)는 동작들(402, 412, 414, 416, 418, 420 및 422)을 수행하고 그리고 PII 서버들(118a, 118b)은 동작들(404, 408 및 410)을 수행한다. 각 동작은 순서 재지정, 추가 또는 제거될 수 있다.4 is a flow diagram of operations taken by the PII server and client device (s) in some implementations of the
프로세스(400)는 PII 서버들(118a, 118b) 중 하나(이하, "요청 서버(requesting server)")가 PII 데이터에 대한 클라이언트 디바이스(204)에 요청을 전송하는 동작(402)에서 시작한다. 동작(404)에서, 클라이언트 디바이스(204)는 PII 데이터에 대한 요청을 수신한다. 동작(408)에서, 클라이언트 디바이스(204)는 클라이언트 디바이스(204) 상에 위치한 PII 데이터를 수집한다. 일 구현에서, 클라이언트 디바이스(204)는 수집 에이전트(312)를 촉구하여 모든 PII 데이터에 대한 클라이언트 디바이스(204)의 모든 소프트웨어(예를 들어, 브라우저들에 의해 저장된 쿠키들) 및 하드웨어 컴포넌트들(예를 들어, 네트워크 인터페이스(308)에 연결된 디바이스들, 사용자 인터페이스(304)에 연결된 디바이스들, 프로세서(306)의 캐시 영역들 및 메모리(302))을 탐색할 수 있다. 일부 구현들에서, 수집 에이전트(312)는 클라이언트 디바이스(204) 상에 아직 저장되지 않은 새로운 PII 데이터에 대해 애플리케이션(310)에 질의할 수 있다. 일 구현에서, 수집 에이전트(312)는 추가적인 사용자 정보를 요청하는 팝업 윈도우를 갖는 클라이언트 디바이스(204)의 사용자에게 촉구하는 요청을 인터넷 브라우저에 보낼 수 있다. 클라이언트 디바이스(204)의 사용자는 PII 수집을 위해 수집 에이전트(312)에 이용 가능하게 하도록 팝업 윈도우에 요청된 정보를 입력함으로써 응답할 수 있다. 클라이언트 디바이스(204)와 관련된 PII 데이터의 전부 또는 일부를 수집한 후, 클라이언트 디바이스(204)는 PII 데이터를 요청 서버(예를 들어, PII 서버(118a), PII 서버 (118b))에 전달한다.The
동작 412에서, 요청 서버는 전달된 PII 데이터를 수신한다. 동작 414에서, 요청 서버는 PII 데이터를 클라이언트 장치와 관련된 사용자 식별(예를 들어, 사용자 태그 또는 브리지 태그)에 맵핑한다. 일 구현에서, PII 서버(118a)(회사(116)에 위치함)가 정보를 요청하면, PII 서버(118a)는 회사(116)와 제휴된 임의의 컴퓨팅 디바이스와 통신하는 (디바이스 ID(314)에 기초한) 클라이언트 장치의 각 사용자를 식별하고, 클라이언트 디바이스의 사용자에 대해 수신된 PII 데이터에 "사용자 태그(user tag)"를 추가할 것이다. 마찬가지로, PII 서버(118b)(데이터 파트너(132)에 위치함)가 정보를 요청하면, PII 서버(118b)는 데이터 파트너(132)와 제휴된 임의의 컴퓨팅 디바이스와 통신하는 (디바이스 ID(314)에 기초한) 클라이언트 디바이스의 각 사용자를 식별하고, 클라이언트 디바이스의 사용자에 대해 수신된 PII 데이터에 "브릿지 태그(bridge tag)"를 추가할 것이다. At operation 412, the requesting server receives the transmitted PII data. At operation 414, the requesting server maps the PII data to a user identification (e.g., a user tag or a bridge tag) associated with the client device. In one implementation, if
동작 416에서, 요청 서버는 할당된 사용자 태그들을 데이터 구조 포맷(예를 들어, 데이터 구조(126), 데이터 구조(136))으로 조직화하고 그리고 데이터베이스(예를 들어, UT PII 맵핑 저장장치(120), BT PII 맵핑 저장장치(134))에 데이터 구조를 저장한다. 일부 구현들에서, 요청 서버는 할당된 사용자 태그들 및 PII 데이터를 어레이, 링크된 리스트, 레코드, 공용체, 태그 지정된 공용체, 클래스, 트리, 큐 또는 플랫 파일로 구성한다. 요청 서버는 쉼표, 세미콜론, 탭, 공백, 밑줄 또는 하이픈과 같은 특수 문자들을 사용하여 플랫 파일의 테이블 형식 데이터를 분리할 수 있다. 일 구현에서, 요청 서버는 예를 들어 다음과 같이 쉼표로 분리된 텍스트 파일로 데이터 구조(126)의 콘텐츠를 저장할 수 있다:At
1, 9288, cat@mail.com, 555-0100 1, 9288, cat@mail.com, 555-0100
2, 5002, dog1@email.com, 555-0140 2, 5002, dog1@email.com, 555-0140
3, 4263, mouse@email.com, 555-2105 3, 4263, mouse@email.com, 555-2105
4, 1284, snake@email.com, 555-9106 4, 1284, snake@email.com, 555-9106
5, 0301, bird@email.com, 555-8136 5, 0301, bird@email.com, 555-8136
동작 418에서, 요청 서버는 추가 클라이언트들이 요청 서버와 제휴하는지 여부를 결정한다. 추가의 클라이언트들이 존재하면, 동작 420에서, 요청 서버는 PII 데이터 요청을 다음 클라이언트 디바이스(204)에 전송하고, 동작(404)로 진행하여 프로세스(400)를 반복한다. 요청들이 모든 클라이언트 디바이스들에 전송되면, 프로세스는 동작 422에서 종료한다.At operation 418, the requesting server determines whether additional clients associate with the requesting server. If there are additional clients, at operation 420, the requesting server sends a PII data request to the next client device 204, and proceeds to
도 5는 사용자 태그들 및 브리지 태그들을 링크하기 위한 프로세스(500)의 일부 구현들에서 연결 서버 및 PII 서버들에 의해 취해진 동작의 흐름도이다. 일부 구현들에서, 프로세스(500)는 도 1의 서버(104) 및 PII 서버들(118a, 118b)을 링크함으로써 수행될 수 있다. 프로세스(500)는 워터폴 접근법을 사용하는 연결 단계를 서술한다. 각 동작은 순서 재지정, 추가 또는 제거될 수 있다.5 is a flow diagram of operations taken by connection servers and PII servers in some implementations of
동작 502로부터 동작 512까지, 연결 서버(104)는 회사(116)로부터 제1 세트의 데이터를 수집한다. 일 구현에서, 동작 502에서, 연결 서버(104)는 회사(116)에 의해 유지되는 사용자 태그 대 PII 맵핑(예를 들어, UT PII 맵핑(122))에 대한 요청을 PII 서버(118a)에 전송한다. 동작 504에서, PII 서버(118a)는 요청을 수신하고, 요청 수신에 응답하여, PII 서버(118a)는, 동작 506에서, 저장 장치(예를 들어, UT PII 맵핑 저장 장치(120))로부터 PII 맵핑(예를 들어, UT PII 맵핑(122))에 대한 사용자 태그를 검색한다. 동작 508에서, PII 서버(118a)는 각 사용자 태그와 관련된 PII 데이터를 해시한다. 일 구현에서, PII 서버(118a)는 데이터 구조(126)의 엔트리(127)와 연관된 이메일 주소를 UT PII 맵핑(122)(또는 UT PII 맵핑 저장 장치(120))으로부터 검색하고, 검색된 값을 해싱하고, 그리고 저장된 이메일 주소를 해시 값에 등가적으로 덮어쓴다. 이후, PII 서버(118a)는 데이터 구조(126)의 엔트리(127)와 연관된 전화 번호를 UT PII 맵핑(122) (또는 UT PII 맵핑 저장장치(120))으로부터 검색하고, 검색된 값을 해싱하고, 저장된 전화번호를 해시 값에 등가적으로 덮어쓴다. PII 서버(118a)는 UT PII 맵핑 저장 장치(120) 내의 각 엔트리에 대한 프로세스를 반복할 수 있다. 일부 구현들에서, PII 서버(118a)는 예를 들어, 트리플 DES(Data Encryption Standard), RSA, 블로피시, 투피쉬 또는 AES(Advanced Encryption Standard)를 사용하여 PII 데이터를 (해싱 대신에) 암호화할 수 있다. 일부 구현들에서, PII 서버(118a)는 미가공의, 해시되지 않은 PII 데이터를 사용하여 동작 510으로 진행하도록 동작 508을 스킵할 수 있다. 일부 구현들에서, 각각의 PII 서버(118)는 저장 컨텐츠를 해싱 및 겹쳐 쓰기 전에 제2 저장 장치(도시되지 않음)에 각각의 저장 장치(예를 들어, UT PII 맵핑 저장 장치(120), BT PII 맵핑 저장 장치(134))의 콘텐츠를 백업할 수 있다.From operation 502 to operation 512, connection server 104 collects a first set of data from company 116. In one implementation, at operation 502, connection server 104 sends a request to
동작 510에서, PII 서버(118a)는 데이터 저장 장치(예를 들어, UT PII 맵핑 저장 장치(120))로부터 해싱된 PII 맵핑(예를 들어, UT PII 맵핑(122))을 검색하고 해싱된 PII 맵핑(예를 들어, UT PII 맵핑(122))을 연결 서버(104)에 전달한다. 동작 512에서, 연결 서버(104)는 PII 서버(118a)로부터 UT PII 맵핑(122)을 수신하고 그리고 데이터 저장 장치(예를 들어, PII 맵핑 저장 장치(106))에 UT PII 맵핑(122)을 저장한다.At
동작 514에서 동작 524까지, 연결 서버(104)는 데이터 파트너(132)로부터 제2 데이터 세트를 수집한다. 일 구현에서, 동작 516에서, 연결 서버(104)는 데이터 파트너(132)에 의해 유지되는 브리지 태그 대 PII 맵핑(예를 들어, BT PII 맵핑(144))에 대한 요청을 PII 서버(118b)에 전송한다. 동작 516에서, PII 서버(118b)는 요청을 수신하고, 요청 수신에 응답하여, PII 서버(118b)는, 동작 518에서, 저장 장치(예를 들어, BT PII 맵핑 저장 장치(134))로부터 브리지 태그 대 PII 맵핑(예를 들어, BT PII 맵핑(144))을 검색한다. 동작 520에서, PII 서버 (118b)는 각각의 브리지 태그와 관련된 PII 데이터를 해시한다. 일부 구현들에서, PII 서버(118a)는 예를 들어, 트리플 DES(Data Encryption Standard), RSA, 블로피시, 투피쉬 또는 AES(Advanced Encryption Standard)를 사용하여 PII 데이터를 (해싱 대신에) 암호화할 수 있다. 일부 구현들에서, PII 서버(118b)는 미가공의, 해시되지 않은 PII 데이터를 사용하여 동작 522으로 진행하도록 동작 520을 스킵할 수 있다. 동작 520에서, PII 서버(118b)는 데이터 저장 장치(예를 들어, BT PII 맵핑 저장 장치(134))로부터 해싱된 PII 맵핑(예를 들어, BT PII 맵핑(144))을 검색하고 해싱된 PII 맵핑(예를 들어, BT PII 맵핑(122))을 연결 서버(104)에 전달한다. 동작 524에서, 연결 서버(104)는 PII 서버(118b)로부터 BT PII 맵핑(144)을 수신하고 그리고 데이터 저장 장치(예를 들어, PII 맵핑 저장 장치(106))에 BT PII 맵핑(144)을 저장한다.From
일부 구현들에서, PII 서버들(118a, 118b)은, 미리결정된 시간(예를 들어, 특정 날짜들, 일주일 중 어떤 날들, 매일, "월요일 오후 7시" 또는 "오후 7시 이후 매일"과 같은 한 달 중 어떤 날들), PII 서버가 클라이언트 디바이스에서 새로운 PII 데이터를 수신할 때마다 또는 클라이언트 디바이스가 PII 서버에 연결할 때마다와 같은 트리거링 이벤트의 만족에 응답하여 각각의 PII를 해시한다.In some implementations, the
도 5를 계속 참조하면, 동작 526에서, 연결 서버(104)는 워터폴 매치 유형(예를 들어, 이메일 주소, 전화 번호, 사회 보장 번호)을 설정함으로써 브리지 태그들에 사용자 태그들을 연결하는 워터폴 접근을 시작한다. 일 구현에서, 연결 서버(104)는 각 사용자에 대한 이메일 주소가 되도록 워터폴 매치 유형을 선택할 수 있다. 따라서, 동작들(528 내지 560)은 각 사용자의 이메일 주소에 기초하여 브리지 태그들에 사용자 태그들을 링크시킬 것이다. 일 구현에서, 연결 서버(104)는 각 사용자에 대한 전화 번호가 되도록 워터폴 매치 유형을 선택할 수 있다. 따라서, 동작들(528 내지 560)은 각 사용자의 전화 번호에 기초하여 브리지 태그들에 사용자 태그들을 링크시킬 것이다. 매치 유형은 여기에 서술된 것처럼 PII 데이터 값으로 적용될 수 있다. 5, at
동작 528에서, 연결 서버(104)는 동작(526)으로부터의 선택된 PII 매치 유형에 기초하여 데이터베이스(예를 들어, PII 맵핑 저장 장치(106))로부터 PII 맵핑 엔트리에 대한 사용자 태그를 검색한다. 일 구현에서, 데이터 구조(126)는 연결 서버(104)에 의해 수신된 UT PII 맵핑(122)에 대한 데이터 구조를 도시한다. 연결 서버(104)는 PII 맵핑 저장 장치(106)에 UT PII 맵핑(122)을 저장할 때 이와 동일한 데이터 구조를 유지한다. 연결 서버(104)가 매치 유형으로서 '이메일 주소'를 선택하면(즉, 동작 526), 연결 서버(104)는 데이터 구조(126)의 제1 사용자에 대응하는 엔트리(127)로부터 해싱된 이메일 주소(예를 들어, cat@email.com)를 검색한다.At operation 528, connection server 104 retrieves the user tag for the PII mapping entry from the database (e.g., PII mapping storage device 106) based on the selected PII match type from
동작 532에서, 연결 서버(104)는 동작 526으로부터의 선택된 PII 매치 유형에 기초하여 데이터베이스(예를 들어, PII 맵핑 저장 장치(106))로부터 브리지 태그 대 PII 맵핑 엔트리를 검색한다. 일 구현에서, 데이터 구조(136)는 연결 서버(104)에 의해 수신된 BT PII 맵핑(144)에 대한 데이터 구조를 도시한다. 연결 서버(104)는 BT PII 맵핑(144)을 PII 맵핑 저장 장치(106)에 저장할 때 이러한 동일한 데이터 구조를 유지한다. 이어서, 연결 서버(104)는 데이터 구조(136)의 제1 사용자에 대응하는 엔트리(138)로부터 해시된 이메일 주소(예를 들어, snake@email.com)를 검색한다.At operation 532, connection server 104 retrieves a bridge tag-to-PII mapping entry from a database (e.g., PII mapping storage device 106) based on the selected PII match type from
동작 536에서, 연결 서버(104)는 검색된 사용자 태그를 PII 맵핑 엔트리를 비교하고 그리고 검색된 브리지 태그를 PII 맵핑 엔트리와 비교하여, 검색된 값들이 매칭하는지를 결정한다(동작 538). 매칭이 발견되지 않으면, 연결 서버(104)는 포인터(예를 들어, 메모리 포인터, 데이터베이스 포인터, 스택 포인터)를 다음 브리지 태그 대 PII 맵핑 엔트리로 증가시키고 동작 532로 진행한다. 일부 구현 예에서, 연결 서버(104)는 포인터를 데이터 구조(136)의 엔트리(139)(예를 들어, bird@email.com)로 이동시킨다. 그러나, 매칭이 발견되면, 연결 서버(104)는 동작 542로 진행한다.At
연결 서버(104)는 브루트 포스 알고리즘, 결정론적 유한 오토마톤 알고리즘, 카르프-라빈 알고리즘, 시프트 오어 알고리즘, 모리스-프랫 알고리즘, 크누스-모리스-프랫 알고리즘, 사이몬 알고리즘, 콜루씨 알고리즘, 가릴-지안카를로 알고리즘, 아포스토리코-크로시모어 알고리즘, 낫 소 나이브(Not So Naive) 알고리즘, 보이어-무어(Boyer-Moore) 알고리즘, 터보(Turbo) BM 알고리즘, 아포스토리코-지안카를로(Apostolico-Giancarlo) 알고리즘, 리버스-콜루시 알고리즘, 호스풀(Horspool) 알고리즘, 퀵 서치(Quick Search) 알고리즘, 튜닝된 보이어-무어(Boyer-Moore) 알고리즘, 주-타카오카(Zhu-Takaoka) 알고리즘, 베리-라빈드란(Berry-Ravindran) 알고리즘, 스미스(Smith) 알고리즘, 라이타(Raita) 알고리즘, 리버스 팩터(Reverse Factor) 알고리즘, 터보 리버스 팩터(Turbo Reverse Factor) 알고리즘, 포워드 도그 매칭(Forward Dawg Matching) 알고리즘, 백워드 비결정론적 도그 매칭(Backward Nondeterministic Dawg Matching) 알고리즘, 백워드 오라클 매칭(Backward Oracle Matching) 알고리즘, 가릴-세이페라스(Galil-Seiferas) 알고리즘, 투 웨이(Two Way) 알고리즘, 순서화된 알파벳들(Ordered Alphabets) 상의 스트링 매칭 알고리즘, 최적 미스매칭 알고리즘, 최대 시프트 알고리즘, 스킵 서치 알고리즘, 크누스-모리스-프랫(KMP) 스킵 서치 알고리즘 및 알파 스킵 서치 알고리즘과 같은 스트링비교 알고리즘을 사용하여 값들을 비교할 수 있다. 일부 구현에서, 브루트 포스 알고리즘을 사용하여, 연결 서버(104)는 cat@email.com 및 snake@email.com 둘 모두를 제1 세트의 개별 문자들 및 제2 세트의 개별 문자들로 파싱한다. 이후, 연결 서버(104)는 제1 세트의 개별 문자들 중 제1 문자(예를 들어, cat@email.com으로부터의 'c')와 제2 세트의 개별 문자들 중 제1 문자(예를 들어, snake@email로부터의 's')를 비교한다. 매칭하는 것이 있으면, 연결 서버(104)는 제1 세트의 개별 문자들 중 제2 문자(예를 들어, cat@email.com으로부터의 'a')를 제2 세트의 개별 문자들 중 제2 문자(예를 들어, snake@email.com으로부터의 'n')를 비교한다. 연결 서버(104)는 제1 세트의 개별 문자들(예를 들어, cat@email.com)의 모든 문자들이 제2 세트의 개별 문자들(예를 들어, snake@email.com)의 모든 문자들 매칭함을 식별하기 위해 문자-문자 비교를 계속한다. The connection server 104 may be any one of a variety of communication systems such as a brute force algorithm, a deterministic finite automaton algorithm, a Carp-Lavin algorithm, a shift ore algorithm, a Morris-Pratt algorithm, a Knuth- The algorithms are as follows: Giancarlo algorithm, Apostolico-Cross Seymour algorithm, Not So Naive algorithm, Boyer-Moore algorithm, Turbo BM algorithm, Apostolico- Giancarlo algorithm, A Hoers-Algorithm, a Horspool algorithm, a Quick Search algorithm, a tuned Boyer-Moore algorithm, a Zhu-Takaoka algorithm, a Berry- Ravindran algorithm, Smith algorithm, Raita algorithm, Reverse factor algorithm, Turbo reverse factor algorithm, Forward diagram Forward Dawg Matching Algorithm, Backward Nondeterministic Dawg Matching Algorithm, Backward Oracle Matching Algorithm, Galil-Seiferas Algorithm, Two Way ), A string matching algorithm such as a string matching algorithm on ordered alphabets, an optimal mismatch algorithm, a maximum shift algorithm, a skip search algorithm, a Knuth-Morris-Pratt (KMP) skip search algorithm, and an alpha skip search algorithm You can use the algorithm to compare values. In some implementations, using the brute force algorithm, the connection server 104 parses both cat@email.com and snake@email.com into a first set of individual characters and a second set of individual characters . The connection server 104 then sends the first set of individual characters (e.g., 'c' from cat@email.com) and the first of the second set of individual characters For example, 's' from snake @ email). If there is a match, the connection server 104 sends a second character (e.g., 'a' from cat@email.com) of the first set of individual characters to the second character of the second set of individual characters (For example, 'n' from snake@email.com). The connection server 104 determines that all the characters of the first set of individual characters (e.g., cat@email.com) are all characters of the second set of individual characters (e.g., snake@email.com) Continue the character-character comparison to identify the match.
동작 542에서, 연결 서버(104)는 검색된 사용자 태그와 검색된 브리지 태그 사이에 링크를 설정한다. 일 구현에서, 연결 서버(104)는 데이터 구조(110)를 생성함으로써 링크를 설정할 수 있다. 데이터 구조(110)의 각각의 엔트리는 회사(116) (사용자 태그로 표현됨) 및 데이터 파트너(132)(브리지 태그로 표현됨) 모두에 공통인 사용자를 나타낼 수 있다.At operation 542, the connection server 104 establishes a link between the retrieved user tag and the retrieved bridge tag. In one implementation, connection server 104 may establish a link by creating
동작 544에서, 연결 서버(104)는 생성된 데이터 구조(110)를 링크 저장 장치 (108)에 저장한다. 동작 536 및 538에서 식별된 매치마다, 연결 서버(104)는 대응하는 사용자 태그 및 브리지 태그를 첨부한다. 일부 구현에서, 연결 서버(104)는 데이터 구조(110)의 제1 엔트리에 기록하고 다른 모든 엔트리들을 하나씩 푸시 (push)한다.At operation 544, the connection server 104 stores the generated
동작 546에서, 연결 서버는 검색된 사용자 태그 및 모든 연관된 PII 데이터를 PII 맵핑 저장 장치(106)로부터 제거하거나 삭제한다. 유사하게, 동작 548에서, 연결 서버(104)는 PII 맵핑 저장 장치(106)로부터 검색된 브리지 태그 및 모든 관련된 PII 데이터를 제거하거나 삭제한다. 일부 구현들에서, 연결 서버(104)는, 그 정보를 삭제하는 대신에, 정보를 문자(예 : At operation 546, the connection server removes or deletes the retrieved user tag and all associated PII data from the PII
동작 550에서, 연결 서버(104)는 추가의 사용자 태그 대 PII 맵핑 엔트리들 (예를 들어, 엔트리 127, 128, 129, 130, 131)이 데이터 구조(126)에 존재하는지를 검사한다. 존재하는 경우, 연결 서버(104)는 동작 556로 진행하여 다음 사용자 태그 대 PII 맵핑 엔트리로의 포인터를 증가시키고, 동작 558로 진행하여 브리지 태그를 데이터 구조(136)의 제1 엔트리(예를 들어, 엔트리(138))에 대한 PII 맵핑 포인터로 리셋하고, 그리고 동작 528로 진행하여 새로운 검색된 값들을 사용하여 프로세스를 반복한다. 존재하지 않는 경우, 연결 서버(104)는 추가 매치 유형들이 매치 타입 시퀀스에 존재하는지를 검사하기 위해 동작 552으로 진행한다. 추가적인 매치 유형들(예를 들어, 이메일 주소, 전화 번호)이 있는 경우, 연결 서버(104)는 동작 560으로 진행하여 포인터를 다음 매치 유형으로 증가시키고, 이어서 동작 526을 진행하여 다음 매치 유형을 사용하도록 워터폴 매칭 처리를 설정한다. 하지만, 연결 서버(104)가 동작 552에서 추가적인 매치 유형들이 없다고 결정하면, 연결 서버(104)는 동작 554으로 진행한다. 동작 554에서, 연결 서버(104)는 링크(124)를 회사(116)에 전달한다.At operation 550, connection server 104 checks if additional user tag-to-PII mapping entries (e.g.,
이후, 회사(116)는 수신된 링크들(124)을 이용할 수 있다. 한 가지 가능한 용도는 저장된 사용자 ID 대 PII 맵핑 데이터를 연구하여 인터넷 관련 서비스들 및 제품들을 고객들에게 전달하는 것이다. 예를 들어, 회사의 사용자 태그와 데이터 파트너의 브리지 태그 간의 연결을 설정함으로써, 모회사의 웹 사이트 상의 자동차들 및 자회사의 웹 사이트 상의 트럭들을 홍보하는 자동차 제조업체("회사")의 상기의 언급된 예에서, 회사는 모회사의 자동차 웹 사이트를 방문하는 사용자도 트럭 구매에 관심이 있음을 발견할 수 있다. 따라서, 회사는 자회사의 트럭 웹 사이트에서 구입할 수 있는 트럭들의 이미지들을 포함하도록 사용자를 위해 모회사의 자동차 웹 사이트의 룩 앤드 필(look and feel)을 사용자 정의할 수 있다. 이는, 사용자가 트럭을 제공하는 웹 사이트를 찾기 위해 검색들을 수행할 필요가 없으므로 네트워크 트래픽과 필요한 대역폭이 줄어들기 때문에 보다 자원 효율적인 프로세스를 제공할 수 있다.The company 116 may then utilize the received links 124. One possible use is to study stored user ID versus PII mapping data to deliver Internet-related services and products to customers. For example, by establishing a link between a company's user tag and a data partner's bridge tag, the aforementioned example of an automobile manufacturer ("the company") promoting cars on the parent company's website and on the subsidiary's website , The company may find that a user visiting a parent company's car website is also interested in buying a truck. Thus, the company can customize the look and feel of the parent company's automotive web site for the user to include images of the trucks available on the subsidiary's truck website. This can provide a more resource efficient process because the network traffic and the required bandwidth are reduced because the user does not need to perform searches to find the website that provides the truck.
도 6은 사용자 태그들 및 브리지 태그들을 링크하기 위한 프로세스(600)의 일부 구현들에서 서버 및 PII 서버들을 연결하는 사용자 식별(ID)에 의해 취해진 동작들의 흐름도이다. 일부 구현들에서, 프로세스(600)는 도 1의 연결 서버(104) 및 PII 서버들(118a, 118b)을 링크함으로써 수행될 수 있다. 특히, 각각의 클린 룸(102) 동작은 연결 서버(104)에 의해 수행되고, 각 회사(116) 동작은 PII 서버 (118a)에 의해 수행되며, 그리고 각각의 데이터 파트너(132) 동작은 PII 서버 (118b)에 의해 수행된다. 프로세스(600)는 각 당사자가 자신의 데이터를 사용자 ID들(예를 들어, 사용자 태그들, 브리지 태그들)의 링크를 위해 클린 룸(102)에 전달하기 전에 데이터 파트너(132)가 회사(116)와 데이터를 공유하는 것을 포함하는 대체 연결 단계를 서술한다. 각 동작은 순서 재지정, 추가 또는 제거될 수 있다.Figure 6 is a flow diagram of operations taken by user identification (ID) connecting server and PII servers in some implementations of
프로세스(600)에 대해, PII 서버(118b)(즉, 데이터 파트너(132))는 각 사용자를 식별하기 위해 사용자 레벨 ID("브리지 태그"로 언급됨) 및 사용자에 연결된 각 PII 데이터(예를 들어, 이메일 주소, 전화 번호)를 식별하기 위해 다수의 PII-레벨 ID들("PII tag-1", "PII tag-2", "PII tag-3" ... "PII tag-n"으로 언급됨)을 저장한다. 사용자 레벨 ID와 연관된 PII 레벨 ID 각각의 링크는 다음 맵핑 표현식으로 서술될 수 있다.For the
(1) 브리지 태그 <> 이메일 (PII tag-1) <> 전화 번호(PII tag-2)(1) Bridge tag <> email (PII tag-1) <> phone number (PII tag-2)
맵핑 표현식 (1)에서, 특정 사용자에게 지정된 브리지 태그는 사용자의 이메일 주소를 나타내는 제1 PII 레벨 ID(예를 들어, PII tag-1)와 연관되고(<>) 그리고 사용자의 전화 번호를 나타내는 제2 PII 레벨 ID(예를 들어, PII tag-2)를 표시한다. 즉, 사용자의 실제 이메일 주소와 실제 전화 번호는 이 표현식에 표시되지 않는다. 대신, 사용자의 개인 식별 정보는 PII 레벨 ID들로 표시된다. 이 동일한 명명법은 프로세스 600의 동작들을 서술하는데 사용된다.In the mapping expression (1), the bridge tag assigned to a particular user is associated with a first PII level ID (e.g., PII tag-1) representing the user's email address (& 2 Indicates the PII level ID (e.g., PII tag-2). That is, the user's actual email address and actual phone number are not displayed in this expression. Instead, the user's personally identifiable information is represented by PII level IDs. This same nomenclature is used to describe the operations of
동작 602에서, PII 서버(118b)는 데이터 파트너(132)와 제휴된 각 사용자와 관련된 각각의 PII 데이터를 해시한다. 도 5의 프로세스(500)에서 서술된 해싱 절차 및 이용 가능한 해싱 알고리즘들은 또한 프로세스(602)에 적용된다. 일부 구현들에서, PII 서버(118b)는 예를 들어, 트리플 DES(Data Encryption Standard), RSA, 블로피시, 투피쉬 또는 AES(Advanced Encryption Standard)를 사용하여 각 PII 데이터를 (해싱 대신에) 암호화할 수 있다. At
동작 604에서, PII 서버(118b)는 자신의 각 사용자에 대한 다중 PII 레벨 ID <> 해시된 PII 맵핑들을 회사(116)의 PII 서버(118a)에 제공한다. 일 구현에서, PII 서버(118b)는, 전화 번호의 해시된 값(예를 들어, 해시된 (555-0100))과 연관된(<>) 제1 사용자의 전화 번호(예를 들어, PII tag-2)의 PII-레벨 ID와 연관된(<>), 이메일 주소의 해시된 값(예를 들어, 해쉬된 cat@email.com)과 연관된(<>) 제1 사용자의 이메일 주소(예를 들어, PII tag-1)에 대한 PII 레벨 ID를, PII 서버(118a)에 전송한다. 따라서, PII 서버(118b)는 제2 사용자에 대한 PII 서버 (118a)에 다음 맵핑을 전송한다.At operation 604, the
(2) PII tag-1 <> 해시된 (cat@email.com) <> PII tag-2 <> 해시된 (555-0100). (2) PII tag-1 <> hashed (cat@email.com) <> PII tag-2 <> hashed (555-0100).
더욱이, PII 서버(118b)는, 전화 번호의 해시된 값(예를 들어, 해시된 (555-0140))과 연관된(<>) 제2 사용자의 전화 번호(예를 들어, PII tag-4)의 PII-레벨 ID와 연관된(<>), 이메일 주소의 해시된 값(예를 들어, 해쉬된 dog1@email.com)과 연관된(<>) 제2 사용자의 이메일 주소(예를 들어, PII tag-3)에 대한 PII 레벨 ID를, PII 서버(118a)에 전송한다. 따라서, PII 서버(118b)는 제2 사용자에 대한 PII 서버(118a)에 다음 맵핑을 전송한다.Furthermore, the
(3) PII tag-3 <> 해시된 (dog1@email.com) <> PII tag-4 <> 해시된 (555-0140). (3) PII tag-3 <> hashed (dog1@email.com) <> PII tag-4 <> hashed (555-0140).
동작 606에서, PII 서버(118a)는 PII 서버(118b)로부터 PII 레벨 ID <> 해시 PII 맵핑을 수신하고 그리고 수신된 데이터를 로컬 스토리지(예를 들어, UT PII 맵핑 스토리지(120)) 또는 외부 스토리지(예를 들어, 클라우드 데이터베이스, 원격 저장장치)에 저장한다.At
동작 608에서, PII 서버(118a)는 회사(116)와 제휴된 각 사용자와 관련된 각각의 PII 데이터를 해시한다. 도 5의 프로세스(500)에서 서술된 해싱 절차 및 이용 가능한 해싱 알고리즘은 또한 프로세스(602)에 적용된다. 일부 구현들에서, PII 서버(118a)는 예를 들어, 트리플 DES(Data Encryption Standard), RSA, 블로피시, 투피쉬 또는 AES(Advanced Encryption Standard)를 사용하여 각 PII 데이터를 (해싱 대신에) 암호화할 수 있다. 사용자 태그들 및 브리지 태그들의 성공적인 연결을 보장하기 위해, PII 서버(118a) 및 PII 서버(118b)는 각각의 데이터 각각을 해싱하기 위해 동일한 해싱 함수를 사용한다. 일부 구현들에서, 당사자들은 업계에서 일반적으로 허용되는 기본 해싱 함수를 사용한다. 일부 구현들에서, 당사자들(회사(116) 및 데이터 파트너(132))는 특정 해싱 기능에 동의하기 위해 서로 통신한다.At
동작 610에서, PII 서버(118a)는 회사(116)의 사용자 ID들("사용자 태그(user tag)")와 PII 서버(118b)로부터 수신된 다수의 PII-레벨 ID들 사이의 링크를 설정한다. 링크를 설립시키기 위해, PII 서버(118a)는 여기에서 서술된 임의의 스트링 비교 알고리즘들(예를 들어, 브루트 포스 알고리즘, 결정론적 유한 오토마톤 알고리즘, 카프-라빈 알고리즘 등)을 사용하여 해시된 PII 데이터를 데이터 파트너(132)의 해시된 PII 데이터와 비교한다. PII 서버(118a)가 회사(116)의 해시 된 PII 데이터와 데이터 파트너(132)의 해시된 PII 데이터 사이의 매칭을 결정하면, PII 서버(118a)는 회사(116)의 사용자 태그를 해당 사용자와 관련된 데이터 파트너(132)의 여러 PII 레벨 ID들에 링크(==)한다. 일 실시예에서, 데이터 파트너 (132)는 제1 사용자에 대한 다음 맵핑을 회사(116)에 제공한다. At
(4) PII tag-1 <> 해시된 (cat@email.com) <> PII tag-2 <> 해시된 (555-0100).(4) PII tag-1 <> hashed (cat@email.com) <> PII tag-2 <> hashed (555-0100).
여기서 PII tag-1은 cat@email.com의 이메일 주소에 대한 PII-레벨 ID이고 그리고 PII tag-2는 555-0100의 전화 번호에 대한 PII-레벨 ID이다.Where PII tag-1 is the PII-level ID for the email address of cat@email.com and PII tag-2 is the PII-level ID for the phone number of 555-0100.
PII 서버(118a)는 저장 장치(예를 들어, UT PII 매핑 저장 장치(120), 클라우드 저장 장치)로부터 다음 매핑을 검색한다.The
(5) user tag-1 <> 해시된 (cat2@email.com) <> 해시된 (555-0100). (5) user tag-1 <> hashed (cat2@email.com) <> hashed (555-0100).
여기서 user tag-1은 동일한 "제1" 사용자의 사용자 ID이고, 그리고 cat@email.com은 제1 사용자와 연관된 제1 PII 데이터이며, 그리고 555-0100은 제1 사용자와 연관된 제2 PII 데이터이다. Where user tag-1 is the user ID of the same " first " user, and cat@email.com is the first PII data associated with the first user, and 555-0100 is the second PII data associated with the first user .
PII 서버(118a)는 매핑(4)의 해시된 PII 데이터와 매핑(5)의 해시된 PII 데이터 간의 스트링 비교를 수행한다. 일부 구현들에서, PII 서버(118a)는 다음 순서로 스트링 비교를 수행한다:The
매핑(4)의 제1 PII 데이터와 매핑(5)의 제1 PII 데이터 비교The first PII data of the mapping (4) and the first PII data of the mapping (5)
매핑(4)의 제2 PII 데이터와 매핑(5)의 제2 PII 데이터 비교The second PII data of the mapping (4) and the second PII data of the mapping (5)
매핑(4)의 제1 PII 데이터와 매핑(5)의 제2 PII 데이터 비교The first PII data of the mapping (4) and the second PII data of the mapping (5)
매핑(4)의 제2 PII 데이터와 매핑(5)의 제1 PII 데이터 비교The second PII data of the mapping (4) and the first PII data of the mapping (5)
일 구현에서, PII 서버(118a)는 매칭을 결정하기 위해 맵핑(4)으로부터 해시 된 (cat@email.com)과 매핑(5)으로부터 해시된 (cat2@email.com)을 비교한다. 따라서, PII 서버(118a)는 "제1" 사용자에게 할당된 회사(116)에서의 사용자 ID(예를 들어, user tag-1)를 제1 해시된 PII 데이터에 대한 PII-레벨 ID(예를 들어, PII tag-1) 및 제2 해시된 PII 데이터에 대한 PII-레벨 ID(예를 들어, PII tag-2)를 다음과 같이 링크(==)한다.In one implementation,
(6) User tag-1 == PII tag-1, PII tag-2 (6) User tag-1 == PII tag-1, PII tag-2
PII 서버(118a)는 사용자 태그를 각각의 매칭하는 사용자에 대한 저장 장치(예를 들어, UT PII 매핑 저장 장치(120))의 사용자 레벨 ID 링크들에 저장한다.The
동작 612에서, PII 서버(118a)는 매칭하지 않는 모든 데이터를 저장 장치 (예를 들어, UT PII 매핑 저장 장치(120))로부터 제거한다. 일 실시예에서, PII 서버(118a)는 회사의 116개의 사용자 태그들 및 관련 PII 데이터 모두를 제거하고, 일치하지 않는 모든 데이터 파트너(132)의 PII 레벨 ID <> 해싱된 PII 데이터를 제거한다.At
동작 614에서, PII 서버(118a)는 저장 장치(예를 들어, UT PII 매핑 저장 장치(120))로부터 사용자 태그 대 사용자 레벨 ID를 검색하고, 그리고 이를 클린 룸(102)의 연결 서버(104)에 제공한다. 동작 616에서, 연결 서버(104)는 PII 서버 (118a)로부터 제공된 데이터를 수신하여 이를 데이터 저장 장치(예를 들어, PII 매핑 저장 장치(106))에 저장한다. 동작 618에서, PII 서버(118b)는 저장 장치(예를 들어, BT PII 매핑 저장 장치(134))로부터 브릿지 태그 대 사용자 레벨 ID 연결들을 검색하고, 그것을 클린 룸(102)의 연결 서버(104)에 제공한다. 동작 620에서, 연결 서버(104)는 PII 서버(118b)로부터 제공된 데이터를 수신하여 이를 데이터 저장 장치(예를 들어, PII 매핑 저장 장치(106))에 저장한다.At operation 614, the
동작 622에서, 연결 서버(104)는, PII 서버(118a)(즉, 회사(116))로부터의 PII 레벨 ID들과 PII 서버(118b)(즉, 데이터 파트너(132))로부터의 PII 레벨 ID들을 비교하고 매칭시킴으로써 달성함으로써 각각의 사용자 태그와 브리지 태그사이의 링크를 확립할 수 있다. 링크를 확립하기 위해, 연결 서버(104)는 여기에서 서술된 바와 같이, 동작(610)의 동일한 스트링 비교 기술을 적용한다.At operation 622, connection server 104 receives PII level IDs from
동작 624에서, 연결 서버(104)는 사용자 태그 대 브리지 태그 연결들을 PII 서버(118a)(즉, 회사(116))에 제공한다. 동작 626에서, PII 서버(118a)는 링크들 (124)을 수신한다. 동작 628에서, PII 서버(118a)는 프로세스(600)가 추가 데이터 세트들에 대해 반복될 필요가 있는지를 결정하기 위해 회사(116)(예를 들어, UT PII 매핑 저장 장치(120))의 저장 장치를 검사한다. 필요가 없다면, 그때, 프로세스(600)는 동작(630)에서 종료한다. 필요하다면, 프로세스(600)는 다음 데이터 세트를 선택하기 위해 동작 632로 진행한 다음 동작 602로 진행하여 프로세스(600)를 반복한다.At operation 624, connection server 104 provides user tag-to-bridge tag connections to
많은 암호화 표준들에는, 두 개의 상이한 키들 각각에 대해 한 번씩, 값을 두 번 암호화하면 어떤 키가 먼저 사용되는지에 관계없이 동일한 암호화된 값을 초래하도록 하는 교환 속성이 있다. 즉, 암호화 기능인 Encrypt()의 경우, 암호화(키1, 암호화(키2, 메시지))의 결과는 암호화(키2, 암호화(키1, 메시지))의 결과와 동일하다. 따라서, 도 5 및 도 6을 참조하여, 상기에서 서술된 비교들은, 이중 암호화된 데이터에 대해 수행될 수 있다. 일부 구현들에서, 아래에서 보다 상세히 설명되는 것처럼, 두 당사자들은 각각의 비밀 키로 암호화된 데이터를 교환할 수 있고 그리고 교환된 데이터를 각각의 비밀 키 중 다른 하나와 함께 추가로 암호화함으로써 이를 비교할 수 있다. 각 당사자는 어떤 비밀 키가 먼저 사용되었는지 관계없이 그리고 비밀 키들을 공유하지 않고도 동일한 결과(비교에 적합함)를 가진다. 도 7에 도시된 프로세스(700)는, 클린 룸 환경을 사용하지 않고 그리고 내부 PII 맵핑들을 공유하지 않으면서 사용자 태그들과 데이터 파트너의 브리지 태그들 사이에 링크를 설정하기 위해 교환가능한 암호화의 이러한 특징을 사용한다.Many cryptographic standards include an exchange attribute that, once for each of two different keys, encrypts the value twice, resulting in the same encrypted value regardless of which key is used first. That is, in the case of the encryption function Encrypt (), the result of encryption (key 1, encryption (key 2, message)) is the same as the result of encryption (key 2, encryption (key 1, message)). Thus, with reference to Figures 5 and 6, the comparisons described above can be performed on double encrypted data. In some implementations, as described in more detail below, the two parties can exchange the encrypted data with each secret key and compare the exchanged data with the other one of the respective secret keys by further encrypting . Each party has the same result (suitable for comparison) regardless of which secret key was used first and without sharing the secret keys. The
도 7은 클린 룸 환경을 사용하지 않고 사용자 태그들과 브리지 태그들을 링크하기 위한 프로세스(700)의 일부 구현들에서 PII 서버들에 의해 취해진 동작들의 흐름도이다. 일부 구현들에서, 프로세스(700)는 도 1에 도시된 PII 서버들(118a, 118b)에 의해 수행될 수 있다. 특히, 각각의 회사(116) 동작은 PII 서버(118a)에 의해 수행되고, 각각의 데이터 파트너(132) 동작은 PII 서버(118b)에 의해 수행된다. 프로세스(700)는 PII 맵핑들을 노출시키지 않고 비교를 위해 암호화된 PII 데이터를 한 곳에서 함께 가져 오는 대체 프로세스를 서술한다. 일부 구현들에서, PII 서버(118b)가 암호화된 데이터를 가지면, 이후 PII 데이터는 이전에 기술된 것과 동일한 워터폴 방식으로 비교된다. 각 동작은 순서 재지정, 추가 또는 제거될 수 있다.7 is a flow diagram of operations taken by PII servers in some implementations of
프로세스(700)에서, 회사(116) PII 서버(118a)는 사용자를 식별하기 위해 사용자 레벨 ID("사용자 태그"라고 함)를 저장하고, 데이터 파트너(132) PII 서버(118b)는 사용자를 식별하기 위해 사용자 레벨 ID("브리지 태그"라고 함)를 저장하며 그리고 PII 서버들(118a, 118b) 각각은 사용자들에게 링크된 다양한 PII 데이터(예를 들어, 이메일 주소, 전화 번호)에 대응하는 다수의 PII 데이터 요소들을 저장한다. PII 서버(118b)는 브리지 태그들(예를 들어, "BT1", "BT2" 등)의 데이터 쌍들 및 암호화된 개별 PII 데이터 요소들(예를 들어, "PII1.1", "PII1.2" 등, 암호화된 형태로 "E(Key, PII#)"로 표시되어 암호화된 데이터 및 사용된 암호화 키를 나타냄)을 생성한다. PII 데이터 요소들을 암호화하는데 사용되는 암호화 알고리즘은 결정론적 교환 가능한 암호화 알고리즘(예를 들어, 큰 소수(prime)를 모듈화한 지수)이다. 회사(116) PII 서버(118a)는 사용자 태그들 및 브리지 태그들을 추가로 암호화한다. 사용자 태그들 및 브리지 태그들을 암호화하기 위해 회사(116) PII 서버(118a)에 의해 사용되는 알고리즘은 결정론적 암호화 알고리즘이지만, 교환 가능할 필요는 없고, 그리고 일부 구현들에서, PII 데이터를 암호화하는데 사용되는 알고리즘과 상이한 알고리즘이다. 대칭 암호화 알고리즘들(암호화 및 암호 해독 모두에 단일 키 사용) 또는 비대칭 암호화 알고리즘들(암호화에 대해 하나 및 상호 암호 해독에 대해 다른 하나씩 키들의 쌍들을 사용)을 사용할 수 있다. 다음 설명에서는 대칭(단일 키) 알고리즘이 각 암호화 작업에 사용되고 그리고 암호화 키만이 서술되는 것으로 가정한다. 그러나, 일부 구현들에서, 하나 이상의 비대칭 암호화 알고리즘들이 사용될 수 있다. In
아래에서 보다 상세하게 설명되는 바와 같이, 프로세스(700)에서, PII 서버들(118a, 118b) 각각은 PII 데이터를 암호화하여 데이터 파트너(132) PII 서버(118b)는 암호화된 사용자 태그들과 연관된 이중 암호화된 PII 데이터의 세트 및 암호화된 브리지 태그들과 연관된 이중 암호화된 PII 데이터의 세트를 획득한다. 이후, 데이터 파트너(132) PII 서버(118b)는 이중 암호화된 PII 데이터를 비교하여 암호화된 사용자 태그들과 브리지 태그들 간의 상관 관계를 식별한다. 데이터 파트너(132) PII 서버(118b)는 회사(116) PII 서버(118a)와의 상관 관계들을 리턴하며, 이후, 회사(116)는 태그 데이터를 암호 해독하고 그리고 내부 PII 또는 PII 매핑들을 공개하는 사람 없이 원하는 태그 연결 데이터를 갖는다. As described in more detail below, in
동작 710에서, 데이터 파트너(132) PII 서버(118b)는 암호화 키, X를 생성한다. 일부 구현들에서, PII 서버(118b)는 항상 동일한 키, X를 사용한다. 일부 구현들에서, PII 서버(118b)는 프로세스(700)의 각각의 호출에 대해 새로운 키, X를 생성한다. 암호화 키, X는 데이터 파트너(132)에 의해 비밀로 유지되며, 프로세스 (700)의 완료 후에 폐기될 수 있다.At operation 710, the data partner 132
동작 710 이전, 이후 또는 병렬일 수 있는 동작 715에서, 회사(116) 측의 PII 서버(118a)는 2개의 무관한 암호화 키들 G 및 Z를 생성한다. 키 G는 사용자 태그들 및 브리지 태그들을 암호화하는 데 사용된다. 일부 구현들에서, 키 G 및 키 Z는 상이한 암호화 알고리즘들에 대해 PII 서버(118a)에 의해 생성된다. 일부 구현들에서, 사용자 태그들 및 브리지 태그들을 암호화하는데 사용되는 암호화 알고리즘은 비 교환적이다. 암호화 키들 G 및 Z는 회사(116)에 의해 비밀로 유지되며, 프로세스(700)의 완료 후에 하나 또는 둘 모두가 폐기될 수 있다.At operation 715, which may be before, after, or parallel to operation 710, the
동작 718에서, 데이터 파트너(132) PII 서버(118b)는 암호화 키, X를 사용하여 각 PII 데이터 요소를 개별적으로 암호화한다. PII 서버(118b)는 사용자의 브리지 태그의 데이터 쌍들을 생성하고 그리고 각 PII 데이터 요소는 사용자의 브리지 태그와 연관되며, 각 PII 데이터 요소는 키, X를 사용하여 암호화된다. 따라서, 데이터 파트너(132)가 브리지 태그를 이메일 어드레스 및 전화 번호에 매핑할 수 있는 경우, PII 서버(118b)는 이메일 주소를 암호화하여 브리지 태그 및 암호화된 이메일 주소의 제1 데이터 쌍을 생성하고, 그리고 PII 서버(118b)는 전화 번호를 암호화하여 브리지 태그 및 암호화된 전화 번호의 제2 데이터 쌍을 생성한다.At
동작 720에서, 데이터 파트너(132) PII 서버(118b)는 {브리지 태그, 암호화 된 PII}의 데이터 쌍들을 회사(116) PII 서버(118a)에 전송한다. 일부 구현들에서, 데이터 파트너(132) PII 서버(118b)는 데이터를 링크를 통해, 예를 들어 TCP, SCTP 또는 임의의 다른 OSI 계층-4 전송 프로토콜을 통해 회사(116) PII 서버(118a)에 데이터를 전송한다. 일부 구현들에서, 데이터 링크는, 예를 들어, 종단 간 암호화의 추가적인 계층을 사용하는 보안 네트워크 링크이다. 일부 구현들에서, 데이터 파트너(132) PII 서버(118b)는 피어 투 피어 링크를 통해 회사(116) PII 서버(118a)에 데이터를 전송한다. 동작 725에서, 회사(116) PII 서버(118a)는 데이터 파트너(132) PII 서버(118b)로부터 데이터 쌍들을 수신한다.At
동작 720에서 데이터 파트너(132) PII 서버(118b)에 의해 전송된 데이터의 일례는 일련의 데이터 쌍 {BT1, E(X, PII1.1)}, {BT1, E(X, PII1.2)}, {BT2, E(X, PII2.1)}등이있다. 이 예에서, "BT1" 및 "BT2"는 브리지 태그들의 예이며, 각각은 암호화된 PII 데이터 요소와 쌍을 이루고 있다. 회사(116) PII 서버(118a)는 동작 725에서 이 데이터를 수신한 다음, 암호화된 데이터와 각각 쌍을 이루는 브리지 태그들의 세트를 소유하게 된다. 따라서, PII 데이터는 난독화되어 보호된다. 개인 정보는 공유되지 않는다.One example of the data transmitted by the data partner 132
동작 733에서, 회사(116) PII 서버(118a)는 G를 사용하여 각 브리지 태그를 암호화하고 그리고 Z를 사용하여 이미 암호화된 파트너 PII 데이터를 이중 암호화하도록 암호 키를 사용하여 파트너 데이터를 암호화한다. 이 동작의 결과는 수신된 브리지 태그와 암호화된 PII 데이터 요소 쌍이 암호화된 브리지 태그가되고 이중 암호화된 PII 데이터 요소 쌍인 {BT , E(X, PII)}는 {E(G, BT), E(Z, E(X, PII))}이 된다.At
동작 735에서, 회사(116) PII 서버(118a)는 이중 암호화된 데이터 쌍들을 데이터 파트너(132) PII 서버(118b)로 전송한다. 일부 구현들에서, 회사(116) PII 서버(118a)는 데이터를 링크를 통해, 예를 들어 TCP, SCTP 또는 임의의 다른 OSI 계층-4 전송 프로토콜을 통해 데이터 파트너(132) PII 서버(118b)에 데이터를 전송한다. 일부 구현들에서, 데이터 링크는, 예를 들어, 종단 간 암호화의 추가적인 계층을 사용하는 보안 네트워크 링크이다. 일부 구현들에서, 회사(116) PII 서버(118a)는 피어-투-피어 링크를 통해 데이터 파트너(132) PII 서버(118b)에 데이터를 전송한다. 일부 구현들에서, 회사(116) PII 서버(118a)는 동작 720에서 사용된 것과 동일한 링크를 사용하여 데이터를 전송한다. 일부 구현들에서, 이중 암호화된 데이터 쌍들을 전송하기 전에 (또는 전송하는 동안), 회사(116) PII 서버(118a)는 (각각의 쌍을 손상시키지 않고) 데이터 쌍들의 순서를 섞는다. 순서를 섞는 것은, 동작 725에서 회사(116) PII 서버(118a)에 의해 수신된 데이터 쌍들의 세트가 제1 순서에서 재정렬되도록 하여, 동작 735에서 이중 암호화된 데이터 쌍들이 데이터 파트너(132) PII 서버(118b)로 리턴될 때, 이들은 제1 순서와 상이한 제2 순서로 리턴된다. 이러한 순서를 섞는 것은, 암호화된 데이터와 데이터 원본 간의 관계들을 더욱 모호하게 만든다. 데이터 파트너(132) PII 서버(118b)는 동작 738에서 암호화 된 (그리고 일부 구현들에서는 순서가 섞여진) 데이터를 수신한다.At operation 735, the corporate 116
동작 735에서, 회사(116) PII 서버(118a)에 의해 전송된 데이터의 예는 일련의 데이터 쌍들이며, 이전에 예에 기초하여, 동작 733에서, 이중 암호화되고 그리고 순서가 섞여진다. 이 예에서, 암호화 및 순서를 섞는 것은, 일련의 {E(G, BT1), E(Z, E(X, PII1.1))}, {(E(G,BT2), E(Z,E(X, PII2.1))}, {E(G, BT1), E(Z, E(X, PII1.2))}를 초래한다. 데이터 파트너(132) PII 서버(118b)는 동작 738에서 이 데이터를 수신한 다음, 이중 암호화된 데이터와 각각 쌍을 이루는 암호화된 브리지 태그들의 세트를 소유하게 된다. 따라서, PII 데이터는 여전히 난독화되어 보호된다. 개인 정보는 공유되지 않는다. At operation 735, an example of the data transmitted by company 116
동작들 725, 733 및 735의 이전, 이후 또는 병렬일 수 있는 동작 743에서, 회사(116) 측의 PII 서버(118a)는 암호화 키들 G, Z를 사용하여 회사(116) PII 데이터를 암호화한다. PII 서버(118a)는 내부 사용자 태그들을 키 G로 암호화한다. 일부 구현들에서, PII 서버(118a)는 내부 사용자 태그들을 대안 키 G'로 암호화한다. 일부 구현들에서, PII 서버(118a)는 내부 사용자 태그들을 랜덤 로컬 고유 값들로 1회 맵핑을 생성하고 그리고 해당 사용자 태그들에 대한 랜덤 값들을 대체한다(이 프로세스를 나중에 역전시키는 데 사용하기 위해 맵핑을 유지함). PII 서버 (118a)는 암호화된 (또는 대체된) 사용자 태그들의 데이터 쌍들을 대응하는 연관된 PII 데이터 요소들과 함께 생성한다. 각 데이터 쌍에서, PII 서버(118a)는 키 Z를 사용하여 PII 데이터 요소를 암호화한다. 일부 구현들에서, PII 서버(118a)는 또한 페이크 사용자 태그들 및/또는 페이크 PII 데이터 요소들을 포함하는 거짓 데이터 쌍들을 생성한다. 이 추가적인 거짓 데이터는 실제 데이터를 난독화하는데 도움이되며 암호화 프로세스를 취소하려는 인증되지 않은 시도들을 혼동시킬 수 있다.In operation 743, which may be before, after or in parallel with
동작 745에서, 회사(116) PII 서버(118a)는 암호화된 회사 데이터를 데이터 파트너(132) PII 서버(118b)로 전송한다. 일부 구현들에서, 회사(116) PII 서버(118a)는 데이터를 링크를 통해, 예를 들어 TCP, SCTP 또는 임의의 다른 OSI 계층-4 전송 프로토콜을 통해 데이터 파트너(132) PII 서버(118b)에 데이터를 전송한다. 일부 구현들에서, 데이터 링크는, 예를 들어, 종단 간 암호화의 추가적인 계층을 사용하는 보안 네트워크 링크이다. 일부 구현들에서, 회사(116) PII 서버(118a)는 피어-투-피어 링크를 통해 데이터 파트너(132) PII 서버(118b)에 데이터를 전송한다. 일부 구현들에서, 회사(116) PII 서버(118a)는 동작 720 및/또는 동작 735에서 사용된 동일한 링크를 사용하여 데이터를 전송한다. 동작 748에서, 데이터 파트너(132) PII 서버(118b)는 회사(116) PII 서버(118a)로부터 암호화된 회사 데이터 쌍들을 수신한다.At operation 745, the company 116
동작 745에서, 회사(116) PII 서버(118a)에 의해 전송된 데이터의 일례는 일련의 데이터 쌍들 {(E(G,UT1), E(Z, PII1.1)}, {E(G,UT3), E(Z, PII3.1)}, {(E(G,UT5), E(Z, PII5.1)}등이 있다. 이 예에서, "UT1", "UT2" 및 "UT5"는 사용자 태그들의 예이며, 각각은 암호화된 PII 데이터 요소, PII1.1, PII3.1, PII5.1 등과 쌍을 이루고 있다. 데이터(132) PII 서버(118b)는 동작 748에서 이 데이터를 수신한 다음, 암호화된 PII 데이터와 각각 쌍을 이루는 암호화된 사용자 태그들의 세트를 소유하게 된다. 따라서, PII 데이터는 보호된다. 개인 정보는 공유되지 않는다.At operation 745, an example of the data transmitted by company 116
동작 756에서, 데이터 파트너(132) PII 서버(118b)는, 동작 745에서 회사(116) PII 서버(118a)에 의해 전송된 데이터에서 개별적으로 각각의 PII 데이터 요소를 이중 암호화하기 위해 암호화 키 X를 사용한다. 예를 들어, 동작 748에서, PII 서버(118b)는 PII 데이터 요소 "PII1.1"과 연관된 사용자 태그 "UT1"에 대한 데이터 쌍을 수신할 수 있고, 회사(116) PII 서버(118a)는 E(Z, PII1.1)로서 암호화된 서버이다. 데이터 쌍은 {E(G,UT1), E(Z, PII1.1)}로서 표현될 수 있다. 동작 756에서, 데이터 파트너(132) PII 서버(118b)는 암호화 키 X를 사용하여 PII 요소를 이중 암호화하여 데이터 쌍 {E(G, UT1), E(X, E(Z, PII1.1))}을 초래한다.At
일부 구현들에서, 동작 748)에서 수신된 데이터를 이중 암호화하기보다는, 데이터 파트너(132) PII 서버(118b)는 대신 동작 738에서 수신된 이중 암호화된 데이터에 복호화 프로세스를 적용한다. 복호화 프로세스에서, 데이터 파트너(132) PII 서버(118b)는 동작 718에서 적용된 원래 암호화를 제거하기 위해 키 X (또는 키 X에 대응하는 복호화 키)를 사용한다. 이 복호화 프로세스는 동작 733에서 회사(116) PII 서버(118a)에 의해 적용된 암호화를 제거하지 않고 키 Z에 의해 암호화된 단일 암호화된 값을 초래한다. 즉, 복호화(X, 암호화(Z, 암호화(X, 메시지))) = 암호화(Z, 메시지)이다. 이후, 데이터 파트너(132) PII 서버(118b)가 동작 748에서 단일 암호화된 데이터를 수신할 때, 동작 760에서의 비교는 동작 756없이 수행될 수 있다. 일부 구현들에서, 이러한 대안은 동작 748에서 수신된 데이터 세트가 적어도 임계 값만큼 동작 720에서 송신된 데이터보다 큰 경우에만 호출된다.In some implementations, rather than double encrypting the data received at operation 748, data partner 132
동작 760에서, 데이터 파트너(132) PII 서버(118b)는 동작들(738 및 756)로부터의 이중 암호화된 데이터 세트들을 비교한다. PII 암호화에 사용되는 암호화 알고리즘은 교환 가능하기 때문에, E(X, E(Z, PII1.1))는 E(Z, E(X, PII1.1))과 동일하다. 그 결과로서, 데이터 파트너(132) PII 서버(118b)는 동작 756에서 생성된 E(X, E(Z, PII1.1)) 값을 동작 738에서 수신된 값들과 비교할 수 있고, 그리고 E(Z, E(X, PII1.1))과 같은 매칭들을 식별할 수 있다. 동작 760에서의 비교들은 암호화된 데이터이므로, 개인 식별 데이터는 밝혀지지 않는다. 또한, 서로 다른 유형들의 PII 데이터 간 링크들이 드러나지 않는다. At
동작 766에서, 데이터 파트너(132) PII 서버(118b)는 사용자 태그들과 브리지 태그들 사이의 연관들의 브리지 링크들을 식별한다. 암호화된 사용자 태그와 암호화된 브리지 태그가 모두 동일한 이중 암호화된 PII 데이터 요소들과 연관되는 연관성이 존재한다. 일부 구현들에서, 동작 766에서, 데이터 파트너(132) PII 서버(118b)는 매칭된 이중 암호화된 PII 요소들에 기초하여 암호화된 브리지 태그들에 링크된 암호화된 사용자 태그들의 맵을 생성한다. 일부 구현들에서는, 암호화된 사용자 태그들과 암호화된 브리지 태그들 간에 많은 상관 관계들이 존재한다. 일부 그와 같은 구현들에서, 데이터 파트너(132) PII 서버(118b)는 여분의 상관 관계들을 필터링한다. 일부 구현들에서, 다중 태그들은 동일한 PII에 대응할 것이다. 예를 들어, 다수의 사용자들이 동일한 주소, 동일한 전화 번호, 같은 도시, 같은 연령대 등을 가질 수 있다. 일부 구현들에서, 데이터 파트너(132) PII 서버(118b)는 (예를 들어, 다른 태그들과 비교하여) 매칭된 PII 요소들의 수가 가장 많은 것에 기초하여, 암호화된 사용자 태그와 암호화된 브리지 태그 간의 가장 강한 상관 관계를 식별한다. 일부 구현들에서, 데이터 파트너(132) PII 서버(118b)는 하나 이상의 암호화된 사용자 태그를 특정 암호화된 브리지 태그에 매핑시키는 임의의 연관들을 필터링한다. 일부 구현들에서, 데이터 파트너(132) PII 서버(118b)는 추가적인 필터를 적용한다. 일부 구현들에서, 분석을 위해 집계 데이터를 회사(116) PII 서버(118a)에 제공하고; 일부 구현들에서, 데이터 파트너(132) PII 서버(118b)가 임의의 필터를 적용하지 않고서 집합 데이터가 제공된다.At
동작 760에서, 데이터 파트너(132) PII 서버(118b)는 브리지 연결 데이터를 회사(116) PII 서버(118a)로 전송한다. 일부 구현들에서, 데이터 파트너(132) PII 서버(118b)는 데이터를 링크를 통해, 예를 들어 TCP, SCTP 또는 임의의 다른 OSI 계층-4 전송 프로토콜을 통해 회사(116) PII 서버(118a)에 데이터를 전송한다. 일부 구현들에서, 데이터 링크는, 예를 들어, 종단 간 암호화의 추가적인 계층을 사용하는 보안 네트워크 링크이다. 일부 구현들에서, 데이터 파트너(132) PII 서버(118b)는 피어-투-피어 링크를 통해 회사(116) PII 서버(118a)에 데이터를 전송한다. 일부 구현들에서, 회사(116) PII 서버(118a)는 동작 720에서 사용된 동일한 링크를 사용하여 데이터를 전송한다. 일부 구현들에서, 데이터 파트너(132) PII 서버(118b)는 동작 765에서 생성된 맵을 회사(116) PII 서버(118a)로 전송한다. 일부 구현들에서, 데이터 파트너(132) PII 서버(118b)는 암호화된 사용자 태그들 및 암호화된 브리지 태그들, 예컨대 {E(G, UT1), E(G, BT1)}의 세트들로서 링크 쌍들을 전송한다.At
동작 775에서, 회사(116) PII 서버(118a)는 데이터 파트너(132) PII 서버(118b)로부터 데이터 쌍들을 수신한다. 회사(116) PII 서버(118a)는 키 G (또는 키 G에 대응하는 복호화 키)를 사용하여 링크들을 복호화할 수 있다. 제3 암호화 키, G의 사용은 데이터 교환의 보안을 개선하고, 그리고 내부 링크 데이터가 누설되는 것을 더 보호한다.At operation 775, the company 116
많은 구현들에서, 사용자에 대해 수집된 데이터는 개인 정보를 보호하기 위해 익명화되거나 모호해질 수 있다. 클라이언트 디바이스의 사용자에 관한 개인 정보가 측정을 위해 수집될 수 있거나 또는 제3 자 콘텐츠를 선택하는데 사용될 수 있는 많은 구현들에서, 사용자는 개인 정보(예를 들어, 사용자의 사회적 네트워크, 사회적 행동들 또는 활동들, 사용자의 선호도들 또는 사용자의 현재 위치에 관한 정보)를 수집할 수 있는 프로그램 또는 특징들을 제어할 기회 또는 측정 데이터를 PII 서버(예를 들어, PII 서버(118a, 118b))에 전달할지 또는 어떻게 전달할지를 제어할 기회를 제공받을 수 있다. 또한, 특정 PII 데이터가 PII 서버 또는 연결 서버에 저장되거나 사용되기 전에 하나 이상의 방법들로 처리될 수 있어, 파라미터들(예를 들어, 인구 통계 파라미터들)을 생성할 때 개인 식별 정보가 삭제된다. 사용자의 신원은 익명으로 처리되어 사용자에 대해 어떤 개인 식별 정보를 확인할 수 없거나 또는 사용자의 지리적 위치는 위치 정보가 획득되는 곳(예를 들어, 도시, 우편 번호 또는 주 레벨)으로 일반화될 수 있다. 따라서 사용자는 PII 서버들 및 연결 서버들에서 자신의 정보를 수집하는 방법을 제어할 수 있다.In many implementations, the data collected for the user may be anonymized or obscured to protect personal information. In many implementations in which personal information about a user of a client device may be collected for measurement or used to select third party content, the user may choose to store personal information (e.g., a user's social network, (E.g.,
본 명세서에서 설명된 특허 대상 및 동작은, 본 명세서에 개시된 구조 및 그 구조적 균등물을 포함하는 디지털 전자 회로, 또는 컴퓨터 소프트웨어, 펌웨어 또는 하드웨어, 또는 이들의 하나 이상의 조합으로 구현될 수 있다. 본 명세서에 기술된 주제들의 구현들은 하나 이상의 컴퓨터 프로그램, 예컨대, 데이터 처리 장치에 의한 실행을 위해 또는 그 동작을 제어하기 위해 하나 이상의 컴퓨터 저장 매체 상에 인코딩된, 하나 이상의 컴퓨터 프로그램들, 즉, 컴퓨터 프로그램 명령어들의 하나 이상의 모듈들로서 구현될 수 있다. 선택적으로 또는 부가적으로, 프로그램 명령어는 인위적으로 생성된 전파 신호, 예컨대, 데이터 처리 장치에 의해 실행할 수 있도록 적절한 수신기 장치로 전송하기 위한 정보를 인코딩하기 위해 생성되는 기계-생성 전기 신호, 광학 신호 또는 전자기 신호로 인코딩될 수 있다. 컴퓨터 저장 매체는 컴퓨터 판독 가능 저장 장치, 컴퓨터 판독 가능 저장 기판, 랜덤 또는 직렬 액세스 메모리 어레이 또는 장치, 또는 이들의 하나 이상의 조합일 수도 있고 이들에 포함될 수도 있다. 더욱이, 컴퓨터 저장 매체는 전파 신호가 아니고, 컴퓨터 저장 매체는 인위적으로 생성된 전파 신호로 인코딩된 컴퓨터 프로그램 명령어의 소스 또는 목적지일 수 있다. 컴퓨터 저장 매체는 또한 하나 이상의 개별 컴포넌트 또는 매체(예컨대, 복수의 CD들, 디스크들 또는 다른 저장 장치들)일 수도 있고 이들에 포함될 수도 있다. 따라서, 컴퓨터 저장 매체는 형태를 가질 수 있다.The subject matter and operation described herein may be implemented in digital electronic circuitry, or computer software, firmware, or hardware, or a combination of one or more thereof, including the structures disclosed herein and their structural equivalents. Implementations of the subject matter described herein may be embodied in one or more computer programs, e.g., computer programs, such as computer readable instructions, May be implemented as one or more modules of program instructions. Optionally or additionally, the program instructions may comprise machine-generated electrical signals, optical signals, or other signals generated to encode artificially generated propagated signals, e.g., information for transmission to a suitable receiver device for execution by a data processing apparatus, It can be encoded into an electromagnetic signal. The computer storage media may be a computer readable storage medium, a computer readable storage medium, a random or serial access memory array or device, or a combination of one or more of the foregoing. Moreover, the computer storage media is not a radio signal, and the computer storage media may be a source or destination of computer program instructions encoded with artificially generated propagation signals. Computer storage media may also be or may be comprised of one or more discrete components or media (e.g., a plurality of CDs, disks, or other storage devices). Thus, computer storage media may take the form.
본 명세서에서 서술된 동작들은 하나 이상의 컴퓨터 판독 가능 저장 장치에 저장된 데이터 또는 다른 소스로부터 수신된 데이터에 대해 데이터 처리 장치에 의해 수행되는 동작들로 구현될 수 있다.The operations described herein may be implemented with operations performed by a data processing apparatus for data stored in one or more computer readable storage devices or data received from another source.
"클라이언트" 또는 "서버"라는 용어는 프로그램가능 프로세서, 컴퓨터, 칩상의 시스템, 또는 전술한 것 중 다수의 것들 또는 조합들을 포함하여 데이터를 처리하기 위한 모든 종류의 장치들, 디바이스들 및 기계들을 포함한다. 장치는 특수 목적 논리 회로, 예를 들어 FPGA(현장 프로그램 가능 게이트 어레이) 또는 ASIC(주문형 집적 회로)을 포함할 수 있다. 또한, 장치는 하드웨어 외에, 당해 컴퓨터 프로그램을 위한 실행 환경을 생성하는 코드, 예컨대 프로세서 펌웨어를 구성하는 코드, 프로토콜 스택, 데이터베이스 관리 시스템, 운영 체제, 크로스-플랫폼 런타임(cross-platform runtime) 환경, 가상 머신, 또는 이들 중 하나 이상의 조합을 구성하는 코드를 포함할 수 있다. 장치 및 실행 환경은 웹 서비스, 분산 컴퓨팅 및 그리드 컴퓨팅 인프라스트럭처와 같은 다양한 다른 컴퓨팅 모델 인프라스트럭처를 실현할 수 있다. The term " client " or " server " encompasses all types of devices, devices, and machines for processing data, including a programmable processor, a computer, a system on a chip, do. The device may comprise a special purpose logic circuit, for example an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit). The device may also include, in addition to the hardware, code for creating an execution environment for the computer program, such as code that constitutes processor firmware, a protocol stack, a database management system, an operating system, a cross-platform runtime environment, Machine, or a combination of one or more of these. Devices and execution environments can realize a variety of different computing model infrastructures such as web services, distributed computing, and grid computing infrastructure.
컴퓨터 프로그램(프로그램, 소프트웨어, 소프트웨어 애플리케이션, 앱, 스크립트 또는 코드로도 알려져 있음)은 컴파일된 또는 해석된 언어, 선언적 또는 절차 적 언어를 포함하는 임의의 형태의 프로그래밍 언어로 기록될 수 있으며, 독립형 프로그램 또는 모듈, 컴포넌트, 서브루틴, 객체 또는 컴퓨팅 환경에서 사용하기에 적합한 다른 유닛을 포함하는 임의의 형태로 사용될 수 있다. 컴퓨터 프로그램은 파일 시스템의 파일에 대응할 수 있으나, 반드시 필요한 것은 아니다. 프로그램은 다른 프로그램이나 데이터(예컨대, 마크 업 언어 문서에 저장된 하나 이상의 스크립트)를 보관하는 파일의 일부나, 당해 프로그램에 전용인 단일 파일, 또는 복수의 조정 파일(예컨대, 하나 이상의 모듈, 서브 프로그램 또는 코드의 일부를 저장하는 파일)에 저장될 수 있다. 컴퓨터 프로그램은 하나의 컴퓨터 또는 한 사이트에 있거나 여러 사이트에 분산되어 있으며 통신 네트워크로 상호 연결된 여러 대의 컴퓨터에서 실행되도록 배포될 수 있다.Computer programs (also known as programs, software, software applications, apps, scripts, or code) may be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, Or in any form including modules, components, subroutines, objects, or other units suitable for use in a computing environment. A computer program may correspond to a file in the file system, but it is not necessary. The program may be a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), a single file dedicated to the program, or a plurality of files (e.g., one or more modules, A file that stores a portion of the code). Computer programs can be distributed on a single computer or on a single site or distributed across multiple sites and running on multiple computers interconnected by a communications network.
본 명세서에서 설명된 프로세스 및 논리 흐름은 입력 데이터를 조작하고 출력을 생성함으로써 동작을 수행하기 위한 하나 이상의 컴퓨터 프로그램을 실행하는 하나 이상의 프로그램 가능 프로세서에 의해 수행될 수 있다. 프로세스 및 논리 흐름은 또한, 예컨대, 시스템 온 칩(SOC), FPGA(field programmable gate array) 또는 ASIC(application-specific integrated circuit)과 같은 특수 목적 논리 회로에 의해 수행될 수 있고, 장치는 또한 이러한 특수 목적의 논리 회로로서 구현될 수 있다. The processes and logic flows described herein may be performed by one or more programmable processors executing one or more computer programs for performing operations by manipulating input data and generating output. Process and logic flows may also be performed by special purpose logic circuits such as, for example, a system on chip (SOC), a field programmable gate array (FPGA) or an application specific integrated circuit (ASIC) Can be implemented as a logic circuit of interest.
컴퓨터 프로그램 실행에 적합한 프로세서들에는 일반 및 특수 목적 마이크로 프로세서와 모든 종류의 디지털 컴퓨터의 하나 이상의 프로세서가 포함된다. 일반적으로, 프로세서는 판독 전용 메모리 또는 랜덤 액세스 메모리 또는 둘 모두로부터 명령 및 데이터를 수신할 것이다. 컴퓨터의 필수 구성 요소는 명령어들에 따라 작업을 수행하는 프로세서와 명령어들 및 데이터를 저장하기 위한 하나 이상의 메모리 디바이스들이다. 일반적으로, 컴퓨터는 데이터(예를 들어, 자기, 광자기 디스크들 또는 광 디스크들)를 저장하기 위한 하나 이상의 대용량 저장 장치로부터 데이터를 수신하거나 전송하기 위해 동작 가능하게 결합될 것이다. 그러나, 컴퓨터에는 이러한 장치가 있을 필요가 없다. 또한, 컴퓨터는 이동 전화, 개인 휴대 정보 단말기(PDA), 모바일 오디오 또는 비디오 플레이어, 게임 콘솔, 위성 위치 확인 시스템(GPS) 수신기 또는 휴대용 저장 장치(예를 들어, 범용 직렬 버스(USB) 플래시 드라이브)와 같은 다른 장치에 내장될 수 있다. 컴퓨터 프로그램 명령어 및 데이터를 저장하기에 적합한 장치는, 예를 들어 EPROM, EEPROM 및 플래시 메모리 장치와 같은 반도체 메모리 장치, 내부 하드 디스크 또는 이동식 디스크와 같은 자기 디스크, 광 자기 디스크, 및 CD ROM 및 DVD-ROM 디스크를 포함하는 모든 형태의 비휘발성 메모리, 매체 및 메모리 장치를 포함한다. 프로세서 및 메모리는 특수 목적 논리 회로에 의해 보충되거나 그 안에 포함될 수 있다.Suitable processors for executing computer programs include general and special purpose microprocessors and one or more processors of any kind of digital computer. Generally, a processor will receive commands and data from either a read-only memory or a random access memory, or both. An essential component of a computer is a processor that performs tasks according to instructions and one or more memory devices for storing instructions and data. Generally, a computer will be operably coupled to receive or transmit data from one or more mass storage devices for storing data (e.g., magnetic, magneto-optical disks or optical disks). However, the computer does not need to have such a device. The computer may also be a mobile phone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a GPS receiver or a portable storage device (e.g., a universal serial bus (USB) flash drive) And the like. Apparatus suitable for storing computer program instructions and data may include, for example, semiconductor memory devices such as EPROM, EEPROM and flash memory devices, magnetic disks such as internal hard disks or removable disks, magneto-optical disks, and CD ROM and DVD- ROM disk, all types of non-volatile memory, media, and memory devices. The processor and memory may be supplemented by or included in a special purpose logic circuit.
사용자와의 상호 작용을 제공하기 위해, 본 명세서에서 서술된 주제의 구현들은, 디스플레이 디바이스, 예를 들어, 음극선 관(CRT), 액정 디스플레이(LCD), 유기 발광 다이오드(OLED), 박막 트랜지스터(TFT), 플라즈마, 기타 플렉서블 구성 또는 사용자에게 정보를 디스플레이하는 임의의 다른 모니터, 키보드, 사용자가 컴퓨터에 입력을 제공할 수 있는 마우스, 트랙볼 등과 같은 포인팅 장치 또는 터치 스크린, 터치 패드 등을 갖는 컴퓨터 상에 구현될 수 있다. 다른 종류의 장치가 사용자와의 상호 작용을 제공하는 데 사용될 수 있고; 사용자에게 제공되는 피드백은 시각 피드백, 청각 피드백 또는 촉각 피드백과 같은 임의의 형태의 감각 피드백 일 수 있으며, 그리고 사용자로부터의 입력은 음향, 음성 또는 촉각 입력을 포함하는 임의의 형태로 수신될 수 있다. 또한, 컴퓨터는 사용자가 사용하는 장치와 문서를주고 받음으로써 사용자와 상호 작용할 수 있다. 예를 들어, 웹 브라우저로부터 수신된 요청들에 응답하여 사용자의 클라이언트 장치상의 웹 브라우저에 웹 페이지를 전송함으로써 달성될 수 있다.To provide for interaction with a user, implementations of the subject matter described herein may be implemented in a display device such as a cathode ray tube (CRT), a liquid crystal display (LCD), an organic light emitting diode (OLED), a thin film transistor ), A computer having a plasma or other flexible configuration or any other monitor that displays information to the user, a pointing device or touch screen, such as a keyboard, a mouse that a user can provide input to the computer, a touch screen, Can be implemented. Other types of devices may be used to provide interactions with the user; The feedback provided to the user may be any form of sensory feedback, such as visual feedback, auditory feedback or tactile feedback, and the input from the user may be received in any form including acoustic, voice or tactile input. In addition, the computer can interact with the user by exchanging documents with the device the user is using. For example, by sending a web page to a web browser on the user's client device in response to requests received from the web browser.
본 명세서에서 서술된 주제의 구현들은, 데이터 서버와 같은 백엔드 컴포넌트를 포함하거나, 애플리케이션 서버와 같은 미들웨어 컴포넌트를 포함하거나, 예를 들어 사용자가 본 명세서에서 설명된 특허 대상의 구현과 상호 작용할 수 있게 하는 웹 브라우저 또는 그래픽 사용자 인터페이스를 갖는 클라이언트 컴퓨터와 같은 프론트엔드 컴포넌트, 또는 하나 이상의 이러한 백엔드, 미들웨어 또는 프론트엔드 컴포넌트들의 조합을 포함하는 컴퓨팅 시스템으로 구현될 수 있다. 시스템의 컴포넌트는 디지털 데이터 통신의 임의의 형태 또는 매체, 예를 들어 통신 네트워크에 의해 상호 접속될 수 있다. 통신 네트워크의 예로는 근거리 통신망("LAN") 및 광역 통신망("WAN"), 인터네트워크(예컨대, 인터넷) 및 피어 투 피어 네트워크(예컨대, 애드 혹(ad hoc) 피어 투 피어 네트워크)를 들 수 있다.Implementations of the subject matter described herein may include a back-end component, such as a data server, or may include a middleware component, such as an application server, or may allow a user to interact with an implementation of the subject matter described herein A front end component such as a web browser or a client computer with a graphical user interface, or a computing system including a combination of one or more such backend, middleware or front end components. The components of the system may be interconnected by any form or medium of digital data communication, for example a communication network. Examples of communication networks include a local area network (" LAN ") and a wide area network (" WAN "), an internetwork (e.g., the Internet), and a peer- have.
본 명세서는 많은 특정 구현 세부 사항을 포함하지만, 이들은 발명의 범위 또는 청구될 수 있는 범위에 대한 제한으로 해석되어서는 안되며, 오히려 특정 발명의 특정 구현에 특정된 피처에 대한 설명으로 해석되어서는 안된다. 별도의 구현의 문맥에서 이 명세서에 기술된 특정 특징은 또한 단일 구현으로 조합하여 구현될 수 있다. 반대로, 단일 구현의 문맥에서 기술된 다양한 특징은 또한 다수의 구현 예에서 개별적으로 또는 임의의 적절한 하위 조합으로 구현될 수 있다. 더욱이, 특징들은 특정 조합으로 작용하고 심지어 그 자체로 초기에 청구된 것으로서 기술될 수 있지만, 청구된 조합으로부터의 하나 이상의 특징은 어떤 경우에는 그 조합으로부터 절제될 수 있고, 청구된 조합은 서브 콤비네이션 또는 서브 콤비네이션의 변형을 지향할 수 있다.While this specification contains many specific implementation details, these should not be construed as limitations on the scope of the invention or the scope of what can be claimed, but rather should not be construed as an explanation of features specific to a particular implementation of a particular invention. Certain features described herein in the context of separate implementations may also be implemented in combination in a single implementation. Conversely, various features described in the context of a single implementation may also be implemented in many implementations, either individually or in any suitable subcombination. Moreover, although the features may be described as acting in a particular combination and even claimed as being initially claimed by itself, one or more features from the claimed combination may in some cases be abstained from the combination, and the claimed combination may be subcombined or It is possible to change the subcombination.
유사하게, 동작들이 특정 순서로 도면들에 도시되어 있지만, 이는 바람직한 동작을 달성하기 위해, 표시된 동작들이 순차적으로 또는 순차적으로 수행되거나, 도시된 모든 동작들이 수행될 필요가 있는 것으로 이해되어서는 안된다. 특정 상황에서 멀티 태스킹 및 병렬 처리가 유리할 수 있다. 또한, 상술한 구현 예에서 다양한 시스템 구성 요소의 분리는 모든 구현 예에서 그러한 분리를 요구하는 것으로 이해되어서는 안되며, 서술된 프로그램 구성 요소 및 시스템은 일반적으로 단일 소프트웨어 제품에 함께 통합되거나 여러 소프트웨어 제품에 패키징될 수 있다.Similarly, although operations are shown in the figures in a particular order, it should be understood that the indicated operations may be performed sequentially or sequentially, or that all of the depicted operations need to be performed, in order to achieve the desired operation. Multitasking and parallel processing can be advantageous under certain circumstances. It should also be understood that the separation of the various system components in the above-described implementation is not to be understood as requiring such separation in all implementations, and that the described program components and systems are generally integrated into a single software product, Can be packaged.
따라서, 본 발명의 특정 구현 예가 설명되었다. 다른 구현 예들은 다음의 청구항들의 범위 내에 있다. 하나의 양태 또는 구현을 참조하여 설명된 특징은 임의의 다른 양태 또는 구현 예에서 제공될 수있다. 경우에 따라 청구 범위에 나열된 작업을 다른 순서로 수행할 수 있으며 여전히 바람직한 결과를 얻을 수 있다. 또한, 첨부된 도면에 도시된 프로세스는 바람직한 결과를 얻기 위해 도시된 특정 순서 또는 순차적 순서를 반드시 필요로 하지는 않는다. 특정 구현들에서, 멀티 태스킹 또는 병렬 처리가 이용될 수 있다.Thus, certain embodiments of the present invention have been described. Other implementations are within the scope of the following claims. The features described with reference to one aspect or implementation may be provided in any other aspect or implementation. In some cases, the tasks listed in the claims can be performed in a different order and still produce desirable results. In addition, the process shown in the accompanying drawings does not necessarily require the specific sequence or sequential order shown to obtain the desired result. In certain implementations, multitasking or parallel processing may be used.
Claims (20)
엔트리들을 포함하는 제1 데이터 구조를, 연결 서버(linking server)에 의해 그리고 회사 서버로부터 수신하는 단계 - 각 엔트리는 사용자 태그, 제1 해시된 사용자 정보 및 제2 해시된 사용자 정보를 포함하고, 각 엔트리는 클라이언트 디바이스와 관련되며 - 와;
엔트리들을 포함하는 제2 데이터 구조를, 연결 서버에 의해 그리고 파트너 서버로부터 수신하는 단계 - 각 엔트리는 브리지 태그, 제1 해시된 브리지 정보 및 제2 해시된 브리지 정보를 포함하고, 각 엔트리는 클라이언트 디바이스와 관련되며 - 와;
상기 제1 데이터 구조의 엔트리들 중 제1 엔트리를, 상기 연결 서버에 의해 그리고 상기 제1 데이터 구조로부터 검색하는 단계와;
상기 제2 데이터 구조의 엔트리들 중 제1 엔트리를, 상기 연결 서버에 의해 그리고 상기 제2 데이터 구조로부터 검색하는 단계와;
상기 연결 서버에 의해, 상기 제1 데이터 구조의 제1 엔트리의 제1 해시된 사용자 정보를 상기 제2 데이터 구조의 제1 엔트리의 제1 해시된 브리지 정보와 비교하는 단계와; 그리고
상기 연결 서버에 의해 그리고 매칭을 결정하는 것에 응답하여, 제1 링크를 발생시키기 위해 상기 제1 데이터 구조의 제1 엔트리의 사용자 태그와 상기 제2 데이터 구조의 제1 엔트리의 브리지 태그를 링크시키는 단계를 포함하는 것을 특징으로 하는
사용자 식별자들을 링크하는 방법.A method of linking user identifiers,
Receiving, by a linking server and from a company server, a first data structure comprising entries, each entry comprising a user tag, a first hashed user information and a second hashed user information, An entry is associated with a client device;
Receiving a second data structure comprising entries from a connection server and from a partner server, each entry comprising a bridge tag, a first hashed bridge information and a second hashed bridge information, - and;
Retrieving, by the connection server and from the first data structure, a first one of the entries of the first data structure;
Retrieving a first entry of entries of the second data structure from the connection server and from the second data structure;
Comparing, by the connection server, first hashed user information of a first entry of the first data structure with first hashed bridge information of a first entry of the second data structure; And
Linking a user tag of a first entry of the first data structure and a bridge tag of a first entry of the second data structure to generate a first link by the connection server and in response to determining a match ≪ RTI ID = 0.0 >
A method for linking user identifiers.
상기 비교하는 단계는:
상기 제1 데이터 구조의 제1 엔트리의 제1 해시된 사용자 정보를 제1 세트의 문자들로, 상기 연결 서버에 의해 파싱(parsing)하는 단계와;
상기 제2 데이터 구조의 제1 엔트리의 제1 해시된 브리지 정보를 제2 세트의 문자들로, 상기 연결 서버에 의해 파싱하는 단계와; 그리고
상기 연결 서버에 의해, 상기 제1 세트의 문자들 중 하나의 문자를 상기 제2 세트의 문자들 중 하나의 문자와 비교하는 단계를 더 포함하는 것을 특징으로 하는
사용자 식별자들을 링크하는 방법.The method according to claim 1,
Wherein the comparing comprises:
Parsing the first hashed user information of the first entry of the first data structure by the connection server with a first set of characters;
Parsing the first hashed bridge information of the first entry of the second data structure with a second set of characters by the connection server; And
Further comprising, by the connection server, comparing one character of the first set of characters to one character of the second set of characters
A method for linking user identifiers.
상기 연결 서버에 의해, 상기 제1 링크를 상기 회사 서버에 제공하는 단계를 더 포함하는 것을 특징으로 하는
사용자 식별자들을 링크하는 방법.3. The method according to claim 1 or 2,
Further comprising the step of providing, by the connection server, the first link to the company server
A method for linking user identifiers.
상기 연결 서버는 클린 룸 환경 내에 존재하고,
상기 회사 서버는 상기 클린 룸 환경 외부에 존재하며, 그리고
상기 파트너 서버는 상기 클린 룸 환경 외부에 존재하는 것을 특징으로 하는
사용자 식별자들을 링크하는 방법.4. The method according to any one of claims 1 to 3,
The connection server is in a clean room environment,
The company server is outside the clean room environment, and
Wherein the partner server is outside the clean room environment
A method for linking user identifiers.
상기 연결 서버에 의해, 상기 제1 데이터 구조의 제1 엔트리 및 상기 제2 데이터 구조의 제1 엔트리를 제거하는 단계를 더 포함하는 것을 특징으로 하는
사용자 식별자들을 링크하는 방법.5. The method according to any one of claims 1 to 4,
Further comprising, by the connection server, removing a first entry of the first data structure and a first entry of the second data structure
A method for linking user identifiers.
상기 제1 데이터 구조의 엔트리들 중 제2 엔트리를, 상기 연결 서버에 의해 그리고 상기 제1 데이터 구조로부터 검색하는 단계와;
상기 제2 데이터 구조의 엔트리들 중 제2 엔트리를, 상기 연결 서버에 의해 그리고 상기 제2 데이터 구조로부터 검색하는 단계와; 그리고
상기 연결 서버에 의해, 상기 제1 데이터 구조의 제2 엔트리의 제1 해시된 사용자 정보를 상기 제2 데이터 구조의 제2 엔트리의 제1 해시된 브리지 정보와 비교하는 단계를 더 포함하는 것을 특징으로 하는
사용자 식별자들을 링크하는 방법.6. The method according to any one of claims 1 to 5,
Retrieving a second entry of entries of the first data structure by the connection server and from the first data structure;
Retrieving a second entry of entries of the second data structure from the connection server and from the second data structure; And
And comparing the first hashed user information of the second entry of the first data structure with the first hashed bridge information of the second entry of the second data structure by the connection server doing
A method for linking user identifiers.
상기 연결 서버에 의해, 상기 제1 데이터 구조의 제2 엔트리의 제1 해시된 사용자 정보와 상기 제2 데이터 구조의 제2 엔트리의 제1 해시된 브리지 정보 간의 미스매칭을 결정하는 단계와; 그리고
상기 연결 서버에 의해, 상기 제1 데이터 구조의 제2 엔트리의 제2 해시된 사용자 정보를 상기 제2 데이터 구조의 제2 엔트리의 제2 해시된 브리지 정보와 비교하는 단계를 더 포함하는 것을 특징으로 하는
사용자 식별자들을 링크하는 방법.The method according to claim 6,
Determining, by the connection server, a mismatch between first hashed user information of a second entry of the first data structure and first hashed bridge information of a second entry of the second data structure; And
Comparing the second hashed user information of the second entry of the first data structure with the second hashed bridge information of the second entry of the second data structure by the connection server, doing
A method for linking user identifiers.
상기 연결 서버에 의해, 상기 제1 데이터 구조의 제1 엔트리의 제1 해시된 사용자 정보와 상기 제2 데이터 구조의 제1 엔트리의 제1 해시된 브리지 정보 간의 미스매칭을 결정하는 단계와;
상기 엔트리들 중 제2 엔트리를, 상기 연결 서버에 의해 그리고 상기 제2 데이터 구조로부터 검색하는 단계와; 그리고
상기 연결 서버에 의해, 상기 제1 데이터 구조의 제1 엔트리의 제1 해시된 사용자 정보를 상기 제2 데이터 구조의 제2 엔트리의 제1 해시된 브리지 정보와 비교하는 단계를 더 포함하는 것을 특징으로 하는
사용자 식별자들을 링크하는 방법.6. The method according to any one of claims 1 to 5,
Determining, by the connection server, a mismatch between first hashed user information of a first entry of the first data structure and first hashed bridge information of a first entry of the second data structure;
Retrieving a second one of the entries from the connection server and from the second data structure; And
And comparing the first hashed user information of the first entry of the first data structure with the first hashed bridge information of the second entry of the second data structure by the connection server doing
A method for linking user identifiers.
상기 연결 서버에 의해, 상기 제1 데이터 구조의 제1 엔트리의 제2 해시된 사용자 정보를 상기 제2 데이터 구조의 제2 엔트리의 제2 해시된 브리지 정보와 비교하는 단계와;
상기 연결 서버에 의해 그리고 매칭을 결정하는 것에 응답하여, 제1 링크를 발생시키기 위해 상기 제1 데이터 구조의 제1 엔트리의 사용자 태그와 상기 제2 데이터 구조의 제1 엔트리의 브리지 태그를 링크시키는 단계와; 그리고
상기 연결 서버에 의해, 상기 제1 링크를 상기 회사 서버에 제공하는 단계를 더 포함하는 것을 특징으로 하는
사용자 식별자들을 링크하는 방법.9. The method of claim 8,
Comparing, by the connection server, second hashed user information of a first entry of the first data structure with second hashed bridge information of a second entry of the second data structure;
Linking a user tag of a first entry of the first data structure and a bridge tag of a first entry of the second data structure to generate a first link by the connection server and in response to determining a match Wow; And
Further comprising the step of providing, by the connection server, the first link to the company server
A method for linking user identifiers.
상기 시스템은 연결 서버를 포함하고, 상기 연결 서버는:
엔트리들을 포함하는 제1 데이터 구조를 회사 서버로부터 수신하고, 각 엔트리는 사용자 태그, 제1 해시된 사용자 정보 및 제2 해시된 사용자 정보를 포함하고, 각 엔트리는 클라이언트 디바이스의 사용자와 관련되며,
엔트리들을 포함하는 제2 데이터 구조를 파트너 서버로부터 수신하고, 각 엔트리는 브리지 태그, 제1 해시된 브리지 정보 및 제2 해시된 브리지 정보를 포함하고, 각 엔트리는 클라이언트 디바이스의 사용자와 관련되며,
상기 제1 데이터 구조의 엔트리들 중 제1 엔트리를 상기 제1 데이터 구조로부터 검색하고,
상기 제2 데이터 구조의 엔트리들 중 제1 엔트리를 상기 제2 데이터 구조로부터 검색하고,
상기 제1 데이터 구조의 제1 엔트리의 제1 해시된 사용자 정보를 상기 제2 데이터 구조의 제1 엔트리의 제1 해시된 브리지 정보와 비교하며, 그리고
매칭을 결정하는 것에 응답하여, 제1 링크를 발생시키기 위해 상기 제1 데이터 구조의 제1 엔트리의 사용자 태그와 상기 제2 데이터 구조의 제1 엔트리의 브리지 태그를 링크시키도록 구성되는 것을 특징으로 하는
사용자 식별자들을 링크하는 시스템.A system for linking user identifiers,
The system comprising a connection server, the connection server comprising:
Wherein each entry includes a user tag, a first hashed user information, and a second hashed user information, each entry associated with a user of the client device,
Each entry comprising a bridge tag, a first hashed bridge information and a second hashed bridge information, each entry associated with a user of the client device,
Retrieving a first one of the entries of the first data structure from the first data structure,
Retrieving a first one of the entries of the second data structure from the second data structure,
Compare the first hashed user information of the first entry of the first data structure with the first hashed bridge information of the first entry of the second data structure,
And to link the user tag of the first entry of the first data structure and the bridge tag of the first entry of the second data structure in response to determining a match,
A system for linking user identifiers.
상기 연결 서버는:
상기 제1 데이터 구조의 제1 엔트리의 제1 해시된 사용자 정보를 제1 세트의 문자들로 파싱하고,
상기 제2 데이터 구조의 제1 엔트리의 제1 해시된 브리지 정보를 제2 세트의 문자들로 파싱하며, 그리고
상기 제1 세트의 문자들 중 하나의 문자를 상기 제2 세트의 문자들 중 하나의 문자와 비교하도록 구성되는 것을 특징으로 하는
사용자 식별자들을 링크하는 시스템.11. The method of claim 10,
The connection server comprises:
Parsing the first hashed user information of the first entry of the first data structure into a first set of characters,
Parse the first hashed bridge information of the first entry of the second data structure into a second set of characters, and
And compare one character of the first set of characters with one character of the second set of characters
A system for linking user identifiers.
상기 연결 서버는, 상기 제1 링크를 상기 회사 서버에 제공하도록 더 구성되는 것을 특징으로 하는
사용자 식별자들을 링크하는 시스템.The method according to claim 10 or 11,
Wherein the connection server is further configured to provide the first link to the company server
A system for linking user identifiers.
상기 연결 서버는 클린 룸 환경 내에 존재하고,
상기 회사 서버는 상기 클린 룸 환경 외부에 존재하며, 그리고
상기 파트너 서버는 상기 클린 룸 환경 외부에 존재하는 것을 특징으로 하는
사용자 식별자들을 링크하는 시스템.13. The method according to any one of claims 10 to 12,
The connection server is in a clean room environment,
The company server is outside the clean room environment, and
Wherein the partner server is outside the clean room environment
A system for linking user identifiers.
상기 연결 서버는, 상기 제1 데이터 구조의 제1 엔트리 및 상기 제2 데이터 구조의 제1 엔트리를 제거하도록 더 구성되는 것을 특징으로 하는
사용자 식별자들을 링크하는 시스템.14. The method according to any one of claims 10 to 13,
The connection server is further configured to remove a first entry of the first data structure and a first entry of the second data structure
A system for linking user identifiers.
상기 연결 서버는:
상기 엔트리들 중 제2 엔트리를 상기 제1 데이터 구조로부터 검색하고,
상기 엔트리들 중 제2 엔트리를 상기 제2 데이터 구조로부터 검색하며, 그리고
상기 제1 데이터 구조의 제2 엔트리의 제1 해시된 사용자 정보를 상기 제2 데이터 구조의 제2 엔트리의 제1 해시된 브리지 정보와 비교하도록 더 구성되는 것을 특징으로 하는
사용자 식별자들을 링크하는 시스템.15. The method according to any one of claims 10 to 14,
The connection server comprises:
Retrieving a second entry of the entries from the first data structure,
Retrieving a second entry of the entries from the second data structure, and
And compare the first hashed user information of the second entry of the first data structure with the first hashed bridge information of the second entry of the second data structure
A system for linking user identifiers.
상기 연결 서버는,
상기 제1 데이터 구조의 제2 엔트리의 제1 해시된 사용자 정보와 상기 제2 데이터 구조의 제2 엔트리의 제1 해시된 브리지 정보 간의 미스매칭을 결정하고, 그리고
상기 제1 데이터 구조의 제2 엔트리의 제2 해시된 사용자 정보를 상기 제2 데이터 구조의 제2 엔트리의 제2 해시된 브리지 정보와 비교하도록 더 구성되는 것을 특징으로 하는
사용자 식별자들을 링크하는 시스템.16. The method of claim 15,
The connection server,
Determine a mismatch between first hashed user information of a second entry of the first data structure and first hashed bridge information of a second entry of the second data structure,
And compare the second hashed user information of the second entry of the first data structure with the second hashed bridge information of the second entry of the second data structure
A system for linking user identifiers.
상기 연결 서버는,
상기 제1 데이터 구조의 제1 엔트리의 제1 해시된 사용자 정보와 상기 제2 데이터 구조의 제1 엔트리의 제1 해시된 브리지 정보 간의 미스매칭을 결정하고,
상기 제2 데이터 구조의 엔트리들 중 제2 엔트리를 상기 제2 데이터 구조로부터 검색하며, 그리고
상기 제1 데이터 구조의 제1 엔트리의 제1 해시된 사용자 정보를 상기 제2 데이터 구조의 제2 엔트리의 제1 해시된 브리지 정보와 비교하도록 더 구성되는 것을 특징으로 하는
사용자 식별자들을 링크하는 시스템.15. The method according to any one of claims 10 to 14,
The connection server,
Determining a mismatch between first hashed user information of a first entry of the first data structure and first hashed bridge information of a first entry of the second data structure,
Retrieve a second entry of entries of the second data structure from the second data structure, and
And compare the first hashed user information of the first entry of the first data structure with the first hashed bridge information of the second entry of the second data structure
A system for linking user identifiers.
상기 연결 서버는,
상기 제1 데이터 구조의 제1 엔트리의 제2 해시된 사용자 정보를 상기 제2 데이터 구조의 제2 엔트리의 제2 해시된 브리지 정보와 비교하고,
매칭을 결정하는 것에 응답하여, 제1 링크를 발생시키기 위해 상기 제1 데이터 구조의 제1 엔트리의 사용자 태그와 상기 제2 데이터 구조의 제1 엔트리의 브리지 태그를 링크시키고, 그리고
상기 제1 링크를 상기 회사 서버에 제공하도록 더 구성되는 것을 특징으로 하는
사용자 식별자들을 링크하는 시스템.18. The method of claim 17,
The connection server,
Compare the second hashed user information of the first entry of the first data structure with the second hashed bridge information of the second entry of the second data structure,
Link a user tag of a first entry of the first data structure with a bridge tag of a first entry of the second data structure in response to determining a match,
And to provide the first link to the company server.
A system for linking user identifiers.
엔트리들을 포함하는 제1 데이터 구조를, 연결 서버에 의해 그리고 회사 서버로부터 수신하는 단계 - 각 엔트리는 사용자 태그, 제1 해시된 사용자 정보 및 제2 해시된 사용자 정보를 포함하고, 각 엔트리는 클라이언트 디바이스와 관련되며 - 와;
엔트리들을 포함하는 제2 데이터 구조를, 연결 서버에 의해 그리고 파트너 서버로부터 수신하는 단계 - 각 엔트리는 브리지 태그, 제1 해시된 브리지 정보 및 제2 해시된 브리지 정보를 포함하고, 각 엔트리는 클라이언트 디바이스와 관련되며 - 와;
상기 제1 데이터 구조 및 상기 제2 데이터 구조에 기초하여 제3 데이터 구조를, 상기 연결 서버에 의해 생성하는 단계; 과
상기 연결 서버에 의해, 상기 제3 데이터 구조를 상기 회사 서버에 제공하는 단계를 포함하는 것을 특징으로 하는
사용자 식별자들을 링크하는 방법.A method of linking user identifiers,
Receiving a first data structure comprising entries from a connection server and from a company server, each entry comprising a user tag, a first hashed user information and a second hashed user information, - and;
Receiving a second data structure comprising entries from a connection server and from a partner server, each entry comprising a bridge tag, a first hashed bridge information and a second hashed bridge information, - and;
Generating a third data structure by the connection server based on the first data structure and the second data structure; and
And providing the third data structure to the company server by the connection server.
A method for linking user identifiers.
상기 제1 데이터 구조는 클라이언트 디바이스와 연관된 제1 이메일 주소 및 상기 클라이언트 디바이스와 연관된 제1 전화 번호를 포함하고, 그리고 상기 제2 데이터 구조는 상기 클라이언트 디바이스와 연관된 제2 이메일 주소 및 상기 클라이언트 디바이스와 연관된 제2 전화 번호를 포함하는 것을 특징으로 하는
사용자 식별자들을 링크하는 방법.20. The method of claim 19,
Wherein the first data structure comprises a first email address associated with the client device and a first telephone number associated with the client device and the second data structure includes a second email address associated with the client device and a second email address associated with the client device And a second telephone number.
A method for linking user identifiers.
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US15/419,726 | 2017-01-30 | ||
US15/419,726 US10558817B2 (en) | 2017-01-30 | 2017-01-30 | Establishing a link between identifiers without disclosing specific identifying information |
PCT/US2017/066516 WO2018140146A1 (en) | 2017-01-30 | 2017-12-14 | Establishing a link between identifiers without disclosing specific identifying information |
Publications (2)
Publication Number | Publication Date |
---|---|
KR20190061078A true KR20190061078A (en) | 2019-06-04 |
KR102194202B1 KR102194202B1 (en) | 2020-12-22 |
Family
ID=62979618
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
KR1020197013590A KR102194202B1 (en) | 2017-01-30 | 2017-12-14 | Establish links between identifiers without disclosing specific identifying information |
Country Status (6)
Country | Link |
---|---|
US (1) | US10558817B2 (en) |
EP (1) | EP3516576A4 (en) |
JP (1) | JP7165653B2 (en) |
KR (1) | KR102194202B1 (en) |
CN (1) | CN109891424B (en) |
WO (1) | WO2018140146A1 (en) |
Families Citing this family (23)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
EP3408965B1 (en) * | 2017-03-03 | 2020-08-19 | Google LLC | Systems and methods for establishing a link between identifiers without disclosing specific identifying information |
US10341864B2 (en) | 2017-03-03 | 2019-07-02 | Verizon Patent And Licensing Inc. | Network-based device registration for content distribution platforms |
US20180286000A1 (en) * | 2017-03-31 | 2018-10-04 | At&T Intellectual Property I, L.P. | Identity Management for Offline User Data |
US11444952B2 (en) * | 2018-05-03 | 2022-09-13 | Springcoin, Inc. | Synthetic identification protocol apparatus and method |
US10614250B2 (en) * | 2018-05-04 | 2020-04-07 | GroupSense, Inc. | Systems and methods for detecting and remedying theft of data |
US10949564B2 (en) * | 2018-05-07 | 2021-03-16 | Apple Inc. | Contact discovery service with privacy aspect |
KR102624339B1 (en) * | 2019-02-01 | 2024-01-15 | 삼성전자주식회사 | Electronic device for managing personal information and method thereof |
US11106669B2 (en) * | 2019-04-11 | 2021-08-31 | Sap Se | Blocking natural persons data in analytics |
US20210004481A1 (en) * | 2019-07-05 | 2021-01-07 | Google Llc | Systems and methods for privacy preserving determination of intersections of sets of user identifiers |
CN110851869B (en) * | 2019-11-14 | 2023-09-19 | 深圳前海微众银行股份有限公司 | Sensitive information processing method, device and readable storage medium |
RU2722685C2 (en) * | 2019-11-18 | 2020-06-03 | Общество с ограниченной ответственностью "КВАНТУМ А РУС" | Mobile advertising management system |
US11159665B2 (en) * | 2020-01-29 | 2021-10-26 | Lenovo (Singapore) Pte. Ltd. | Generate user-friendly string to replace telephone number |
US20210357788A1 (en) * | 2020-05-13 | 2021-11-18 | The Nielsen Company (Us), Llc | Methods and apparatus to generate computer-trained machine learning models to correct computer-generated errors in audience data |
US11003789B1 (en) * | 2020-05-15 | 2021-05-11 | Epsilon Data Management, LLC | Data isolation and security system and method |
KR102403462B1 (en) | 2020-07-22 | 2022-05-27 | 경북대학교 산학협력단 | Transmitter, receiver, control apparatus and method using random bit-inversion |
CN114450919B (en) * | 2020-08-14 | 2023-12-19 | 谷歌有限责任公司 | Online privacy protection method and system |
US11805416B2 (en) * | 2020-08-20 | 2023-10-31 | Apple Inc. | Systems and methods for multi-link device privacy protection |
CN112115381A (en) * | 2020-09-28 | 2020-12-22 | 北京百度网讯科技有限公司 | Construction method and device of convergence relationship network, electronic equipment and medium |
WO2022238948A1 (en) * | 2021-05-12 | 2022-11-17 | Pitts Jonathan Graham | Method and system for transforming personally identifiable information |
JPWO2022254821A1 (en) * | 2021-06-04 | 2022-12-08 | ||
US11943354B2 (en) * | 2021-07-20 | 2024-03-26 | Snap Inc. | Privacy safe joint identification protocol |
IL292554A (en) * | 2022-04-27 | 2023-11-01 | Google Llc | Cryptographically secure and privacy-preserving matching |
US11947812B2 (en) * | 2022-08-29 | 2024-04-02 | Capital One Services, Llc | Systems and methods for secure storage of sensitive data |
Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US7610627B1 (en) * | 2004-01-23 | 2009-10-27 | Acxiom Corporation | Secure data exchange technique |
KR101307966B1 (en) * | 2013-04-19 | 2013-09-12 | 동양대학교 산학협력단 | Private information management system |
JP2014513826A (en) * | 2011-02-28 | 2014-06-05 | エイチエスビーシー ホールディングス ピーエルシー | Computer systems, databases and their use |
US20140250111A1 (en) * | 2008-04-24 | 2014-09-04 | Lexisnexis Risk Solutions Fl Inc. | External Linking Based On Hierarchical Level Weightings |
Family Cites Families (26)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5867689A (en) * | 1996-05-01 | 1999-02-02 | Mci Communications Corporation | Method and apparatus for emulating a digital cross-connect switch network using a flexible topology to test MCS network management |
WO1997041657A1 (en) * | 1996-05-01 | 1997-11-06 | Mci Communications Corporation | Method and apparatus for emulating a digital cross-connect switch network |
US5809286A (en) * | 1996-05-01 | 1998-09-15 | Mci Communications Corporation | Method and apparatus for emulating a dynamically configured digital cross-connect switch network |
US8443115B2 (en) * | 2003-12-31 | 2013-05-14 | Motorola Mobility Llc | Method and system for managing access to presence attribute information |
CN101297319B (en) * | 2005-08-23 | 2013-02-27 | 株式会社理光 | Embedding hot spots in electronic documents |
JPWO2008102754A1 (en) * | 2007-02-21 | 2010-05-27 | 日本電気株式会社 | Information association system, method and program for associating user information |
US8495143B2 (en) * | 2010-10-29 | 2013-07-23 | Facebook, Inc. | Inferring user profile attributes from social information |
JP2012247882A (en) | 2011-05-26 | 2012-12-13 | Hitachi Ltd | Matching system for information |
US10733151B2 (en) * | 2011-10-27 | 2020-08-04 | Microsoft Technology Licensing, Llc | Techniques to share media files |
WO2013155066A2 (en) * | 2012-04-09 | 2013-10-17 | Exacttarget, Inc. | System and method for secure distribution of communications |
WO2013158108A1 (en) * | 2012-04-20 | 2013-10-24 | Hewlett-Packard Development Company, L.P. | Unified user profiles |
US8706739B1 (en) * | 2012-04-26 | 2014-04-22 | Narus, Inc. | Joining user profiles across online social networks |
US20140122268A1 (en) * | 2012-10-31 | 2014-05-01 | Wal-Mart Stores, Inc. | Point-Of-Sale-Customer-Identification Apparatus And Method |
US9438488B2 (en) * | 2012-11-09 | 2016-09-06 | Citrix Systems, Inc. | Systems and methods for appflow for datastream |
US9105068B2 (en) * | 2012-11-12 | 2015-08-11 | Facebook, Inc. | Grammar model for structured search queries |
US9589280B2 (en) * | 2013-07-17 | 2017-03-07 | PlaceIQ, Inc. | Matching anonymized user identifiers across differently anonymized data sets |
US20140222561A1 (en) * | 2013-02-04 | 2014-08-07 | Facebook, Inc. | Cross-Platform Advertisement Targeting |
JP5843401B2 (en) * | 2013-06-14 | 2016-01-13 | シャープ株式会社 | Content information providing apparatus, content information providing system, content information providing method, and content information providing program |
CN104636677A (en) | 2013-11-07 | 2015-05-20 | 北京安码科技有限公司 | Data safety storage method based on privacy protection |
US9158925B2 (en) * | 2013-11-27 | 2015-10-13 | Microsoft Technology Licensing, Llc | Server-aided private set intersection (PSI) with data transfer |
US10607726B2 (en) | 2013-11-27 | 2020-03-31 | Accenture Global Services Limited | System for anonymizing and aggregating protected health information |
US9235724B2 (en) * | 2014-03-17 | 2016-01-12 | Saudi Arabian Oil Company | Systems, methods, and computer medium to securely transfer backup data between physically isolated networks having different levels of network protection |
WO2016108983A2 (en) * | 2014-10-07 | 2016-07-07 | Optum, Inc. | Highly secure networked system and methods for storage, processing, and transmission of sensitive personal information |
JP6444702B2 (en) * | 2014-11-21 | 2018-12-26 | 日本調剤株式会社 | Dispensing information management system |
US11601281B2 (en) * | 2016-06-27 | 2023-03-07 | Vmware, Inc. | Managing user profiles securely in a user environment |
US10270746B2 (en) * | 2017-01-25 | 2019-04-23 | Facebook, Inc. | People-based user synchronization within an online system |
-
2017
- 2017-01-30 US US15/419,726 patent/US10558817B2/en active Active
- 2017-12-14 KR KR1020197013590A patent/KR102194202B1/en active IP Right Grant
- 2017-12-14 JP JP2019519727A patent/JP7165653B2/en active Active
- 2017-12-14 WO PCT/US2017/066516 patent/WO2018140146A1/en unknown
- 2017-12-14 CN CN201780066681.3A patent/CN109891424B/en active Active
- 2017-12-14 EP EP17894305.6A patent/EP3516576A4/en active Pending
Patent Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US7610627B1 (en) * | 2004-01-23 | 2009-10-27 | Acxiom Corporation | Secure data exchange technique |
US20140250111A1 (en) * | 2008-04-24 | 2014-09-04 | Lexisnexis Risk Solutions Fl Inc. | External Linking Based On Hierarchical Level Weightings |
JP2014513826A (en) * | 2011-02-28 | 2014-06-05 | エイチエスビーシー ホールディングス ピーエルシー | Computer systems, databases and their use |
KR101307966B1 (en) * | 2013-04-19 | 2013-09-12 | 동양대학교 산학협력단 | Private information management system |
Also Published As
Publication number | Publication date |
---|---|
WO2018140146A1 (en) | 2018-08-02 |
US20180218168A1 (en) | 2018-08-02 |
CN109891424B (en) | 2023-07-18 |
EP3516576A4 (en) | 2020-06-03 |
KR102194202B1 (en) | 2020-12-22 |
CN109891424A (en) | 2019-06-14 |
US10558817B2 (en) | 2020-02-11 |
JP2020507826A (en) | 2020-03-12 |
EP3516576A1 (en) | 2019-07-31 |
JP7165653B2 (en) | 2022-11-04 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
KR102194202B1 (en) | Establish links between identifiers without disclosing specific identifying information | |
US11297048B2 (en) | Secure application access system | |
US20220116219A1 (en) | Zero-knowledge environment based social networking engine | |
CN109325870B (en) | Method and system for sharing private data | |
JP6518844B1 (en) | Middleware security layer for cloud computing services | |
US9047480B2 (en) | Secure application access system | |
US8302169B1 (en) | Privacy enhancements for server-side cookies | |
CN108463827B (en) | System and method for detecting sensitive information leakage while preserving privacy | |
US9202078B2 (en) | Data perturbation and anonymization using one way hash | |
CN107615730A (en) | Across the safe storage based on cloud of the shared data of file system object and client | |
EP3063691A2 (en) | Dynamic de-identification and anonymity | |
US10298401B1 (en) | Network content search system and method | |
JP6542883B2 (en) | Database system, database processing method | |
US11799713B2 (en) | Timestamp-based association of identifiers | |
JP2023162169A (en) | System and method for safe identification information search | |
CN112134882A (en) | System and method for anonymously transferring data in a network | |
US10049222B1 (en) | Establishing application trust levels using taint propagation | |
CN107707528B (en) | Method and device for isolating user information | |
US11741257B2 (en) | Systems and methods for obtaining anonymized information derived from data obtained from external data providers | |
US20220394063A1 (en) | Traffic splitting in kernel for targeted traffic protection | |
CN116702192A (en) | Efficient privacy protection joint calculation method, system and device for data confusion | |
CN114254311A (en) | System and method for anonymously collecting data related to malware from a client device |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
A201 | Request for examination | ||
E902 | Notification of reason for refusal | ||
E701 | Decision to grant or registration of patent right | ||
GRNT | Written decision to grant |