WO2024030114A1 - Multi-label pairwise ranking - Google Patents
Multi-label pairwise ranking Download PDFInfo
- Publication number
- WO2024030114A1 WO2024030114A1 PCT/US2022/039070 US2022039070W WO2024030114A1 WO 2024030114 A1 WO2024030114 A1 WO 2024030114A1 US 2022039070 W US2022039070 W US 2022039070W WO 2024030114 A1 WO2024030114 A1 WO 2024030114A1
- Authority
- WO
- WIPO (PCT)
- Prior art keywords
- label
- ranking
- labels
- computer
- loss
- Prior art date
Links
- 230000006870 function Effects 0.000 claims abstract description 61
- 238000000034 method Methods 0.000 claims abstract description 44
- 230000001143 conditioned effect Effects 0.000 claims abstract description 37
- 230000003750 conditioning effect Effects 0.000 claims description 46
- 238000012549 training Methods 0.000 claims description 24
- 238000005192 partition Methods 0.000 claims description 18
- 230000000295 complement effect Effects 0.000 claims description 12
- 238000000638 solvent extraction Methods 0.000 claims description 11
- 238000012545 processing Methods 0.000 claims description 7
- 238000013459 approach Methods 0.000 abstract description 29
- 238000010801 machine learning Methods 0.000 abstract description 15
- 238000005457 optimization Methods 0.000 abstract description 8
- 238000013528 artificial neural network Methods 0.000 description 14
- 230000015654 memory Effects 0.000 description 11
- 230000006399 behavior Effects 0.000 description 6
- 230000007423 decrease Effects 0.000 description 6
- 238000010586 diagram Methods 0.000 description 6
- 238000009499 grossing Methods 0.000 description 6
- 238000007477 logistic regression Methods 0.000 description 5
- 230000008569 process Effects 0.000 description 5
- 230000004044 response Effects 0.000 description 5
- 238000003860 storage Methods 0.000 description 5
- 230000008901 benefit Effects 0.000 description 4
- 238000004891 communication Methods 0.000 description 4
- 238000009826 distribution Methods 0.000 description 4
- 230000000694 effects Effects 0.000 description 4
- 230000000306 recurrent effect Effects 0.000 description 3
- 230000002776 aggregation Effects 0.000 description 2
- 238000004220 aggregation Methods 0.000 description 2
- 230000004075 alteration Effects 0.000 description 2
- 230000008859 change Effects 0.000 description 2
- 238000013527 convolutional neural network Methods 0.000 description 2
- 238000011156 evaluation Methods 0.000 description 2
- 230000007246 mechanism Effects 0.000 description 2
- 230000009471 action Effects 0.000 description 1
- 238000007792 addition Methods 0.000 description 1
- 230000004931 aggregating effect Effects 0.000 description 1
- 230000009286 beneficial effect Effects 0.000 description 1
- 230000001186 cumulative effect Effects 0.000 description 1
- 230000003247 decreasing effect Effects 0.000 description 1
- 238000005315 distribution function Methods 0.000 description 1
- 230000009977 dual effect Effects 0.000 description 1
- 238000005516 engineering process Methods 0.000 description 1
- 230000003993 interaction Effects 0.000 description 1
- 238000012986 modification Methods 0.000 description 1
- 230000004048 modification Effects 0.000 description 1
- 230000003287 optical effect Effects 0.000 description 1
- 238000013139 quantization Methods 0.000 description 1
- 230000006403 short-term memory Effects 0.000 description 1
- 239000013598 vector Substances 0.000 description 1
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/047—Probabilistic or stochastic networks
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/24—Querying
- G06F16/245—Query processing
- G06F16/2457—Query processing with adaptation to user needs
- G06F16/24578—Query processing with adaptation to user needs using ranking
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/048—Activation functions
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
- G06N3/084—Backpropagation, e.g. using gradient descent
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/044—Recurrent networks, e.g. Hopfield networks
- G06N3/0442—Recurrent networks, e.g. Hopfield networks characterised by memory or gating, e.g. long short-term memory [LSTM] or gated recurrent units [GRU]
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/0464—Convolutional networks [CNN, ConvNet]
Definitions
- the present disclosure relates generally to machine learning. More particularly, the present disclosure relates to pairwise ranking losses for multi-label ranking problems.
- Ranking is an important aspect of various systems or applications such as recommendation systems, information retrieval systems (e.g., search engines), and/or other systems.
- Ranking can refer to the concept of defining a relative ordering between potential items as responses to a particular query.
- a query can be implicit (e.g., defined based on context) or explicit (e.g., defined based on specific natural language and/or image input (e.g., input by a user)).
- a query can be user-agnostic or user-specific.
- items that are candidates for providing as a response to the query can be ranked, where, for example, the ranking orders the items from most relevant to less relevant.
- Ranking is related to but distinct from determining a relevance score for an item relative to a query. For example, while ranking defines a relative ordering between items, a relevance score for a particular item can indicate how relevant the item is for a particular query, irrespective of other potential candidate responses to the query.
- a relevance score is an engagement score.
- an engagement score can indicate a probability that a user will “engage” (e.g., select for further evaluation, information gathering, “click through”, etc.) a particular item if it is presented as a response to a query.
- relevance scores can be predicted or otherwise represented using one or more labels (e.g., a single label indicating a likelihood of engagement) or multiple labels (e.g., multiple different labels corresponding to different ranges of scores or multiple different labels corresponding to fractional labels of a binary outcome such as “engagement”).
- labels e.g., a single label indicating a likelihood of engagement
- multiple labels e.g., multiple different labels corresponding to different ranges of scores or multiple different labels corresponding to fractional labels of a binary outcome such as “engagement”.
- One example aspect of the present disclosure is directed to a computer-implemented method to perform training for multi-label pairwise ranking.
- the method includes processing, by a computing system comprising one or more computing devices, a first input with a machine- learned ranking model to generate a first intermediate representation for the first input.
- the method includes processing, by a computing system comprising one or more computing devices, a second input with the machine-learned ranking model to generate a second intermediate representation for the second input.
- the method includes generating, by the computing system, a first label output for the first input based on the first intermediate representation, wherein the first label output is generated relative to a plurality of potential labels.
- the method includes generating, by the computing system, a second label output for the second input based on the second intermediate representation, wherein the second label output is generated relative to the plurality of potential labels.
- the method includes generating, by the computing system, a ranking output for the first input and the second input based on the first intermediate representation and the second intermediate representation, wherein the ranking output indicates a relative ranking between the first input and the second input.
- the method includes evaluating, by the computing system, one or more ranking loss functions based on the ranking output, wherein the one or more ranking loss functions comprise a conditional loss that is conditioned on a conditioning event partitioned into two complement sets of events.
- the method includes modifying, by the computing system, the machine-learned ranking model based on the one or more ranking loss functions.
- the computer system includes one or more processors and one or more non-transitory computer- readable media.
- the one or more non-transitory computer-readable media collectively store a machine-learned ranking model configured to generate ranking outputs for pairs of inputs that are responsive to a query and configured to generate a respective label output for each input relative to a plurality of potential labels.
- the machine-learned ranking model has been trained using one or more ranking loss functions, wherein the one or more ranking loss functions comprise a conditional loss that is conditioned on a conditioning event partitioned into two complement sets of events.
- the one or more non-transitory computer-readable media collectively store instructions that, when executed by the one or more processors, cause the computer system to run the machine-learned ranking model configured to generate one or both of (a) ranking outputs for the pairs of inputs that are responsive to a query; or (b) the respective label output for each input relative to the plurality of potential labels.
- Figure 1 shows a graphical illustration of a conditional interpretation of joint direct pointwise engagement rate label prediction training with pairwise ranking training.
- Figures 2A-B show graphical illustrations of pairwise implementations of joint multi-label engagement rate label prediction training with conditional ranking training.
- Figure 3A depicts a block diagram of an example computing system.
- Figure 3B depicts a block diagram of an example computing device.
- Figure 3C depicts a block diagram of an example computing device.
- the present disclosure is directed to pairwise ranking losses for multi-label ranking problems.
- One example setting for the proposed approaches is when a machine learning ranking model generates a label output for a given input, where the label output is generated relative to a plurality of potential labels that correspond to relevance scores, and where the relevance scores also define an ordering among items.
- the loss function(s) applied to the machine learning model should capture the labels, the ranking order, and ranking score differences, integrating these into ranking optimization.
- the present disclosure considers a number of general cases.
- predictions provide probabilities of the different label (score) classes based on their ranking, and ranking can provide conditional ranking probabilities between pairs of items conditioned on the event that the items have unequal ranking.
- a loss allows also for adjusting predictions by the label differences between items in the same set.
- a second case is a binary case where multilabels can be interpreted as fractional labels of a binary outcome. Pairwise ranking losses based on the conditional probability that one of the items has a better label than the other can be adapted to this case. As provided by the present disclosure, these losses can be interpreted as conditional probabilities. Given this conditional probability interpretation of these losses, they can be easily integrated in optimization that combines ranking with individual item pointwise multi-class label optimization. For all cases, example techniques provided herein take a view of pairwise ranking in which the loss is applied only to a subset of events which is defined by the relation between labels in a pair. Each such event can dictate two symmetric events conditioned on it with opposite rankings.
- an ideal optimization approach for various ranking systems where both individual relevance scores and ranking matter may combine ranking and individual relevance scoring into a multi-objective training approach and loss function.
- it may be efficient to use a shared intermediate representation from a shared model to provide the signal for both ranking and pointwise individual relevance scoring (e.g., to separately generate the ranking and relevance score predictions from the intermediate representation(s)).
- One example intermediate representation that can be used is a set of logit scores.
- ranking and relevance scoring can be combined using a pairwise approach, applied only on pairs for which opposite labels have been observed, ignoring pairs with equal labels.
- This approach can be seen as applying a conditional ranking loss, where a loss is applied on a pair of items conditioned on the event where the items have opposite labels.
- Optimization seeks the best conditional probability of one item having a better label than the other conditioned on the items having opposite labels.
- This conditional probability can be attained by using the logistic (Sigmoid) function on logit score differences between the items.
- the same approach can be generalized to listwise losses applying the Softmax function on a list of items conditioned on the event that exactly one item has a positive outcome and all others negative ones.
- Various other listwise losses, optimizing ranking scores have been proposed, but they are not always compliant with probability optimization that can be attained with logistic regression, and they may not be generalizable to multiple labels, where it is also important to predict correct labels.
- both ranking methods described can be viewed as regularizers on top of the direct label loss, where one regularizes differences towards 0 in logits, and the other away from 0. In either case, they are biased and may not push to the same optima as the direct label loss.
- engagement outcomes may be recorded as multi-label ones, where the labels also describe ranking order or relevance scores, e.g., a larger label means a better engagement or better relevance.
- rankings include ratings of an item, as opposed to just engagement with the item, as well as quantization of a continuous engagement measure into multiple buckets, where, e.g., a larger score means a better engagement.
- Scores that count the number of engagements with a recommended item in recommendation systems can also be included in this setup.
- One objective of the present disclosure is to provide a ranking loss that is well-aligned with scores learned for individual engagement rates, can be interpreted as a probability measure, but that is able to capture label order relations.
- some example implementations of the present disclosure correspond to a logistic regression approach with either Softmax labels for the multi-label problem, or Sigmoid binary labels for the case where engagement responses may be interpreted as fractional labels.
- the interpretation described above of a pairwise ranking loss as a conditional loss, conditioned on some (conditioning) event, is applied to the multi-label setting.
- Each pair of items with a pair of unequal labels can belong to some conditioning event.
- a partition can be chosen that creates two complement events conditioned on this event, which provide opposite ranking scores between the two items in the pair.
- Logit scores e.g., binary logit scores
- the loss in the multi-label case can be defined on a collection of initial conditioning events, which may (or may not) form a partition of all possible pairwise ranking events into disjoint sets.
- the pair of conditioned events partitions the conditioning event into two complementing sets.
- a pairwise event can invoke the conditioning event and one of the events conditioned on it.
- the event invoked determines the “pairwise label” which in turn determines a loss relative to learned per-label per-item model parameters.
- Such parameters can be multi-label softmax logit scores of the possible labels an item can have.
- the pairwise event may equal the conditioned event or may be a subset of it. Intersecting conditioning events are possible, as long as a pairwise event is clearly associated by definition with only one of the conditioning events. This approach also allows easy combination of ranking losses with learning of the individual label losses.
- C ij be a conditioning event defined on the label pair ⁇ y i , y j ⁇ .
- E i ⁇ Ej ⁇ (the empty set).
- This general approach can give two important technical benefits: First, determining the conditioning and the conditioned events is a form of regularization that emphasizes the traits important for the ranking loss which is designed. Second, in some of the cases, like the binary one, this gives a direct relation between the logits learned for label loss and those for pairwise ranking. Such relations can simplify the optimization for ranking in terms of the individual items’ engagement logit scores. Determining the conditioning events and their partitioning to pairwise ranking events can determine how label logit scores for a pair of items should be updated to improve ranking among items. The approach allows different methods that can focus on different aspects of ranking in such updates.
- Figure 1 shows an example of a pair of items in the same set (query) for which the model trains with both direct engagement rate and conditional pairwise ranking loss as described in the equations above.
- Figure 1 shows a graphical illustration of a conditional interpretation of joint direct pointwise engagement rate label prediction training with conditional ranking training.
- a machine learning ranking model generates a respective engagement probability for each of items A and B by first generating a respective logit score for each item.
- the respective logit score for each item is converted by the Logistic (Sigmoid) function to probability of a positive label (shown as P A for item A and P B for item B).
- a difference between the two respective logit scores can be converted to a conditional probability that the label of A is greater than that of B (i.e., that A should be ranked higher than B) conditioned on the labels being unequal.
- FIGS 2A and 2B show example illustrations of this multi-label setting.
- a machine learning ranking model 12a can process a first input (e.g., item i 14 and, optionally, data descriptive of a query 16) to generate a first intermediate representation (e.g., shown as logit i 20) for the first input.
- the machine learning ranking model 12b can also process a second input (e.g., item j 18 and, optionally, data descriptive of the query 16) to generate a second intermediate representation for the second input (e.g., shown as logit j 21).
- the machine learning ranking model 12b can be the same model as model 12a (e.g., two instantiations of the same model parameters).
- the items 14 and 16 can be any item such as a resource, a webpage, a file, a product, an entity, a user, and/or any candidate result (e.g., responsive to the query 16).
- the query can be any kind of query including a natural language query, an image query, a query that includes user data, a query that includes context data, a query that includes metadata, and/or any other form of query.
- the intermediate representations are shown as logits, other forms of intermediate representations can be used (e.g., embeddings from a hidden layer).
- a computing system can generate a first label output for the first input based on the first intermediate representation.
- the first label output can be a multi-label output that is generated relative to a plurality of potential labels.
- the computing system can generate a second label output for the second input based on the second intermediate representation.
- the second label output can be a multi-label output that is generated relative to a plurality of potential labels.
- a softmax operation 22 can transform the logit i 20 into a set of probability values 24, where each probability value in the set 24 corresponds to a predicted probability of item i 14 having a respective one of the plurality of potential labels.
- the set of probability values 24 can be evaluated using a multi -label loss function 26a.
- the multi-label loss function 26a can compare the set of probability values 24 to a ground truth label for the item i 14.
- the multi-label loss function 26a can be backpropagated (e.g., to modify parameter values of the machine learning ranking model 12a).
- a softmax operation 36 can transform the logit j 21 into a set of probability values 38, where each probability value in the set 38 corresponds to a predicted probability of item j 18 having a respective one of the plurality of potential labels.
- the set of probability values 38 can be evaluated using a multi-label loss function 26b.
- the multi-label loss function 26b can compare the set of probability values 38 to a ground truth label for the item j 18.
- the multi-label loss function 26b can be backpropagated (e.g., to modify parameter values of the machine learning ranking model 12b).
- a logistic (Sigmoid) function 222 can be used to transform the logit i 20 into a probability value that can be treated as selection of one of the plurality of potential labels, where the potential labels correspond to fractional outcomes of a binary label (e.g., as shown at 224).
- the selection at 224 of one of the fractional labels can be evaluated by a binary label loss function 226a.
- the computing system can map the multiple-labels into points on the outcome of the binary probability.
- the fractional binary label loss function 226a representing the multi-label value can be backpropagated (e.g., to modify parameter values of the machine learning ranking model 12a).
- a logistic (Sigmoid) function 236 can be used to transform the logit j 21 into a probability value that can be treated as selection of one of the plurality of potential labels, where the potential labels correspond to fractional outcomes of a binary label (e.g., as shown at 238).
- the selection at 238 of one of the fractional labels can be evaluated by the binary loss function 226b representing multiple labels.
- the loss function 226b can compare the selected label 238 to a ground truth label for the item j 18.
- the loss function 226b can be backpropagated (e.g., to modify parameter values of the machine learning ranking model 12b).
- softmax operators 22 and 36 is shown in Figure 2 A and the use of logistic functions 222 and 236 is shown in Figure 2B
- other operators and/or model layers can be used to generate the label outputs from the intermediate representations.
- one or more fully connected layers can be included (e.g., prior to a softmax operator or logistic function).
- the computing system can generate a ranking output 32 for the first input and the second input based on the first intermediate representation and the second intermediate representation.
- the ranking output can indicate a relative ranking between the first input and the second input.
- the ranking output can indicate a probability that the label for item i 14 is greater than the label for item j 18 (e.g., which may indicate that item i 14 should be ranked higher than item j 18.
- the ranking output 32 can be conditioned on a conditioning event.
- a computing system can determine an aggregate (e.g., by applying an aggregation operation 28) of the logit i 20 and the logit j 21.
- the computing system can generate the ranking output 34 based on said aggregate.
- a logistic function 30 can be applied to the aggregate to generate the ranking output.
- one or more model layers e.g., fully connected neural network layers
- other operators can be positioned between the intermediate representations and the ranking output 32).
- the aggregation operation can be determined by the specific equation of the loss as described herein so as to give some logit value Sj that maps the vectors and Zj as a function of the label values y t and y 7 to a binary logit. Then, this logit is transformed at 30 into a conditional probability of some relation between the label y t and yj conditioned on an event that includes both values of the binary event. For example, conditioned on the conditioning event is the positive event represented by and is the negative one.
- a computing system can determine a difference (e.g., by applying a subtraction operation 228) between the logit i 20 and the logit j 21.
- the computing system can generate the ranking output 34 based on said difference.
- a logistic function 30 can be applied to the difference to generate the ranking output.
- one or more model layers e.g., fully connected neural network layers
- other operators can be positioned between the intermediate representations and the ranking output 32).
- the computing system can evaluate a ranking loss function (L ; ) 34 based on the ranking output 32.
- the ranking loss function 34 can be a conditional loss that is conditioned on a conditioning event partitioned into two complement sets of events, the two complement sets of disjoint events
- the computing system can modify the machine-learned ranking model (12a and 12b) based on the ranking loss function 34.
- the ranking loss function 34 can be backpropagated to update the parameters of the models 12a and 12b.
- Example implementations of the ranking loss function 34 will now be discussed in further detail.
- Example implementations extend the approach (or interpretation) described in a previous section for pairwise ranking with binary labels, in which a ranking loss is applied conditioned on some event.
- a ranking loss is applied conditioned on some event.
- the ranking loss in the binary case, it was a single event of the examples taking opposite labels.
- the ranking loss will be applied on a union of several conditioning events which need not be mutually exclusive, as long as the loss is well defined for a given pair of labels.
- a pair of events conditioned on the conditioning event can be defined by a binary logit value which will take one sign if items are ordered in one direction, and the opposite sign if the opposite direction.
- a ranking loss could also (but does not have to) decrease the probabilities that item i takes label 1 and that item j takes label 9. But what about the probabilities of both items taking labels in ⁇ 2, 3, 4, 5, 6, 7, 8 ⁇ ?
- a loss that increases z i9 and z ;1 will implicitly lower all probabilities of items i and j taking any different label values.
- a loss that increases z i9 and z ;1 and also decreases z tl and Zj 9 will implicitly affect and for v in this set through the Softmax function, but it could either increase or decrease them depending on the actual values of all parameters.
- the ranking loss can now be defined as where /( ⁇ ) is the indicator function, the scaling
- the conditioning event in (4) is that both labels are in [I, k].
- the conditioned events are that one label is I and the other greater than I.
- the loss (3) is applied only for events in which one label is k and the other is I.
- this loss can apply additional smoothing to the intermediate labels by applying a scaling factor.
- a scaling factor can be inversely proportional to the distance between the label and I and k.
- an inverse scaling of c can be applied, where c is a constant that is determined such that the sum of all scaling factors sums to 1 (or to another value).
- Such scaling creates a smoothing, in which greater loss is applied to labels closer to the ones observed, and the loss scales down in the range between them.
- a similar idea can be used to smooth label losses when optimizing for individual engagement label loss, where the labels also have relevance information that may affect adjacent labels, and a goal is to focus on learning a smooth label distribution (e.g., probability mass function).
- An alternative partitioning method for ranking loss is to use binary logits to separate sets of labels hierarchically. Instead of using Softmax, labels will be aggregated into two sets and a binary logit distinguishes between the sets. Then, the loss evaluation system can recurse down in one of the sets to update binary logits to distinguish among all labels. This can be done for the direct engagement loss per item. Grouping can be done as a binary search tree, partitioning labels into sets of half in each level, or by separating one label from the rest in every recursion step. Ranking loss then uses the binary approach for each level. If the labels for items i and j are in the same set, no loss is incurred and recursion goes down applied on this set.
- a binary ranking loss is applied conditioned on the event that one label is in one partition and the other in the other. The process then stops.
- This approach still does not fully distinguish between labels in the same set, once the label for item i is separated from that of j.
- the overall logits for all labels in the set of the label y t will equally move, and similarly those in the set of y ; -, whereas the movement will happen on the binary logit score representing the set. Outside the granularity of the sets, the loss will attain an expected ranking behavior.
- the choice of the recursive partitioning can be made so that set logit movements are reasonable for the specific application.
- An additional softmax loss can be applied within a set to further identify the label after set partitioning occurred from the label of the other item.
- FIG. 3 A depicts a block diagram of an example computing system 100 according to example embodiments of the present disclosure.
- the system 100 includes a user computing device 102, a server computing system 130, and a training computing system 150 that are communicatively coupled over a network 180.
- the user computing device 102 can be any type of computing device, such as, for example, a personal computing device (e.g., laptop or desktop), a mobile computing device (e.g., smartphone or tablet), a gaming console or controller, a wearable computing device, an embedded computing device, or any other type of computing device.
- a personal computing device e.g., laptop or desktop
- a mobile computing device e.g., smartphone or tablet
- a gaming console or controller e.g., a gaming console or controller
- a wearable computing device e.g., an embedded computing device, or any other type of computing device.
- the user computing device 102 includes one or more processors 112 and a memory 114.
- the one or more processors 112 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, an FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected.
- the memory 114 can include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof.
- the memory 114 can store data 116 and instructions 118 which are executed by the processor 112 to cause the user computing device 102 to perform operations.
- the user computing device 102 can store or include one or more machine-learned ranking models 120.
- the machine-learned ranking models 120 can be or can otherwise include various machine-learned models such as neural networks (e.g., deep neural networks) or other types of machine-learned models, including non-linear models and/or linear models.
- Neural networks can include feed-forward neural networks, recurrent neural networks (e.g., long short-term memory recurrent neural networks), convolutional neural networks or other forms of neural networks.
- Some example machine-learned models can leverage an attention mechanism such as self-attention.
- some example machine- learned models can include multi-headed self-attention models (e.g., transformer models).
- the one or more machine-learned ranking models 120 can be received from the server computing system 130 over network 180, stored in the user computing device memory 114, and then used or otherwise implemented by the one or more processors 112.
- the user computing device 102 can implement multiple parallel instances of a single machine-learned ranking model 120 (e.g., to perform parallel ranking across multiple instances of pairwise inputs).
- one or more machine-learned ranking models 140 can be included in or otherwise stored and implemented by the server computing system 130 that communicates with the user computing device 102 according to a client-server relationship.
- the machine-learned ranking models 140 can be implemented by the server computing system 140 as a portion of a web service (e.g., a information retrieval service).
- a web service e.g., a information retrieval service.
- one or more models 120 can be stored and implemented at the user computing device 102 and/or one or more models 140 can be stored and implemented at the server computing system 130.
- the user computing device 102 can also include one or more user input components 122 that receives user input.
- the user input component 122 can be a touch-sensitive component (e.g., a touch-sensitive display screen or a touch pad) that is sensitive to the touch of a user input object (e.g., a finger or a stylus).
- the touch-sensitive component can serve to implement a virtual keyboard.
- Other example user input components include a microphone, a traditional keyboard, or other means by which a user can provide user input.
- the server computing system 130 includes one or more processors 132 and a memory 134.
- the one or more processors 132 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, an FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected.
- the memory 134 can include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof.
- the memory 134 can store data 136 and instructions 138 which are executed by the processor 132 to cause the server computing system 130 to perform operations.
- the server computing system 130 includes or is otherwise implemented by one or more server computing devices. In instances in which the server computing system 130 includes plural server computing devices, such server computing devices can operate according to sequential computing architectures, parallel computing architectures, or some combination thereof.
- the server computing system 130 can store or otherwise include one or more machine-learned ranking models 140.
- the models 140 can be or can otherwise include various machine-learned models.
- Example machine-learned models include neural networks or other multi-layer non-linear models.
- Example neural networks include feed forward neural networks, deep neural networks, recurrent neural networks, and convolutional neural networks.
- Some example machine-learned models can leverage an attention mechanism such as self-attention.
- some example machine-learned models can include multi-headed self-attention models (e.g., transformer models).
- the user computing device 102 and/or the server computing system 130 can train the models 120 and/or 140 via interaction with the training computing system 150 that is communicatively coupled over the network 180.
- the training computing system 150 can be separate from the server computing system 130 or can be a portion of the server computing system 130.
- the training computing system 150 includes one or more processors 152 and a memory 154.
- the one or more processors 152 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, an FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected.
- the memory 154 can include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof.
- the memory 154 can store data 156 and instructions 158 which are executed by the processor 152 to cause the training computing system 150 to perform operations.
- the training computing system 150 includes or is otherwise implemented by one or more server computing devices.
- the training computing system 150 can include a model trainer 160 that trains the machine-learned models 120 and/or 140 stored at the user computing device 102 and/or the server computing system 130 using various training or learning techniques, such as, for example, backwards propagation of errors.
- a loss function can be backpropagated through the model(s) to update one or more parameters of the model(s) (e.g., based on a gradient of the loss function).
- Various loss functions can be used such as mean squared error, likelihood loss, cross entropy loss, hinge loss, and/or various other loss functions.
- Gradient descent techniques can be used to iteratively update the parameters over a number of training iterations.
- performing backwards propagation of errors can include performing truncated backpropagation through time.
- the model trainer 160 can perform a number of generalization techniques (e.g., weight decays, dropouts, etc.) to improve the generalization capability of the models being trained.
- the model trainer 160 can train the machine-learned ranking models 120 and/or 140 based on a set of training data 162.
- the training data 162 can include, for example, inputs annotated with ground truth labels.
- the training examples can be provided by the user computing device 102.
- the model 120 provided to the user computing device 102 can be trained by the training computing system 150 on user-specific data received from the user computing device 102. In some instances, this process can be referred to as personalizing the model.
- the model trainer 160 includes computer logic utilized to provide desired functionality.
- the model trainer 160 can be implemented in hardware, firmware, and/or software controlling a general purpose processor.
- the model trainer 160 includes program files stored on a storage device, loaded into a memory and executed by one or more processors.
- the model trainer 160 includes one or more sets of computer-executable instructions that are stored in a tangible computer-readable storage medium such as RAM, hard disk, or optical or magnetic media.
- the network 180 can be any type of communications network, such as a local area network (e.g., intranet), wide area network (e.g., Internet), or some combination thereof and can include any number of wired or wireless links.
- communication over the network 180 can be carried via any type of wired and/or wireless connection, using a wide variety of communication protocols (e.g., TCP/IP, HTTP, SMTP, FTP), encodings or formats (e.g., HTML, XML), and/or protection schemes (e.g., VPN, secure HTTP, SSL).
- Figure 3 A illustrates one example computing system that can be used to implement the present disclosure.
- the user computing device 102 can include the model trainer 160 and the training dataset 162.
- the models 120 can be both trained and used locally at the user computing device 102.
- the user computing device 102 can implement the model trainer 160 to personalize the models 120 based on userspecific data.
- FIG. 3B depicts a block diagram of an example computing device 10 that performs according to example embodiments of the present disclosure.
- the computing device 10 can be a user computing device or a server computing device.
- the computing device 10 includes a number of applications (e.g., applications 1 through N). Each application contains its own machine learning library and machine-learned model(s). For example, each application can include a machine-learned model.
- Example applications include a text messaging application, an email application, a dictation application, a virtual keyboard application, a browser application, etc.
- each application can communicate with a number of other components of the computing device, such as, for example, one or more sensors, a context manager, a device state component, and/or additional components.
- each application can communicate with each device component using an API (e.g., a public API).
- the API used by each application is specific to that application.
- Figure 3C depicts a block diagram of an example computing device 50 that performs according to example embodiments of the present disclosure.
- the computing device 50 can be a user computing device or a server computing device.
- the computing device 50 includes a number of applications (e.g., applications 1 through N). Each application is in communication with a central intelligence layer.
- Example applications include a text messaging application, an email application, a dictation application, a virtual keyboard application, a browser application, etc.
- each application can communicate with the central intelligence layer (and model(s) stored therein) using an API (e.g., a common API across all applications).
- the central intelligence layer includes a number of machine-learned models. For example, as illustrated in Figure 3C, a respective machine-learned model can be provided for each application and managed by the central intelligence layer. In other implementations, two or more applications can share a single machine-learned model. For example, in some implementations, the central intelligence layer can provide a single model for all of the applications. In some implementations, the central intelligence layer is included within or otherwise implemented by an operating system of the computing device 50. [99] The central intelligence layer can communicate with a central device data layer. The central device data layer can be a centralized repository of data for the computing device 50.
- the central device data layer can communicate with a number of other components of the computing device, such as, for example, one or more sensors, a context manager, a device state component, and/or additional components.
- the central device data layer can communicate with each device component using an API (e.g., a private API).
Abstract
Provided are pairwise ranking losses for multi-label ranking problems. One example setting for the proposed approaches is when a machine learning ranking model generates a label output for a given input, where the label output is generated relative to a plurality of potential labels that correspond to relevance scores, and where the relevance scores can also define an ordering among items. The loss function(s) applied to the machine learning model capture the labels, the ranking order, and ranking score differences, integrating these into ranking optimization. Example techniques provided herein take a view of pairwise ranking in which the loss is applied only to a subset of events which is defined by the relation between labels in a pair. Each such event can dictate two symmetric events conditioned on it with opposite rankings.
Description
MULTI-LABEL PAIRWISE RANKING
FIELD
[1] The present disclosure relates generally to machine learning. More particularly, the present disclosure relates to pairwise ranking losses for multi-label ranking problems.
BACKGROUND
[2] Ranking is an important aspect of various systems or applications such as recommendation systems, information retrieval systems (e.g., search engines), and/or other systems. Ranking can refer to the concept of defining a relative ordering between potential items as responses to a particular query. A query can be implicit (e.g., defined based on context) or explicit (e.g., defined based on specific natural language and/or image input (e.g., input by a user)). A query can be user-agnostic or user-specific. Thus, items that are candidates for providing as a response to the query can be ranked, where, for example, the ranking orders the items from most relevant to less relevant.
[3] Ranking is related to but distinct from determining a relevance score for an item relative to a query. For example, while ranking defines a relative ordering between items, a relevance score for a particular item can indicate how relevant the item is for a particular query, irrespective of other potential candidate responses to the query. One example form of a relevance score is an engagement score. In some instances, an engagement score can indicate a probability that a user will “engage” (e.g., select for further evaluation, information gathering, “click through”, etc.) a particular item if it is presented as a response to a query. In some instances, relevance scores (e.g., an engagement score) can be predicted or otherwise represented using one or more labels (e.g., a single label indicating a likelihood of engagement) or multiple labels (e.g., multiple different labels corresponding to different ranges of scores or multiple different labels corresponding to fractional labels of a binary outcome such as “engagement”).
[4] In large scale machine learning systems that train over a large amount of data, optimizing for individual relevance scores (e.g., engagement rates) does not always lead to the same results as optimizing for ranking. For some systems, only ranking is important, and these systems would ideally optimize only for ranking. However, due to sparsity in such systems, where items rarely co-occur in the same recommendation set, it may be infeasible to directly optimize for ranking
only. Other systems, like click-through-rate (CTR) predictions, may need good predictions of both individual relevance scores (or of individual labels) and of ranking. Thus, techniques that enable systems to train on both ranking and individual scoring objectives with improved balance are desired in the art.
SUMMARY
[5] Aspects and advantages of embodiments of the present disclosure will be set forth in part in the following description, or can be learned from the description, or can be learned through practice of the embodiments.
[6] One example aspect of the present disclosure is directed to a computer-implemented method to perform training for multi-label pairwise ranking. The method includes processing, by a computing system comprising one or more computing devices, a first input with a machine- learned ranking model to generate a first intermediate representation for the first input. The method includes processing, by a computing system comprising one or more computing devices, a second input with the machine-learned ranking model to generate a second intermediate representation for the second input. The method includes generating, by the computing system, a first label output for the first input based on the first intermediate representation, wherein the first label output is generated relative to a plurality of potential labels. The method includes generating, by the computing system, a second label output for the second input based on the second intermediate representation, wherein the second label output is generated relative to the plurality of potential labels. The method includes generating, by the computing system, a ranking output for the first input and the second input based on the first intermediate representation and the second intermediate representation, wherein the ranking output indicates a relative ranking between the first input and the second input. The method includes evaluating, by the computing system, one or more ranking loss functions based on the ranking output, wherein the one or more ranking loss functions comprise a conditional loss that is conditioned on a conditioning event partitioned into two complement sets of events. The method includes modifying, by the computing system, the machine-learned ranking model based on the one or more ranking loss functions.
[7] Another example aspect of the present disclosure is directed to a computer system. The computer system includes one or more processors and one or more non-transitory computer-
readable media. The one or more non-transitory computer-readable media collectively store a machine-learned ranking model configured to generate ranking outputs for pairs of inputs that are responsive to a query and configured to generate a respective label output for each input relative to a plurality of potential labels. The machine-learned ranking model has been trained using one or more ranking loss functions, wherein the one or more ranking loss functions comprise a conditional loss that is conditioned on a conditioning event partitioned into two complement sets of events. The one or more non-transitory computer-readable media collectively store instructions that, when executed by the one or more processors, cause the computer system to run the machine-learned ranking model configured to generate one or both of (a) ranking outputs for the pairs of inputs that are responsive to a query; or (b) the respective label output for each input relative to the plurality of potential labels.
[8] Other aspects of the present disclosure are directed to various systems, apparatuses, non- transitory computer-readable media, user interfaces, and electronic devices.
[9] These and other features, aspects, and advantages of various embodiments of the present disclosure will become better understood with reference to the following description and appended claims. The accompanying drawings, which are incorporated in and constitute a part of this specification, illustrate example embodiments of the present disclosure and, together with the description, serve to explain the related principles.
BRIEF DESCRIPTION OF THE DRAWINGS
[10] Detailed discussion of embodiments directed to one of ordinary skill in the art is set forth in the specification, which makes reference to the appended figures, in which:
[11] Figure 1 shows a graphical illustration of a conditional interpretation of joint direct pointwise engagement rate label prediction training with pairwise ranking training.
[12] Figures 2A-B show graphical illustrations of pairwise implementations of joint multi-label engagement rate label prediction training with conditional ranking training.
[13] Figure 3A depicts a block diagram of an example computing system.
[14] Figure 3B depicts a block diagram of an example computing device.
[15] Figure 3C depicts a block diagram of an example computing device.
[16] Reference numerals that are repeated across plural figures are intended to identify the same features in various implementations.
DETAILED DESCRIPTION
Overview
[17] Generally, the present disclosure is directed to pairwise ranking losses for multi-label ranking problems. One example setting for the proposed approaches is when a machine learning ranking model generates a label output for a given input, where the label output is generated relative to a plurality of potential labels that correspond to relevance scores, and where the relevance scores also define an ordering among items. In particular, unlike most ranking work, in this setting not only the ordering by relevance scores matters, but also the actual labels themselves. As such, the loss function(s) applied to the machine learning model should capture the labels, the ranking order, and ranking score differences, integrating these into ranking optimization. The present disclosure considers a number of general cases. In one example case, predictions provide probabilities of the different label (score) classes based on their ranking, and ranking can provide conditional ranking probabilities between pairs of items conditioned on the event that the items have unequal ranking. Such a loss allows also for adjusting predictions by the label differences between items in the same set. A second case is a binary case where multilabels can be interpreted as fractional labels of a binary outcome. Pairwise ranking losses based on the conditional probability that one of the items has a better label than the other can be adapted to this case. As provided by the present disclosure, these losses can be interpreted as conditional probabilities. Given this conditional probability interpretation of these losses, they can be easily integrated in optimization that combines ranking with individual item pointwise multi-class label optimization. For all cases, example techniques provided herein take a view of pairwise ranking in which the loss is applied only to a subset of events which is defined by the relation between labels in a pair. Each such event can dictate two symmetric events conditioned on it with opposite rankings.
[18] More particularly, an ideal optimization approach for various ranking systems where both individual relevance scores and ranking matter may combine ranking and individual relevance scoring into a multi-objective training approach and loss function. When combining ranking and relevance scoring, it may be efficient to use a shared intermediate representation from a shared model to provide the signal for both ranking and pointwise individual relevance scoring (e.g., to separately generate the ranking and relevance score predictions from the intermediate
representation(s)). One example intermediate representation that can be used is a set of logit scores. Thus, while portions of the present disclosure will focus on use of logit scores, it should be understood that these portions can be equally applied to other intermediate representations (e.g., “embeddings”). Using logit intermediate scores that are shared between an individual relevance and a ranking task with correct configuration can give ranking losses interpretation of losses optimizing conditional probabilities
[19] In the binary label case, ranking and relevance scoring can be combined using a pairwise approach, applied only on pairs for which opposite labels have been observed, ignoring pairs with equal labels. This approach can be seen as applying a conditional ranking loss, where a loss is applied on a pair of items conditioned on the event where the items have opposite labels. Optimization seeks the best conditional probability of one item having a better label than the other conditioned on the items having opposite labels. This conditional probability can be attained by using the logistic (Sigmoid) function on logit score differences between the items. The same approach can be generalized to listwise losses applying the Softmax function on a list of items conditioned on the event that exactly one item has a positive outcome and all others negative ones. Various other listwise losses, optimizing ranking scores, have been proposed, but they are not always compliant with probability optimization that can be attained with logistic regression, and they may not be generalizable to multiple labels, where it is also important to predict correct labels.
[20] Combining ranking loss with individual item label loss is a balancing act between two objectives that may agree only if models are fully correctly specified and labels are independently distributed, but do not agree in practice. With logistic regression, while an individual engagement rate focuses on the empirical distribution of the labels, the ranking loss focuses on the empirical distribution of the label (logit) differences. If the pairwise approach, which equally divides the pairwise label when label ties occur, is used, the ranking loss effectively regularizes ranking predictions towards 0 in logit space. On the other hand, the conditional approach, which applies the ranking loss only when labels are unequal, emphasizes the difference between items, pushing ranking prediction away from 0 logit. When ranking loss is combined with individual label loss, both ranking methods described can be viewed as regularizers on top of the direct label loss, where one regularizes differences towards 0 in logits,
and the other away from 0. In either case, they are biased and may not push to the same optima as the direct label loss.
[21] In various applications, engagement outcomes may be recorded as multi-label ones, where the labels also describe ranking order or relevance scores, e.g., a larger label means a better engagement or better relevance. Examples include ratings of an item, as opposed to just engagement with the item, as well as quantization of a continuous engagement measure into multiple buckets, where, e.g., a larger score means a better engagement. Scores that count the number of engagements with a recommended item in recommendation systems can also be included in this setup. One objective of the present disclosure is to provide a ranking loss that is well-aligned with scores learned for individual engagement rates, can be interpreted as a probability measure, but that is able to capture label order relations.
[22] In particular, some example implementations of the present disclosure correspond to a logistic regression approach with either Softmax labels for the multi-label problem, or Sigmoid binary labels for the case where engagement responses may be interpreted as fractional labels. The interpretation described above of a pairwise ranking loss as a conditional loss, conditioned on some (conditioning) event, is applied to the multi-label setting. Each pair of items with a pair of unequal labels can belong to some conditioning event. Within this conditioning event, a partition can be chosen that creates two complement events conditioned on this event, which provide opposite ranking scores between the two items in the pair. Logit scores (e.g., binary logit scores) can then be defined that, conditioned on the original conditioning event, discriminate between the two conditional events with opposite rankings. Opposite binary ranking scores on these two events lead to the definition of a conditional loss. Unlike the case of binary labels where there is only a single conditioning event, the loss in the multi-label case can be defined on a collection of initial conditioning events, which may (or may not) form a partition of all possible pairwise ranking events into disjoint sets. The pair of conditioned events partitions the conditioning event into two complementing sets. A pairwise event can invoke the conditioning event and one of the events conditioned on it. The event invoked determines the “pairwise label” which in turn determines a loss relative to learned per-label per-item model parameters. Such parameters can be multi-label softmax logit scores of the possible labels an item can have. The pairwise event may equal the conditioned event or may be a subset of it. Intersecting conditioning events are possible, as long as a pairwise event is clearly associated by definition
with only one of the conditioning events. This approach also allows easy combination of ranking losses with learning of the individual label losses.
[23] More precisely, let Cij be a conditioning event defined on the label pair {yi, yj} . Let Ei and Ej be a partition of Cij, such that Ei U Ej = Cijand (optionally) Ei ∩ Ej = Φ (the empty set). Let the pair {k, 1} ∈ Cij. Then, if by definition, we choose to invoke
[24] This general approach can give two important technical benefits: First, determining the conditioning and the conditioned events is a form of regularization that emphasizes the traits important for the ranking loss which is designed. Second, in some of the cases, like the binary one, this gives a direct relation between the logits learned for label loss and those for pairwise ranking. Such relations can simplify the optimization for ranking in terms of the individual items’ engagement logit scores. Determining the conditioning events and their partitioning to pairwise ranking events can determine how label logit scores for a pair of items should be updated to improve ranking among items. The approach allows different methods that can focus on different aspects of ranking in such updates.
Example Discussion of Binary Ranking Conditional Pairwise Ranking
[25] This section first overviews a conditional interpretation of an example pairwise approach in a binary label setting: Let t G {1, 2, ... , T} denote the index of a set of Nt examples (shown for the t-th query) in the training dataset. Let denote the label of example i in query t. Let
[26] To add a ranking loss, we can now define the probability given by the logistic function of the logit score difference, wh
[28] By the inverse function of the Sigmoid, it can be shown that p-j gives the conditional probability of a positive/negative label pair conditioned on unequal labels. For brevity, we omit the query superscript t in the analysis.
[30] Note that the last equality, relating Pij to the conditional probability, is only true under the assumption that the events represented by pt and Pj are independent. This is clearly not the case in practice. However, we expect that the conditional ranking loss combined with the pointwise engagement loss will yield an optimum that balances between the marginal independent predictions of the direct engagement model, and the ranking predictions of the ranking model, which do model the effects of one item over the other, and are thus not independent by definition. We can think of pt and Pj as some expectation of a product of a marginal probability (Pi) and conditional Pj (conditioned on the event represented by p^).
[31] Figure 1 shows an example of a pair of items in the same set (query) for which the model trains with both direct engagement rate and conditional pairwise ranking loss as described in the equations above. Specifically, Figure 1 shows a graphical illustration of a conditional interpretation of joint direct pointwise engagement rate label prediction training with conditional ranking training. A machine learning ranking model generates a respective engagement probability for each of items A and B by first generating a respective logit score for each item. The respective logit score for each item is converted by the Logistic (Sigmoid) function to probability of a positive label (shown as PA for item A and PB for item B). A difference between the two respective logit scores can be converted to a conditional probability that the label of A is greater than that of B (i.e., that A should be ranked higher than B) conditioned on the labels being unequal.
[32] The proof that a ranking loss as defined above models the conditional probability conditioned on unequal labels can be generalized to listwise Softmax multi-item losses to show that a similar approach, using Softmax on logits, where there is a Softmax component to the binary logit of each item, models the ranking probability as the conditional probability of an item having positive engagement conditioned on the event that exactly one item in the set has a positive engagement while all other items have negative ones.
Example Discussion of Multi-Label Pairwise Ranking
[33] Now consider the same pairwise setting, but in which individual outcomes have multiple labels, where the actual label values make a difference. Without loss of generality, we can consider a set of L integer labels {0,1, 2, ... , L — 1], where, e.g., a larger label means a better score and higher ranking (more relevance), and in the engagement case, a 0 label means no engagement at all. If item i has a larger label than item j, it is ranked higher. We may care only which item is ranked higher in a pair of two, or also how much higher the ranking of i is relative to j.
[34] Figures 2A and 2B show example illustrations of this multi-label setting. Specifically, referring to both Figures 2A and 2B, a machine learning ranking model 12a can process a first input (e.g., item i 14 and, optionally, data descriptive of a query 16) to generate a first intermediate representation (e.g., shown as logit i 20) for the first input. The machine learning ranking model 12b can also process a second input (e.g., item j 18 and, optionally, data
descriptive of the query 16) to generate a second intermediate representation for the second input (e.g., shown as logit j 21). The machine learning ranking model 12b can be the same model as model 12a (e.g., two instantiations of the same model parameters).
[35] The items 14 and 16 can be any item such as a resource, a webpage, a file, a product, an entity, a user, and/or any candidate result (e.g., responsive to the query 16). The query can be any kind of query including a natural language query, an image query, a query that includes user data, a query that includes context data, a query that includes metadata, and/or any other form of query. Although the intermediate representations are shown as logits, other forms of intermediate representations can be used (e.g., embeddings from a hidden layer).
[36] A computing system can generate a first label output for the first input based on the first intermediate representation. Specifically, the first label output can be a multi-label output that is generated relative to a plurality of potential labels. Similarly, the computing system can generate a second label output for the second input based on the second intermediate representation. Specifically, the second label output can be a multi-label output that is generated relative to a plurality of potential labels.
[37] As an example, as shown in Figure 2A, a softmax operation 22 can transform the logit i 20 into a set of probability values 24, where each probability value in the set 24 corresponds to a predicted probability of item i 14 having a respective one of the plurality of potential labels. The set of probability values 24 can be evaluated using a multi -label loss function 26a. For example, the multi-label loss function 26a can compare the set of probability values 24 to a ground truth label for the item i 14. The multi-label loss function 26a can be backpropagated (e.g., to modify parameter values of the machine learning ranking model 12a).
[38] Likewise, referring still to Figure 2A, a softmax operation 36 can transform the logit j 21 into a set of probability values 38, where each probability value in the set 38 corresponds to a predicted probability of item j 18 having a respective one of the plurality of potential labels. The set of probability values 38 can be evaluated using a multi-label loss function 26b. For example, the multi-label loss function 26b can compare the set of probability values 38 to a ground truth label for the item j 18. The multi-label loss function 26b can be backpropagated (e.g., to modify parameter values of the machine learning ranking model 12b).
[39] Referring now to Figure 2B, as another example, a logistic (Sigmoid) function 222 can be used to transform the logit i 20 into a probability value that can be treated as selection of one of
the plurality of potential labels, where the potential labels correspond to fractional outcomes of a binary label (e.g., as shown at 224). The selection at 224 of one of the fractional labels can be evaluated by a binary label loss function 226a. In the binary label loss function 226a, the computing system can map the multiple-labels into points on the outcome of the binary probability. The fractional binary label loss function 226a representing the multi-label value can be backpropagated (e.g., to modify parameter values of the machine learning ranking model 12a).
[40] Likewise, referring still to Figure 2B, a logistic (Sigmoid) function 236 can be used to transform the logit j 21 into a probability value that can be treated as selection of one of the plurality of potential labels, where the potential labels correspond to fractional outcomes of a binary label (e.g., as shown at 238). The selection at 238 of one of the fractional labels can be evaluated by the binary loss function 226b representing multiple labels. For example, the loss function 226b can compare the selected label 238 to a ground truth label for the item j 18. The loss function 226b can be backpropagated (e.g., to modify parameter values of the machine learning ranking model 12b).
[41] Although the use of softmax operators 22 and 36 is shown in Figure 2 A and the use of logistic functions 222 and 236 is shown in Figure 2B, other operators and/or model layers can be used to generate the label outputs from the intermediate representations. For example, one or more fully connected layers can be included (e.g., prior to a softmax operator or logistic function).
[42] Referring now again to Figures 2A and 2B collectively, according to an aspect of the present disclosure, the computing system can generate a ranking output 32 for the first input and the second input based on the first intermediate representation and the second intermediate representation. The ranking output can indicate a relative ranking between the first input and the second input. For example, the ranking output can indicate a probability that the label for item i 14 is greater than the label for item j 18 (e.g., which may indicate that item i 14 should be ranked higher than item j 18. As will be discussed further with reference to the corresponding ranking loss function 34, the ranking output 32 can be conditioned on a conditioning event.
[43] In particular, as one example, as shown in Figure 2 A, a computing system can determine an aggregate (e.g., by applying an aggregation operation 28) of the logit i 20 and the logit j 21. The computing system can generate the ranking output 34 based on said aggregate. As one
example, a logistic function 30 can be applied to the aggregate to generate the ranking output. In other examples, one or more model layers (e.g., fully connected neural network layers) and/or other operators can be positioned between the intermediate representations and the ranking output 32). In some implementations, the aggregation operation can be determined by the specific equation of the loss as described herein so as to give some logit value Sj that maps the vectors and Zj as a function of the label values yt and y7 to a binary logit. Then, this logit is transformed at 30 into a conditional probability of some relation between the label yt and yj conditioned on an event that includes both values of the binary event. For example, conditioned on the conditioning event
[44] As another example, as shown in Figure 2B, a computing system can determine a difference (e.g., by applying a subtraction operation 228) between the logit i 20 and the logit j 21. The computing system can generate the ranking output 34 based on said difference. As one example, a logistic function 30 can be applied to the difference to generate the ranking output. In other examples, one or more model layers (e.g., fully connected neural network layers) and/or other operators can be positioned between the intermediate representations and the ranking output 32).
[45] The computing system can evaluate a ranking loss function (L ;) 34 based on the ranking output 32. In particular, according to an aspect of the present disclosure, and as will be discussed in further detail below, the ranking loss function 34 can be a conditional loss that is conditioned on a conditioning event partitioned into two complement sets of events, the two complement sets of disjoint events The computing system can modify the machine-learned ranking model (12a and 12b) based on the ranking loss function 34. For example, the ranking loss function 34 can be backpropagated to update the parameters of the models 12a and 12b. Example implementations of the ranking loss function 34 will now be discussed in further detail.
[46] The remainder of the present disclosure considers loss contribution in a single query and drops the dependence on the query index t for brevity. More precisely, for ease of explication, we only consider a pairwise loss of items (or examples) i and j in a given query, and denote
[47] Example implementations extend the approach (or interpretation) described in a previous section for pairwise ranking with binary labels, in which a ranking loss is applied conditioned on some event. As described, in the binary case, it was a single event of the examples taking opposite labels. For the multi-label case, we can condition the ranking loss for multiple events, e.g., the ranking loss will be applied on a union of several conditioning events which need not be mutually exclusive, as long as the loss is well defined for a given pair of labels. For each conditioning event, a pair of events conditioned on the conditioning event can be defined by a binary logit value which will take one sign if items are ordered in one direction, and the opposite sign if the opposite direction.
[48] Because there are multiple ways to define pairwise ranking relations between different label values, there can be multiple ways to define ranking losses. For example, if a pair of examples have non-consecutive labels k and l, k > I, a ranking loss can either push the probability of k up for the first example and that of I up in the second, it can push the probability of the larger label up, and that of the smaller label down for one item, and apply the opposite for the other item. It can also, however, influence all other label values, specifically those between the I and k. If for example, item i has label k = 9, and item j has label I = 1, clearly item i should be ranked higher based on this pair than item j. So, the probability that item i takes label 9 should increase and the probability that item j takes label 1 should increase. A ranking loss could also (but does not have to) decrease the probabilities that item i takes label 1 and that item j takes label 9. But what about the probabilities of both items taking labels in {2, 3, 4, 5, 6, 7, 8}? A loss that increases zi9 and z;1 will implicitly lower all probabilities of items i and j taking any different label values. A loss that increases zi9 and z;1 and also decreases ztl and Zj9 will
implicitly affect
[49] Define the log partial Softmax sum
Example Extension of the Binary Conditional Loss to Multi-Labels
[50] The simplest way to shift the loss to focus more on ranking is by applying a pairwise joint probability loss only when labels are unequal. This gives a loss
[51] This can be corrected by making this loss a direct extension of the binary case described earlier. Define the logit
[52] For every
Example Naive Multi-Label Ranking Loss
[53] This section continues with another example approach that simplifies the conditioning event to depend only on the labels k and I of the pair of items. We define the logit on the conditioning event that one of yt and y;- takes label k and the other label I excluding k = I. Thus
[54] This equation gives a similar notion to equation (1), where is and S is
[55] The ranking loss can now be defined as
Example Label Value Aware Ranking Loss
[56] This section further builds on the conditional probability view. Instead of considering the conditioning event in which and y;- are permutations of (Z, fc), where k > I, this section considers a wider conditioning event where they can be labels in [Z, k], but defines the ranking loss for the pair
[57] To guarantee that for yt = k, yj = l, k > I, zik and Zji will go up, while z and Zjk will go down, and all ziv. i < v < k, will go up, while z;v will go down, we define
[58] Plugging (4) in (3) gives a loss that will push up probabilities of labels I + 1 up to k for item i, and down all respective label probabilities for item j, while increasing the probability of the lower label I for item j, and decreasing it for i. This is intuitively what one would expect given i has a better label than j. The logit in (4) describes
[59] The conditioning event in (4) is that both labels are in [I, k]. The conditioned events are that one label is I and the other greater than I. The loss (3) is applied only for events in which one label is k and the other is I.
[60] Alternatively to (4), we can partition the events between label k and labels I < y < k. We can also partition the event with respect to i this way, while keeping the partition of yj around I. This would push all labels v, I < v < k for both examples to lower logits. An alternative approach can combine two losses, one partitioning between {£} and {Z + 1, k} as in (4), and the other between {k} and {I, ... , k — 1}. This will increase the logit of k for item i, and that of I for item j, and superimpose increases and decreases for the labels between the two, where the overall net smooths the labels between I and k for both items.
[61] In some implementations, this loss can apply additional smoothing to the intermediate labels by applying a scaling factor. One such factor can be inversely proportional to the distance between the label and I and k. For example, an inverse scaling of c
[62] Another example approach is to partition in the middle, such that the lower half portion of labels will have loss gradients moving in the direction of I for both items i and j, and the upper half would move in the direction of label k for both items. If the range has an odd number of labels, we can either exclude the middle label (so its logit doesn’t move), or include it in both events. Consider the first option, which gives
[63] The logit s j can be plugged into (3) to give a loss. Here, again, the loss is applied to the same conditioning event that the labels are in [Z, k], but the partition of this event into the two labels is different. As the previous losses, this logit is used when yt = k,yj = I or vice versa, but affects labels between I and k for both items i and j. For where at
[64] The methods described thus far in this section guarantee that softmax logit scores of the larger label for the item with the larger label and of the smaller label for the item with the smaller label will increase. The scores of the smaller label for the item with the large one, and of the larger label for the item with the smaller one will decrease. In the middle, scores will be controlled as designed by the specific loss. These losses will not affect logit scores of labels outside the interval [Z, k], which is a desirable behavior. However, probabilities of labels outside this interval may, in fact, change because the softmax normalizers Vt and Vj may change. This can lead to lowering the probabilities predicted for labels v > k for the item with the larger label, or lower the probability predicted for labels v < I for the item with the smaller label. Such behavior is not desirable. However, it may be irrelevant, because this loss is focused on ranking and not on individual predictions, and ranking will only be considered through the logit scores. In applications, where the label probability is important, the ranking loss can still be
combined with a direct loss that tries to best predict the label probabilities. The losses described in the remainder of this section will minimize this behavior, as they will push all logits of labels complementary to the direction of the better (or worse) label in the opposite direction.
[65] If we only want a loss that changes ranking, but does not depend on the distances between the labels, we can partition the joint events by either the maximal label value k, or the minimal I. This will form a mutually exclusive partition of the pairwise ranking conditioning events. For label k, this gives
[66] This loss essentially compares the probability assigned to the fc-th label to the Cumulative Distribution Function (CDF) of all labels smaller than k for both examples. Similarly, for the minimal label Z, this gives
[67] The gradient on the loss relative to label k in (5) will push zik up and ziv for v < k down, and Zjk down, while ZjV for v < k up. This increases the probability of the larger label for the item with the larger label, while lowering all other probabilities of the item with the larger label. Similarly, it decreases the probability of the larger label for the item with the smaller label, while increasing the probabilities of all lower labels for this item. A dual behavior, relative to the lower label, will be attained with the loss around \ell. To mix the effects for the range between the labels, we can apply both losses together.
Example Label Difference Ranking
[68] A different loss can consider ranking only by label differences. This calls for aggregating all pairwise events with the same label difference between the items in the pair to make this loss agnostic to the actual labels. While this yields a more complicated loss, it may be suitable when the label difference is the most important factor for ranking. Taking a conditional probability view, this loss will give a partition of the pairwise events into disjoint conditioning events on which we apply losses that can be described as negative logarithms of conditional probabilities.
The partition is by the absolute difference \k — Z| (or |jZj — y7 |) between the labels. The conditional probability is given by
[69] It gives the log-odds ratio between the event that item i has a label which is delta larger than the label of item j and the event that item j’s label is delta larger than item i’s label conditioned on the event that the labels are delta apart. The loss in (3) can be weighted by delta
[70] One interpretation of this approach is that the label counts engagements. With this interpretation, scaling of the loss by differences is reasonable. In other scenarios, this loss may create biases due to unequal treatment of different label pairs.
Example Fractional Labels Pairwise Ranking
[71] Unlike the multi-label case, we consider the case in which the model learns binary labels, but sees fractional labels. In a more general case, labels observed can be from a larger alphabet, but then, they can be mapped to [0, 1], Assume one observes labels
[72] The ideas proposing multi-label pairwise losses can also be applied for Poisson regression, where logit parameters are used to learn a single parameter, which is the rate of a Poisson random variable. Taking the conditioning approach, the probabilities of events that are included in each of the two conditional events between which a binary label is applied to generate the loss can be aggregated for each of the items. Similarly to the logistic regression approach, we can form sums Z taking individual probabilities defined by the Poisson distribution, and taking the logarithm over the sum. We can define ziv as the logarithm of the probability of the event that item i takes label v. With this setup, we fit the Poisson regression to the analysis we performed for the multi-label logistic regression setting. Specifically, if we use the loss defined in equation (5), the Poisson CDF can take the place of
Example Hierarchical Approach
[73] An alternative partitioning method for ranking loss is to use binary logits to separate sets of labels hierarchically. Instead of using Softmax, labels will be aggregated into two sets and a binary logit distinguishes between the sets. Then, the loss evaluation system can recurse down in one of the sets to update binary logits to distinguish among all labels. This can be done for the direct engagement loss per item. Grouping can be done as a binary search tree, partitioning labels into sets of half in each level, or by separating one label from the rest in every recursion step. Ranking loss then uses the binary approach for each level. If the labels for items i and j are in the same set, no loss is incurred and recursion goes down applied on this set. Once i and j are in different partitions of the current set, a binary ranking loss is applied conditioned on the event that one label is in one partition and the other in the other. The process then stops. This approach still does not fully distinguish between labels in the same set, once the label for item i is separated from that of j. The overall logits for all labels in the set of the label yt will equally move, and similarly those in the set of y;-, whereas the movement will happen on the binary logit score representing the set. Outside the granularity of the sets, the loss will attain an expected ranking behavior. The choice of the recursive partitioning can be made so that set logit movements are reasonable for the specific application. An additional softmax loss can be applied
within a set to further identify the label after set partitioning occurred from the label of the other item.
Example Devices and Systems
[74] Figure 3 A depicts a block diagram of an example computing system 100 according to example embodiments of the present disclosure. The system 100 includes a user computing device 102, a server computing system 130, and a training computing system 150 that are communicatively coupled over a network 180.
[75] The user computing device 102 can be any type of computing device, such as, for example, a personal computing device (e.g., laptop or desktop), a mobile computing device (e.g., smartphone or tablet), a gaming console or controller, a wearable computing device, an embedded computing device, or any other type of computing device.
[76] The user computing device 102 includes one or more processors 112 and a memory 114. The one or more processors 112 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, an FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected. The memory 114 can include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof. The memory 114 can store data 116 and instructions 118 which are executed by the processor 112 to cause the user computing device 102 to perform operations.
[77] In some implementations, the user computing device 102 can store or include one or more machine-learned ranking models 120. For example, the machine-learned ranking models 120 can be or can otherwise include various machine-learned models such as neural networks (e.g., deep neural networks) or other types of machine-learned models, including non-linear models and/or linear models. Neural networks can include feed-forward neural networks, recurrent neural networks (e.g., long short-term memory recurrent neural networks), convolutional neural networks or other forms of neural networks. Some example machine-learned models can leverage an attention mechanism such as self-attention. For example, some example machine- learned models can include multi-headed self-attention models (e.g., transformer models).
[78] In some implementations, the one or more machine-learned ranking models 120 can be received from the server computing system 130 over network 180, stored in the user computing
device memory 114, and then used or otherwise implemented by the one or more processors 112. In some implementations, the user computing device 102 can implement multiple parallel instances of a single machine-learned ranking model 120 (e.g., to perform parallel ranking across multiple instances of pairwise inputs).
[79] Additionally or alternatively, one or more machine-learned ranking models 140 can be included in or otherwise stored and implemented by the server computing system 130 that communicates with the user computing device 102 according to a client-server relationship. For example, the machine-learned ranking models 140 can be implemented by the server computing system 140 as a portion of a web service (e.g., a information retrieval service). Thus, one or more models 120 can be stored and implemented at the user computing device 102 and/or one or more models 140 can be stored and implemented at the server computing system 130.
[80] The user computing device 102 can also include one or more user input components 122 that receives user input. For example, the user input component 122 can be a touch-sensitive component (e.g., a touch-sensitive display screen or a touch pad) that is sensitive to the touch of a user input object (e.g., a finger or a stylus). The touch-sensitive component can serve to implement a virtual keyboard. Other example user input components include a microphone, a traditional keyboard, or other means by which a user can provide user input.
[81] The server computing system 130 includes one or more processors 132 and a memory 134. The one or more processors 132 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, an FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected. The memory 134 can include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof. The memory 134 can store data 136 and instructions 138 which are executed by the processor 132 to cause the server computing system 130 to perform operations.
[82] In some implementations, the server computing system 130 includes or is otherwise implemented by one or more server computing devices. In instances in which the server computing system 130 includes plural server computing devices, such server computing devices can operate according to sequential computing architectures, parallel computing architectures, or some combination thereof.
[83] As described above, the server computing system 130 can store or otherwise include one or more machine-learned ranking models 140. For example, the models 140 can be or can otherwise include various machine-learned models. Example machine-learned models include neural networks or other multi-layer non-linear models. Example neural networks include feed forward neural networks, deep neural networks, recurrent neural networks, and convolutional neural networks. Some example machine-learned models can leverage an attention mechanism such as self-attention. For example, some example machine-learned models can include multi-headed self-attention models (e.g., transformer models).
[84] The user computing device 102 and/or the server computing system 130 can train the models 120 and/or 140 via interaction with the training computing system 150 that is communicatively coupled over the network 180. The training computing system 150 can be separate from the server computing system 130 or can be a portion of the server computing system 130.
[85] The training computing system 150 includes one or more processors 152 and a memory 154. The one or more processors 152 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, an FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected. The memory 154 can include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof. The memory 154 can store data 156 and instructions 158 which are executed by the processor 152 to cause the training computing system 150 to perform operations. In some implementations, the training computing system 150 includes or is otherwise implemented by one or more server computing devices.
[86] The training computing system 150 can include a model trainer 160 that trains the machine-learned models 120 and/or 140 stored at the user computing device 102 and/or the server computing system 130 using various training or learning techniques, such as, for example, backwards propagation of errors. For example, a loss function can be backpropagated through the model(s) to update one or more parameters of the model(s) (e.g., based on a gradient of the loss function). Various loss functions can be used such as mean squared error, likelihood loss, cross entropy loss, hinge loss, and/or various other loss functions. Gradient descent techniques can be used to iteratively update the parameters over a number of training iterations.
[87] In some implementations, performing backwards propagation of errors can include performing truncated backpropagation through time. The model trainer 160 can perform a number of generalization techniques (e.g., weight decays, dropouts, etc.) to improve the generalization capability of the models being trained.
[88] In particular, the model trainer 160 can train the machine-learned ranking models 120 and/or 140 based on a set of training data 162. The training data 162 can include, for example, inputs annotated with ground truth labels.
[89] In some implementations, if the user has provided consent, the training examples can be provided by the user computing device 102. Thus, in such implementations, the model 120 provided to the user computing device 102 can be trained by the training computing system 150 on user-specific data received from the user computing device 102. In some instances, this process can be referred to as personalizing the model.
[90] The model trainer 160 includes computer logic utilized to provide desired functionality. The model trainer 160 can be implemented in hardware, firmware, and/or software controlling a general purpose processor. For example, in some implementations, the model trainer 160 includes program files stored on a storage device, loaded into a memory and executed by one or more processors. In other implementations, the model trainer 160 includes one or more sets of computer-executable instructions that are stored in a tangible computer-readable storage medium such as RAM, hard disk, or optical or magnetic media.
[91] The network 180 can be any type of communications network, such as a local area network (e.g., intranet), wide area network (e.g., Internet), or some combination thereof and can include any number of wired or wireless links. In general, communication over the network 180 can be carried via any type of wired and/or wireless connection, using a wide variety of communication protocols (e.g., TCP/IP, HTTP, SMTP, FTP), encodings or formats (e.g., HTML, XML), and/or protection schemes (e.g., VPN, secure HTTP, SSL).
[92] Figure 3 A illustrates one example computing system that can be used to implement the present disclosure. Other computing systems can be used as well. For example, in some implementations, the user computing device 102 can include the model trainer 160 and the training dataset 162. In such implementations, the models 120 can be both trained and used locally at the user computing device 102. In some of such implementations, the user computing
device 102 can implement the model trainer 160 to personalize the models 120 based on userspecific data.
[93] Figure 3B depicts a block diagram of an example computing device 10 that performs according to example embodiments of the present disclosure. The computing device 10 can be a user computing device or a server computing device.
[94] The computing device 10 includes a number of applications (e.g., applications 1 through N). Each application contains its own machine learning library and machine-learned model(s). For example, each application can include a machine-learned model. Example applications include a text messaging application, an email application, a dictation application, a virtual keyboard application, a browser application, etc.
[95] As illustrated in Figure 3B, each application can communicate with a number of other components of the computing device, such as, for example, one or more sensors, a context manager, a device state component, and/or additional components. In some implementations, each application can communicate with each device component using an API (e.g., a public API). In some implementations, the API used by each application is specific to that application.
[96] Figure 3C depicts a block diagram of an example computing device 50 that performs according to example embodiments of the present disclosure. The computing device 50 can be a user computing device or a server computing device.
[97] The computing device 50 includes a number of applications (e.g., applications 1 through N). Each application is in communication with a central intelligence layer. Example applications include a text messaging application, an email application, a dictation application, a virtual keyboard application, a browser application, etc. In some implementations, each application can communicate with the central intelligence layer (and model(s) stored therein) using an API (e.g., a common API across all applications).
[98] The central intelligence layer includes a number of machine-learned models. For example, as illustrated in Figure 3C, a respective machine-learned model can be provided for each application and managed by the central intelligence layer. In other implementations, two or more applications can share a single machine-learned model. For example, in some implementations, the central intelligence layer can provide a single model for all of the applications. In some implementations, the central intelligence layer is included within or otherwise implemented by an operating system of the computing device 50.
[99] The central intelligence layer can communicate with a central device data layer. The central device data layer can be a centralized repository of data for the computing device 50. As illustrated in Figure 3C, the central device data layer can communicate with a number of other components of the computing device, such as, for example, one or more sensors, a context manager, a device state component, and/or additional components. In some implementations, the central device data layer can communicate with each device component using an API (e.g., a private API).
Additional Disclosure
[100] The technology discussed herein makes reference to servers, databases, software applications, and other computer-based systems, as well as actions taken and information sent to and from such systems. The inherent flexibility of computer-based systems allows for a great variety of possible configurations, combinations, and divisions of tasks and functionality between and among components. For instance, processes discussed herein can be implemented using a single device or component or multiple devices or components working in combination. Databases and applications can be implemented on a single system or distributed across multiple systems. Distributed components can operate sequentially or in parallel.
[101] While the present subject matter has been described in detail with respect to various specific example embodiments thereof, each example is provided by way of explanation, not limitation of the disclosure. Those skilled in the art, upon attaining an understanding of the foregoing, can readily produce alterations to, variations of, and equivalents to such embodiments. Accordingly, the subject disclosure does not preclude inclusion of such modifications, variations and/or additions to the present subject matter as would be readily apparent to one of ordinary skill in the art. For instance, features illustrated or described as part of one embodiment can be used with another embodiment to yield a still further embodiment. Thus, it is intended that the present disclosure cover such alterations, variations, and equivalents.
Claims
1. A computer-implemented method to perform training for multi-label pairwise ranking, the method comprising: processing, by a computing system comprising one or more computing devices, a first input with a machine-learned ranking model to generate a first intermediate representation for the first input; processing, by a computing system comprising one or more computing devices, a second input with the machine-learned ranking model to generate a second intermediate representation for the second input; generating, by the computing system, a first label output for the first input based on the first intermediate representation, wherein the first label output is generated relative to a plurality of potential labels; generating, by the computing system, a second label output for the second input based on the second intermediate representation, wherein the second label output is generated relative to the plurality of potential labels; generating, by the computing system, a ranking output for the first input and the second input based on the first intermediate representation and the second intermediate representation, wherein the ranking output indicates a relative ranking between the first input and the second input; and evaluating, by the computing system, one or more ranking loss functions based on the ranking output, wherein the one or more ranking loss functions comprise a conditional loss that is conditioned on a conditioning event partitioned into two complement sets of events; and modifying, by the computing system, the machine-learned ranking model based on the one or more ranking loss functions.
2. The computer-implemented method of claim 1, wherein the conditioning event comprises that either:
(a) the first label output equals a first value and the second label output equals a second, different value; or
(b) the first label output does not equal the first value and the second label output does not equal the second, different value.
3. The computer-implemented method of claim 1, wherein the conditioning event comprises that both:
(a) one of the first label output or the second label output equals a first value; and
(b) the other of the first label output or the second label output equals a second, different value.
4. The computer-implemented method of claim 1, wherein the conditioning event comprises that a difference between the first label output and the second label output is at least a delta value.
5. The computer-implemented method of claim 1, wherein the conditioning event has been partitioned such that a range of the plurality of labels is partitioned into two sets of label values.
6. The computer-implemented method of claim 6, wherein the two sets of label values comprise a first set containing a first label value and a second set containing all label values that are greater than the first label value.
7. The computer-implemented method of claim 6, wherein the two sets of label values comprise a first set containing a first label value and a second set containing all label values that are less than the first label value.
8. The computer-implemented method of claim 6, wherein the two sets of label values contain equal numbers of label values, where the labels in one set are smaller than all the labels in the other.
9. The computer-implemented method of any preceding claim, wherein the two complement sets of events comprise a first set of events and a second set of events, and at least one of the first set of events and second set of events contains two or more events.
10. The computer-implemented method of any preceding claim, wherein the two complement sets of events comprise disjoint sets.
11. The computer-implemented method of any preceding claim, further comprising: evaluating, by the computing system, a multi-label loss function for the first input based on the first label output; evaluating, by the computing system, the multi-label loss function for the second input based on the second label output; and modifying, by the computing system, the machine-learned ranking model based on the classification loss function evaluated for the first input and the classification loss function evaluated for the second input.
12. The computer-implemented method of any preceding claim, wherein the plurality of potential labels comprises three or more different labels.
13. The computer-implemented method of any preceding claim, the plurality of potential labels comprise fractional labels of a binary outcome.
14. The computer-implemented method of any preceding claim, wherein the first intermediate output comprises a first logit score, and wherein the second intermediate output comprises a second logit score.
15. The computer-implemented method of any preceding claim, wherein generating, by the computing system, the ranking output for the first input and the second input based on the first intermediate representation and the second intermediate representation comprises: determining, by the computing system, a difference between the first intermediate representation and the second intermediate representation; and
generating, by the computing system, the ranking output for the first input and the second input based on the difference between the first intermediate representation and the second intermediate representation.
16. The computer-implemented method of any preceding claim, wherein: the first label output and the second label output comprise engagement scores relative to a query; and the ranking comprises a probability that the first input is ranked higher than the second input relative to the query.
17. The computer-implemented method of any preceding claim, wherein the plurality of potential labels are modeled by one or more standard probability mass functions (PMF), and wherein the one or more ranking loss functions partition the plurality of potential labels into a sum by summing the probabilities of the elements in the complement sets of events.
18. The computer-implemented method of any preceding claim, wherein the one or more ranking loss functions comprise a hierarchical partitioning of the plurality of potential labels, the hierarchical partitioning comprising multiple layers, each layer defining a conditioning event that partitions into two conditioned events.
19. A computer system, comprising: one or more processors; and one or more non-transitory computer-readable media that collectively store: a machine-learned ranking model configured to generate ranking outputs for pairs of inputs that are responsive to a query and configured to generate a respective label output for each input relative to a plurality of potential labels, wherein the machine-learned ranking model has been trained using one or more ranking loss functions, wherein the one or more ranking loss functions comprise a conditional loss that is conditioned on a conditioning event partitioned into two complement sets of events: and instructions that, when executed by the one or more processors, cause the computer system to run the machine-learned ranking model configured to generate one or both
of: (a) ranking outputs for the pairs of inputs that are responsive to a query; or (b) the respective label output for each input relative to the plurality of potential labels.
20. The computer system of claim 19, wherein the conditioning event comprises that either:
(a) the first label output equals a first value and the second label output equals a second, different value; or
(b) the first label output does not equal the first value and the second label output does not equal the second, different value.
21. The computer system of claim 19, wherein the conditioning event comprises that both:
(a) one of the first label output or the second label output equals a first value; and
(b) the other of the first label output or the second label output equals a second, different value.
22. The computer system of claim 19, wherein the conditioning event has been partitioned such that a range of the plurality of labels is partitioned into two sets of label values.
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
PCT/US2022/039070 WO2024030114A1 (en) | 2022-08-01 | 2022-08-01 | Multi-label pairwise ranking |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
PCT/US2022/039070 WO2024030114A1 (en) | 2022-08-01 | 2022-08-01 | Multi-label pairwise ranking |
Publications (1)
Publication Number | Publication Date |
---|---|
WO2024030114A1 true WO2024030114A1 (en) | 2024-02-08 |
Family
ID=83149364
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
PCT/US2022/039070 WO2024030114A1 (en) | 2022-08-01 | 2022-08-01 | Multi-label pairwise ranking |
Country Status (1)
Country | Link |
---|---|
WO (1) | WO2024030114A1 (en) |
-
2022
- 2022-08-01 WO PCT/US2022/039070 patent/WO2024030114A1/en unknown
Non-Patent Citations (1)
Title |
---|
HUANG JIZHOU ET AL: "Learning to Explain Entity Relationships by Pairwise Ranking with Convolutional Neural Networks", PROCEEDINGS OF THE TWENTY-SIXTH INTERNATIONAL JOINT CONFERENCE ON ARTIFICIAL INTELLIGENCE, 1 August 2017 (2017-08-01) - 1 February 2023 (2023-02-01), California, US, pages 4018 - 4025, XP055794226, ISBN: 978-0-9992411-0-3, Retrieved from the Internet <URL:https://www.ijcai.org/proceedings/2017/0561.pdf> [retrieved on 20230201], DOI: 10.24963/ijcai.2017/561 * |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US10360500B2 (en) | Two-phase distributed neural network training system | |
US20210287048A1 (en) | System and method for efficient generation of machine-learning models | |
US11481456B2 (en) | Model and pattern structure online unital learning: mapsoul | |
Lorena et al. | Evolutionary tuning of SVM parameter values in multiclass problems | |
US10592777B2 (en) | Systems and methods for slate optimization with recurrent neural networks | |
US11693917B2 (en) | Computational model optimizations | |
US20230267302A1 (en) | Large-Scale Architecture Search in Graph Neural Networks via Synthetic Data | |
Mandal et al. | Three-way decision model under a large-scale group decision-making environment with detecting and managing non-cooperative behaviors in consensus reaching process | |
Abusnaina et al. | Self-adaptive mussels wandering optimization algorithm with application for artificial neural network training | |
Gnecco et al. | A machine learning approach to economic complexity based on matrix completion | |
Alshareet et al. | Incorporation of ISO 25010 with machine learning to develop a novel quality in use prediction system (QiUPS) | |
US20220092387A1 (en) | Systems and Methods for Producing an Architecture of a Pyramid Layer | |
WO2024030114A1 (en) | Multi-label pairwise ranking | |
US20230124258A1 (en) | Embedding optimization for machine learning models | |
Konishi et al. | End-to-end learning for prediction and optimization with gradient boosting | |
Qiao et al. | A joint neural network model for combining heterogeneous user data sources: An example of at‐risk student prediction | |
US20230153843A1 (en) | System to combine intelligence from multiple sources that use disparate data sets | |
Karimi et al. | A new method of mining data streams using harmony search | |
Cordes et al. | Systematic literature review of the performance characteristics of Chebyshev polynomials in machine learning applications for economic forecasting in low-income communities in sub-Saharan Africa | |
Jin et al. | Variational auto-encoder based Bayesian Poisson tensor factorization for sparse and imbalanced count data | |
CN113743615A (en) | Feature removal framework to simplify machine learning | |
Darbandi Monfared | A novel web page recommender using data automatic clustering and Markov process | |
WO2024063765A1 (en) | Learning to rank with ordinal regression | |
US11822564B1 (en) | Graphical user interface enabling interactive visualizations using a meta-database constructed from autonomously scanned disparate and heterogeneous sources | |
US11928128B2 (en) | Construction of a meta-database from autonomously scanned disparate and heterogeneous sources |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
121 | Ep: the epo has been informed by wipo that ep was designated in this application |
Ref document number: 22761719Country of ref document: EPKind code of ref document: A1 |