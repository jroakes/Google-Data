US20020073086A1 - Scalable and programmable query distribution and collection in a network of queryable devices - Google Patents
Scalable and programmable query distribution and collection in a network of queryable devices Download PDFInfo
- Publication number
- US20020073086A1 US20020073086A1 US09/900,704 US90070401A US2002073086A1 US 20020073086 A1 US20020073086 A1 US 20020073086A1 US 90070401 A US90070401 A US 90070401A US 2002073086 A1 US2002073086 A1 US 2002073086A1
- Authority
- US
- United States
- Prior art keywords
- query
- responses
- network
- response
- node
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Granted
Links
Images
Classifications
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L41/00—Arrangements for maintenance, administration or management of data switching networks, e.g. of packet switching networks
- H04L41/04—Network management architectures or arrangements
- H04L41/046—Network management architectures or arrangements comprising network management agents or mobile agents therefor
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L41/00—Arrangements for maintenance, administration or management of data switching networks, e.g. of packet switching networks
- H04L41/04—Network management architectures or arrangements
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L41/00—Arrangements for maintenance, administration or management of data switching networks, e.g. of packet switching networks
- H04L41/34—Signalling channels for network management communication
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L41/00—Arrangements for maintenance, administration or management of data switching networks, e.g. of packet switching networks
- H04L41/02—Standardisation; Integration
- H04L41/0213—Standardised network management protocols, e.g. simple network management protocol [SNMP]
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99931—Database or file accessing
- Y10S707/99933—Query processing, i.e. searching
- Y10S707/99934—Query formulation, input preparation, or translation
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99931—Database or file accessing
- Y10S707/99933—Query processing, i.e. searching
- Y10S707/99935—Query augmenting and refining, e.g. inexact access
Definitions
- the present invention relates to methods and apparatus for querying large numbers of devices using a network. More specifically, the present invention relates to efficiently and scaleably issuing queries to devices from a monitor and collecting results of those queries.
- SNMP SNMP
- a network monitor would send queries out to devices that are responsive to SNMP and the devices would respond to the queries back to the network monitor.
- the network monitor is coupled to the network at a network node and the devices are coupled to the network as well.
- SNMP might work well with one network monitor querying dozens, hundreds or even thousands of devices, but becomes problematic with greater numbers of devices.
- One problem is that the network around the network node gets congested as the network monitor attempts to send SNMP query request packets to each device. Even if the query request could be broadcast to the devices, using multicasting or other techniques, the returning query responses would bog down the network near the network node. Such congestion would occur with only one response per device, so the congestion could be expected to be much worse if each device sends more than one response per query, as might be the case for a query that requests periodic updates from a device.
- a network comprises many networked devices. Operating such a network is typically a critical yet complex task requiring refined mechanisms for configuring, managing, debugging, monitoring, and measuring equipment and equipment performance. While protocols and tools for managing individual pieces of equipment within a network are well understood, systems for managing or monitoring an ensemble of equipment across a network are poorly understood and underdeveloped.
- CDNs are described in McCanne III.
- a CDN routes “content”, as opposed to a lower level router that merely routes individual packets.
- the content routed by a CDN might be a set of media streams and the content flows across the CDN to “edge devices”, which might be clients for viewing or storing the content or servers that forward on the content to such clients.
- CDNs may function in such a way that the content is distributed to interested edge devices without requiring a centralized control point in the network that knows the exact details of which devices are receiving the content or how it is being distributed (for example, which network paths is the content flowing across).
- management and monitoring tools often need access to this very information in order to perform their functions.
- One embodiment of the present invention provides for an improved query handling system.
- the network transports query messages from query nodes to device nodes.
- Query responses from the device node are directed through the network to a collection node or nodes.
- the device nodes might be supported by servers that are located in the network near the network devices. Such servers would maintain information about their network devices, such as information about the data streams being served to the network devices.
- an internal response network node receives multiple query responses from device nodes, the internal response network node might aggregate, as needed, the multiple query responses into an aggregated query response.
- an aggregated query response occupies less bandwidth than the aggregated multiple query responses.
- the result desired at the collection node is a computed function of the multiple query responses, such as a concatenation, sum, logical function, summary, etc.
- the computed function can be performed at each internal response network node on the multiple query responses received at that node, thus distributing the computation needed to form a collected response to the query.
- queries might request real-time or non-real-time responses and queries might request one response, periodic responses or one response for each occurrence of an event.
- the internal response network nodes might store lookup tables, or access a centralized lookup table, that specify details of queries, thus obviating the need for each query message to carry all of the necessary details of the query.
- query messages from a query originator to a network device identify the query being made by an index into a query lookup table.
- the lookup table might also include details or instructions usable by the internal response network nodes for performing an aggregation specific to the query.
- FIG. 1 is a block diagram of a generalized query handling system according to one embodiment of the present invention.
- FIG. 2 is a schematic diagram similar to FIG. 1, but showing more details of traffic flow.
- FIG. 3 is a diagram illustrating the flow of a query to device nodes.
- FIG. 4 is a diagram illustrating the flow of query responses from device nodes to a collection node via aggregation nodes.
- FIG. 5 is a diagram illustrating the flow of a query to device nodes using multicasting.
- FIG. 6 is a diagram illustrating the flow of query responses to a collection node using aggregation at intermediate nodes.
- FIG. 7 is a diagram illustrating the flow of query responses to a collection node using aggregation at intermediate nodes with less increase in bandwidth use near a root collection point relative to the aggregation shown in FIG. 6.
- FIG. 8( a ) is a diagram illustrating a query response network with active aggregation nodes and passive aggregation nodes
- FIG. 8( b ) is a diagram illustrating a similar arrangement, but with data combination at passive aggregation nodes.
- FIG. 9 illustrates a query response network wherein queries about content originate with a content source
- FIG. 9( a ) is a diagram illustrating content flow from a content source to edge devices
- FIG. 9( b ) is a diagram illustrating a query flow along the same paths as content flow.
- FIG. 9( c ) illustrates response collection along those same paths.
- FIG. 10 illustrates using separate distribution trees for content and querying.
- FIG. 11 illustrates aggregation of vector responses.
- FIG. 12 illustrates aggregation of vector responses with variable length vector responses.
- FIG. 13 is a diagram illustrating the issuance of queries and collection of responses at different nodes.
- FIG. 14 illustrates multiple levels of aggregation nodes.
- Query handling systems can operate over many different types of data networks, such as a well-known TCP/IP network.
- a content distribution network CDN
- a query handling system using a CDN is first described, along with features specifically useful for CDNs, followed by a description of a query handling system for a generic packet-switched network.
- a query handling system could be used to query edge devices in a CDN, where the routed elements are content, such as media streams, or where the routed elements are packets, as with a packet-switched network.
- query originator refers to a person or machine that originates a query for information about a network. Presumably, the query is issued for the purposes of obtaining an answer to the question inherent in the query. However, other uses of issuing queries might become apparent upon review of this disclosure. For example, a query might be issued for testing purposes or to trigger an event elsewhere in the network. Such uses can be the entire reason for making the query or might be ancillary to getting an answer to the question posed.
- a “query message” is data that, alone or in combination with other data (such as lookup tables), indicates what question is being asked of the network.
- a “network device” is a device that is coupled to the network.
- a network device might be an entirely self-contained object or might be an object that interfaces with nonnetwork equipment or users.
- a “query node” is a node of the network at which the query is said to originate or where the query is “injected” into the network.
- a network might include nodes and/or equipment between the query node and the query originator without departing from the general definition of query node used herein.
- a “device node” is a network node at which a network device connects to the network or a node at which queries about that network device can be answered.
- Device nodes might be supported by servers that are located in the network near the network devices. Such servers would maintain information about their network devices, such as information about the data streams being served to the network devices.
- the device node which is used for query/response activity, can be the same node the network device uses for its main function.
- a streaming video player client might use the same IP address for receiving and responding to queries as it uses to receive streaming video (its main function).
- the network device's network node for its main function might be distinct from the device's device node used only for the query process.
- a “collection node” is a network node at which query responses from device nodes are received.
- a collection node is where a response collection system is coupled to the network, however other configurations are possible.
- queries can be thought of as originating at a query node, propagating to device nodes and query responses can be thought of as originating at device nodes and propagating to collection nodes.
- An “internal network node” is a network node that is between a query node and a device node or a device node and a collection node.
- An “internal response network node” is an internal network node on a path between a device node and a query node.
- An “internal query network node” is an internal network node on a path between a query node and a device node.
- the internal response network nodes visited by a query response as it passes from a device node to a collection node can define the same path that a query follows but in reverse, but that need not be the case.
- each network monitoring node is a query node and a collection node and a query follows a path through the network to a device node, encountering internal query network nodes and the response to the query follows the same path in a reverse order (albeit with some aggregation possibly occurring at various internal response network nodes), where the nodes that act as internal query network nodes act as internal response network nodes for the returning responses.
- FIG. 1 is an illustration of a Content Distribution Network (“CDN”) 100 with which a query handling system might be used.
- CDN 100 Content Distribution Network
- content sources 102 provide content (such as programs 103 ) to the network and that content is provided by CDN 100 to edge devices 104 that provide the content to end-users.
- edge devices 104 Of particular interest to broadcasters is the number of end-users receiving particular content and other data about the end-user clients, edge devices 104 , etc.
- an edge device 104 will have individual connections to end-user computing devices 106 , such as a point-to-point packet channel, so that an edge device is fully aware of the content received by the end-user computing devices through the CDN. In such cases, edge devices 104 would be able to answer queries about the content received by the end-user computing devices.
- an end-user device itself or a server monitoring the end-user device apart from its coupling to the network, it should be understood that a query directed at the end-user device's device node would evoke a response (if the query calls for a response) from the device, program or logic assigned to be the respondent at that device node.
- a broadcast center (“BC”) 110 monitors content broadcasting from nodes distinct from the content sources, by sending out queries to edge devices 104 and receiving subsequent query responses.
- the content sources and broadcast center might be integrated at one network location.
- FIG. 2 shows the system of FIG. 1 with more details on specific data flows, such as program feeds, pathways for query messages and pathways for query responses.
- BC 110 is a query originator
- a node at which BC 110 is coupled to the network is a query node
- nodes at which edge devices 104 are coupled to the network are device nodes.
- a query originator can be implemented as a computing device coupled to CDN 100 (or a packet-switched network underlying CDN 100 ), as program code executing on a general purpose computer, as program code executing on a routing device, or the like.
- software agents run within a virtual machine (VM), such as a JavaTM VM executing on a computer coupled to CDN 100 , act as query originators.
- VM virtual machine
- An example of a query respondent i.e., a device, software or agent at which query collection starts; typically coupled to the network at a device node
- a query respondent i.e., a device, software or agent at which query collection starts; typically coupled to the network at a device node
- the SNMP agent can access Management Information Base (MIB) objects in nearby equipment and can respond to queries about the information stored in those MIB objects.
- MIB's are described in greater detail in RFC 1156 , which is hereby incorporated by reference for all purposes.
- the data can be provided to various processes, devices or users that need the data. For example, the data might be written to text files that may be viewed or processed later or inserted into a database. Access to the data might then be dependent on the query and who generated it.
- one query handling system might be used by multiple content providers, but each content provider would have to be authenticated to the collector collecting the responses, so that each content provider can only access data relating to their own content, even if the data was collected for multiple content providers. This approach is useful where the data network is run by a service provider that delivers data for more than one customer.
- An authentication system such as a Web-based SSL login/authorization transaction, can ensure that only its legitimate customers can view data stored at the collector. Each customer can also be limited such that the customer cannot view all of the data collected by the service provider for that customer, if the service provider does not wish to pass on all of the collected data. If the customer is allowed to initiate queries, an authentication system can also control or limit the types of queries that the customer can perform.
- one query originator originates a query to many, many query respondents, receiving individual responses from each respondent may congest the network around the collection node. Congestion might also occur around a query node as the originator sends individual queries to each respondent. Where the query node and the collection node are the same node, this congestion could be expected for both outgoing traffic and incoming traffic, but the problems are the same whether the query node and the collection node are the same or separated.
- the data network such as CDN 100 (shown in FIGS. 1 - 2 , et seq.), is populated with aggregation nodes, as illustrated by FIGS. 3 - 5 and described in more detail below.
- CDN 100 shown in FIGS. 1 - 2 , et seq.
- Agents, or other computing objects, at an aggregation node perform programmable aggregation operations on received query responses that flow to the aggregation node from device nodes and forward the aggregated result on towards the collection node or nodes.
- the maximum load on the network for query response data can be reduced from a load proportional to the number of device nodes, and instead be proportional to the maximum “fanout”, where fanout refers to the number of device nodes or aggregation nodes that “report” to a given aggregation node or collection node.
- fanout refers to the number of device nodes or aggregation nodes that “report” to a given aggregation node or collection node.
- the amount of processing needed at a collection node might also be reduced.
- the maximum number of additions performed at any aggregation node or collection node is not proportional to the number of respondents but instead is proportional to the maximum fanout of that aggregation node or collection node.
- This section describes how the network may be mapped onto specific data delivery systems for distributing queries and responses.
- streaming multimedia programs being delivered through a CDN.
- Some examples also assume the use of a sender-based multicast tree for distributing program content and queries and assume that the multicast infrastructure supports reverse-path transmission of data from the edge of the tree towards the root or core.
- CDN 100 delivers program content from content sources 102 to those edge devices 104 that are interested in the content (this is a feature of CDN 100 ).
- CDN 100 comprises various interconnected nodes or routers that can deliver content from content sources 102 to edge devices 104 . Further details of the operation of CDN 100 can be found in McCanne III.
- Edge devices 104 may be the final destination for the content (for example, they could be streaming media viewing clients), or edge devices 104 could be intermediate devices, such as servers that in turn forward content on to clients.
- CDN 100 could comprise a network of FastForward MediabridgeTM servers running ALM (Application-Level Multicasting), but CDN 100 could also use another delivery mechanism capable of reaching multiple receivers, such as IP multicast, a RealNetworks G2TM Splitter network, or even separate unicast connections from each content source 102 to every edge device 104 pulling down content from that content source.
- ALM Application-Level Multicasting
- BC 110 monitors the current state and health of CDN 100 , the content that is flowing across it, and information from any devices used to effect CDN 100 , such as the current number of clients receiving a program from CDN 100 .
- BC 110 serves as a controller of CDN 100 as well as a query originator and a response collection system. In that case, BC 110 can be said to be at the query node and the collection node for its set of queries.
- a given network might have multiple BC's operating more or less independently.
- FIG. 1 only represents a logical view of a CDN; it is not intended to imply that BC 110 or content sources 102 must be located on the “edge” of CDN 100 . In many cases, it will be beneficial to locate these elements close to the center or “core” of CDN 100 .
- FIG. 2 is a schematic diagram similar to FIG. 1, but showing more details of traffic flow related to a querying process.
- BC 110 might issue a query to determine how many clients are watching program A (i.e., receiving the content associated with program A).
- content source 102 ( 1 ) is injecting two programs, A and B, into the network and content source 102 ( 2 ) is injecting two other programs, C and D, into the network.
- Those programs are being received by edge devices 104 , with each edge device typically receiving only the programs that are being fed to clients connected to that edge device, as shown.
- edge device 104 ( 1 ) For example, clients 106 coupled to edge device 104 ( 1 ) are receiving only programs A and B, so edge device 104 ( 1 ) need only receive programs A and B.
- Edge devices 104 might be media servers that receive program streams from CDN 100 and deliver the streams to clients 106 . As shown in FIG. 2, edge device 104 ( 1 ) receives programs A and B; edge device 104 ( 2 ) receives A and D; edge device 104 ( 3 ) receives A, B, and C; and edge device 104 ( 4 ) receives only stream D. If the operator of BC 110 wants to know how many people are watching program A, the operator causes BC 110 to issue a query to that effect and CDN 100 distributes the query to each edge device 104 .
- Edge devices 104 respond with their answers (edge device 104 ( 1 ): 2, edge device 104 ( 2 ): 3, edge device 104 ( 3 ): 1, edge device 104 ( 4 ): 0) and send their responses back into CDN 100 , which collects the responses, aggregates them, and preferably delivers a single total back to BC 110 (6 in this case).
- the edge devices include a naming system to map well known virtual names, which may be used in programmable queries, onto corresponding physical, equipment-specific names. This allows different, heterogeneous equipment to respond to the same query. For example, if some clients are receiving program A, but know it as program X and other clients are receiving program A, but know it as program Y, their respective edge devices could translate the query using the naming system so that queries about program A are applied to programs X and Y as well.
- FIGS. 3 - 4 show an example of unicast, or point-to-point, connections between BC 110 and each edge device 104 .
- FIG. 3 is a diagram illustrating the flow of a query from BC 110 to various device nodes, where edge devices are coupled to the network.
- FIG. 4 is a diagram illustrating the flow of query responses from the device nodes to a collection node (which happens to be the same node as the query node, in this case) via aggregation nodes.
- program content being distributed through CDN 100 from a content source; this can be done through any arbitrary technique, including separate unicast connections to all edge devices, IP multicast, a splitter network of servers forming a distribution tree, or an application-level multicast as shown in McCanne III.
- the content source could be co-located at BC 110 or at any other node in the network.
- CDN 100 could distribute the content in one of a variety of ways.
- the content distribution mechanism is independent of the query/response distribution mechanism in this case.
- FIG. 3 shows the first step of query handling: distributing a query message Q from BC 110 to the four edge devices 104 .
- the dashed lines represent the separate unicast connections used to distribute the query message.
- the connections traverse common network links close to BC 110 and as a result, more bandwidth is used on those links because they carry multiple copies of the query message. This bandwidth usage increases as the number of edge devices increases, and hence this technique suffers from scaling problems for large networks. Additionally, the number of network connections and packets BC 110 must open and deliver also increases in proportion to the number of edge devices.
- FIG. 4 shows the second step in query handling: the edge devices (the query respondents in this example) responding to the received query message.
- the edge devices the query respondents in this example
- the query response messages cause the same scaling problem as the unicast query messages: the bandwidth used near BC 110 and the number of network connections open at it increase linearly with the number of edge devices.
- all of the replies must be processed and analyzed at BC 110 .
- the response processing load at BC 110 scales just as poorly as the query/response network bandwidth does.
- An alternative to the above is to collect the responses from the edge devices at BC 110 using separate unicast connections, but to distribute the query using multicast for the query messages.
- a distribution tree is constructed so that only a single copy of data transmitted from the source flows along any network link common between the sender and multiple receivers.
- FIG. 5 shows a multicast tree distributing the query messages from BC 110 to the edge devices. Note that, unlike the arrangement shown in FIG. 3, only one connection is used, and only one copy of the query message needs to flow, across each link in the paths. This solves the network bandwidth scaling problem for the queries; however, it does nothing to solve the bandwidth and processing scaling problems for the responses. Multicast can be used to distribute the query because each edge device receives the same query. However, because each response is potentially unique, multicast cannot be used to achieve similar savings in bandwidth for response collection. As a result, if the uniqueness of the responses is dealt with again by unicasting the responses back to BC 110 (as in FIG. 4), the responses still cause bandwidth and processing scaling difficulties.
- FIG. 6 shows a multicast distribution tree with intermediate aggregation nodes 200 between edge devices 104 and BC 110 , as might be used to collect query responses to the query sent out as illustrated in FIG. 5.
- the aggregation nodes are arranged in a hierarchical tree, with parent aggregation nodes relating to child aggregation nodes.
- the answers are propagated back up the multicast tree towards the root (BC 110 ), from child AN to parent AN, but at each aggregation node (AN) 200 along the way, the answers from the children of that AN are concatenated together and sent in a single transmission to the parent of that AN.
- the responses from edge devices 104 ( 1 ) and 104 ( 2 ) are concatenated at their parent AN (AN 200 ( 1 )) and the combined response could be sent in a single packet to the parent of AN 200 ( 1 ), which is AN 200 ( 3 ).
- This can result in a reduction of some of the network processing performed by the CDN and bandwidth used in the CDN.
- savings are achieved in network processing (fewer packets to route and process at BC 110 ) and bandwidth (fewer packets means fewer packet headers).
- the amount of response data flowing towards BC 110 still grows linearly with the number of edge devices.
- This bandwidth growth is illustrated by the width of the lines representing the flow of responses in FIG. 6.
- the widths of the lines represent the bandwidth used in transmitting a response.
- the line widths increase because the size of the responses increases as more individual responses get concatenated together.
- the bandwidth used by this response collection scheme still grows proportionally to the number of edge devices.
- this technique does nothing to effectively scale the data processing done by BC 110 ; it still must combine and analyze all of the data from the senders (in this case, it must sum all of the results). Nonetheless, such a scheme is an improvement over a system of sending individual queries and receiving individual responses.
- FIG. 7 shows a more bandwidth and processing efficient approach to aggregation. It builds on the technique shown in FIG. 6, in which each AN in the tree combines the results from its children and sends a single response to its parent. However, unlike the arrangement in FIG. 6, in which ANs perform simple concatenation of their children's responses, the ANs in FIG. 7 apply an aggregation operator (other than simply concatenation) to the responses. In this case, the aggregation operator is simple addition: the responses of the children are added together and only their sum is propagated upward towards BC 110 . Note that because of the aggregation, the arrows representing the responses in FIG. 7 do not get thicker.
- the aggregation of FIG. 7 has several advantages. For one, it maintains a desirable property of the simple concatenation described in the previous section in that, because only one response packet flows along any link in the tree, the network processing performed at the routers and BC 110 can scale with large numbers of edge devices. Another advantage is that because each intermediate AN between the edge devices and BC 110 aggregates the responses that flow through it, the computational processing needed to analyze the queries is distributed throughout the CDN, instead of concentrated entirely at BC 110 .
- the aggregation operator is scalar addition. Rather than having BC 110 perform N ⁇ 1 additions of the results from N edge devices, these N ⁇ 1 additions are spread throughout the aggregating nodes 200 of the CDN. How effectively the data processing can be distributed depends on the specifics of the query and the aggregation function used, but in many cases (for example, addition) the maximum number of inputs any AN must analyze is upper bounded by the ANs' maximum fanout (i.e., the number of immediate children of a AN).
- Yet another advantage is reduced bandwidth, since the bandwidth needed for sending response information to BC 110 is bounded and independent of the number of device nodes, resulting in scalability for large numbers of device nodes.
- the size of the data flowing towards BC 110 stays constant, because the aggregation operator combines many scalar inputs into a single scalar output.
- a network could contain active AN's and passive AN's. Whether an AN is active or passive could be determined either statically during network configuration or with a dynamic protocol. In between aggregation nodes, the responses could flow as in FIG. 1 (separate flows), but overall scalability can still be ensured.
- FIG. 8( a ) shows intermediate nodes that do not aggregate responses and just forward them on up the tree. Those are passive aggregation nodes. Note that although the response bandwidth and network overhead (i.e., the number of connections and packets used) can increase immediately up the tree from these nodes, as soon as an active aggregation node is reached, those factors scale back again.
- FIG. 8( b ) shows a similar arrangement, except that the non-aggregating nodes (passive aggregation nodes) do concatenate responses before forwarding them up the tree. This reduces some of the network processing as described in the “Multicast Queries and Concatenated Responses” section above and illustrated in FIG. 7.
- broadcast center that issues queries and receives responses.
- multiple broadcast centers can be used to issue different queries (or even identical queries, for robustness) to different subsets of the device nodes (or all of them).
- This section details example embodiments of distribution mechanisms that can be applied to deliver queries from query nodes to device nodes. All of the examples in this section assume that the queries will be distributed using multicast for efficient delivery; but it should be apparent after review of this disclosure to apply these techniques if unicast is to be used for query distribution, as that case is much simpler.
- queries are uniquely identifiable where more than one query is flowing through the network (a likely occurrence), so that a device node can associate particular responses with particular queries and so that an aggregation node can distinguish among responses.
- a unique query identifier is assumed to be included with query messages sent from a query originator.
- the identifier allows aggregation nodes to know which programmable aggregation operation(s) should be performed on the responses flowing into them and the identifier can be used for “controlling” the query.
- the “query program” describing the information to be queried and how it should be combined need only be distributed to the device nodes once, even if it is to be executed multiple times.
- Queries can be sent dynamically or they can be statically configured and stored in each device node. In either case, once a device node has seen a query, it only has to store it at the device node (in a table, for example) in such a manner that it may be referenced it by its identifier (for example, an N-bit number).
- One way to reliably propagate and “install” queries at the device nodes is to distribute the queries using the MINT protocol described in the MINT application (referenced above).
- the MINT protocol allows key-value pairs of information to be associated with or “published” to an Application-Level Multicast Group and reliably distributed to all members of that group. Queries (and query control messages) can be disseminated using the MINT protocol.
- the queries can then be distributed to device nodes telling them to start or stop running the query, to change the frequency of response, to modify parameters of the query itself, etc., simply by referring to the query identifier rather than by including the entire query structure (which might be a series of instructions, such as SQL instructions, or query instructions is a language specific to this application).
- the query structure or instructions are unique among queries so that query structure/instructions (or a hash thereof) can use used as the unique identifier.
- the responses would include the query structure, instructions or hash to identify the query to which the response is responsive.
- the section describes how query multicast distribution trees might be configured and established, the closely related issue of deciding what the delivery scope of the queries should be, and possible distribution mechanisms for delivering the queries to their destinations via their distribution trees.
- the destination of the queries is assumed to be known. In some cases, it is known exactly which edge devices and/or network nodes are to be queried. In other cases, explicit knowledge is not known, or strictly necessary, but instead just a class of device nodes is known (e.g., the class of all edge devices receiving program N from Content Source X). It is also assumed that there is some path for information flow from a source to the device nodes (which is not necessarily the same source as the query node).
- a broadcast center might be the at the query node and act as the query originator sending a query to all device nodes associated with edge devices pulling down a certain program stream. In this case, the edge devices are not explicitly known, but a mechanism exists for reaching the nodes: the multicast group rooted at the content source injecting the program into the CDN.
- the process described below for establishing a query and response distribution tree is in two parts.
- the first part is to establish a multicast distribution tree for sending the queries.
- the queries flow from the root of this tree down towards its leaves (device nodes). Note that device nodes can be located in the interior of the tree as well as at the leaves.
- the second part is to establish a reverse-path collection tree upon which the responses will flow up from the device nodes towards a collection node.
- Aggregation nodes will be located at interior nodes in this tree (i.e., nonleaf nodes), so that responses flowing into an aggregation node from its child nodes (which could comprise one or more device nodes and/or other ANs) are aggregated into a response sent upwards to the parent of the AN (either another AN or the collection node at the root of this tree).
- both the query distribution and the response aggregation trees can be the same, but they need not be. Also, it is possible to use still another tree to distribute the instructions necessary to construct the query distribution and/or collection trees.
- the existing content distribution tree might be used for both the query distribution and response collection, as has already demonstrated by FIGS. 5 and 7.
- separate query distribution and response collection trees could be constructed, if desired, using techniques described below.
- FIG. 9( a ) shows content distribution
- FIG. 9( b ) shows BC 110 unicasting a query to a content source 102 , which then distributes the query to the edge devices.
- FIG. 9( c ) shows collecting the responses at content source 102 and then delivering the final response back to the BC 110 via unicast.
- the existing content distribution tree is used for both the queries and responses. This technique allows the possibility of “piggybacking” queries onto program data that is already flowing to edge devices.
- FIG. 10 shows one framework that can allow for these different tree possibilities.
- a broadcast center that wants to send a query to the distribution tree of program A, rooted at content source CS 1 .
- the broadcast center sends CS 1 a message to be distributed to program A's recipients instructing them to join a new query distribution group rooted at the broadcast center group, called group (A, broadcast center) (step 1 , FIG. 10( a )).
- group (A, broadcast center) multicasts this join instruction to group (A, CS 1 ) (step 2 , FIG. 10( a )).
- group (A, CS 1 )'s members send join messages up to the broadcast center, constructing the query distribution tree (step 3 , FIG.
- the broadcast center multicasts queries on the new multicast group (step 4 , FIG. 10( c )).
- Query responses flow up the reverse query distribution tree towards its root, the broadcast center (step 5 , FIG. 10( d )).
- Aggregation nodes located along the tree can collect responses from below and generate aggregated responses sent up towards the broadcast center.
- the framework illustrated in FIG. 10 can handle many different cases, such as:
- Step 1 is unnecessary. Steps 2 - 3 are performed whenever an edge device or node joins a program group.
- step 1 could be replaced by the broadcast center joining the program tree, and the join instruction of step 2 would then be sent directly by the broadcast center, rather than CS 1 .
- This section gives some examples of different delivery scopes that may be used with queries, using a CDN as the data network being queried.
- a query can be done using a well-known “broadcast” multicast channel that every device joins upon startup.
- the delivery scope is a dynamically configured subset of nodes of the CDN, such as the edge devices belonging to a specific content program distribution tree, another approach is needed. Because these devices may dynamically join and leave the program distribution group, the broadcast center does not know exactly, prior to sending the query, the query's intended recipients. However, the query can still reach all of the intended recipients if the query is broadcast on the program's distribution tree.
- This dynamic set of nodes could also include (or might consist solely of) the internal nodes belonging to a specific program tree (for example, the routing devices used to distribute the program).
- the programmable query could be sent along the program distribution tree and specify whether edge devices or internal nodes (or both) should act as device nodes.
- the CDN might be configured with information about the domain (or domains) that each node belongs to.
- Domain-specific distribution trees can either be statically constructed during startup of the CDN (as each device in the CDN is initialized it joins a specified query distribution group(s) corresponding to its domain(s)), or they can be dynamically constructed at a later time, as necessary, by flooding a control information request (e.g., MINTs) to the entire CDN (using the well-known broadcast channel) instructing nodes matching a domain to join a domain information tree rooted at the broadcast center.
- MINTs control information request
- queries may pass through some possible device nodes that are not supposed to respond to the query, but instead simply forward it on to other downstream device nodes.
- the programmable query may specify which devices are supposed to respond to it. At a high level, the query could simply specify that the query be executed on all network nodes that it passes through, or all edge devices that it reaches, or both. The query could also specify specific subsets of these.
- the queries and responses are delivered by the data network. There are many possible ways to do this. One would be to use a multicast distribution system for delivering the queries, and use a reverse-path multicast tree for delivering the responses. IP Multicast could be used if the routers are programmed with the ability to execute queries and run aggregation operations.
- ALM Application-Level Multicast
- the multicast routers need to know how to route “upwards” from the leaves of the tree towards the root.
- unicast could be used between devices in the query and/or response distribution trees if these device nodes and aggregation nodes are manually configured to route towards the next appropriate “hop” in the distribution tree.
- Query responses and their aggregates can be categorized as either being single-dimensional (scalar) or multi-dimensional (vector).
- Scalar responses are those in which a device node returns a single value and which ANs can aggregate into another single value. For example, three different device nodes responding to the query “How many clients are watching program 101 ?” might produce scalar responses of 5, 3 and 0. An AN receiving these responses could then sum them together to form the scalar aggregate response of 8.
- Vector responses can have more than one dimension.
- Vectors could be “distributions” in which the answers fall into a fixed and defined set of buckets or bins. For example, queries such as “How many servers have loads in the ranges [0-10%, 10-20%, . . . , 90-100%]?” or “How many clients are viewing: [Program 1 , Program 3 , Program 7 ]?” would have a fixed set of bins. This is illustrated by FIG. 11 for a CDN example, which shows all responses (including the aggregate) having three dimensions (bins), even when the contents are zero. The responses are aggregated by summing the responses within each bin.
- Vector responses can also be of variable length, such as the answers to the query “How many clients are watching all channels?” and an aggregation instruction “Return the results by channel” (the variable being the number of channels).
- This type of vector response is shown in FIG. 12 for a CDN.
- the responses comprise keys (the program channel, i.e. “A” or “C”) and corresponding values.
- the size of the responses can increase as they flow up the aggregation response tree, as shown by FIG. 12.
- the query returns an amount of data upper bounded by the total number of channels being injected (which bounds are presumably known to the broadcast center).
- Addition This operator sums the responses flowing into the AN to form the response that flows upward. This is straightforward for scalar responses. Addition may also be used to combine vector distributions (of fixed or variable length) together by performing scalar addition bin-by-bin. This is illustrated in FIGS. 11 - 12 .
- Concatenation With concatenation, the results are simply combined or appended together. As such, the amount of data returned to the broadcast center increases linearly with the number of device nodes responding to the query. This may cause scaling issues, but a concatenation operation may still be acceptable to the data network provider, especially if the network has been appropriately provisioned with the bandwidth and processing power to handle the queries.
- An example use of concatenation would be to aggregate the responses to the query “What are the IP addressees of all clients watching Program 3 ?”. Since the response collection system wishes to know all of the unique responses, all responses are simply combined together by the ANs and forwarded on.
- Sort This operator can be combined with concatenation to return a sorted list of results (using a programmable sort operator).
- the computational processing required to sort all of the responses is effectively distributed throughout the collection nodes and aggregation nodes by using a divide-and-conquer-style algorithm such as the “quicksort” algorithm.
- the aggregate response is the minimum value of all of the responses that flow into the aggregator.
- the aggregate response is the maximum value of all of the responses that flow into the aggregator.
- Programmable filters could be used to exclude certain responses or aggregate them using AN-specific knowledge. For example, a query may ask “What is the distribution of computational load of the edge devices?” and specify that the results be aggregated by Internet Service Provider (ISP).
- ISP Internet Service Provider
- the edge devices may not be explicitly programmed with knowledge of who their ISP is, and thus could leave the “backbone provider” field blank, or alternatively list their IP addresses instead.
- These responses would be concatenated together until they reach an AN at the edge of an ISP network.
- These edge ANs could be programmed with a full mapping of ISP to IP addresses (or simply know that any responses that flow into the edge must have originated from within the specific ISP), and hence they could aggregate the concatenated responses into groupings by ISP.
- the query might ask “What is the distribution of load of the edge devices belonging to ISP XYZ?”, but the query may again be distributed to edge devices in other ISPs as well. Again assuming that these devices are unaware of their ISP, they would all run the query and return a response as before. But this time the ISP-aware ANs would filter out or drop any responses originating from machines in ISPs other than XYZ.
- Aggregation operators can be distributed using any of the techniques for distributing queries described above. For example, MINT could be used to distribute and install operators and ANs in an ALM network. And just like queries, each aggregation operation should have some kind of unique identifier. The primary purpose of this identifier is to allow the aggregation operation to be associated with a query and its responses, but it can also be used for other purposes such as referencing installed aggregation operators in control information.
- One identifier that can be used is simply the identifier of the query to be aggregated (which could be the query itself).
- Another identifier is the aggregation operator itself, which could be distributed by the query originator to each device node and then included in all responses flowing from the device nodes to the ANs.
- the aggregation operator identifier need not be the same, because a query may have multiple different aggregation operators performed on its responses, or vice versa, where the same aggregation operator is used on the responses of multiple different programmable queries.
- One feature of the programmable nature of the queries and aggregators is that the frequency of response can be specified as well.
- a query should be performed multiple times. For example, a query delivered to a CDN asking, “How many viewers are watching program 101 ?” would result in a viewer count or “ratings snapshot” at the particular time the query was issued, if the device nodes only responded to it once. However, if the query specified that the device nodes respond every 5 seconds, the queryor then can not only get a near-real-time viewership ratings snapshot, but can also see how the ratings evolve over the life of the program.
- the ratings are “near-real-time” not only because there may be some network and processing delay to transmit responses from device nodes through ANs and to the collection node, but also because the programmable aggregation operator may introduce some delay in order to save bandwidth.
- the query frequency is a fully programmable aspect of the query, many possible choices of response frequency exist, such as single response (the device nodes respond only once to the query), finite persistence, indefinite persistence and threshold responses.
- Finite persistence is a generalization of the single response, wherein the query may instruct device nodes to execute the query multiple times.
- the query might define the period between responses and persist until a fixed number of responses have been generated or a certain time has been reached. This could be used to view a “window” of data at a particular point in time.
- An indefinite persistence query specifies that the device nodes should execute the query periodically, with no end time or maximum number of responses specified.
- the period T of the query is programmable. Additionally, the device nodes might execute the query every T plus or minus X time units (where X is random or pseudorandom), such that the inter-response interval is not always exactly T, but averages out to T over time. This randomization can be used to avoid synchronization of all responses (i.e., avoid having all responses from flowing to an AN or a collection node at exactly the same time). Similar phenomena observed in the periodic exchange of routing messages in the Internet are described in Floyd, S. and Jacobson, V., “The Synchronization of Periodic Routing Messages”, IEEE/ACM Transactions on Networking, V.2 N.2, p. 122-36 (April 1994).
- Threshold responses are persistent queries (either finite or indefinite) that get run at the device nodes and, instead of being run at a fixed period, are only run when the response changes by more than a programmable threshold amount. Additionally, the query may specify that device nodes should also respond at a low frequency even if their response has not exceeded the threshold, to provide robustness against packet loss and ensure that the aggregated response reflects the state of the devices within a recent time interval.
- the frequency at which an aggregated response is generated and propagated up towards the collection node may also be specified. Some possible frequencies include unlimited, frequency-limited, rate-limited, programmable rate and policy-based.
- an aggregator With no limit frequency, an aggregator generates a new aggregated response whenever it receives a new response from any of its children. This method does not scale well, as each response generated by a device node results in a response being propagated all the way up the aggregation distribution tree to the collection node root. However, this may be more scalable if used with thresholded queries.
- an aggregator may be programmed to generate an aggregate response every T time units. Randomization and/or threshold techniques (as described above) can also be applied. If the aggregation period is the same as a periodic query, the result is that, on average, an AN should receive a new query update (or aggregated response from another AN) from each of its children between each aggregate response generated by the AN.
- a token-bucket or other rate-controlling mechanism might be used to ensure that the bandwidth of the aggregated responses does not exceed a defined limit. This may be useful with the concatenation aggregation operator or other aggregation operators that may result in the size of the aggregate response being larger than the size of any response flowing into the AN.
- an AN may have the ability to specify the rate at which it wishes to receive responses from its children by modifying the programmable query/aggregator as it flows down the tree through the node the AN is attached to.
- An AN can control the total rate of responses flowing into it using such a method. For example, an AN may have 5 children, be running 3 queries, and wish to receive no more than 30 responses/second. Before forwarding each query and aggregation information to its children, it may modify them to specify that each child should send a response every 0.5 seconds.
- the query/response frequency can also be determined by customer-specific bandwidth policies. These can be influenced by attributes in the query itself, as well as bandwidth-sharing policies defined by the CDN (for example, as taught by Welch.
- a CDN may specify that a customer be allowed to run queries at a “typical rate” comprising a maximum bandwidth and/or update frequency that may be used.
- the actual rate allocated to that customer's queries might be limited by available network bandwidth, in which case a bandwidth-sharing policy is used to determine what actual rate to give to the queries.
- FIGS. 13 - 14 illustrate a basic query network handling system used with a generic data network.
- a cloud represents the equipment that makes up the network.
- a query originator 901 and a response collection system 902 are shown in FIG. 13, coupled to query node 903 and collection node 904 , respectively.
- Query originator 901 distributes a query 905 and response collection system 902 receives the query response data. Examples of query originators and response collection systems include a broadcast center running in a CDN and a “Network Operation Center” (NOC) in a general data network.
- NOC Network Operation Center
- the programmable queries are received at each of these device nodes and the responses are returned back through the data network to response collection system 902 .
- the device nodes might also provide a naming system to map well known virtual names (that may be used in programmable queries) onto corresponding physical, equipment-specific names. This allows different, heterogeneous equipment to respond to the same query.
- the device nodes 906 might be included as part of the devices being queried, or could be a separate components that are able to obtain responses to the query about the devices.
- FIG. 14 shows the query responses first shown in FIG. 13 flowing through two aggregation nodes 920 .
- Responses R 1 and R 2 flow through aggregation node (AN) 920 ( 1 ), where they are aggregated into response R 4 .
- This response, along with response R 3 flows through AN 920 ( 2 ), and finally the resulting aggregated response R 5 is the only one delivered to collection node 904 .
- this can result in network bandwidth savings.
- the programmable aggregation operation for a query in a CDN asking “How many viewers are watching program 700 ?” could sum the responses together to form the aggregate response, and so N responses each of data size X flowing into an AN result in a single aggregate response of size X.
- the maximum amount of response data flowing towards any aggregation node or collection node in the network is hence bounded not by the number of device nodes, but instead by the maximum fanout.
Abstract
Description
- This application claims priority from Provisional Application No. 60/217,250, filed on Jul. 10, 2000 and is incorporated herein by reference for all purposes.
- This application may reference:
- U.S. patent application Ser. No. 09/323,869, entitled “Performing Multicast Communication In Computer Networks By Using Overlay Routing”, filed Jun. 1, 1999 (hereinafter referred to as “McCanne I”);
- U.S. patent application Ser. No. 09/384,865, entitled “System for Bandwidth Allocation in a Computer Network”, filed Aug. 27, 1999 (hereinafter “Welch”);
- U.S. patent application Ser. No. 09/412,815, entitled “System For Multipoint Infrastructure Transport In A Computer Network”, filed Oct. 5, 1999 (hereinafter “the MINT application”);
- U.S. patent application Ser. No. 09/458,216, entitled “A Proximity-Based Redirection System For Robust And Scalable Service-Node Location In An Internetwork”, filed Dec. 9, 1999 (hereinafter “McCanne II”); and
- U.S. patent application Ser. No. 09/609,442, entitled “A Content Distribution System For Operation Over An Internetwork Including Content Peering Arrangements”, filed Jul. 3, 2000 (hereinafter “McCanne III”).
- The disclosures of the above-referenced applications are also incorporated in their entirety herein by reference for all purposes and those applications are assigned, or the inventors are under an obligation to assign, to the assignees of the present application.
- The present invention relates to methods and apparatus for querying large numbers of devices using a network. More specifically, the present invention relates to efficiently and scaleably issuing queries to devices from a monitor and collecting results of those queries.
- Connecting large numbers of devices to a network is known. Perhaps the most referenced network, and possibly the most used, is the global internetwork of networks known as the “Internet”. With the Internet and other networks, a network manager of all or part of the network often needs to query devices at many nodes of the network. In the Internet field, a protocol known as SNMP (Simple Network Management Protocol) has been in wide use for querying devices for status and collecting responses. Some details of SNMP are set forth in Request for Comments (RFC) 1156 (May 1990) and RFC 1157 (May 1990). RFC's form the basis for many standards used in connection with the Internet and are widely available.
- Using SNMP, a network monitor would send queries out to devices that are responsive to SNMP and the devices would respond to the queries back to the network monitor. The network monitor is coupled to the network at a network node and the devices are coupled to the network as well. SNMP might work well with one network monitor querying dozens, hundreds or even thousands of devices, but becomes problematic with greater numbers of devices. One problem is that the network around the network node gets congested as the network monitor attempts to send SNMP query request packets to each device. Even if the query request could be broadcast to the devices, using multicasting or other techniques, the returning query responses would bog down the network near the network node. Such congestion would occur with only one response per device, so the congestion could be expected to be much worse if each device sends more than one response per query, as might be the case for a query that requests periodic updates from a device.
- Often, a network comprises many networked devices. Operating such a network is typically a critical yet complex task requiring refined mechanisms for configuring, managing, debugging, monitoring, and measuring equipment and equipment performance. While protocols and tools for managing individual pieces of equipment within a network are well understood, systems for managing or monitoring an ensemble of equipment across a network are poorly understood and underdeveloped.
- This problem becomes even more acute in the context of an emerging network abstraction called a Content Distribution Network (CDN). Examples of CDNs are described in McCanne III. A CDN routes “content”, as opposed to a lower level router that merely routes individual packets. The content routed by a CDN might be a set of media streams and the content flows across the CDN to “edge devices”, which might be clients for viewing or storing the content or servers that forward on the content to such clients. CDNs may function in such a way that the content is distributed to interested edge devices without requiring a centralized control point in the network that knows the exact details of which devices are receiving the content or how it is being distributed (for example, which network paths is the content flowing across). Unfortunately, management and monitoring tools often need access to this very information in order to perform their functions.
- One embodiment of the present invention provides for an improved query handling system. The network transports query messages from query nodes to device nodes. Query responses from the device node are directed through the network to a collection node or nodes. The device nodes might be supported by servers that are located in the network near the network devices. Such servers would maintain information about their network devices, such as information about the data streams being served to the network devices. When an internal response network node receives multiple query responses from device nodes, the internal response network node might aggregate, as needed, the multiple query responses into an aggregated query response. Preferably, an aggregated query response occupies less bandwidth than the aggregated multiple query responses.
- Where the result desired at the collection node is a computed function of the multiple query responses, such as a concatenation, sum, logical function, summary, etc., the computed function can be performed at each internal response network node on the multiple query responses received at that node, thus distributing the computation needed to form a collected response to the query.
- In particular embodiments, queries might request real-time or non-real-time responses and queries might request one response, periodic responses or one response for each occurrence of an event. The internal response network nodes might store lookup tables, or access a centralized lookup table, that specify details of queries, thus obviating the need for each query message to carry all of the necessary details of the query. In a specific embodiment, query messages from a query originator to a network device identify the query being made by an index into a query lookup table. The lookup table might also include details or instructions usable by the internal response network nodes for performing an aggregation specific to the query.
- A further understanding of the nature and advantages of the inventions herein may be realized by reference to the remaining portions of the specification and the attached drawings.
- FIG. 1 is a block diagram of a generalized query handling system according to one embodiment of the present invention.
- FIG. 2 is a schematic diagram similar to FIG. 1, but showing more details of traffic flow.
- FIG. 3 is a diagram illustrating the flow of a query to device nodes.
- FIG. 4 is a diagram illustrating the flow of query responses from device nodes to a collection node via aggregation nodes.
- FIG. 5 is a diagram illustrating the flow of a query to device nodes using multicasting.
- FIG. 6 is a diagram illustrating the flow of query responses to a collection node using aggregation at intermediate nodes.
- FIG. 7 is a diagram illustrating the flow of query responses to a collection node using aggregation at intermediate nodes with less increase in bandwidth use near a root collection point relative to the aggregation shown in FIG. 6.
- FIG. 8(a) is a diagram illustrating a query response network with active aggregation nodes and passive aggregation nodes; FIG. 8(b) is a diagram illustrating a similar arrangement, but with data combination at passive aggregation nodes.
- FIG. 9 illustrates a query response network wherein queries about content originate with a content source;
- FIG. 9(a) is a diagram illustrating content flow from a content source to edge devices;
- FIG. 9(b) is a diagram illustrating a query flow along the same paths as content flow; and
- FIG. 9(c) illustrates response collection along those same paths.
- FIG. 10 illustrates using separate distribution trees for content and querying.
- FIG. 11 illustrates aggregation of vector responses.
- FIG. 12 illustrates aggregation of vector responses with variable length vector responses.
- FIG. 13 is a diagram illustrating the issuance of queries and collection of responses at different nodes.
- FIG. 14 illustrates multiple levels of aggregation nodes.
- A few examples of specific embodiments of query handling systems according to the present invention are described herein. Others may become apparent after reading this description and it should be understood that the invention is not limited to these specific examples, but is limited only by the appended claims. Furthermore, while specific methods and apparatus are shown, it should be apparent upon reading this disclosure that some of the methods can be practiced using different apparatus and the apparatus shown could be used to perform different methods than shown.
- This description discloses how to make and use several embodiments of a system according to the present invention, but for brevity omits descriptions of many well-known components of such systems. For example, the operation and design of a standard TCP/IP network, standard TCP/IP clients and the like are not explicitly disclosed herein, as they well described in countless readily available sources.
- In the description below, like elements of the figures are referenced with like numbers. Distinct instances of like elements might be referenced with like numbers followed by distinct instance numbers in parentheses.
- Query handling systems according to the present invention can operate over many different types of data networks, such as a well-known TCP/IP network. Another type of network is a content distribution network (CDN). In the figures, a query handling system using a CDN is first described, along with features specifically useful for CDNs, followed by a description of a query handling system for a generic packet-switched network. Upon review of this disclosure, it should become apparent that a query handling system could be used to query edge devices in a CDN, where the routed elements are content, such as media streams, or where the routed elements are packets, as with a packet-switched network.
- As used herein, “query originator” refers to a person or machine that originates a query for information about a network. Presumably, the query is issued for the purposes of obtaining an answer to the question inherent in the query. However, other uses of issuing queries might become apparent upon review of this disclosure. For example, a query might be issued for testing purposes or to trigger an event elsewhere in the network. Such uses can be the entire reason for making the query or might be ancillary to getting an answer to the question posed.
- A “query message” is data that, alone or in combination with other data (such as lookup tables), indicates what question is being asked of the network.
- A “network device” is a device that is coupled to the network. A network device might be an entirely self-contained object or might be an object that interfaces with nonnetwork equipment or users.
- A “query node” is a node of the network at which the query is said to originate or where the query is “injected” into the network. A network might include nodes and/or equipment between the query node and the query originator without departing from the general definition of query node used herein.
- A “device node” is a network node at which a network device connects to the network or a node at which queries about that network device can be answered. Device nodes might be supported by servers that are located in the network near the network devices. Such servers would maintain information about their network devices, such as information about the data streams being served to the network devices. For a given network device, the device node, which is used for query/response activity, can be the same node the network device uses for its main function. For example, a streaming video player client might use the same IP address for receiving and responding to queries as it uses to receive streaming video (its main function). However, for other network devices, the network device's network node for its main function might be distinct from the device's device node used only for the query process.
- A “collection node” is a network node at which query responses from device nodes are received. Typically, a collection node is where a response collection system is coupled to the network, however other configurations are possible.
- At a high level, queries can be thought of as originating at a query node, propagating to device nodes and query responses can be thought of as originating at device nodes and propagating to collection nodes.
- An “internal network node” is a network node that is between a query node and a device node or a device node and a collection node. An “internal response network node” is an internal network node on a path between a device node and a query node. An “internal query network node” is an internal network node on a path between a query node and a device node. The internal response network nodes visited by a query response as it passes from a device node to a collection node can define the same path that a query follows but in reverse, but that need not be the case. Thus, a query might follow one path from a query node to a device node and another path from the device node to a collection node, even where the query node and the collection node are the same node. In a specific embodiment, each network monitoring node is a query node and a collection node and a query follows a path through the network to a device node, encountering internal query network nodes and the response to the query follows the same path in a reverse order (albeit with some aggregation possibly occurring at various internal response network nodes), where the nodes that act as internal query network nodes act as internal response network nodes for the returning responses.
- FIG. 1 is an illustration of a Content Distribution Network (“CDN”)100 with which a query handling system might be used. The details of
CDN 100 are not shown, but typically might include routers, switches, caches, servers, databases, etc., as part of the network fabric. WithCDN 100,content sources 102 provide content (such as programs 103) to the network and that content is provided byCDN 100 to edgedevices 104 that provide the content to end-users. Of particular interest to broadcasters is the number of end-users receiving particular content and other data about the end-user clients,edge devices 104, etc. Typically, but not always, anedge device 104 will have individual connections to end-user computing devices 106, such as a point-to-point packet channel, so that an edge device is fully aware of the content received by the end-user computing devices through the CDN. In such cases,edge devices 104 would be able to answer queries about the content received by the end-user computing devices. Regardless of whether the query about an end-user device is answered by an edge device coupling the end-user device to the network, an end-user device itself or a server monitoring the end-user device apart from its coupling to the network, it should be understood that a query directed at the end-user device's device node would evoke a response (if the query calls for a response) from the device, program or logic assigned to be the respondent at that device node. - In some cases, as is shown in FIG. 1, a broadcast center (“BC”)110 monitors content broadcasting from nodes distinct from the content sources, by sending out queries to edge
devices 104 and receiving subsequent query responses. In other embodiments, the content sources and broadcast center might be integrated at one network location. - FIG. 2 shows the system of FIG. 1 with more details on specific data flows, such as program feeds, pathways for query messages and pathways for query responses. In FIG. 2, the transport of query messages and query responses is not illustrated; such details are shown in subsequent figures. In FIG. 2,
BC 110 is a query originator, a node at whichBC 110 is coupled to the network is a query node and nodes at whichedge devices 104 are coupled to the network are device nodes. - A query originator can be implemented as a computing device coupled to CDN100 (or a packet-switched network underlying CDN 100), as program code executing on a general purpose computer, as program code executing on a routing device, or the like. In one specific embodiment, software agents run within a virtual machine (VM), such as a Java™ VM executing on a computer coupled to CDN 100, act as query originators.
- An example of a query respondent (i.e., a device, software or agent at which query collection starts; typically coupled to the network at a device node) is a program inside a VM that runs an SNMP agent. The SNMP agent can access Management Information Base (MIB) objects in nearby equipment and can respond to queries about the information stored in those MIB objects. MIB's are described in greater detail in RFC1156, which is hereby incorporated by reference for all purposes.
- Once the query responses are collected at a collector coupled at a collection node, the data can be provided to various processes, devices or users that need the data. For example, the data might be written to text files that may be viewed or processed later or inserted into a database. Access to the data might then be dependent on the query and who generated it. Thus, one query handling system might be used by multiple content providers, but each content provider would have to be authenticated to the collector collecting the responses, so that each content provider can only access data relating to their own content, even if the data was collected for multiple content providers. This approach is useful where the data network is run by a service provider that delivers data for more than one customer. An authentication system, such as a Web-based SSL login/authorization transaction, can ensure that only its legitimate customers can view data stored at the collector. Each customer can also be limited such that the customer cannot view all of the data collected by the service provider for that customer, if the service provider does not wish to pass on all of the collected data. If the customer is allowed to initiate queries, an authentication system can also control or limit the types of queries that the customer can perform.
- If one query originator originates a query to many, many query respondents, receiving individual responses from each respondent may congest the network around the collection node. Congestion might also occur around a query node as the originator sends individual queries to each respondent. Where the query node and the collection node are the same node, this congestion could be expected for both outgoing traffic and incoming traffic, but the problems are the same whether the query node and the collection node are the same or separated. There are several methods and/or apparatus, described below, that can be used to avoid or reduce congestion at a collection node and at a query node. As explained below, congestion around a query node is often easier to resolve, and some prior art methods, such as the use of multicasting, can partially (or in some cases, entirely) solve the congestion problem at the query node.
- As the number of respondents grows, without more, there would be a proportional growth in the network bandwidth needed to deliver the query responses to their destination and the computational processing power and time needed to process the responses at the destination. To relieve bandwidth and computing bottlenecks, the data network, such as CDN100 (shown in FIGS. 1-2, et seq.), is populated with aggregation nodes, as illustrated by FIGS. 3-5 and described in more detail below. As query responses travel between the device nodes and one or more collection nodes, the responses flow through aggregation nodes. Agents, or other computing objects, at an aggregation node perform programmable aggregation operations on received query responses that flow to the aggregation node from device nodes and forward the aggregated result on towards the collection node or nodes.
- With aggregation, the maximum load on the network for query response data can be reduced from a load proportional to the number of device nodes, and instead be proportional to the maximum “fanout”, where fanout refers to the number of device nodes or aggregation nodes that “report” to a given aggregation node or collection node. With aggregation, the amount of processing needed at a collection node might also be reduced. For example, with an addition aggregation operation, the maximum number of additions performed at any aggregation node or collection node is not proportional to the number of respondents but instead is proportional to the maximum fanout of that aggregation node or collection node.
- Distribution Methods for Queries and Query Responses
- This section describes how the network may be mapped onto specific data delivery systems for distributing queries and responses. Throughout, we use one specific example of streaming multimedia programs being delivered through a CDN. Some examples also assume the use of a sender-based multicast tree for distributing program content and queries and assume that the multicast infrastructure supports reverse-path transmission of data from the edge of the tree towards the root or core.
- In the example shown in FIG. 1,
multiple content sources 102 inject programs from different parts of the network,multiple edge devices 104 are located on “leaf nodes” at the edges of the network, andCDN 100 delivers program content fromcontent sources 102 to thoseedge devices 104 that are interested in the content (this is a feature of CDN 100).CDN 100 comprises various interconnected nodes or routers that can deliver content fromcontent sources 102 to edgedevices 104. Further details of the operation ofCDN 100 can be found in McCanne III.Edge devices 104 may be the final destination for the content (for example, they could be streaming media viewing clients), oredge devices 104 could be intermediate devices, such as servers that in turn forward content on to clients.CDN 100 could comprise a network of FastForward Mediabridge™ servers running ALM (Application-Level Multicasting), butCDN 100 could also use another delivery mechanism capable of reaching multiple receivers, such as IP multicast, a RealNetworks G2™ Splitter network, or even separate unicast connections from eachcontent source 102 to everyedge device 104 pulling down content from that content source. - In the first example shown (FIGS.1-7), broadcast center (BC) 110 monitors the current state and health of
CDN 100, the content that is flowing across it, and information from any devices used to effectCDN 100, such as the current number of clients receiving a program fromCDN 100. Thus,BC 110 serves as a controller ofCDN 100 as well as a query originator and a response collection system. In that case, BC 110 can be said to be at the query node and the collection node for its set of queries. Although not shown, a given network might have multiple BC's operating more or less independently. - Of course, those three functions (CDN control, querying, collecting) do not necessarily have to be located at the same point in the network. FIG. 1 only represents a logical view of a CDN; it is not intended to imply that BC110 or
content sources 102 must be located on the “edge” ofCDN 100. In many cases, it will be beneficial to locate these elements close to the center or “core” ofCDN 100. - FIG. 2 is a schematic diagram similar to FIG. 1, but showing more details of traffic flow related to a querying process. As an example of a querying process,
BC 110 might issue a query to determine how many clients are watching program A (i.e., receiving the content associated with program A). As shown, content source 102(1) is injecting two programs, A and B, into the network and content source 102(2) is injecting two other programs, C and D, into the network. Those programs are being received byedge devices 104, with each edge device typically receiving only the programs that are being fed to clients connected to that edge device, as shown. For example,clients 106 coupled to edge device 104(1) are receiving only programs A and B, so edge device 104(1) need only receive programs A andB. Edge devices 104 might be media servers that receive program streams fromCDN 100 and deliver the streams toclients 106. As shown in FIG. 2, edge device 104(1) receives programs A and B; edge device 104(2) receives A and D; edge device 104(3) receives A, B, and C; and edge device 104(4) receives only stream D. If the operator ofBC 110 wants to know how many people are watching program A, the operator causes BC 110 to issue a query to that effect andCDN 100 distributes the query to eachedge device 104.Edge devices 104 respond with their answers (edge device 104(1): 2, edge device 104(2): 3, edge device 104(3): 1, edge device 104(4): 0) and send their responses back intoCDN 100, which collects the responses, aggregates them, and preferably delivers a single total back to BC 110 (6 in this case). - In some cases, the edge devices include a naming system to map well known virtual names, which may be used in programmable queries, onto corresponding physical, equipment-specific names. This allows different, heterogeneous equipment to respond to the same query. For example, if some clients are receiving program A, but know it as program X and other clients are receiving program A, but know it as program Y, their respective edge devices could translate the query using the naming system so that queries about program A are applied to programs X and Y as well.
- The following sections describe how the network maps on to various query and response distribution mechanisms. Note that not all components will be used in each instance.
- Unicast Queries and Unicast Responses
- FIGS.3-4 show an example of unicast, or point-to-point, connections between
BC 110 and eachedge device 104. FIG. 3 is a diagram illustrating the flow of a query fromBC 110 to various device nodes, where edge devices are coupled to the network. FIG. 4 is a diagram illustrating the flow of query responses from the device nodes to a collection node (which happens to be the same node as the query node, in this case) via aggregation nodes. - Not shown is program content being distributed through
CDN 100 from a content source; this can be done through any arbitrary technique, including separate unicast connections to all edge devices, IP multicast, a splitter network of servers forming a distribution tree, or an application-level multicast as shown in McCanne III. The content source could be co-located atBC 110 or at any other node in the network. In addition,CDN 100 could distribute the content in one of a variety of ways. The content distribution mechanism is independent of the query/response distribution mechanism in this case. - FIG. 3 shows the first step of query handling: distributing a query message Q from
BC 110 to the fouredge devices 104. The dashed lines represent the separate unicast connections used to distribute the query message. The connections traverse common network links close toBC 110 and as a result, more bandwidth is used on those links because they carry multiple copies of the query message. This bandwidth usage increases as the number of edge devices increases, and hence this technique suffers from scaling problems for large networks. Additionally, the number of network connections and packets BC 110 must open and deliver also increases in proportion to the number of edge devices. - FIG. 4 shows the second step in query handling: the edge devices (the query respondents in this example) responding to the received query message. Once again, separate unicast connections are used to communicate between each
edge device 104 andBC 110. The query response messages cause the same scaling problem as the unicast query messages: the bandwidth used nearBC 110 and the number of network connections open at it increase linearly with the number of edge devices. Additionally, all of the replies must be processed and analyzed atBC 110. Thus, the response processing load atBC 110 scales just as poorly as the query/response network bandwidth does. - Multicast Queries and Unicast Responses
- An alternative to the above is to collect the responses from the edge devices at
BC 110 using separate unicast connections, but to distribute the query using multicast for the query messages. In a multicast arrangement, a distribution tree is constructed so that only a single copy of data transmitted from the source flows along any network link common between the sender and multiple receivers. - FIG. 5 shows a multicast tree distributing the query messages from
BC 110 to the edge devices. Note that, unlike the arrangement shown in FIG. 3, only one connection is used, and only one copy of the query message needs to flow, across each link in the paths. This solves the network bandwidth scaling problem for the queries; however, it does nothing to solve the bandwidth and processing scaling problems for the responses. Multicast can be used to distribute the query because each edge device receives the same query. However, because each response is potentially unique, multicast cannot be used to achieve similar savings in bandwidth for response collection. As a result, if the uniqueness of the responses is dealt with again by unicasting the responses back to BC 110 (as in FIG. 4), the responses still cause bandwidth and processing scaling difficulties. - Multicast Queries and Concatenated Responses
- FIG. 6 shows a multicast distribution tree with
intermediate aggregation nodes 200 betweenedge devices 104 andBC 110, as might be used to collect query responses to the query sent out as illustrated in FIG. 5. - As shown, the aggregation nodes (ANs) are arranged in a hierarchical tree, with parent aggregation nodes relating to child aggregation nodes. In this case, the answers are propagated back up the multicast tree towards the root (BC110), from child AN to parent AN, but at each aggregation node (AN) 200 along the way, the answers from the children of that AN are concatenated together and sent in a single transmission to the parent of that AN. For example, the responses from edge devices 104(1) and 104(2) are concatenated at their parent AN (AN 200(1)) and the combined response could be sent in a single packet to the parent of AN 200(1), which is AN 200(3). This can result in a reduction of some of the network processing performed by the CDN and bandwidth used in the CDN. By reducing the number of packets flowing in the network closer to
BC 110, savings are achieved in network processing (fewer packets to route and process at BC 110) and bandwidth (fewer packets means fewer packet headers). However, despite these savings the amount of response data flowing towardsBC 110 still grows linearly with the number of edge devices. - This bandwidth growth is illustrated by the width of the lines representing the flow of responses in FIG. 6. The widths of the lines represent the bandwidth used in transmitting a response. As the responses flow up the tree from the edge devices towards the broadcast center, the line widths increase because the size of the responses increases as more individual responses get concatenated together. As a result, the bandwidth used by this response collection scheme still grows proportionally to the number of edge devices. Furthermore, this technique does nothing to effectively scale the data processing done by
BC 110; it still must combine and analyze all of the data from the senders (in this case, it must sum all of the results). Nonetheless, such a scheme is an improvement over a system of sending individual queries and receiving individual responses. - Multicast Queries and Aggregated Response
- FIG. 7 shows a more bandwidth and processing efficient approach to aggregation. It builds on the technique shown in FIG. 6, in which each AN in the tree combines the results from its children and sends a single response to its parent. However, unlike the arrangement in FIG. 6, in which ANs perform simple concatenation of their children's responses, the ANs in FIG. 7 apply an aggregation operator (other than simply concatenation) to the responses. In this case, the aggregation operator is simple addition: the responses of the children are added together and only their sum is propagated upward towards
BC 110. Note that because of the aggregation, the arrows representing the responses in FIG. 7 do not get thicker. - The aggregation of FIG. 7 has several advantages. For one, it maintains a desirable property of the simple concatenation described in the previous section in that, because only one response packet flows along any link in the tree, the network processing performed at the routers and BC110 can scale with large numbers of edge devices. Another advantage is that because each intermediate AN between the edge devices and BC 110 aggregates the responses that flow through it, the computational processing needed to analyze the queries is distributed throughout the CDN, instead of concentrated entirely at
BC 110. - In this example, the aggregation operator is scalar addition. Rather than having BC110 perform N−1 additions of the results from N edge devices, these N−1 additions are spread throughout the aggregating
nodes 200 of the CDN. How effectively the data processing can be distributed depends on the specifics of the query and the aggregation function used, but in many cases (for example, addition) the maximum number of inputs any AN must analyze is upper bounded by the ANs' maximum fanout (i.e., the number of immediate children of a AN). - Yet another advantage is reduced bandwidth, since the bandwidth needed for sending response information to
BC 110 is bounded and independent of the number of device nodes, resulting in scalability for large numbers of device nodes. In the addition example above, the size of the data flowing towardsBC 110 stays constant, because the aggregation operator combines many scalar inputs into a single scalar output. - Note that although many examples given here include processing and aggregation at each AN, that need not be the case. For example, techniques described herein can easily be adapted so that only a subset of network nodes performs aggregation while others merely forward query responses they receive. Thus, a network could contain active AN's and passive AN's. Whether an AN is active or passive could be determined either statically during network configuration or with a dynamic protocol. In between aggregation nodes, the responses could flow as in FIG. 1 (separate flows), but overall scalability can still be ensured.
- Two examples of this are shown in FIG. 8. FIG. 8(a) shows intermediate nodes that do not aggregate responses and just forward them on up the tree. Those are passive aggregation nodes. Note that although the response bandwidth and network overhead (i.e., the number of connections and packets used) can increase immediately up the tree from these nodes, as soon as an active aggregation node is reached, those factors scale back again. FIG. 8(b) shows a similar arrangement, except that the non-aggregating nodes (passive aggregation nodes) do concatenate responses before forwarding them up the tree. This reduces some of the network processing as described in the “Multicast Queries and Concatenated Responses” section above and illustrated in FIG. 7.
- In the above examples, only one broadcast center that issues queries and receives responses is shown. However, in other embodiments, multiple broadcast centers can be used to issue different queries (or even identical queries, for robustness) to different subsets of the device nodes (or all of them).
- Distributing Queries
- This section details example embodiments of distribution mechanisms that can be applied to deliver queries from query nodes to device nodes. All of the examples in this section assume that the queries will be distributed using multicast for efficient delivery; but it should be apparent after review of this disclosure to apply these techniques if unicast is to be used for query distribution, as that case is much simpler.
- Preferably, queries are uniquely identifiable where more than one query is flowing through the network (a likely occurrence), so that a device node can associate particular responses with particular queries and so that an aggregation node can distinguish among responses. In the following examples, a unique query identifier is assumed to be included with query messages sent from a query originator.
- The identifier allows aggregation nodes to know which programmable aggregation operation(s) should be performed on the responses flowing into them and the identifier can be used for “controlling” the query. For example, the “query program” describing the information to be queried and how it should be combined need only be distributed to the device nodes once, even if it is to be executed multiple times.
- Queries can be sent dynamically or they can be statically configured and stored in each device node. In either case, once a device node has seen a query, it only has to store it at the device node (in a table, for example) in such a manner that it may be referenced it by its identifier (for example, an N-bit number). One way to reliably propagate and “install” queries at the device nodes is to distribute the queries using the MINT protocol described in the MINT application (referenced above). The MINT protocol allows key-value pairs of information to be associated with or “published” to an Application-Level Multicast Group and reliably distributed to all members of that group. Queries (and query control messages) can be disseminated using the MINT protocol.
- Once the queries are installed, instructions can then be distributed to device nodes telling them to start or stop running the query, to change the frequency of response, to modify parameters of the query itself, etc., simply by referring to the query identifier rather than by including the entire query structure (which might be a series of instructions, such as SQL instructions, or query instructions is a language specific to this application). In a particular implementation, the query structure or instructions are unique among queries so that query structure/instructions (or a hash thereof) can use used as the unique identifier. In that implementation, the responses would include the query structure, instructions or hash to identify the query to which the response is responsive.
- Establishing/Configuring Query Distribution Trees
- The section describes how query multicast distribution trees might be configured and established, the closely related issue of deciding what the delivery scope of the queries should be, and possible distribution mechanisms for delivering the queries to their destinations via their distribution trees.
- Establishing a Distribution Tree
- In setting up a distribution tree for queries and their responses, the destination of the queries is assumed to be known. In some cases, it is known exactly which edge devices and/or network nodes are to be queried. In other cases, explicit knowledge is not known, or strictly necessary, but instead just a class of device nodes is known (e.g., the class of all edge devices receiving program N from Content Source X). It is also assumed that there is some path for information flow from a source to the device nodes (which is not necessarily the same source as the query node). Returning again to the example application of a CDN, a broadcast center might be the at the query node and act as the query originator sending a query to all device nodes associated with edge devices pulling down a certain program stream. In this case, the edge devices are not explicitly known, but a mechanism exists for reaching the nodes: the multicast group rooted at the content source injecting the program into the CDN.
- The process described below for establishing a query and response distribution tree is in two parts. The first part is to establish a multicast distribution tree for sending the queries. The queries flow from the root of this tree down towards its leaves (device nodes). Note that device nodes can be located in the interior of the tree as well as at the leaves. The second part is to establish a reverse-path collection tree upon which the responses will flow up from the device nodes towards a collection node. Aggregation nodes will be located at interior nodes in this tree (i.e., nonleaf nodes), so that responses flowing into an aggregation node from its child nodes (which could comprise one or more device nodes and/or other ANs) are aggregated into a response sent upwards to the parent of the AN (either another AN or the collection node at the root of this tree). Note that both the query distribution and the response aggregation trees can be the same, but they need not be. Also, it is possible to use still another tree to distribute the instructions necessary to construct the query distribution and/or collection trees.
- A few example initialization steps that can be used for different network configurations are described below, once again using a CDN example wherein a broadcast center desires to send one or more queries to all edge devices receiving a program from a content source.
- When the content source is located at the query node, the existing content distribution tree might be used for both the query distribution and response collection, as has already demonstrated by FIGS. 5 and 7. Alternatively, separate query distribution and response collection trees could be constructed, if desired, using techniques described below.
- When the content source and the query node are in separate parts of the network, there are many possible techniques that can be used. The broadcast center and content source might use a point-to-point unicast connection to exchange query and response data. For example, FIG. 9(a) shows content distribution and FIG. 9(b) shows BC 110 unicasting a query to a
content source 102, which then distributes the query to the edge devices. FIG. 9(c) shows collecting the responses atcontent source 102 and then delivering the final response back to theBC 110 via unicast. Thus, the existing content distribution tree is used for both the queries and responses. This technique allows the possibility of “piggybacking” queries onto program data that is already flowing to edge devices. - Another approach is to use separate distribution trees, as shown in FIG. 10. The tree used to distribute program data and queries (information which flows “down” towards the edge devices) can be different than the response collection tree used to collect and aggregate the query responses (which flow “up” from the edge devices towards the broadcast center). Additionally, the query distribution tree can also be different from the program data distribution tree, even though both trees may reach the same set of edge devices. Finally, the query distribution and response aggregation trees may be the same, but different from the program data distribution tree. FIG. 10 shows one framework that can allow for these different tree possibilities.
- For example, consider a broadcast center that wants to send a query to the distribution tree of program A, rooted at
content source CS 1. We refer to this tree as multicast group (A, CS 1). The broadcast center sends CS 1 a message to be distributed to program A's recipients instructing them to join a new query distribution group rooted at the broadcast center group, called group (A, broadcast center) (step 1, FIG. 10(a)).Content source CS 1 multicasts this join instruction to group (A, CS 1) (step 2, FIG. 10(a)). Upon receiving the instruction, group (A, CS 1)'s members send join messages up to the broadcast center, constructing the query distribution tree (step 3, FIG. 10(b)). Once the tree is established, the broadcast center multicasts queries on the new multicast group (step 4, FIG. 10(c)). Query responses flow up the reverse query distribution tree towards its root, the broadcast center (step 5, FIG. 10(d)). Aggregation nodes located along the tree can collect responses from below and generate aggregated responses sent up towards the broadcast center. - The framework illustrated in FIG. 10 can handle many different cases, such as:
- 1) Broadcasting all queries to all devices: If there is a single broadcast center, that broadcast center might simply broadcast any queries to all nodes and devices in the CDN, which would have joined a well-known “broadcast” distribution tree rooted at the broadcast center when they were initially configured. Queries could still contain information restricting what nodes or devices should respond to it. In this case, steps1-3 of the above process are unnecessary.
- 2) Easily “derived” query multicast groups: If a query group corresponding to a program can be derived based on the program group and a well known formula (for example, group (X,CS N) would have a query group (N_X, broadcast center)), then all members could automatically join the query group after joining the program group. This eliminates
steps Step 3 is performed whenever an edge device or node joins a program group. - 3) Pre-configured query multicast groups: If every program group either has a statically configured query group that is told to all recipients when they first join the program group,
step 1 is unnecessary. Steps 2-3 are performed whenever an edge device or node joins a program group. - 4) Dynamic query group generation (use all of the steps to dynamically generate a query distribution tree): In this approach, if the CDN allows any member of a program tree to send to the tree,
step 1 could be replaced by the broadcast center joining the program tree, and the join instruction ofstep 2 would then be sent directly by the broadcast center, rather thanCS 1. - Delivery Scope
- This section gives some examples of different delivery scopes that may be used with queries, using a CDN as the data network being queried. Where the delivery scope is all devices in the entire CDN, a query can be done using a well-known “broadcast” multicast channel that every device joins upon startup. Where the delivery scope is a dynamically configured subset of nodes of the CDN, such as the edge devices belonging to a specific content program distribution tree, another approach is needed. Because these devices may dynamically join and leave the program distribution group, the broadcast center does not know exactly, prior to sending the query, the query's intended recipients. However, the query can still reach all of the intended recipients if the query is broadcast on the program's distribution tree. This dynamic set of nodes could also include (or might consist solely of) the internal nodes belonging to a specific program tree (for example, the routing devices used to distribute the program). The programmable query could be sent along the program distribution tree and specify whether edge devices or internal nodes (or both) should act as device nodes.
- Where the delivery scope is an arbitrary static subset of CDN nodes, the CDN might be configured with information about the domain (or domains) that each node belongs to. Domain-specific distribution trees can either be statically constructed during startup of the CDN (as each device in the CDN is initialized it joins a specified query distribution group(s) corresponding to its domain(s)), or they can be dynamically constructed at a later time, as necessary, by flooding a control information request (e.g., MINTs) to the entire CDN (using the well-known broadcast channel) instructing nodes matching a domain to join a domain information tree rooted at the broadcast center.
- Depending on how the queries are delivered, queries may pass through some possible device nodes that are not supposed to respond to the query, but instead simply forward it on to other downstream device nodes. The programmable query may specify which devices are supposed to respond to it. At a high level, the query could simply specify that the query be executed on all network nodes that it passes through, or all edge devices that it reaches, or both. The query could also specify specific subsets of these.
- Distribution Mechanisms
- The queries and responses are delivered by the data network. There are many possible ways to do this. One would be to use a multicast distribution system for delivering the queries, and use a reverse-path multicast tree for delivering the responses. IP Multicast could be used if the routers are programmed with the ability to execute queries and run aggregation operations.
- Application-Level Multicast (ALM) could also be used to perform the same functions, with the added advantage that more powerful and flexible query and aggregation operations can be implemented. For the reverse-path aggregation, the multicast routers need to know how to route “upwards” from the leaves of the tree towards the root. Alternatively, unicast could be used between devices in the query and/or response distribution trees if these device nodes and aggregation nodes are manually configured to route towards the next appropriate “hop” in the distribution tree.
- Aggregation
- Query responses and their aggregates can be categorized as either being single-dimensional (scalar) or multi-dimensional (vector). Scalar responses are those in which a device node returns a single value and which ANs can aggregate into another single value. For example, three different device nodes responding to the query “How many clients are watching program101?” might produce scalar responses of 5, 3 and 0. An AN receiving these responses could then sum them together to form the scalar aggregate response of 8.
- Vector responses can have more than one dimension. Vectors could be “distributions” in which the answers fall into a fixed and defined set of buckets or bins. For example, queries such as “How many servers have loads in the ranges [0-10%, 10-20%, . . . , 90-100%]?” or “How many clients are viewing: [
Program 1,Program 3, Program 7]?” would have a fixed set of bins. This is illustrated by FIG. 11 for a CDN example, which shows all responses (including the aggregate) having three dimensions (bins), even when the contents are zero. The responses are aggregated by summing the responses within each bin. - Vector responses can also be of variable length, such as the answers to the query “How many clients are watching all channels?” and an aggregation instruction “Return the results by channel” (the variable being the number of channels). This type of vector response is shown in FIG. 12 for a CDN. In the example, the responses comprise keys (the program channel, i.e. “A” or “C”) and corresponding values. The size of the responses can increase as they flow up the aggregation response tree, as shown by FIG. 12. In this example, the query returns an amount of data upper bounded by the total number of channels being injected (which bounds are presumably known to the broadcast center).
- Aggregation Operators
- Because the aggregators are programmable, a myriad of possible aggregation techniques exists. Some of the possible aggregation operators include:
- Addition: This operator sums the responses flowing into the AN to form the response that flows upward. This is straightforward for scalar responses. Addition may also be used to combine vector distributions (of fixed or variable length) together by performing scalar addition bin-by-bin. This is illustrated in FIGS.11-12.
- Concatenation: With concatenation, the results are simply combined or appended together. As such, the amount of data returned to the broadcast center increases linearly with the number of device nodes responding to the query. This may cause scaling issues, but a concatenation operation may still be acceptable to the data network provider, especially if the network has been appropriately provisioned with the bandwidth and processing power to handle the queries. An example use of concatenation would be to aggregate the responses to the query “What are the IP addressees of all
clients watching Program 3?”. Since the response collection system wishes to know all of the unique responses, all responses are simply combined together by the ANs and forwarded on. - Logical: An example is a query “are any servers experiencing greater than 90% load?”; the aggregation operator would logically OR the true/false responses.
- Sort: This operator can be combined with concatenation to return a sorted list of results (using a programmable sort operator). The computational processing required to sort all of the responses is effectively distributed throughout the collection nodes and aggregation nodes by using a divide-and-conquer-style algorithm such as the “quicksort” algorithm.
- Minimum: The aggregate response is the minimum value of all of the responses that flow into the aggregator.
- Maximum: The aggregate response is the maximum value of all of the responses that flow into the aggregator.
- Programmable filters could be used to exclude certain responses or aggregate them using AN-specific knowledge. For example, a query may ask “What is the distribution of computational load of the edge devices?” and specify that the results be aggregated by Internet Service Provider (ISP). The edge devices may not be explicitly programmed with knowledge of who their ISP is, and thus could leave the “backbone provider” field blank, or alternatively list their IP addresses instead. These responses would be concatenated together until they reach an AN at the edge of an ISP network. These edge ANs could be programmed with a full mapping of ISP to IP addresses (or simply know that any responses that flow into the edge must have originated from within the specific ISP), and hence they could aggregate the concatenated responses into groupings by ISP. As another example, the query might ask “What is the distribution of load of the edge devices belonging to ISP XYZ?”, but the query may again be distributed to edge devices in other ISPs as well. Again assuming that these devices are ignorant of their ISP, they would all run the query and return a response as before. But this time the ISP-aware ANs would filter out or drop any responses originating from machines in ISPs other than XYZ.
- Distributing the Aggregation Operators
- Aggregation operators can be distributed using any of the techniques for distributing queries described above. For example, MINT could be used to distribute and install operators and ANs in an ALM network. And just like queries, each aggregation operation should have some kind of unique identifier. The primary purpose of this identifier is to allow the aggregation operation to be associated with a query and its responses, but it can also be used for other purposes such as referencing installed aggregation operators in control information. One identifier that can be used is simply the identifier of the query to be aggregated (which could be the query itself). Another identifier is the aggregation operator itself, which could be distributed by the query originator to each device node and then included in all responses flowing from the device nodes to the ANs. In general, the aggregation operator identifier need not be the same, because a query may have multiple different aggregation operators performed on its responses, or vice versa, where the same aggregation operator is used on the responses of multiple different programmable queries.
- Query and Response Frequency
- One feature of the programmable nature of the queries and aggregators (where programmable queries and aggregators are used) is that the frequency of response can be specified as well. There are many examples of situations where a query should be performed multiple times. For example, a query delivered to a CDN asking, “How many viewers are watching program101?” would result in a viewer count or “ratings snapshot” at the particular time the query was issued, if the device nodes only responded to it once. However, if the query specified that the device nodes respond every 5 seconds, the queryor then can not only get a near-real-time viewership ratings snapshot, but can also see how the ratings evolve over the life of the program. The ratings are “near-real-time” not only because there may be some network and processing delay to transmit responses from device nodes through ANs and to the collection node, but also because the programmable aggregation operator may introduce some delay in order to save bandwidth.
- Because the query frequency is a fully programmable aspect of the query, many possible choices of response frequency exist, such as single response (the device nodes respond only once to the query), finite persistence, indefinite persistence and threshold responses.
- Finite persistence is a generalization of the single response, wherein the query may instruct device nodes to execute the query multiple times. The query might define the period between responses and persist until a fixed number of responses have been generated or a certain time has been reached. This could be used to view a “window” of data at a particular point in time.
- An indefinite persistence query specifies that the device nodes should execute the query periodically, with no end time or maximum number of responses specified. The period T of the query is programmable. Additionally, the device nodes might execute the query every T plus or minus X time units (where X is random or pseudorandom), such that the inter-response interval is not always exactly T, but averages out to T over time. This randomization can be used to avoid synchronization of all responses (i.e., avoid having all responses from flowing to an AN or a collection node at exactly the same time). Similar phenomena observed in the periodic exchange of routing messages in the Internet are described in Floyd, S. and Jacobson, V., “The Synchronization of Periodic Routing Messages”, IEEE/ACM Transactions on Networking, V.2 N.2, p. 122-36 (April 1994).
- Threshold responses are persistent queries (either finite or indefinite) that get run at the device nodes and, instead of being run at a fixed period, are only run when the response changes by more than a programmable threshold amount. Additionally, the query may specify that device nodes should also respond at a low frequency even if their response has not exceeded the threshold, to provide robustness against packet loss and ensure that the aggregated response reflects the state of the devices within a recent time interval.
- Just as a query's response generation at the device nodes may be specified, the frequency at which an aggregated response is generated and propagated up towards the collection node may also be specified. Some possible frequencies include unlimited, frequency-limited, rate-limited, programmable rate and policy-based.
- With no limit frequency, an aggregator generates a new aggregated response whenever it receives a new response from any of its children. This method does not scale well, as each response generated by a device node results in a response being propagated all the way up the aggregation distribution tree to the collection node root. However, this may be more scalable if used with thresholded queries.
- With frequency-limited responses, an aggregator may be programmed to generate an aggregate response every T time units. Randomization and/or threshold techniques (as described above) can also be applied. If the aggregation period is the same as a periodic query, the result is that, on average, an AN should receive a new query update (or aggregated response from another AN) from each of its children between each aggregate response generated by the AN.
- With rate-limited responses, a token-bucket or other rate-controlling mechanism might be used to ensure that the bandwidth of the aggregated responses does not exceed a defined limit. This may be useful with the concatenation aggregation operator or other aggregation operators that may result in the size of the aggregate response being larger than the size of any response flowing into the AN.
- With programmable rate responses, if the query and response aggregation trees are identical, an AN may have the ability to specify the rate at which it wishes to receive responses from its children by modifying the programmable query/aggregator as it flows down the tree through the node the AN is attached to. An AN can control the total rate of responses flowing into it using such a method. For example, an AN may have 5 children, be running 3 queries, and wish to receive no more than 30 responses/second. Before forwarding each query and aggregation information to its children, it may modify them to specify that each child should send a response every 0.5 seconds.
- With policy-based response frequencies, the query/response frequency can also be determined by customer-specific bandwidth policies. These can be influenced by attributes in the query itself, as well as bandwidth-sharing policies defined by the CDN (for example, as taught by Welch. For example, a CDN may specify that a customer be allowed to run queries at a “typical rate” comprising a maximum bandwidth and/or update frequency that may be used. However, the actual rate allocated to that customer's queries might be limited by available network bandwidth, in which case a bandwidth-sharing policy is used to determine what actual rate to give to the queries.
- FIGS.13-14 illustrate a basic query network handling system used with a generic data network. In FIG. 13, a cloud represents the equipment that makes up the network. A
query originator 901 and aresponse collection system 902 are shown in FIG. 13, coupled toquery node 903 andcollection node 904, respectively.Query originator 901 distributes aquery 905 andresponse collection system 902 receives the query response data. Examples of query originators and response collection systems include a broadcast center running in a CDN and a “Network Operation Center” (NOC) in a general data network.Query originator 901 deliversquery 905 via the data network to device nodes 906(1)-(3). The programmable queries are received at each of these device nodes and the responses are returned back through the data network toresponse collection system 902. The device nodes might also provide a naming system to map well known virtual names (that may be used in programmable queries) onto corresponding physical, equipment-specific names. This allows different, heterogeneous equipment to respond to the same query. Thedevice nodes 906 might be included as part of the devices being queried, or could be a separate components that are able to obtain responses to the query about the devices. - FIG. 14 shows the query responses first shown in FIG. 13 flowing through two
aggregation nodes 920. Responses R1 and R2 flow through aggregation node (AN) 920(1), where they are aggregated into response R4. This response, along with response R3, flows through AN 920(2), and finally the resulting aggregated response R5 is the only one delivered tocollection node 904. Depending on the aggregation operation, this can result in network bandwidth savings. For example, the programmable aggregation operation for a query in a CDN asking “How many viewers are watching program 700?” could sum the responses together to form the aggregate response, and so N responses each of data size X flowing into an AN result in a single aggregate response of size X. The maximum amount of response data flowing towards any aggregation node or collection node in the network is hence bounded not by the number of device nodes, but instead by the maximum fanout. - A novel query handling system and several novel components have now been described. Alternatives and substitutions will now be apparent to persons of skill in the art. Accordingly, it is not intended to limit the invention except as provided by the appended claims.
Claims (17)
Priority Applications (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US09/900,704 US6826564B2 (en) | 2000-07-10 | 2001-07-06 | Scalable and programmable query distribution and collection in a network of queryable devices |
PCT/US2001/021938 WO2002005141A2 (en) | 2000-07-10 | 2001-07-10 | Network management arrangement with query aggregation |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US21725000P | 2000-07-10 | 2000-07-10 | |
US09/900,704 US6826564B2 (en) | 2000-07-10 | 2001-07-06 | Scalable and programmable query distribution and collection in a network of queryable devices |
Publications (2)
Publication Number | Publication Date |
---|---|
US20020073086A1 true US20020073086A1 (en) | 2002-06-13 |
US6826564B2 US6826564B2 (en) | 2004-11-30 |
Family
ID=26911764
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US09/900,704 Expired - Lifetime US6826564B2 (en) | 2000-07-10 | 2001-07-06 | Scalable and programmable query distribution and collection in a network of queryable devices |
Country Status (2)
Country | Link |
---|---|
US (1) | US6826564B2 (en) |
WO (1) | WO2002005141A2 (en) |
Cited By (65)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20020112069A1 (en) * | 2000-10-26 | 2002-08-15 | Sim Siew Yong | Method and apparatus for generating a large payload file |
US20020133491A1 (en) * | 2000-10-26 | 2002-09-19 | Prismedia Networks, Inc. | Method and system for managing distributed content and related metadata |
US20030135509A1 (en) * | 2002-01-11 | 2003-07-17 | Davis Andrew Thomas | Edge server java application framework having application server instance resource monitoring and management |
WO2004012093A1 (en) * | 2002-07-31 | 2004-02-05 | International Business Machines Corporation | Communicating state information in a network |
US20040170188A1 (en) * | 2001-09-07 | 2004-09-02 | Toni Paila | Implementing multicasting |
US6826564B2 (en) * | 2000-07-10 | 2004-11-30 | Fastforward Networks | Scalable and programmable query distribution and collection in a network of queryable devices |
US20050044214A1 (en) * | 2003-07-14 | 2005-02-24 | Schwertfuehrer Gerit Edler Von | Method for monitoring distributed software |
US20050097091A1 (en) * | 2003-09-06 | 2005-05-05 | Oracle International Corporation | SQL tuning base |
US20050190796A1 (en) * | 2003-09-19 | 2005-09-01 | Masaaki Date | Method of avoiding synchronization between communicating nodes |
US6973269B1 (en) * | 2001-10-18 | 2005-12-06 | At&T Corp. | Metropolitan networks based on fiber and free space access distribution system |
US6999961B2 (en) * | 1999-04-22 | 2006-02-14 | Mark Hall | Method of aggregating and distributing informal and formal knowledge using software agents |
US7076553B2 (en) | 2000-10-26 | 2006-07-11 | Intel Corporation | Method and apparatus for real-time parallel delivery of segments of a large payload file |
WO2007079280A2 (en) * | 2005-11-08 | 2007-07-12 | Nortel Networks Limited | Selective multicasting of sensor data for reliable delivery |
US20070274235A1 (en) * | 2006-05-25 | 2007-11-29 | Cisco Technology, Inc. | Techniques for reliable switchover to a date multicast distribution tree (MDT) |
US20080294646A1 (en) * | 2007-05-24 | 2008-11-27 | Via Technologies, Inc. | Data distributing and accessing method and system |
US20100235432A1 (en) * | 2006-08-21 | 2010-09-16 | Telefonaktiebolaget L M Ericsson | Distributed Server Network for Providing Triple and Play Services to End Users |
US20120054172A1 (en) * | 2010-08-31 | 2012-03-01 | International Business Machines Corporation | Method and system for transmitting a query in a wireless network |
US20130058333A1 (en) * | 2011-09-02 | 2013-03-07 | Ilt Innovations Ab | Method For Handling Requests In A Storage System And A Storage Node For A Storage System |
US20140297676A1 (en) * | 2013-04-01 | 2014-10-02 | International Business Machines Corporation | Rdf graphs made of rdf query language queries |
US8903973B1 (en) | 2008-11-10 | 2014-12-02 | Tanium Inc. | Parallel distributed network management |
US8904039B1 (en) * | 2008-11-10 | 2014-12-02 | Tanium Inc. | Large-scale network querying and reporting |
US8972566B1 (en) | 2008-11-10 | 2015-03-03 | Tanium Inc. | Distributed statistical detection of network problems and causes |
US9059961B2 (en) | 2012-12-21 | 2015-06-16 | Tanium Inc. | Creation and maintenance of self-organizing communication orbits in distributed networks |
US20150280931A1 (en) * | 2013-01-07 | 2015-10-01 | Mitsubishi Electric Corporation | Data distribution system, root wireless device, and wireless device |
US9183279B2 (en) * | 2011-09-22 | 2015-11-10 | International Business Machines Corporation | Semantic questioning mechanism to enable analysis of information architectures |
US9191411B2 (en) | 2013-03-15 | 2015-11-17 | Zerofox, Inc. | Protecting against suspect social entities |
US9305012B2 (en) | 2011-09-02 | 2016-04-05 | Compuverde Ab | Method for data maintenance |
US9329955B2 (en) | 2008-10-24 | 2016-05-03 | Compuverde Ab | System and method for detecting problematic data storage nodes |
US9503524B2 (en) | 2010-04-23 | 2016-11-22 | Compuverde Ab | Distributed data storage |
US9544325B2 (en) | 2014-12-11 | 2017-01-10 | Zerofox, Inc. | Social network security monitoring |
US9667738B2 (en) | 2014-03-24 | 2017-05-30 | Tanium Inc. | Local data caching for data transfers on a network of computational devices |
US9674214B2 (en) * | 2013-03-15 | 2017-06-06 | Zerofox, Inc. | Social network profile data removal |
US9674212B2 (en) | 2013-03-15 | 2017-06-06 | Zerofox, Inc. | Social network data removal |
US9769275B2 (en) | 2014-03-24 | 2017-09-19 | Tanium Inc. | Data caching and distribution in a local network |
US9769037B2 (en) | 2013-11-27 | 2017-09-19 | Tanium Inc. | Fast detection and remediation of unmanaged assets |
US9910752B2 (en) | 2015-04-24 | 2018-03-06 | Tanium Inc. | Reliable map-reduce communications in a decentralized, self-organizing communication orbit of a distributed network |
US20180260401A1 (en) * | 2017-03-08 | 2018-09-13 | Netradyne Inc | Distributed video search with edge computing |
US10095864B2 (en) | 2016-03-08 | 2018-10-09 | Tanium Inc. | System and method for performing event inquiries in a network |
US10498744B2 (en) | 2016-03-08 | 2019-12-03 | Tanium Inc. | Integrity monitoring in a local network |
US10516567B2 (en) | 2015-07-10 | 2019-12-24 | Zerofox, Inc. | Identification of vulnerability to social phishing |
US10560663B2 (en) * | 2007-12-31 | 2020-02-11 | Alcatel Lucent | Method and apparatus for distributing content |
US10579615B2 (en) | 2011-09-02 | 2020-03-03 | Compuverde Ab | Method for data retrieval from a distributed data storage system |
US10824729B2 (en) | 2017-07-14 | 2020-11-03 | Tanium Inc. | Compliance management in a local network |
US10841365B2 (en) | 2018-07-18 | 2020-11-17 | Tanium Inc. | Mapping application dependencies in a computer network |
US10868824B2 (en) | 2017-07-31 | 2020-12-15 | Zerofox, Inc. | Organizational social threat reporting |
US10873645B2 (en) | 2014-03-24 | 2020-12-22 | Tanium Inc. | Software application updating in a local network |
US10929345B2 (en) | 2016-03-08 | 2021-02-23 | Tanium Inc. | System and method of performing similarity search queries in a network |
US10970333B2 (en) | 2016-08-08 | 2021-04-06 | NetraDyne, Inc. | Distributed video storage and search with edge computing |
US11134097B2 (en) | 2017-10-23 | 2021-09-28 | Zerofox, Inc. | Automated social account removal |
US11153383B2 (en) | 2016-03-08 | 2021-10-19 | Tanium Inc. | Distributed data analysis for streaming data sources |
US11165801B2 (en) | 2017-08-15 | 2021-11-02 | Zerofox, Inc. | Social threat correlation |
US11256812B2 (en) | 2017-01-31 | 2022-02-22 | Zerofox, Inc. | End user social network protection portal |
US20220121681A1 (en) * | 2014-02-19 | 2022-04-21 | Snowflake Inc. | Resource management systems and methods |
US11343355B1 (en) | 2018-07-18 | 2022-05-24 | Tanium Inc. | Automated mapping of multi-tier applications in a distributed system |
US11372938B1 (en) | 2016-03-08 | 2022-06-28 | Tanium Inc. | System and method for performing search requests in a network |
US11394722B2 (en) | 2017-04-04 | 2022-07-19 | Zerofox, Inc. | Social media rule engine |
US11403400B2 (en) | 2017-08-31 | 2022-08-02 | Zerofox, Inc. | Troll account detection |
US11418527B2 (en) | 2017-08-22 | 2022-08-16 | ZeroFOX, Inc | Malicious social media account identification |
US11461208B1 (en) | 2015-04-24 | 2022-10-04 | Tanium Inc. | Reliable map-reduce communications in a decentralized, self-organizing communication orbit of a distributed network |
US11563764B1 (en) | 2020-08-24 | 2023-01-24 | Tanium Inc. | Risk scoring based on compliance verification test results in a local network |
US11609835B1 (en) | 2016-03-08 | 2023-03-21 | Tanium Inc. | Evaluating machine and process performance in distributed system |
US20230102209A1 (en) * | 2021-05-11 | 2023-03-30 | Strong Force Vcn Portfolio 2019, Llc | Edge-Distributed Query Processing in Value Chain Networks |
US11711810B1 (en) | 2012-12-21 | 2023-07-25 | Tanium Inc. | System, security and network management using self-organizing communication orbits in distributed networks |
US11831670B1 (en) | 2019-11-18 | 2023-11-28 | Tanium Inc. | System and method for prioritizing distributed system risk remediations |
US11886229B1 (en) | 2016-03-08 | 2024-01-30 | Tanium Inc. | System and method for generating a global dictionary and performing similarity search queries in a network |
Families Citing this family (20)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US7143139B2 (en) * | 2002-03-27 | 2006-11-28 | International Business Machines Corporation | Broadcast tiers in decentralized networks |
US7069318B2 (en) * | 2002-03-27 | 2006-06-27 | International Business Machines Corporation | Content tracking in transient network communities |
US7039701B2 (en) * | 2002-03-27 | 2006-05-02 | International Business Machines Corporation | Providing management functions in decentralized networks |
US7181536B2 (en) * | 2002-03-27 | 2007-02-20 | International Business Machines Corporation | Interminable peer relationships in transient communities |
US7251689B2 (en) * | 2002-03-27 | 2007-07-31 | International Business Machines Corporation | Managing storage resources in decentralized networks |
US7177929B2 (en) * | 2002-03-27 | 2007-02-13 | International Business Machines Corporation | Persisting node reputations in transient network communities |
US7606167B1 (en) * | 2002-04-05 | 2009-10-20 | Cisco Technology, Inc. | Apparatus and method for defining a static fibre channel fabric |
US7272122B2 (en) * | 2002-04-26 | 2007-09-18 | Nokia Corporation | Relocation of application-specific functionality during seamless network layer-level handoffs |
US7653059B1 (en) * | 2002-12-20 | 2010-01-26 | Symantec Operating Corporation | Communication sessions for a computer network |
US7644365B2 (en) * | 2003-09-12 | 2010-01-05 | Cisco Technology, Inc. | Method and system for displaying network security incidents |
US7408938B1 (en) * | 2003-10-15 | 2008-08-05 | Microsoft Coporation | System and method for efficient broadcast of information over a network |
US8200789B2 (en) * | 2004-10-12 | 2012-06-12 | International Business Machines Corporation | Method, system and program product for automated topology formation in dynamic distributed environments |
US20060120384A1 (en) * | 2004-12-08 | 2006-06-08 | International Business Machines Corporation | Method and system for information gathering and aggregation in dynamic distributed environments |
US20060161520A1 (en) * | 2005-01-14 | 2006-07-20 | Microsoft Corporation | System and method for generating alternative search terms |
US7710983B2 (en) * | 2005-04-21 | 2010-05-04 | Cisco Technology, Inc. | Method and apparatus for determining information associated with a particular multicast channel in a multicast network |
US7882262B2 (en) * | 2005-08-18 | 2011-02-01 | Cisco Technology, Inc. | Method and system for inline top N query computation |
DE102007027915B3 (en) * | 2007-06-18 | 2009-04-02 | Siemens Ag | A method, computer program product, and system for referencing patient-related information in a distributed medical system |
US8176200B2 (en) * | 2008-10-24 | 2012-05-08 | Microsoft Corporation | Distributed aggregation on an overlay network |
FR2941831B1 (en) | 2009-02-05 | 2011-03-04 | Ipanema Technologies | METHOD FOR MANAGING EXCHANGES OF DATA STREAMS IN AN AUTONOMOUS TELECOMMUNICATION NETWORK |
US9672274B1 (en) | 2012-06-28 | 2017-06-06 | Amazon Technologies, Inc. | Scalable message aggregation |
Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6385604B1 (en) * | 1999-08-04 | 2002-05-07 | Hyperroll, Israel Limited | Relational database management system having integrated non-relational multi-dimensional data store of aggregated data elements |
US6415323B1 (en) * | 1999-09-03 | 2002-07-02 | Fastforward Networks | Proximity-based redirection system for robust and scalable service-node location in an internetwork |
US6553404B2 (en) * | 1997-08-08 | 2003-04-22 | Prn Corporation | Digital system |
US6601062B1 (en) * | 2000-06-27 | 2003-07-29 | Ncr Corporation | Active caching for multi-dimensional data sets in relational database management system |
Family Cites Families (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
DE4133385A1 (en) * | 1991-10-09 | 1993-04-15 | Philips Patentverwaltung | HIERARCHICAL NETWORK MANAGEMENT SYSTEM |
US5872931A (en) * | 1996-08-13 | 1999-02-16 | Veritas Software, Corp. | Management agent automatically executes corrective scripts in accordance with occurrences of specified events regardless of conditions of management interface and management engine |
US6085243A (en) * | 1996-12-13 | 2000-07-04 | 3Com Corporation | Distributed remote management (dRMON) for networks |
US6826564B2 (en) * | 2000-07-10 | 2004-11-30 | Fastforward Networks | Scalable and programmable query distribution and collection in a network of queryable devices |
-
2001
- 2001-07-06 US US09/900,704 patent/US6826564B2/en not_active Expired - Lifetime
- 2001-07-10 WO PCT/US2001/021938 patent/WO2002005141A2/en active Application Filing
Patent Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6553404B2 (en) * | 1997-08-08 | 2003-04-22 | Prn Corporation | Digital system |
US6385604B1 (en) * | 1999-08-04 | 2002-05-07 | Hyperroll, Israel Limited | Relational database management system having integrated non-relational multi-dimensional data store of aggregated data elements |
US6415323B1 (en) * | 1999-09-03 | 2002-07-02 | Fastforward Networks | Proximity-based redirection system for robust and scalable service-node location in an internetwork |
US6601062B1 (en) * | 2000-06-27 | 2003-07-29 | Ncr Corporation | Active caching for multi-dimensional data sets in relational database management system |
Cited By (137)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6999961B2 (en) * | 1999-04-22 | 2006-02-14 | Mark Hall | Method of aggregating and distributing informal and formal knowledge using software agents |
US6826564B2 (en) * | 2000-07-10 | 2004-11-30 | Fastforward Networks | Scalable and programmable query distribution and collection in a network of queryable devices |
US7076553B2 (en) | 2000-10-26 | 2006-07-11 | Intel Corporation | Method and apparatus for real-time parallel delivery of segments of a large payload file |
US20050198238A1 (en) * | 2000-10-26 | 2005-09-08 | Sim Siew Y. | Method and apparatus for initializing a new node in a network |
US6970939B2 (en) * | 2000-10-26 | 2005-11-29 | Intel Corporation | Method and apparatus for large payload distribution in a network |
US7272613B2 (en) | 2000-10-26 | 2007-09-18 | Intel Corporation | Method and system for managing distributed content and related metadata |
US20020133491A1 (en) * | 2000-10-26 | 2002-09-19 | Prismedia Networks, Inc. | Method and system for managing distributed content and related metadata |
US20030026254A1 (en) * | 2000-10-26 | 2003-02-06 | Sim Siew Yong | Method and apparatus for large payload distribution in a network |
US20020112069A1 (en) * | 2000-10-26 | 2002-08-15 | Sim Siew Yong | Method and apparatus for generating a large payload file |
US7181523B2 (en) | 2000-10-26 | 2007-02-20 | Intel Corporation | Method and apparatus for managing a plurality of servers in a content delivery network |
US7177270B2 (en) | 2000-10-26 | 2007-02-13 | Intel Corporation | Method and apparatus for minimizing network congestion during large payload delivery |
US7165095B2 (en) | 2000-10-26 | 2007-01-16 | Intel Corporation | Method and apparatus for distributing large payload file to a plurality of storage devices in a network |
US20030031176A1 (en) * | 2000-10-26 | 2003-02-13 | Sim Siew Yong | Method and apparatus for distributing large payload file to a plurality of storage devices in a network |
US7058014B2 (en) | 2000-10-26 | 2006-06-06 | Intel Corporation | Method and apparatus for generating a large payload file |
US7047287B2 (en) | 2000-10-26 | 2006-05-16 | Intel Corporation | Method and apparatus for automatically adapting a node in a network |
US20040170188A1 (en) * | 2001-09-07 | 2004-09-02 | Toni Paila | Implementing multicasting |
US8218545B2 (en) * | 2001-09-07 | 2012-07-10 | Nokia Siemens Networks Oy | Implementing multicasting |
US6973269B1 (en) * | 2001-10-18 | 2005-12-06 | At&T Corp. | Metropolitan networks based on fiber and free space access distribution system |
US20030135509A1 (en) * | 2002-01-11 | 2003-07-17 | Davis Andrew Thomas | Edge server java application framework having application server instance resource monitoring and management |
CN1316394C (en) * | 2002-07-31 | 2007-05-16 | 国际商业机器公司 | Communicating state information in a network |
WO2004012093A1 (en) * | 2002-07-31 | 2004-02-05 | International Business Machines Corporation | Communicating state information in a network |
US7801963B2 (en) * | 2003-07-14 | 2010-09-21 | Robert Bosch Gmbh | Method for monitoring distributed software |
US20050044214A1 (en) * | 2003-07-14 | 2005-02-24 | Schwertfuehrer Gerit Edler Von | Method for monitoring distributed software |
US20050138015A1 (en) * | 2003-09-06 | 2005-06-23 | Oracle International Corporation | High load SQL driven statistics collection |
US7634456B2 (en) | 2003-09-06 | 2009-12-15 | Oracle International Corporation | SQL structure analyzer |
US20050120001A1 (en) * | 2003-09-06 | 2005-06-02 | Oracle International Corporation | SQL structure analyzer |
US20050120000A1 (en) * | 2003-09-06 | 2005-06-02 | Oracle International Corporation | Auto-tuning SQL statements |
US8983934B2 (en) | 2003-09-06 | 2015-03-17 | Oracle International Corporation | SQL tuning base |
US20050125427A1 (en) * | 2003-09-06 | 2005-06-09 | Oracle International Corporation | Automatic SQL tuning advisor |
US7747606B2 (en) | 2003-09-06 | 2010-06-29 | Oracle International Corporation | Automatic SQL tuning advisor |
US20050125398A1 (en) * | 2003-09-06 | 2005-06-09 | Oracle International Corporation | Global hints |
US20050097091A1 (en) * | 2003-09-06 | 2005-05-05 | Oracle International Corporation | SQL tuning base |
US8825629B2 (en) | 2003-09-06 | 2014-09-02 | Oracle International Corporation | Method for index tuning of a SQL statement, and index merging for a multi-statement SQL workload, using a cost-based relational query optimizer |
US20050187917A1 (en) * | 2003-09-06 | 2005-08-25 | Oracle International Corporation | Method for index tuning of a SQL statement, and index merging for a multi-statement SQL workload, using a cost-based relational query optimizer |
US7805411B2 (en) | 2003-09-06 | 2010-09-28 | Oracle International Corporation | Auto-tuning SQL statements |
US7739263B2 (en) | 2003-09-06 | 2010-06-15 | Oracle International Corporation | Global hints |
US20050125452A1 (en) * | 2003-09-06 | 2005-06-09 | Oracle International Corporation | SQL profile |
US7664730B2 (en) * | 2003-09-06 | 2010-02-16 | Oracle International Corporation | Method and system for implementing a SQL profile |
US7664778B2 (en) | 2003-09-06 | 2010-02-16 | Oracle International Corporation | SQL tuning sets |
US7522640B2 (en) * | 2003-09-19 | 2009-04-21 | Oki Electric Industry Co., Ltd. | Method of avoiding synchronization between communicating nodes |
US20050190796A1 (en) * | 2003-09-19 | 2005-09-01 | Masaaki Date | Method of avoiding synchronization between communicating nodes |
US20080267181A1 (en) * | 2005-11-08 | 2008-10-30 | Nortel Networks Limited | Selective Multicasting of Sensor Data for Reliable Delivery |
WO2007079280A3 (en) * | 2005-11-08 | 2007-12-13 | Nortel Networks Ltd | Selective multicasting of sensor data for reliable delivery |
WO2007079280A2 (en) * | 2005-11-08 | 2007-07-12 | Nortel Networks Limited | Selective multicasting of sensor data for reliable delivery |
US8068481B2 (en) * | 2006-05-25 | 2011-11-29 | Cisco Technology, Inc. | Techniques for reliable switchover to a date multicast distribution tree (MDT) |
US20120057594A1 (en) * | 2006-05-25 | 2012-03-08 | Cisco Technology, Inc. | Techniques for Reliable Switchover to a Date Multicast Distribution Tree (MDT) |
US20070274235A1 (en) * | 2006-05-25 | 2007-11-29 | Cisco Technology, Inc. | Techniques for reliable switchover to a date multicast distribution tree (MDT) |
US8761161B2 (en) * | 2006-05-25 | 2014-06-24 | Cisco Technology, Inc. | Techniques for reliable switchover to a date multicast distribution tree (MDT) |
US20100235432A1 (en) * | 2006-08-21 | 2010-09-16 | Telefonaktiebolaget L M Ericsson | Distributed Server Network for Providing Triple and Play Services to End Users |
US20080294646A1 (en) * | 2007-05-24 | 2008-11-27 | Via Technologies, Inc. | Data distributing and accessing method and system |
US9032015B2 (en) | 2007-05-24 | 2015-05-12 | Via Technologies, Inc. | Data distributing and accessing method and system |
US11134219B2 (en) * | 2007-12-31 | 2021-09-28 | Alcatel Lucent | Method and apparatus for distributing content |
US10560663B2 (en) * | 2007-12-31 | 2020-02-11 | Alcatel Lucent | Method and apparatus for distributing content |
US11468088B2 (en) | 2008-10-24 | 2022-10-11 | Pure Storage, Inc. | Selection of storage nodes for storage of data |
US9329955B2 (en) | 2008-10-24 | 2016-05-03 | Compuverde Ab | System and method for detecting problematic data storage nodes |
US10650022B2 (en) | 2008-10-24 | 2020-05-12 | Compuverde Ab | Distributed data storage |
US11907256B2 (en) | 2008-10-24 | 2024-02-20 | Pure Storage, Inc. | Query-based selection of storage nodes |
US9495432B2 (en) | 2008-10-24 | 2016-11-15 | Compuverde Ab | Distributed data storage |
US11258654B1 (en) | 2008-11-10 | 2022-02-22 | Tanium Inc. | Parallel distributed network management |
US10708116B2 (en) | 2008-11-10 | 2020-07-07 | Tanium Inc. | Parallel distributed network management |
US8903973B1 (en) | 2008-11-10 | 2014-12-02 | Tanium Inc. | Parallel distributed network management |
US8904039B1 (en) * | 2008-11-10 | 2014-12-02 | Tanium Inc. | Large-scale network querying and reporting |
US8972566B1 (en) | 2008-11-10 | 2015-03-03 | Tanium Inc. | Distributed statistical detection of network problems and causes |
US9729429B2 (en) | 2008-11-10 | 2017-08-08 | Tanium Inc. | Parallel distributed network management |
US9503524B2 (en) | 2010-04-23 | 2016-11-22 | Compuverde Ab | Distributed data storage |
US9948716B2 (en) | 2010-04-23 | 2018-04-17 | Compuverde Ab | Distributed data storage |
US20120054172A1 (en) * | 2010-08-31 | 2012-03-01 | International Business Machines Corporation | Method and system for transmitting a query in a wireless network |
US8346758B2 (en) * | 2010-08-31 | 2013-01-01 | International Business Machines Corporation | Method and system for transmitting a query in a wireless network |
US9626378B2 (en) * | 2011-09-02 | 2017-04-18 | Compuverde Ab | Method for handling requests in a storage system and a storage node for a storage system |
US20130058333A1 (en) * | 2011-09-02 | 2013-03-07 | Ilt Innovations Ab | Method For Handling Requests In A Storage System And A Storage Node For A Storage System |
US10909110B1 (en) | 2011-09-02 | 2021-02-02 | Pure Storage, Inc. | Data retrieval from a distributed data storage system |
US11372897B1 (en) | 2011-09-02 | 2022-06-28 | Pure Storage, Inc. | Writing of data to a storage system that implements a virtual file structure on an unstructured storage layer |
US9305012B2 (en) | 2011-09-02 | 2016-04-05 | Compuverde Ab | Method for data maintenance |
US10769177B1 (en) | 2011-09-02 | 2020-09-08 | Pure Storage, Inc. | Virtual file structure for data storage system |
US10579615B2 (en) | 2011-09-02 | 2020-03-03 | Compuverde Ab | Method for data retrieval from a distributed data storage system |
US10430443B2 (en) | 2011-09-02 | 2019-10-01 | Compuverde Ab | Method for data maintenance |
US9965542B2 (en) | 2011-09-02 | 2018-05-08 | Compuverde Ab | Method for data maintenance |
US9183279B2 (en) * | 2011-09-22 | 2015-11-10 | International Business Machines Corporation | Semantic questioning mechanism to enable analysis of information architectures |
US9059961B2 (en) | 2012-12-21 | 2015-06-16 | Tanium Inc. | Creation and maintenance of self-organizing communication orbits in distributed networks |
US9246977B2 (en) | 2012-12-21 | 2016-01-26 | Tanium Inc. | System, security and network management using self-organizing communication orbits in distributed networks |
US10136415B2 (en) | 2012-12-21 | 2018-11-20 | Tanium Inc. | System, security and network management using self-organizing communication orbits in distributed networks |
US11711810B1 (en) | 2012-12-21 | 2023-07-25 | Tanium Inc. | System, security and network management using self-organizing communication orbits in distributed networks |
US10111208B2 (en) | 2012-12-21 | 2018-10-23 | Tanium Inc. | System and method for performing security management operations in network having non-static collection of nodes |
US20150280931A1 (en) * | 2013-01-07 | 2015-10-01 | Mitsubishi Electric Corporation | Data distribution system, root wireless device, and wireless device |
US9191411B2 (en) | 2013-03-15 | 2015-11-17 | Zerofox, Inc. | Protecting against suspect social entities |
US9674214B2 (en) * | 2013-03-15 | 2017-06-06 | Zerofox, Inc. | Social network profile data removal |
US9674212B2 (en) | 2013-03-15 | 2017-06-06 | Zerofox, Inc. | Social network data removal |
US9390127B2 (en) * | 2013-04-01 | 2016-07-12 | International Business Machines Corporation | RDF graphs made of RDF query language queries |
US20140297675A1 (en) * | 2013-04-01 | 2014-10-02 | International Business Machines Corporation | Rdf graphs made of rdf query language queries |
US20140297676A1 (en) * | 2013-04-01 | 2014-10-02 | International Business Machines Corporation | Rdf graphs made of rdf query language queries |
US9342556B2 (en) * | 2013-04-01 | 2016-05-17 | International Business Machines Corporation | RDF graphs made of RDF query language queries |
US10148536B2 (en) | 2013-11-27 | 2018-12-04 | Tanium Inc. | Fast detection and remediation of unmanaged assets |
US9769037B2 (en) | 2013-11-27 | 2017-09-19 | Tanium Inc. | Fast detection and remediation of unmanaged assets |
US20220121681A1 (en) * | 2014-02-19 | 2022-04-21 | Snowflake Inc. | Resource management systems and methods |
US11928129B1 (en) | 2014-02-19 | 2024-03-12 | Snowflake Inc. | Cloning catalog objects |
US11977560B2 (en) * | 2014-02-19 | 2024-05-07 | Snowflake Inc. | Resource management systems and methods |
US9667738B2 (en) | 2014-03-24 | 2017-05-30 | Tanium Inc. | Local data caching for data transfers on a network of computational devices |
US10873645B2 (en) | 2014-03-24 | 2020-12-22 | Tanium Inc. | Software application updating in a local network |
US10412188B2 (en) | 2014-03-24 | 2019-09-10 | Tanium Inc. | Data caching, distribution and request consolidation in a local network |
US9769275B2 (en) | 2014-03-24 | 2017-09-19 | Tanium Inc. | Data caching and distribution in a local network |
US11277489B2 (en) | 2014-03-24 | 2022-03-15 | Tanium Inc. | Software application updating in a local network |
US9544325B2 (en) | 2014-12-11 | 2017-01-10 | Zerofox, Inc. | Social network security monitoring |
US10491623B2 (en) | 2014-12-11 | 2019-11-26 | Zerofox, Inc. | Social network security monitoring |
US9910752B2 (en) | 2015-04-24 | 2018-03-06 | Tanium Inc. | Reliable map-reduce communications in a decentralized, self-organizing communication orbit of a distributed network |
US11461208B1 (en) | 2015-04-24 | 2022-10-04 | Tanium Inc. | Reliable map-reduce communications in a decentralized, self-organizing communication orbit of a distributed network |
US11809294B1 (en) | 2015-04-24 | 2023-11-07 | Tanium Inc. | Reliable map-reduce communications in a decentralized, self-organizing communication orbit of a distributed network |
US10649870B1 (en) | 2015-04-24 | 2020-05-12 | Tanium Inc. | Reliable map-reduce communications in a decentralized, self-organizing communication orbit of a distributed network |
US10999130B2 (en) | 2015-07-10 | 2021-05-04 | Zerofox, Inc. | Identification of vulnerability to social phishing |
US10516567B2 (en) | 2015-07-10 | 2019-12-24 | Zerofox, Inc. | Identification of vulnerability to social phishing |
US11914495B1 (en) | 2016-03-08 | 2024-02-27 | Tanium Inc. | Evaluating machine and process performance in distributed system |
US11153383B2 (en) | 2016-03-08 | 2021-10-19 | Tanium Inc. | Distributed data analysis for streaming data sources |
US11700303B1 (en) | 2016-03-08 | 2023-07-11 | Tanium Inc. | Distributed data analysis for streaming data sources |
US10482242B2 (en) | 2016-03-08 | 2019-11-19 | Tanium Inc. | System and method for performing event inquiries in a network |
US10498744B2 (en) | 2016-03-08 | 2019-12-03 | Tanium Inc. | Integrity monitoring in a local network |
US11609835B1 (en) | 2016-03-08 | 2023-03-21 | Tanium Inc. | Evaluating machine and process performance in distributed system |
US10372904B2 (en) | 2016-03-08 | 2019-08-06 | Tanium Inc. | Cost prioritized evaluations of indicators of compromise |
US11372938B1 (en) | 2016-03-08 | 2022-06-28 | Tanium Inc. | System and method for performing search requests in a network |
US10095864B2 (en) | 2016-03-08 | 2018-10-09 | Tanium Inc. | System and method for performing event inquiries in a network |
US11886229B1 (en) | 2016-03-08 | 2024-01-30 | Tanium Inc. | System and method for generating a global dictionary and performing similarity search queries in a network |
US10929345B2 (en) | 2016-03-08 | 2021-02-23 | Tanium Inc. | System and method of performing similarity search queries in a network |
US10970333B2 (en) | 2016-08-08 | 2021-04-06 | NetraDyne, Inc. | Distributed video storage and search with edge computing |
US11256812B2 (en) | 2017-01-31 | 2022-02-22 | Zerofox, Inc. | End user social network protection portal |
US20180260401A1 (en) * | 2017-03-08 | 2018-09-13 | Netradyne Inc | Distributed video search with edge computing |
US11394722B2 (en) | 2017-04-04 | 2022-07-19 | Zerofox, Inc. | Social media rule engine |
US10824729B2 (en) | 2017-07-14 | 2020-11-03 | Tanium Inc. | Compliance management in a local network |
US10868824B2 (en) | 2017-07-31 | 2020-12-15 | Zerofox, Inc. | Organizational social threat reporting |
US11165801B2 (en) | 2017-08-15 | 2021-11-02 | Zerofox, Inc. | Social threat correlation |
US11418527B2 (en) | 2017-08-22 | 2022-08-16 | ZeroFOX, Inc | Malicious social media account identification |
US11403400B2 (en) | 2017-08-31 | 2022-08-02 | Zerofox, Inc. | Troll account detection |
US11134097B2 (en) | 2017-10-23 | 2021-09-28 | Zerofox, Inc. | Automated social account removal |
US11343355B1 (en) | 2018-07-18 | 2022-05-24 | Tanium Inc. | Automated mapping of multi-tier applications in a distributed system |
US11956335B1 (en) | 2018-07-18 | 2024-04-09 | Tanium Inc. | Automated mapping of multi-tier applications in a distributed system |
US10841365B2 (en) | 2018-07-18 | 2020-11-17 | Tanium Inc. | Mapping application dependencies in a computer network |
US11831670B1 (en) | 2019-11-18 | 2023-11-28 | Tanium Inc. | System and method for prioritizing distributed system risk remediations |
US11563764B1 (en) | 2020-08-24 | 2023-01-24 | Tanium Inc. | Risk scoring based on compliance verification test results in a local network |
US11777981B1 (en) | 2020-08-24 | 2023-10-03 | Tanium Inc. | Risk scoring based on compliance verification test results in a local network |
US20230102209A1 (en) * | 2021-05-11 | 2023-03-30 | Strong Force Vcn Portfolio 2019, Llc | Edge-Distributed Query Processing in Value Chain Networks |
Also Published As
Publication number | Publication date |
---|---|
WO2002005141A2 (en) | 2002-01-17 |
US6826564B2 (en) | 2004-11-30 |
WO2002005141A8 (en) | 2003-11-20 |
WO2002005141A3 (en) | 2002-08-29 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US6826564B2 (en) | Scalable and programmable query distribution and collection in a network of queryable devices | |
Chuang et al. | Pricing multicast communication: A cost-based approach | |
US10356144B1 (en) | Reassigning source peers | |
US8477617B2 (en) | Systems and methods for managing multicast data transmissions | |
US7408877B2 (en) | Method and apparatus for applying quality of service to multicast streams transmitted in a cable network | |
Vogel et al. | QoS-based routing of multimedia streams in computer networks | |
US9807163B1 (en) | Data client | |
CN101322363A (en) | Apparatus and method for providing end-to-end service quality guarantee in business network | |
US20150350291A1 (en) | System, method and live streaming optimizer server for live media content distribution optimization from a content delivery network | |
KR20010020190A (en) | System, device, and method for managing multicast group memberships in a multicast network | |
WO2012065531A1 (en) | Method, device, and system for implementing relay selection | |
Li et al. | Bandwidth control for replicated-stream multicast video distribution | |
CN101166194B (en) | A system and method for realizing distributed acceptance control | |
US7715424B2 (en) | Method and system for billing network usage in a network | |
Makofske et al. | MHealth: A real-time graphical multicast monitoring tool | |
Parsa et al. | Scalable Internet multicast routing | |
US8566436B1 (en) | Data client | |
Fei et al. | Optimal allocation of clients to replicated multicast servers | |
Makofske et al. | Real‐time multicast tree visualization and monitoring | |
Yamamoto | Multicast Communications--Present and Future | |
Jagannathan et al. | Using tree topology for multicast congestion control | |
EP1856838A1 (en) | Method and apparatus for managing multicast transmission costs | |
Alekseev et al. | Evaluation of a topological distance algorithm for construction of a P2P multicast hybrid overlay tree | |
JP2010035203A (en) | Method for controlling multicast transmission cost and its device | |
Salyers et al. | A novel approach for transparent bandwidth conservation |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: FASTFORWARD NETWORKS, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:THOMPSON, NICHOLAS;WELCH, WILLIAM;LANG, KEVIN J.;AND OTHERS;REEL/FRAME:012608/0709;SIGNING DATES FROM 20011005 TO 20020108 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
AS | Assignment |
Owner name: YAHOO| INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:FASTFORWARD NETWORKS, INC.;REEL/FRAME:018015/0494Effective date: 20060502Owner name: YAHOO| INC.,CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:FASTFORWARD NETWORKS, INC.;REEL/FRAME:018015/0494Effective date: 20060502 |
|
FPAY | Fee payment |
Year of fee payment: 4 |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:YAHOO| INC.;REEL/FRAME:033868/0257Effective date: 20140630 |
|
FPAY | Fee payment |
Year of fee payment: 12 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044127/0735Effective date: 20170929 |