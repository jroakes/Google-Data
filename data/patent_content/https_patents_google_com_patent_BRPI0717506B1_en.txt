BRPI0717506B1 - method and apparatus for encoding and decoding data - Google Patents
method and apparatus for encoding and decoding data Download PDFInfo
- Publication number
- BRPI0717506B1 BRPI0717506B1 BRPI0717506A BRPI0717506B1 BR PI0717506 B1 BRPI0717506 B1 BR PI0717506B1 BR PI0717506 A BRPI0717506 A BR PI0717506A BR PI0717506 B1 BRPI0717506 B1 BR PI0717506B1
- Authority
- BR
- Brazil
- Prior art keywords
- fec
- bits
- block
- sizes
- segments
- Prior art date
Links
Classifications
-
- H—ELECTRICITY
- H03—ELECTRONIC CIRCUITRY
- H03M—CODING; DECODING; CODE CONVERSION IN GENERAL
- H03M13/00—Coding, decoding or code conversion, for error detection or error correction; Coding theory basic assumptions; Coding bounds; Error probability evaluation methods; Channel models; Simulation or testing of codes
- H03M13/29—Coding, decoding or code conversion, for error detection or error correction; Coding theory basic assumptions; Coding bounds; Error probability evaluation methods; Channel models; Simulation or testing of codes combining two or more codes or code structures, e.g. product codes, generalised product codes, concatenated codes, inner and outer codes
-
- H—ELECTRICITY
- H03—ELECTRONIC CIRCUITRY
- H03M—CODING; DECODING; CODE CONVERSION IN GENERAL
- H03M13/00—Coding, decoding or code conversion, for error detection or error correction; Coding theory basic assumptions; Coding bounds; Error probability evaluation methods; Channel models; Simulation or testing of codes
- H03M13/29—Coding, decoding or code conversion, for error detection or error correction; Coding theory basic assumptions; Coding bounds; Error probability evaluation methods; Channel models; Simulation or testing of codes combining two or more codes or code structures, e.g. product codes, generalised product codes, concatenated codes, inner and outer codes
- H03M13/2957—Turbo codes and decoding
- H03M13/2996—Tail biting
-
- H—ELECTRICITY
- H03—ELECTRONIC CIRCUITRY
- H03M—CODING; DECODING; CODE CONVERSION IN GENERAL
- H03M13/00—Coding, decoding or code conversion, for error detection or error correction; Coding theory basic assumptions; Coding bounds; Error probability evaluation methods; Channel models; Simulation or testing of codes
- H03M13/29—Coding, decoding or code conversion, for error detection or error correction; Coding theory basic assumptions; Coding bounds; Error probability evaluation methods; Channel models; Simulation or testing of codes combining two or more codes or code structures, e.g. product codes, generalised product codes, concatenated codes, inner and outer codes
- H03M13/2903—Methods and arrangements specifically for encoding, e.g. parallel encoding of a plurality of constituent codes
-
- H—ELECTRICITY
- H03—ELECTRONIC CIRCUITRY
- H03M—CODING; DECODING; CODE CONVERSION IN GENERAL
- H03M13/00—Coding, decoding or code conversion, for error detection or error correction; Coding theory basic assumptions; Coding bounds; Error probability evaluation methods; Channel models; Simulation or testing of codes
- H03M13/29—Coding, decoding or code conversion, for error detection or error correction; Coding theory basic assumptions; Coding bounds; Error probability evaluation methods; Channel models; Simulation or testing of codes combining two or more codes or code structures, e.g. product codes, generalised product codes, concatenated codes, inner and outer codes
- H03M13/2957—Turbo codes and decoding
Abstract
método e aparelho para codificar e decodificar dados é provido aqui um método e aparelho para turbo codificação e decodificação. durante operação, um bloco de transporte concatenado (ctb) de comprimento x é recebido e um tamanho de bloco ki de correção antecipada de erro (fec) é determinado a partir de um grupo de tamanhos de blocos fec não-contíguos disponíveis entre kmin e kmax, e em que kmin <=ki< kmax, e em que ki se baseia adicionalmente em x. o bloco de transporte concatenado de comprimento x é segmentado em c segmentos cada um deles com tamanho substancialmente igual a ki. uma palavra-código fec para cada um dos c segmentos é determinada utilizando o tamanho de bloco fec ki; e as e palavras - código fec são transmitidas através do canal.Method and apparatus for encoding and decoding data A method and apparatus for turbo encoding and decoding is provided herein. during operation, a concatenated transport block (ctb) of length x is received and a forward error correction (fec) block size ki is determined from a group of available noncontiguous fec block sizes between kmin and kmax , and wherein kmin <= ki <kmax, and wherein ki is additionally based on x. the concatenated transport block of length x is segmented into c segments each of a size substantially equal to ki. a fec codeword for each of the c segments is determined using the fec ki block size; and the fec and codewords are transmitted through the channel.
Description
MÉTODO E APARELHO PARA CODIFICAR E DECODIFICAR DADOSMETHOD AND APPARATUS FOR ENCODING AND DECODING DATA
Campo da Invenção A presente invenção se refere geralmente à codificação e decodificação de dados e especificamente, a um método e aparelho para turbo codificação e decodificação.Field of the Invention The present invention generally relates to the encoding and decoding of data and specifically, to a method and apparatus for turbo encoding and decoding.
Antecedentes da Invenção As transmissões de dados digitais através de ligações cabeadas e sem fio podem ser corrompidas, por exemplo, por ruído na ligação ou canal, mediante interferência a partir de outras transmissões, ou por outros fatores ambientais. Para combater os erros introduzidos pelo canal, muitos sistemas de comunicação empregam técnicas de correção de erro para auxiliar na comunicação.Background of the Invention Digital data transmissions through wired and wireless connections can be corrupted, for example, by connection or channel noise, by interference from other transmissions, or by other environmental factors. To combat errors introduced by the channel, many communication systems employ error correction techniques to assist in communication.
Uma técnica utilizada para correção de erro é a turbo codificação de um bloco de informação a ser transmitido. Utilizando tal técnica, um codificador dentro do transmissor de um sistema de comunicação codificará um bloco de entrada u de K' bits de comprimento em um bloco de palavra-código x de N bits. O bloco de palavra-código é então transmitido através do canal, possivelmente após processamento adicional tal como intercalação de canal conforme definido nas especificações IEEE 802.16e. No receptor, o turbo decodificador pega o vetor de sinal recebido y de comprimento N como entrada, e gera uma estimativa ü de vetor u.A technique used for error correction is the turbo coding of a block of information to be transmitted. Using such a technique, an encoder within the transmitter of a communication system will encode an input block u of K 'bits long into a code word block x of N bits. The code word block is then transmitted over the channel, possibly after further processing such as channel interleaving as defined in the IEEE 802.16e specifications. At the receiver, the turbo decoder takes the received signal vector y of length N as input, and generates an estimate ü of vector u.
Tipicamente o turbo codificador é composto de dois codificadores convolucionais constituintes. O primeiro codificador constituinte pega o bloco de entrada u como entrada em sua ordem original, e o segundo codificador constituinte pega o bloco de entrada u em sua ordem intercalada após passar u através de um turbo intercalador π. A saída do turbo codificador x é composta dos bits sistemáticos (igual ao bloco de entrada u) , os bits de paridade a partir do primeiro codificador constituinte, e os bits de paridade a partir do segundo codificador constituinte.Typically the turbo encoder is composed of two constituent convolutional encoders. The first constituent encoder takes input block u as input in its original order, and the second constituent encoder takes input block u in its interleaved order after passing u through a turbo interleaver π. The output of the turbo encoder x is composed of the systematic bits (same as the input block u), the parity bits from the first constituent encoder, and the parity bits from the second constituent encoder.
Correspondentemente o turbo decodificador dentro do receptor do sistema de comunicação é composto de dois decodificadores convolucionais constituintes, um para cada código constituinte. Os decodificadores constituintes são separados pelo intercalador π e o desintercalador correspondente π-1. Mensagens no formato de razões de log-verossimilhança (LLRs) são passadas entre os decodificadores constituintes iterativamente. A decisão ü é tomada após várias iterações. O turbo intercalador π é o componente-chave no modelo de turbo código. Ele é responsável pelo embaralhamento do bloco de entrada u de uma forma pseudo-aleatória, desse modo proporcionando as palavras-código x com distribuição de peso adequada, portanto capacidades adequadas de correção de erro. Em adição à performance de decodificação, o turbo intercalador π tem impacto significativo sobre a implementação do turbo decodificador dentro do receptor. Normalmente, a performance dos turbo códigos melhora com comprimento crescente do intercalador. Contudo, há um retorno decrescente ao se aumentar o tamanho do intercalador. Na prática, o tamanho de bloco máximo de Correção Antecipada de Erro (FEC) (isto é, tamanho de intercalador) de um turbo código é limitado a certo valor devido à complexidade e por razões de retardo. Portanto, se o tamanho do bloco de entrada (bloco de transporte concatenado ou CTB) for maior do que o tamanho de bloco FEC máximo suportado pelo turbo código, o CTB é segmentado (por exemplo, utilizando regra de segmentação de bloco de código) em vários segmentos pequenos, cada um dos quais é processado separadamente pelo turbo codificador no transmissor e correspondentemente pelo turbo decodificador no receptor.Correspondingly, the turbo decoder within the receiver of the communication system is composed of two constituent convolutional decoders, one for each constituent code. The constituent decoders are separated by interleaver π and the corresponding deinterleaver π-1. Messages in the format of log-likelihood ratios (LLRs) are passed between the constituent decoders iteratively. The ü decision is made after several iterations. The turbo interleaver π is the key component in the turbo code model. It is responsible for shuffling the input block u in a pseudo-random way, thereby providing the code words x with an appropriate weight distribution, therefore adequate error correction capabilities. In addition to the decoding performance, the π turbo interleaver has a significant impact on the implementation of the turbo decoder within the receiver. Typically, the performance of the turbo codes improves with increasing interleaver length. However, there is a decreasing return when increasing the size of the interleaver. In practice, the maximum Early Error Correction (FEC) block size (ie interleaver size) of a turbo code is limited to a certain value due to complexity and for reasons of delay. Therefore, if the input block size (concatenated transport block or CTB) is larger than the maximum FEC block size supported by the turbo code, the CTB is segmented (for example, using code block segmentation rule) in several small segments, each of which is processed separately by the turbo encoder at the transmitter and correspondingly by the turbo decoder at the receiver.
Em alguns sistemas, o turbo código pode ser projetado para suportar apenas um pequeno número de tamanhos de bloco FEC por várias razões (por exemplo, decodificação de alta velocidade, armazenamento reduzido, etc.). Portanto, existe a necessidade de um método e aparelho para turbo codificar e decodificar que combine apropriadamente o CTB com os tamanhos de bloco FEC disponíveis.In some systems, turbo code can be designed to support only a small number of FEC block sizes for several reasons (eg, high speed decoding, reduced storage, etc.). Therefore, there is a need for a method and apparatus for turbo encoding and decoding that appropriately combines the CTB with the available FEC block sizes.
MOTOROLA, FRANCE TELECOM, GET AND ORANGE, "EUTRA FECMOTOROLA, FRANCE TELECOM, GET AND ORANGE, "EUTRA FEC
Enhancement", TDOC R1-061050 OF 3GPP TSG RAN WG 1 MEETING #44BIS, Athens, Greece se refere a turbo codificação para sistemas de comunicação 3GPP CDMA.Enhancement ", TDOC R1-061050 OF 3GPP TSG RAN WG 1 MEETING # 44BIS, Athens, Greece refers to turbo coding for 3GPP CDMA communication systems.
Descrição Resumida dos Desenhos A Figura 1 é um diagrama de blocos de um transmissor. A Figura 2 é um diagrama de blocos de um receptor. A Figura 3 é um diagrama de blocos do turbo codificador da Figura 1. A Figura 4 é um diagrama de blocos do formador de bloco de transporte pelo lado do transmissor. A Figura 5 é um diagrama de blocos de um montador de bloco de transporte pelo lado do receptor. A Figura 6 é um fluxograma mostrando a operação do transmissor da Figura 1. A Figura 7 é um fluxograma mostrando a operação do receptor da Figura 2.Brief Description of the Drawings Figure 1 is a block diagram of a transmitter. Figure 2 is a block diagram of a receiver. Figure 3 is a block diagram of the Figure 1 turbo encoder. Figure 4 is a block diagram of the transport block former from the transmitter side. Figure 5 is a block diagram of a carrier block assembler on the receiver side. Figure 6 is a flow chart showing the operation of the Figure 1 transmitter. Figure 7 is a flow chart showing the operation of the Figure 2 receiver.
Descrição Detalhada dos Desenhos Para tratar da necessidade mencionada acima, é provido aqui um método e aparelho para turbo codificação e decodificação. Durante a operação, um bloco de transporte concatenado (CTB) de comprimento X é recebido e um tamanho de bloco Ki de correção antecipada de erro (FEC) é determinado a partir de um grupo de tamanhos de bloco FEC não-contíguos disponíveis Kmin e Kmax, e em que <=A7< θ em que Ki se baseia adícionalmente em X. 0 bloco de transporte concatenado de comprimento X é segmentado em C segmentos cada um de tamanho substancialmente igual a Ki. Uma palavra código FEC para cada um dos C segmentos é determinada utilizando tamanho de bloco FEC Ki, e as C palavras código FEC são transmitidas através do canal.Detailed Description of the Drawings To address the need mentioned above, a method and apparatus for turbo encoding and decoding is provided here. During operation, a concatenated transport block (CTB) of length X is received and an error correction Ki block size Ki (FEC) is determined from a group of available non-contiguous FEC block sizes Kmin and Kmax , and where <= A7 <θ on which Ki is additionally based on X. The concatenated transport block of length X is segmented into C segments each of size substantially equal to Ki. One FEC code word for each of the C segments is determined using FEC Ki block size, and the C FEC code words are transmitted through the channel.
Em uma modalidade alternativa, um bloco de transporte concatenado (CTB) de comprimento X é recebido Ki-i e Ki são determinados a partir de um grupo de tamanhos de bloco FEC não-contíguos, em que os tamanhos de bloco FEC não-contíguos disponíveis estão entre Kmin e Kmax, e em que <= A7-i< <= Â/<= θ em gue Kll θ Kl se baseiam adícionalmente em X. 0 bloco de transporte concatenado de comprimento X é segmentado em C segmentos cada um de tamanho substancialmente igual a Ki-i e Ki. Uma palavra código FEC para cada um dos C segmentos é determinada utilizando tamanhos de bloco FEC Ki ou Ki-i, e as C palavras código FEC são transmitidas através do canal. 0 benefício dos métodos acima é que eles reduzem o enchimento dos bits de enchimento exigidos para codificar o CTB, enquanto utilizando o menor número de segmentos permitido pelos tamanhos de bloco FEC não-contíguos disponíveis. Especificamente, o segundo método utiliza dois diferentes tamanhos de bloco FEC (porém adjacentes) para minimizar o número de bits de enchimento enquanto utilizando o menor número de segmentos conforme permitido pelos tamanhos de blocos FEC não-contíguos disponíveis. Além disso, os tamanhos de bloco FEC para os tamanhos de segmento e o número de segmentos para as duas modalidades podem ser determinados utilizando conjunto de circuitos, lógicos, simples.In an alternative embodiment, a concatenated transport block (CTB) of length X is received Ki-i and Ki are determined from a group of non-contiguous FEC block sizes, in which the non-contiguous FEC block sizes are available are between Kmin and Kmax, and where <= A7-i <<= Â / <= θ in which Kll θ Kl are additionally based on X. The concatenated transport block of length X is segmented into C segments each of size substantially equal to Ki-i and Ki. One FEC code word for each of the C segments is determined using FEC Ki or Ki-i block sizes, and the C FEC code words are transmitted through the channel. The benefit of the above methods is that they reduce the filling of the filling bits required to encode the CTB, while using the smallest number of segments allowed by the non-contiguous FEC block sizes available. Specifically, the second method uses two different (but adjacent) FEC block sizes to minimize the number of fill bits while using the fewest number of segments as allowed by the available non-contiguous FEC block sizes. In addition, the FEC block sizes for the segment sizes and the number of segments for the two modalities can be determined using simple, logical, circuitry.
Antes de descrever os dados de codificação e decodificação, as seguintes definições são providas para definir os antecedentes necessários: ■ Para facilidade de notação, um bloco de transporte concatenado se refere ao resultado de concatenar um ou mais blocos de transporte, após adicionar overhead tal como bits CRC para cada bloco de transporte. ■ X denota o tamanho de bloco de transporte concatenado (por exemplo, comprimento do bloco de transporte concatenado em bits). ■ Y denota o tamanho total de bits de enchimento adicionados a um bloco de transporte concatenado. ■ C denota o número de segmentos nos quais o bloco de transporte concatenado é segmentado. ■ CBSSi denota o tamanho do i° segmento de um bloco de transporte concatenado (i=1,... C), onde C é o tamanho do segmento. CBSS significa o tamanho de segmento de bloco. ■ K1-1 e Ki denotam tamanhos de bloco FEC (por exemplo, tamanhos para os quais o intercalador interno de turbo código é definido) que podem ser usados para codificar FEC os segmentos de um bloco de transporte concatenado. ■ Ktabie denota um conjunto de tamanhos de blocos FEC não-contíguos disponíveis (tamanhos para os quais um intercalador interno de turbo código é definido). ■ Kfiiier denota o número de bits de enchimento adicionados a um segmento. ■ R denota a taxa de código-mãe do turbo codificador (por exemplo, R = 1/3 para turbo-código de 3GPP) . ■ R-1 é o inverso da taxa de código-mãe do turbo codificador (por exemplo, R-1 = 3 para turbo-código de 3GPP). ■ Ntb é o número de bits finais no bloco codificado, especificamente para turbo-código de 3GPP, o Ntb = 12 para turbo-código de 3GPP com bits finais o Ntb = o para um turbo-código de 3GPP com códigos convolucionais constituintes tail-biting. ■ π denota o intercalador interno de turbo código. ■ A operação de limite mínimo . x. denota o número inteiro maior, menor do que ou igual a x e a operação de limite máximo ΓχΊ denota o menor número inteiro maior do que ou igual a x.Before describing the encoding and decoding data, the following definitions are provided to define the necessary background: ■ For ease of notation, a concatenated transport block refers to the result of concatenating one or more transport blocks, after adding overhead such as CRC bits for each transport block. ■ X denotes the size of the concatenated transport block (for example, length of the concatenated transport block in bits). ■ Y denotes the total size of padding bits added to a concatenated transport block. ■ C denotes the number of segments in which the concatenated transport block is segmented. ■ CBSSi denotes the size of the 1st segment of a concatenated transport block (i = 1, ... C), where C is the size of the segment. CBSS stands for the block segment size. ■ K1-1 and Ki denote FEC block sizes (for example, sizes for which the internal turbo code interleaver is defined) that can be used to FEC encode the segments of a concatenated transport block. ■ Ktabie denotes a set of available non-contiguous FEC block sizes (sizes for which an internal turbo code interleaver is defined). ■ Kfiiier denotes the number of padding bits added to a segment. ■ R denotes the parent code rate of the turbo encoder (for example, R = 1/3 for 3GPP turbo-code). ■ R-1 is the inverse of the turbo coder parent code rate (for example, R-1 = 3 for 3GPP turbo-code). ■ Ntb is the number of final bits in the coded block, specifically for 3GPP turbo-code, Ntb = 12 for 3GPP turbo-code with final bits o Ntb = o for a 3GPP turbo-code with tail-forming convolutional codes biting. ■ π denotes the internal turbo code interleaver. ■ The lower limit operation. x. denotes the integer greater than, less than or equal to x and the upper limit operation ΊχΊ denotes the smallest integer greater than or equal to x.
De acordo agora com os desenhos, em que numerais semelhantes designam componentes semelhantes, a Figura 1 é um diagrama de blocos do transmissor 100. Conforme mostrado, o transmissor 100 compreende conjunto de circuitos de segmentação de bloco de código 102, conjunto de circuitos de enchimento 103, turbo codificador 104, conjunto de circuitos de descarte de enchimento 105, transmissor 108, conjunto de circuitos lógicos 106, e tabela/meio de armazenamento 107. 0 transmissor 100 compreende adicionalmente conjunto de circuitos de recepção (não mostrado na Figura 1) que recebe um bloco de transporte concatenado de comprimento X. 0 conjunto de circuitos lógicos 106 determina um tamanho de bloco FEC disponível Ki a partir de um grupo de tamanhos de blocos FEC não-contíguos 107, em que os tamanhos de blocos FEC não-contíguos disponíveis estão entre Kmin e Kmax, e em que θ em gue Kl se baseia adicionalmente em X. 0 conjunto de circuitos de segmentação de bloco de código 102 segmenta o bloco de transporte concatenado de comprimento X em C segmentos de tamanhos substancialmente iguais à Ki, e conjunto de circuitos de codificação 104 determina uma palavra código FEC para cada um dos C segmentos utilizando o tamanho de bloco FEC Ki. Finalmente, o conjunto de circuitos de transmissão 108 transmite as C palavras código FEC através de um canal.According to the drawings now, where similar numerals designate similar components, Figure 1 is a block diagram of transmitter 100. As shown, transmitter 100 comprises code block segmentation circuitry 102, filling circuitry assembly 103, turbo encoder 104, fill discharge circuitry 105, transmitter 108, logic circuitry 106, and storage table / medium 107. The transmitter 100 additionally comprises the receiving circuitry (not shown in Figure 1) which receives a concatenated transport block of length X. The logic circuitry 106 determines an available FEC block size Ki from a group of non-contiguous FEC block sizes 107, where the available non-contiguous FEC block sizes are between Kmin and Kmax, and where θ in g and Kl is additionally based on X. The set of code block segmentation circuits 102 segments the concatenated transport block of length X into C segments of substantially the same size as Ki, and coding circuitry 104 determines an FEC code word for each of the C segments using the FEC Ki block size. Finally, the transmission circuitry 108 transmits the FEC code words through a channel.
Em outra modalidade, o transmissor 100 compreende conjunto de circuitos de recepção (não mostrado na Figura 1) que recebe um bloco de transporte concatenado de comprimento X, conjunto de circuitos lógicos 106 que determina dois tamanhos de bloco FEC disponíveis Ki-i e Ki a partir de um grupo de tamanhos de bloco FEC não-contíguos 107, em que os tamanhos de bloco FEC não-contíguos disponíveis estão entre Kmin e Kmax, e em que <= K/-j< <= ky = Xmj,., θ em gue 2 θ se baseiam adicionalmente em X. 0 transmissor 100 compreende conjunto de circuitos de segmentação de bloco de código 102 que segmenta o bloco de transporte concatenado de comprimento X em C segmentos de tamanhos substancialmente iguais a K1-1 ou Ki, e conjunto de circuitos de codificação 104 que determina uma palavra código FEC para cada um dos C segmentos utilizando tamanho de bloco FEC Ki ou K1-1. Finalmente, é provido conjunto de circuitos de transmissão 108 que transmite as C palavras código FEC através de um canal. O conjunto de circuitos de codificação 104 é precedido por conjunto de circuitos de enchimento 103 que insere bits de enchimento nos segmentos para formar um bloco de entrada FEC. O codificador FEC 104 codifica o bloco de entrada FEC, e conjunto de circuitos de descarte de enchimento 105 descarta os bits relacionados aos bits de enchimento.In another embodiment, the transmitter 100 comprises a set of receiving circuits (not shown in Figure 1) that receives a concatenated transport block of length X, a set of logic circuits 106 that determines two available FEC block sizes Ki-i and Ki a from a group of non-contiguous FEC block sizes 107, where the available non-contiguous FEC block sizes are between Kmin and Kmax, and where <= K / -j <<= ky = Xmj,., θ in which 2 θ are additionally based on X. The transmitter 100 comprises a set of code block segmentation circuits 102 that segments the concatenated transport block of length X into C segments of sizes substantially equal to K1-1 or Ki, and set of coding circuits 104 which determines an FEC code word for each of the C segments using FEC block size Ki or K1-1. Finally, a set of transmission circuits 108 is provided which transmits the FEC code words through a channel. The coding circuitry 104 is preceded by a filler circuitry 103 that inserts filler bits into the segments to form an FEC input block. The FEC encoder 104 encodes the FEC input block, and the fill discard circuitry 105 discards the bits related to the fill bits.
Durante operação do transmissor 100, os dados na forma de um bloco de transporte concatenado são recebidos pelo conjunto de circuitos 102. O conjunto de circuitos 102 prepara o bloco de transporte concatenado antes da codificação de Correção Antecipada de Erros (FEC).During operation of transmitter 100, data in the form of a concatenated transport block is received by circuitry 102. Circuitry 102 prepares the concatenated transport block before the Early Error Correction (FEC) coding.
Em geral, a faixa dos tamanhos CTB (isto é, X) pode ser diferente da faixa dos tamanhos de bloco FEC suportados pelo esquema FEC subjacente na camada física para um sistema de comunicação. Portanto, é necessário definir uma regra que divide um CTB em segmentos que podem ser manejados eficientemente pelo FEC. Especificamente, os tamanhos de CTB (isto é, X) frequentemente são muito maiores do que o tamanho de bloco FEC máximo que o codificador FEC 104 pode manejar. Portanto, o CTB precisa ser segmentado pelo conjunto de circuitos 102 em um número de segmentos de tamanho menor e cada segmento precisa ser codificado pelo codificador FEC 104 em uma palavra código FEC separada. O conjunto de circuitos 102 utiliza uma regra de segmentação de bloco de código que é projetada para obter bom desempenho (isto é, o desempenho agregado dos segmentos para um determinado CTB) com FEC subjacente. Ele envolve os seguintes aspectos para qualquer tamanho de CTB determinado: ■ Escolha do número de segmentos C; ■ Escolha dos tamanhos de cada segmento; ■ Inserção dos bits de enchimento antes da codificação FEC e a remoção dos bits de enchimento após a codificação FEC, se o tamanho de segmento não puder ser manejado diretamente pelo FEC.In general, the range of CTB sizes (i.e., X) can be different from the range of FEC block sizes supported by the underlying FEC scheme in the physical layer for a communication system. Therefore, it is necessary to define a rule that divides a CTB into segments that can be handled efficiently by the FEC. Specifically, the CTB sizes (i.e., X) are often much larger than the maximum FEC block size that the FEC 104 encoder can handle. Therefore, the CTB needs to be segmented by circuitry 102 into a number of smaller sized segments and each segment needs to be encoded by the FEC encoder 104 in a separate FEC code word. Circuitry 102 uses a code block segmentation rule that is designed to achieve good performance (i.e., the aggregate performance of segments for a given CTB) with underlying FEC. It involves the following aspects for any given CTB size: ■ Choice of the number of C segments; ■ Choice of sizes for each segment; ■ Inserting the filler bits before FEC coding and removing the filler bits after FEC coding, if the segment size cannot be handled directly by the FEC.
As regras de segmentação propostas são particularmente úteis para o sistema de Acesso de Rádio Terrestre UMTS-Expandido (EUTRA) onde um turbo codificador pode ser definido para apenas um conjunto limitado de tamanhos de bloco FEC (tamanhos de intercalador). Ao contrário do turbo codificador 3GPP Versão 6 que define 5.075 intercaladores de tamanho contíguo, um para cada tamanho de intercalador Ki entre 40 bits e 5.114 bits, um turbo codificador EUTRA pode define um número limitado de tamanhos de bloco FEC Ktabie (por exemplo, 40~50 intercaladores com tamanhos não-contíguos variando de 128 bits a 6.144 bits) para cobrir um grande número de tamanhos de segmento (por exemplo, 6.144128+1 = 6.017 tamanhos). Quando o tamanho de segmento é igual a um tamanho de bloco FEC disponível, então o segmento pode ser considerado como um bloco de entrada FEC diretamente (desse modo não precisa ser inserção de bits de enchimento). Contudo, quando o tamanho de segmento não é igual a qualquer um dos tamanhos de bloco FEC disponíveis, o enchimento de bit de enchimento pode ser aplicado, e o próximo maior tamanho de bloco FEC disponível (isto é, tamanho de intercalador) escolhido a partir de Ktabie 107 pode ser usado. Número de segmentos: As regras de segmentação consideram as seguintes propriedades de turbo codificação. (a) A performance do turbo código melhora à medida que aumenta o tamanho do bloco FEC. (b) Aperfeiçoamento da performance do turbo código por intermédio de tamanhos crescentes de bloco FEC tem retornos decrescentes além de uns poucos milhares de bits. (c) Um CTB é recebido corretamente apenas se todos os segmentos forem recebidos corretamente.The proposed segmentation rules are particularly useful for the UMTS-Expanded Terrestrial Radio Access (EUTRA) system where a turbo encoder can be defined for only a limited set of FEC block sizes (interleaver sizes). Unlike the 3GPP Version 6 turbo encoder that defines 5,075 contiguous size interleavers, one for each Ki interleaver size between 40 bits and 5,114 bits, an EUTRA turbo encoder can define a limited number of Ktabie FEC block sizes (for example, 40 ~ 50 interleavers with non-contiguous sizes ranging from 128 bits to 6,144 bits) to cover a large number of segment sizes (for example, 6,144128 + 1 = 6,017 sizes). When the segment size is equal to an available FEC block size, then the segment can be considered as an FEC input block directly (so there is no need to insert fill bits). However, when the segment size is not equal to any of the available FEC block sizes, the fill bit filler can be applied, and the next largest available FEC block size (i.e., interleaver size) chosen from of Ktabie 107 can be used. Number of segments: The segmentation rules consider the following properties of turbo coding. (a) Turbo code performance improves as the FEC block size increases. (b) Improvement of the performance of the turbo code through increasing FEC block sizes has decreasing returns beyond a few thousand bits. (c) A CTB is received correctly only if all segments are received correctly.
As propriedades (a) e (c) indicam que a performance global provavelmente deve ser dominada pelo segmento tendo o pior desempenho. Desse modo, é preferível ter segmentos que sejam aproximadamente de tamanhos iguais de modo que eles são codificados com FEC com aproximadamente tamanhos de bloco iguais de FEC (e, portanto, proteção de erro aproximadamente igual acordada a partir da perspectiva de FEC). A propriedade (b) sugere que não é necessário incluir intercaladores para cada tamanho grande na tabela (Ktabie). Contudo, os tamanhos de bloco de FEC definidos em Ktabie podem depender de outros fatores. Por exemplo, i) para armazenamento/complexidade reduzida, um pequeno número de intercaladores em Ktabie pode ser desejável, e ii) o tamanho de intercalador máximo definido em Ktabie pode ser escolhido para limitar o número de segmentos por CTB. Desse modo limitando a penalidade de segmentação de um CTB. A penalidade de segmentação é a perda de performance devido à divisão de um CTB em vários segmentos em vez de codificar o CTB inteiro em uma palavra código FEC. A propriedade (c) sugere que o número mínimo de segmentos deve ser usado para reduzir a penalidade de segmentação.Properties (a) and (c) indicate that the overall performance is likely to be dominated by the segment having the worst performance. Thus, it is preferable to have segments that are approximately equal in size so that they are encoded with FEC with approximately equal block sizes of FEC (and therefore approximately equal error protection agreed from the perspective of FEC). Property (b) suggests that it is not necessary to include interleavers for each large size in the table (Ktabie). However, the FEC block sizes defined in Ktabie may depend on other factors. For example, i) for storage / reduced complexity, a small number of interleavers in Ktabie may be desirable, and ii) the maximum interleaver size defined in Ktabie can be chosen to limit the number of segments per CTB. Thereby limiting the targeting penalty of a CTB. The segmentation penalty is the loss of performance due to the division of a CTB into several segments instead of encoding the entire CTB in an FEC code word. Property (c) suggests that the minimum number of segments should be used to reduce the targeting penalty.
Considerando tudo que foi mencionado acima, o número de segmentos é “Γ^/^ιικιιΙ; onde Kmax é o tamanho máximo de bloco FEC definido em Ktabie. Supondo que CBSSi denota o tamanho de segmento do i° segmento (í = 1,... Cj do bloco de transporte concatenado, a soma de todos os segmentos é igual ao tamanho do bloco de transporte concatenado X, isto é, os tamanhos de segmento são limitados pela seguinte equação. A próxima seção descreve a determinação do tamanho de bloco FEC usado para codificação FEC, um para cada um dos C tamanhos de segmento.Considering everything mentioned above, the number of segments is “Γ ^ / ^ ιικιιΙ; where Kmax is the maximum FEC block size defined in Ktabie. Assuming that CBSSi denotes the segment size of the 1st segment (í = 1, ... Cj of the concatenated transport block, the sum of all segments is equal to the size of the concatenated transport block X, that is, the sizes of segment are limited by the following equation: The next section describes the determination of the FEC block size used for FEC encoding, one for each of the C segment sizes.
Determinação de tamanho de bloco FECFEC block size determination
Dado que um CTB de comprimento X é a entrada para a função de segmentação de bloco de código, a regra para determinar o tamanho de bloco FEC (tamanho de intercalador) para o turbo codificador conforme descrito na Versão 6 do padrão 3GPP é conforme a seguir onde Kmax = 5114 é o tamanho de intercalador máximo para Turbo código Versão 6, C é o número de segmentos (ou blocos de código), Ki é o tamanho de intercalador, e Y é o número total de bits de enchimento inseridos para o CTB de tamanho X quando C blocos de entrada FEC de tamanho Ki são usados. Em essência, um CTB de tamanho X é segmentado em C segmentos de tamanho aproximadamente igual, e cada segmento é codificado utilizando um turbo código com um intercalador de U bits. Se Y > 0, Y bits conhecidos são preenchidos para o início do primeiro segmento antes da codificação. Como os tamanhos de blocos FEC (isto é, intercaladores) são definidos para todos os tamanhos entre Kmin = 40 e Kmax = 5114 no turbo código 3GPP Versão 6, o número de bits de enchimento é limitado por C, o número de segmentos usados para segmentação de blocos de código.Given that a CTB of length X is the entry for the code block segmentation function, the rule for determining the FEC block size (interleaver size) for the turbo encoder as described in Version 6 of the 3GPP standard is as follows where Kmax = 5114 is the maximum interleaver size for Turbo code Version 6, C is the number of segments (or code blocks), Ki is the interleaver size, and Y is the total number of filling bits entered for the CTB of size X when C FEC input blocks of size Ki are used. In essence, a CTB of size X is segmented into C segments of approximately equal size, and each segment is encoded using a turbo code with a U bit interleaver. If Y> 0, Y known bits are filled in to the beginning of the first segment before encoding. As FEC block sizes (ie interleavers) are defined for all sizes between Kmin = 40 and Kmax = 5114 in the 3GPP Version 6 turbo code, the number of fill bits is limited by C, the number of segments used for segmentation of code blocks.
Contudo, em outros sistemas tal como aquele sendo considerado para EUTRA, os tamanhos de bloco FEC (tamanhos de intercalador) podem ser definidos apenas para tamanhos não-contíguos (um conjunto mais grosseiro de tamanhos de intercalador) Ktabie. Em tais casos, os tamanhos de segmento que não são iguais a quaisquer tamanhos de bloco FEC disponíveis (isto é, não definidos em Ktabie) precisam ser manejados utilizando bits de enchimento antes de codificação FEC (e perfuração após codificação para chegar a uma taxa de código desejada).However, in other systems such as the one being considered for EUTRA, FEC block sizes (interleaver sizes) can be defined only for non-contiguous sizes (a coarser set of interleaver sizes) Ktabie. In such cases, segment sizes that are not equal to any available FEC block sizes (ie, not defined in Ktabie) need to be handled using fill bits before FEC encoding (and drilling after encoding to reach a rate of desired code).
Supondo que um turbo codificador suporta apenas um número limitado de tamanhos de bloco FEC distribuídos entre Kmin e Kmax, ambos inclusivos, dois métodos simples de segmentação de blocos de código de um bloco de transporte concatenado de comprimento X utilizando Ktabie são descritos a seguir. Esses métodos utilizam o menor número possível de segmentos enquanto eles também reduzem o número de bits de enchimento que são exigidos para codificação.Assuming that a turbo encoder supports only a limited number of FEC block sizes distributed between Kmin and Kmax, both inclusive, two simple methods of segmenting code blocks of a concatenated transport block of length X using Ktabie are described below. These methods use as few segments as possible while they also reduce the number of padding bits that are required for encoding.
Permitir apenas um tamanho de bloco FECAllow only one FEC block size
Um método é o de modificar (1) e deixar todos os segmentos serem codificados com um único tamanho de intercalador Ki, onde onde i, l< = i< = T, é indexado no grupo de tamanhos de blocos FEC não-contíguos disponíveis em Ktabie, supondo que T tamanhos em Ktabie são classificados em ordem ascendente. Em essência, esse método escolhe o menor Ki a partir de Ktabie que é maior do que, ou igual a hM isto é, *T,-p7Cl+tf; onde £ »<*■(-*·,,. e A',-,<UZU.One method is to modify (1) and let all segments be encoded with a single interleaver size Ki, where i, l <= i <= T, is indexed in the group of non-contiguous FEC block sizes available in Ktabie, assuming that T sizes in Ktabie are sorted in ascending order. In essence, this method chooses the smallest Ki from Ktabie which is greater than, or equal to hM ie * T, -p7Cl + tf; where £ »<* ■ (- * · ,,. and A ', -, <UZU.
Observar que é atribuído que Ki-i = 0 quando 1 = 1. Portanto, o número de bits de enchimento é dado por Portanto, Y é maior do que δ em tamanho. Os exemplos a seguir ilustram como o número de tamanhos de bloco FEC disponíveis {Ktabie) afeta Y. • Se Ktabie tem todos os valores entre Zmin = 4 0 e Zmax = 5114, o número máximo de bits de enchimento é igual a C-1 . • Se Ktabie tem valores T = 100 distribuídos uniformemente entre Zmin = 40 e Zmax = 5114, o número total máximo de bits de enchimento enchidos em todos os segmentos é aproximadamente igual a 50xC.Note that Ki-i = 0 when 1 = 1 is assigned. Therefore, the number of filling bits is given by Therefore, Y is greater than δ in size. The following examples illustrate how the number of available FEC block sizes (Ktabie) affects Y. • If Ktabie has all values between Zmin = 40 and Zmax = 5114, the maximum number of filling bits is equal to C-1 . • If Ktabie has T = 100 values evenly distributed between Zmin = 40 and Zmax = 5114, the maximum total number of filled bits in all segments is approximately equal to 50xC.
Portanto, o número de bits de enchimento pode ser controlado mediante variação da granularidade de tamanho de bloco FEC em Ktabie. 0 número de bits de enchimento também pode ser reduzido utilizando outra abordagem como descrito a seguir. Contudo, antes de discutir o próximo método, observa-se que em um caso geral, qualquer b/ci> pode ser escolhido a partir de Ktabie para codificação FEC à custa de um número potencialmente aumentado de bits de enchimento. Nesse caso, os tamanhos de segmento obtidos após a segmentação de blocos de código satisfaz 055¾ s Kh para í=l,...C. Nesse caso, o conjunto de circuitos lógicos 106 determina o número de segmentos usando a seguinte relação Permitir apenas dois tamanhos de blocos FEC adjacentes Em vez de usar um tamanho de bloco FEC Ki para codificar todos os segmentos de um dado CTB, propõe-se que dois tamanhos de bloco FEC adjacentes Ki-i e Ki, Ki-kKi, 1<=I<=T, sejam selecionados a partir de Ktabie. Observar que é atribuído que Ki-i=0 quando 1=1. 0 número de segmentos C e o tamanho de bloco FEC maior Ki ainda são escolhidos para serem idênticos como nos casos anteriores, isto é, C ainda é computado como em (1) e Ki ainda é computado como (2) . Contudo, o número de segmentos codificados com tamanho Ki-i e tamanho Ki é determinado como a seguir (para facilidade de entendimento, todas as computações envolvidas são repetidas abaixo). Nesse caso, o conjunto de circuitos lógicos 106 realiza as seguintes operações para achar o número de segmentos, e Ci-i e Ci representam o número de segmentos que são codificados utilizando os tamanhos de bloco FEC Ki-i e Ki, respectivamente, onde Ki é o menor tamanho a partir dos tamanhos de bloco FEC disponíveis que é maior do que ou igual a e Di denota a diferença entre os tamanhos de intercaladores adjacentes Ki-i e Ki.Therefore, the number of filling bits can be controlled by varying the granularity of FEC block size in Ktabie. The number of fill bits can also be reduced using another approach as described below. However, before discussing the next method, it is noted that in a general case, any b / ci> can be chosen from Ktabie for FEC encoding at the expense of a potentially increased number of padding bits. In this case, the segment sizes obtained after segmenting code blocks satisfy 055¾ s Kh for í = l, ... C. In that case, logic circuitry 106 determines the number of segments using the following relationship Allow only two adjacent FEC block sizes Instead of using one FEC Ki block size to encode all segments of a given CTB, it is proposed that two adjacent FEC block sizes Ki-i and Ki, Ki-kKi, 1 <= I <= T, are selected from Ktabie. Note that Ki-i = 0 when 1 = 1 is assigned. The number of C segments and the larger FEC block size Ki are still chosen to be identical as in the previous cases, i.e., C is still computed as in (1) and Ki is still computed as (2). However, the number of segments encoded with size Ki-i and size Ki is determined as follows (for ease of understanding, all computations involved are repeated below). In this case, the logic circuitry 106 performs the following operations to find the number of segments, and Ci-i and Ci represent the number of segments that are encoded using the FEC block sizes Ki-i and Ki, respectively, where Ki is the smallest size from the available FEC block sizes that is greater than or equal to e Di denotes the difference between the adjacent interleaver sizes Ki-i and Ki.
Observar que em (4) Y não indica o número de bits de enchimento exigido se permitindo dois tamanhos adjacentes; mas indica que o número de bits de enchimento exigido tinha apenas um tamanho de Ki usado para todos os C segmentos.Note that in (4) Y does not indicate the number of filling bits required if two adjacent sizes are allowed; but it indicates that the required number of fill bits had only one Ki size used for all C segments.
Desse modo, a segmentação de blocos de código forma C segmentos, dos quais Ci-i segmentos são codificados FEC com um tamanho de bloco FEC Ki-i. Observar que quando Y<Di, (4) proporciona Ci-i=0, e esse método degenera para usar apenas um tamanho de bloco FEC de Ki (isto é, tamanho Ki-i é permitido, mas não efetivamente usado). Por outro lado, quando Y>=Di, esse método requer um número menor de bits de enchimento do que o enchimento de todos os C segmentos para o maior tamanho de bloco FEC Ki. Esse método é ótimo em que o número de bits de enchimento Y” adicionados por CTB é garantido para ser o mínimo enquanto utilizando o menor número possível de segmentos. Y” é determinado como a seguir r + CA, - A. „ (5) Pode ser comprovado que Y” é limitado por Di, independente de C, 0£ϊ’< K, -K,_,, (6) Nesse caso, os tamanhos de segmento obtidos após a segmentação de bloco de código têm as seguintes limitações, supondo (sem perda de generalidade que os primeiros Ci segmentos são codificados com Ki e o resto com Ki-i) .Thus, segmentation of code blocks forms C segments, of which Ci-i segments are FEC encoded with a FEC Ki-i block size. Note that when Y <Di, (4) provides Ci-i = 0, and this method degenerates to use only one FEC block size of Ki (ie, size Ki-i is allowed, but not actually used). On the other hand, when Y> = Di, this method requires a smaller number of filling bits than filling all C segments for the largest FEC Ki block size. This method is great in that the number of filling bits Y ”added by CTB is guaranteed to be the minimum while using the least possible number of segments. Y ”is determined as follows r + CA, - A.„ (5) It can be proved that Y ”is limited by Di, independent of C, 0 £ ϊ '<K, -K, _ ,, (6) In this case, the segment sizes obtained after the code block segmentation have the following limitations, assuming (without loss of generality that the first Ci segments are coded with Ki and the rest with Ki-i).
Retornando à Figura 1, conforme discutido acima, um tamanho de bloco FEC adequado precisa ser escolhido a partir da Tabela 107 de tamanhos de blocos FEC não-contíguos. 0 conjunto de circuitos lógicos 106 realiza a tarefa de escolher o tamanho/tamanhos de blocos FEC apropriados conforme discutido acima. Um exemplo da Tabela 107 é fornecido na Tabela 1. Por exemplo, no primeiro caso, o conjunto de circuitos lógicos 106 escolhe o tamanho de bloco FEC a partir dos tamanhos de bloco FEC não-contíguos disponíveis entre Kmin e Kmax, e em que Kmin<=Ki< = Kmax, e em que Ki se baseia adicionalmente em X. Particularmente, se um único tamanho de bloco FEC Ki deve ser usado, o conjunto de circuitos lógicos 106 escolhe o menor Ki (a partir da Ktabie) que não é menor do que ruu. isto é, íf, -p/cl+d; onde δ>0 , e ai < r.r/cl . Se, contudo, dois tamanhos de bloco FEC devem ser usados, Ki-i e Ki são determinados com a equação (4) dando o número de segmentos que são codificados utilizando os tamanhos de bloco FEC Ki-i e Ki.Returning to Figure 1, as discussed above, a suitable FEC block size needs to be chosen from Table 107 of non-contiguous FEC block sizes. The logic circuitry 106 performs the task of choosing the appropriate FEC block size / sizes as discussed above. An example from Table 107 is provided in Table 1. For example, in the first case, logic circuitry 106 chooses the FEC block size from the non-contiguous FEC block sizes available between Kmin and Kmax, and where Kmin <= Ki <= Kmax, and on which Ki is additionally based on X. Particularly, if a single FEC Ki block size is to be used, logic circuitry 106 chooses the smallest Ki (from Ktabie) that is not smaller than ruu. that is, íf, -p / cl + d; where δ> 0, and ai <r.r / cl. If, however, two FEC block sizes are to be used, Ki-i and Ki are determined with equation (4) giving the number of segments that are encoded using the FEC block sizes Ki-i and Ki.
Tabela 1: 0 conjunto de tamanhos de bloco FEC para os quais o intercalador interno de turbo codificador é definido O codificador FEC subjacente 104 suporta apenas um conjunto limitado de tamanhos de bloco FEC (ou tamanhos de entrada). Sem perda de generalidade, supõe-se que o codificador FEC 104 seja um turbo codificador, e o conjunto de tamanhos de bloco FEC suportados pelo turbo codificador seja o conjunto de tamanhos de intercalador para os quais o intercalador interno de turbo código é definido. Contudo, aqueles de conhecimento comum na técnica reconhecerão que outros esquemas FEC podem ser usados em 104, incluindo códigos de verificação de paridade de baixa densidade (LDPC); códigos convolucionais; turbo códigos de bloco; códigos Reed-Solomon, etc.Table 1: The set of FEC block sizes for which the internal turbo encoder interleaver is defined The underlying FEC encoder 104 supports only a limited set of FEC block sizes (or input sizes). Without loss of generality, the FEC 104 encoder is assumed to be a turbo encoder, and the set of FEC block sizes supported by the turbo encoder is the set of interleaver sizes for which the internal turbo code interleaver is defined. However, those of ordinary skill in the art will recognize that other FEC schemes can be used in 104, including low density parity check codes (LDPC); convolutional codes; turbo block codes; Reed-Solomon codes, etc.
Quando o número de segmentos C e o tamanho de bloco FEC para cada segmento forem determinados, essa informação é passada para o conjunto de circuitos de segmentação de bloco de código 102 onde o CTB (X bits) segmentado em C segmentos os quais são codificados com tamanho de bloco FEC Ki, se apenas um tamanho de bloco FEC for permitido. Alternativamente, se dois tamanhos de bloco FEC adjacentes forem permitidos, o conjunto de circuitos de segmentação de bloco de códigos 102 pode emitir Ci segmentos os quais podem ser codificados com tamanho de bloco FEC Ki e Ci-i segmentos os quais devem ser tamanho de bloco FEC codificado Ki-i.When the number of C segments and the FEC block size for each segment are determined, this information is passed to the set of code block segmentation circuits 102 where the CTB (X bits) segmented into C segments which are encoded with FEC Ki block size, if only one FEC block size is allowed. Alternatively, if two adjacent FEC block sizes are allowed, code block segmentation circuitry 102 can output Ci segments which can be encoded with FEC block size Ki and Ci-i segments which must be block size Ki-i encoded FEC.
Inserção de Bit de Enchimento O número de bits de enchimento (preenchidos para cada segmento) pode ser determinado com base no tamanho de segmento e no tamanho de bloco FEC sendo usado para codificação FEC do segmento. Há ao menos duas formas de distribuir os bits de enchimento totais nos C segmentos. · Enchimento concentrado. Colocar os bits de enchimento no menor número possível de segmentos sem tornar os tamanhos dos segmentos muito pequenos. Em um exemplo, todos os bits de enchimento podem aparecer no início do primeiro segmento. A vantagem é que apenas um segmento (contendo todos os bits de enchimento) precisa ser manipulado separadamente. Além disso, os bits de enchimento podem ser preenchidos no segmento que é codificado com o maior tamanho de bloco FEC Ki mais propriamente do que o menor tamanho de bloco FEC Ki-i quando dois tamanhos de bloco FEC são usados para um CTB. Esse método é particularmente atraente ao permitir dois tamanhos de bloco FEC adjacentes para codificação. · Enchimento distribuído. Distribuir os bits de enchimento igualmente (tanto quanto possível) em vários segmentos. Os bits de enchimento podem ser distribuídos em tantos quantos todos os C segmentos.Filling Bit Insertion The number of filling bits (filled for each segment) can be determined based on the segment size and FEC block size being used for segment FEC encoding. There are at least two ways to distribute the total fill bits across the C segments. · Concentrated filling. Place the filling bits in as few segments as possible without making the segment sizes too small. In one example, all filler bits can appear at the beginning of the first segment. The advantage is that only one segment (containing all the filling bits) needs to be manipulated separately. In addition, the filler bits can be filled in the segment that is encoded with the largest FEC Ki block size rather than the smallest FEC Ki-i block size when two FEC block sizes are used for a CTB. This method is particularly attractive in that it allows two adjacent FEC block sizes for encoding. · Distributed filling. Distribute the filling bits evenly (as much as possible) in several segments. The filling bits can be distributed over as many as all C segments.
Para implementação eficiente do transmissor e do receptor, enchimento concentrado é preferido. Uma modalidade preferida é a de apensar Y” (se permitindo dois tamanhos de bloco FEC adjacentes; Y se permitindo apenas um tamanho de bloco FEC) bits de enchimento consecutivos na frente de um dois segmentos (por exemplo, o primeiro ou o último) utilizando o tamanho de bloco FEC Ki antes de enviar o mesmo para o codificador. Em termos de performance, é equivalente a apensar Y'' bits de enchimento consecutivos na extremidade de um segmento tendo tamanho de bloco FEC Ki.For efficient implementation of the transmitter and receiver, concentrated filling is preferred. A preferred modality is to append Y ”(allowing two adjacent FEC block sizes; Y if allowing only one FEC block size) consecutive fill bits in front of a two segments (for example, the first or the last) using the FEC Ki block size before sending it to the encoder. In terms of performance, it is equivalent to appending Y '' consecutive filling bits at the end of a segment having FEC Ki block size.
Retornando à Figura 1, para cada segmento (produzido pelo conjunto de circuitos 102), uma palavra código FEC é determinada utilizando as etapas de inserir os bits de enchimento no segmento para formar um bloco de entrada FEC; codificar FEC o bloco de entrada FEC; e descartar os bits relacionados aos bits de enchimento.Returning to Figure 1, for each segment (produced by circuitry 102), an FEC code word is determined using the steps of inserting the filling bits in the segment to form an FEC input block; FEC code the FEC input block; and discard the bits related to the filler bits.
Cada segmento produzido pelo conjunto de circuitos 102 é passado para o conjunto de circuitos de enchimento 103 onde ocorre a inserção do bit de enchimento. Se nenhum bit de enchimento for exigido, então o conjunto de circuitos de enchimento é transparente, isto é, nenhum bit de enchimento é adicionado (Kfiiier=0) . Os segmentos (junto com os bits de enchimento) são então passados para o turbo codificador 104 onde turbo codificação dos C segmentos leva a C palavras código FEC. Os bits de enchimento são então descartados pelo conjunto de circuitos 105 e as C palavras código resultantes são apropriadamente transmitidas pelo conjunto de circuitos de transmissão 108. Se nenhum bit de enchimento for adicionado pelo conjunto de circuitos 103, então o conjunto de circuitos de descartar enchimento 105 é transparente, isto é, nenhum bit de enchimento é removido (Kfiiier=0) . Observar que é possível que o conjunto de circuitos 105 possa não descartar quaisquer bits correspondendo aos bits de enchimento. A Figura 2 é um diagrama de blocos de um receptor. Durante operação o vetor de sinal recebido segue através do conjunto de circuitos de de-segmentação de bloco de código 202 o qual organiza porções do vetor de sinal recebido de acordo com o segmento com o qual elas estão associadas. O tamanho de segmento, número de segmentos, tamanho de bloco FEC usados para turbo decodificar cada segmento, número de bits de enchimento podem ser determinados utilizando conjunto de circuito lógico 213 e tabela de tamanho de bloco FEC disponível 215 de uma forma similar àquela no codificador. O conjunto de circuitos de manejo de enchimento 204 utiliza o conhecimento da localização dos bits de enchimento para favorecer o turbo codificador 206, por exemplo, mediante ajuste das LLRs correspondendo aos bits de enchimento em uma magnitude elevada. Após a turbo decodificação, o conjunto de circuitos 208 descarta os bits de enchimento para obter estimativa de um segmento. O montador de bloco de código 211 monta o transporte estimado mediante ação de adequadamente coletar e arranjar as estimativas dos segmentos obtidos a partir do conjunto de circuitos 208.Each segment produced by the circuitry 102 is passed to the filling circuitry 103 where the filling bit is inserted. If no filling bits are required, then the filling circuitry is transparent, that is, no filling bits are added (Kfiiier = 0). The segments (together with the filler bits) are then passed to the turbo coder 104 where turbo coding of the C segments leads to C FEC code words. The filler bits are then discarded by the circuitry 105 and the resulting C code words are appropriately transmitted by the transmission circuitry 108. If no filler bit is added by the circuitry 103, then the discard filler circuitry 105 is transparent, that is, no filling bits are removed (Kfiiier = 0). Note that it is possible that circuitry 105 may not discard any bits corresponding to the filler bits. Figure 2 is a block diagram of a receiver. During operation the received signal vector follows through the set of code block de-segmentation circuits 202 which organizes portions of the received vector according to the segment with which they are associated. The segment size, number of segments, FEC block size used to turbo decode each segment, number of padding bits can be determined using logic circuit set 213 and available FEC block size table 215 in a similar way to that in the encoder . The filling management circuitry 204 uses the knowledge of the location of the filling bits to favor the turbo encoder 206, for example, by adjusting the LLRs corresponding to the filling bits in a high magnitude. After turbo decoding, circuitry 208 discards the fill bits to obtain a segment estimate. The code block assembler 211 assembles the estimated transport through the action of properly collecting and arranging the estimates of the segments obtained from the circuitry 208.
Remoção dos bits de paridade do codificador constituinte Essa seção provê uma forma específica de determinar a palavras código FEC. O método que tira proveito do conhecimento da inserção de bits de conhecimento no transmissor é descrito. Especificamente, o método determina quais bits (bits não apenas sistemáticos como também de paridade) podem ser descartados a partir da saída de turbo codificador com nenhuma, ou apenas insignificantes, degradação de desempenho. Em geral, os bits de enchimento são conhecidos e, portanto, os bits sistemáticos desses bits (igual aos bits conhecidos) podem ser descartados antes da transmissão. Contudo, não é evidente se quaisquer bits de paridade podem ser descartados. A Figura 3 é um diagrama de blocos do turbo codificador 104 da Figura 1. Durante a operação, o bloco de entrada de comprimento de Ki bits entra tanto no intercalador 301 como no codificador constituinte 302. O intercalador 301 intercala o bloco de entrada e passa o bloco de entrada em ordem intercalada para o codificador constituinte 303. O codificador constituinte 303 então codifica o bloco de entrada intercalado. De uma maneira similar, o codificador constituinte 302 codifica o bloco de entrada original. O bloco de palavra código x é composto de bloco sistemático (igual ao bloco de entrada FEC), saída do codificador constituinte 302, e saída do codificador constituinte 303. O bloco de palavra código x é então enviado ao conjunto de circuitos 105.Removing the constituent encoder parity bits This section provides a specific way of determining the FEC code words. The method that takes advantage of the knowledge of inserting knowledge bits in the transmitter is described. Specifically, the method determines which bits (not only systematic but also parity bits) can be discarded from the turbo encoder output with no, or only negligible, performance degradation. In general, the filling bits are known and, therefore, the systematic bits of these bits (same as the known bits) can be discarded before transmission. However, it is not clear whether any parity bits can be discarded. Figure 3 is a block diagram of the turbo encoder 104 of Figure 1. During operation, the Ki bit length input block enters both interleaver 301 and constituent encoder 302. Interleaver 301 interleaves the input block and passes the input block in interleaved order for constituent encoder 303. Constituent encoder 303 then encodes the interleaved input block. In a similar manner, constituent encoder 302 encodes the original input block. The code word block x consists of a systematic block (same as the FEC input block), output from constituent encoder 302, and output from constituent encoder 303. The code word block x is then sent to circuitry 105.
Em um turbo codificador convencional tal como, por exemplo, turbo códigos finais, o estado inicial dos codificadores constituintes (conteúdo de registrador de deslocamento) é supostamente de todos zeros. Em tal caso, quando Kfiiier bits de enchimento (normalmente 0) são inseridos no início do bloco de entrada de turbo código, os bits sistemáticos e os bits de paridade do codificador constituinte 302 correspondendo às posições de Kfiiier bit, são todos zeros. Portanto, esses bits podem ser descartados no transmissor e o receptor pode utilizar esse conhecimento ao realizar a turbo decodificação. Contudo, no codificador constituinte 303, os Kfiiier bits são embaralhados devido ao intercalador de turbo código e, portanto, os bits de paridade do codificador constituinte 303 correspondendo aos bits de enchimento não são conhecidos e assim não podem ser simplesmente descartados.In a conventional turbo encoder such as, for example, final turbo codes, the initial state of the constituent encoders (displacement register content) is supposed to be all zeros. In such a case, when Kfiiier filling bits (usually 0) are inserted at the beginning of the turbo code input block, the systematic bits and the parity bits of the constituent encoder 302 corresponding to the Kfiiier bit positions, are all zeros. Therefore, these bits can be discarded at the transmitter and the receiver can use this knowledge when performing turbo decoding. However, in the constituent encoder 303, the Kfiiier bits are scrambled due to the turbo code interleaver and therefore the parity bits of the constituent encoder 303 corresponding to the filler bits are not known and thus cannot be simply discarded.
Quando o turbo codificador tem codificadores constituintes de tail-biting, o estado inicial dos codificadores constituintes pode não ser sempre zero. Para códigos tail-biting, o estado inicial e o estado final para um codificador constituinte são iguais e eles dependem do bloco de entrada. Portanto, quando Kfiiier bits de enchimento consecutivos (isto é, zeros) são inseridos no início do bloco de entrada de turbo código, os bits de paridade do codificador constituinte 302 correspondendo às posições de Kfiiier bits nem sempre são zeros. Contudo, pode ser comprovado que a maioria desses Kfiiier bits de paridade do codificador constituinte 302 não carregam informação.When the turbo encoder has tail-biting constituent encoders, the initial state of the constituent encoders may not always be zero. For tail-biting codes, the starting state and ending state for a constituent encoder are the same and they depend on the input block. Therefore, when Kfiiier consecutive padding bits (i.e., zeros) are inserted at the beginning of the turbo code input block, the parity bits of the constituent encoder 302 corresponding to the positions of Kfiiier bits are not always zeros. However, it can be shown that most of these Kfiiier parity bits of constituent encoder 302 do not carry information.
Em geral, grupos de bits de enchimento consecutivos são inseridos em um segmento para formar um bloco FEC em que o comprimento do grupo é um múltiplo de 2m-1 ( = 7 para os códigos convolucionais constituintes dentro do turbo codificador 3GPP). Então, o bloco de entrada FEC é codificado FEC e os bits de paridade relacionados aos bits de enchimento são descartados. O codificador FEC pode ser um código convolucional tail-biting usado isoladamente, ou um código convolucional tail-biting usado como um código constituinte de um turbo codificador.In general, groups of consecutive fill bits are inserted into a segment to form an FEC block in which the length of the group is a multiple of 2m-1 (= 7 for the constituent convolutional codes within the 3GPP turbo encoder). Then, the FEC input block is FEC encoded and the parity bits related to the fill bits are discarded. The FEC encoder can be a tail-biting convolutional code used alone, or a tail-biting convolutional code used as a constituent code of a turbo encoder.
Especificamente, quando usados para turbo códigos com códigos constituintes tail-biting, grupos de bits sistemáticos correspondendo aos bits de enchimento podem ser descartados; e os bits de paridade correspondendo aos grupos de bits de enchimento na saída de um codificador constituinte podem ser descartados, em que o codificador constituinte pega o bloco de entrada FEC sem intercalação para turbo codificadores tail-biting. Isso pode ser mostrado como a seguir.Specifically, when used for turbo codes with tail-biting constituent codes, groups of systematic bits corresponding to the fill bits can be discarded; and the parity bits corresponding to the groups of padding bits at the output of a constituent encoder can be discarded, wherein the constituent encoder takes the FEC input block without interleaving for tail-biting turbo encoders. This can be shown as follows.
Deixemos o estado do registrador de deslocamento do codificador constituinte 302 na etapa i ser S(i), deixemos m ser o número de elementos no registrador de deslocamento, e deixemos γ ser qualquer número inteiro maior do que zero. Quando (2m-l)x/zeros são introduzidos no codificador constituinte a partir da etapa i + 1 para a etapa i+(2m-l)xy, o que se segue é uma propriedade do codificador convolucional recursivo (tal como aquele usado no turbo código 3GPP Versão 6), S(i)= S(i+(2”-l)x^ (7) Observar que S(i) pode não ser uma constante. Além disso, os estados S(j) intermediários podem não ser uma constante ou igual ao estado S(í) , i<j< = i+ (2“-l) χγ) .Let the state of the displacement register of the constituent encoder 302 in step i be S (i), let m be the number of elements in the displacement register, and let γ be any integer greater than zero. When (2m-l) x / zeros are entered in the constituent encoder from step i + 1 to step i + (2m-l) xy, the following is a property of the recursive convolutional encoder (such as that used in the turbo code 3GPP Version 6), S (i) = S (i + (2 ”-l) x ^ (7) Note that S (i) may not be a constant, and intermediate S (j) states may not be a constant or equal to the state S (í), i <j <= i + (2 "-l) χγ).
Portanto, o estado do codificador constituinte permanece inalterado entre a etapa i+1 até a etapa i+(2“-1)χχ. Portanto, o transmissor pode tirar proveito de (7) mediante descarte da saída de codificador constituinte durante aquelas etapas, uma vez que esses bits de enchimento não mudam o estado do registrador de deslocamento e desse modo não proporcionam informação para o decodificador. 0 decodificador dentro do receptor também pode tirar proveito de (7) similarmente com base no conhecimento das posições e valores dos bits de enchimento. A seguir, o método acima é descrito com um exemplo onde Kfiiier bits de enchimento (zeros) são inseridos e constituem posições na entrada de um turbo código tail-biting.Therefore, the state of the constituent encoder remains unchanged between step i + 1 to step i + (2 “-1) χχ. Therefore, the transmitter can take advantage of (7) by discarding the constituent encoder output during those steps, since these fill bits do not change the state of the shift register and thus do not provide information to the decoder. The decoder within the receiver can also take advantage of (7) similarly based on knowledge of the positions and values of the fill bits. Next, the above method is described with an example where Kfiiier padding bits (zeros) are inserted and constitute positions at the entry of a tail-biting turbo code.
Como Kfiiier bits de enchimento consecutivos (zeros) são inseridos no bloco de entrada de turbo código, e, portanto, pxyx(2m-l) bits de paridade do codificador constituinte 302 podem ser descartados, onde p é o número de bits de paridade na saída do codificador constituinte 302 que são gerados para cada bit no bloco de entrada FEC. Portanto, apenas os bits de paridade correspondendo aos grupos de bits de enchimento na saída do codificador constituinte 302 são descartados, em que o codificador constituinte 302 pega o bloco de entrada FEC sem intercalação para turbo codificadores tail-biting.As Kfiiier consecutive filler bits (zeros) are inserted into the turbo code input block, and therefore pxyx (2m-l) parity bits from constituent encoder 302 can be discarded, where p is the number of parity bits in the output of constituent encoder 302 that are generated for each bit in the FEC input block. Therefore, only the parity bits corresponding to the groups of padding bits at the output of constituent encoder 302 are discarded, where constituent encoder 302 takes the FEC input block without interleaving for tail-biting turbo encoders.
Para um turbo codificador 3GPP tail-bitincr, d=1 no codificador constituinte 1, m=3 . Desse modo bits de paridade podem ser descartados a partir do codificador constituinte 302 para Kfiiier bits de enchimento consecutivos. Como m=3, no máximo apenas 6 bits de paridade correspondendo aos Kfiiier bits de enchimento do codificador constituinte 302 podem precisar ser mantidos na saída do codificador constituinte 302.For a tail-bitincr 3GPP turbo encoder, d = 1 in constituent encoder 1, m = 3. In this way, parity bits can be discarded from the constituent encoder 302 for consecutive fill bits. As m = 3, at most only 6 parity bits corresponding to the Kfiiier filling bits of constituent encoder 302 may need to be maintained at the output of constituent encoder 302.
No codificador constituinte 303, os Kfiiier bits de enchimento podem ser dispersos devido ao intercalador de turbo código. Portanto, pode não ser possível descartar os bits de paridade a partir do codificador constituinte 303 sem afetar o desempenho. A seção a seguir descreve alguns cenários exemplares nos quais a regra de segmentação de bloco de código pode ser usada, por exemplo, Repetição Híbrida-Automática reQuest (HARQ), Múltiplas Entradas, Múltiplas Saídas (MIMO), etc.In the constituent encoder 303, the Kfiiier filling bits can be dispersed due to the turbo code interleaver. Therefore, it may not be possible to discard the parity bits from the constituent encoder 303 without affecting performance. The following section describes some exemplary scenarios in which the code block segmentation rule can be used, for example, ReQuest Hybrid-Automatic Repeat (HARQ), Multiple Inputs, Multiple Outputs (MIMO), etc.
Formador de Bloco de Transporte (TB) A regra de segmentação de bloco de código descrita acima é aplicada a um bloco de transporte concatenado (CTB) em canal ARQ híbrido (HARQ). Antes da segmentação de bloco de código, os bits de informação que precisam ser enviados a um único usuário a partir da estação base dentro de um intervalo de tempo de transmissão (TTI) podem precisar ser divididos em ao menos um bloco de transporte, desse modo seguindo através de ao menos um canal HARQ. Por exemplo, a Figura 4 mostra um exemplo em que os bits de informação são transmitidos utilizando dois canais HARQ (correspondendo a HARQ1, e HARQ2), e dois blocos de transporte TB1 e TB2. Durante operação, os bits de informação de comprimento A são recebidos pelo conjunto de circuito de formação TB 402 para ser transmitidos em um ou mais fluxos espaciais. O conjunto de circuitos 402 designa X' bits como um bloco de transporte TB1, onde X'<A; o processador HARQ1 404 anexa CRC bits aos X' bits para formar o bloco de transporte concatenado de comprimento X; o bloco de transporte concatenado de comprimento X é mapeado para um primeiro canal HARQ. O bloco de transporte concatenado é enviado para o conjunto de circuitos de segmentação de bloco de código 102. O conjunto de circuitos 402 designa W'=A-X' bits a partir dos bits de informação como um segundo bloco de transporte TB2; o processador HARQ2 406 anexa os bits CRC a Y bits para formar um segundo bloco de transporte concatenado; o bloco de transporte concatenado é mapeado para um segundo canal HARQ. O bloco de transporte concatenado é enviado ao conjunto de circuitos de segmentação de bloco de código 102.Transport Block Maker (TB) The code block segmentation rule described above is applied to a concatenated transport block (CTB) in a hybrid ARQ channel (HARQ). Before code block segmentation, the information bits that need to be sent to a single user from the base station within a transmission time interval (TTI) may need to be divided into at least one transport block, thus following through at least one HARQ channel. For example, Figure 4 shows an example in which information bits are transmitted using two HARQ channels (corresponding to HARQ1, and HARQ2), and two transport blocks TB1 and TB2. During operation, information bits of length A are received by the TB 402 forming circuit pack to be transmitted in one or more spatial streams. Circuitry 402 designates X 'bits as a transport block TB1, where X' <A; the HARQ1 404 processor appends CRC bits to the X 'bits to form the X-length concatenated transport block; the concatenated transport block of length X is mapped to a first HARQ channel. The concatenated transport block is sent to the code block segmentation circuitry 102. Circuitry 402 designates W '= A-X' bits from the information bits as a second transport block TB2; the HARQ2 processor 406 appends the CRC bits to Y bits to form a second concatenated transport block; the concatenated transport block is mapped to a second HARQ channel. The concatenated transport block is sent to the code block segmentation circuitry 102.
Observar que o conjunto de circuitos 404 e 406 pode realizar funções adicionais tais como outras funcionalidades relacionadas a HARQ, adicionando informação de controle, etc. Embora os conceitos na Figura 4 sejam ilustrados utilizando dois canais HARQ, eles podem ser facilmente estendidos para uma pluralidade de canais HARQ. Se mais do que um canal HARQ for suportado para um usuário dentro de um Intervalo de Tempo de Transmissão (TTI), a regra de segmentação de bloco de código pode ser aplicada a cada TB. Múltiplos canais HARQ podem ocorrer devido ao fato de ter muitas palavras código FEC (ou segmentos) por TTI por usuário, tal como a partir de largura de banda larga (por exemplo, 20 MHz), modulação de ordem superior (por exemplo, 64 QAM), MIMO de múltiplos fluxos, etc. Múltiplos canais HARQ também podem ser usados para os TBs que têm diferentes QoS, tal como VoIP e dados de melhor esforço.Note that circuits 404 and 406 can perform additional functions such as other HARQ-related functionality, adding control information, etc. Although the concepts in Figure 4 are illustrated using two HARQ channels, they can be easily extended to a plurality of HARQ channels. If more than one HARQ channel is supported for a user within a Transmission Time Range (TTI), the code block segmentation rule can be applied to each TB. Multiple HARQ channels can occur due to having many FEC code words (or segments) per TTI per user, such as from broadband (for example, 20 MHz), higher order modulation (for example, 64 QAM ), Multi-stream MIMO, etc. Multiple HARQ channels can also be used for TBs that have different QoS, such as VoIP and best effort data.
Uma palavra código MIMO compreende os bits que são enviados a um único usuário dentro de um TTI em um fluxo MIMO. Desse modo uma palavra código MIMO pode compreender uma ou mais palavras código FEC. Algumas vezes uma palavra código MIMO é usada para se referir aos bits em um fluxo MIMO.A MIMO code word comprises the bits that are sent to a single user within a TTI in a MIMO stream. In this way a MIMO code word can comprise one or more FEC code words. Sometimes a MIMO code word is used to refer to the bits in a MIMO stream.
Regras podem ser definidas para a criação de um TB. Em uma modalidade, um TB deve compreender não mais do que x (por exemplo, x=8) palavras código FEC (o valor de x é determinado pelo programador eNodeB em EUTRA). Em outra modalidade, se mais do que x palavras código FEC forem necessárias para um TB, então dois TBs são criados como a seguir. O pacote é dividido aproximadamente de forma igual entre os dois TBs, cada TB tendo quase o mesmo número de palavras código FEC de aproximadamente o mesmo tamanho. Em ainda outra modalidade, para palavras código FEC que devem ser enviadas para dois fluxos MIMO, cada uma pertence a um TB separado. Em ainda outra modalidade, para palavras código FEC que devem ser enviadas para três fluxos MIMO enquanto utilizando dois canais HARQ simultâneos, o primeiro (na média, o fluxo de melhor qualidade) pertence a um TB e o segundo e o terceiro fluxo pertencem a um segundo TB. Em ainda outra modalidade, quatro palavras código MIMO a serem enviadas utilizando dois canais HARQ, várias combinações são possíveis. Por exemplo, (a) TB1=1,2 TB2=3,4 (b) TB1=1,3 TB2=2,4 (c) TB1=1,2 TB2=2,3 (d) TB1=1, TB2 = 2,3,4. Aqui, TBi se refere ao TB de i° canal HARQ; os números 1 a 4 indicam o número de palavra código (ou fluxo) MIMO. A Figura 5 é um diagrama de blocos de processamento de receptor quando os bits de informação são recebidos através de ao menos um canal HARQ. Os bits recebidos a partir do montador de bloco de código 211 são introduzidos nos processadores de canal, apropriados, 504 e 506. A saída dos processadores de canal são os blocos de transporte estimados TB1 e TB2 os quais são introduzidos no conjunto de circuitos de montador TB 502 que combina os TBs e emite os bits de informação estimados. A Figura 6 é um fluxograma mostrando a operação do transmissor da Figura 1. O fluxo lógico começa na etapa 601 onde o conjunto de circuitos de segmentação recebe um bloco de transporte concatenado de comprimento X. Na etapa 603 o conjunto de circuitos lógicos acessa a tabela 107 e escolhe um tamanho de bloco FEC apropriado. Conforme discutido acima, em uma primeira modalidade da presente invenção o tamanho de bloco FEC Ki é determinado a partir de um grupo de tamanhos de bloco FEC não-contíguos localizados na tabela 107, onde os tamanhos de bloco FEC não-contíguos na tabela 107 estão entre Kmín θ Kmax, θ θγώ qus Kmin<=Ki<Kmax. Como discutido acima, Ki se baseia em X. X é determinado pelo conjunto de circuitos lógicos 106 a partir do bloco de transporte concatenado. Quando X é determinado, AÇ-fA/rl+á e -|"Λ/^Ηηλ1 sgo determinados. Em uma segunda modalidade da presente invenção os tamanhos de bloco FEC Ki e Ki-i são determinados, onde -ΓΧ/Cl+c!Rules can be defined for the creation of a TB. In one embodiment, a TB must comprise no more than x (for example, x = 8) FEC code words (the value of x is determined by the eNodeB programmer in EUTRA). In another embodiment, if more than x FEC code words are needed for one TB, then two TBs are created as follows. The packet is divided approximately equally between the two TBs, each TB having almost the same number of FEC code words of approximately the same size. In yet another modality, for FEC code words that must be sent to two MIMO streams, each belongs to a separate TB. In yet another modality, for FEC code words that must be sent to three MIMO streams while using two simultaneous HARQ channels, the first (on average, the best quality stream) belongs to a TB and the second and third stream belong to a according to TB. In yet another modality, four MIMO code words to be sent using two HARQ channels, several combinations are possible. For example, (a) TB1 = 1.2 TB2 = 3.4 (b) TB1 = 1.3 TB2 = 2.4 (c) TB1 = 1.2 TB2 = 2.3 (d) TB1 = 1, TB2 = 2.3.4. Here, TBi refers to the 1st channel TB HARQ; numbers 1 to 4 indicate the MIMO code word (or flow) number. Figure 5 is a block diagram of receiver processing when information bits are received through at least one HARQ channel. The bits received from the code block assembler 211 are introduced into the appropriate channel processors, 504 and 506. The output of the channel processors are the estimated transport blocks TB1 and TB2 which are introduced into the assembler circuitry TB 502 that combines the TBs and outputs the estimated information bits. Figure 6 is a flow chart showing the operation of the transmitter in Figure 1. The logic flow begins at step 601 where the segmentation circuitry receives a concatenated transport block of length X. In step 603 the logic circuitry accesses the table 107 and choose an appropriate FEC block size. As discussed above, in a first embodiment of the present invention the FEC Ki block size is determined from a group of non-contiguous FEC block sizes located in table 107, where the non-contiguous FEC block sizes in table 107 are between Kmín θ Kmax, θ θγώ qus Kmin <= Ki <Kmax. As discussed above, Ki is based on X. X is determined by the logic circuitry 106 from the concatenated transport block. When X is determined, AÇ-fA / rl + á and - | "Λ / ^ Ηηλ1 are determined. In a second embodiment of the present invention the FEC block sizes Ki and Ki-i are determined, where -ΓΧ / Cl + c !
Continuando, na etapa 605 o número de segmentos C e os tamanhos de bloco FEC são passados para o conjunto de circuitos de segmentação 102 e na etapa 607 o conjunto de circuitos de segmentação segmenta o bloco de transporte concatenado de comprimento X em C segmentos de tamanho substancialmente igual a Ki (ou alternativamente Ki e Ki-i) . Os bits de enchimento são adicionados (se necessário) na etapa 609 por intermédio do conjunto de circuitos 103 e na etapa 611 cada um dos C segmentos é codificado (por exemplo, uma palavra código FEC é determinada para cada um dos C segmentos) . Finalmente, na etapa 613 as palavras código FEC são transmitidas por intermédio do conjunto de circuitos de transmissão 108.Continuing, in step 605 the number of C segments and the FEC block sizes are passed to the segmentation circuit set 102 and in step 607 the segmentation circuit set segments the X length concatenated transport block into C size segments substantially equal to Ki (or alternatively Ki and Ki-i). The filling bits are added (if necessary) in step 609 via circuitry 103 and in step 611 each of the C segments is encoded (for example, an FEC code word is determined for each of the C segments). Finally, in step 613 the FEC code words are transmitted via the transmission circuitry 108.
Conforme discutido acima, a etapa de determinar uma palavra código FEC compreende as etapas de inserir bits de enchimento no segmento para formar um bloco de entrada FEC, codificar FEC o bloco de entrada FEC, e descartar os bits relacionados aos bits de enchimento. Essa etapa pode requerer a inserção de grupos de bits de enchimento consecutivos em um segmento para formar um bloco de entrada FEC onde o comprimento de grupo é um múltiplo de 7, codificar FEC o bloco de entrada FEC, e descartar os bits relacionados aos bits de enchimento. Descartar os bits de enchimento compreende as etapas de descartar os grupos de bits sistemáticos correspondendo aos bits de enchimento e descartar os bits de paridade correspondendo aos grupos de bits de enchimento na saída do codificador constituinte 1, onde o codificador constituinte pega o bloco de entrada FEC sem intercalação para os turbo codificadores tail-biting. A Figura 7 é um fluxograma mostrando a operação do receptor da Figura 2. 0 fluxo lógico começa na etapa 701 onde o tamanho de segmento, número de segmentos, tamanho de bloco FEC usado para turbo decodificar cada segmento, e o número de bits de enchimento são determinados utilizando o conjunto de circuitos lógicos 213 e a tabela 215. Conforme discutido acima, em uma primeira modalidade da presente invenção o tamanho de bloco FEC Ki é determinado a partir de um grupo de tamanhos de bloco FEC não-contíguos na tabela 215, onde os tamanhos de bloco FEC não-contíguos disponível na tabela 2 05 estão entre Kmin e Kmax, e em que Kmin< = Ki<Kmax. Como discutido acima, Ki se baseia em X. X é determinado pelo conjunto de circuitos lógicos 213 a partir do vetor de sinal recebido. 0 conjunto de circuitos lógicos 213 então determina ~ + í' e ( ΓΛ/λ\ιαχ1 . Em uma segunda modalidade da presente invenção os tamanhos de bloco FEC Ki e Ki-i são determinados, onde -rx/cl+í Na etapa 703 um vetor de sinal recebido segue através do conjunto de circuitos de de-segmentação de bloco de código 202 o qual organiza porções do vetor de sinal recebido de acordo com o segmento C ao qual elas estão associadas. Na etapa 705 o conjunto de circuitos de manejo de enchimento 204 utiliza o conhecimento da localização dos bits de enchimento para favorecer o turbo decodificador 206, para, por exemplo, ajustar as LLRs correspondendo aos bits de enchimento em uma magnitude elevada. Cada um dos C segmentos é decodificado na etapa 707. Após turbo decodificar, o conjunto de circuitos 208 descarta os bits de enchimento para obter a estimativa de um segmento (etapa 709). O montador de bloco de código 211 monta o transporte estimado mediante coleta e arranjo adequados das estimativas dos segmentos obtidos a partir do conjunto de circuitos 208 (etapa 711).As discussed above, the step of determining an FEC code word comprises the steps of inserting filler bits into the segment to form an FEC input block, FEC code the FEC input block, and discard the bits related to the filler bits. This step may require the insertion of groups of consecutive fill bits in a segment to form an FEC input block where the group length is a multiple of 7, FEC code the FEC input block, and discard the bits related to the filling. Discarding the filler bits comprises the steps of discarding the systematic bit groups corresponding to the filler bits and discarding the parity bits corresponding to the filler bit groups at the output of constituent encoder 1, where the constituent encoder takes the FEC input block without interleaving for the tail-biting turbo encoders. Figure 7 is a flow chart showing the operation of the receiver in Figure 2. The logic flow starts at step 701 where the segment size, number of segments, FEC block size used to turbo decode each segment, and the number of fill bits are determined using logic circuitry 213 and table 215. As discussed above, in a first embodiment of the present invention the FEC Ki block size is determined from a group of non-contiguous FEC block sizes in table 215, where the non-contiguous FEC block sizes available in table 2 05 are between Kmin and Kmax, and where Kmin <= Ki <Kmax. As discussed above, Ki is based on X. X is determined by the logic circuitry 213 from the received signal vector. The set of logic circuits 213 then determines ~ + í 'e (ΓΛ / λ \ ιαχ1. In a second embodiment of the present invention the FEC block sizes Ki and Ki-i are determined, where -rx / cl + í In step 703 a received signal vector follows through the set of code block de-segmentation circuits 202 which organizes portions of the received vector according to segment C to which they are associated. In step 705 the set of management circuits filler 204 uses knowledge of the location of the filler bits to favor the turbo decoder 206, for example, to adjust the LLRs corresponding to the filler bits to a high magnitude, each of the C segments is decoded in step 707. After turbo decode, circuitry 208 discards the filler bits to obtain a segment estimate (step 709). The code block assembler 211 assembles the estimated transport through proper collection and arrangement of the estimates of segments obtained from circuit set 208 (step 711).
Embora a invenção tenha sido particularmente mostrada e descrita com referência a uma modalidade específica, será entendido por aqueles versados na técnica que várias mudanças em forma e detalhes podem ser feitas na mesma sem se afastar do espírito e escopo da invenção. Pretende-se que tais mudanças sejam abrangidas pelo escopo das reivindicações a seguir.Although the invention has been particularly shown and described with reference to a specific modality, it will be understood by those skilled in the art that various changes in shape and details can be made therein without departing from the spirit and scope of the invention. Such changes are intended to fall within the scope of the following claims.
REIVINDICAÇÕES
Claims (8)
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US82821306P | 2006-10-04 | 2006-10-04 | |
US11/539,404 US8356232B2 (en) | 2006-10-06 | 2006-10-06 | Method and apparatus for encoding and decoding data |
PCT/US2007/078676 WO2008042586A2 (en) | 2006-10-04 | 2007-09-17 | Method and apparatus for encoding and decoding data |
Publications (4)
Publication Number | Publication Date |
---|---|
BRPI0717506A2 BRPI0717506A2 (en) | 2014-06-24 |
BRPI0717506A8 BRPI0717506A8 (en) | 2017-03-07 |
BRPI0717506B1 true BRPI0717506B1 (en) | 2019-12-03 |
BRPI0717506B8 BRPI0717506B8 (en) | 2019-12-17 |
Family
ID=39269076
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
BRPI0717506A BRPI0717506B8 (en) | 2006-10-04 | 2007-09-17 | method and apparatus for encoding and decoding data |
Country Status (9)
Country | Link |
---|---|
EP (1) | EP2080271B1 (en) |
JP (2) | JP4714941B2 (en) |
KR (1) | KR101429786B1 (en) |
CN (1) | CN101573872B (en) |
AR (1) | AR064591A1 (en) |
BR (1) | BRPI0717506B8 (en) |
ES (1) | ES2386911T3 (en) |
PL (1) | PL2080271T3 (en) |
WO (1) | WO2008042586A2 (en) |
Families Citing this family (8)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
JP5453268B2 (en) * | 2007-09-14 | 2014-03-26 | エージェンシー フォー サイエンス， テクノロジー アンド リサーチ | Bit string encoding method and encoding circuit |
JP4922242B2 (en) * | 2008-06-05 | 2012-04-25 | パナソニック株式会社 | Encoding device, encoding method, and Viterbi decoding device |
JP2010004416A (en) * | 2008-06-23 | 2010-01-07 | Fujitsu Ltd | Mobile radio apparatus |
US8726137B2 (en) * | 2009-02-02 | 2014-05-13 | Telefonaktiebolaget L M Ericsson (Publ) | Encoding and decoding methods for expurgated convolutional codes and convolutional turbo codes |
CN107659384A (en) * | 2012-11-16 | 2018-02-02 | 华为技术有限公司 | The method and apparatus of data processing |
EP3264613A4 (en) * | 2015-04-01 | 2018-04-11 | Huawei Technologies Co. Ltd. | Encoding method, apparatus, base station and user equipment |
WO2021044765A1 (en) * | 2019-09-04 | 2021-03-11 | 株式会社日立国際電気 | Communication system and communication method |
WO2022220394A1 (en) * | 2021-04-12 | 2022-10-20 | 삼성전자 주식회사 | Method for recovering lost transmitted data and electronic apparatus therefor |
Family Cites Families (8)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
JPH09321634A (en) * | 1996-05-27 | 1997-12-12 | Toshiba Corp | Block de-interleave device |
FI106758B (en) * | 1999-04-16 | 2001-03-30 | Nokia Networks Oy | Segmentation mechanism for block encoder |
US6397368B1 (en) * | 1999-12-06 | 2002-05-28 | Intellon Corporation | Forward error correction with channel adaptation |
JP3880542B2 (en) * | 2003-05-19 | 2007-02-14 | 松下電器産業株式会社 | Error correction encoding / decoding device and error correction encoding / decoding method |
JP3847733B2 (en) | 2003-06-12 | 2006-11-22 | 松下電器産業株式会社 | Multi-carrier communication method and communication apparatus therefor |
CN1691785A (en) * | 2004-04-19 | 2005-11-02 | 上海国皓电子有限公司 | Front-end device based on DVB digital television RF channel measurement |
WO2008013528A1 (en) * | 2006-07-25 | 2008-01-31 | Thomson Licensing | Recovery from burst packet loss in internet protocol based wireless networks using staggercasting and cross-packet forward error correction |
KR20080094192A (en) * | 2007-04-19 | 2008-10-23 | 엘지전자 주식회사 | Method for signal transmitting and apparatus for the same, method for signal receiving and apparatus for the same |
-
2007
- 2007-09-17 CN CN2007800375299A patent/CN101573872B/en active Active
- 2007-09-17 KR KR1020097006933A patent/KR101429786B1/en active IP Right Grant
- 2007-09-17 WO PCT/US2007/078676 patent/WO2008042586A2/en active Application Filing
- 2007-09-17 EP EP07842624A patent/EP2080271B1/en active Active
- 2007-09-17 PL PL07842624T patent/PL2080271T3/en unknown
- 2007-09-17 ES ES07842624T patent/ES2386911T3/en active Active
- 2007-09-17 BR BRPI0717506A patent/BRPI0717506B8/en active IP Right Grant
- 2007-09-28 JP JP2007252797A patent/JP4714941B2/en active Active
- 2007-10-03 AR ARP070104380A patent/AR064591A1/en active IP Right Grant
-
2010
- 2010-11-25 JP JP2010262461A patent/JP5110407B2/en active Active
Also Published As
Publication number | Publication date |
---|---|
JP5110407B2 (en) | 2012-12-26 |
JP4714941B2 (en) | 2011-07-06 |
EP2080271B1 (en) | 2012-07-11 |
CN101573872B (en) | 2013-06-12 |
ES2386911T3 (en) | 2012-09-05 |
CN101573872A (en) | 2009-11-04 |
WO2008042586A2 (en) | 2008-04-10 |
KR101429786B1 (en) | 2014-08-18 |
BRPI0717506B8 (en) | 2019-12-17 |
JP2011066932A (en) | 2011-03-31 |
BRPI0717506A8 (en) | 2017-03-07 |
JP2008092570A (en) | 2008-04-17 |
AR064591A1 (en) | 2009-04-15 |
EP2080271A2 (en) | 2009-07-22 |
BRPI0717506A2 (en) | 2014-06-24 |
KR20090074183A (en) | 2009-07-06 |
WO2008042586A3 (en) | 2008-07-03 |
PL2080271T3 (en) | 2012-10-31 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
CN109314602B (en) | Apparatus and method for error detection coding | |
US8356232B2 (en) | Method and apparatus for encoding and decoding data | |
CN107026709B (en) | Data packet coding processing method and device, base station and user equipment | |
BRPI0717506B1 (en) | method and apparatus for encoding and decoding data | |
US8543884B2 (en) | Communications channel parallel interleaver and de-interleaver | |
KR101221915B1 (en) | Method of transmitting data | |
US9240808B2 (en) | Methods, apparatus, and systems for coding with constrained interleaving | |
JP5481759B2 (en) | Wireless communication device using multi-layer cyclic redundancy check code | |
CN108282246B (en) | Information processing method, equipment and communication system | |
US9118350B2 (en) | Methods, apparatus, and systems for coding with constrained interleaving | |
US6859906B2 (en) | System and method employing a modular decoder for decoding turbo and turbo-like codes in a communications network | |
JP2008219892A (en) | Method and apparatus of encoding and decoding data | |
BRPI0721176B1 (en) | methods and apparatus for operating a turbo encoder | |
CN101667884A (en) | Method and device for coding channel and method and device for decoding channel | |
WO2007020678A1 (en) | Transmitter apparatus, coder apparatus and decoder apparatus | |
WO2007020677A1 (en) | Transmitter apparatus | |
KR20090084641A (en) | Method for determining transport block size and signal transmission method using the same | |
US9112534B2 (en) | Methods, apparatus, and systems for coding with constrained interleaving | |
KR101208555B1 (en) | Apparatus and method for transmitting data using a ctc(convolutional turbo code) encoder in a mobile communication system | |
BR112016028982B1 (en) | TRANSMITTER DEVICE AND RECEIVER DEVICE FOR WIRELESS COMMUNICATION SYSTEM, AND TRANSMISSION METHOD AND RECEPTION METHOD IN WIRELESS COMMUNICATION SYSTEM | |
JP2014209785A (en) | Methods and apparatus for programmable decoding of plural code types | |
TW202015349A (en) | Decoding device and decoding method |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
B25D | Requested change of name of applicant approved |
Owner name: MOTOROLA SOLUTIONS, INC. (US) |
|
B25A | Requested transfer of rights approved |
Owner name: MOTOROLA MOBILITY, INC. (US) |
|
B25E | Requested change of name of applicant rejected |
Owner name: MOTOROLA MOBILITY, INC. (US)Free format text: INDEFERIDO O PEDIDO DE ALTERACAO DE NOME CONTIDO NA PETICAO 20130041710 DE 16/05/2013, DEVIDO A AUSENCIA DE GUIA DE RECOLHIMENTO RELATIVA AO SERVICO. |
|
B25G | Requested change of headquarter approved |
Owner name: MOTOROLA MOBILITY, INC. (US) |
|
B25D | Requested change of name of applicant approved |
Owner name: GOOGLE TECHNOLOGY HOLDINGS LLC (US) |
|
B25A | Requested transfer of rights approved |
Owner name: GOOGLE TECHNOLOGY HOLDINGS LLC (US) |
|
B06T | Formal requirements before examination [chapter 6.20 patent gazette] |
Free format text: PARECER 6.20 |
|
B06A | Patent application procedure suspended [chapter 6.1 patent gazette] | ||
B09A | Decision: intention to grant [chapter 9.1 patent gazette] | ||
B16A | Patent or certificate of addition of invention granted [chapter 16.1 patent gazette] |
Free format text: PRAZO DE VALIDADE: 10 (DEZ) ANOS CONTADOS A PARTIR DE 03/12/2019, OBSERVADAS AS CONDICOES LEGAIS. (CO) 10 (DEZ) ANOS CONTADOS A PARTIR DE 03/12/2019, OBSERVADAS AS CONDICOES LEGAIS |
|
B16C | Correction of notification of the grant [chapter 16.3 patent gazette] |
Free format text: REFERENTE A RPI 2552 DE 03/12/2019, QUANTO AO DESENHO. |