CROSS-REFERENCE TO RELATED APPLICATION
This application is based upon and claims benefit of priority of the prior Greek Patent Application No. 20180100232, filed on May 29, 2018. The disclosure of the foregoing application is hereby incorporated by reference in its entirety.
BACKGROUND
This specification relates to determining architectures for neural networks that perform image processing tasks.
Neural networks are machine learning models that employ one or more layers of nonlinear units to predict an output for a received input. Some neural networks include one or more hidden layers in addition to an output layer. The output of each hidden layer is used as input to the next layer in the network, i.e., the next hidden layer or the output layer. Each layer of the network generates an output from a received input in accordance with current values of a respective set of parameters.
SUMMARY
This specification describes a system implemented as computer programs on one or more computers in one or more locations that determines an architecture for a neural network that is configured to perform a dense image prediction task.
Generally, a dense image prediction task is a task that requires making a respective prediction for each of a large number of pixels in an input image. Many dense image prediction task require assigning a label or otherwise making a prediction for each pixel of the image. Thus, dense image prediction tasks generally require the neural network to operate on high-resolution images and to maintain the resolution of the images throughout the processing pipeline.
To determine the architecture, the system obtains training data for the dense image prediction task. The system then determines an architecture for a neural network that is configured to perform the dense image prediction task, i.e., to receive inputs and generate outputs that conform to the requirements of the dense prediction task, using the training data.
In particular, the system searches a space of candidate architectures to identify one or more best performing architectures using the training data. Each candidate architecture in the space of candidate architectures includes (i) the same first neural network backbone that is configured to receive an input image and to process the input image to generate a plurality of feature maps and (ii) a different dense prediction cell configured to process the plurality of feature maps and to generate an output for the dense image prediction task. Thus, each candidate architecture includes the same neural network backbone as each other candidate architecture but has a different dense prediction cell from each other candidate architecture.
The system then determines the architecture for the neural network based on the best performing candidate architectures.
Particular embodiments of the subject matter described in this specification can be implemented so as to realize one or more of the following advantages.
The architecture search techniques described in this specification can determine a high-performing architecture for a dense prediction task in a computationally efficient manner. In particular, because dense prediction tasks require generating predictions for a large number of the pixels in the input image, such tasks require the network to operate on high resolution imagery. This makes existing architecture search techniques, e.g., techniques geared for image classification or other, non-dense image processing tasks, ill-suited for use for these tasks. This is because many of these tasks rely on low-resolution proxy tasks that would not be representative of the final dense image prediction task or require a search space to be searched that is so large as to make such searching computationally infeasible when operating on high-resolution images.
The described techniques, on the other hand, effectively limit the search space to identifying the best architecture for a dense prediction cell, resulting in architectures that have performance that exceeds the previous state-of-the-art in multiple dense image prediction tasks.
Moreover, by making use of the described techniques, the resulting architecture can be more computationally efficient than the previously state-of-the-art models while exceeding their performance. As examples of the kinds of results that the described techniques can achieve, the resulting architectures can achieve state-of-the-art performance on several dense prediction tasks, including achieving 82.7% mIOU accuracy on the Cityscapes data set (street scene parsing), 71.3% mIOU accuracy on the PASCAL-Person-Part data set (person-part segmentation), and 87.9% mIOU accuracy on the PASCAL VOC 2012 data set (semantic image segmentation). At the same time, the resulting architectures are more computationally efficient, requiring approximately half the parameters and half the computational cost as previous state of the art systems to achieve these levels of performance on these data sets.
Additionally, by making use of a smaller backbone during the search than will be included in the final architecture, the amount of resources consumed by the search process is reduced. Additionally, by pre-training the backbone, e.g., on an object segmentation task, and then holding the backbone fixed during the search, the amount of resources consumed by the search process is reduced. Additionally, by pre-computing and then caching the feature maps generated by the pre-trained backbone, the amount of resources consumed by the search is reduced. As a particular example, when the backbone is smaller and the feature maps generated by the pre-trained backbone are pre-computed and cached, the system can perform the search with much less latency and much greater data efficiency (i.e., using much less memory), than techniques that rely on training candidate neural networks without pre-caching inputs and without decreasing the size of the
The details of one or more embodiments of the subject matter described in this specification are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the subject matter will become apparent from the description, the drawings, and the claims.
BRIEF DESCRIPTION OF THE DRAWINGS
FIG. 1 shows an example neural architecture search system.
FIG. 2 shows an example candidate architecture.
FIG. 3 is a flow diagram of an example process for determining a final architecture.
FIG. 4 is a flow diagram of an example process for searching the space of candidate architectures.
Like reference numbers and designations in the various drawings indicate like elements.
DETAILED DESCRIPTION
This specification describes a system implemented as computer programs on one or more computers in one or more locations that determines an architecture for a neural network that is configured to perform a dense image prediction task.
Generally, a dense image prediction task is a task that requires making a respective prediction for each of a large number of pixels in an input image. Many dense image prediction tasks require assigning a label or otherwise making a prediction for each pixel of the image. Thus, dense image prediction tasks generally require the neural network to operate on high-resolution images.
One example of a dense image prediction task is an image segmentation task. In an segmentation task, the input is an image and the output is a respective label for every pixel in the image that classifies the content depicted at that pixel in the image.
One example of an image segmentation task is a person-part segmentation task, where the inputs are images of one or more people and the output is a respective label for every pixel in the image such that the labels classify which pixels correspond to which person parts (e.g., head, torso, legs, and so on) and which correspond to the background (i.e., do not depict any people).
Another example of an image segmentation task is a semantic image segmentation task. In a semantic image segmentation task, the input is an image and the output is a respective label for every pixel in the image that identifies which object class the pixel belongs to, e.g., from a set of multiple foreground object classes and one or more background object classes.
Another example of an image segmentation task is a scene parsing task. In a scene parsing task, the input is an image and the output is a respective label for every pixel in the image that identifies which portion of a scene depicted in the image the pixel belongs to.
Another example of a dense image prediction task is an object detection task. In an object detection task, the input is an image and the output is data that specifies which pixels of the image are parts of an image of an object. For example, the output may be a label for each pixel in the image that identifies whether the pixel is part of an image of an object. As another example, the output may be a score for each of a large number of bounding boxes in the image that indicates whether the bounding box is part of an image of an object.
FIG. 1 shows an example neural architecture search system 100. The neural architecture search system 100 is an example of a system implemented as computer programs on one or more computers in one or more locations, in which the systems, components, and techniques described below can be implemented.
The neural architecture search system 100 is a system that obtains training data 102 for training a neural network to perform a dense image prediction task and a validation set 104 for evaluating the performance of the neural network on the dense image prediction task. The system then uses the training data 102 and the validation set 104 to determine an architecture for a neural network that is configured to perform the dense image prediction task i.e., to receive inputs and generate outputs that conform to the requirements of the dense prediction task. The architecture defines the number of layers in the neural network, the operations performed by each of the layers, and the connectivity between the layers in the neural network, i.e., which layers receive inputs from which other layers in the neural network.
Generally, the training data 102 and the validation set 104 both include a set of training inputs and, for each training input, a respective target output that should be generated by the neural network to perform the dense image prediction task. For example, a larger set of training data may have been randomly partitioned to generate the training data 102 and the validation set 104. In the dense image prediction task setting, each training input is an image and the neural network output for the training input identifies the labels that should be assigned to some or all of the pixels in the training input.
The system 100 can receive the training data 102 and the validation set 104 in any of a variety of ways. For example, the system 100 can receive training data as an upload from a remote user of the system over a data communication network, e.g., using an application programming interface (API) made available by the system 100, and randomly divide the uploaded data into the training data 102 and the validation set 104. As another example, the system 100 can receive an input from a user specifying which data that is already maintained by the system 100 should be used for training the neural network, and then divide the specified data into the training data 102 and the validation set 104.
Generally, the system 100 determines the architecture for the neural network by searching a space of candidate architectures to identify one or more best performing architectures.
Each candidate architecture in the space of candidate architectures includes (i) the same first neural network backbone that is configured to receive an input image and to process the input image to generate a plurality of feature maps and (ii) a different dense prediction cell configured to process the plurality of feature maps and to generate an output for the dense image prediction task.
Thus, each candidate architecture includes the same neural network backbone as each other candidate architecture but has a different dense prediction cell from each other candidate architecture.
FIG. 2 shows a candidate neural network architecture 200. As described above, the architecture 200 receives a training input 220, i.e., one of the three images shown in FIG. 2, and generates a neural network output 250 that assigns labels to the training input. As shown in FIG. 2, the neural network output 250 is represented as an overlay over the corresponding input image, with pixels assigned the same label being in the same shade in the overlay.
The candidate neural network architecture includes a backbone 230 that is made up of multiple neural networks layers, e.g., convolutional layers optionally combined with other types of layers (batch normalization, pooling, and so on) and receives the training input 220 and generates feature maps that are provided as input to a dense prediction cell (DPC) 240. The dense prediction cell 240 processes the feature maps to generate the neural network output 250.
As indicated above, each candidate neural network in the search space has the same backbone 230 but all of the candidate neural networks have different DPCs 240. Thus, the search space for the architecture search is the space of possible architectures for the DPC 240.
An example of a space of possible architectures for the DPC 240 that can be searched by the system 100 follows.
For example, the DPC can have B branches, where B is a fixed integer greater than one. Each of the B branches of the DPC maps an input tensor to the branch to an output tensor by applying an operation to the input tensor. The DPC can then combine, e.g., concatenate, the output tensors generated by all of the B branches to generate a combined tensor output or use the output tensor generated by a designated one of the B branches, e.g., the last of the B branches in a processing order, as the combined tensor output. B can be, e.g., an integer in the range of 3 to 10, inclusive, with larger values of B allowing more flexibility and a larger search space but increasing the computational cost of the search process.
In some cases, the combined tensor output can be used as the output of the DPC 240 for the dense prediction task. In other cases, the DPC processes the combined tensor output through one or more output layers, e.g., a sigmoid output layer, to generate a final output.
Thus, the different architectures in the search space each specify (i) an input tensor from a set of input tensors to be provided as input to each of the B branches, and (ii) an operation from a set of operations to be performed by each of the B branches to generate the output tensor from the input tensor.
The input tensor for a given branch can be selected from a set that includes (i) the feature maps generated by the backbone and (ii) output tensors generated by any branches before the given branch in the processing order of the B branches. Thus, for the first branch in the processing order, the set includes only the feature maps generated by the backbone while for the last of the B branches in the processing order, the set includes (i) the feature maps generated by the backbone and (ii) output tensors generated by any of the B−1 other branches.
The operator space, i.e., the space of possible operations from which the operation performed by each of the B blocks is selected, can include one or more of the following: (1) a convolution with a 1×1 kernel, (2) one or more atrous separable convolutions, each having a different sampling rate, and (3) one or more spatial pyramid pooling operations, each having a respective grid size.
When the operator space includes multiple atrous separable convolutions, each of the atrous separable convolutions will have a different sampling rate. For example, the sampling rate can be defined as r_h×r_w, where each of r_h and r_w is selected from the set of {1, 2, 6, 9, . . . , 21}.
When the operator space includes multiple spatial pyramid pooling operations, each of the spatial pyramid pooling operations will have a different grid size. For example, the grid size can be defined as g_h×g_w, where each of g_h and g_w is selected from the set of {1, 2, 4, 8}.
Other examples of search spaces can include different operator spaces and different possible values for the sampling rates and grid sizes of the operators in the space.
Returning to the description of FIG. 1, the system 100 includes a candidate selection engine 130, a training engine 140, and a quality evaluation engine 150.
To search the space of candidate architectures, the system repeatedly performs a set of architecture search operations.
At each iteration of the operations, the candidate selection engine 130 selects one or more candidate architectures from the space of possible candidate architectures using quality measures for candidate architectures that have already been evaluated.
The training engine 140 then trains the selected candidate architectures on at least some of the training data 102 and the quality evaluation engine 150 evaluates the trained candidate architectures using the validation set 104.
Selecting candidate architectures, training the candidate architectures, and evaluating the quality of the architectures is described in more detail below with reference to FIGS. 3 and 4.
After the architecture search operations have been repeatedly performed, the system 100 can identify as the best performing candidate architectures a threshold, fixed number of candidate architectures evaluated during the search that had the best quality measures.
Once the system 100 has identified the best performing candidate architectures, the system 100 determines the final architecture for the neural network based on the best performing candidate architectures.
For example, the system 100 can generate, from each of the identified best performing candidates, a final architecture, and then train the final architectures to convergence on the dense prediction task. The system can then select the best performing, e.g., as determined based on a quality measure on the validation set 104, trained architecture as the architecture of the neural network.
In some implementations, the candidate architecture and the corresponding final architecture are the same.
In other implementations, however, the system 100 replaces the neural network backbone with a different, larger neural network backbone that has more parameters and that allows the final neural network to perform better on the dense prediction task.
In other words, in some cases, the system uses a smaller backbone for the architecture search than is employed by the final architecture.
For example, the system can employ an Xception architecture for the backbone in the final architecture while employing the MobileNet-v2 architecture for the candidate architectures, i.e., during the search. The MobileNet-v2 architecture requires roughly one twentieth the computational cost of the Xception architecture and cuts down the number of channels in the backbone feature maps from 2048 to 320 dimensions. The Xception architecture is described in more detail in F. Chollet. Xception: Deep learning with depthwise separable convolutions. In CVPR, 2017 while the MobileNet-v2 architecture is described in more detail in M. Sandler, A. Howard, M. Zhu, A. Zhmoginov, and L.-C. Chen. Mobilenetv2: Inverted residuals and linear bottlenecks. In CVPR, 2018.
Using the smaller backbone can allow the system to make architecture search more computationally efficient while still providing a quality signal for how well the final architecture having the larger backbone will perform on the dense image prediction task.
Additional techniques that can be employed by the system to improve the computational efficiency of the search are described below with reference to FIG. 4.
The neural network search system 100 can then output architecture data 152 that specifies the final architecture of the neural network, i.e., data specifying the layers that are part of the neural network, the connectivity between the layers, and the operations performed by the layers. For example, the neural network search system 100 can output the architecture data 152 to the user that submitted the training data.
In some implementations, instead of or in addition to outputting the architecture data 152, the system 100 uses the trained neural network having the final architecture to process requests received by users, e.g., through the API provided by the system. That is, the system 100 can receive inputs to be processed, use the trained neural network to process the inputs, and provide the outputs generated by the trained neural network or data derived from the generated outputs in response to the received inputs.
FIG. 3 is a flow diagram of an example process 300 for determining a final architecture for a dense image prediction task. For convenience, the process 300 will be described as being performed by a system of one or more computers located in one or more locations. For example, a neural architecture search system, e.g., the neural architecture search system 100 of FIG. 1, appropriately programmed, can perform the process 300.
The system receives training data for the dense image prediction task (step 302).
The system searches a space of candidate architectures to identify one or more best performing architectures using the training data (step 304). Searching the space of candidate architectures is described in more detail below with reference to FIG. 4. Once the search has completed, the system can select, as the best performing architectures, a threshold number of candidate architectures that had the best quality evaluation during the search.
The system determines the architecture for the neural network based on the one or more best performing candidate architectures (step 306). For example, the system can generate, from each of the identified best performing candidates, a final architecture, and then train the final architectures to convergence on the dense prediction task. The system can then select the best performing trained architecture, e.g., as determined based on a quality measure on the validation set, as the architecture of the neural network. The quality measure that is used can be the same as the one described below with reference to step 410.
In some implementations, the candidate architecture and the corresponding final architecture are the same.
In other implementations, however, the system replaces the neural network backbone with a different, larger neural network backbone that has more parameters and that allows the final neural network to perform better on the dense prediction task.
In other words, in some cases, the system uses a smaller backbone for the architecture search than is employed by the final architecture.
FIG. 4 is a flow diagram of an example process 400 for searching the space of candidate architectures. For convenience, the process 400 will be described as being performed by a system of one or more computers located in one or more locations. For example, a neural architecture search system, e.g., the neural architecture search system 100 of FIG. 1, appropriately programmed, can perform the process 400.
The system obtains data specifying a pre-trained backbone for use in searching the space of candidate architectures (step 402). In some cases, the system pre-trains the backbone along with a placeholder DPC on a placeholder dense image prediction task to determine trained values of the parameters of the backbone, i.e., so that the system only needs train the backbone once for the entire search process. In some other cases, the system obtains data specifying the trained values of the backbone parameters from another system that has already pre-trained the backbone.
Optionally, the system processes at least some of the training inputs in the training data using the pre-trained backbone to generate feature maps for the training inputs (step 404). In other words, the system processes each of the training inputs using the pre-trained backbone, i.e., in accordance with the trained values of the parameters of the backbone, to generate feature maps and then stores the generated feature maps for use during the search process. When the system is using the smaller backbone for the search, because the feature maps generated by the smaller backbone have many fewer channels than the feature maps generated by the larger backbone (that will be used in the final architecture), storing the feature maps requires much less storage space than would be required to store feature maps generated by the larger backbone.
The system then repeatedly performs steps 406-410 until termination criteria for the search are satisfied, e.g., until a threshold number of candidate architectures have been evaluated, until the highest performing candidate architecture reaches a threshold accuracy, or until a threshold amount of time has elapsed.
The system selects one or more candidate architectures from the space of candidate architectures (step 406). The system can use any of a variety of techniques for searching the space to select the candidate architectures.
For example, the system can use a random search strategy. In a random search strategy, at each iteration of the process 400, the system selects one or more architectures from the space of candidate architectures uniformly at random while also selecting one or more architectures that are close to, i.e., are similar to, the currently best observed architectures, i.e., the architectures already evaluated as part of the search that have been found to perform best on the dense prediction task. Random search strategies that can be employed by the system are described in more detail in D. Golovin, B. Solnik, S. Moitra, G. Kochanski, J. Karro, and D. Sculley. Google vizier: A service for black-box optimization. In SIGKDD, 2017 and in B. Zoph, V. Vasudevan, J. Shlens, and Q. V. Le. Learning transferable architectures for scalable image recognition. In CVPR, 2018.
As another example, the system can use a reinforcement learning guided search strategy to select the candidate actions. In particular, at each iteration of the process 400, the system can select architectures that are output by a recurrent neural network that is being trained through reinforcement learning to output candidate architectures that perform well on the task. Examples of reinforcement learning guided search strategies that can be employed by the system are described in more detail in B. Zoph and Q. V. Le. Neural architecture search with reinforcement learning. In ICLR, 2017.
The system trains the selected one or more candidate architectures on at least a portion of the training data (step 408). That is, for each selected candidate, the system trains a neural network having the architecture until criteria for stopping the training are satisfied. During the training, the system holds the trained values of the backbone parameters fixed while updating the values of the parameters of the DPC in the neural network.
In particular, in implementations where step 404 was performed to pre-process the training data using the pre-trained backbone, the system does not process the training inputs using the backbone during step 408 and instead accesses the pre-generated feature maps from memory and provides the pre-generated feature maps as input to the DPC. This greatly decreases the processing power and time consumed by the training, since training inputs do not need to be processed through backbone to generate the feature maps before the feature maps can processed by the DPC.
The system can perform this training using an early stopping criterion, i.e., can train each candidate for a fixed number of iterations instead of to convergence.
The system evaluates the performance of each of the trained candidate architectures (step 410). The system uses an evaluation metric that measures the performance of the trained neural network having the candidate architecture on the validation set to evaluate the performance.
Any evaluation metric that is appropriate for dense prediction tasks can be used. For example, the system can use the pixel-wise mean intersection-over-union (mIOU) of the trained neural network over the validation data set as the evaluation metric. As another example, the system can use the mean pixel accuracy over the validation data set of the trained neural network as the evaluation metric.
This specification uses the term “configured” in connection with systems and computer program components. For a system of one or more computers to be configured to perform particular operations or actions means that the system has installed on it software, firmware, hardware, or a combination of them that in operation cause the system to perform the operations or actions. For one or more computer programs to be configured to perform particular operations or actions means that the one or more programs include instructions that, when executed by data processing apparatus, cause the apparatus to perform the operations or actions.
Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, in tangibly-embodied computer software or firmware, in computer hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions encoded on a tangible non transitory storage medium for execution by, or to control the operation of, data processing apparatus. The computer storage medium can be a machine-readable storage device, a machine-readable storage substrate, a random or serial access memory device, or a combination of one or more of them. Alternatively or in addition, the program instructions can be encoded on an artificially generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus.
The term “data processing apparatus” refers to data processing hardware and encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers. The apparatus can also be, or further include, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit). The apparatus can optionally include, in addition to hardware, code that creates an execution environment for computer programs, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them.
A computer program, which may also be referred to or described as a program, software, a software application, an app, a module, a software module, a script, or code, can be written in any form of programming language, including compiled or interpreted languages, or declarative or procedural languages; and it can be deployed in any form, including as a stand alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data, e.g., one or more scripts stored in a markup language document, in a single file dedicated to the program in question, or in multiple coordinated files, e.g., files that store one or more modules, sub programs, or portions of code. A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a data communication network.
In this specification, the term “database” is used broadly to refer to any collection of data: the data does not need to be structured in any particular way, or structured at all, and it can be stored on storage devices in one or more locations. Thus, for example, the index database can include multiple collections of data, each of which may be organized and accessed differently.
Similarly, in this specification the term “engine” is used broadly to refer to a software-based system, subsystem, or process that is programmed to perform one or more specific functions. Generally, an engine will be implemented as one or more software modules or components, installed on one or more computers in one or more locations. In some cases, one or more computers will be dedicated to a particular engine; in other cases, multiple engines can be installed and running on the same computer or computers.
The processes and logic flows described in this specification can be performed by one or more programmable computers executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by special purpose logic circuitry, e.g., an FPGA or an ASIC, or by a combination of special purpose logic circuitry and one or more programmed computers.
Computers suitable for the execution of a computer program can be based on general or special purpose microprocessors or both, or any other kind of central processing unit. Generally, a central processing unit will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a central processing unit for performing or executing instructions and one or more memory devices for storing instructions and data. The central processing unit and the memory can be supplemented by, or incorporated in, special purpose logic circuitry. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device, e.g., a universal serial bus (USB) flash drive, to name just a few.
Computer readable media suitable for storing computer program instructions and data include all forms of non volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto optical disks; and CD ROM and DVD-ROM disks.
To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input. In addition, a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a web browser on a user's device in response to requests received from the web browser. Also, a computer can interact with a user by sending text messages or other forms of message to a personal device, e.g., a smartphone that is running a messaging application, and receiving responsive messages from the user in return.
Data processing apparatus for implementing machine learning models can also include, for example, special-purpose hardware accelerator units for processing common and compute-intensive parts of machine learning training or production, i.e., inference, workloads.
Machine learning models can be implemented and deployed using a machine learning framework, e.g., a TensorFlow framework, a Microsoft Cognitive Toolkit framework, an Apache Singa framework, or an Apache MXNet framework.
Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front end component, e.g., a client computer having a graphical user interface, a web browser, or an app through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back end, middleware, or front end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (LAN) and a wide area network (WAN), e.g., the Internet.
The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other. In some embodiments, a server transmits data, e.g., an HTML page, to a user device, e.g., for purposes of displaying data to and receiving user input from a user interacting with the device, which acts as a client. Data generated at the user device, e.g., a result of the user interaction, can be received at the server from the device.
While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any invention or on the scope of what may be claimed, but rather as descriptions of features that may be specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially be claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.
Similarly, while operations are depicted in the drawings and recited in the claims in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system modules and components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
Particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. For example, the actions recited in the claims can be performed in a different order and still achieve desirable results. As one example, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In some cases, multitasking and parallel processing may be advantageous.