US10558932B1 - Multi-machine distributed learning systems - Google Patents
Multi-machine distributed learning systems Download PDFInfo
- Publication number
- US10558932B1 US10558932B1 US14/694,762 US201514694762A US10558932B1 US 10558932 B1 US10558932 B1 US 10558932B1 US 201514694762 A US201514694762 A US 201514694762A US 10558932 B1 US10558932 B1 US 10558932B1
- Authority
- US
- United States
- Prior art keywords
- information
- sub
- matrix
- workers
- computer
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active, expires
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N10/00—Quantum computing, i.e. information processing based on quantum-mechanical phenomena
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F17/00—Digital computing or data processing equipment or methods, specially adapted for specific functions
- G06F17/10—Complex mathematical operations
- G06F17/16—Matrix or vector computation, e.g. matrix-matrix or matrix-vector multiplication, matrix factorization
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N20/00—Machine learning
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N7/00—Computing arrangements based on specific mathematical models
- G06N7/01—Probabilistic graphical models, e.g. probabilistic networks
Definitions
- This specification relates to multi-machine distributed learning systems.
- Multi-machine distributed learning systems can be used in solving machine learning problems, e.g., non-convex optimization and Bayesian learning.
- the systems include computer programs operated on computers, e.g., classical computers or ones that include quantum processors, connected in parallel.
- the computers can be configured to have a master-slave architecture in which one computer performs the role of a master while all other computers perform the role of slaves controlled by the master.
- the computer programs operate on the master and slave computers in the form of parallel computing.
- a machine learning problem can be partitioned into a group of sub-problems each handled by a slave computer. Each sub-problem is solved by iterations of computations carried out by its slave computer and with the help of the master computer. For example, the sub-problems can be correlated and the master computer can control the correlation among the sub-problems so that the each slave performs the iterative computations with the correctly updated parameters and variables.
- Each of the slave computers can perform the computation iterations independently such that the sub-problems can be solved asynchronously.
- the slave computers work together to solve the machine learning problem without requiring mutex locks so that the systems are implemented in a lock-free manner.
- the systems can be error tolerant. For example, when one or more slave computers malfunction, information stored on the master computer can be retrieved to restore or replace those slave computers without disturbing the other slave computers that are functioning properly. The machine learning processes can continue without being significantly interrupted. In another example, when the master computer malfunctions, the information stored on the master computer can be retrieved to recover the machine learning processes at a moment earlier than the malfunction and continue with the processes.
- Each of the sub-problems solved by a slave computer can involve stochastic gradient descent (SGD).
- each slave computer can be required solve a sub-problem that is computationally harder than SGD, e.g., non-convex optimization or Bayesian learning, to reduce the amount of network communication between the computers in the system.
- the network communication reduces the speed of the machine learning processes and reduction of the amount of network communication can improve the speed of the machine learning processes.
- Each of the master computer and the slave computers can be a classical computer, or each can include a quantum processor. Sometimes some of the master computer and the slave computers are classical computers while the others include quantum processors. In some situations, in addition to the master and slave computers, additional quantum computers or processors can be used to receive input from the master computer and/or slave computers to solve parts of the machine learning problems. For example, solutions to the parts of the machine learning problems can be encoded in an energy spectrum, e.g., the ground state, of a many-body quantum Hamiltonian characterizing the quantum processor. The quantum processors can then be used to perform quantum annealing processes to find the energy spectrum and the solutions.
- an energy spectrum e.g., the ground state
- the quantum processors can provide the solutions to these parts of the machine learning problems faster than, and/or with higher precision than, classical computers.
- the classical computers may not be able to provide solutions within reasonable time and the use of the quantum processors may be necessary.
- the multi-machine distributed learning systems can be used to solve a variety of problems, including matrix completion, latent Dirichlet allocation, classification, and deep learning.
- FIGS. 1, 2, 4, and 6 are block diagrams showing examples of multi-machine distributed learning systems.
- FIGS. 3, 5, and 7 are flow diagrams showing examples of processes performed by a worker on a slave computer.
- FIG. 1 shows an example of a multi-machine distributed learning system 100 for solving a machine learning problem.
- the system 100 includes a taskmaster 106 operating on a master computer 102 and distributed workers 104 including workers 104 a , 104 b , . . . , 104 p operating on respective distributed slave computers 108 including slave computers 108 a , 108 b , . . . , 108 p , and a submitter 104 s operating on a slave computer 108 s .
- Each of the taskmaster 106 , workers 104 , and the submitter 104 s can be in the form of computer programs.
- the master computer 102 and the slave computers 108 can be connected in a network and each can be a classical computer or can include a quantum processor that carries out instructions of the computer programs.
- the taskmaster 106 responds to queries from the workers 104 and the submitter 104 s and receives information, stores information received, and updates stored information based on information received, from the workers and the submitter, on the master computer 102 .
- the information includes information about work tasks 110 to be carried out by the workers, result tasks 112 that contain results of the work tasks 110 carried out by the workers, and summary task 114 s .
- the taskmaster 106 does not carry out actual computations for machine learning.
- the workers 104 each work independently of each other on a sub-problem of the machine learning problem.
- the sub-problem can be defined by a task in the work tasks 110 stored on the master computer 102 .
- the workers 104 communicate with the taskmaster 106 , which coordinates the work on the different tasks by the different workers to collectively solve the machine learning problem.
- the submitter 104 s does not work on any of the tasks for the machine learning problem. Instead, the submitter works on updating and maintaining the summary task 114 .
- the workers 104 and the submitter 104 s have different authorizations with regard to access and use of the information stored on the master computer 102 .
- the workers 104 and the submitter 104 s can access authorized information stored on the master computer 102 using one or more of the following procedures:
- An example of Query is a read action in which a worker 104 or the submitter 104 s reads information stored by the taskmaster 106 on the master computer 102 .
- Query to the same piece of information can be performed simultaneously by one or more workers and the submitter without causing any conflicts at the piece of information.
- the piece of the information being queried does not have to be locked for the query.
- An example of QueryandOwn is a use action in which a worker 104 or the submitter 104 s requests to use certain information and the use may result in updating the information.
- the worker may be carrying out an iteration of computation using a current set of parameters and producing an updated set of parameters.
- the use of the information precludes other workers from using the same piece of information to allow the information to be properly updated.
- the taskmaster 106 sends a copy of the information to the worker and at the same time locks the information at the master computer 102 for the predetermined amount of time.
- the worker obtaining the information has to complete use of the information and update the information at the master computer 102 , if necessary, within the predetermined amount of time, so that when the other workers are allowed to access the information, the information has been updated.
- the submitter 104 s may need to update the information of a result task in the summary task 114 so the workers 104 are precluded from accessing the summary task 114 until the update is completed.
- Update is a write action in which a worker or the submitter 104 s writes or requests the taskmaster 106 to write updated information to replace the corresponding stored information in the master computer 102 .
- the workers and the submitter 104 s can only perform authorized procedure(s) on authorized information stored or to be stored on the master computer 102 .
- the work tasks 110 are n work tasks 110 a , 110 b , . . . , 110 n .
- the number n of work tasks is determined based on the machine learning problem to be solved by the system 100 and the number of workers 104 .
- the machine learning problem can be divided into the n work tasks to be carried out by the workers 104 .
- Each work task contains a subset of variables of the machine learning problem or the statistics of a subset of random variables.
- the number n is the same as the number of workers 104 . However, n does not have to be equal to the number of workers 104 .
- Each worker can use any of the three access procedures to access any of the available work tasks that are not currently owned by another worker.
- the submitter 104 s does not access the work tasks 110 .
- the result tasks 112 contains p result tasks 112 a , 112 b , . . . , 112 p , each owned by a corresponding worker 104 a , 104 b , . . . , 104 p .
- Each result task can only be updated by its owner or by the taskmaster 106 upon the request of its owner.
- Other workers and the submitter 104 s who are not the owners of a result task cannot update the result task, but can only query, e.g., read, the result task at the master computer 102 .
- the summary task 114 contains summary of the tasks carried out by the workers 104 .
- the summary task 114 is exclusively owned by the submitter 104 s , who is allowed to update or request the taskmaster 106 to update the information of the summary task 114 .
- the submitter 104 s may query the result tasks 112 to obtain information for updating the summary task 114 .
- the workers 104 cannot update the summary task 114 , but can only query, e.g., read, the summary task 114 .
- the workers 104 and the submitter 104 s can work together without using mutex locks.
- the configuration of the system 100 ensures that at any given time, the same piece of information stored or to be stored in the master computer 102 is not updated or written simultaneously by more than one of the workers 104 and the submitter 104 s . Furthermore, because the information about the machine learning problem is stored and constantly updated by the taskmaster in the master computer, any failure of workers or the submitter does not have any major impact on the process of solving the problem. As a result, the system 100 can have high error tolerance.
- an incomplete data matrix X having N ⁇ D dimensions is decomposed into the product of two smaller matrices, A having N ⁇ K dimension and B having K ⁇ D dimension, where K is called the base number and is much smaller than both N and D:
- the incomplete data matrix X has at least some data elements x ij unknown.
- Matrices A and B are to be determined so that the residual of ⁇ X ⁇ A B ⁇ is smaller than a predetermined value.
- Solutions to a matrix completion problem can have many uses, including in movie/music recommendation, player matching, advertisement matching, and so on.
- each row of the matrix X can represent a user and each column of the matrix X can represent a movie.
- Each matrix element x ij can represent the ith user's rating of the jth movie.
- At least some of the N users may have rated less than all of the D movies. However, the ratings of those unrated movies by these users can be predicted using a machine learning process based on the known ratings of these users and the other users.
- the matrix X can be completed using the system 100 of FIG. 1 by computing a minimum of an objective function:
- a , B ⁇ F ⁇ ( A , B ) ⁇ i , j ⁇ I ⁇ ( x ij - A i ⁇ B j ) 2 + ⁇ i ⁇ ⁇ ⁇ ⁇ A i ⁇ 2 + ⁇ i ⁇ ⁇ ⁇ B j ⁇ 2
- ⁇ >0 is a scalar
- a i , B j are sub-matrices a i , b j .
- FIG. 2 shows how a system 200 that has the same hardware and software architectures as the system 100 of FIG. 1 is used in solving the matrix completion problem described above.
- the matrix X is very large. In the example of movie rating, the matrix X can have millions of rows.
- Each sub-matrix X m can contain one or more row sub-matrices x l .
- Different sub-matrices X m can have different numbers of rows.
- the division of the matrix X can be done by a computer different from all computers in the system 200 or by the master computer 102 . Sometimes a user can make the division.
- the division can be made based on various factors, e.g., load balancing of the different slave computers, or the number of unknown matrix elements in each sub-matrix.
- Each sub-matrix X m is stored by a worker 104 m on its corresponding slave computer 108 m.
- Each sub-matrix A m has the same number of rows as its corresponding sub-matrix X m and can be initialized to have random values for its matrix elements.
- the initialized values for each sub-matrix A m are stored by a worker 104 m on its slave computer 108 m with the corresponding sub-matrix X m .
- the values of the matrix elements for the sub-matrix A m are updated in iterations based on the computations performed by the workers 104 ; and the worker 104 m stores the updated values on the slave computer 108 m .
- the matrix B is stored in work tasks column-wise such that each row sub-matrix b i is stored as one work task 110 i .
- each sub-matrix b i can be initialized to have random values for its matrix elements.
- the values of the matrix elements for the sub-matrix b i are updated in iterations based on the computations performed by the workers 104 ; and the taskmaster 106 stores the updated values on the master computer 102 .
- each sub-problem completes a sub-matrix X m .
- Each worker 104 m uses its slave computer 108 m to work on a sub-problem F m (A, B) and determine an optimized sub-matrix X m .
- Different workers 104 work on different sub-problems. However, the optimization of a sub-matrix X m by the worker 104 m depends on the optimization of the sub-matrices b i , and therefore, the other sub-problems being solved by the other workers.
- a worker 104 m has to use the entire matrix B based on:
- each worker can perform a QueryandOwn to use a mini-batch of the tasks ⁇ b i ⁇ , where i is a sub-group of 1, . . . , D.
- the size of the mini-batch can be predetermined or can be dynamically determined, e.g., based on load balancing and/or progress of the different completion processes at different slave computers.
- different workers can work on a part of their corresponding sub-matrix X m simultaneously. Over multiple iterations and multiple QueryandOwn procedures, a worker can own the entire matrix B and work on the entire sub-matrix X m .
- FIG. 3 shows an example process 300 of solving a sub-problem F m (A, B) by a worker 104 m .
- the worker 104 m performs a QueryandOwn 302 to use a mini-batch of tasks ⁇ b i t-1 ⁇ , where i is a sub-group of 1, . . . , D and t is the current number of iterations of computation the worker 104 m is to perform.
- the worker 104 m Upon receiving the requested mini-batch from the taskmaster 102 , the worker 104 m computes 304 A m t and ⁇ b i t ⁇ and performs an Update 304 on the tasks at the master computer 102 .
- the worker 104 m also computes 306 residual:
- the worker 104 m performs an Update to store the residual at the result task 112 m .
- the worker 104 m then performs a Query 308 to read the summary task 114 and determines 310 whether the value in the summary task 114 is smaller than a predetermined value S 0 .
- the summary task contains a summary of all residuals from the result tasks 112 .
- the submitter 104 s regularly performs a Query to read each of the result tasks 112 and performs an Update on the summary task 114 .
- the optimization of the sub-matrix X m ends 312 .
- the matrix X can be completed based on the optimized matrices A and B. If the value in the summary task 114 is greater than a predetermined value S 0 , then the worker 104 m enters the next iteration and increments t by 1.
- B j t ⁇ b i t ⁇
- ⁇ t is a sequence of step sizes.
- each worker can solve a harder optimization problem than SGD based on the following equation:
- Latent Dirichlet Allocation is a Bayesian learning method, and an example of the use of LDA is in text clustering.
- Text clustering can include extracting topics of different documents, automatically organizing documents, e.g., based on topics, and fast retrieving or filtering information contained in the documents.
- each document is represented by words of a pre-determined vocabulary of words while the order of the words in the document is ignored. For example, a document containing the sentence: “The apple company has an apple logo.” is represented by “the: 1, apple: 2, company: 1, has: 1, an: 1, logo: 1”.
- Each number after a word represents the total number of times the word appears in the document. Sometimes the same word appearing multiple times can have different meanings. For example, the word “apple” in the example document above appears two times and has two different meanings.
- the documents can be represented by the following matrix:
- Each matrix element x ij represents the number of times a word j appears in a document i.
- each word j in the document i has a topic z ij ⁇ 1, . . . , K ⁇ .
- a topic matrix Z for all N documents can be written as:
- the topic is analogous to a base in matrix completion described above.
- the same word appearing multiple times having multiple meanings has multiple topics.
- Gibbs sampling which is a Markov chain Monte Carlo (MCMC) method
- n ik is the number of words in document i that has the topic k
- n kj is the number of words j that has topic k
- n k is the total number of words that has the topic k.
- n kj (n 1j n 2j . . . n Kj ), for each word j;
- n ik (n i1 n i2 . . . n iK ), for each document I;
- n k (n 1 n 2 . . . n K ), for all words and all documents.
- FIG. 4 shows how a system 400 that has the same hardware and software architectures as the system 100 of FIG. 1 is used in solving the text clustering problem described above.
- the total number of documents for use in the test clustering is divided into p sub-groups, each to be assigned to a worker 104 to work on a slave computer.
- the topic matrix is also divided into p sub-matrices Z 1 , . . . , Z p .
- Each worker 104 m stores on its slave computer 108 m a sub-matrix X m which corresponds to the assigned document group ⁇ x l ⁇ and corresponding topic sub-matrix Z m , which corresponds to topic group ⁇ z l ⁇ .
- the worker 104 m also stores and updates all n ik for the assigned document group ⁇ x l ⁇ .
- each word j and its topic assignment statistics n kj are stored as a work task 110 j by the taskmaster 106 .
- the system 400 determines n kj and n ik using iterative computations performed by each worker 104 . Similar to the matrix completion problem, in each iteration, each worker obtains a mini-batch of tasks from the master computer 102 .
- FIG. 5 shows an example process 500 of text clustering a sub-group of documents represented by the matrix X m by a worker 104 m .
- the worker 104 m performs a QueryandOwn 502 to use a mini-batch of tasks ⁇ n kj t-1 ⁇ , where j is a sub-group of 1, . . . , V and t is the current number of iterations of computation the worker 104 m is to perform.
- the worker 104 m also performs a Query 504 to read the summary task 114 to obtain n k .
- the distributed learning system 100 can also be applied in classification.
- binary classification is described.
- Other classification problems e.g., multi-class classification problems, can be similarly solved.
- a binary classification problem has a loss function L, data
- FIG. 6 shows how a system 600 that has the same hardware and software architectures as the system 100 of FIG. 1 is used in solving the binary classification problem described above.
- the parameter element w i of the vector w is stored as a work task 110 i in the master computer 102 .
- the data matrix X is partitioned into sub-matrices X m , each corresponding to a group of row sub-matrices ⁇ x i ⁇ and stored by a corresponding worker 104 m on its slave computer 108 m .
- a label y m corresponding to the sub-matrices X m is also stored on the same slave computer 108 .
- FIG. 7 shows an example process 700 of solving a sub-problem of the binary classification by a worker 104 m .
- the worker 104 m performs a QueryandOwn 702 to use a mini-batch of tasks ⁇ w sp t-1 ⁇ , where sp is a sub-group of 1, . . . , D and t is the current number of iterations of computation the worker 104 m is to perform.
- the worker 104 m Upon receiving the requested mini-batch from the taskmaster 102 , the worker 104 m computes 304 X m and ⁇ w sp t ⁇ and performs an Update 704 on the tasks at the master computer 102 .
- the worker 104 m also computes 706 the error: E ( X m ,y m ), and sends 706 the computed error to the taskmaster 106 to be stored at its corresponding result task 112 m . Effectively, the worker 104 m performs an Update on the stored residual at the result task 112 m . The worker 104 m then performs a Query 708 to read the summary task 114 and determines 710 whether the value in the summary task 114 is smaller than a predetermined value E 0 .
- the summary task contains a summary of all errors from the result tasks 112 .
- the submitter 104 s regularly performs a Query to read each of the result tasks 112 and performs an Update on the summary task 114 .
- the optimization of the sub-matrix X m ends 712 . If the value in the summary task 114 is greater than a predetermined value E 0 , then the worker 104 m enters the next iteration t+1.
- the update of the sub-matrix X m and the parameters ⁇ w sp t ⁇ can be performed using SGD similarly to the update of the described process for matrix completion.
- w S p t arg ⁇ ⁇ min w S p ⁇ ⁇ ⁇ i ⁇ I p ⁇ L ( ⁇ j ⁇ S p ⁇ y x ⁇ x ij ⁇ w j + ⁇ j ⁇ S p ⁇ y i ⁇ x ij ⁇ w j t - 1 ) + ⁇ t ⁇ ⁇ w S p - w S p t - 1 ⁇ 2 ⁇ .
- the loss function L is a non-convex loss function
- the above problem is a non-convex sub-problem.
- this sub-problem is much smaller (
- global optimization methods including quantum annealing can be used to solve the sub-problem. For example, w sp t-1 , x ij , y i , and ⁇ t can be input into a quantum processor, which outputs w sp t .
- the learning system 100 can also be used in deep learning. Datasets can be partitioned for the p different slave computers. In each iteration, each computer can execute a QueryandOwn to use some parameters based on the data it has and the past parameter it had, similarly to the classification problem described above.
- Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, in tangibly-embodied computer software or firmware, in computer hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them.
- Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions encoded on a tangible non-transitory storage medium for execution by, or to control the operation of, data processing apparatus.
- the program instructions can be encoded on an artificially-generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus.
- the computer storage medium can be a machine-readable storage device, a machine-readable storage substrate, a random or serial access memory device, or a combination of one or more of them.
- data processing apparatus refers to data processing hardware and encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable digital processor, a digital computer, or multiple digital processors or computers.
- the apparatus can also be or further include special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
- the apparatus can optionally include, in addition to hardware, code that creates an execution environment for computer programs, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them.
- a computer program which may also be referred to or described as a program, software, a software application, a module, a software module, a script, or code, can be written in any form of programming language, including compiled or interpreted languages, or declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment.
- a computer program may, but need not, correspond to a file in a file system.
- a program can be stored in a portion of a file that holds other programs or data, e.g., one or more scripts stored in a markup language document, in a single file dedicated to the program in question, or in multiple coordinated files, e.g., files that store one or more modules, sub-programs, or portions of code.
- a computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a data communication network.
- the processes and logic flows described in this specification can be performed by one or more programmable computers executing one or more computer programs to perform functions by operating on input data and generating output.
- the processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
- FPGA field programmable gate array
- ASIC application-specific integrated circuit
- Computers suitable for the execution of a computer program include, by way of example, can be based on general or special purpose microprocessors or both, or any other kind of central processing unit.
- a central processing unit will receive instructions and data from a read-only memory or a random access memory or both.
- the essential elements of a computer are a central processing unit for performing or executing instructions and one or more memory devices for storing instructions and data.
- a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks.
- mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks.
- a computer need not have such devices.
- a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device, e.g., a universal serial bus (USB) flash drive, to name just a few.
- PDA personal digital assistant
- GPS Global Positioning System
- USB universal serial bus
- Computer-readable media suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks.
- semiconductor memory devices e.g., EPROM, EEPROM, and flash memory devices
- magnetic disks e.g., internal hard disks or removable disks
- magneto-optical disks e.g., CD-ROM and DVD-ROM disks.
- the processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
- Control of the various systems described in this specification, or portions of them, can be implemented in a computer program product that includes instructions that are stored on one or more non-transitory machine-readable storage media, and that are executable on one or more processing devices.
- the systems described in this specification, or portions of them, can be implemented as an apparatus, method, or electronic system that may include one or more processing devices and memory to store executable instructions to perform the operations described in this specification.
Abstract
A system comprises a network of computers comprising a master computer and slave computers. For a machine learning problem that is partitioned into a number of correlated sub-problems, each master computer is configured to store tasks associated with the machine learning problem, and each of the slave computers is assigned one of the correlated sub-problems. Each slave computer is configured to store variables or parameters or both associated with the assigned one of the correlated sub-problems; obtain information about one or more tasks stored by the master computer without causing conflict with other slave computers with regard to the information; perform computations to update the obtained information and the variables or parameters or both of the assigned sub-problem; send the updated information to the master computer to update the information stored at the master computer; and store the updated variables or parameters or both of the assigned sub-problem.
Description
This application claims priority under 35 USC § 119(e) to U.S. Patent Application Ser. No. 61/983,111, filed on Apr. 23, 2014, the entire contents of which are hereby incorporated by reference.
This specification relates to multi-machine distributed learning systems.
Multi-machine distributed learning systems can be used in solving machine learning problems, e.g., non-convex optimization and Bayesian learning. The systems include computer programs operated on computers, e.g., classical computers or ones that include quantum processors, connected in parallel. The computers can be configured to have a master-slave architecture in which one computer performs the role of a master while all other computers perform the role of slaves controlled by the master. The computer programs operate on the master and slave computers in the form of parallel computing. Generally, a machine learning problem can be partitioned into a group of sub-problems each handled by a slave computer. Each sub-problem is solved by iterations of computations carried out by its slave computer and with the help of the master computer. For example, the sub-problems can be correlated and the master computer can control the correlation among the sub-problems so that the each slave performs the iterative computations with the correctly updated parameters and variables.
Each of the slave computers can perform the computation iterations independently such that the sub-problems can be solved asynchronously. The slave computers work together to solve the machine learning problem without requiring mutex locks so that the systems are implemented in a lock-free manner. The systems can be error tolerant. For example, when one or more slave computers malfunction, information stored on the master computer can be retrieved to restore or replace those slave computers without disturbing the other slave computers that are functioning properly. The machine learning processes can continue without being significantly interrupted. In another example, when the master computer malfunctions, the information stored on the master computer can be retrieved to recover the machine learning processes at a moment earlier than the malfunction and continue with the processes.
Each of the sub-problems solved by a slave computer can involve stochastic gradient descent (SGD). Alternatively, each slave computer can be required solve a sub-problem that is computationally harder than SGD, e.g., non-convex optimization or Bayesian learning, to reduce the amount of network communication between the computers in the system. Generally, the network communication reduces the speed of the machine learning processes and reduction of the amount of network communication can improve the speed of the machine learning processes.
Each of the master computer and the slave computers can be a classical computer, or each can include a quantum processor. Sometimes some of the master computer and the slave computers are classical computers while the others include quantum processors. In some situations, in addition to the master and slave computers, additional quantum computers or processors can be used to receive input from the master computer and/or slave computers to solve parts of the machine learning problems. For example, solutions to the parts of the machine learning problems can be encoded in an energy spectrum, e.g., the ground state, of a many-body quantum Hamiltonian characterizing the quantum processor. The quantum processors can then be used to perform quantum annealing processes to find the energy spectrum and the solutions. Generally, the quantum processors can provide the solutions to these parts of the machine learning problems faster than, and/or with higher precision than, classical computers. Sometimes, e. g., when the parts of the problems are complex, e.g., NP-hard problems, the classical computers may not be able to provide solutions within reasonable time and the use of the quantum processors may be necessary.
The multi-machine distributed learning systems can be used to solve a variety of problems, including matrix completion, latent Dirichlet allocation, classification, and deep learning.
The details of one or more embodiments of the subject matter of this specification are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the subject matter will be apparent from the description, the drawings, and the claims.
Example System Architecture
In some implementations, the taskmaster 106 responds to queries from the workers 104 and the submitter 104 s and receives information, stores information received, and updates stored information based on information received, from the workers and the submitter, on the master computer 102. The information includes information about work tasks 110 to be carried out by the workers, result tasks 112 that contain results of the work tasks 110 carried out by the workers, and summary task 114 s. The taskmaster 106 does not carry out actual computations for machine learning.
In some implementations, the workers 104 each work independently of each other on a sub-problem of the machine learning problem. The sub-problem can be defined by a task in the work tasks 110 stored on the master computer 102. The workers 104 communicate with the taskmaster 106, which coordinates the work on the different tasks by the different workers to collectively solve the machine learning problem. The submitter 104 s does not work on any of the tasks for the machine learning problem. Instead, the submitter works on updating and maintaining the summary task 114. The workers 104 and the submitter 104 s have different authorizations with regard to access and use of the information stored on the master computer 102.
The workers 104 and the submitter 104 s can access authorized information stored on the master computer 102 using one or more of the following procedures:
-
- Query: obtain information, e.g., of a task;
- QueryandOwn: obtain and acquire ownership of information, e.g., a task, and prevent other workers/submitter from acquiring the information for a predetermined amount of time;
- Update: update information, e.g., of a task.
An example of Query is a read action in which a worker 104 or the submitter 104 s reads information stored by the taskmaster 106 on the master computer 102. Query to the same piece of information can be performed simultaneously by one or more workers and the submitter without causing any conflicts at the piece of information. The piece of the information being queried does not have to be locked for the query.
An example of QueryandOwn is a use action in which a worker 104 or the submitter 104 s requests to use certain information and the use may result in updating the information. For example, the worker may be carrying out an iteration of computation using a current set of parameters and producing an updated set of parameters. The use of the information precludes other workers from using the same piece of information to allow the information to be properly updated. Typically, upon the worker's request, the taskmaster 106 sends a copy of the information to the worker and at the same time locks the information at the master computer 102 for the predetermined amount of time. The worker obtaining the information has to complete use of the information and update the information at the master computer 102, if necessary, within the predetermined amount of time, so that when the other workers are allowed to access the information, the information has been updated. In another example, the submitter 104 s may need to update the information of a result task in the summary task 114 so the workers 104 are precluded from accessing the summary task 114 until the update is completed.
An example of Update is a write action in which a worker or the submitter 104 s writes or requests the taskmaster 106 to write updated information to replace the corresponding stored information in the master computer 102.
Although the three access procedures, Query, QueryandOwn, and Update, are available to all workers 104 and the submitter 104 s, the workers and the submitter 104 s can only perform authorized procedure(s) on authorized information stored or to be stored on the master computer 102.
The work tasks 110 are n work tasks 110 a, 110 b, . . . , 110 n. In some implementations, the number n of work tasks is determined based on the machine learning problem to be solved by the system 100 and the number of workers 104. The machine learning problem can be divided into the n work tasks to be carried out by the workers 104. Each work task contains a subset of variables of the machine learning problem or the statistics of a subset of random variables. In some implementations, the number n is the same as the number of workers 104. However, n does not have to be equal to the number of workers 104. Each worker can use any of the three access procedures to access any of the available work tasks that are not currently owned by another worker. The submitter 104 s does not access the work tasks 110.
The result tasks 112 contains p result tasks 112 a, 112 b, . . . , 112 p, each owned by a corresponding worker 104 a, 104 b, . . . , 104 p. Each result task can only be updated by its owner or by the taskmaster 106 upon the request of its owner. Other workers and the submitter 104 s who are not the owners of a result task cannot update the result task, but can only query, e.g., read, the result task at the master computer 102.
The summary task 114 contains summary of the tasks carried out by the workers 104. The summary task 114 is exclusively owned by the submitter 104 s, who is allowed to update or request the taskmaster 106 to update the information of the summary task 114. For example, the submitter 104 s may query the result tasks 112 to obtain information for updating the summary task 114. The workers 104 cannot update the summary task 114, but can only query, e.g., read, the summary task 114.
In solving a machine learning problem, the workers 104 and the submitter 104 s can work together without using mutex locks. The configuration of the system 100 ensures that at any given time, the same piece of information stored or to be stored in the master computer 102 is not updated or written simultaneously by more than one of the workers 104 and the submitter 104 s. Furthermore, because the information about the machine learning problem is stored and constantly updated by the taskmaster in the master computer, any failure of workers or the submitter does not have any major impact on the process of solving the problem. As a result, the system 100 can have high error tolerance.
Example Implementations
Many algorithms in machine learning can be implemented using the system 100. A few examples are described below.
1. Matrix Completion
In a matrix completion problem, an incomplete data matrix X having N×D dimensions is decomposed into the product of two smaller matrices, A having N×K dimension and B having K×D dimension, where K is called the base number and is much smaller than both N and D:
The incomplete data matrix X has at least some data elements xij unknown. Matrices A and B are to be determined so that the residual of ∥X−A B∥ is smaller than a predetermined value.
Solutions to a matrix completion problem, i.e., finding the matrices A and B with all matrix elements aij and bij known, can have many uses, including in movie/music recommendation, player matching, advertisement matching, and so on. For example, in movie recommendation, each row of the matrix X can represent a user and each column of the matrix X can represent a movie. Each matrix element xij can represent the ith user's rating of the jth movie. At least some of the N users may have rated less than all of the D movies. However, the ratings of those unrated movies by these users can be predicted using a machine learning process based on the known ratings of these users and the other users.
The matrix X can be completed using the system 100 of FIG. 1 by computing a minimum of an objective function:
where λ>0 is a scalar, Ai, Bj are sub-matrices ai, bj.
Corresponding to the division of the matrix X, the matrix A is divided row-wise into sub-matrices Am, where m=1, . . . , p. Each sub-matrix Am has the same number of rows as its corresponding sub-matrix Xm and can be initialized to have random values for its matrix elements. The initialized values for each sub-matrix Am are stored by a worker 104 m on its slave computer 108 m with the corresponding sub-matrix Xm. In computing a minimum of the objective function, the values of the matrix elements for the sub-matrix Am are updated in iterations based on the computations performed by the workers 104; and the worker 104 m stores the updated values on the slave computer 108 m. The matrix B is stored in work tasks column-wise such that each row sub-matrix bi is stored as one work task 110 i. Like the sub-matrix Am each sub-matrix bi can be initialized to have random values for its matrix elements. In computing a minimum of the objective function, the values of the matrix elements for the sub-matrix bi are updated in iterations based on the computations performed by the workers 104; and the taskmaster 106 stores the updated values on the master computer 102.
By dividing the matrices A, B, and X, computing a minimum of the objective function F(A, B) is decomposed into sub-problems Fm (A, B) each only depending on sub-matrices Am and bi, where i=1, . . . , D. Each sub-problem completes a sub-matrix Xm. Each worker 104 m uses its slave computer 108 m to work on a sub-problem Fm(A, B) and determine an optimized sub-matrix Xm. Different workers 104 work on different sub-problems. However, the optimization of a sub-matrix Xm by the worker 104 m depends on the optimization of the sub-matrices bi, and therefore, the other sub-problems being solved by the other workers.
To optimize a sub-matrix Xm, a worker 104 m has to use the entire matrix B based on:
However, in carrying out the matrix completion task, instead of using the entire matrix B, each worker can perform a QueryandOwn to use a mini-batch of the tasks {bi}, where i is a sub-group of 1, . . . , D. The size of the mini-batch can be predetermined or can be dynamically determined, e.g., based on load balancing and/or progress of the different completion processes at different slave computers. As a result, different workers can work on a part of their corresponding sub-matrix Xm simultaneously. Over multiple iterations and multiple QueryandOwn procedures, a worker can own the entire matrix B and work on the entire sub-matrix Xm.
and sends 306 the computed residual to the taskmaster to be stored at its
The computation of Am t and {bi t} in each iteration can be based on stochastic gradient decent (SGD):
where Bj t={bi t}, and γt is a sequence of step sizes.
Alternatively, each worker can solve a harder optimization problem than SGD based on the following equation:
where λt is a sequence of step sizes. This alternative optimization problem is non-convex because it contains 4th order polynomials. To solve the problem, coordinate descent or global optimization methods including quantum annealing can be used. For example, Ai t-1, Bi t-1, and λt can be input into a quantum processor, which outputs Ai t and Bi t.
2. Latent Dirichlet Allocation
Latent Dirichlet Allocation (LDA) is a Bayesian learning method, and an example of the use of LDA is in text clustering. Text clustering can include extracting topics of different documents, automatically organizing documents, e.g., based on topics, and fast retrieving or filtering information contained in the documents. To perform text clustering on a group of documents, each document is represented by words of a pre-determined vocabulary of words while the order of the words in the document is ignored. For example, a document containing the sentence: “The apple company has an apple logo.” is represented by “the: 1, apple: 2, company: 1, has: 1, an: 1, logo: 1”. Each number after a word represents the total number of times the word appears in the document. Sometimes the same word appearing multiple times can have different meanings. For example, the word “apple” in the example document above appears two times and has two different meanings. For a total of N documents and V words for representing all the documents, the documents can be represented by the following matrix:
where xl=(xl1 xl2 . . . xlV), and l=1, . . . , N. Each matrix element xij represents the number of times a word j appears in a document i.
In LDA, it is assumed that each word j in the document i has a topic zij∈{1, . . . , K}. A topic matrix Z for all N documents can be written as:
Here, the topic is analogous to a base in matrix completion described above. The same word appearing multiple times having multiple meanings has multiple topics. Using Gibbs sampling, which is a Markov chain Monte Carlo (MCMC) method, the probability of word j in the document i having the topic k is sampled based on the current assignment of the topic of all other words:
P(z ij =k)
P(z ij =k)
where nik is the number of words in document i that has the topic k; nkj is the number of words j that has topic k; and nk is the total number of words that has the topic k. Parameters α and β are constants. For k=1, . . . , K total topics, the following vectors can be used:
nkj=(n1j n2j . . . nKj), for each word j;
nik=(ni1 ni2 . . . niK), for each document I;
nk=(n1 n2 . . . nK), for all words and all documents.
Each worker 104 m stores on its slave computer 108 m a sub-matrix Xm which corresponds to the assigned document group {xl} and corresponding topic sub-matrix Zm, which corresponds to topic group {zl}. The worker 104 m also stores and updates all nik for the assigned document group {xl}. Furthermore, each word j and its topic assignment statistics nkj are stored as a work task 110 j by the taskmaster 106. To solve the text clustering problem, the system 400 determines nkj and nik using iterative computations performed by each worker 104. Similar to the matrix completion problem, in each iteration, each worker obtains a mini-batch of tasks from the master computer 102.
3 Classification
The distributed learning system 100 can also be applied in classification. For simplicity of the description, binary classification is described. Other classification problems, e.g., multi-class classification problems, can be similarly solved.
As an example, a binary classification problem has a loss function L, data
labels y={y1, . . . , yn}∈{+1, −1}n and parameter w=(w1 w2 . . . wD)T.
The objective function to minimize is:
E(X m ,y m),
and sends 706 the computed error to the
In each iteration, the update of the sub-matrix Xm and the parameters {wsp t} can be performed using SGD similarly to the update of the described process for matrix completion.
Alternatively, instead of computing the gradient with respect to wsp, the following problem can be solved:
In some implementations, the loss function L is a non-convex loss function, and the above problem is a non-convex sub-problem. Compared to the original size (N×D) of the problem, this sub-problem is much smaller (|Ip|×|Sp|). In some implementations, global optimization methods including quantum annealing can be used to solve the sub-problem. For example, wsp t-1, xij, yi, and λt can be input into a quantum processor, which outputs wsp t.
4. Deep Learning
The learning system 100 can also be used in deep learning. Datasets can be partitioned for the p different slave computers. In each iteration, each computer can execute a QueryandOwn to use some parameters based on the data it has and the past parameter it had, similarly to the classification problem described above.
Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, in tangibly-embodied computer software or firmware, in computer hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions encoded on a tangible non-transitory storage medium for execution by, or to control the operation of, data processing apparatus. Alternatively or in addition, the program instructions can be encoded on an artificially-generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. The computer storage medium can be a machine-readable storage device, a machine-readable storage substrate, a random or serial access memory device, or a combination of one or more of them.
The term “data processing apparatus” refers to data processing hardware and encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable digital processor, a digital computer, or multiple digital processors or computers. The apparatus can also be or further include special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit). The apparatus can optionally include, in addition to hardware, code that creates an execution environment for computer programs, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them.
A computer program, which may also be referred to or described as a program, software, a software application, a module, a software module, a script, or code, can be written in any form of programming language, including compiled or interpreted languages, or declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data, e.g., one or more scripts stored in a markup language document, in a single file dedicated to the program in question, or in multiple coordinated files, e.g., files that store one or more modules, sub-programs, or portions of code. A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a data communication network.
The processes and logic flows described in this specification can be performed by one or more programmable computers executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit). For a system of one or more computers to be “configured to” perform particular operations or actions means that the system has installed on it software, firmware, hardware, or a combination of them that in operation cause the system to perform the operations or actions. For one or more computer programs to be configured to perform particular operations or actions means that the one or more programs include instructions that, when executed by data processing apparatus, cause the apparatus to perform the operations or actions.
Computers suitable for the execution of a computer program include, by way of example, can be based on general or special purpose microprocessors or both, or any other kind of central processing unit. Generally, a central processing unit will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a central processing unit for performing or executing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device, e.g., a universal serial bus (USB) flash drive, to name just a few.
Computer-readable media suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
Control of the various systems described in this specification, or portions of them, can be implemented in a computer program product that includes instructions that are stored on one or more non-transitory machine-readable storage media, and that are executable on one or more processing devices. The systems described in this specification, or portions of them, can be implemented as an apparatus, method, or electronic system that may include one or more processing devices and memory to store executable instructions to perform the operations described in this specification.
While this specification contains many specific implementation details, these should not be construed as limitations on the scope of what may be claimed, but rather as descriptions of features that may be specific to particular embodiments. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.
Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system modules and components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
Particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. For example, the actions recited in the claims can be performed in a different order and still achieve desirable results. As one example, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In some cases, multitasking and parallel processing may be advantageous.
Claims (9)
1. A system comprising:
a network of computers comprising
a master computer, and
two or more slave computers,
wherein:
workers operate on respective slave computers,
a submitter operates on one of the slave computers, wherein the submitter is configured to update and maintain a summary task containing a summary of tasks carried out by the workers;
a taskmaster operates on the master computer, wherein the taskmaster receives information from the workers and the submitter, stores received information at the master computer, and updates information stored at the master computer based on information received from the workers and the submitter, the information comprising information about work tasks to be performed by the workers, information containing results of work tasks performed by the workers, and a summary task;
for a machine learning problem that is partitioned into a number of correlated sub-problems, the master computer being configured to store information associated with the machine learning problem, and each of the workers being assigned one of the correlated sub-problems and being configured to
store variables or parameters or both associated with the assigned correlated sub-problem;
query information about one or more tasks stored by the master computer without causing conflict with other workers or the submitter with regard to the information; and
iteratively perform computations to update the queried information and the variables or parameters or both of the assigned sub-problem that is assigned to the worker, wherein performing computations to update the queried information and the variables or parameters or both of the assigned sub-problem comprises performing computations that are computationally harder than stochastic gradient descent.
2. The system of claim 1 , wherein each slave computer is further configured to:
send the updated information to the master computer to update the information stored at the master computer; and
store the updated variables or parameters or both of the assigned sub-problem.
3. The system of claim 2 , wherein the two or more slave computers are configured to perform the steps of claim 2 asynchronously.
4. The method of claim 1 , wherein the machine learning problem comprises determining a solution to an objective function problem
for completing an incomplete data matrix X having N×D dimensions and matrix elements xij, where X is approximated by the product of the matrices A and B, and where Ai represents a sub-matrix of the matrix A that has the same number of columns as the matrix A, and Bj represents a sub-matrix of the matrix B that has the same number or rows as the matrix B, and
wherein performing computations to update the queried information and the variable or parameters or both of the assigned sub-problem comprises updating Ai and Bj in iterations by a computer based on the following equation:
where λt represents a sequence of step sizes, and t represents the current number of iteration.
5. The method of claim 4 , wherein the computer includes a quantum processor, and Ai t-1, Bi t-1, and λt are input into the quantum processor and Ai t and Bi t are output from the quantum processor.
6. The method of claim 1 , wherein the machine learning problem comprises determining a minimum of an objective function
for a binary classification problem that has a data set
with labels y={y1, . . . , yN}∈{+1, −1}N and parameter w=(w1 w2 . . . wD)T, wherein performing computations to update the queried information and the variable or parameters or both of the assigned sub-problem comprises updating a sub-group of parameters wSp in iterations by a computer according to the following equation:
where Sp is a sub-group of 1, . . . , D, t is a current iteration, and L is a loss function of the binary classification.
7. The method of claim 6 , wherein the computer includes a quantum processor.
8. The method of claim 1 , wherein the machine learning problem comprises a matrix completion task, latent Dirichlet allocation task, classification task or deep learning task.
9. The method of claim 1 , wherein the workers and the submitter work together without using mutex locks, and wherein at any given time, information stored or to be stored in the master computer is not updated or written simultaneously by more than one of the workers and the submitter.
Priority Applications (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US14/694,762 US10558932B1 (en) | 2014-04-23 | 2015-04-23 | Multi-machine distributed learning systems |
US16/719,881 US11861466B1 (en) | 2014-04-23 | 2019-12-18 | Multi-machine distributed learning systems |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201461983111P | 2014-04-23 | 2014-04-23 | |
US14/694,762 US10558932B1 (en) | 2014-04-23 | 2015-04-23 | Multi-machine distributed learning systems |
Related Child Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US16/719,881 Continuation US11861466B1 (en) | 2014-04-23 | 2019-12-18 | Multi-machine distributed learning systems |
Publications (1)
Publication Number | Publication Date |
---|---|
US10558932B1 true US10558932B1 (en) | 2020-02-11 |
Family
ID=69410792
Family Applications (2)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US14/694,762 Active 2037-05-04 US10558932B1 (en) | 2014-04-23 | 2015-04-23 | Multi-machine distributed learning systems |
US16/719,881 Active 2037-10-07 US11861466B1 (en) | 2014-04-23 | 2019-12-18 | Multi-machine distributed learning systems |
Family Applications After (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US16/719,881 Active 2037-10-07 US11861466B1 (en) | 2014-04-23 | 2019-12-18 | Multi-machine distributed learning systems |
Country Status (1)
Country | Link |
---|---|
US (2) | US10558932B1 (en) |
Cited By (6)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US10826845B2 (en) | 2016-05-26 | 2020-11-03 | 1Qb Information Technologies Inc. | Methods and systems for quantum computing |
US10824478B2 (en) * | 2016-06-13 | 2020-11-03 | 1Qb Information Technologies Inc. | Methods and systems for quantum ready and quantum enabled computations |
US11514134B2 (en) | 2015-02-03 | 2022-11-29 | 1Qb Information Technologies Inc. | Method and system for solving the Lagrangian dual of a constrained binary quadratic programming problem using a quantum annealer |
US11797641B2 (en) | 2015-02-03 | 2023-10-24 | 1Qb Information Technologies Inc. | Method and system for solving the lagrangian dual of a constrained binary quadratic programming problem using a quantum annealer |
US11861466B1 (en) | 2014-04-23 | 2024-01-02 | Google Llc | Multi-machine distributed learning systems |
US11947506B2 (en) | 2019-06-19 | 2024-04-02 | 1Qb Information Technologies, Inc. | Method and system for mapping a dataset from a Hilbert space of a given dimension to a Hilbert space of a different dimension |
Citations (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6442732B1 (en) * | 1999-04-21 | 2002-08-27 | Lucent Technologies, Inc. | Virtual logic system for solving satisfiability problems using reconfigurable hardware |
US20090083517A1 (en) * | 2007-09-25 | 2009-03-26 | Packeteer, Inc. | Lockless Processing of Command Operations in Multiprocessor Systems |
US20090204471A1 (en) * | 2008-02-11 | 2009-08-13 | Clearshift Corporation | Trust Level Based Task Assignment in an Online Work Management System |
US20100115027A1 (en) * | 2008-11-03 | 2010-05-06 | Samsung Electronics Co.,Ltd. | Method and apparatus for controlling access to resources in remote user interface service |
US20140108308A1 (en) * | 2012-07-13 | 2014-04-17 | Social Data Technologies, LLC | System and method for combining data for identifying compatibility |
Family Cites Families (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20030005068A1 (en) * | 2000-12-28 | 2003-01-02 | Nickel Ronald H. | System and method for creating a virtual supercomputer using computers working collaboratively in parallel and uses for the same |
EP2593844A4 (en) * | 2010-07-16 | 2017-05-31 | The Trustees of Columbia University in the City of New York | Machine learning for power grids |
US20140205040A1 (en) * | 2013-01-24 | 2014-07-24 | Futurewei Technologies, Inc. | System and Method for Digital Communications Using Channel Statistics |
US9338097B2 (en) * | 2013-10-31 | 2016-05-10 | Telefonaktiebolaget L M Ericsson (Publ) | Method and system for load balancing at a data network |
US10558932B1 (en) | 2014-04-23 | 2020-02-11 | Google Llc | Multi-machine distributed learning systems |
-
2015
- 2015-04-23 US US14/694,762 patent/US10558932B1/en active Active
-
2019
- 2019-12-18 US US16/719,881 patent/US11861466B1/en active Active
Patent Citations (6)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6442732B1 (en) * | 1999-04-21 | 2002-08-27 | Lucent Technologies, Inc. | Virtual logic system for solving satisfiability problems using reconfigurable hardware |
US20090083517A1 (en) * | 2007-09-25 | 2009-03-26 | Packeteer, Inc. | Lockless Processing of Command Operations in Multiprocessor Systems |
US20090204471A1 (en) * | 2008-02-11 | 2009-08-13 | Clearshift Corporation | Trust Level Based Task Assignment in an Online Work Management System |
US20090204470A1 (en) * | 2008-02-11 | 2009-08-13 | Clearshift Corporation | Multilevel Assignment of Jobs and Tasks in Online Work Management System |
US20100115027A1 (en) * | 2008-11-03 | 2010-05-06 | Samsung Electronics Co.,Ltd. | Method and apparatus for controlling access to resources in remote user interface service |
US20140108308A1 (en) * | 2012-07-13 | 2014-04-17 | Social Data Technologies, LLC | System and method for combining data for identifying compatibility |
Non-Patent Citations (5)
Title |
---|
"An introduction to distributed and parallel computing": Crichlow, 1988, Prentice Hall. * |
"Training a Large Scale Classifier with the Quantum Adiabatic Algorithm": Neven, 2009. * |
‘NIPS 2009 Demonstration: Binary Classification using Hardware Implementation of Quantum Annealing’: Neven, 2009. * |
'NIPS 2009 Demonstration: Binary Classification using Hardware Implementation of Quantum Annealing': Neven, 2009. * |
Yun et al., "NOMAD: Non-locking, stOchastic Multi-machine algorithm for Asynchronous and Decentralized matrix completion," arXiv:1312.0193v2 [cs.DC], Apr. 2014, pp. 1-18. |
Cited By (6)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US11861466B1 (en) | 2014-04-23 | 2024-01-02 | Google Llc | Multi-machine distributed learning systems |
US11514134B2 (en) | 2015-02-03 | 2022-11-29 | 1Qb Information Technologies Inc. | Method and system for solving the Lagrangian dual of a constrained binary quadratic programming problem using a quantum annealer |
US11797641B2 (en) | 2015-02-03 | 2023-10-24 | 1Qb Information Technologies Inc. | Method and system for solving the lagrangian dual of a constrained binary quadratic programming problem using a quantum annealer |
US10826845B2 (en) | 2016-05-26 | 2020-11-03 | 1Qb Information Technologies Inc. | Methods and systems for quantum computing |
US10824478B2 (en) * | 2016-06-13 | 2020-11-03 | 1Qb Information Technologies Inc. | Methods and systems for quantum ready and quantum enabled computations |
US11947506B2 (en) | 2019-06-19 | 2024-04-02 | 1Qb Information Technologies, Inc. | Method and system for mapping a dataset from a Hilbert space of a given dimension to a Hilbert space of a different dimension |
Also Published As
Publication number | Publication date |
---|---|
US11861466B1 (en) | 2024-01-02 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US11861466B1 (en) | Multi-machine distributed learning systems | |
US11068658B2 (en) | Dynamic word embeddings | |
EP3035250B1 (en) | Large-scale classification in neural networks using hashing | |
Cadini et al. | An improved adaptive kriging-based importance technique for sampling multiple failure regions of low probability | |
US10540587B2 (en) | Parallelizing the training of convolutional neural networks | |
US20210264109A1 (en) | Stylistic Text Rewriting for a Target Author | |
Recht et al. | Factoring nonnegative matrices with linear programs | |
CN108351982B (en) | Convolution gated recurrent neural network | |
CN106294533B (en) | The distributed work flow replicated using database | |
US10977737B2 (en) | Training gradient boosted decision trees with progressive maximum depth for parsimony and interpretability | |
US8903748B2 (en) | Systems and methods for large-scale randomized optimization for problems with decomposable loss functions | |
US8924315B2 (en) | Multi-task learning using bayesian model with enforced sparsity and leveraging of task correlations | |
Ames | Guaranteed clustering and biclustering via semidefinite programming | |
Gauraha | Introduction to the lasso: A convex optimization approach for high-dimensional problems | |
Wu et al. | Foundations of predictive analytics | |
US20170270407A1 (en) | Globally normalized neural networks | |
US20180075349A1 (en) | Training a machine learning model for analysis of instruction sequences | |
Bahadori et al. | Learning with minimum supervision: A general framework for transductive transfer learning | |
EP4120137A1 (en) | System and method for molecular property prediction using edge conditioned identity mapping convolution neural network | |
Rivotti et al. | Constrained dynamic programming of mixed-integer linear problems by multi-parametric programming | |
CN105045827A (en) | Familiarity based information recommendation method and apparatus | |
EP3044699A1 (en) | Information extraction | |
Croux et al. | Robust and sparse estimation of the inverse covariance matrix using rank correlation measures | |
EP3510528B1 (en) | Machine learning model for analysis of instruction sequences | |
US11327925B2 (en) | Method and system for data transfer between databases |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 4TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1551); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 4 |