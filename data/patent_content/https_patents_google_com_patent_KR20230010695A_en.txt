KR20230010695A - Differentiated private frequency deduplication - Google Patents
Differentiated private frequency deduplication Download PDFInfo
- Publication number
- KR20230010695A KR20230010695A KR1020227043543A KR20227043543A KR20230010695A KR 20230010695 A KR20230010695 A KR 20230010695A KR 1020227043543 A KR1020227043543 A KR 1020227043543A KR 20227043543 A KR20227043543 A KR 20227043543A KR 20230010695 A KR20230010695 A KR 20230010695A
- Authority
- KR
- South Korea
- Prior art keywords
- vector data
- data structures
- frequency
- providers
- vector
- Prior art date
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/21—Design, administration or maintenance of databases
- G06F16/215—Improving data quality; Data cleansing, e.g. de-duplication, removing invalid entries or correcting typographical errors
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/60—Protecting data
- G06F21/62—Protecting access to data via a platform, e.g. using keys or access control rules
- G06F21/6218—Protecting access to data via a platform, e.g. using keys or access control rules to a system of files or objects, e.g. local or distributed file system or database
- G06F21/6245—Protecting personal data, e.g. for financial or medical purposes
- G06F21/6254—Protecting personal data, e.g. for financial or medical purposes by anonymising data, e.g. decorrelating personal data from the owner's identification
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/22—Indexing; Data structures therefor; Storage structures
- G06F16/2228—Indexing structures
- G06F16/2237—Vectors, bitmaps or matrices
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/23—Updating
- G06F16/2365—Ensuring data consistency and integrity
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L63/00—Network architectures or network communication protocols for network security
- H04L63/04—Network architectures or network communication protocols for network security for providing a confidential data exchange among entities communicating through data packet networks
- H04L63/0428—Network architectures or network communication protocols for network security for providing a confidential data exchange among entities communicating through data packet networks wherein the data content is protected, e.g. by encrypting or encapsulating the payload
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L67/00—Network arrangements or protocols for supporting network services or applications
- H04L67/2866—Architectures; Arrangements
- H04L67/30—Profiles
- H04L67/306—User profiles
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/06—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols the encryption apparatus using shift registers or memories for block-wise or stream coding, e.g. DES systems or RC4; Hash functions; Pseudorandom sequence generators
- H04L9/0643—Hash functions, e.g. MD5, SHA, HMAC or f9 MAC
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/08—Key distribution or management, e.g. generation, sharing or updating, of cryptographic keys or passwords
- H04L9/0894—Escrow, recovery or storing of secret information, e.g. secret key escrow or cryptographic key storage
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/32—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols including means for verifying the identity or authority of a user of the system or for message authentication, e.g. authorization, entity authentication, data integrity or data verification, non-repudiation, key authentication or verification of credentials
- H04L9/3236—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols including means for verifying the identity or authority of a user of the system or for message authentication, e.g. authorization, entity authentication, data integrity or data verification, non-repudiation, key authentication or verification of credentials using cryptographic hash functions
- H04L9/3239—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols including means for verifying the identity or authority of a user of the system or for message authentication, e.g. authorization, entity authentication, data integrity or data verification, non-repudiation, key authentication or verification of credentials using cryptographic hash functions involving non-keyed hash functions, e.g. modification detection codes [MDCs], MD5, SHA or RIPEMD
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04W—WIRELESS COMMUNICATION NETWORKS
- H04W12/00—Security arrangements; Authentication; Protecting privacy or anonymity
- H04W12/02—Protecting privacy or anonymity, e.g. protecting personally identifiable information [PII]
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L2209/00—Additional information or applications relating to cryptographic mechanisms or cryptographic arrangements for secret or secure communication H04L9/00
- H04L2209/42—Anonymization, e.g. involving pseudonyms
Abstract
차등 프라이버시를 유지하면서 개인과 제공자 그룹 간의 상호작용을 기록하는 개선된 빈도별 카운팅 시스템을 위한 시스템 및 방법이 여기에 개시된다. 개인에 해당하는 식별자를 분류하기 위해 빈도 빈을 지정하는 프로토콜이 정의될 수 있다. 제공자는 프로토콜에 정의된 복수의 빈도에 각각 대응하는 복수의 프라이빗 스케치를 생성할 수 있다. 빈도 데이터는 각 식별자에 대해 결정된다. 식별자는 식별자의 관련 빈도에 해당하는 프라이빗 스케치로 인코딩된다. 제공자 그룹의 각 제공자로부터의 복수의 프라이빗 스케치는 그룹 전체에 걸쳐 중복 제거된 배포를 생성하기 위해 결합된다. 일 구현에서, 각 제공자의 프라이빗 스케치는 전체 분포가 추정될 수 있는 모든 스케치가 결합될 때까지 순차적으로 병합된다. Systems and methods are disclosed herein for an improved frequency counting system that records interactions between individuals and groups of providers while maintaining differential privacy. A protocol can be defined that specifies frequency bins to classify identifiers corresponding to individuals. The provider may create a plurality of private sketches each corresponding to a plurality of frequencies defined in the protocol. Frequency data is determined for each identifier. Identifiers are encoded into private sketches corresponding to the identifier's associated frequency. Multiple private sketches from each provider in the provider group are combined to create a deduplicated distribution across the group. In one implementation, each provider's private sketches are sequentially merged until all sketches from which the overall distribution can be estimated are combined.
Description
본 명세서는 차별화된 프라이빗 빈도 중복 제거에 관한 것이다.This specification relates to differentiated private frequency deduplication.
많은 경우에 컴퓨팅 및 데이터 분석 시스템은 데이터 분석 또는 처리의 일부로 대규모 데이터 세트의 인터섹션 또는 유니온(union)을 결정할 수 있다. 여러 소스에 분산된 대규모 데이터 세트의 유니온, 인터섹션 또는 빈도를 계산하려면 일반적으로 여러 원본 간에 대규모 데이터 세트에 대한 정보를 공유해야 한다. 각 출처의 정보에는 프라이빗 또는 보호된 정보가 포함될 수 있으며, 이러한 정보를 공유하면 프라이버시 및 보안에 부정적인 영향을 미칠 수 있다. In many cases, computing and data analysis systems can determine the intersections or unions of large data sets as part of data analysis or processing. Computing unions, intersections, or frequencies of large data sets distributed across multiple sources usually requires sharing information about large data sets among multiple sources. Information from each source may contain private or protected information, and sharing such information may adversely affect privacy and security.
본 기술 솔루션의 적어도 하나의 양태는 제공자 그룹에 걸쳐 데이터 세트를 중복 제거하기 위한 데이터 구조를 생성하기 위한 방법에 관한 것이고, 그 방법은, 하나 이상의 프로세서 및 메모리를 포함하는 데이터 처리 시스템에 의해, 상기 복수의 제공자들의 제공자와 복수의 사용자들 사이의 상호작용을 각각 식별하는 레코드의 데이터 세트를 데이터베이스에 유지하는 단계; 상기 데이터 처리 시스템에 의해, 복수의 벡터 데이터 구조들을 초기화하는 단계 -상기 복수의 벡터 데이터 구조들의 각각의 벡터 데이터 구조는 복수의 빈도들의 각각의 빈도에 대응함-; 상기 데이터 처리 시스템에 의해, 상기 복수의 사용자들 중 각각의 사용자에 대해, 상기 레코드의 데이터 세트에 기초하여 상기 사용자와 상기 제공자 간의 상호작용의 빈도 데이터를 결정하는 단계 -사용자의 빈도 데이터는 타겟 상호작용 유형을 갖는 사용자와 제공자 간의 상호작용의 수를 나타냄-; 상기 데이터 처리 시스템에 의해, 상기 복수의 사용자들의 각 사용자의 빈도 데이터에 기초하여 상기 복수의 벡터 데이터 구조들을 업데이트하는 단계 -상기 복수의 벡터 데이터 구조들의 제1 벡터 데이터 구조는 상기 복수의 빈도들의 제1 빈도 값에 대응하고 그리고 상기 복수의 벡터 데이터 구조들이 차등적으로 프라이빗(private)되도록 상기 제1 빈도 값과 일치하는 상호작용의 수를 나타내는 빈도 데이터를 갖는 상기 복수의 사용자들 중 사용자의 식별자를 인코딩하도록 업데이트됨-; 그리고 상기 데이터 처리 시스템에 의해, 상기 복수의 제공자들에 걸친 상기 레코드의 데이터 세트의 중복 제거를 위해 분석 서버에 상기 복수의 벡터 데이터 구조들을 전송하는 단계를 포함한다.At least one aspect of the present technical solution relates to a method for creating a data structure for deduplicating a data set across a group of providers, the method comprising: by a data processing system comprising one or more processors and memory; maintaining in a database a data set of records each identifying an interaction between a provider of a plurality of providers and a plurality of users; initializing, by the data processing system, a plurality of vector data structures, each vector data structure of the plurality of vector data structures corresponding to a respective frequency of a plurality of frequencies; determining, by the data processing system, for each user of the plurality of users, frequency data of interactions between the user and the provider based on the data set of records; Indicates the number of interactions between users and providers with action types; updating, by the data processing system, the plurality of vector data structures based on frequency data of each user of the plurality of users, a first vector data structure of the plurality of vector data structures being a first vector data structure of the plurality of frequencies; An identifier of a user of the plurality of users corresponding to 1 frequency value and having frequency data representing the number of interactions matching the first frequency value such that the plurality of vector data structures are differentially private. Updated to encode-; and sending, by the data processing system, the plurality of vector data structures to an analysis server for deduplication of the data set of records across the plurality of providers.
일부 구현에서, 상기 분석 서버는 중복 제거된 분포를 생성하기 위해 상기 복수의 벡터 데이터 구조들을 제2 제공자로부터의 제2 복수의 벡터 데이터 구조들과 결합한다. In some implementations, the analysis server combines the plurality of vector data structures with a second plurality of vector data structures from a second provider to create a deduplicated distribution.
일부 구현에서, 상기 복수의 벡터 데이터 구조들 각각은 복수의 카운터들에 대한 좌표를 정의하고, 상기 복수의 벡터 데이터 구조들을 업데이트하는 단계는 상기 사용자의 식별자를 인코딩하도록 상기 복수의 벡터 데이터 구조들에서 적어도 하나의 카운터를 업데이트하는 단계를 포함한다.In some implementations, each of the plurality of vector data structures defines coordinates for a plurality of counters, and the updating of the plurality of vector data structures is performed in the plurality of vector data structures to encode the identifier of the user. Updating at least one counter.
일부 구현에서, 상기 복수의 벡터 데이터 구조들을 업데이트하는 단계는 상기 사용자의 식별자의 해시 함수에 기초하여 상기 복수의 벡터 데이터 구조들의 제1 좌표를 결정하는 단계를 더 포함한다.In some implementations, updating the plurality of vector data structures further includes determining a first coordinate of the plurality of vector data structures based on a hash function of the user's identifier.
일부 구현들에서, 상기 복수의 벡터 데이터 구조들 각각은 1과 정의된 빈도 임계값 사이의 특정 빈도에 대응한다.In some implementations, each of the plurality of vector data structures corresponds to a specific frequency between 1 and a defined frequency threshold.
일부 구현에서, 상기 복수의 사용자들의 식별자들은 상기 복수의 벡터 데이터 구조들 중 하나 이하의 벡터 데이터 구조로 인코딩된다. In some implementations, identifiers of the plurality of users are encoded in one or more of the plurality of vector data structures.
본 개시의 다양한 양태들은 복수의 제공자들과의 사용자 상호작용의 빈도들에 대응하는 데이터 세트들을 중복 제거하기 위한 방법에 관한 것으로, 상기 방법은, 하나 이상의 프로세서 및 하나 이상의 메모리를 포함하는 데이터 처리 시스템에 의해, 복수의 제공자들 중 제1 제공자로부터 둘 이상의 벡터 데이터 구조들의 제1 세트를 수신하는 단계 -상기 제1 세트의 둘 이상의 벡터 데이터 구조들 각각은, 차등 프라이버시로, 상기 제1 세트의 둘 이상의 벡터 데이터 구조들 각각의 개별 빈도와 일치하는, 타겟 상호작용 유형을 갖는 상기 제1 제공자와의 상호작용의 수와 연관된 사용자 식별자들을 인코딩함-; 상기 데이터 처리 시스템에 의해, 복수의 제공자들 중 제2 제공자로부터 둘 이상의 벡터 데이터 구조들의 제2 세트를 수신하는 단계 -상기 제2 세트의 둘 이상의 벡터 데이터 구조들 각각은, 차등 프라이버시로, 상기 제2 세트의 둘 이상의 벡터 데이터 구조들 각각의 개별 빈도와 일치하는, 상기 타겟 상호작용 유형을 갖는 상기 제2 제공자와의 상호작용의 수와 연관된 사용자 식별자들을 인코딩함-; 그리고 상기 데이터 처리 시스템에 의해, 상기 둘 이상의 벡터 데이터 구조들의 제1 세트와 상기 둘 이상의 벡터 데이터 구조들의 제2 세트를 복수의 빈도들 각각에 대해 제1 제공자와 제2 제공자 모두에 걸쳐 타겟 상호작용 유형을 갖는 사용자 상호작용의 총 빈도를 정의하는 중복 제거된 빈도 분포로 결합하는 단계를 포함한다. Various aspects of the present disclosure relate to a method for deduplicating data sets corresponding to frequencies of user interactions with a plurality of providers, the method comprising: a data processing system comprising one or more processors and one or more memories; receiving a first set of two or more vector data structures from a first provider of a plurality of providers, wherein each of the two or more vector data structures of the first set, with Differential Privacy, two or more vector data structures of the first set; encode user identifiers associated with a number of interactions with the first provider with a target interaction type that match the respective frequency of each of the above vector data structures; receiving, by the data processing system, a second set of two or more vector data structures from a second provider of a plurality of providers, each of the two or more vector data structures of the second set, with differential privacy; encode user identifiers associated with a number of interactions with the second provider with the target interaction type that match a respective frequency of each of two sets of two or more vector data structures; and by the data processing system, the first set of two or more vector data structures and the second set of two or more vector data structures are targeted for interaction across both the first and second providers for each of a plurality of frequencies. combining into a deduplicated frequency distribution defining the total frequency of user interactions with the type.
일부 구현에서, 상기 데이터 처리 시스템에 의해, 중복 제거된 빈도 분포의 표현을 포함하는 그래픽 사용자 인터페이스 데이터를 생성하는 단계를 더 포함한다. In some implementations, further comprising generating, by the data processing system, graphical user interface data comprising a representation of the deduplicated frequency distribution.
일부 구현에서, 방법은 상기 데이터 처리 시스템에 의해, 임계 빈도를 상기 복수의 제공자들에게 전송하는 단계를 더 포함하고, 상기 복수의 빈도들은 상기 임계 빈도에 의해 정의된다. In some implementations, the method further comprises transmitting, by the data processing system, a threshold frequency to the plurality of providers, the plurality of frequencies being defined by the threshold frequency.
일부 구현에서, 상기 둘 이상의 벡터 데이터 구조들의 제1 세트 및 상기 둘 이상의 벡터 데이터 구조들의 제2 세트는 각각 1과 상기 임계 빈도 사이의 특정 빈도에 대응한다.In some implementations, the first set of two or more vector data structures and the second set of two or more vector data structures each correspond to a specific frequency between 1 and the threshold frequency.
일부 구현에서, 상기 식별자들은 상기 둘 이상의 벡터 데이터 구조들의 제1 세트의 하나 이하의 벡터 데이터 구조 및 상기 둘 이상의 벡터 데이터 구조들의 제2 세트의 하나 이하의 벡터 데이터 구조로 인코딩된다.In some implementations, the identifiers are encoded in one or less vector data structure of the first set of two or more vector data structures and one or less vector data structure of the second set of two or more vector data structures.
일부 구현에서, 상기 둘 이상의 벡터 데이터 구조들의 제1 세트 및 상기 둘 이상의 벡터 데이터 구조들의 제2 세트는 카운트 벡터들(vectors of counts)이다.In some implementations, the first set of two or more vector data structures and the second set of two or more vector data structures are vectors of counts.
일부 구현에서, 상기 둘 이상의 벡터 데이터 구조들의 제1 세트 및 상기 둘 이상의 벡터 데이터 구조들의 제2 세트는 임의의 분포 블룸 필터들(distribution bloom filters)이다. In some implementations, the first set of two or more vector data structures and the second set of two or more vector data structures are random distribution bloom filters.
일부 구현에서, 상기 둘 이상의 벡터 데이터 구조들의 제1 세트 및 상기 둘 이상의 벡터 데이터 구조들의 제2 세트를 상기 중복 제거된 빈도 분포로 결합하는 단계는, 상기 데이터 처리 시스템에 의해, 상기 둘 이상의 벡터 데이터 구조들의 제1 세트 및 상기 둘 이상의 벡터 데이터 구조들의 제2 세트를 둘 이상의 벡터 데이터 구조들의 제1 결합 세트로 결합하는 단계; 상기 데이터 처리 시스템에 의해, 상기 복수의 제공자들 중 제3 제공자로부터 둘 이상의 벡터 데이터 구조들의 제3 세트를 수신하는 단계; 그리고 상기 둘 이상의 벡터 데이터 구조들의 제1 세트 및 상기 둘 이상의 벡터 데이터 구조들의 제2 세트를 둘 이상의 벡터 데이터 구조들의 제1 결합 세트로 결합하는 것에 응답하여, 상기 데이터 처리 시스템에 의해, 둘 이상의 벡터 데이터 구조들의 제1 결합 세트와 제3 제공자로부터의 둘 이상의 벡터 데이터 구조들의 제3 세트를 둘 이상의 벡터 데이터 구조들의 제2 결합 세트로 결합하는 단계를 포함한다. In some implementations, combining the first set of two or more vector data structures and the second set of two or more vector data structures into the deduplicated frequency distribution comprises, by the data processing system, the two or more vector data structures. combining the first set of structures and the second set of two or more vector data structures into a first combined set of two or more vector data structures; receiving, by the data processing system, a third set of two or more vector data structures from a third provider of the plurality of providers; and in response to combining the first set of two or more vector data structures and the second set of two or more vector data structures into a first combined set of two or more vector data structures, by the data processing system, the two or more vectors combining the first combined set of data structures and the third set of two or more vector data structures from a third provider into a second combined set of two or more vector data structures.
일부 구현에서, 상기 둘 이상의 벡터 데이터 구조들의 제1 세트 및 상기 둘 이상의 벡터 데이터 구조들의 제2 세트를 상기 중복 제거된 빈도 분포로 결합하는 단계는, 상기 둘 이상의 벡터 데이터 구조들의 제1 세트의 제1 벡터 데이터 구조와 상기 둘 이상의 벡터 데이터 구조들의 제2 세트의 제2 벡터 데이터 구조 간의 인터섹션(intersection)을 결정하는 단계; 상기 제1 벡터 데이터 구조와 상기 제2 벡터 데이터 구조의 상기 인터섹션에 인코딩된 사용자 수를 결정하는 단계; 그리고 상기 결정된 사용자 수를 기반으로 상기 중복 제거된 빈도 분포를 업데이트하는 단계를 포함한다.In some implementations, combining the first set of two or more vector data structures and the second set of two or more vector data structures into the deduplicated frequency distribution comprises: determining an intersection between one vector data structure and a second vector data structure of the second set of the two or more vector data structures; determining the number of users encoded in the intersection of the first vector data structure and the second vector data structure; and updating the frequency distribution with duplicate removal based on the determined number of users.
본 개시의 다양한 양태는 또한 복수의 제공자로부터 수신된 데이터 세트를 감소시키기 위한 시스템에 관한 것이고, 상기 시스템은, 상기 복수의 제공자들과 연관된 복수의 서버들과 통신하도록 구성된 네트워크 인터페이스; 그리고Various aspects of the disclosure also relate to a system for reducing a data set received from a plurality of providers, the system comprising: a network interface configured to communicate with a plurality of servers associated with the plurality of providers; And
상기 네트워크 인터페이스 및 메모리에 연결된 하나 이상의 프로세서를 포함하며, 상기 메모리는 상기 하나 이상의 프로세서에 의해 실행될 때 상기 하나 이상의 프로세서로 하여금 동작들을 수행하게 하는 명령어를 저장하며; 상기 동작들은, 상기 네트워크 인터페이스를 통해, 상기 복수의 제공자들 중 제1 제공자로부터 차등적 프라이빗 스케치(private sketche)들의 제1 세트를 수신하는 동작 -상기 제1 세트의 차등적 프라이빗 스케치들 각각은 차등 프라이버시로, 상기 제1 세트의 차등적 프라이빗 스케치들 각각의 개별 빈도와 일치하는, 타겟 상호작용 유형을 갖는 상기 제1 제공자와의 상호작용의 수와 연관된 사용자 식별자들을 인코딩함-; 상기 네트워크 인터페이스를 통해, 상기 복수의 제공자들 중 제2 제공자로부터 차등적 프라이빗 스케치들의 제2 세트를 수신하는 동작 -상기 제2 세트의 차등적 프라이빗 스케치들 각각은 차등 프라이버시로, 상기 제2 세트의 차등적 프라이빗 스케치들 각각의 개별 빈도와 일치하는, 타겟 상호작용 유형을 갖는 상기 제2 제공자와의 상호작용의 수와 연관된 사용자 식별자들을 인코딩함-; 상기 차등적 프라이빗 스케치들의 제1 세트와 상기 차등적 프라이빗 스케치들의 제2 세트를 사용하여 결합된 분포를 생성하는 동작 -상기 결합된 분포는 상기 차등적 프라이빗 스케치들의 제1 세트와 상기 차등적 프라이빗 스케치들의 제2 세트로 표시되는 상기 데이터 세트들의 중복을 제거하고 그리고 복수의 빈도들 각각에 대해 상기 제1 제공자와 상기 제2 제공자 모두에 걸쳐 상기 타겟 상호작용 유형을 갖는 사용자 상호작용의 총 빈도를 정의함-; 데이터베이스에 상기 결합된 분포를 저장하는 동작을 포함한다.one or more processors coupled to the network interface and memory, the memory storing instructions that when executed by the one or more processors cause the one or more processors to perform operations; The operations include receiving, via the network interface, a first set of differential private sketches from a first provider of the plurality of providers, each of the differential private sketches in the first set being a differential encode user identifiers associated with a number of interactions with the first provider with a target interaction type that match the individual frequency of each of the differential private sketches in the first set, with privacy; receiving, via the network interface, a second set of differential private sketches from a second provider of the plurality of providers, each of the differential private sketches of the second set having differential privacy; encode user identifiers associated with a number of interactions with the second provider with a target interaction type that match the respective frequency of each of the differential private sketches; generating a combined distribution using the first set of differential private sketches and the second set of differential private sketches, the combined distribution comprising the first set of differential private sketches and the differential private sketch deduplicating the data sets represented by a second set of frequencies and defining for each of a plurality of frequencies a total frequency of user interactions with the target interaction type across both the first provider and the second provider box-; and storing the combined distribution in a database.
일부 구현들에서, 상기 동작들은, 상기 차등적 프라이빗 스케치들의 제1 세트와 상기 차등적 프라이빗 스케치들의 제2 세트를 차등적 프라이빗 스케치들의 병합된 세트로 결합하는 동작; 그리고 상기 데이터베이스에, 상기 차등적 프라이빗 스케치들의 병합된 세트를 저장하는 동작을 더 포함한다.In some implementations, the operations may include combining the first set of differential private sketches and the second set of differential private sketches into a merged set of differential private sketches; and storing the merged set of differential private sketches in the database.
일부 구현에서, 상기 동작들은, 상기 복수의 제공자들 중 제3 제공자로부터 차등적으로 프라이빗 스케치들의 제3 세트를 수신하는 동작; 상기 차등적 프라이빗 스케치들의 병합된 세트와 상기 차등적 프라이빗 스케치들의 제3 세트를 결합하여 차등적 프라이빗 스케치들의 새로 병합된 세트(new merged set)를 생성하는 동작; 그리고 상기 차등적 프라이빗 스케치들의 새로 병합된 세트를 상기 데이터베이스에 저장하는 동작을 더 포함한다. In some implementations, the operations include receiving a third set of private sketches differentially from a third provider of the plurality of providers; combining the merged set of differential private sketches and the third set of differential private sketches to create a new merged set of differential private sketches; and storing the newly merged set of differential private sketches in the database.
일부 구현에서 프라이빗 스케치는 VOC(Vector of counts)이다.In some implementations, the private sketch is a vector of counts (VOC).
일부 구현에서 프라이빗 스케치는 배포 블룸 필터이다.In some implementations the private sketch is a distributed bloom filter.
본 기술의 이러한 및 기타 특징 및 특성뿐만 아니라, 관련 구조 요소의 기능 및 동작의 방법 및 부품의 조합과 제조의 경제성은 모두 본 명세서의 일부를 형성하는 첨부 도면을 참조하여 다음 설명 및 첨부된 청구범위를 고려하면 더욱 분명해질 것이며, 여기서, 유사한 참조 번호는 다양한 도면에서 대응하는 부분을 나타낸다. 그러나, 도면은 단지 예시 및 설명을 위한 것이며 본 발명의 제한을 정의하려는 것이 아님을 분명히 이해해야 한다. 명세서 및 청구범위에 사용된 단수 형태는 문맥이 명백하게 달리 지시하지 않는 한 복수의 지시 대상을 포함한다.These and other features and characteristics of the present technology, as well as the function of the related structural elements and methods of operation and combinations of parts and economy of manufacture, all of which are described in the following description and appended claims with reference to the accompanying drawings, which form a part of this specification. , where like reference numbers indicate corresponding parts in the various figures. However, it should be clearly understood that the drawings are for illustration and description only and are not intended to define the limitations of the present invention. The singular forms used in the specification and claims include plural referents unless the context clearly dictates otherwise.
첨부된 도면은 축척에 맞게 그려진 것이 아니다. 다양한 도면에서 유사한 참조 번호 및 명칭은 유사한 요소를 나타낸다. 명확성을 위해 모든 컴포넌트에 모든 도면에 레이블이 지정되지 않을 수 있다. 본 기술 솔루션의 이러한 양태 및 특징은 첨부 도면과 함께 다음 설명을 검토하면 당업자에게 명백해질 것이다.
도 1은 장치 식별자의 카운트 및 빈도를 결정하기 위해 프라이빗 스케치 세트를 생성하기 위한 시스템의 예시적인 구현을 예시하는 블록도를 도시한다.
도 2는 데이터 세트를 프라이빗 스케치 세트로 인코딩하기 위한 프로세스의 흐름도를 도시한다.
도 3은 블룸 필터를 업데이트하는 예시적인 예를 도시한다.
도 4a 내지 도 4c는 임의의 분포 블룸 필터의 예시적인 예를 도시한다.
도 5는 데이터 세트를 임의의 분포 블룸 필터로 인코딩하기 위한 프로세스의 흐름도를 도시한다.
도 6은 단일 분포를 생성하기 위해 복수의 제공자로부터 데이터 세트를 중복 제거하기 위한 프로세스의 흐름도를 도시한다.
도 7은 단일 세트의 프라이빗 스케치를 생성하기 위해 프라이빗 스케치 세트를 순차적으로 병합하기 위한 흐름도를 도시한다.
도 8a 내지 도 8d는 시스템의 다양한 실험 파라미터의 비교 및 순차 병합 알고리즘을 사용하여 결과 계산에 미치는 영향을 나타내는 예시적인 데이터 그래프를 도시한다.
도 9a 및 도 9b는 시스템의 다양한 실험 파라미터의 비교 및 PO(pairwise-overlap) 알고리즘을 사용하여 결과 계산에 미치는 영향을 나타내는 예시적인 데이터 그래프를 도시한다.
도 10은 본 명세서에서 설명된 임의의 컴퓨팅/처리 장치 및 회로를 구현하기 위해 사용될 수 있는 예시적인 컴퓨터 시스템의 일반적인 아키텍처를 도시한다.The accompanying drawings are not drawn to scale. Like reference numbers and designations in the various drawings indicate like elements. For clarity, not all components may be labeled in all drawings. These aspects and features of the present technology solution will become apparent to those skilled in the art upon review of the following description in conjunction with the accompanying drawings.
1 shows a block diagram illustrating an example implementation of a system for generating a set of private sketches to determine the count and frequency of device identifiers.
2 shows a flow diagram of a process for encoding a data set into a private sketch set.
3 shows an illustrative example of updating a bloom filter.
4A-4C show illustrative examples of random distributed bloom filters.
5 shows a flow diagram of a process for encoding a data set into an arbitrary distributed bloom filter.
6 shows a flow diagram of a process for deduplicating data sets from multiple providers to create a single distribution.
7 shows a flow diagram for sequentially merging sets of private sketches to create a single set of private sketches.
8A-8D show example data graphs showing comparison of various experimental parameters of the system and their effect on result calculations using the sequential merge algorithm.
9A and 9B show example data graphs showing a comparison of various experimental parameters of the system and their effect on the calculation of results using a pairwise-overlap (PO) algorithm.
10 illustrates the general architecture of an example computer system that can be used to implement any of the computing/processing devices and circuits described herein.
다음은 데이터 교환 및 저장의 크기 및 복잡성 요구 사항을 줄이면서 정확도 및 프라이버시를 증가시키면서 빈도별 도달 데이터(reach data)의 프라이빗 스케치를 생성 및 결합하는 방법, 장치 및 시스템과 관련된 다양한 개념 및 구현에 대한 자세한 설명이다. 설명된 개념이 특정 구현 방식으로 제한되지 않기 때문에 위에서 소개되고 아래에서 더 자세히 설명되는 다양한 개념은 다양한 방식으로 구현될 수 있다. 특정 구현 및 애플리케이션의 예는 주로 설명을 위해 제공된다. The following describes various concepts and implementations related to methods, devices and systems for generating and combining private sketches of frequency-specific reach data while increasing accuracy and privacy while reducing size and complexity requirements for data exchange and storage. detailed explanation. The various concepts introduced above and described in more detail below may be implemented in a variety of ways, as the described concepts are not limited to any particular implementation. Examples of specific implementations and applications are provided primarily for illustrative purposes.
제공자 그룹은 집단 내의 개인과 각각 상호작용할 수 있고 상기 상호작용의 발생 및 빈도를 개별적으로 기록할 수 있다. 여기서, 개인("사용자", "클라이언트" 또는 "고객"과 같은 의미로 사용됨)은 특정 유형의 상호작용(예: 특정 콘텐츠 캠페인, 특정 콘텐츠 아이템, 특정 콘텐츠 아이템 세트, 콘텐츠 아이템의 특정 유형/형식, 콘텐츠의 특정 카테고리 등)을 위해 개인이 제공자와 상호작용한 횟수를 나타내는 빈도와 연관될 수 있다. 각 제공자가 관리하는 데이터 세트는 제공자와 상호 작용하는 개인의 프라이버시를 보장하기 위해 보호되므로 제공자는 기록된 데이터 세트의 세부 정보를 그룹의 다른 제공자와 자유롭게 공유할 수 없다. 그러나 제공자 그룹은 각 상호작용 빈도당 전체 제공자 그룹에 걸쳐 개인에 대한 상호작용의 총 분포를 이해하는 데 관심이 있을 수 있다. 예를 들어, 제공자 또는 분석가는 모집단에서 제공자 그룹과 총 3번의 상호작용을 한 개인이 몇 명인지 또는 제공자 그룹과 총 5번 이상의 상호작용을 한 개인이 몇 명인지 등을 알고 싶어할 수 있다. A group of providers may each interact with individuals in the population and individually record the occurrence and frequency of such interactions. Here, an individual (used interchangeably with “user”, “client”, or “customer”) is a specific type of interaction (e.g., a specific content campaign, a specific content item, a specific set of content items, or a specific type/form of content items). , a particular category of content, etc.) The data sets managed by each provider are protected to ensure the privacy of individuals interacting with the providers, so providers cannot freely share details of recorded data sets with other providers in the group. However, the provider group may be interested in understanding the total distribution of interactions for individuals across the entire provider group per frequency of each interaction. For example, a provider or analyst may want to know how many individuals in a population have interacted with a group of providers a total of 3 times, or how many individuals have interacted with a group of providers a total of 5 times or more, and the like.
한 가지 방법론에는 인코딩된 프라이빗 스케치(private sketch)를 사용하여 전체 도달범위를 이해하기 위해 여러 제공자의 데이터 세트를 중복 제거(deduplicating)하는 것이 포함된다(즉, 그룹의 적어도 한 제공자와 상호 작용한 개인의 수를 결정). 프라이빗 스케치는 프라이빗 스케치에 포함된 사용자의 신원을 공개하지 않고 사용자의 신원에 관한 암호화된 정보를 제공하는 데이터 구조이다. 프라이빗 스케치는 분석가 또는 자동화된 서버가 데이터 세트의 중복을 제거할 수 있도록 구성된다. 중복 제거는 데이터 세트에 여러 번 포함될 수 있는 엔트리를 제거하는 것을 말한다. 예를 들어, 제1 제공자는 개인 A 및 개인 B와의 상호 작용을 기록할 수 있고 제2 제공자는 개인 A 및 개인 C와의 상호 작용을 기록할 수 있다. 그러나 두 데이터 세트를 결합할 때 개인 A는 총 3명의 개인이 제1 및 제2 제공자의 총 도달범위로 기록되도록 한 번만 기록해야 한다. One methodology involves deduplicating data sets from multiple contributors (i.e., individuals who have interacted with at least one contributor in the group) to understand overall reach using an encoded private sketch. determine the number of). A private sketch is a data structure that provides encrypted information about a user's identity without disclosing the identity of the user contained in the private sketch. Private sketches are constructed so that analysts or automated servers can dedupe data sets. Deduplication refers to removing entries that may be included multiple times in a data set. For example, a first contributor may record interactions with Person A and Person B and a second contributor may record interactions with Person A and Person C. However, when combining the two data sets, individual A must be recorded only once so that a total of three individuals are recorded with the total reach of the first and second providers.
그럼에도 불구하고 이러한 데이터 세트 중복 제거 방법론은 보호되는 개인 정보의 프라이빗로 인해 빈도별 분석(예: 빈도별 도달 또는 배포)을 허용하지 않는다. 예를 들어, 신원을 프라이빗 스케치로 인코딩함으로써 제공자는 개인의 관련 빈도 데이터를 프라이빗 스케치로 인코딩하는 것을 금지하고, 이는 분석가가 빈도에 따라 데이터 세트를 정확하게 중복 제거하는 능력을 제한한다. 위에서 사용된 예시적인 예를 다시 참조하면, 빈도별 분석에서 데이터 세트 중복 제거는 개인 A가 제1 제공자와 두 번, 제2 제공자와 한 번 상호 작용하는 경우 개인 A가 할당되거나 총 빈도가 3인 것으로 계산되도록 데이터 세트를 중복 제거해야 함을 의미한다. 이러한 방법론을 사용하여 사용자 식별자와 관련하여 빈도 데이터(frequency data)를 포함하려는 시도는 데이터 교환 프로토콜의 크기, 복잡성 및 유도된 오류를 증가시킬 것이다. 일반적으로 프라이빗된 정보의 향상된 저장 및 전송을 위해 데이터 세트의 크기와 복잡성을 줄이는 것이 바람직하다. Nonetheless, these data set deduplication methodologies do not allow frequency-by-frequency analysis (e.g. frequency-by-frequency arrival or distribution) due to the privacy of the personal information being protected. For example, by encoding identities into private sketches, providers are prohibited from encoding an individual's associated frequency data into private sketches, which limits the ability of analysts to accurately de-duplicate data sets based on frequency. Referring back to the illustrative example used above, in a frequency-by-frequency analysis, data set deduplication is that if individual A interacts with the first contributor twice and with the second contributor once, then individual A is assigned or the total frequency is three. means that the data set must be deduplicated so that it counts as Attempting to include frequency data in association with user identifiers using this methodology will increase the size, complexity, and error induced of data exchange protocols. It is generally desirable to reduce the size and complexity of data sets for improved storage and transmission of private information.
제공자는 범용 식별자를 기반으로 개인을 재식별할 수 있기 때문에 제공자는 마찬가지로 익명화된 데이터 세트를 공유하는 것이 제한된다. 프라이빗(프라이빗)된 데이터 세트의 데이터 프라이버시에 대한 한 가지 표준은 데이터 세트가 차등 프라이버시(differential privacy)를 유지하도록 하는 것이다. 차등 프라이버시는 일반적으로 데이터 세트에 포함된 특정 사용자의 프라이버시가 데이터 세트에 없는 개인의 프라이버시와 거의 동일하다고 규정한다. 다시 말해, 차등 프라이버시는 특정 사용자가 데이터 세트에 포함되었는지 여부를 결정하는 능력을 가리게(obscure) 한다. Because providers can re-identify individuals based on universal identifiers, providers are likewise limited from sharing anonymized data sets. One standard for data privacy in data sets that are private is to ensure that the data set maintains differential privacy. Differential privacy generally stipulates that the privacy of a particular user included in a data set is approximately equal to the privacy of individuals not included in the data set. In other words, differential privacy obscures the ability to determine whether a particular user is included in a data set.
본 개시는 데이터 교환 처리 시스템에서 빈도별 분석을 위해 데이터 세트를 중복 제거하기 위한 프로토콜 및 관련 방법을 정의함으로써 이러한 문제에 대한 솔루션을 제공한다. 일반적으로, 제공자 그룹은 각각의 프라이빗 스케치가 개인과 제공자 간의 특정 상호 작용 빈도에 해당하는 미리 정의된 수의 프라이빗 스케치를 생성한다. 그런 다음 각 제공자는 전체 배포가 생성될 수 있도록 프라이빗 스케치 세트를 공유할 수 있다. 전체 분포는 전체 제공자 그룹과의 총 상호작용 횟수(즉, 총 빈도)에 따라 익명으로 개인을 분류한다. 제공자 또는 분석가는 얼마나 많은 고유한 개인이 제공자 그룹과 한 번 상호 작용했는지, 얼마나 많은 개인이 그룹과 두 번 상호 작용했는지 등을 이해할 수 있다. 따라서 차등 개인 데이터 교환 프로토콜을 활용하여 교환된 데이터 세트의 크기와 복잡성을 줄이고 보호된 정보를 노출하지 않고 제공자 그룹 전체에서 데이터 세트를 보다 정확하게 중복 제거할 수 있다. The present disclosure provides a solution to this problem by defining protocols and related methods for deduplicating data sets for frequency-by-frequency analysis in a data exchange processing system. Typically, a provider group creates a predefined number of private sketches, each private sketch corresponding to a particular frequency of interaction between the individual and the provider. Each provider can then share a set of private sketches from which a full distribution can be created. The overall distribution classifies individuals as anonymous according to the total number of interactions (i.e., total frequency) with the entire group of providers. A provider or analyst can understand how many unique individuals have interacted with a group of providers once, how many individuals have interacted with a group twice, and the like. Thus, differential private data exchange protocols can be leveraged to reduce the size and complexity of exchanged data sets and more accurately de-dupe data sets across groups of providers without exposing protected information.
예시적인 구현에 따라 프로토콜의 더 자세한 개요가 아래에 제공된다.A more detailed overview of the protocol, along with example implementations, is provided below.
첫째, s개의 제공자들의 그룹에 대해, 임계 빈도는 k로 지정될 수 있는 모든 제공자에 의해 합의된다.First, for a group of s providers, a threshold frequency is agreed upon by all providers that can be specified as k.
그런 다음 제공자 그룹의 각 제공자 i는 k개의 프라이빗 스케치를 개별적으로 생성하여 제공자 i가 상호작용한 개인과 관련된 식별자를 개인적으로 인코딩한다. k 프라이빗 스케치가 지정된다.Then, each provider i in the provider group individually creates k private sketches to privately encode identifiers associated with the individuals with whom provider i has interacted. k A private sketch is specified.
스케치 #1(Sketch #1): 빈도 f = 1인 식별자들(identifiers)Sketch #1: identifiers with frequency f = 1
스케치 #2(Sketch #2): 빈도 f = 2인 식별자들Sketch #2: identifiers with frequency f = 2
……
스케치 #(k-1): 빈도 f = (k-1)인 식별자들Sketch #(k-1): identifiers with frequency f = (k-1)
스케치 #k: 빈도 f >= k인 식별자들(f = k+와 상호교환적으로 사용됨)Sketch #k: identifiers with frequency f >= k (used interchangeably with f = k+)
따라서, 제공자의 레코드에 있는 각 식별자는 개인과 제공자 i 간의 상호 작용 수(횟수)에 따라 k 프라이빗 스케치 중 정확히 하나로 인코딩될 수 있다. Thus, each identifier in the provider's record can be encoded into exactly one of the k private sketches, depending on the number (number) of interactions between the person and provider i.
제공자 i가 상호작용하지 않은 개인이 있는 경우(종종 그런 경우임), 해당 개인은 제공자 i에 대한 프라이빗 스케치로 인코딩되지 않는다. If there is an individual that provider i has not interacted with (which is often the case), that individual is not encoded in the private sketch for provider i.
s 제공자 각각은 k 프라이빗 스케치 세트를 생성하며, 이를 결합하여 모든 s 제공자에 대한 전체 배포를 형성할 수 있다. 특정 빈도 w에 대한 빈도별 도달범위(per-frequency reach)(즉, 제공자 그룹 전체에 걸쳐 특정 수의 상호작용을 한 개인의 총 수)는 수학식 1과 같은 표기법으로 나타낼 수 있다.Each s provider creates a set of k private sketches, which can be combined to form a global distribution to all s providers. The per-frequency reach for a specific frequency w (ie, the total number of individuals who have had a specific number of interactions across all provider groups) can be represented by a notation such as
여기서, 각 R은 s 제공자 각각의 다양한 빈도 조합을 기반으로 총 빈도가 w인 고유한 개인의 총 수를 출력하는 함수이다. 예시적인 예로, w = 3의 경우, 개인이 제공자(1)와 두 번(Here, each R is a function that outputs the total number of unique individuals whose total frequency is w, based on the various frequency combinations of each of the s providers. As an illustrative example, in the case of w = 3, the individual twice with the provider (1) (
다음 섹션에서 더 자세히 설명될 빈도별 도달범위(Reach by frequency (which will be discussed in more detail in the next section)
개시된 방법 및 시스템의 기술적 이점은 프라이빗된(privatized) 데이터 세트의 전송 및 저장을 위한 크기 및 복잡성의 감소이다. 위에서 설명한 대로 데이터 세트는 프라이빗 스케치로 인코딩되어 데이터 세트의 전체 크기를 줄인다. 또한, 본 솔루션은 빈도별 분석을 위해 설계된 다른 차등-프라이빗 교환 프로토콜과 비교하여 빈도별 차등-프라이빗 데이터 세트의 복잡성을 줄인다. A technical advantage of the disclosed method and system is the reduction in size and complexity for transmission and storage of private data sets. As described above, the dataset is encoded as a private sketch to reduce the overall size of the dataset. Additionally, the solution reduces the complexity of frequency-dependent differential-private data sets compared to other differential-private exchange protocols designed for frequency-based analysis.
제2 기술적 이점은 프라이빗된 데이터 구조에서 중복 제거된(deduplicated) 데이터 세트의 정확도를 향상시키는 데 있다. DP(Differential Privacy)는 개인이 데이터 세트에 포함되는지 여부를 통계적으로 결정하는 신뢰도 레벨에 해당하는 0이 아닌 오류 값(non-zero error value)(ε)을 정의하여 테스트할 수 있다. ε 값은 개인을 포함하는지 여부만 다른 두 개의 동일한 데이터 세트 간의 한계 차이로 간주된다. 신뢰도 레벨이 ε보다 작을 때 차등 프라이버시(DP: Differential privacy)가 유지된다. 더 작은 데이터 세트의 경우 데이터 세트에 대한 변경 사항이 비례적으로 더 커지고 ε-DP 임계값을 유지하기 위해 데이터 세트에 노이즈(때때로 DP 노이즈라고도 함)가 추가될 수 있다. 마찬가지로, 앞서 언급한 방법론을 사용하여 빈도 데이터를 인코딩하는 경우와 같이 편차가 더 큰 분포의 경우, 차등 프라이버시를 유지하기 위해 더 높은 비율의 DP 노이즈가 추가되어 전체 분포 추정치에서 오류가 증가한다. 식별자와 관련하여 프라이빗 스케치의 빈도 데이터를 인코딩하지 않음으로써 현재 솔루션은 중복 제거된 데이터의 정확도를 높인다. A second technical benefit is to improve the accuracy of deduplicated data sets in private data structures. Differential Privacy (DP) can be tested by defining a non-zero error value (ε) that corresponds to a confidence level that statistically determines whether an individual is included in a data set. The value of ε is taken as the marginal difference between two identical data sets that differ only in whether they contain individuals. Differential privacy (DP) is maintained when the confidence level is less than ε. For smaller data sets, changes to the data set are proportionately larger and noise (sometimes called DP noise) can be added to the data set to maintain the ε-DP threshold. Similarly, for distributions with greater variance, such as when frequency data is encoded using the aforementioned methodology, a higher percentage of DP noise is added to maintain differential privacy, increasing the error in the overall distribution estimate. By not encoding the private sketch's frequency data with respect to the identifier, the current solution increases the accuracy of the deduplicated data.
여기에 설명된 시스템 및 방법의 사용 사례는 의료 산업과 관련될 수 있다. 예를 들어, 병원 그룹은 각각 도시 또는 지역에 서비스를 제공할 수 있으며, 각 병원은 내부적으로 특정 환자와의 상호 작용 수를 기록할 수 있지만 병원은 환자가 병원 그룹(예: ER 방문)에서 제공된 서비스를 얼마나 자주 받는지 이해하는 데 관심이 있을 수 있다. 그러나 보호되는 개인 정보의 공유에 대한 법적 제한으로 인해, 병원은 서비스를 제공한 환자의 신원을 공유하는 것이 허용되지 않을 수 있으므로 환자가 서비스를 받은 빈도의 중복 제거 분포(deduplicated distribution)를 계산하기 위해 데이터를 자유롭게 공유할 수 없다. 현재 솔루션은 여러 병원의 데이터 처리 시스템이 전체 분포를 추정할 수 있는 프라이빗된 환자 정보를 공유할 수 있는 안전한 방법을 제공한다. Use cases for the systems and methods described herein may relate to the medical industry. For example, a group of hospitals may each serve a city or region, and each hospital may internally record the number of interactions with a particular patient, but hospitals may not be able to track the number of interactions a patient has received from a group of hospitals (e.g., ER visits). You may be interested in understanding how often you receive services. However, due to legal restrictions on the sharing of protected personal information, hospitals may not be permitted to share the identity of patients who provided services, so to calculate a deduplicated distribution of the frequency with which patients received services. Data cannot be freely shared. The current solution provides a secure way for multiple hospitals' data processing systems to share private patient information that allows them to estimate overall distributions.
여기에 설명된 시스템 및 방법의 또 다른 사용 사례는 온라인 광고와 관련될 수 있다. 온라인 마케팅 담당자는 비용을 지불하여 여러 웹사이트에 광고를 게재할 수 있다. 마케터는 잠재 고객을 더 잘 이해하기 위해 인터넷 사용자가 여러 웹 사이트에서 광고를 본 빈도를 이해하고자 할 수 있다. 그러나 온라인 사용자 데이터의 개인 정보 보호 문제로 인해, 웹 사이트 서버는 웹 사이트에 액세스한 다른 사용자 또는 특정 사용자가 광고가 포함된 웹 페이지를 본 횟수를 공유하는 것이 허용되지 않을 수 있다. 여기에 설명된 솔루션을 사용하면 웹사이트가 민감한 사용자 정보를 노출하지 않고 마케팅 데이터를 프라이빗로 공유할 수 있으므로 광고주가 얼마나 많은 사람들이 자신의 광고를 몇 번 보았는지 이해할 수 있다. Another use case for the systems and methods described herein may relate to online advertising. Online marketers can pay to place ads on multiple websites. Marketers may want to understand how often internet users have seen ads on different websites in order to better understand their potential customers. However, due to privacy concerns of online user data, website servers may not be allowed to share the number of times a particular user or other users who have accessed the website have viewed a web page containing advertisements. The solution described here allows websites to privately share marketing data without exposing sensitive user information, allowing advertisers to understand how many people have seen their ads and how many times.
도 1을 참조하면, 상호작용 데이터의 전체 도달 분포(reach distribution)를 생성하기 위해 다중 제공자로부터 데이터 세트를 중복 제거하는(deduplicating) 시스템(100)이 도시되어 있다. 시스템(100)은 적어도 하나의 데이터 처리 시스템(105A-S)(때때로 일반적으로 데이터 처리 시스템(105)이라고 함), 적어도 하나의 네트워크(110), 적어도 하나의 중복 제거 서버(분석 서버와 혼용)(115), 및 적어도 하나의 분석 장치(120)를 포함할 수 있다. 일부 구현에서, 시스템(100)은 적어도 하나의 클라이언트 장치(135A-N)(때때로 일반적으로 클라이언트 장치(135)로 지칭됨)를 포함한다. 데이터 처리 시스템(105)은 적어도 하나의 벡터 생성기(140), 적어도 하나의 빈도 식별자(145), 적어도 하나의 벡터 선택기(150), 적어도 하나의 데이터 레코더 해셔(recorder hasher)(155), 및 적어도 하나의 벡터 인코더(160)를 포함하는 저장 매체(108) 및 적어도 하나의 프로세서(107)를 갖는 처리(프로세싱) 회로(106)를 포함한다. 데이터베이스(125)는 클라이언트 식별자(132) 및 대응하는 속성(134)을 포함할 수 있는 적어도 하나의 데이터 레코드(130)를 포함할 수 있다. 유사하게, 중복 제거 서버(115)는 적어도 하나의 프로세서(117) 및 적어도 하나의 프로토콜 조정기(165), 적어도 하나의 벡터 중복 제거기(170), 적어도 하나의 분포 생성기(175), 및 적어도 하나의 GUI 생성기(180)를 포함하는 저장 매체(118)를 갖는 처리 회로(116)를 포함한다. Referring to FIG. 1 , a
시스템(100)의 컴포넌트들(예: 데이터 처리 시스템(105), 네트워크(110), 중복 제거 서버(115), 분석 장치(120), 클라이언트 장치(135)) 각각은 하드웨어 컴포넌트, 소프트웨어(하나 이상의 컴퓨터 판독 가능 저장 매체에 저장된 명령어), 또는 이들의 조합(예를 들어, 도 10과 관련하여 본 명세서에 상세히 설명된 컴퓨팅 시스템(1000)의 하드웨어 컴포넌트 또는 하드웨어 컴포넌트와 소프트웨어의 조합)을 사용하여 구현될 수 있다. 예를 들어, 데이터 처리 시스템(105)은 서버 또는 다른 컴퓨팅 장치를 포함할 수 있다. 분석 장치(120)는 서버 또는 다른 컴퓨팅 장치를 포함할 수 있다. 유사하게, 데이터 처리 시스템(105) 및 중복 제거 서버(115)의 하위 컴포넌트(예를 들어, 벡터 생성기(140), 빈도 식별자(145), 벡터 선택기(150), 데이터 레코더 해셔(155), 벡터 인코더(160), 프로토콜 조정기(165), 벡터 중복 제거기(170), 분배 생성기(175), 및 GUI 생성기(180))는 여기에 설명된 기능을 수행하기 위해 별개의 또는 결합된 하드웨어 및/또는 소프트웨어 요소로 구현될 수 있다. Each of the components of system 100 (e.g., data processing system 105,
네트워크(110)는 인터넷, 로컬, 와이드, 메트로 또는 기타 영역 네트워크, 인트라넷, 위성 네트워크, 음성 또는 데이터 이동 전화 통신 네트워크와 같은 다른 컴퓨터 네트워크, 및 이들의 조합과 같은 컴퓨터 네트워크를 포함할 수 있다. 시스템(100)의 데이터 처리 시스템(105)은 네트워크(110)를 통해, 예를 들어 다른 데이터 처리 시스템(105A-S), 중복 제거 서버(115), 및/또는 분석 장치(120)와 통신할 수 있다. 네트워크(110)는 중복 제거 서버(115), 데이터 처리 시스템(105), 및 웹 서버와 같은 하나 이상의 다른 소스 사이에서 정보를 중계하는 임의의 형태의 컴퓨터 네트워크일 수 있다. 일부 구현에서, 네트워크(110)는 인터넷 및/또는 LAN(Local Area Network), WAN(Wide Area Network), 셀룰러 네트워크, 위성 네트워크, 또는 다른 유형의 데이터 네트워크와 같은 다른 유형의 데이터 네트워크를 포함할 수 있다. 네트워크(110)는 또한 네트워크(110) 내에서 데이터를 수신 및/또는 전송하도록 구성된 임의의 수의 컴퓨팅 장치(예: 컴퓨터, 서버, 라우터, 네트워크 스위치 등)를 포함할 수 있다. 네트워크(110)는 임의의 수의 유선 및/또는 무선 연결을 더 포함할 수 있다. 중복 제거 서버(115)는 네트워크(110)의 다른 컴퓨팅 장치에 (예를 들어, 광섬유 케이블, CAT5 케이블 등을 통해) 유선으로 연결된 트랜시버(송수신기)와 무선으로(예를 들어, WiFi, 셀룰러, 라디오 등을 통해) 통신할 수 있다. 중복 제거 서버(115)는 또한 프록시 디바이스(예를 들어, 라우터, 네트워크 스위치, 또는 게이트웨이)를 통해 네트워크(110)의 컴퓨팅 장치들(컴퓨팅 장치들)과 무선으로 통신할 수 있다.
데이터 처리 시스템(105)은 적어도 하나의 프로세서 및 메모리, 즉 처리 회로를 포함할 수 있다. 메모리는 프로세서에 의해 실행될 때 프로세서가 여기에 설명된 하나 이상의 동작을 수행하게 하는 프로세서 실행 가능 명령어를 저장한다. 프로세서는 마이크로프로세서, ASIC(application-specific integrated circuit), FPGA(field-programmable gate array) 등, 또는 이들의 조합을 포함할 수 있다. 메모리는 전자, 광학, 자기, 또는 프로세서에 프로그램 명령을 제공할 수 있는 임의의 다른 저장 또는 전송 장치를 포함할 수 있지만 이에 제한되지 않는다. 메모리는 플로피 디스크, CD-ROM, DVD, 자기 디스크, 메모리 칩, ASIC, FPGA, 읽기 전용 메모리(ROM), 랜덤 액세스 메모리(RAM), 전기적으로 지울 수 있는 프로그래밍 가능 ROM(EEPROM), 지울 수 있는 프로그래밍 가능한 ROM(EPROM), 플래시 메모리, 광학 미디어 또는 프로세서가 명령어를 읽을 수 있는 다른 적절한 메모리를 더 포함할 수 있다. 명령어는 적절한 컴퓨터 프로그래밍 언어의 코드를 포함할 수 있다. 데이터 처리 시스템(105)은 예를 들어, 여기에 설명된 기능 또는 방법을 포함하는 다양한 기능을 수행할 수 있는 하나 이상의 컴퓨팅 장치 또는 서버를 포함할 수 있다.Data processing system 105 may include at least one processor and memory, or processing circuitry. The memory stores processor-executable instructions that, when executed by a processor, cause the processor to perform one or more operations described herein. The processor may include a microprocessor, an application-specific integrated circuit (ASIC), a field-programmable gate array (FPGA), or the like, or a combination thereof. Memory may include, but is not limited to, electronic, optical, magnetic, or any other storage or transmission device capable of providing program instructions to a processor. Memory includes floppy disks, CD-ROMs, DVDs, magnetic disks, memory chips, ASICs, FPGAs, read-only memory (ROM), random-access memory (RAM), electrically erasable programmable ROM (EEPROM), erasable It may further include programmable ROM (EPROM), flash memory, optical media, or other suitable memory from which the processor can read instructions. Instructions may include code in a suitable computer programming language. Data processing system 105 may include one or more computing devices or servers capable of performing various functions including, for example, the functions or methods described herein.
데이터베이스(125)는 본 명세서에 설명된 정보 중 임의의 것을 저장 및/또는 유지하도록 구성된 데이터베이스일 수 있다. 데이터베이스(125)는 본 명세서에 설명된 값, 복수, 또는 임계값 각각을 포함하거나 인덱싱할 수 있는 하나 이상의 데이터 구조를 유지할 수 있다. 데이터베이스(125)는 하나 이상의 메모리 주소 또는 인덱스 값을 사용하여 액세스될 수 있다. 데이터베이스(125)는 네트워크(110)를 통해 데이터 처리 시스템(105)의 컴포넌트에 의해, 또는 일부 구현에서 분석 장치(120)에 의해 액세스될 수 있다. 일부 구현에서, 데이터베이스(125)는 데이터 처리 시스템(105) 외부에 존재할 수 있고, 네트워크(110)를 통해 액세스될 수 있다. 데이터베이스(125)는 많은 상이한 컴퓨터 시스템 또는 저장 요소에 걸쳐 분산될 수 있고, 네트워크(110) 또는 적절한 컴퓨터 버스 인터페이스를 통해 액세스될 수 있다. 데이터 처리 시스템(105)은 적절한 값으로 인덱싱된 하나 이상의 데이터 구조에서 임의의 또는 모든 계산, 결정, 선택, 식별, 생성, 구성 또는 계산의 결과를 데이터베이스(125)에 저장할 수 있다. 이들 각각은 데이터 처리 시스템(105) 또는 클라이언트 장치(135)에 의해 액세스되어 본 명세서에 설명된 기능(functionalities) 또는 기능(functions) 중 임의의 것을 수행할 수 있다. Database 125 may be a database configured to store and/or maintain any of the information described herein. Database 125 may maintain one or more data structures that may contain or index each value, plurality, or threshold value described herein. Database 125 may be accessed using one or more memory addresses or index values. Database 125 may be accessed by components of data processing system 105 via
분석 장치(120)는 데이터 처리 시스템(105)에 의해 제공되는 표시(예를 들어, 클라이언트 식별자(132), 속성(134), 빈도 값, 또는 여기에 설명된 임의의 다른 값의 세트의 카디널리티(cardinality)를 표시하는 표시 등)와 같은 데이터를 디스플레이하기 위해 네트워크(110)를 통해 통신하도록 구성된 컴퓨팅 장치일 수 있다. 분석 장치(120)는 데스크탑 컴퓨터, 랩톱 컴퓨터, 태블릿 컴퓨터, 스마트폰, 개인 정보 단말기, 모바일 장치, 소비자 컴퓨팅 장치, 서버, 클라이언트, 디지털 비디오 레코더, 텔레비전용 셋톱 박스, 비디오 게임 콘솔, 또는 무엇보다도 네트워크(110)를 통해 통신하도록 구성된 임의의 다른 컴퓨팅 장치일 수 있다. 분석 장치(120)는 하나 이상의 클라이언트 식별자(132) 또는 하나 이상의 속성(134)을 데이터 처리 시스템(105)으로 전송하거나 수신할 수 있다. 분석 장치(120)는 일부 구현에서 적어도 하나의 데이터베이스(125)와 통신하여 각각의 분석 장치(120)와 관련하여 클라이언트 식별자(132) 또는 속성(134)을 저장할 수 있다. The analysis device 120 may determine the cardinality (e.g., of a set of
분석 장치(120)는 프로세서 및 메모리, 즉 처리 회로를 포함할 수 있다. 메모리는 프로세서에 의해 실행될 때 프로세서가 여기에 설명된 하나 이상의 동작을 수행하게 하는 기계 명령어를 저장한다. 프로세서는 마이크로프로세서, ASIC(application-specific integrated circuit), FPGA(field-programmable gate array) 등, 또는 이들의 조합을 포함할 수 있다. 메모리는 전자, 광학, 자기, 또는 프로세서에 프로그램 명령어를 제공할 수 있는 임의의 다른 저장 또는 전송 장치를 포함할 수 있지만 이에 제한되지 않는다. 메모리는 플로피 디스크, CD-ROM, DVD, 자기 디스크, 메모리 칩, ASIC, FPGA, 읽기 전용 메모리(ROM), 랜덤 액세스 메모리(RAM), 전기적으로 소거 가능한 프로그램 가능 ROM(EEPROM), 소거 가능한 프로그래밍 가능한 ROM(EPROM), 플래시 메모리, 광학 미디어 또는 프로세서가 명령을 읽을 수 있는 다른 적절한 메모리를 포함할 수 있다. 명령어는 적절한 컴퓨터 프로그래밍 언어의 코드를 포함할 수 있다.The analysis device 120 may include a processor and memory, i.e., processing circuitry. Memory stores machine instructions that, when executed by a processor, cause the processor to perform one or more operations described herein. The processor may include a microprocessor, an application-specific integrated circuit (ASIC), a field-programmable gate array (FPGA), or the like, or a combination thereof. Memory may include, but is not limited to, electronic, optical, magnetic, or any other storage or transmission device capable of providing program instructions to a processor. Memory includes floppy disks, CD-ROMs, DVDs, magnetic disks, memory chips, ASICs, FPGAs, read-only memory (ROM), random-access memory (RAM), electrically erasable programmable ROM (EEPROM), erasable programmable ROM (EPROM), flash memory, optical media, or other suitable memory from which a processor can read instructions. Instructions may include code in a suitable computer programming language.
분석 장치(120)는 하나 이상의 사용자 인터페이스 장치를 포함할 수 있다. 일반적으로, 사용자 인터페이스 장치는 감각 정보(예: 디스플레이의 시각화, 하나 이상의 사운드 등)를 생성하여 사용자에게 데이터를 전달하거나 사용자로부터 수신된 감각 정보를 전자 신호로 변환하는 모든 전자 장치(예: 키보드, 마우스, 포인팅 장치, 터치 스크린 디스플레이, 마이크 등)를 의미한다. 하나 이상의 사용자 인터페이스 장치는 분석 장치(120)의 하우징 내부(예: 내장 디스플레이, 마이크 등)에 있거나 분석 장치(120)의 하우징 외부(예: 분석 장치(120)에 연결된 모니터, 분석 장치(120)에 연결된 스피커 등)에 있을 수 있다. 일부 구현에서, 분석 장치(120)는 분석 장치(120)에서 실행되는 운영 체제에 의해 제공되거나 데이터베이스(125)로부터 검색되거나 데이터 처리 시스템(105)에 의해 제공되는 인터페이스 데이터를 사용하여 인터페이스를 시각적으로 표시하는 전자 디스플레이를 포함할 수 있다. Analysis device 120 may include one or more user interface devices. In general, a user interface device is any electronic device that either produces sensory information (e.g., a visualization on a display, one or more sounds, etc.) to convey data to the user, or converts sensory information received from the user into electronic signals (e.g., a keyboard, mouse, pointing device, touch screen display, microphone, etc.). One or more user interface devices may be within the housing of analysis device 120 (eg, a built-in display, microphone, etc.) or outside the housing of analysis device 120 (eg, a monitor connected to analysis device 120, analysis device 120). speakers connected to , etc.). In some implementations, analysis device 120 uses interface data provided by the operating system running on analysis device 120, retrieved from database 125, or provided by data processing system 105 to visually display an interface. It may include an electronic display for displaying.
클라이언트 장치(135)는 데이터 처리 시스템(105)에 의해 제공되는 표시(예를 들어, 식별자(132), 속성(134), 빈도 값, 또는 여기에 설명된 임의의 다른 값의 세트의 카디널리티를 표시하는 표시 등)와 같은 데이터를 디스플레이하기 위해 네트워크(110)를 통해 통신하도록 구성된 컴퓨팅 장치일 수 있다. 클라이언트 장치(135)는 데스크탑 컴퓨터, 랩톱 컴퓨터, 태블릿 컴퓨터, 스마트폰, 개인 정보 단말기, 모바일 장치, 소비자 컴퓨팅 장치, 서버, 클라이언트, 디지털 비디오 레코더, 텔레비전용 셋톱 박스, 비디오 게임 콘솔, 또는 무엇보다도 네트워크(110)를 통해 통신하도록 구성된 임의의 다른 컴퓨팅 장치일 수 있다. 클라이언트 장치(135)는 하나 이상의 클라이언트 식별자(132) 또는 하나 이상의 속성(134)을 데이터 처리 시스템으로 전송하거나 수신할 수 있다. 클라이언트 장치(135)는 적어도 하나의 데이터베이스(125)와 통신하여 각각의 클라이언트 장치(135)와 관련하여 클라이언트 식별자(132) 또는 속성(134)을 저장할 수 있다. Client device 135 indicates the cardinality of an indication provided by data processing system 105 (e.g.,
클라이언트 장치(135)는 프로세서 및 메모리, 즉 처리 회로를 포함할 수 있다. 메모리는 프로세서에 의해 실행될 때 프로세서가 여기에 설명된 하나 이상의 동작을 수행하게 하는 기계 명령어를 저장한다. 프로세서는 마이크로프로세서, ASIC(application-specific integrated circuit), FPGA(field-programmable gate array) 등, 또는 이들의 조합을 포함할 수 있다. 메모리는 전자, 광학, 자기, 또는 프로세서에 프로그램 명령을 제공할 수 있는 임의의 다른 저장 또는 전송 장치를 포함할 수 있지만 이에 제한되지 않는다. 메모리는 플로피 디스크, CD-ROM, DVD, 자기 디스크, 메모리 칩, ASIC, FPGA, 읽기 전용 메모리(ROM), 랜덤 액세스 메모리(RAM), 전기적으로 소거 가능한 프로그램 가능 ROM(EEPROM), 소거 가능한 프로그래밍 가능한 ROM(EPROM), 플래시 메모리, 광학 미디어 또는 프로세서가 명령을 읽을 수 있는 다른 적절한 메모리를 포함할 수 있다. 명령어는 적절한 컴퓨터 프로그래밍 언어의 코드를 포함할 수 있다. The client device 135 may include a processor and memory, or processing circuitry. Memory stores machine instructions that, when executed by a processor, cause the processor to perform one or more operations described herein. The processor may include a microprocessor, an application-specific integrated circuit (ASIC), a field-programmable gate array (FPGA), or the like, or a combination thereof. Memory may include, but is not limited to, electronic, optical, magnetic, or any other storage or transmission device capable of providing program instructions to a processor. Memory includes floppy disks, CD-ROMs, DVDs, magnetic disks, memory chips, ASICs, FPGAs, read-only memory (ROM), random-access memory (RAM), electrically erasable programmable ROM (EEPROM), erasable programmable ROM (EPROM), flash memory, optical media, or other suitable memory from which a processor can read instructions. Instructions may include code in a suitable computer programming language.
클라이언트 장치(135)는 하나 이상의 사용자 인터페이스 장치를 포함할 수 있다. 일반적으로, 사용자 인터페이스 장치는 감각 정보(예: 디스플레이의 시각화, 하나 이상의 사운드 등)를 생성하여 사용자에게 데이터를 전달하거나 사용자로부터 수신된 감각 정보를 전자 신호로 변환하는 모든 전자 장치(예: 키보드, 마우스, 포인팅 장치, 터치 스크린 디스플레이, 마이크 등)를 의미한다. 하나 이상의 사용자 인터페이스 장치는 클라이언트 장치(135)의 하우징 내부(예: 내장 디스플레이, 마이크 등)에 있거나 클라이언트 장치(135)의 하우징 외부(예: 클라이언트 장치(135)에 연결된 모니터, 클라이언트 장치(135)에 연결된 스피커 등)에 있을 수 있다. 일부 구현에서, 클라이언트 장치(135)는 클라이언트 장치(135)에서 실행되거나 데이터베이스(125)로부터 검색되거나 데이터 처리 시스템(105)에 의해 제공되는 운영 체제에 의해 제공되는 인터페이스 데이터를 사용하여 인터페이스를 시각적으로 표시하는 전자 디스플레이를 포함할 수 있다. Client device 135 may include one or more user interface devices. In general, a user interface device is any electronic device that either produces sensory information (e.g., a visualization on a display, one or more sounds, etc.) to convey data to the user, or converts sensory information received from the user into electronic signals (e.g., a keyboard, mouse, pointing device, touch screen display, microphone, etc.). One or more user interface devices may be internal to the housing of the client device 135 (eg, built-in display, microphone, etc.) or external to the housing of the client device 135 (eg, a monitor connected to the client device 135, the client device 135). speakers connected to , etc.). In some implementations, client device 135 can visually display an interface using interface data provided by an operating system running on client device 135 or retrieved from database 125 or provided by data processing system 105 . It may include an electronic display for displaying.
따라서, 클라이언트 장치(135)는 특정 카테고리, 아이템 또는 제품과 관련된 제공자의 콘텐츠 캠페인과 관련된 콘텐츠와 같은 웹페이지 또는 애플리케이션을 통한 제공자 콘텐츠의 전송을 통해 하나 이상의 제공자의 데이터 처리 시스템(105)과 상호작용할 수 있다. 사용자와 제공자 간의 상호 작용에는 웹 페이지 다운로드, 구독, 보기(views), 클릭 또는 기타 유형의 상호 작용이 포함될 수 있다.Accordingly, the client device 135 may interact with the data processing system 105 of one or more providers through the delivery of provider content via a webpage or application, such as content related to the provider's content campaign related to a particular category, item, or product. can Interactions between users and providers may include web page downloads, subscriptions, views, clicks, or other types of interactions.
데이터 처리 시스템(105)은 데이터베이스(125)에서 적어도 하나의 데이터 레코드(130)를 유지할 수 있다. 데이터 레코드(130)는 예를 들어, 적어도 하나의 클라이언트 식별자(132) 및 적어도 하나의 속성(134)을 포함할 수 있다. 클라이언트 식별자(132)는 사용자(클라이언트와 상호교환가능하게 사용됨), 클라이언트 장치(135), 또는 사용자와 연관된 다른 프록시에 대응할 수 있다. 속성(134)은 데이터 레코드(130)의 클라이언트 식별자(132)와 연관될 수 있고, 각각의 클라이언트의 속성에 대한 정보를 포함할 수 있다. 속성은 예를 들어 Data processing system 105 may maintain at least one data record 130 in database 125 . Data record 130 may include, for example, at least one
클라이언트 장치 위치 데이터, 클라이언트 장치 메타데이터, 클라이언트 장치 파라미터, 설정 및 기타 정보, 사용자 프로필 데이터, 클라이언트 장치(135)에 의해 수행된 상호작용, 애플리케이션 브라우징 이력, 웹 페이지 브라우징 이력, 활동 정보, 장치 특성, 클라이언트 장치(135)가 콘텐츠 아이템을 보거나 상호작용했는지 여부, 네트워크 활용 정보, 전력 활용 정보, 및 장치 운영 체제 버전, 설정 및 기타 정보를 포함할 수 있다. 데이터 처리 시스템은 각각의 클라이언트 장치(135)로부터 장치 식별자 및 속성 데이터를 수신할 수 있고, 각각의 클라이언트 장치(135)에 대응하는 데이터베이스(125) 내의 각각의 데이터 레코드를 생성 및 유지할 수 있다. 일부 구현에서, 데이터 처리 시스템(105) 각각은 사용자 또는 클라이언트 장치(135)의 특정 세트로부터 클라이언트 장치 식별자 및 정보만을 수신할 수 있다. 데이터 처리 시스템(105A-S)은 다른 데이터 처리 시스템(105A-S)에 의해 액세스될 수 없는 자체 데이터베이스(125)에 각각의 데이터 레코드를 유지할 수 있다. 일부 구현에 따르면, 사용자의 다른 그룹은 다른 식별자 서버(예를 들어, 데이터 처리 시스템(105))에 의해 서비스를 받을 수 있으며, 각 데이터 처리 시스템은 사용자 세트의 각각에 해당하는 자체 데이터 레코드 세트를 유지할 수 있다.client device location data, client device metadata, client device parameters, settings and other information, user profile data, interactions performed by the client device 135, application browsing history, web page browsing history, activity information, device characteristics, whether the client device 135 has viewed or interacted with the content item, network utilization information, power utilization information, and device operating system version, settings, and other information. The data processing system may receive the device identifier and attribute data from each client device 135 and may create and maintain a respective data record in database 125 corresponding to each client device 135 . In some implementations, each of the data processing systems 105 may only receive client device identifiers and information from a particular set of users or client devices 135 . The data processing system 105A-S may maintain each data record in its own database 125 that cannot be accessed by other data processing systems 105A-S. According to some implementations, different groups of users may be served by different identifier servers (eg, data processing systems 105), each data processing system having its own set of data records corresponding to each of the set of users. can keep
다양한 구현에서, 데이터 처리 시스템(105A-S) 각각은 제공자 그룹의 제공자와 연관될 수 있다. 따라서 데이터 처리 시스템(105A-S)은 집단 내의 개인과 개별 제공자 간의 상호작용에 관한 데이터를 기록 및 관리할 수 있다. 일부 구현에서, 제공자 그룹의 제공자는 본 명세서에 설명된 기능을 구현하기 위해 다수의 데이터 처리 시스템(105)을 활용할 수 있다. 일부 구현에서, 데이터 처리 시스템(105A-S)은 네트워크(110)를 통해 사용자와 연관된 클라이언트 장치(135)와 통신하고 연관된 클라이언트 장치(135)와의 상호작용을 기록하도록 구성될 수 있다.In various implementations, each of the data processing systems 105A-S may be associated with a provider of a provider group. Accordingly, the data processing systems 105A-S may record and manage data relating to interactions between individuals within the population and individual contributors. In some implementations, providers of a provider group may utilize multiple data processing systems 105 to implement the functionality described herein. In some implementations, data processing systems 105A-S may be configured to communicate with client devices 135 associated with users over
데이터 처리 시스템(105)은 데이터 세트를 인코딩하기 위한 벡터 데이터 구조를 생성하도록 구성될 수 있는 벡터 생성기(140)를 포함하는 것으로 도시되어 있다. 벡터 생성기(140)는 복수의 좌표를 포함하는 벡터를 생성할 수 있다. 벡터를 생성하기 위해, 벡터 생성기(140)는 적어도 하나의 카운터 레지스터를 수용하도록 데이터 처리 시스템(105)에서 메모리의 하나 이상의 영역을 할당할 수 있다. 할당된 카운터 레지스터는 벡터의 적어도 하나의 좌표(coordinate)에 해당할 수 있다. 하나 이상의 카운터 레지스터에 대한 메모리를 생성 및 할당함으로써, 벡터 생성기(140)는 카운터 레지스터를 포함하는 벡터를 생성할 수 있다. 벡터 생성기(140)는 벡터의 카운터 레지스터들 각각을 초기화 값, 예를 들어 0 또는 1로 초기화할 수 있다. 벡터 생성기(140)는 블룸 필터에 대응할 수 있는 벡터를 생성하여 임의의 개수의 카운터 레지스터(때때로 "버킷"으로 지칭됨)를 가질 수 있다. 예를 들어, 벡터 생성기(140)는 n개의 버킷으로 블룸 필터를 생성하라는 표시를 수신할 수 있거나, 버킷 또는 카운터 레지스터의 수로 블룸 필터의 크기를 지정하는 외부 컴퓨팅 장치에 의해 제공되는 내부 구성 설정에 액세스할 수 있다. The data processing system 105 is shown to include a
유사하게, 벡터 생성기(140)는 벡터들의 세트에 대해 생성할 벡터들의 수의 표시를 수신하도록 구성될 수 있다. 일부 구현들에서, 벡터 생성기(140)는 생성된 벡터들의 세트와 연관시키기 위한 빈도 빈들의 지정(designation)을 수신할 수 있다. 벡터 생성기(140)는 벡터 세트의 각 벡터에 주석을 달거나 그렇지 않으면 빈도 지정의 대응하는 빈도와 연관시킬 수 있다. 일부 구현에서, 지정은 중복 제거 서버(115)로부터 수신될 수 있다. 일부 구현에서, 빈도는 각각 단일 빈도에 해당한다. 일부 구현에서, 일부 지정은 빈도 범위에 대응할 수 있다. 일 구현에서, 빈도 지정은 빈도 빈 세트(1, 2, …, k-1, k+)를 지정한다. 이해되는 바와 같이, 빈도 지정의 다른 배열이 프라이빗 스케치 세트에 사용될 수 있다. 예를 들어, 1+를 나타내는 프라이빗 스케치와 같은 추가 프라이빗 스케치가 포함될 수 있다. 일부 구현에서, 세트의 프라이빗 스케치들 각각은 (1+, 2+, …, k+) 중 하나에 대응할 수 있다. Similarly,
빈도 식별자(145)는 클라이언트 식별자(132)와 연관된 빈도 데이터를 결정하도록 구성된다. 일부 구현에서, 빈도 식별자(145)는 속성(134)에 저장된 데이터에 기초하여 클라이언트 식별자(132)의 빈도 데이터를 결정할 수 있다. 예를 들어, 빈도 식별자(145)는 클라이언트 식별자가 데이터 레코드(130)에 나타나는 횟수를 결정할 수 있다. 일부 구현에서, 빈도 식별자(145)는 특정 서비스 또는 상호작용의 빈도를 결정하고, 따라서 클라이언트 식별자와 관련된 모든 상호작용을 카운트하지 않을 수 있다. 일부 구현에서, 빈도 식별자(145)는 클라이언트 식별자(132)와 관련하여 속성(134)의 일부로서 빈도 데이터를 저장한다. 일부 구현에서, 빈도 식별자(145)는 클라이언트 식별자(132)에 대한 빈도 데이터를 주기적으로 또는 지속적으로 업데이트할 수 있다. 빈도 식별자(145)에 의해 결정된 빈도 데이터는 식별자와 연관된 빈도 데이터에 대응하는 프라이빗 스케치로 식별자를 인코딩하는 데 사용하기 위해 후속적으로 액세스 가능하거나 그렇지 않으면 벡터 선택기(150)에 전달될 수 있다.
벡터 선택기(150)는 식별자를 인코딩할 스케치 세트에서 적절한 스케치를 결정하도록 구성된다. 벡터 선택기(150)는 연관된 빈도에 대응하는 적절한 스케치를 결정하기 위해 빈도 식별자(145)에 의해 생성된 빈도 데이터에 액세스하거나 그렇지 않으면 검색할 수 있다. 일부 구현들에서, 벡터 선택기(150)는 식별자를 인코딩하기 위해 벡터들의 세트에서 단일 스케치를 결정한다. 다른 구현들에서, 벡터 선택기(150)는 다수의 벡터들에서 식별자를 인코딩할지 여부를 결정할 수 있다.The
데이터 레코드 해셔(155)는 벡터 데이터 구조에서 식별자를 인코딩하는 데 사용할 수 있는 해시 함수의 목록으로부터 하나 이상의 해시 함수를 식별할 수 있다. 예를 들어, 해시 목록에서 식별된 각 해시는 입력 값을 기반으로 하는 정규 분포 또는 임의성의 기대치를 제공할 수 있다. 즉, 예를 들어 해시 함수에 대한 유사한 입력이 해시 함수에 대한 유사한 출력을 반드시 가질 필요는 없다. 해시 함수는 블룸 필터에 대한 최적의 해시 함수로 선택할 수 있다. 예를 들어, 데이터 레코드 해셔(155)는 독립적이고 균일하게 분포된 해시 함수를 선택할 수 있다. 이러한 해시 함수에는 예를 들어 MH(murmur hashes), FNV(Fowler-Noll-Vo) 시리즈 해시 또는 Jenkins 해시가 포함될 수 있다. 데이터 레코드 해셔(155)는 다수의 해시 함수를 선택하거나 식별할 수 있고, 각 해시 함수를 각 데이터 레코드에 적용하여 해시된 데이터 레코드 세트를 생성할 수 있다.
데이터 레코드 해셔(155)는 각각의 데이터 처리 시스템(105)에 의해 유지되는 데이터 레코드 각각을 해싱하여 해싱된 데이터 레코드의 각각의 세트를 생성할 수 있다. 해시 데이터 레코드를 적용하는 것은 데이터 레코드 해셔(155)에 의해 식별된 해시 함수에 대한 인수로서 데이터 레코드를 사용하는 것을 포함할 수 있다. 데이터 레코드 해셔(155)는 식별된 각각의 해시를 사용하여 각각의 데이터 레코드를 해싱할 수 있으며, 이에 의해 데이터 레코드 각각에 대응하는 다수의 해싱된 값을 생성할 수 있다. 이와 같이, 데이터 레코드 해셔(155)는 루프의 데이터 레코드 각각에 대해 반복할 수 있고, 해시 함수 각각을 선택될 때 각 데이터 레코드에 적용할 수 있다. 해시 함수를 적용한 후, 데이터 레코드 해셔(155)는 각각의 데이터 처리 시스템(105)의 메모리에 있는 각각의 데이터 레코드와 연관하여 해시된 데이터 레코드 각각을 저장할 수 있다. 데이터 레코드 해셔(155)는 각각의 데이터 처리 시스템(105)에 의해 유지되는 데이터 레코드 각각에 대응하는 해시된 데이터 레코드 각각으로부터 레지스터 식별자를 더 추출할 수 있다. 해시된 데이터 레코드 세트의 해시된 데이터 레코드 각각은 벡터 생성기(140)에 의해 생성된 벡터의 카운터 레지스터에 대응할 수 있다. 대응하는 카운터 레지스터를 식별하기 위해, 데이터 레코드 해셔(155)는 해시된 데이터 레코드 각각으로부터 레지스터 식별자를 추출할 수 있다. 데이터 레코드 해셔(155)는 예를 들어 벡터의 카운터 레지스터의 수로 각각의 해싱된 데이터 식별자에 대해 모듈러스(modulus) 연산을 수행함으로써 레지스터 식별자를 추출할 수 있다.
벡터 인코더(160)는 데이터 레코드 해셔(155)의 출력에 기초하여 벡터의 카운터 레지스터를 업데이트하도록 구성된다. 예를 들어, 벡터 인코더(160)는 식별자를 인코딩할 데이터 레코드 해셔(155)로부터 벡터 데이터 구조의 좌표를 수신할 수 있고, 벡터 인코더(160)는 그에 따라 카운터 레지스터를 업데이트한다. 벡터 인코더(160)는 예를 들어 블룸 필터 또는 카운트의 벡터와 같은 다양한 카운팅 구조 중 하나를 구현할 수 있다. 벡터 인코더(160)는 식별자가 이미 벡터들 중 적어도 하나로 인코딩되었는지 여부를 결정하도록 구성될 수 있다. 일부 그러한 구현에서, 벡터 인코더(160)는 데이터 엔트리가 스케치로 인코딩되었는지 여부를 지정하는 속성(134)을 저장할 수 있다. 벡터 인코더(160)는 데이터 엔트리들의 세트를 반복하도록 구성될 수 있고, 빈도 식별자(145), 벡터 식별자(150), 및 데이터 레코드 해셔(155)와의 통신을 통해, 벡터 생성기(140)에 의해 생성된 벡터들의 세트로 데이터 세트의 인코딩을 용이하게 한다. 일부 구현에서, 벡터 인코더(160)는 데이터베이스(125)와 같은 메모리에 업데이트된 벡터를 저장하도록 구성될 수 있다.The
중복 제거 서버(115)를 참조하면, 중복 제거 서버(115)는 데이터 처리 시스템(105)이 통신하는 별도의 서버로 구성될 수 있다. 일부 구현에서, 중복 제거 서버(115)의 기능 및 특징은 데이터 처리 시스템(105)이 다른 데이터 처리 시스템(105)과의 직접 통신을 통해 복수의 데이터 세트를 중복 제거하도록 하나 이상의 데이터 처리 시스템(105)에 포함된다. 예를 들어, 데이터 처리 시스템(105A)은 각 데이터 처리 시스템의 프라이빗 스케치 세트를 요청하는 데이터 처리 시스템(105B-S)에 쿼리할 수 있으며, 이로부터 데이터 처리 시스템(105A)은 데이터 세트의 중복 제거된 분포를 생성한다. 다른 예에서, 데이터 처리 시스템(105A-S)은 미리 결정된 시간 간격(예: 매일, 월, 년 등) 또는 트리거에 따라 프라이빗 스케치의 각자의 세트를 자동으로 생성하고 다른 데이터 처리 시스템(105)으로 전송하도록 구성된다. 일 구현에서, 중복 제거 서버(115)의 기능은 다중 데이터 처리 시스템(105)에 걸쳐 분산된다. Referring to deduplication server 115 , deduplication server 115 may be configured as a separate server with which data processing system 105 communicates. In some implementations, the functions and features of deduplication server 115 may be such that one or more data processing systems 105 may dedupe multiple data sets through direct communication with other data processing systems 105. ) are included in For example, data processing system 105A can query data processing system 105B-S requesting each data processing system's private set of sketches, from which data processing system 105A de-dupes the data set. create a distribution of In another example, the data processing systems 105A-S automatically create their respective sets of private sketches according to predetermined time intervals (eg daily, monthly, yearly, etc.) or triggers and transfer them to other data processing systems 105. configured to transmit. In one implementation, the functions of deduplication server 115 are distributed across multiple data processing systems 105.
중복 제거 서버(115)는 프로토콜 조정자(coordinator)(165)를 포함하는 것으로 도시되어 있다. 프로토콜 조정자(165)는 표준화된 프로토콜 파라미터를 각각의 데이터 처리 시스템(105)에 전달할 수 있다. 프로토콜 파라미터에는 빈도 지정, 데이터 구조 유형, 데이터 구조의 길이 또는 크기, 해시 함수가 포함될 수 있지만 이에 국한되지 않는다. 프로토콜 조정자(165)는 분석 장치(120)와 같은 사용자 장치로부터 수신된 사용자 입력에 기초하여 프로토콜 파라미터를 결정할 수 있다. 프로토콜 조정자(165)는 각 제공자에 대한 프라이빗 스케치 세트를 검색하기 위해 데이터 처리 시스템(105)에 대한 요청을 용이하게 할 수 있다. 프로토콜 조정자(165)는 추후 참조를 위해 중복 제거 서버(115)의 메모리에 프로토콜 파라미터를 저장할 수 있다. Deduplication server 115 is shown as including a
벡터 중복 제거기(170)는 데이터 처리 시스템(105)으로부터 수신된 벡터 세트를 중복 제거하도록 구성된 로직을 포함한다. 벡터 중복 제거기(170)는 중복 제거를 위한 하나 이상의 알고리즘을 구현할 수 있으며, 이는 인터섹션, 유니온 또는 SD(set difference)와 같은 벡터 연산을 포함할 수 있다. 일부 구현에서, 벡터 중복 제거기(170)는 데이터 세트의 크기 또는 수에 기초하여 선호되는 중복 제거 알고리즘을 결정한다. 일부 구현들에서, 벡터 중복 제거기(170)는 포괄적인 데이터 세트를 나타내는 벡터 데이터 구조들의 중복 제거된 세트를 생성한다. 그러한 구현들에서, 벡터 중복 제거기(170)는 복수의 인코딩된 데이터 세트들에 기초하여 벡터들의 세트들을 생성 및 저장하도록 구성될 수 있다.
분포 생성기(175)는 전체 분포(히스토그램과 상호교환가능하게 사용됨)의 빈도당 카운트를 결정하도록 구성된다. 일부 구현들에서, 분포 생성기(175)는 벡터 중복 제거기(170)로부터 수신된 벡터들의 결합된 세트에 기초하여 전체 중복 제거된 분포를 결정한다. 일부 구현에서, 분포 생성기(175)는 수신된 스케치로부터 직접 전체 분포를 추정한다. 특정 빈도에 대한 카운트를 결정하기 위해, 분포 생성기(175)는 벡터의 카디널리티를 결정할 수 있다. 일부 구현에서는 HyperLogLog(HLL)가 카디널리티 추정기로 사용된다. 카디널리티 추정기는 실제로 매우 큰 일부 멀티세트(multiset) M의 요소 수를 추정할 수 있다. HLL은 낮은 오류율, 낮은 분산 및 낮은 메모리 사용량으로 특징지을 수 있다. 또한 두 HLL의 유니온은 계산하기 쉬울 수 있으며, 즉, HLL을 분산 계산 애플리케이션에서 구현할 수 있다. FLL(FreqLogLog)이라고 하는 HLL의 확장을 통해 M의 요소 수와 빈도를 추정할 수 있다. 다른 계수 추정기가 분포 생성기(175)에 의해 사용될 수 있다. 분포 생성기(175)는 중복 제거 서버(115)의 메모리에 전체 분포를 저장할 수 있다. 일부 구현에서, 분포 생성기(175)는 분포 데이터를 데이터 처리 시스템(105) 또는 분석 장치(120)로 전송한다.
GUI 생성기(180)는 생성된 분포의 표현을 포함하는 그래픽 사용자 인터페이스(GUI)에 속하는 데이터를 생성하도록 구성된다. 일 구현에서, GUI 생성기(180)는 분석가에게 표시하기 위해 분포의 시각적 표현을 제공하는 그래픽 요소를 생성한다. 일부 구현에서, GUI 생성기(180)는 분포의 표현을 포함하는 웹페이지 데이터를 유지하고 네트워크(110)를 통해 액세스할 수 있다. GUI 생성기(180)는 생성된 GUI 데이터를 분석 장치(120)와 같은 디스플레이를 위해 사용자 장치로 보낼 수 있다. 다른 구현에서, GUI 데이터는 중복 제거 서버(115)로부터 수신된 데이터에 기초하여 분석 장치(120)에 의해 생성된다.
도 2를 참조하면, 몇몇 구현들에 따라, k 벡터 데이터 구조들의 세트를 생성하기 위한 프로세스(200)가 도시된다. 프로세스(200)는 임의의 프로세싱 시스템(105A-S)과 같은 메모리에 연결된 하나 이상의 프로세서에 의해 실행될 수 있다. 프로세스(200)는 일반적으로 제공자와 사용자 간의 상호작용에 대응하는 데이터 세트를 프라이빗 스케치 세트로 압축하고 프라이빗화(privatize)한다. 따라서 생성된 k 벡터 데이터 구조 세트는 데이터 세트의 크기를 줄이고 식별자 값의 차등 프라이버시를 유지한다. Referring to FIG. 2 , a
202에서, 하나 이상의 프로세서는 제공자 그룹의 특정 제공자와의 사용자 상호작용에 대응하는 데이터 레코드(기록)를 유지한다. 데이터 기록(레코드)은 사용자가 특정 제공자와 상호 작용할 때 시간이 지남에 따라 데이터베이스에 유지될 수 있다. 데이터 기록에는 사용자를 고유하게 식별하는 식별자, 상호 작용 유형, 상호 작용과 관련된 타임스탬프 또는 빈도 데이터 및 이들의 조합이 포함될 수 있지만 이에 국한되지 않는다. 일부 구현에서, 데이터 기록은 보호된 개인 정보를 포함할 수 있고 암호화되거나 그렇지 않으면 상기 개인 정보를 보호하는 방식으로 저장될 수 있다. At 202, one or more processors maintain data records (records) corresponding to user interactions with particular providers in the group of providers. Data records (records) can be persisted in a database over time as users interact with particular providers. Data records may include, but are not limited to, an identifier that uniquely identifies a user, type of interaction, timestamp or frequency data associated with an interaction, and combinations thereof. In some implementations, data records may contain protected personal information and may be encrypted or otherwise stored in a manner that protects the personal information.
일부 구현에서, 하나 이상의 프로세서는 프라이빗 스케치를 생성하는 데 사용하기 위한 빈도 지정을 수신한다. 일부 구현에서, 빈도 지정은 미리 정의된 세트로 수신될 수 있다. 일부 구현에서, 지정은 빈도 임계값 k이고, 여기서 지정된 빈도 빈은 세트 {1, 2, …, k-1, k+}로 정의되는 것으로 이해된다. 생성되어야 하는 프라이빗 스케치의 유형, 프라이빗 스케치의 크기, 해시 함수, 또는 프라이빗 스케치를 구현하는 데 사용되는 데이터 구조의 다른 파라미터와 같은 다른 프로토콜 정보도 204에서 수신될 수 있다. In some implementations, one or more processors receive a frequency designation for use in generating private sketches. In some implementations, frequency designations may be received in a predefined set. In some implementations, the designation is a frequency threshold k, where the specified frequency bins are the set {1, 2, ... , k-1, k+}. Other protocol information may also be received at 204, such as the type of private sketch to be created, the size of the private sketch, hash function, or other parameters of the data structure used to implement the private sketch.
일부 구현에서, 제공자의 데이터 세트에 관한 일반 정보는 데이터 교환 프로토콜의 파라미터를 맞춤화하기 위해 중앙 서버(예: 중복 제거 서버(115))로 전송될 수 있다. 예를 들어, 제공자는 데이터 세트의 총 개인 수를 결정하고 결정된 수를 중앙 서버에 보낼 수 있다. 그 다음, 중앙 서버는 예를 들어 단계 204에서 그룹의 제공자들에 의해 수신될 수 있는 프로토콜에서 정의하기 위해 사용할 최적의 벡터 크기를 결정할 수 있다.In some implementations, general information about a provider's data set may be sent to a central server (eg, deduplication server 115) to customize the parameters of the data exchange protocol. For example, a provider may determine the total number of individuals in a data set and send the determined number to a central server. The central server can then determine the optimal vector size to use for defining in the protocol that can be received by the providers of the group, for example in
204에서, 빈도 지정에 기초하여 복수의 벡터 데이터 구조가 생성된다. 일 구현에서, 복수의 벡터 데이터 구조의 각각의 벡터는 특정 빈도 빈(frequency bin)에 대응한다. 빈도 빈은 단일 빈도, 다중 빈도 또는 빈도 범위를 나타낼 수 있다. 다양한 구현에서, 복수의 벡터 데이터 구조는 VoC일 수 있다. 일부 구현에서, 복수의 벡터 데이터 구조는 블룸 필터(bloom filters)일 수 있다. 벡터 데이터 구조는 복수의 카운팅 레지스터에 대응하는 좌표를 정의할 수 있다. 복수의 벡터 데이터 구조는 각각의 레지스터에서 초기값으로 초기화될 수 있다.At 204, multiple vector data structures are created based on the frequency specifications. In one implementation, each vector of the multiple vector data structure corresponds to a particular frequency bin. A frequency bin can represent a single frequency, multiple frequencies, or a range of frequencies. In various implementations, the plurality of vector data structures may be a VoC. In some implementations, the plurality of vector data structures can be bloom filters. A vector data structure may define coordinates corresponding to a plurality of counting registers. A plurality of vector data structures may be initialized with initial values in each register.
206에서, 데이터 세트의 대응하는 속성 데이터에 기초하여 유지된 데이터 세트의 사용자와 연관된 식별자에 대한 빈도 데이터가 결정된다. 예를 들어, 식별자를 식별하는 데이터 세트의 상호 작용 수는 식별자와 관련된 상호 작용의 빈도를 결정하기 위해 계산될 수 있다. 일부 구현에서, 빈도 데이터는 특정 서비스 또는 상호작용 유형에 대해 결정된다. 일부 구현에서, 빈도 데이터는 데이터 세트에서 검색된 속성의 일부로 저장된다. 벡터 데이터 구조 세트의 벡터는 빈도 데이터를 기반으로 선택된다. 선택된 벡터는 식별자와 연관된 빈도 데이터를 포함하는 빈도 빈에 대응하는 벡터일 수 있다. At 206, frequency data is determined for an identifier associated with a user of the maintained data set based on corresponding attribute data in the data set. For example, the number of interactions in a data set that identifies an identifier may be computed to determine the frequency of interactions associated with the identifier. In some implementations, frequency data is determined for a particular service or type of interaction. In some implementations, frequency data is stored as part of an attribute retrieved from a data set. Vectors in the set of vector data structures are selected based on frequency data. The selected vector may be a vector corresponding to a frequency bin containing frequency data associated with the identifier.
208에서, 세트의 적어도 하나의 벡터는 식별자를 인코딩하도록 업데이트된다. 선택된 벡터를 업데이트하는 것은 하나 이상의 해시 함수에 기초하여 벡터의 좌표를 결정하고 식별된 좌표에 대응하는 하나 이상의 카운팅 레지스터를 증가시키는 것을 포함할 수 있다. 일부 구현에서, 각각의 식별자는 식별자와 연관된 빈도 데이터에 기초하여 세트의 하나의 벡터로만 인코딩된다. 일부 구현에서, 카운팅 레지스터는 카운팅 레지스터에 현재 저장된 값 및 카운팅 프로토콜에 기초하여 업데이트되지 않는다. 벡터 인코딩에 대한 자세한 내용은 다음 섹션에서 설명한다.At 208, at least one vector of the set is updated to encode the identifier. Updating the selected vector may include determining coordinates of the vector based on one or more hash functions and incrementing one or more counting registers corresponding to the identified coordinates. In some implementations, each identifier is encoded in only one vector of the set based on frequency data associated with the identifier. In some implementations, the counting register is not updated based on the counting protocol and the value currently stored in the counting register. The details of vector encoding are discussed in the next section.
일부 구현에서, 프로세서는 데이터 세트의 아이템 또는 식별자에 대한 데이터 레코드를 반복적으로 검색하고, 각 식별자에 대한 빈도 데이터를 개별적으로 결정하고, 데이터 세트의 다음 엔트리로 반복하기 전에 세트의 하나 이상의 벡터를 업데이트할 수 있다. In some implementations, the processor iteratively searches the data records for an item or identifier in the data set, individually determines frequency data for each identifier, and updates one or more vectors of the set before iterating to the next entry in the data set. can do.
210에서, 관심 있는 모든 데이터 엔트리가 복수의 벡터 데이터 구조로 인코딩되면, 프라이빗 스케치 세트가 처리를 위해 요청 서버로 전송된다. 일부 구현에서, 프라이빗 스케치 세트는 나중에 사용하거나 업데이트하기 위해 일시적으로 또는 장기간 동안 저장될 수 있다. 예를 들어, 서버는 데이터 세트의 새로운 엔트리가 프로세서에 의해 기록됨에 따라 복수의 벡터 데이터 구조를 점진적으로 업데이트할 수 있다. At 210, once all data entries of interest have been encoded into the plurality of vector data structures, the private sketch set is sent to the requesting server for processing. In some implementations, private sketch sets may be stored temporarily or for a long period of time for later use or update. For example, the server may incrementally update the plurality of vector data structures as new entries of the data set are written by the processor.
프라이빗 스케치 구성의 다양한 구현은 아래에서 더 자세히 설명될 것이다.The various implementations of private sketch constructs will be described in more detail below.
개시된 시스템 및 방법에서 사용될 수 있는 프라이빗 스케치의 한 유형은 카운트 벡터(VoC: vector of counts)이다. VoC는 일반적으로 벡터의 다양한 엔트리에 대응하는 복수의 카운터(버킷(buckets), 빈 등)가 있는 벡터로 표현될 수 있다. VoC는 복수의 카운터 값을 정의하는 1차원 벡터일 수 있다. VoC는 벡터 데이터 구조로 구현될 수 있으며, 여기서 벡터 데이터 구조는 일반적으로 프로세서가 정의된 카운터에 해당하는 데이터 구조에 의해 정의된 메모리 위치에 대해 연산자를 구현하고 저장된 값을 검색할 수 있도록 컴퓨터 메모리의 지정 또는 구성(configuration)으로 정의된다. 벡터 데이터 구조의 카운터는 비트, 하나 이상의 바이트 또는 다른 고차 데이터 유형으로 구성될 수 있다. One type of private sketch that may be used in the disclosed systems and methods is a vector of counts (VoC). A VoC can generally be represented as a vector with multiple counters (buckets, bins, etc.) corresponding to the various entries in the vector. VoC may be a one-dimensional vector defining a plurality of counter values. A VoC can be implemented as a vector data structure, where a vector data structure is typically a part of computer memory that allows a processor to implement operators and retrieve stored values for memory locations defined by the data structures corresponding to defined counters. Defined as a designation or configuration. A counter in a vector data structure can consist of bits, one or more bytes, or other higher-order data types.
현재 솔루션에서 사용할 수 있는 다른 유형의 프라이빗 스케치는 블룸 필터이다. 블룸 필터는 세트의 간결한 표현을 제공할 수 있다. 블룸 필터는 벡터 데이터 구조로 구현될 수도 있으며, 삽입 및 포함 메서드(contains method)를 모두 구현할 수 있지만, 간결한 표현으로 인해 메서드가 FP(false positive)를 반환할 가능성이 적다. 이는 요소가 세트에 없을 수도 있지만 요소가 세트에 있다고 말할 수 있음을 의미한다. 반면에 FN(false negatives)은 배제되는데, 즉, 포함 메서드가 거짓을 반환하면 항상 정확할 수 있다. Another type of private sketch available in current solutions is the bloom filter. A bloom filter can provide a concise representation of a set. A bloom filter can also be implemented as a vector data structure, and can implement both insert and contains methods, but the method is less likely to return a false positive (FP) due to its concise expression. This means that an element may not be in a set, but an element can be said to be in a set. On the other hand, false negatives (FNs) are excluded, i.e. it can always be correct if the containing method returns false.
빈 블룸 필터는 모든 비트가 0으로 설정된 m 크기의 비트 배열일 수 있다. 요소 x는 k 해시 함수 모듈러스 m을 통해 전달한 다음 블룸 필터의 해당 비트를 1로 설정하여 삽입할 수 있다(아래 예 참조). 이 방법은 유사한 방식으로 작동할 수 있으며, x 모듈러스 m의 모든 k 해시가 1로 설정되면 "true"를 반환하고 그렇지 않으면 "false"를 반환할 수 있다. An empty bloom filter can be a bit array of size m with all bits set to 0. Element x can be inserted by passing it through k hash function modulus m and then setting the corresponding bit in the bloom filter to 1 (see example below). This method can work in a similar way, returning "true" if all k hashes of x modulus m are set to 1, and "false" otherwise.
비교적 높은 메모리 요구 사항(예: HLL과 관련하여)으로 인해, 블룸 필터는 일반적으로 카디널리티 추정에 사용되지 않을 수 있지만 블룸 필터의 카디널리티는 다음 수학식2를 평가하여 결정할 수 있다.Due to their relatively high memory requirements (e.g. in the context of HLL), bloom filters may not normally be used for cardinality estimation, but the cardinality of bloom filters can be determined by evaluating
여기서, x는 블룸 필터의 (활성 비트) 수이고, m은 블룸 필터의 비트 수이고, n은 블룸 필터의 카디널리티 추정치 수(number of the estimate)이다.Here, x is the number of (active bits) of the bloom filter, m is the number of bits of the bloom filter, and n is the number of cardinality estimates of the bloom filter.
추정량(estimator)의 분산은 다음 수학식 3으로 근사된다.The variance of the estimator is approximated by
여기서, n은 블룸 필터의 TSC(True Set Cardinality)이다. Here, n is the true set cardinality (TSC) of the bloom filter.
분산은 Taylor 확장을 기반으로 파생될 수 있다. The variance can be derived based on the Taylor expansion.
이 섹션에서 설명하는 스케치는 일반적으로 '모든 분포 블룸 필터(ADBF)'라고도 한다. 이 섹션에 설명된 스케치에는 균일 또는 지수 이외의 대체 분포 함수를 수용할 수 있는 비트 분포에 대한 허용이 포함될 수 있다. 예를 들어, 여기에 설명된 기술은 선형 감쇠(linearly decaying) 블룸 필터(BF), 하이퍼볼릭(hyperbolic) BF, 또는 MUE(Mixture of Uniform and Exponential) BF를 구현할 수 있다. 노이즈 보정은 하나 이상의 데이터 처리 시스템 또는 서버(예: 데이터 처리 시스템(105) 또는 중복 제거 서버(115))에 의해 효율적으로 적용될 수 있다. The sketch described in this section is also commonly referred to as an 'all-distributed bloom filter' (ADBF). The sketches described in this section may include allowances for bit distributions that may accommodate alternative distribution functions other than uniform or exponential. For example, the techniques described herein may implement a linearly decaying bloom filter (BF), a hyperbolic BF, or a Mixture of Uniform and Exponential (MUE) BF. Noise correction may be efficiently applied by one or more data processing systems or servers (eg, data processing system 105 or deduplication server 115).
또한, 데이터 처리 시스템 또는 서버(예: 데이터 처리 시스템(105) 또는 중복 제거 서버(115))에 의해 구현되는 추정 기술은 스케치의 모든 비트가 카디널리티 추정에 기여할 수 있도록 구현될 수 있으며, 참조 레기온(reference legion) 기반 구현에서와 달리 참조 레기온의 비트만 사용된다. 참조 레기온을 선택하는 대신 데이터 처리 시스템은 스케치의 각 비트의 가중치를 조정할 수 있으며, 여기서 가중치 값은 최종 카디널리티 추정에 대한 스케치의 비트 기여도를 나타낸다. 스케치의 파라미터를 기반으로 데이터 처리 시스템은 스케치의 각 비트에 대한 최적의 가중치를 도출하여 카디널리티 추정의 전체 정확도를 향상시킬 수 있다. In addition, an estimation technique implemented by a data processing system or server (eg, data processing system 105 or deduplication server 115) may be implemented such that all bits of the sketch can contribute to cardinality estimation, and the reference region ( Unlike in the reference legion-based implementation, only the bits of the reference legion are used. Instead of selecting a reference region, the data processing system can adjust the weight of each bit in the sketch, where the weight value represents the sketch's bit contribution to the final cardinality estimate. Based on the parameters of the sketch, the data processing system can derive the optimal weight for each bit of the sketch to improve the overall accuracy of cardinality estimation.
도 3을 참조하면, 도시된 것은 적어도 하나의 데이터 처리 시스템 (예를 들어, 데이터 처리 시스템(105) 중 적어도 하나 등)에 의한 블룸 필터로의 데이터 레코드 X의 삽입을 예시하는 흐름도(300)의 예시이다. 블록(302)에서, 데이터 처리 시스템은 블룸 필터에 삽입할 데이터 레코드를 표시할 수 있다. 표시된 데이터 레코드는 예를 들어 데이터베이스(예를 들어, 데이터베이스(125))로부터 선택될 수 있다. 데이터 처리 시스템은 여기에서 h1, h2 및 h3으로 표시된 여러 해시 함수를 선택할 수 있다. 3개의 해시 함수만 표시되지만, 데이터 처리 시스템은 데이터 레코드를 표준 블룸 필터에 삽입하기 위해 여러 해시 함수를 사용할 수 있음을 이해해야 한다. 블록(304A-C)에서, 데이터 처리 시스템은 식별된 해시 함수 각각을 사용하여 데이터 레코드 X를 적어도 한 번 복제하고 해시할 수 있다. 해시 함수는 예를 들어 여기에 설명된 ElGamal 해시, 또는 특히 SHA-1, SHA-2, MD5와 같은 임의의 다른 유형의 해시일 수 있다. 데이터 레코드 X를 3회 복제하고 해싱함으로써, 데이터 처리 시스템은 h1(x), h2(x), h3(x)와 같이 도 3에 나타낸 바와 같이 3개의 해싱된 데이터 레코드를 생성하였다. 여전히 블록(304A-C)을 참조하면, 데이터 처리 시스템은 해시된 데이터 레코드 각각에서 인덱스 값을 추출할 수 있다. 추출된 인덱스 값은 블룸 필터에서 적어도 하나의 각각의 위치에 대응할 수 있다. 도 3a에 제공된 예에서, 각 해시는 블룸 필터의 레지스터 위치 수인 11의 모듈러스로 계산된다. 11개의 레지스터 위치만 블룸 필터를 사용하지만 블룸 필터를 구현하는 데 여러 개의 카운팅 레지스터를 사용할 수 있음을 이해해야 한다.Referring to FIG. 3 , shown is a flow diagram 300 illustrating the insertion of data record X into a bloom filter by at least one data processing system (e.g., at least one of data processing systems 105, etc.). This is an example. At
도 3에서, h1(x)의 모듈러스(modulus) 11은 1과 같고, h2(x)의 모듈러스 11은 3과 같고, h3(x)의 모듈러스 11은 9와 같다. 이러한 값 각각은 블룸 필터의 해당 위치(예: ID 값 등)와 관련된 카운터 레지스터에 대한 포인터로 데이터 처리 시스템에서 사용할 수 있다. 예를 들어, 1과 같은 h1(x)의 모듈러스 11은 블룸 필터에서 위치 '1'을 가리킬 수 있고, 3과 동일한 h2(x)의 모듈러스 11은 블룸 필터에서 위치 '3'을 가리킬 수 있다. 이는 블룸 필터와 관련된 작업을 설명하기 위한 순전히 예시적인 값이며, 블룸 필터를 설명하는 구현의 범위를 제한하는 것으로 해석되어서는 안 된다. 데이터 처리 시스템은 각각의 해시 함수가 가리키는 카운터 레지스터 각각의 비트를 활성화하여 블룸 필터를 업데이트(예: 데이터 레코드 삽입)하여 업데이트된 블룸 필터(306)를 생성할 수 있다. 그러나 도 3은 1만큼만 증가된 각 카운터 레지스터를 도시했지만, 데이터 처리 시스템은 임의의 값만큼, 예를 들어 바이트, 비트 수만큼, 또는 본 명세서에 설명된 임의의 다른 값, 임계값 또는 추정치에 따라 임의의 카운터 레지스터를 증가시킬 수 있음을 이해해야 한다.In FIG. 3, the
ADBF 구현을 설명하기 위해 PSCA(probabilistic counting and stochastic averaging)를 구현하는 예시적인 ADBF가 설명된다. To illustrate an ADBF implementation, an exemplary ADBF implementing probabilistic counting and stochastic averaging (PSCA) is described.
PSCA 기반 기술은 비트맵 데이터 구조를 활용할 수 있다. 비트 맵 데이터 구조는 레지스터에 의해 정의된 좌표와 레지스터 내의 비트 위치를 갖는 벡터 데이터 구조, 벡터 데이터 구조의 벡터(ector-of-vectors data structure)와 같은 여러 방식으로 구현될 수 있다. 도 4a는 PCSA 3x2 비트맵을 예시한다. 각 셀 값은 1 또는 0과 약간 같을 수 있다. 여기에서 일반 지정자 '행'과 '열'은 특정 셀의 위치를 설명하는 데 사용된다. 행은 레지스터라고도 한다. PSCA 스케치에서 식별자는 비트 시퀀스를 기반으로 셀에 할당될 수 있다. 예를 들어, 각 행은 전체 유니버스 식별자의 1/nrows(이 예에서는 ⅓) 부분을 캡처할 수 있다. 열에는 전체 유니버스 식별자 중 기하급수적으로 감소한 부분이 있을 수 있다. 예를 들어 열 1은 ½을 가질 수 있고 열 2는 ¼을 가질 수 있다. 따라서 셀은 유니버스의 1/nrows * (½)^column_id 부분을 캡처한다. 3x2 PSCA 스케치의 예시적인 표현이 아래에 포함되어 있다. PSCA-based technologies may utilize bitmap data structures. Bitmap data structures can be implemented in several ways, such as vector data structures with coordinates defined by registers and bit locations within registers, and vector of vector data structures (ector-of-vectors data structure). 4A illustrates a PCSA 3x2 bitmap. Each cell value can be slightly equal to 1 or 0. Here, the general specifiers 'row' and 'column' are used to describe the location of a particular cell. A row is also called a register. In the PSCA sketch, identifiers can be assigned to cells based on bit sequences. For example, each row can capture 1/nrows (⅓ in this example) portion of the entire universe identifier. A column can contain an exponentially decreasing fraction of the total universe identifier. For
PCSA 비트맵은 도 4b에 도시된 바와 같이 비트 벡터로 평면화될 수 있다. 벡터는 열의 순서로 셀을 정렬한다. 제1 열에서 3개 셀의 제1 세그먼트이다. 이들은 각각 유니버스 id의 1/6를 캡처한다. 제2 열에서 3개 셀의 제2 세그먼트. 그들은 각각 유니버스의 1/12을 캡처한다. 비트 맵과 비트 벡터가 동일하며 서로 1-1 매핑될 수 있음이 분명하다. A PCSA bitmap can be flattened into a bit vector as shown in FIG. 4B. A vector sorts cells in column order. The first segment of three cells in the first row. They each
ADBF 스케치는 그러한 스케치의 일반화된 형태일 수 있다. ADBF 스케치는 도 4c의 일반적인 형태로 예시된 바와 같이 유니버스의 임의의 확률을 취할 수 있다.An ADBF sketch can be a generalized form of such a sketch. ADBF sketches can take any probability of the universe as illustrated in the general form of Figure 4c.
스케치의 각 위치에 대한 확률 분포는 임의의 값으로 일반화될 수 있기 때문에 여기에 설명된 다른 구조가 결과적으로 나타날 수 있다. 예를 들어, 모든 확률 값이 1/m로 동일하게 가중치가 부여되면 클래식 블룸 필터 구현이 나타나며, 여기서 m은 스케치의 위치 수(number of positions)이다. 마찬가지로 'water-fall'와 같은 확률이 각 세그먼트에 할당되면 PSCA와 같은 스케치가 나타난다. 또한 지수 p 값이 사용되는 경우 수학식 4와 같다.Because the probability distribution for each location in the sketch can be generalized to any value, other structures described here may result. For example, a classic bloom filter implementation results if all probability values are equally weighted as 1/m, where m is the number of positions in the sketch. Similarly, when probabilities like 'water-fall' are assigned to each segment, a sketch like PSCA emerges. In addition, when the exponent p value is used, it is the same as in
여기서, i는 스케치 위치의 인덱스이고, c는 정규화 인자이며, m은 스케치의 위치 수이며, LL(liquid legions) 유형 스케치가 나타난다.Here, i is the index of the sketch position, c is the normalization factor, m is the number of positions in the sketch, and a liquid legions (LL) type sketch appears.
아래에 설명된 지수 블룸 필터 사례는 ES(elegant statistical) 모델 및 해석을 통해 폐쇄형 최대 가능성 솔루션을 갖는다. 다음으로, 식별자로부터 ADBF 구성, 노이즈 추가, 하나의 ADBF 고유 카운트 계산, 여러 결합된 ADBF의 고유 카운트 계산을 포함하여 ADBF 및 일부 이론적 공식이 설명된다. 블룸 필터, PCSA/CL 및 ADBF를 비교하는 시뮬레이션 결과가 제공된다.The exponential bloom filter example described below has a closed maximum likelihood solution via an elegant statistical (ES) model and interpretation. Next, ADBF and some theoretical formulas are described, including constructing ADBF from an identifier, adding noise, calculating the eigencounts of one ADBF, and eigencounts of several combined ADBFs. Simulation results are provided comparing the Bloom filter, PCSA/CL and ADBF.
일반화된 블룸 필터(ADBF)는 다음과 같이 제공자 컴퓨팅 장치(예를 들어, 데이터 처리 시스템(105A-S))에 의해 구성될 수 있다. 카파(kappa) 파라미터는 1의 값으로 설정될 수 있지만 1보다 작을 수 있는 조정 가능한 파라미터이다. 데이터 처리 시스템은 ADBF 데이터 구조를 구성하는 데 활용하기 위해 하나 이상의 데이터 레코드(예: 식별자 및 속성 또는 특정 기준을 충족하는 식별자 등)에 액세스할 수 있다. 예를 들어, 데이터 처리 시스템은 구성된 ADBF 스케치에 삽입하는 데 사용할 하나 이상의 데이터 레코드에 액세스하기 위해 데이터베이스(예를 들어, 데이터베이스(125) 등)에 액세스할 수 있다. ADBF 스케치는 데이터 처리 시스템의 메모리에 유지될 수 있으며, 다른 스케치 구현에 대한 진행 섹션에서 여기에 설명된 초기화 값으로 초기화될 수 있다. 예를 들어, ADBF 스케치를 구성하는 절차는 CL(cascading legions) 스케치 또는 LL(liquid legions) 스케치와 실질적으로 유사할 수 있으며, 데이터 처리 시스템의 메모리에 저장되거나 다른 장치에서 수신된 파라미터를 기반으로 할 수 있다. A generalized bloom filter (ADBF) may be constructed by a provider computing device (eg, data processing system 105A-S) as follows. A kappa parameter is a tunable parameter that can be set to a value of 1, but can be less than 1. A data processing system may have access to one or more data records (eg, identifiers and attributes or identifiers meeting certain criteria) for use in constructing an ADBF data structure. For example, the data processing system may access a database (e.g., database 125, etc.) to access one or more data records for use in inserting into the constructed ADBF sketch. ADBF sketches can be persisted in the memory of the data processing system and initialized with the initialization values described here in the progress section for other sketch implementations. For example, the procedure for constructing an ADBF sketch may be substantially similar to a cascading legions (CL) sketch or a liquid legions (LL) sketch, and may be based on parameters stored in the memory of the data processing system or received from another device. can
구성(construction) 후, 데이터 레코드는 다음 기술을 사용하여 ADBF의 위치에 매핑할 수 있다. ADBF 스케치는 버킷 k의 수와 모든 확률 벡터(p1, p2, …, pk)를 포함하도록 구성할 수 있으며, 여기서 i 범위는 1에서 k인 모든 pi의 합이 카파(kappa)와 같다. 카파 값은 1일 수 있지만 1일 필요는 없다. 확률 벡터는 확률 벡터의 각 좌표가 ADBF 스케치에서 단일 버킷 또는 레지스터에 할당될 수 있도록 한다. 데이터 레코드(예를 들어, 데이터베이스(125)에 유지되는 데이터 레코드 등)의 각 식별자는 확률 p로 ADBF 스케치의 버킷 i에 삽입될 수 있다. 실제로, h를 식별자 공간(예: 데이터 레코드(기록) 공간 등)을 (0, 2^64)에 균일하게 매핑하는 데이터 처리 시스템(105)에 의해 식별된 해시라고 하자. After construction, data records can be mapped to locations in ADBF using the following technique. An ADBF sketch can be constructed to contain the number of buckets k and all probability vectors (p1, p2, ..., pk), where i ranges from 1 to k, where the sum of all pi equals kappa. The kappa value can be 1, but need not be 1. A probability vector allows each coordinate of the probability vector to be assigned to a single bucket or register in the ADBF sketch. Each identifier of a data record (eg, a data record maintained in database 125, etc.) may be inserted into bucket i of an ADBF sketch with probability p. In practice, let h be the hash identified by the data processing system 105 that uniformly maps the identifier space (e.g., data record (record) space, etc.) to (0, 2^64).
스케치의 차등 프라이버시(differentia privacy)를 유지하기 위해, 각각의 제공자 컴퓨팅 장치(예: 데이터 처리 시스템(105A-S) 등)는 미리 결정된 확률로 특정 비트를 플립(flip)할 수 있다. 노이즈를 추가하기 위해 비트를 플리핑(flipping)하는 과정을 여기에서 '블리핑(blipping)'이라고 할 수 있으며, 확률적 비트 플리핑을 통해 도입된 노이즈가 있는 스케치를 때때로 '블립(blipped)'이라고 한다. 데이터 처리 시스템(예: 데이터 처리 시스템(105A-S), 중복 제거 서버(115) 등)에 의해 구현된 추정기는 데이터 처리 시스템(105)에 의해 생성된 노이즈가 있는(예를 들어 블립) ADBF 스케치의 유니온의 카디널리티를 정확하게 계산하도록 추가로 확장될 수 있다. To maintain the differential privacy of the sketch, each provider computing device (eg, data processing system 105A-S, etc.) may flip certain bits with a predetermined probability. The process of flipping bits to add noise may be referred to here as 'blipping', and sketches with noise introduced through stochastic bit flipping are sometimes 'blipped'. It is said. An estimator implemented by a data processing system (eg, data processing system 105A-S, deduplication server 115, etc.) is a noisy (eg blip) ADBF sketch generated by data processing system 105. can be further extended to accurately compute the cardinality of the union of
이 섹션에서 설명하는 BLIP 기술은 차등 프라이버시(개인 정보) 보호가 될 수 있다. 특히, ADBF + BLIP은 raw NBF의 각 버킷을 플리핑(flipping)함으로써 얻는다. 동일한 확률 p로 이진수 0을 이진수 1로, 이진수 1을 이진수 0으로 플리핑한다. 일부 구현에서, 이진(바이너리) 0 값은 확률 p로 이진 1로 플리핑될 수 있고 이진 1 값은 확률 q로 이진 0으로 플리핑될 수 있다. The BLIP technology described in this section can be a differential privacy (personal information) protection. In particular, ADBF + BLIP is obtained by flipping each bucket of raw NBF. Flips binary 0 to
ABDF 스케치의 유니온의 카디널리티는 특정 개카운트 또는 범위(도달범위)(reach)를 결정하기 위해 추정될 수 있다. 추정기는 추정기(예: 데이터 처리 시스템(105), 중복 제거 서버(115) 등))를 실행하는 컴퓨팅 장치의 메모리로부터 일련의 튜닝 파라미터를 포함하거나 검색할 수 있다. 본 명세서에 기술된 하나 이상의 컴퓨팅 장치에 의해 실행, 진행 또는 달리 수행되는 추정기는 노이즈가 없는 ADBF 스케치(예: 노이즈가 포함되지 않은 ADBF 스케치 등)를 중복 제거할 수 있다. 노이즈가 없는 ADBF 스케치를 병합(merging)할 때 유니온 세트의 ADBF가 b=[b1, b2, …, bk]로 표시됨을 관찰한다. 1 ≤ i ≤ k의 경우 유니온의 데이터 레코드가 하나 이상 해당 버킷에 매핑되면 bi=1이고 그렇지 않으면 0이다. 모멘트 메소드는 b1, b2, ..., bk..에서 유니온을 추정하는 데 사용할 수 있다. pi는 버킷 i에 매핑되는 데이터 레코드의 확률을 나타내는 데 사용된다. u의 유니온 카디널리티를 고려하면 u 데이터 레코드가 버킷 i에 속하지 않을 확률은 (1-pi)u와 같다. 즉, P(bi = 0) = (1 - pi)u, 따라서 E(bi = 1|u) = 1 - (1 - pi)u이다. 따라서, 총 수(total number of ones)는 The cardinality of unions in an ABDF sketch can be estimated to determine a specific count or reach. The estimator may contain or retrieve a set of tuning parameters from memory of the computing device running the estimator (eg, data processing system 105, deduplication server 115, etc.). An estimator executed, processed or otherwise performed by one or more computing devices described herein may deduplicate a de-noised ADBF sketch (eg, a de-noised ADBF sketch, etc.). When merging noiseless ADBF sketches, the ADBF of the union set b=[b 1 , b 2 , … , b k ]. For 1 ≤ i ≤ k, b i =1 if at least one data record in the union is mapped to that bucket, and 0 otherwise. The moment method can be used to estimate unions in b 1 , b 2 , ..., b k .. pi is used to represent the probability of a data record mapping into bucket i. Given the union cardinality of u, the probability that a data record u does not belong to bucket i is equal to (1-p i ) u . That is, P(b i = 0) = (1 - pi ) u , so E(b i = 1|u) = 1 - (1 - pi ) u . Thus, the total number of ones is
도 5를 참조하면, 임의의 분포 블룸 필터를 생성 및 업데이트하기 위한 프로세스(500)가 도시되어 있다. 프로세스(500)가 도 5에 예시되어 있지만, 단일 블룸 필터(BF)를 업데이트함에 따라, 프로세스(500)는 위에서 설명된 바와 같이 프로세스(200)와 관련하여 설명된 임의의 특징에 통합될 수 있다. 예를 들어, 프로세스(500)는 주어진 엔트리에 대해 어떤 벡터가 선택되는지에 따라 벡터 데이터 구조 세트의 다양한 벡터에 대해 단계(208)를 수행하기 위해 프로세스(200)에 통합될 수 있다. 프로세스(500)는 임의의 데이터 처리 시스템(105)과 같은 메모리에 연결된 하나 이상의 프로세서에 의해 수행될 수 있다. Referring to FIG. 5 , a
502에서, BF로의 인코딩을 위해 N 데이터 엔트리 세트의 k번째 데이터 엔트리가 검색된다. k번째 데이터 엔트리는 BF에 인코딩될 식별자를 정의할 수 있다. 504에서, 식별자는 하나 이상의 해싱 함수(hashing function)를 사용하여 해싱된다. 하나 이상의 해싱 함수는 식별자를 입력으로 수신하고 BF에서 좌표를 정의하는 입력을 기반으로 해쉬 값을 출력하도록 구성된다. 506에서, BF의 M 좌표는 하나 이상의 해시 함수(hash function)의 하나 이상의 출력에 기초하여 식별된다. 일부 구현에서, 하나 이상의 해시 함수의 하나 이상의 출력은 모듈러스 연산자를 통해 전달되어 출력을 BF의 유효한 좌표로 변환할 수 있다. At 502, the kth data entry of the set of N data entries is retrieved for encoding into BF. The kth data entry may define an identifier to be encoded in BF. At 504, the identifier is hashed using one or more hashing functions. One or more hashing functions are configured to receive identifiers as inputs and output hash values based on the inputs defining coordinates in the BF. At 506, the M coordinate of BF is identified based on one or more outputs of one or more hash functions. In some implementations, one or more outputs of one or more hash functions may be passed through a modulus operator to convert the outputs to valid coordinates of a BF.
506에서 식별된 하나 이상의 좌표는 BF(카운터 j로 표시됨)를 업데이트하기 위해 반복될 수 있다. 508에서, j번째 좌표에 대응하는 카운팅 레지스터가 선택된다. 일부 구현에서, j번째 좌표는 대응하는 카운팅 레지스터의 메모리 위치를 정의한다. 510에서, 선택된 레지스터는 적절한 경우 k번째 식별자를 인코딩하기 위해 증분(incremented)된다. 예를 들어, 선택한 레지스터가 현재 이진 값 0을 보유하고 있는 경우 레지스터는 이진 값 1을 보유하도록 증가할 수 있다. 예를 들어, 선택한 레지스터가 현재 이진 값 1을 보유하고 있는 경우 레지스터가 이미 이진 1 값을 보유하고 있기 때문에 레지스터가 증가하지 않을 수 있다. 512에서의 결정은 k번째 식별자에 대한 M개의 식별된 좌표를 반복한다. 512에서의 기준이 충족되지 않으면, j 카운터를 증가시키기 위해 단계 514가 실행되고 다음 좌표에 대해 단계 508-512를 반복한다. One or more coordinates identified at 506 may be repeated to update BF (denoted by counter j). At 508, the counting register corresponding to the j-th coordinate is selected. In some implementations, the j coordinate defines the memory location of the corresponding counting register. At 510, the selected register is incremented to encode the kth identifier, if appropriate. For example, if the selected register currently holds the
512의 기준이 충족되면, 프로세스(500)는 결정(516)에서 계속된다. 결정(516)은 모든 데이터 아이템이 BF로 인코딩되었는지 여부를 결정한다. 516의 기준이 충족되지 않으면 518에서 카운터 k가 증가하고 다음 데이터 입력에 대해 프로세스(500)가 반복된다. 516의 기준이 충족되면, BF의 업데이트가 완료되고 벡터는 520에서 처리 시스템으로 전송되거나 그렇지 않으면 스토리지로 출력될 수 있다. If the criterion of 512 is met,
도 6을 참조하면, 중복 제거된 데이터 세트를 생성하기 위해 다수의 제공자로부터 데이터 세트를 집계하는 프로세스(600)가 도시되어 있다. 프로세스(600)는 중복 제거 서버(115) 또는 데이터 처리 시스템(105)과 같은 메모리와 결합된 하나 이상의 프로세서에 의해 구현될 수 있다. 프로세스(600)는 복수의 제공자 간의 프라이빗된 데이터 교환 프로토콜의 구현을 용이하게 하는 중앙 서버 장치에 의해 실행될 수 있거나, 복수의 제공자 내의 개별 제공자에 의해 실행될 수 있다. 일반적으로, 프로세스(600)는 예를 들어 프로세스(200)를 통해 생성될 수 있는 제1 제공자와 제2 제공자의 프로세싱 시스템에 의해 생성된 프라이빗 스케치 세트를 결합한다. 프로세스(600)가 둘의 제공자로부터의 데이터 세트만을 포함하는 것으로 예시되어 있지만, 프로세스(600)는 중복 제거된 분포를 생성하기 위해 임의의 수의 제공자로부터의 데이터 세트를 포함할 수 있다. Referring to Fig. 6, a
602에서, 제1 프라이빗 스케치 세트(프라이빗 스케치들의 제1 세트)가 제1 제공자로부터 수신되고 제2 프라이빗 스케치 세트(프라이빗 스케치들의 제2 세트)가 제2 제공자로부터 수신된다. 제1 프라이빗 스케치 세트 및 제2 프라이빗 스케치 세트의 각 프라이빗 스케치는 제1 제공자 및 제2 제공자 각각과의 상호작용과 관련된 식별자를 인코딩하고, 각 프라이빗 스케치는 특정 빈도 또는 빈도 범위에 해당한다. 프라이빗 스케치는 VoC 또는 ADBF와 같은 벡터 데이터 구조로 구성 및 수신될 수 있다. 프라이빗 스케치는 프라이빗 스케치에 인코딩된 사용자의 식별자가 가려(obscured)질 수 있도록 차등적으로 프라이빗될 수 있다. At 602, a first private sketch set (first set of private sketches) is received from a first provider and a second private sketch set (second set of private sketches) is received from a second provider. Each private sketch of the first private sketch set and the second private sketch set encodes an identifier associated with an interaction with each of the first provider and the second provider, and each private sketch corresponds to a specific frequency or frequency range. Private sketches can be constructed and received as vector data structures such as VoC or ADBF. Private sketches can be differentially private so that the user's identifier encoded in the private sketch can be obscured.
604에서, 제1 프라이빗 스케치 세트 및 제2 프라이빗 스케치 세트를 사용하여 중복 제거된 결합된 분포가 생성된다. 중복 제거된 데이터 세트를 생성하기 위해 여러 방법을 수행할 수 있다. 일 구현에서, 제1 프라이빗 스케치 세트는 제2 프라이빗 스케치 세트와 결합되어 2개의 데이터 세트를 중복 제거하는 병합된 프라이빗 스케치 세트(프라이빗 스케치들의 병합된 세트)를 생성한다. 그런 다음 병합된 프라이빗 스케치 세트에서 전체 분포를 추정할 수 있다. 다른 구현에서, 빈도별 분포는 개별 스케치 간의 인터섹션, 유니온 및 SD(set differences)와 같은 세트 연산을 사용하여 프라이빗 스케치 세트로부터 직접 추정될 수 있다. At 604, a deduplicated combined distribution is created using the first private sketch set and the second private sketch set. Several methods can be performed to create a deduplicated data set. In one implementation, a first private sketch set is combined with a second private sketch set to create a merged private sketch set (merged set of private sketches) that de-dupes the two data sets. The overall distribution can then be estimated from the merged set of private sketches. In another implementation, the distribution by frequency can be estimated directly from a set of private sketches using set operations such as intersections, unions, and set differences between individual sketches.
606에서 중복 제거된 분포(distribution)가 데이터베이스에 저장된다. 일부 구현에서, 데이터베이스는 검토를 위해 복수의 제공자 처리 시스템에 액세스할 수 있다. 2개의 프라이빗 스케치 세트로 인코딩된 2개의 데이터 세트가 중복 제거된 단일 데이터 세트로 축소된다는 점에서 프로세스(600)에서 기술적 이점이 실현된다. 따라서 단일 데이터 세트는 동일하거나 거의 동일한 정보를 유지하기 위해 저장해야 하는 데이터가 더 적기 때문에 복수의 제공자에 걸쳐 분산 데이터를 저장하는 메모리 요구사항의 크기 및 복잡성을 줄인다. 608에서, 중복 제거된 분포의 표현을 표시하기 위해 사용자 인터페이스가 생성될 수 있다. 사용자 인터페이스는 처리 시스템과 관련된 디스플레이에 출력되거나 디스플레이를 위해 별도의 처리 장치로 보내질 수 있다. At 606, the deduplicated distribution is stored in the database. In some implementations, the database may access multiple provider processing systems for review. A technical advantage is realized in
일부 구현에서, 빈도 지정은 제1 제공자 및 제2 제공자에게 전송된다. 빈도 지정은 일반적으로 프라이빗된 데이터 교환 프로토콜의 하나 이상의 파라미터를 나타낼 수 있다. 일부 구현에서, 빈도 지정은 k개의 프라이빗 스케치가 세트 {1, 2, …, k-1, k+}의 빈도 빈에 각각 대응하는 각 제공자로부터 요청됨을 나타내는 최대 빈도 임계값 k를 정의할 수 있다. 일부 구현에서, 빈도 지정은 "offline(오프라인)" 매체를 통해, 예를 들어 대면 회의 또는 구두 합의를 통해 각 제공자에게 전송되므로 단계 602를 실행할 필요가 없다. In some implementations, the frequency designation is sent to the first provider and the second provider. The frequency designation may represent one or more parameters of the data exchange protocol that are generally private. In some implementations, the frequency specification is such that k private sketches are set {1, 2, ... , k−1, k+} frequency bins, respectively, may define a maximum frequency threshold value k indicating that requests are requested from each provider. In some implementations, it is not necessary to perform
중복 제거를 위한 몇 가지 방법은 아래에서 더 자세히 설명한다.Several methods for deduplication are described in more detail below.
빈도별 리치(도달범위)(reach)(Reach (reach) by frequency (
순차적 병합 알고리즘은 일반적으로 다음과 같이 나타낼 수 있다. The sequential merge algorithm can be generally expressed as:
제1 제공자가 제1 스케치 세트 {x1, x2, …, x(k-1), x(k+)}를 게시하고 제2 제공자가 제2 스케치 세트 {y1, y2, …, y(k- 1), y(k+)}를 게시한다. A first provider provides a first set of sketches {x 1 , x 2 , . . . , x (k-1) , x (k+) } and the second contributor publishes a second set of sketches {y 1 , y 2 , . . . , y (k-1) , y (k+) }.
먼저 각 제공자에 대해 1+의 빈도 도달범위(리치)를 나타내는 스케치가 생성된다. 각 제공자의 스케치가 연결되지 않은(disjointed) 경우, 1+ 스케치는 수학식 5-6과 같이 생성될 수 있다.First, a sketch is created representing the frequency reach (reach) of 1+ for each provider. When the sketches of each provider are disjointed, 1+ sketches may be generated as shown in Equation 5-6.
k보다 작은 특정 빈도 j에 대해, 제1 제공자와 제2 제공자의 조합을 나타내는 j번째 스케치는 수학식 7과 같이 계산할 수 있다.For a specific frequency j less than k, the j-th sketch representing the combination of the first provider and the second provider can be calculated as in
여기서 (∪)은 유니온 연산자, (∩)은 인터섹트(intersect) 연산자, (＼)는 SD(set different) 연산자이다. 이 공식은 1에서 k-1까지의 j 값에 대해 반복되어 k-1 스케치를 생성한다.Here, (∪) is a union operator, (∩) is an intersect operator, and (\) is a set different (SD) operator. This formula is repeated for values of j from 1 to k-1 to create a k-1 sketch.
k+의 결합된 스케치를 생성하기 위해, 결합은 수학식 8과 같이 계산될 수 있다.To create a combined sketch of k+, the coupling can be calculated as in Equation (8).
위의 수학식은 다음 수학식 9에서 얻을 수 있는 x0과 y(k+)의 인터섹션을 고려한다. The above equation considers the intersection of x 0 and y (k+) , which can be obtained from the following equation (9).
따라서, k개의 스케치는 세트 {z1, z2, …, z(k-1), z(k+)}로 표현되는 제1 및 제2 제공자의 스케치 세트의 조합으로 생성될 수 있다. s 제공자 그룹에 추가 제공자를 병합하기 위해, 순차 병합 방법은 조합 세트 {z1, z2, …, z(k-1), z(k+)}와 제3 제공자, 그 다음 제4 제공자 등에 의해 생성된 스케치들을 조합(결합)하여 재귀적으로 반복될 수 있다. s 제공자의 s 스케치 세트를 조합(결합)한 후, 최종 조합 세트 Thus, k sketches are set {z 1 , z 2 , . . . , z (k-1) , z (k+) }. To merge additional providers into the s provider group, the sequential merge method uses a combination set {z 1 , z 2 , . . . , z (k-1) , z (k+) } and the sketches created by the third provider, then the fourth provider, etc. After assembling (combining) the s sketch sets from the s providers, the final combined set
도 7을 참조하면, 프로세스(700)는 일반적으로 s개의 제공자 각각으로부터 k개의 스케치를 순차적으로 병합하기 위한 방법을 예시한다. Referring to FIG. 7 ,
702에서, 프로세스(700)의 재귀적 병합 연산을 통해 벡터의 워킹 세트(working set)로서 기능하도록 공 벡터(empty vectors) 세트가 생성된다. 공 벡터 세트는 복수의 제공자가 합의한 프로토콜과 동일한 수의 벡터를 포함하며, 복수의 제공자로부터 수신된 벡터와 동일한 방식으로 구성된다. 704에서, 복수의 제공자 중 제1 제공자로부터 수신된 k개의 벡터가 벡터의 워킹 세트로 카피된다. 일부 구현에서, 제1 제공자는 복수의 제공자로부터 무작위로 선택될 수 있다. At 702, a set of empty vectors is created to serve as a working set of vectors through the recursive merge operation of
706에서, 나머지 s-1 제공자를 통해 반복하도록 카운터 j가 정의된다. 카운터 j는 제1 제공자가 반복에서 제외되도록 2로 초기화되는 것으로 표시된다. 708에서, j번째 제공자로부터 벡터 세트가 검색된다. 그 다음, 710에서, j번째 제공자로부터의 k 벡터는 벡터의 병합된 세트를 생성하기 위해 워킹 세트의 k 벡터와 결합된다. 두 세트의 k 벡터는 위에서 설명한 수학식을 사용하여 결합(조합)할 수 있다. 712에서, k 벡터의 병합된 세트는 그 다음 벡터의 워킹 세트로서 저장된다. 따라서, 712에서의 업데이트는 이전 워킹 세트를 가장 최근의 병합된 벡터 세트로 대체할 수 있다. At 706, a counter j is defined to iterate through the remaining s-1 providers. Counter j is marked as being initialized to 2 so that the first provider is excluded from the iteration. At 708, a set of vectors is retrieved from the jth provider. Then, at 710, the k vectors from the jth provider are combined with the k vectors in the working set to create a merged set of vectors. The two sets of k vectors can be combined (combined) using the equation described above. At 712, the merged set of k vectors is then stored as a working set of vectors. Thus, the update at 712 may replace the previous working set with the most recent merged vector set.
714에서, s개의 제공자 그룹의 모든 제공자가 벡터의 워킹 세트로 병합되었는지 여부가 결정된다. 714에서 모든 제공자가 병합되지 않은 것으로 결정되면, 카운터 j는 716에서 증분(incremented)되고 단계 708-714는 다음 제공자에 대해 반복된다. 따라서 각 프라이빗 스케치 세트는 모든 데이터 세트가 병합될 때까지 이전 병합된 벡터 세트(즉, 워킹 세트)와 순차적으로 병합된다. 결정(decision)(714)에서의 그러한 결정(determination)에서, 718에서 최종 분포는 k 벡터의 워킹 세트에 기초하여 추정된다. 상술한 바와 같이, 각 스케치의 카디널리티 추정에 기초하여 빈도별 분포(per-frequency distribution)를 추정할 수 있다. At 714, it is determined whether all providers in the s provider groups have been merged into the vector's working set. If it is determined at 714 that all providers are not merged, the counter j is incremented at 716 and steps 708-714 are repeated for the next provider. Thus, each private sketch set is merged sequentially with the previously merged vector set (i.e. working set) until all data sets are merged. At such a determination in
도 8a를 참조하면, 순차 병합 알고리즘을 사용하여 생성된 제1 테스트 세트의 추정된 분포를 제1 테스트 세트의 실제(true) 분포와 비교하기 위한 예시적인 히스토그램이 제공된다. 여기에서 제1 테스트 세트는 총 식별자 200,000개의 유니버스 크기, 2^14 버킷으로 구성된 벡터, 독립적인 데이터 세트(즉, 데이터 세트 간에 겹치지 않음)가 있는 두 제공자의 중복 제거, 최대 빈도 5(여기서 제5(다섯 번째) 빈도 빈은 "5+"를 나타냄)를 나타낸다.Referring to FIG. 8A , an example histogram for comparing the estimated distribution of the first test set generated using the sequential merge algorithm to the true distribution of the first test set is provided. Here, the first test set is a universe size of 200,000 total identifiers, a vector of 2^14 buckets, deduplication of two providers with independent data sets (i.e., no overlap between data sets), a maximum frequency of 5 (here the 5 (fifth) frequency bin represents "5+").
도 8b를 참조하면, 다른 예시적인 히스토그램은 순차 병합 알고리즘을 사용하여 생성된 제2 테스트 세트의 추정된 분포를 제2 테스트 세트의 실제(true) 분포와 비교하여 제시된다. 여기에서 제2 테스트 세트는 총 식별자 200,000개의 유니버스 크기, 2^14 버킷으로 구성된 벡터, 5개 제공자의 중복 제거, 추가된 DP 노이즈 없음, 최대 빈도 10(여기서 10번째 빈도 빈은 "10+"를 나타냄)을 나타낸다. Referring to FIG. 8B , another example histogram is presented comparing the estimated distribution of the second test set generated using the sequential merge algorithm to the true distribution of the second test set. Here, the second test set has a universe size of 200,000 total identifiers, a vector of 2^14 buckets, deduplication of 5 providers, no added DP noise, and a maximum frequency of 10 (where the 10th frequency bin is "10+"). indicates).
도 8c는 결합(조합) 전에 각 스케치에 초기에 도입된 DP-노이즈 ε = log(3)의 추가와 함께 제2(두 번째) 테스트 세트의 테스트 데이터를 보여준다. Fig. 8c shows the test data of the second (second) test set with the addition of the DP-noise ε = log(3) initially introduced into each sketch before combining (combination).
도 8d는 순차 병합 알고리즘을 사용하여 생성된 제3 테스트 세트의 추정된 분포를 제3 테스트 세트의 실제(true) 분포와 비교하는 다른 예시적인 히스토그램을 도시한다. 여기서 제3 테스트 세트는 총 식별자 200,000개의 유니버스 크기, 2^14 버킷으로 구성된 벡터, 5개 제공자의 중복 제거, DP-노이즈 ε = log(3), 최대 빈도 10(여기서 10번째 빈도 빈은 "10+"를 나타냄)을 나타낸다.8D shows another exemplary histogram comparing the estimated distribution of the third test set generated using the sequential merge algorithm to the true distribution of the third test set. Here, the third test set has a universe size of 200,000 total identifiers, a vector of 2^14 buckets, deduplication of 5 providers, DP-noise ε = log(3), a maximum frequency of 10 (where the 10th frequency bin is "10 indicates +").
s 제공자의 프라이빗 스케치를 결합(조합)하는 또 다른 방법은 Chow-Liu 모델을 기반으로 한다. 빈도 빈 k의 빈도별 도달범위를 수학식 10을 통해 계산한다.Another way to combine (combine) the private sketches of s providers is based on the Chow-Liu model. The reach of each frequency of the frequency bin k is calculated through
여기서, R(*)은 특정 조건(*)을 만족하는 사용자 수(즉, 도달범위)를 나타내며, j는 j번째 제공자에서의 사용자 빈도이다. Here, R(*) represents the number of users (ie, reach) satisfying a specific condition (*), and j is the frequency of users in the j-th provider.
Chow-Liu 모델을 사용하여, 각 항 Using the Chow-Liu model, each term
이는 수학식 12를 의미하며, 수학식 13과 같이 다시 작성될 수 있다.This means
Chow-Liu 모델은 제공자의 임의의 선형 트리를 가정한다. 특히, 1→ 2 → … → s의 선형 트리는 선형 시퀀스에서 인접한 제공자들 간의 쌍별 중첩(pairwise-overlap)을 생성한다. The Chow-Liu model assumes an arbitrary linear tree of providers. In particular, 1→ 2 → … → A linear tree of s produces pairwise-overlap between adjacent contributors in a linear sequence.
이는 수학식 16과 같이 As shown in Equation 16,
따라서 분석 시스템은 위에서 설명한 알고리즘을 사용하여 전체 그룹에 대한 총 도달 분포(reach distribution)를 추정하기 위해 s 제공자 그룹에서 프라이빗 스케치를 중복 제거할 수 있다. Therefore, the analytics system can dedupe private sketches from a group of s providers to estimate the total reach distribution for the entire group using the algorithm described above.
도 9a를 참조하면, 쌍별 중첩(쌍-중첩)(pairwise-overlap) 알고리즘을 사용하여 생성된 제1 테스트 세트의 추정된 분포를 제1 테스트 세트의 실제(true) 분포와 비교하기 위해 예시적인 히스토그램이 제공된다. 여기서 제1 테스트 세트는 총 식별자 200,000개의 유니버스 크기, 2^14 버킷으로 구성된 벡터, 독립적인 푸아송(Poisson) 모델을 사용하여 생성된 5개 제공자의 중복 제거, 최대 빈도 5(여기서 다섯 번째 빈도 빈은 "5+"를 나타냄)를 나타낸다. Referring to FIG. 9A , an exemplary histogram for comparing the estimated distribution of the first test set generated using a pairwise-overlap algorithm with the true distribution of the first test set. is provided. Here, the first test set has a universe size of 200,000 total identifiers, a vector of 2^14 buckets, deduplication of 5 contributors generated using an independent Poisson model, and a maximum frequency of 5 (where the fifth frequency bin is represents "5+").
도 9b는 쌍-중첩 알고리즘을 사용하여 생성된 제2 테스트 세트의 추정된 분포를 제2 테스트 세트의 실제(true) 분포와 비교하는 다른 예시적인 히스토그램을 도시한다. 여기서 제2 테스트 세트는 총 식별자 200,000개의 유니버스 크기, 2^14 버킷으로 구성된 벡터, 역상관 데이터 세트를 사용하여 생성된 5개 제공자의 중복 제거, 최대 빈도 5(여기서 다섯 번째 빈도 빈은 "5+"를 나타냄)를 나타낸다. 9B shows another example histogram comparing the estimated distribution of the second test set generated using the pair-overlap algorithm to the true distribution of the second test set. Here, the second test set has a universe size of 200,000 total identifiers, a vector of 2^14 buckets, deduplication of 5 contributors generated using the decorrelation data set, and a maximum frequency of 5 (where the fifth frequency bin is "5+"). represents ").
제2 테스트 세트는 쌍-중첩 알고리즘을 스트레스 테스트하도록 설계되었다. 빈도별 도달범위(The second test set is designed to stress test the pair-overlap algorithm. Reach by frequency (
여기서, here,
다시 말해서, 각 제공자가 제공한 빈도당 개수는 개별 스케치에서 추정하고 위 수학식에 직접 입력하여 제공자 그룹 전체의 빈도당 분포를 추정할 수 있다. 따라서 분석 시스템은 각 제공자의 빈도별 도달 데이터를 결합하고 중복 제거된 데이터 세트의 예상 분포를 생성하기 위해 위의 수학식을 구현하는 논리로 구성될 수 있다. In other words, the number per frequency provided by each provider can be estimated in an individual sketch and directly input into the above equation to estimate the distribution per frequency of the entire provider group. Thus, the analytics system can be configured with logic that implements the above equation to combine each provider's frequency-of-arrival data and generate the expected distribution of the deduplicated data set.
도 10은 예를 들어 예시적인 데이터 처리 시스템(105), 예시적인 중복 제거 서버(115), 예시적인 분석 장치(120), 예시적인 클라이언트 장치(135), 및/또는 본 개시에서 설명된 다양한 다른 예시적인 시스템을 구현하기 위해 사용될 수 있는 컴퓨터 시스템(1000)의 묘사를 도시한다. 컴퓨팅 시스템(1000)은 정보를 통신하기 위한 버스(1005) 또는 다른 통신 컴포넌트 및 정보를 처리하기 위해 버스(1005)에 연결된 프로세서(1010)를 포함한다. 컴퓨팅 시스템(1000)은 또한 정보를 저장하기 위해 버스(1005)에 연결된 랜덤 액세스 메모리(RAM) 또는 다른 동적 저장 장치와 같은 주 메모리(1015), 및 프로세서(1010)에 의해 실행될 명령어를 포함한다. 메인 메모리(1015)는 또한 프로세서(1010)에 의한 명령어 실행 동안 위치 정보, 임시 변수, 또는 다른 중간 정보를 저장하기 위해 사용될 수 있다. 컴퓨팅 시스템(1000)은 프로세서(1010)에 대한 명령어 및 정적 정보를 저장하기 위해 버스(1005)에 연결된 읽기 전용 메모리(ROM)(1020) 또는 다른 정적 저장 장치를 더 포함할 수 있다. 고체 상태 장치, 자기 디스크 또는 광 디스크와 같은 저장 장치(1025)는 정보 및 명령어를 지속적으로 저장하기 위해 버스(1005)에 연결된다. 10 illustrates, for example, an example data processing system 105, an example deduplication server 115, an example analysis device 120, an example client device 135, and/or various other devices described in this disclosure. It shows a depiction of a
컴퓨팅 시스템(1000)은 버스(1005)를 통해 사용자에게 정보를 디스플레이하기 위해 액정 디스플레이 또는 능동 매트릭스 디스플레이와 같은 디스플레이(1035)에 연결될 수 있다. 영숫자 및 기타 키를 포함하는 키보드와 같은 입력 장치(1030)는 정보 및 명령 선택을 프로세서(1010)에 전달하기 위해 버스(1005)에 연결될 수 있다. 다른 구현에서, 입력 장치(1030)는 터치 스크린 디스플레이(1035)를 갖는다. 입력 장치(1030)는 프로세서(1010)에 방향 정보 및 명령 선택을 전달하고 디스플레이(1035) 상의 커서 이동을 제어하기 위한 마우스, 트랙볼, 또는 커서 방향 키와 같은 커서 제어를 포함할 수 있다.
일부 구현에서, 컴퓨팅 시스템(1000)은 네트워킹 어댑터와 같은 통신 어댑터(1040)를 포함할 수 있다. 통신 어댑터(1040)는 버스(1005)에 연결될 수 있고 컴퓨팅 또는 통신 네트워크(1045) 및/또는 다른 컴퓨팅 시스템과의 통신을 가능하게 하도록 구성될 수 있다. 다양한 예시적인 구현에서, 유선(예를 들어, 이더넷®을 통해), 무선(예를 들어, WiFi®, 블루투스® 등을 통해), 사전 구성된, 애드혹, LAN, WAN과 같은 통신 어댑터(1040)를 사용하여 모든 유형의 네트워킹 구성이 달성될 수 있다. In some implementations,
다양한 구현들에 따르면, 여기에 설명된 예시적인 구현들을 실행하는 프로세스들은 메인 메모리(1015)에 포함된 명령어들의 배열을 실행하는 프로세서(1010)에 응답하여 컴퓨팅 시스템(1000)에 의해 달성될 수 있다. 그러한 명령어는 저장 장치(1025)와 같은 다른 컴퓨터 판독 가능 매체로부터 주 메모리(1015)로 판독될 수 있다. 메인 메모리(1015)에 포함된 명령어 배열의 실행은 컴퓨팅 시스템(1000)이 여기에 설명된 예시적인 프로세스를 수행하게 한다. 다중 처리 배열의 하나 이상의 프로세서는 또한 메인 메모리(1015)에 포함된 명령어를 실행하기 위해 사용될 수 있다. 대안적인 구현에서, 하드와이어드 회로는 예시적인 구현을 구현하기 위해 소프트웨어 명령어 대신에 또는 이와 함께 사용될 수 있다. 따라서 구현은 하드웨어 회로와 소프트웨어의 특정 조합으로 제한되지 않는다. According to various implementations, processes executing the example implementations described herein may be accomplished by
본 개시내용에서 설명된 시스템 및 방법은 임의의 유형의 제3자 콘텐츠 아이템(즉, 리소스에 표시할 모든 유형의 콘텐츠 아이템)에 대해 구현가능할 수 있다. 일 구현에서, 콘텐츠 아이템은 광고를 포함할 수 있다. 한 구현에서, 콘텐츠 아이템에는 텍스트, 이미지, 비디오, 스토리(예: 뉴스 기사), 소셜 미디어 콘텐츠, 링크 또는 제3자가 자사 콘텐츠 제공자의 리소스에 표시하기 위해 제공한 기타 유형의 콘텐츠가 포함될 수 있다. 여기에서 콘텐츠 가시성 방법이 사용되는 콘텐츠 아이템의 유형은 제한되지 않는다. The systems and methods described in this disclosure may be implementable for any type of third party content item (ie, any type of content item to be displayed on a resource). In one implementation, an item of content may include advertisements. In one implementation, content items may include text, images, videos, stories (eg, news articles), social media content, links, or other types of content provided by third parties for display on their content provider's resources. The type of content item for which the content visibility method is used here is not limited.
예시적인 프로세싱 시스템이 도 10에서 설명되었지만, 본 명세서에 기술된 주제 및 기능적 동작의 구현은 다른 유형의 디지털 전자 회로를 사용하여, 또는 본 명세서에 개시된 구조 및 그 구조적 등가물을 포함하는 컴퓨터 소프트웨어, 펌웨어 또는 하드웨어에서, 또는 조합하여 수행될 수 있다.Although an exemplary processing system is illustrated in FIG. 10 , implementations of the subject matter and functional operations described herein may be implemented using other types of digital electronic circuitry, or computer software, firmware, including the structures disclosed herein and their structural equivalents. or in hardware, or in combination.
본 명세서에 기술된 주제 및 동작의 구현은 디지털 전자 회로, 또는 본 명세서에 개시된 구조 및 그 구조적 등가물을 포함하는 유형 매체, 펌웨어 또는 하드웨어에 구현된 컴퓨터 소프트웨어 또는 조합으로 구현될 수 있다. 본 명세서에 기술된 주제의 구현은 하나 이상의 컴퓨터 프로그램, 즉, 데이터 처리 장치에 의해 실행되거나 데이터 처리 장치의 동작을 제어하기 위해 컴퓨터 저장 매체에 인코딩된 컴퓨터 프로그램 명령어의 하나 이상의 컴포넌트로 구현될 수 있다. 프로그램 명령어는 인공적으로 생성된 전파 신호, 예를 들어 데이터 처리 장치에 의한 실행을 위해 적절한 수신기 장치로의 전송을 위한 정보를 인코딩하도록 생성된 기계 생성 전기, 광학 또는 전자기 신호에 인코딩될 수 있다. 컴퓨터 저장 매체는 컴퓨터 판독가능 저장 장치, 컴퓨터 판독가능 저장 기판, 랜덤 또는 직렬 액세스 메모리 어레이 또는 장치, 또는 이들의 임의의 조합일 수 있거나 이에 포함될 수 있다. 더욱이, 컴퓨터 저장 매체는 전파 신호가 아니지만, 컴퓨터 저장 매체는 인위적으로 생성된 전파 신호로 인코딩된 컴퓨터 프로그램 명령어의 소스 또는 목적지를 포함할 수 있다. 컴퓨터 저장 매체는 또한 하나 이상의 개별 물리적 컴포넌트 또는 매체(예: 여러 개의 CD, 디스크, 플래시 메모리, 솔리드 스테이트 메모리 또는 기타 저장 장치)일 수 있거나 이에 포함될 수 있다. Implementations of the subject matter and operations described herein may be implemented in digital electronic circuitry, or in tangible media including the structures disclosed herein and their structural equivalents, computer software embodied in firmware or hardware, or combinations thereof. Implementations of the subject matter described herein may be implemented in one or more computer programs, i.e., one or more components of computer program instructions executed by a data processing device or encoded on a computer storage medium to control the operation of a data processing device. . Program instructions may be encoded in an artificially generated radio signal, for example a machine generated electrical, optical or electromagnetic signal generated to encode information for transmission to an appropriate receiver device for execution by a data processing device. A computer storage medium may be or be included in a computer readable storage device, a computer readable storage substrate, a random or serial access memory array or device, or any combination thereof. Moreover, while a computer storage medium is not a propagated signal, a computer storage medium may include a source or destination of computer program instructions encoded in an artificially generated propagated signal. A computer storage medium can also be or be included in one or more separate physical components or media (eg, multiple CDs, disks, flash memory, solid state memory, or other storage devices).
여기에 개시된 특징은 랩톱 컴퓨터 또는 다른 개인용 컴퓨터, 스마트폰, 다른 이동 전화, 핸드헬드 컴퓨터, 태블릿 PC, 또는 다른 컴퓨팅 장치에서 구현될 수 있다. Features disclosed herein may be implemented on a laptop computer or other personal computer, smart phone, other mobile phone, handheld computer, tablet PC, or other computing device.
본 명세서에서 설명하는 동작은 컴퓨터 판독 가능한 하나 이상의 저장 장치에 저장되거나 다른 소스로부터 수신된 데이터에 대해 데이터 처리 장치가 수행하는 동작으로 구현될 수 있다. Operations described in this specification may be implemented as operations performed by a data processing device on data stored in one or more computer-readable storage devices or received from other sources.
"데이터 처리 장치", "데이터 처리 시스템", "사용자 장치", "클라이언트 장치", "워커 장치", "워커", "워커 컴퓨팅 장치", "게시자" 또는 "컴퓨팅 장치"라는 용어는 예를 들어 프로그램 가능한 프로세서, 컴퓨터, 시스템 온 칩(system on a chip), 또는 이들의 조합을 포함하여 데이터를 처리하기 위한 모든 종류의 장치, 디바이스 및 기계를 포함한다. 장치는 예를 들어 FPGA(field programmable gate array) 또는 ASIC(application-specific integrated circuit)과 같은 특수 목적 논리 회로를 포함할 수 있다. 장치는 또한 하드웨어에 추가하여, 해당 컴퓨터 프로그램에 대한 실행 환경을 생성하는 코드를 포함할 수 있다(예: 프로세서 펌웨어, 프로토콜 스택, 데이터베이스 관리 시스템, 운영 체제, 플랫폼 간 런타임 환경, 가상 머신 또는 이들의 조합을 구성하는 코드). 장치 및 실행 환경은 웹 서비스, 분산 컴퓨팅 및 그리드 컴퓨팅 인프라와 같은 다양한 컴퓨팅 모델 인프라를 실현할 수 있다. The terms "data processing device", "data processing system", "user device", "client device", "worker device", "worker", "worker computing device", "publisher", or "computing device" are used to give examples includes all kinds of devices, devices and machines for processing data, including, for example, programmable processors, computers, systems on a chip, or combinations thereof. The devices may include special purpose logic circuits such as, for example, field programmable gate arrays (FPGAs) or application-specific integrated circuits (ASICs). A device may also include, in addition to hardware, code that creates an execution environment for a corresponding computer program (e.g., processor firmware, protocol stacks, database management systems, operating systems, cross-platform runtime environments, virtual machines, or any of these code that makes up the combination). Devices and execution environments may realize various computing model infrastructures such as web services, distributed computing, and grid computing infrastructures.
컴퓨터 프로그램(프로그램, 소프트웨어, 소프트웨어 애플리케이션, 스크립트 또는 코드라고도 함)은 컴파일 또는 해석된 언어, 선언적 또는 절차적 언어를 포함한 모든 형태의 프로그래밍 언어로 작성할 수 있다. 독립 실행형 프로그램 또는 모듈, 컴포넌트, 서브루틴, 개체 또는 컴퓨팅 환경에서 사용하기에 적합한 기타 단위를 포함하여 모든 형태로 분배될 수 있다. 컴퓨터 프로그램은 파일 시스템의 파일에 대응할 수 있지만 반드시 그런 것은 아니다. 프로그램은 다른 프로그램이나 데이터를 포함하는 파일의 일부(예: 마크업 언어 문서에 저장된 하나 이상의 스크립트), 해당 프로그램 전용 단일 파일 또는 여러 조정 파일(예: 하나 이상의 모듈, 하위 프로그램 또는 코드 부분을 저장하는 파일)에 저장할 수 있다. 컴퓨터 프로그램은 하나의 컴퓨터 또는 한 사이트에 있거나 여러 사이트에 분산되어 있고 통신 네트워크로 상호 연결된 여러 컴퓨터에서 실행되도록 분배될 수 있다.Computer programs (also called programs, software, software applications, scripts, or code) can be written in any form of programming language, including compiled or interpreted languages and declarative or procedural languages. may be distributed in any form, including stand-alone programs or modules, components, subroutines, objects, or other units suitable for use in a computing environment. Computer programs can, but not necessarily, correspond to files in a file system. A program is a part of a file containing other programs or data (for example, one or more scripts stored in a markup language document), a single file dedicated to that program, or several control files (for example, one or more modules, subprograms, or parts of code that store file) can be saved. A computer program may be distributed to be executed on one computer or on multiple computers located at one site or distributed over several sites and interconnected by a communication network.
본 명세서에 설명된 프로세스 및 논리 흐름은 입력 데이터에 대해 동작하고 출력을 생성함으로써 동작을 수행하기 위해 하나 이상의 컴퓨터 프로그램을 실행하는 하나 이상의 프로그래밍 가능한 프로세서에 의해 수행될 수 있다. 프로세스 및 논리 흐름 그리고 장치는 또한 FPGA(field programmable gate array) 또는 ASIC(application specific integrated circuit)와 같은 특수 목적 논리 회로에 의해 수행될 수 있고, 구현될 수 있다. The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform actions by operating on input data and generating output. The processes and logic flows and devices may also be performed and implemented by special purpose logic circuits such as field programmable gate arrays (FPGAs) or application specific integrated circuits (ASICs).
컴퓨터 프로그램의 실행에 적합한 프로세서는 예를 들어 범용 및 특수 목적 마이크로프로세서, 및 임의의 종류의 디지털 컴퓨터의 임의의 하나 이상의 프로세서를 포함한다. 일반적으로 프로세서는 읽기 전용 메모리나 랜덤 액세스 메모리 또는 둘 다에서 명령어과 데이터를 수신한다. 컴퓨터의 필수 요소는 명령어에 따라 동작을 수행하기 위한 프로세서와 명령어 및 데이터를 저장하기 위한 하나 이상의 메모리 장치이다. 일반적으로, 컴퓨터는 또한 데이터를 저장하기 위한 하나 이상의 대용량 저장 장치, 예를 들어 자기, 광자기 디스크 또는 광 디스크로부터 데이터를 수신하거나 이들로 데이터를 전송하거나 둘 다 포함하거나 동작 가능하게 연결된다. 그러나 컴퓨터에는 그러한 장치가 필요하지 않는다. 또한 컴퓨터는, 휴대폰, PDA(personal digital assistant), 모바일 오디오 또는 비디오 플레이어, 게임 콘솔, GPS(Global Positioning System) 수신기, 또는 휴대용 저장 장치(예: USB(Universal Serial Bus) 플래시 드라이브) 등과 같은 다른 장치에 임베딩될 수 있다. 컴퓨터 프로그램 명령어(명령어) 및 데이터를 저장하기에 적합한 장치는 모든 형태의 비휘발성 메모리, 매체 및 메모리 장치를 포함하며, 예를 들어 EPROM, EEPROM 및 플래시 메모리 장치와 같은 반도체 메모리 장치; 자기 디스크, 예를 들어 내부 하드 디스크 또는 이동식 디스크; 자기 광 디스크; 그리고 CD ROM 및 DVD-ROM 디스크를 포함할 수 있다. 프로세서와 메모리는 특수 목적 논리 회로에 의해 보완되거나 통합될 수 있다. Processors suitable for the execution of computer programs include, by way of example, general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Typically, processors receive instructions and data from either read-only memory or random-access memory, or both. The essential elements of a computer are a processor for performing operations according to instructions and one or more memory devices for storing instructions and data. Generally, a computer also includes or is operatively connected to receive data from or transmit data to or both from or to one or more mass storage devices for storing data, such as magnetic, magneto-optical or optical disks. However, computers do not need such a device. A computer may also include other devices, such as a mobile phone, personal digital assistant (PDA), mobile audio or video player, game console, Global Positioning System (GPS) receiver, or portable storage device (such as a Universal Serial Bus (USB) flash drive). can be embedded in Devices suitable for storing computer program instructions (instructions) and data include all forms of non-volatile memory, media and memory devices, including, for example, semiconductor memory devices such as EPROM, EEPROM and flash memory devices; magnetic disks such as internal hard disks or removable disks; magnetic optical disk; And may include CD ROM and DVD-ROM disks. The processor and memory may be complemented or integrated by special purpose logic circuitry.
사용자와의 상호작용을 제공하기 위해, 본 명세서에 기술된 요지의 실시예는 사용자에게 정보를 표시하기 위한 디스플레이 장치, 예를 들어, CRT(cathode ray tube) 또는 LCD(liquid crystal display) 모니터 및 키보드 및 포인팅 장치, 예를 들어, 마우스 또는 트랙볼을 갖는 컴퓨터에서 구현될 수 있으며, 이를 통해 사용자는 컴퓨터에 입력을 제공할 수 있다. 다른 종류의 장치도 사용자와의 상호 작용을 제공하는 데 사용할 수 있다. 예를 들어, 사용자에게 제공되는 피드백은 시각적 피드백, 청각적 피드백 또는 촉각적 피드백과 같은 임의의 형태의 감각적 피드백일 수 있고, 그리고 사용자로부터의 입력은 음향, 음성 또는 촉각 입력을 포함한 모든 형태로 수신될 수 있다. 또한 컴퓨터는 사용자가 사용하는 장치로 문서를 보내고 문서를 수신하여 사용자와 상호 작용할 수 있다. 예를 들어 웹 브라우저에서 수신된 요청에 대한 응답으로 사용자 클라이언트 장치의 웹 브라우저에 웹 페이지를 전송한다. To provide interaction with a user, embodiments of the subject matter described herein may include a display device for displaying information to a user, such as a cathode ray tube (CRT) or liquid crystal display (LCD) monitor and keyboard. and a pointing device, such as a mouse or trackball, through which a user may provide input to the computer. Other types of devices can also be used to provide interaction with the user. For example, the feedback provided to the user can be any form of sensory feedback, such as visual feedback, auditory feedback, or tactile feedback, and input from the user is received in any form, including acoustic, audio, or tactile input. It can be. The computer may also interact with the user by sending documents to and receiving documents from the device used by the user. For example, a web page is sent to a web browser of a user client device in response to a request received from the web browser.
본 명세서에 기술된 요지의 실시예는 백엔드 컴포넌트(예를 들어 데이터 서버)를 포함하는, 미들웨어 컴포넌트(예: 애플리케이션 서버)를 포함하는, 프론트 엔드 컴포넌트(예를 들어 그래픽 사용자 인터페이스가 있는 클라이언트 컴퓨터 또는 사용자가 본 명세서에 설명된 요지의 구현과 상호작용할 수 있는 웹 브라우저)를 포함하는, 또는 하나 이상의 백엔드, 미들웨어 또는 프론트엔드 컴포넌트의 조합을 포함하는 컴퓨팅 시스템에서 구현될 수 있다. 시스템의 컴포넌트는 통신 네트워크와 같은 디지털 데이터 통신의 모든 형태 또는 매체에 의해 상호 연결될 수 있다. 통신 네트워크의 예는, 근거리 통신망("LAN") 및 광역 네트워크("WAN"), 인터-네트워크(예: 인터넷) 및 P2P 네트워크(예: Ad Hoc peer-to-peer 네트워크)를 포함할 수 있다. Embodiments of the subject matter described herein may include front-end components (eg, a client computer with a graphical user interface or a graphical user interface), including middleware components (eg, application servers), including back-end components (eg, data servers). a web browser through which a user can interact with an implementation of the subject matter described herein), or a computing system that includes a combination of one or more backend, middleware, or frontend components. Components of the system may be interconnected by any form or medium of digital data communication, such as a communication network. Examples of communication networks may include local area networks ("LAN") and wide area networks ("WAN"), inter-networks (eg, the Internet), and peer-to-peer networks (eg, Ad Hoc peer-to-peer networks). .
데이터 처리 시스템(105)과 같은 컴퓨팅 시스템은 클라이언트 및 서버를 포함할 수 있다. 예를 들어, 데이터 처리 시스템(105)은 하나 이상의 데이터 센터 또는 서버 팜에 하나 이상의 서버를 포함할 수 있다. 클라이언트와 서버는 일반적으로 서로 멀리 떨어져 있으며 일반적으로 통신 네트워크를 통해 상호 작용한다. 클라이언트와 서버의 관계는 각각의 컴퓨터에서 실행되고 서로 클라이언트-서버 관계를 갖는 컴퓨터 프로그램 덕분에 발생한다. 일부 구현에서, 서버는 데이터(예를 들어, HTML 페이지)를 클라이언트 장치로 전송한다(예: 클라이언트 장치와 상호 작용하는 사용자에게 데이터를 표시하고 사용자 입력을 수신하기 위한 목적). 클라이언트 장치에서 생성된 데이터(예: 사용자 상호 작용의 결과)는 서버에서 클라이언트 장치로부터 수신될 수 있다. A computing system such as data processing system 105 may include a client and a server. For example, data processing system 105 may include one or more servers in one or more data centers or server farms. Clients and servers are usually remote from each other and usually interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other. In some implementations, the server transmits data (eg, HTML pages) to the client device (eg, for purposes of displaying data and receiving user input to a user interacting with the client device). Data generated at the client device (eg, results of user interactions) may be received from the client device at the server.
본 명세서는 많은 특정 구현 세부사항을 포함하지만, 이는 임의의 발명의 범위 또는 청구될 수 있는 것에 대한 제한으로 해석되어서는 안 되며, 오히려 특정 발명의 특정 실시예에 특정한 특징의 설명으로 해석되어서는 안 된다. 별도의 실시예와 관련하여 본 명세서에 설명된 특정 특징은 단일 실시예에서 조합하여 구현될 수도 있다. 역으로, 단일 실시예의 컨텍스트에서 설명된 다양한 특징은 또한 개별적으로 또는 임의의 적절한 하위 조합으로 다중 실시예에서 구현될 수 있다. 더욱이, 특징들이 특정 조합으로 작용하는 것으로 위에서 설명될 수 있고 심지어 초기에 그렇게 청구될 수도 있지만, 청구된 조합의 하나 이상의 특징이 어떤 경우에는 조합에서 제거될 수 있으며, 청구된 조합은 하위 조합 또는 하위 조합의 변형에 관한 것일 수 있다.Although this specification contains many specific implementation details, this should not be construed as a limitation on the scope of any invention or what may be claimed, but rather as a description of features specific to a particular embodiment of a particular invention. . Certain features that are described in this specification in the context of separate embodiments may also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented on multiple embodiments separately or in any suitable subcombination. Moreover, while features may be described above as acting in particular combinations and may even be initially claimed as such, one or more features of a claimed combination may in some cases be removed from the combination, and the claimed combination may be a subcombination or subcombination. It may be about the transformation of
유사하게, 동작이 도면에 특정 순서로 도시되어 있지만, 이는 바람직한 결과를 달성하기 위해 그러한 동작이 도시된 특정 순서로 또는 순차적인 순서로 수행되거나 도시된 모든 동작이 수행될 것을 요구하는 것으로 이해되어서는 안 된다. 어떤 경우에는 청구범위에 인용된 액션이 다른 순서로 수행될 수 있으며 여전히 바람직한 결과를 얻을 수 있다. 또한, 첨부된 도면에 도시된 프로세스는 바람직한 결과를 달성하기 위해 도시된 특정 순서 또는 순차적인 순서를 반드시 필요로 하는 것은 아니다. Similarly, while actions are depicted in a particular order in the drawings, this should not be construed as requiring that such actions be performed in the particular order shown or in a sequential order, or that all actions shown be performed in order to achieve a desired result. Can not be done. In some cases, the actions recited in the claims can be performed in a different order and still produce desirable results. In addition, the processes depicted in the accompanying drawings do not necessarily require the specific order shown or sequential order to achieve desirable results.
특정 상황에서는 멀티태스킹과 병렬 처리가 유리할 수 있다. 더욱이, 위에서 설명된 구현에서 다양한 시스템 컴포넌트의 분리가 모든 구현에서 그러한 분리를 요구하는 것으로 이해되어서는 안되며, 설명된 프로그램 컴포넌트 및 시스템은 일반적으로 단일 소프트웨어 제품에 함께 통합되거나 여러 소프트웨어 제품에 패키지될 수 있음을 이해해야 한다. 예를 들어, 데이터 처리 시스템(105)은 단일 모듈, 하나 이상의 처리 모듈을 갖는 논리 장치, 하나 이상의 서버, 또는 클라우드 컴퓨팅 환경의 일부일 수 있다. Multitasking and parallel processing can be advantageous in certain circumstances. Moreover, the separation of various system components in the implementations described above should not be understood as requiring such separation in all implementations, and the described program components and systems may generally be integrated together in a single software product or packaged in multiple software products. You have to understand that there are For example, data processing system 105 may be a single module, a logical unit having one or more processing modules, one or more servers, or part of a cloud computing environment.
이제 일부 예시적인 구현 및 구현에 대해 설명했지만, 전술한 내용은 예시적인 것이며 제한적이지 않음이 명백하다. 특히, 여기에 제시된 많은 예가 방법 동작 또는 시스템 요소의 특정 조합을 포함하지만, 이러한 동작 및 이러한 요소는 동일한 목적을 달성하기 위해 다른 방식으로 결합될 수 있다. 한 구현과 관련해서만 설명된 행위, 요소 및 기능은 다른 구현에서 유사한 역할에서 제외되도록 의도되지 않았다. Having now described some example implementations and implementations, it is clear that the foregoing is illustrative and not limiting. In particular, while many of the examples presented herein include specific combinations of method acts or system elements, these acts and these elements may be combined in other ways to achieve the same purpose. Behaviors, elements and functions described only in connection with one implementation are not intended to be excluded from a similar role in other implementations.
여기에 사용된 어구 및 용어는 설명을 위한 것이며 제한하는 것으로 간주되어서는 안 된다. 본 명세서에서 "포함하는" "갖는" "~로 특징으로 하는" 및 그 변형의 사용은 그 이후에 나열된 항목, 그 등가물, 추가 항목뿐만 아니라 그 이후에 나열된 항목으로 구성된 대체 구현을 독점적으로 포함하는 것을 의미한다. 일 구현에서, 여기에 설명된 시스템 및 방법은 설명된 요소, 행위 또는 컴포넌트 중 하나 이상, 또는 모두의 각각의 조합으로 구성된다. The phraseology and terminology used herein is for descriptive purposes and should not be regarded as limiting. Use of "comprising," "having," "characterized by" and variations thereof herein includes exclusively any hereinafter enumerated items, their equivalents, and additional items, as well as alternative implementations consisting of the hereinafter enumerated items. means that In one implementation, the systems and methods described herein are comprised of respective combinations of one or more, or all, of the described elements, acts, or components.
본 명세서에서 단수로 언급된 시스템 및 방법의 구현 또는 요소 또는 행위에 대한 임의의 참조는 또한 복수의 이러한 요소를 포함하는 구현을 포함할 수 있고, 임의의 구현 또는 요소 또는 행위에 대한 복수의 참조는 또한 단일 요소만을 포함하는 구현을 포함할 수 있다. 단수 또는 복수 형태의 참조는 현재 개시된 시스템 또는 방법, 그 컴포넌트, 행위 또는 요소를 단일 또는 복수 구성으로 제한하도록 의도되지 않는다. 임의의 정보, 행위 또는 요소를 기반으로 하는 임의의 행위 또는 요소에 대한 참조는 행위 또는 요소가 정보, 행위 또는 요소에 적어도 부분적으로 기초하는 구현을 포함할 수 있다. Any reference to implementations or elements or acts of systems and methods mentioned in the singular herein may also include implementations that include a plurality of such elements, and plural references to any implementations or elements or acts may also include implementations that include a plurality of such elements. May contain implementations that contain only a single element. References in singular or plural form are not intended to limit the presently disclosed system or method, its components, acts or elements to a single or plural configuration. A reference to any act or element that is based on any information, act, or element may include implementations in which the act or element is based at least in part on the information, act, or element.
여기에 개시된 임의의 구현은 임의의 다른 구현과 결합될 수 있으며, "일 구현", "일부 구현", "대체 구현", "다양한 구현", "하나의 구현" 등에 대한 참조는 반드시 상호 배타적이지 않으며, 구현과 관련하여 설명된 특정 특징, 구조 또는 특성이 적어도 하나의 구현에 포함될 수 있음을 나타내기 위한 것이다. 본 명세서에 사용된 그러한 용어는 반드시 모두 동일한 구현을 지칭하는 것은 아니다. 임의의 구현은 여기에 개시된 양태 및 구현과 일치하는 임의의 방식으로 포괄적으로 또는 배타적으로 임의의 다른 구현과 결합될 수 있다. Any implementation disclosed herein may be combined with any other implementation, and references to “one implementation,” “some implementations,” “alternative implementations,” “various implementations,” “an implementation,” etc. are not necessarily mutually exclusive. It is intended to indicate that a particular feature, structure, or characteristic described in connection with an implementation may be included in at least one implementation. As used herein, such terms are not necessarily all referring to the same implementation. Any implementation may be combined with any other implementation, either inclusively or exclusively, in any manner consistent with the aspects and implementations disclosed herein.
"또는"에 대한 언급은 "또는"을 사용하여 설명된 임의의 용어가 단일, 하나 이상 및 설명된 모든 용어 중 임의의 것을 나타낼 수 있도록 포괄적인 것으로 해석될 수 있다. References to “or” may be construed as inclusive such that any term described using “or” may refer to a single, one or more, and any of all terms described.
도면의 기술적 특징, 상세한 설명 또는 청구범위 뒤에 참조 부호가 있는 경우 도면, 상세한 설명 및 청구범위의 명료성을 높이기 위한 목적으로만 참조 부호가 포함되었다. 따라서 참조 기호나 참조 부호의 부재는 청구 범위 요소의 범위를 제한하는 효과가 없다. Where reference numerals appear after the technical features of the drawings, the detailed description, or the claims, reference numerals are included only for the purpose of improving the clarity of the drawings, the detailed description, and the claims. Therefore, reference signs or the absence of reference signs have no limiting effect on the scope of a claim element.
여기에 설명된 시스템 및 방법은 그 특성을 벗어나지 않고 다른 특정 형태로 구현될 수 있다. 여기에 제공된 예는 정보 자원의 콘텐츠 표시를 제어하는 것과 관련되지만, 여기에 설명된 시스템 및 방법은 다른 환경에 적용되는 것을 포함할 수 있다. 전술한 구현은 설명된 시스템 및 방법을 제한하는 것이 아니라 설명을 위한 것이다. 따라서, 본 명세서에 기재된 시스템 및 방법의 범위는 전술한 설명보다는 첨부된 청구범위에 의해 표시되고, 청구범위의 등가의 의미 및 범위 내에 있는 변경이 여기에 포함된다. The systems and methods described herein may be embodied in other specific forms without departing from their characteristics. Although the examples provided herein relate to controlling the presentation of the content of information resources, the systems and methods described herein may include applications in other environments. The foregoing implementations are illustrative rather than limiting to the described systems and methods. Accordingly, the scope of the systems and methods described herein is indicated by the appended claims rather than the foregoing description, and modifications within the meaning and range of equivalency of the claims are hereby incorporated.
위에서 설명된 시스템 및 방법은 하나 이상의 제조 물품, 예를 들어, 컴퓨터 판독 가능 매체에 기록된 하나 이상의 컴퓨터 프로그램의 명령으로서 제공될 수 있다는 것을 이해해야 한다. 제조 물품은 플로피 디스크, 하드 디스크, CD-ROM, 플래시 메모리 카드, PROM, RAM, ROM 또는 자기 테이프일 수 있다. 일반적으로 컴퓨터 프로그램은 LISP, Perl, Python, C, C++, C#, PROLOG와 같은 프로그래밍 언어 또는 JAVA와 같은 바이트 코드 언어로 구현될 수 있다. 소프트웨어 프로그램은 하나 이상의 제품에 객체 코드로 저장될 수 있다. It should be understood that the systems and methods described above may be provided as instructions of one or more computer programs recorded on one or more articles of manufacture, eg, computer readable media. The article of manufacture may be a floppy disk, hard disk, CD-ROM, flash memory card, PROM, RAM, ROM or magnetic tape. In general, computer programs may be implemented in programming languages such as LISP, Perl, Python, C, C++, C#, PROLOG, or bytecode languages such as JAVA. A software program may be stored as object code in one or more products.
방법 및 시스템의 특정 실시예를 설명했지만, 본 발명의 개념을 포함하는 다른 실시예가 사용될 수 있다는 것이 당업자에게 명백할 것이다. 따라서, 본 개시는 특정 실시예에 제한되어서는 안 되며, 오히려 다음 청구범위의 사상 및 범위에 의해서만 제한되어야 한다.Although specific embodiments of the method and system have been described, it will be apparent to those skilled in the art that other embodiments incorporating the inventive concept may be used. Accordingly, the present disclosure should not be limited to the specific embodiments, but rather only by the spirit and scope of the following claims.
Claims (20)
하나 이상의 프로세서 및 메모리를 포함하는 데이터 처리 시스템에 의해, 상기 복수의 제공자들의 제공자와 복수의 사용자들 사이의 상호작용을 각각 식별하는 레코드의 데이터 세트를 데이터베이스에 유지하는 단계;
상기 데이터 처리 시스템에 의해, 복수의 벡터 데이터 구조들을 초기화하는 단계 -상기 복수의 벡터 데이터 구조들의 각각의 벡터 데이터 구조는 복수의 빈도들의 각각의 빈도에 대응함-;
상기 데이터 처리 시스템에 의해, 상기 복수의 사용자들 중 각각의 사용자에 대해, 상기 레코드의 데이터 세트에 기초하여 상기 사용자와 상기 제공자 간의 상호작용의 빈도 데이터를 결정하는 단계 -사용자의 빈도 데이터는 타겟 상호작용 유형을 갖는 사용자와 제공자 간의 상호작용의 수를 나타냄-;
상기 데이터 처리 시스템에 의해, 상기 복수의 사용자들의 각 사용자의 빈도 데이터에 기초하여 상기 복수의 벡터 데이터 구조들을 업데이트하는 단계 -상기 복수의 벡터 데이터 구조들의 제1 벡터 데이터 구조는 상기 복수의 빈도들의 제1 빈도 값에 대응하고 그리고 상기 복수의 벡터 데이터 구조들이 차등적으로 프라이빗(private)되도록 상기 제1 빈도 값과 일치하는 상호작용의 수를 나타내는 빈도 데이터를 갖는 상기 복수의 사용자들 중 사용자의 식별자를 인코딩하도록 업데이트됨-; 그리고
상기 데이터 처리 시스템에 의해, 상기 복수의 제공자들에 걸친 상기 레코드의 데이터 세트의 중복 제거를 위해 분석 서버에 상기 복수의 벡터 데이터 구조들을 전송하는 단계를 포함하는 것을 특징으로 하는 복수의 제공자들에 걸쳐 데이터 세트들을 중복 제거하기 위한 데이터 구조를 생성하는 방법.A method of creating a data structure for deduplicating data sets across multiple providers, comprising:
maintaining, by a data processing system comprising one or more processors and memory, in a database a data set of records each identifying an interaction between a provider of the plurality of providers and a plurality of users;
initializing, by the data processing system, a plurality of vector data structures, each vector data structure of the plurality of vector data structures corresponding to a respective frequency of a plurality of frequencies;
determining, by the data processing system, for each user of the plurality of users, frequency data of interactions between the user and the provider based on the data set of records; Indicates the number of interactions between users and providers with action types;
updating, by the data processing system, the plurality of vector data structures based on frequency data of each user of the plurality of users, a first vector data structure of the plurality of vector data structures being a first vector data structure of the plurality of frequencies; An identifier of a user of the plurality of users corresponding to 1 frequency value and having frequency data representing the number of interactions matching the first frequency value such that the plurality of vector data structures are differentially private. Updated to encode-; And
sending, by the data processing system, the plurality of vector data structures to an analytics server for deduplication of the data set of records across the plurality of providers. How to create a data structure for deduplicating data sets.
상기 복수의 벡터 데이터 구조들을 업데이트하는 단계는 상기 사용자의 식별자를 인코딩하도록 상기 복수의 벡터 데이터 구조들에서 적어도 하나의 카운터를 업데이트하는 단계를 포함하는 것을 특징으로 하는 복수의 제공자들에 걸쳐 데이터 세트들을 중복 제거하기 위한 데이터 구조를 생성하는 방법.2. The method of claim 1, wherein each of the plurality of vector data structures defines coordinates for a plurality of counters;
wherein updating the plurality of vector data structures comprises updating at least one counter in the plurality of vector data structures to encode the identifier of the user. How to create a data structure for deduplication.
하나 이상의 프로세서 및 하나 이상의 메모리를 포함하는 데이터 처리 시스템에 의해, 복수의 제공자들 중 제1 제공자로부터 둘 이상의 벡터 데이터 구조들의 제1 세트를 수신하는 단계 -상기 제1 세트의 둘 이상의 벡터 데이터 구조들 각각은, 차등 프라이버시로, 상기 제1 세트의 둘 이상의 벡터 데이터 구조들 각각의 개별 빈도와 일치하는, 타겟 상호작용 유형을 갖는 상기 제1 제공자와의 상호작용의 수와 연관된 사용자 식별자들을 인코딩함-;
상기 데이터 처리 시스템에 의해, 복수의 제공자들 중 제2 제공자로부터 둘 이상의 벡터 데이터 구조들의 제2 세트를 수신하는 단계 -상기 제2 세트의 둘 이상의 벡터 데이터 구조들 각각은, 차등 프라이버시로, 상기 제2 세트의 둘 이상의 벡터 데이터 구조들 각각의 개별 빈도와 일치하는, 상기 타겟 상호작용 유형을 갖는 상기 제2 제공자와의 상호작용의 수와 연관된 사용자 식별자들을 인코딩함-; 그리고
상기 데이터 처리 시스템에 의해, 상기 둘 이상의 벡터 데이터 구조들의 제1 세트와 상기 둘 이상의 벡터 데이터 구조들의 제2 세트를 복수의 빈도들 각각에 대해 제1 제공자와 제2 제공자 모두에 걸쳐 타겟 상호작용 유형을 갖는 사용자 상호작용의 총 빈도를 정의하는 중복 제거된 빈도 분포로 결합하는 단계를 포함하는 것을 특징으로 하는 복수의 제공자들과 사용자 상호작용의 빈도들에 대응하는 데이터 세트들을 중복 제거하는 방법.A method of deduplicating data sets corresponding to frequencies of user interactions with a plurality of providers, comprising:
receiving, by a data processing system comprising at least one processor and at least one memory, a first set of two or more vector data structures from a first provider of a plurality of providers; the first set of two or more vector data structures each encoding user identifiers associated with a number of interactions with the first provider with a target interaction type matching a respective frequency of each of the two or more vector data structures of the first set, with Differential Privacy; ;
receiving, by the data processing system, a second set of two or more vector data structures from a second provider of a plurality of providers, each of the two or more vector data structures of the second set, with differential privacy; encode user identifiers associated with a number of interactions with the second provider with the target interaction type that match a respective frequency of each of two sets of two or more vector data structures; And
By the data processing system, the first set of two or more vector data structures and the second set of two or more vector data structures are targeted interaction types across both first and second providers for each of a plurality of frequencies. A method of deduplicating data sets corresponding to frequencies of user interaction with a plurality of providers, comprising combining into a deduplicated frequency distribution defining a total frequency of user interaction with .
상기 데이터 처리 시스템에 의해, 중복 제거된 빈도 분포의 표현을 포함하는 그래픽 사용자 인터페이스 데이터를 생성하는 단계를 더 포함하는 것을 특징으로 하는 복수의 제공자들과 사용자 상호작용의 빈도들에 대응하는 데이터 세트들을 중복 제거하는 방법.The method of claim 7, wherein the method,
generating, by the data processing system, graphical user interface data comprising a representation of a deduplicated frequency distribution; How to remove duplicates.
상기 데이터 처리 시스템에 의해, 임계 빈도를 상기 복수의 제공자들에게 전송하는 단계를 더 포함하고, 상기 복수의 빈도들은 상기 임계 빈도에 의해 정의되는 것을 특징으로 하는 복수의 제공자들과 사용자 상호작용의 빈도들에 대응하는 데이터 세트들을 중복 제거하는 방법.The method of claim 7, wherein the method,
a frequency of user interaction with the plurality of providers, further comprising transmitting, by the data processing system, a threshold frequency to the plurality of providers, wherein the plurality of frequencies are defined by the threshold frequency; A method for deduplicating data sets corresponding to .
상기 둘 이상의 벡터 데이터 구조들의 제1 세트 및 상기 둘 이상의 벡터 데이터 구조들의 제2 세트를 상기 중복 제거된 빈도 분포로 결합하는 단계는,
상기 데이터 처리 시스템에 의해, 상기 둘 이상의 벡터 데이터 구조들의 제1 세트 및 상기 둘 이상의 벡터 데이터 구조들의 제2 세트를 둘 이상의 벡터 데이터 구조들의 제1 결합 세트로 결합하는 단계;
상기 데이터 처리 시스템에 의해, 상기 복수의 제공자들 중 제3 제공자로부터 둘 이상의 벡터 데이터 구조들의 제3 세트를 수신하는 단계; 그리고
상기 둘 이상의 벡터 데이터 구조들의 제1 세트 및 상기 둘 이상의 벡터 데이터 구조들의 제2 세트를 둘 이상의 벡터 데이터 구조들의 제1 결합 세트로 결합하는 것에 응답하여, 상기 데이터 처리 시스템에 의해, 둘 이상의 벡터 데이터 구조들의 제1 결합 세트와 제3 제공자로부터의 둘 이상의 벡터 데이터 구조들의 제3 세트를 둘 이상의 벡터 데이터 구조들의 제2 결합 세트로 결합하는 단계를 포함하는 것을 특징으로 하는 복수의 제공자들과 사용자 상호작용의 빈도들에 대응하는 데이터 세트들을 중복 제거하는 방법. According to claim 7,
Combining the first set of two or more vector data structures and the second set of two or more vector data structures into the deduplicated frequency distribution comprises:
combining, by the data processing system, the first set of two or more vector data structures and the second set of two or more vector data structures into a first combined set of two or more vector data structures;
receiving, by the data processing system, a third set of two or more vector data structures from a third provider of the plurality of providers; And
In response to combining the first set of two or more vector data structures and the second set of two or more vector data structures into a first combined set of two or more vector data structures, by the data processing system, the two or more vector data combining a first combined set of structures and a third set of two or more vector data structures from a third provider into a second combined set of two or more vector data structures; A method of deduplicating data sets corresponding to frequencies of actions.
상기 둘 이상의 벡터 데이터 구조들의 제1 세트 및 상기 둘 이상의 벡터 데이터 구조들의 제2 세트를 상기 중복 제거된 빈도 분포로 결합하는 단계는,
상기 둘 이상의 벡터 데이터 구조들의 제1 세트의 제1 벡터 데이터 구조와 상기 둘 이상의 벡터 데이터 구조들의 제2 세트의 제2 벡터 데이터 구조 간의 인터섹션(intersection)을 결정하는 단계;
상기 제1 벡터 데이터 구조와 상기 제2 벡터 데이터 구조의 상기 인터섹션에 인코딩된 사용자 수를 결정하는 단계; 그리고
상기 결정된 사용자 수를 기반으로 상기 중복 제거된 빈도 분포를 업데이트하는 단계를 포함하는 것을 특징으로 하는 복수의 제공자들과 사용자 상호작용의 빈도들에 대응하는 데이터 세트들을 중복 제거하는 방법. According to claim 7,
Combining the first set of two or more vector data structures and the second set of two or more vector data structures into the deduplicated frequency distribution comprises:
determining an intersection between a first vector data structure of the first set of two or more vector data structures and a second vector data structure of the second set of two or more vector data structures;
determining the number of users encoded in the intersection of the first vector data structure and the second vector data structure; And
and updating the deduplicated frequency distribution based on the determined number of users.
상기 복수의 제공자들과 연관된 복수의 서버들과 통신하도록 구성된 네트워크 인터페이스; 그리고
상기 네트워크 인터페이스 및 메모리에 연결된 하나 이상의 프로세서를 포함하며, 상기 메모리는 상기 하나 이상의 프로세서에 의해 실행될 때 상기 하나 이상의 프로세서로 하여금 동작들을 수행하게 하는 명령어를 저장하며; 상기 동작들은,
상기 네트워크 인터페이스를 통해, 상기 복수의 제공자들 중 제1 제공자로부터 차등적 프라이빗 스케치(private sketche)들의 제1 세트를 수신하는 동작 -상기 제1 세트의 차등적 프라이빗 스케치들 각각은 차등 프라이버시로, 상기 제1 세트의 차등적 프라이빗 스케치들 각각의 개별 빈도와 일치하는, 타겟 상호작용 유형을 갖는 상기 제1 제공자와의 상호작용의 수와 연관된 사용자 식별자들을 인코딩함-;
상기 네트워크 인터페이스를 통해, 상기 복수의 제공자들 중 제2 제공자로부터 차등적 프라이빗 스케치들의 제2 세트를 수신하는 동작 -상기 제2 세트의 차등적 프라이빗 스케치들 각각은 차등 프라이버시로, 상기 제2 세트의 차등적 프라이빗 스케치들 각각의 개별 빈도와 일치하는, 타겟 상호작용 유형을 갖는 상기 제2 제공자와의 상호작용의 수와 연관된 사용자 식별자들을 인코딩함-;
상기 차등적 프라이빗 스케치들의 제1 세트와 상기 차등적 프라이빗 스케치들의 제2 세트를 사용하여 결합된 분포를 생성하는 동작 -상기 결합된 분포는 상기 차등적 프라이빗 스케치들의 제1 세트와 상기 차등적 프라이빗 스케치들의 제2 세트로 표시되는 상기 데이터 세트들의 중복을 제거하고 그리고 복수의 빈도들 각각에 대해 상기 제1 제공자와 상기 제2 제공자 모두에 걸쳐 상기 타겟 상호작용 유형을 갖는 사용자 상호작용의 총 빈도를 정의함-;
데이터베이스에 상기 결합된 분포를 저장하는 동작을 포함하는 것을 특징으로 하는 복수의 제공자들로부터 수신된 데이터 세트들을 줄이기 위한 시스템. A system for reducing data sets received from multiple providers, comprising:
a network interface configured to communicate with a plurality of servers associated with the plurality of providers; And
one or more processors coupled to the network interface and memory, the memory storing instructions that when executed by the one or more processors cause the one or more processors to perform operations; These actions are
receiving, via the network interface, a first set of differential private sketches from a first provider of the plurality of providers, each of the differential private sketches of the first set having differential privacy; encode user identifiers associated with a number of interactions with the first provider having a target interaction type that match a respective frequency of each of a first set of differential private sketches;
receiving, via the network interface, a second set of differential private sketches from a second provider of the plurality of providers, each of the differential private sketches of the second set having differential privacy; encode user identifiers associated with a number of interactions with the second provider with a target interaction type that match the respective frequency of each of the differential private sketches;
generating a combined distribution using the first set of differential private sketches and the second set of differential private sketches, the combined distribution comprising the first set of differential private sketches and the differential private sketch deduplicating the data sets represented by a second set of frequencies and defining for each of a plurality of frequencies a total frequency of user interactions with the target interaction type across both the first provider and the second provider box-;
and storing the combined distribution in a database.
상기 차등적 프라이빗 스케치들의 제1 세트와 상기 차등적 프라이빗 스케치들의 제2 세트를 차등적 프라이빗 스케치들의 병합된 세트로 결합하는 동작; 그리고
상기 데이터베이스에, 상기 차등적 프라이빗 스케치들의 병합된 세트를 저장하는 동작을 더 포함하는 것을 특징으로 하는 복수의 제공자들로부터 수신된 데이터 세트들을 줄이기 위한 시스템. The method of claim 16, wherein the operations,
combining the first set of differential private sketches and the second set of differential private sketches into a merged set of differential private sketches; And
and storing the merged set of differential private sketches in the database.
상기 복수의 제공자들 중 제3 제공자로부터 차등적으로 프라이빗 스케치들의 제3 세트를 수신하는 동작;
상기 차등적 프라이빗 스케치들의 병합된 세트와 상기 차등적 프라이빗 스케치들의 제3 세트를 결합하여 차등적 프라이빗 스케치들의 새로 병합된 세트(new merged set)를 생성하는 동작; 그리고
상기 차등적 프라이빗 스케치들의 새로 병합된 세트를 상기 데이터베이스에 저장하는 동작을 더 포함하는 것을 특징으로 하는 복수의 제공자들로부터 수신된 데이터 세트들을 줄이기 위한 시스템. The method of claim 17, wherein the operations,
differentially receiving a third set of private sketches from a third provider among the plurality of providers;
combining the merged set of differential private sketches and the third set of differential private sketches to create a new merged set of differential private sketches; And
and storing the newly merged set of differential private sketches in the database.
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
PCT/US2020/039209 WO2021262155A1 (en) | 2020-06-23 | 2020-06-23 | Differentially private frequency deduplication |
USPCT/US2020/039209 | 2020-06-23 | ||
PCT/US2021/038716 WO2021262868A1 (en) | 2020-06-23 | 2021-06-23 | Differentially private frequency deduplication |
Publications (1)
Publication Number | Publication Date |
---|---|
KR20230010695A true KR20230010695A (en) | 2023-01-19 |
Family
ID=71662305
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
KR1020227043543A KR20230010695A (en) | 2020-06-23 | 2021-06-23 | Differentiated private frequency deduplication |
Country Status (6)
Country | Link |
---|---|
US (1) | US20230144763A1 (en) |
EP (1) | EP4104086A1 (en) |
JP (1) | JP7439305B2 (en) |
KR (1) | KR20230010695A (en) |
CN (1) | CN115699001A (en) |
WO (2) | WO2021262155A1 (en) |
Families Citing this family (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20220156783A1 (en) * | 2020-11-13 | 2022-05-19 | The Nielsen Company (Us), Llc | Methods and apparatus to estimate unique audience sizes across multiple intersecting platforms |
US20230244669A1 (en) * | 2022-01-28 | 2023-08-03 | Seagate Technology Llc | Identifying hot items in a distributed storage system |
US20240005022A1 (en) * | 2022-06-30 | 2024-01-04 | Amazon Technologies, Inc. | Privacy-preserving dataset sketches that can be joined non-interactively |
Family Cites Families (8)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8375030B2 (en) | 2010-12-03 | 2013-02-12 | Mitsubishi Electric Research Laboratories, Inc. | Differentially private aggregate classifier for multiple databases |
US8978158B2 (en) | 2012-04-27 | 2015-03-10 | Google Inc. | Privacy management across multiple devices |
US9678976B2 (en) * | 2014-07-21 | 2017-06-13 | Red Hat, Inc. | Distributed deduplication using locality sensitive hashing |
US10776511B2 (en) * | 2017-06-04 | 2020-09-15 | Apple Inc. | User experience using privatized crowdsourced data |
US10726139B2 (en) | 2017-06-04 | 2020-07-28 | Apple Inc. | Differential privacy using a multibit histogram |
US10102233B1 (en) | 2018-04-30 | 2018-10-16 | Merck Sharp & Dohme Corp. | Indexing for database privacy and anonymization |
CN108900619B (en) * | 2018-07-06 | 2022-01-11 | 创新先进技术有限公司 | Independent visitor counting method and device |
JP7042723B2 (en) | 2018-09-20 | 2022-03-28 | ヤフー株式会社 | Information processing equipment, information processing methods, and programs |
-
2020
- 2020-06-23 WO PCT/US2020/039209 patent/WO2021262155A1/en active Application Filing
-
2021
- 2021-06-23 JP JP2022574588A patent/JP7439305B2/en active Active
- 2021-06-23 WO PCT/US2021/038716 patent/WO2021262868A1/en unknown
- 2021-06-23 KR KR1020227043543A patent/KR20230010695A/en unknown
- 2021-06-23 US US17/911,881 patent/US20230144763A1/en active Pending
- 2021-06-23 EP EP21742635.2A patent/EP4104086A1/en active Pending
- 2021-06-23 CN CN202180037129.8A patent/CN115699001A/en active Pending
Also Published As
Publication number | Publication date |
---|---|
JP2023528481A (en) | 2023-07-04 |
WO2021262868A1 (en) | 2021-12-30 |
CN115699001A (en) | 2023-02-03 |
WO2021262155A1 (en) | 2021-12-30 |
EP4104086A1 (en) | 2022-12-21 |
JP7439305B2 (en) | 2024-02-27 |
US20230144763A1 (en) | 2023-05-11 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
AU2019200530B2 (en) | Identifying network security risks | |
KR20230010695A (en) | Differentiated private frequency deduplication | |
US11416456B2 (en) | Method, apparatus, and computer program product for data quality analysis | |
US11790116B2 (en) | Systems and methods for privacy preserving determination of intersections of sets of user identifiers | |
CN111046237B (en) | User behavior data processing method and device, electronic equipment and readable medium | |
CN110555172B (en) | User relationship mining method and device, electronic equipment and storage medium | |
CN111427971B (en) | Business modeling method, device, system and medium for computer system | |
US20220084074A1 (en) | Privacy Preserving Ad Personalization | |
CN111814065B (en) | Information propagation path analysis method and device, computer equipment and storage medium | |
WO2020087879A1 (en) | Method, device, and system for protecting private information | |
CN112508075A (en) | Horizontal federation-based DBSCAN clustering method and related equipment thereof | |
US20170272362A1 (en) | Data communication systems and methods of operating data communication systems | |
Wang et al. | Asymptotic dependence of in-and out-degrees in a preferential attachment model with reciprocity | |
CN115968484A (en) | System and method for cross-media reporting by quickly merging data sources | |
US11768752B2 (en) | Optimizing large scale data analysis | |
US20210383016A1 (en) | Systems and methods for obtaining anonymized information derived from data obtained from external data providers | |
JP2022075328A (en) | Data management method, computer program, and data management system | |
US20240163268A1 (en) | Privacy-preserving demand estimation across companies | |
US20210409204A1 (en) | Encryption of protected data for transmission over a web interface | |
CN110020211B (en) | Method and device for evaluating influence of user attributes | |
CN112800033A (en) | Data operation request processing method and device, computer equipment and storage medium |