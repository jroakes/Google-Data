EP3055786A1 - Automatic definition of entity collections - Google Patents
Automatic definition of entity collectionsInfo
- Publication number
- EP3055786A1 EP3055786A1 EP13895222.1A EP13895222A EP3055786A1 EP 3055786 A1 EP3055786 A1 EP 3055786A1 EP 13895222 A EP13895222 A EP 13895222A EP 3055786 A1 EP3055786 A1 EP 3055786A1
- Authority
- EP
- European Patent Office
- Prior art keywords
- collection
- constraint
- candidate
- candidate collection
- constraints
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Withdrawn
Links
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/30—Information retrieval; Database structures therefor; File system structures therefor of unstructured textual data
- G06F16/33—Querying
- G06F16/332—Query formulation
- G06F16/3325—Reformulation based on results of preceding query
- G06F16/3326—Reformulation based on results of preceding query using relevance feedback from the user, e.g. relevance feedback on documents, documents sets, document terms or passages
- G06F16/3328—Reformulation based on results of preceding query using relevance feedback from the user, e.g. relevance feedback on documents, documents sets, document terms or passages using graphical result space presentation or visualisation
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N5/00—Computing arrangements using knowledge-based models
- G06N5/02—Knowledge representation; Symbolic representation
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/901—Indexing; Data structures therefor; Storage structures
- G06F16/9024—Graphs; Linked lists
Definitions
- Graph-based knowledge bases represent factual information about the world.
- entities such as people, places, things, concepts, etc.
- the basic unit of such a data graph can be a triple that includes two nodes, or entities, and an edge.
- the triple is sometimes referred to a subject-predicate-object triple, with one node acting as the subject, the second node acting as the object, and the relationship acting as the predicate.
- a triple may include additional information, such as metadata about the entities and/or the relationship, in addition to identifying the subject, predicate, and object.
- Some implementations enable a system to automatically identify potentially useful entity collections and to automatically assign entities in a large graph to the collections.
- the system may identify potentially useful collections using search records, text-based category assignments, or may form a group of entities identified by a user.
- the system may generate rules for membership in the potentially useful collections, evaluate the rules to identify candidate collections, generate a name (or names) for each of the candidate collections, and rank or score the candidate
- I collections to determine which collections to publish for use with the data graph include a language for defining the rules of membership in candidate and published collections.
- a collection may be defined by expressing the sufficient conditions for membership.
- the conditions may be expressed in conjunctive normal form.
- a condition may represent one constraint or two or more disjunctive constraints.
- a constraint may have one of five formats; Exists, Not Exists, Equals, Not Equals, and a Template format.
- For published collections some implementations may efficiently generate an entity's membership in each of the published collections in a single pass of the entity's neighborhood.
- the efficient generation may include building an index for the published collections. The system may use the index to evaluate paths from the entity to determine which collection conditions are satisfied and generate an indication of membership in the graph.
- One aspect of the disclosure can be embodied in a system that includes at least one processor and one or more memories.
- the one or more memories may store a data graph that includes entities connected by edges and instructions that, when executed by the at least one processor, cause the
- the operations may include determining a first set of entities from the data graph and determining a second set of
- the operations may also include generating candidate collection definitions from combinations of the constraints in the second set, where each candidate collection definition identifies at least one constraint from the second set and no more than the quantity of constraints and determining an information gain for at least some of the candidate collection definitions.
- the operations include storing at least one of the candidate
- collection definitions as a candidate collection in the one or more memories, the candidate collection having an information gain that meets a threshold.
- the system can include one or more of the following features.
- determining the first set of entities may include selecting a category from a crowd-sourced document corpus and determining entities identified by the category.
- determining the first set of entities may include identifying a popular query from search records, converting the popular query to at least one semantic query, and executing the at least one semantic query against the data graph to obtain a query result, wherein the first set of entities is the query result from the data graph.
- Converting the popular query to the at least one semantic query may include converting the popular query to a plurality of semantic queries, running each of the plurality of semantic queries against the data graph, and determining a plurality of sets of entities, a set of the plurality of sets representing entities responsive to one of the semantic queries.
- the instructions may further include instructions that, when executed by the at least one processor, cause the computer system to generate a collection name for the candidate collection definition based on properties from the data graph associated with the constraints of the candidate collection definition.
- generating the collection name includes, for each constraint associated with the candidate collection definition: when the constraint identifies a relationship and an object entity, determining a name for the object entity and pluralizing the name and when the constraint identifies a relationship without an object entity, determining a name for the relationship.
- Generating the collection name may also include generating the collection name from a combination of the determined names for the constraints associated with the candidate collection definition.
- determining the second set of constraints can include generating a correlation score for respective constraints and using the correlation scores to select the quantity of constraints.
- the instructions further include instructions that, when executed by the at least one processor, cause the computer system to score the candidate collection based on search records and publish the candidate collection definition when the score meets a score threshold. Scoring the candidate collection can include generating queries from the candidate collection, inspecting the search records for popularity indicators for the generated queries, and using the popularity indicators to score the candidate collection. Publishing the candidate collection may occur subsequent to curation of a collection name.
- the instructions may further include instructions that, when executed by the at least one processor, cause the computer system to determine that a first candidate collection definition and a second candidate collection definition are compatible and merge the first candidate collection definition and the second candidate collection definition into a third candidate collection definition responsive to the determining.
- Determining that the first candidate collection definition and the second candidate collection definition are compatible may include determining that a constraint for the first candidate collection definition is equivalent with a constraint for the second candidate collection definition and generating a condition for the third candidate collection definition that represents a union of the constraint for the first candidate collection definition and the constraint for the second candidate collection definition.
- One or more memories may further store a table indicating relationship equivalencies.
- the instructions can further include instructions that cause the computer system to determine that the constraint for the first candidate is a relationship in the table for a particular equivalency and convert the constraint for the first candidate to a first union that includes the equivalents for the constraint.
- the instructions can further include instructions that cause the computer system to determine that the constraint for the second candidate is a second relationship in the table for the particular equivalency and convert the constraint for the second candidate to a second union that includes the equivalents for the constraint.
- the instructions can further include instructions that cause the computer system to determine that the first union and the second union are identical, wherein the condition for the third candidate represents the first union.
- One or more memories may further store a table indicating source constraints for a target constraint.
- the instructions can further include instructions that cause the computer system to determine that the constraint for the first candidate is a source constraint for the target constraint and convert the constraint for the first candidate to the target constraint.
- the instructions can further include instructions that cause the
- the instructions further include
- a computer-implemented method includes determining, using at least one processor, a first set of entities from a data graph of entities connected by edges and determining a plurality of constraints, each constraint representing a path and target node shared by at least two of the entities in the first set. The method also includes generating, using the at least one processor, a correlation score for each of the plurality of constraints and using the correlation scores to select a quantity of constraints for a set of constraints.
- the method further includes generating, using the at least one processor, candidate collection definitions from combinations of the set of constraints, where each candidate collection definition identifies at least one constraint from the set of constraints and no more than the quantity of constraints, determining an information gain for at least some of the candidate collection definitions, and storing at least one of the candidate collection definitions as a candidate collection in a memory, the candidate collection having an information gain that meets a threshold.
- determining the first set of entities may include selecting a category from a crowd-sourced document corpus and determining entities identified by the category.
- determining the first set of entities can include identifying a popular query from search records, converting the popular query to a semantic query and executing the at least one semantic query against the data graph to obtain a query result, wherein the first set of entities is the query result from the data graph.
- the method may also include generating a collection name for the candidate collection definition based on properties from the data graph associated with the constraints of the candidate collection definition and/or scoring the candidate collection based on search records and using the score to prioritize the candidate collection for name curation.
- the candidate collection is a first candidate collection and the method further includes determining that the first candidate collection and a second candidate collection are compatible and merging the first candidate collection and the second candidate collection into a third candidate collection definition responsive to the determining.
- a computer system includes at least one processor and one or more memories.
- the one or more memories may store a data graph including entities connected by edges, candidate collection definitions, each collection definition including one or more constraints, a constraint representing a path in the data graph, and instructions that, when executed by the at least one processor, cause the computer system to perform operations.
- the operations may include generating a name for a first candidate collection definition of the candidate collection definitions based on properties from the data graph associated with the constraints of the candidate collection definition and providing the name as a suggestion to a curator of the candidate collection definitions.
- the computer system may include one or more of the following features.
- generating the name can include, for each constraint associated with the candidate collection definition, when the constraint identifies a relationship and an object entity, determining a name for the object entity and pluralizing the name, and when the constraint identifies a relationship without an object entity, determining a name for the relationship.
- generating the name may also include generating the name from a combination of the determined names for the constraints associated with the candidate collection definition.
- the data graph can include a mediator for a relationship and generating the name for the first candidate collection definition includes determining that a constraint associated with the candidate collection definition includes the relationship with the mediator; and using the mediator in generating the name.
- the operations may also include generating the name when it is determined that the first candidate collection definition does not include a condition with disjunctive constraints and/or generating at least two names based on the properties from the data graph and providing the at least two names as suggestions.
- a computer system includes at least one processor and one or more memories.
- the one or more memories may store a data graph of nodes connected by edges, store an index of constraints from collection definitions, a definition specifying at least one condition with at ieast one constraint, each constraint having a constraint type, a constraint expression, and wherein multiple conditions in the definition are conjunctive, and store instructions that, when executed by the at least one processor, cause the system to perform operations.
- the operations may include evaluating an edge for a node in the data graph against the index to determine conditions met by the edge and its associated neighborhood, and repeating the evaluating for each edge associated with the node in the data graph.
- the operations may also include determining that conditions for a first collection are met and generating an indication in the data graph that the node is a member of the first collection.
- the computer system can include one or more of the following features.
- multiple constraints associated with a condition in the collection definition are disjunctive and/or the index can include an index for each constraint type.
- the constraint type can be a template type, and the constraint expression includes a path in the data graph and variable representing a target node.
- a collection identifier may be dependent on a value for the variable, so that the system generates a new collection for unique target nodes.
- the memory may further store a collection condition data structure for each collection definition and the operations may also include initializing the collection condition data structure for the node prior to evaluating the edge for the node to indicate no conditions are met and, as part of determining conditions met by the edge, setting a flag for a first collection-condition pair to true when the edge and its associated neighborhood meet a first constraint, the first collection-condition pair being associated with the constraint expression of the first constraint in the index.
- generating the indication includes generating an edge in the data graph between the node and an entity representing the first collection.
- the instructions can include a batch process that causes the system to evaluate each edge associated with a plurality of nodes in the data graph, the evaluation determining collection membership for the evaluated nodes in a plurality of collections, and generate edges in the data graph between collection entities and nodes determined to be members of the collection represented by the collection entity.
- the system may also include instructions that cause the system to receive a query for the data graph, determine that the entity representing the first collection is responsive to the query, and use the edge in the data graph to provide the node as a response to the query.
- the operations may also include receiving a query for the data graph, the query identifying the node in the data graph, performing the evaluating for each edge associated with the node to determine collection membership for the node, and returning the collections the node is a member of.
- the constraint type is an Equals type
- the constraint expression includes a path and a terminal node, so that for the node to match the at least one condition, a path from the node ends at the target node.
- the constraint expression includes a function applied to a value associated with the terminal node.
- the constraint expression is a path of two or more edges, and/or membership of the node in each collection is evaluated in a single traversal of the node's neighborhood.
- a method in another aspect, includes initializing, using at least one processor, first data structures for a node in a data graph, each first data structure corresponding to a particular collection and including a first flag for each condition in the collection, the first flag indicating condition met or condition not met.
- the method also includes initializing, using the at least one processor, second data structures for the node, each second data structure corresponding to a particular collection with a condition having a constraint that represents exclusion, the second data structure including a second flag for the condition indicating violation found or no violation found.
- the method also includes evaluating a relationship and its neighborhood for the node against constraint expressions in a collection index and, for each constraint expression satisfied by the relationship and its neighborhood, if the constraint expression represents inclusion, setting, in the first data structure, a first flag for a condition of a collection associated with the constraint expression in the index to indicate condition met and if the constraint expression represents exclusion, setting, in the second data structure, a second flag for a condition of a collection associated with the constraint expression to violation found.
- the method also includes repeating the evaluating and setting for remaining relationships for the node in the data graph.
- the method may further include, for each second data structure, determining whether a second flag indicates violation not found and when the second flag indicates violation not found, setting, in the first data structure, a first flag for the condition and collection associated with the second flag to indicate condition met.
- the method may further include, for each first data structure, determining whether the first flag for each condition indicates condition met and, when the first flags for each condition indicates condition met, generating a relationship in the data graph that indicates that the node is a member of the collection corresponding to the data structure.
- the method may include one or more of the following features.
- a first condition of a first collection may be associated with a first constraint and a second constraint
- the index can include two entries for the first condition of the first collection.
- the first entry of the two entries may have a first constraint expression for the first constraint that is associated with the first condition of the first collection.
- the second entry of the two entries may have a second constraint expression for the second constraint that is associated with the first condition of the first collection.
- the first constraint has a constraint type that indicates the first constraint is exclusive.
- the second constraint has a template constraint type and the second constraint expression identifies a path and variable.
- the first constraint expression identifies another collection.
- a computer system may include at least one processor and at least one memory storing a data graph of nodes connected by edges and a plurality of collection definitions.
- a collection definition may include a collection identifier and one or more conditions to be satisfied for membership in the collection, a condition being a single constraint or a group of constraints, wherein when one constraint of the group is satisfied, the condition is satisfied.
- a constraint may have a constraint type and a constraint expression.
- the at least one memory may also store instructions that, when executed by the at least one processor, cause the system to generate an index for the plurality of collection definitions, each constraint of the collection definitions having an index entry.
- the index entry can include the constraint type, the constraint expression, the collection identifier, and an indication of the condition within the collection that is associated with the constraint.
- the index can be used to determine collection membership for nodes in the data graph in a single pass of the node's neighborhood.
- the computer system may include one or more of the following features.
- the collection definition may include a whitelist that identifies nodes to be included in the collection regardless of the one or more conditions and/ or a blacklist that identifies nodes to be excluded from the collection regardless of the one or more conditions.
- the constraint type can be selected from the group Equals, Not Equals, Exists, Not Exists, and Template.
- the constraint expression for constraint types of Exists and Not Exists specifies a path without a target node and the constraint expression for constraint types of Equals and Not Equals specifies a path with a target node.
- the constraint expression includes a value function applied to the target node.
- the constraint expression for constraint types of Template specifies a path with a variable.
- a first condition can have two constraints, a first constraint with a Template constraint type and a first constraint expression that specifies a first path and a first variable, and a second constraint with a Template constraint type and a second constraint expression that specifies a second path and the first variable.
- a computer program product embodied on a non- transitory computer-readable storage device includes instructions that, when executed by at least one processor, cause a computing device to perform any of the disclosed methods, operations, or processes.
- a system and/or method for defining entity collections and efficiently determining collection membership for entities in a large data graph substantially as shown in and/or described in connection with at least one of the figures, as set forth more completely in the claims.
- the system may be able to automatically identify interesting entity collections.
- the system may use search records as an indication of a collection of entities that may be part of a collection with increasing or ongoing newsworthiness.
- the system may also be able to automatically generate a large number of collections, rank the collections to determine which may be of relatively greater importance, and either automatically publish the collections for use in the data graph or prioritize the collections for human contributors to review.
- the system beneficially determines what attributes entities may have in common as well as providing a label for summarizing what the commonality is. Clustering is unable to provide such details.
- the system also does not require a pre-existing label or training data to define potentially useful clusters.
- the system uses a method of defining collections that is flexible, and enables expressive collections to be defined.
- the system can efficiently determine entity membership in the collections. For example, collection membership for an entity in a data graph with hundreds of thousands or even millions of entities may be determined in less than 10 milliseconds.
- the system may calculate collection membership for an entity in time 0(number of property-values an entity has). This is in contrast to nested loops, which make take time 0(number of property-values an entity has * number of collection constraints). This enables collection membership to be determined in real time, so that collection membership is fresh and can be used effectively in querying and analyzing the data graph.
- the system may validate the consistency of potential new data by analyzing the data graph to determine if the new data implies membership in inconsistent collections. If so, the system may flag the potential new data as erroneous data.
- FIG. 1 illustrates an example system in accordance with some implementations.
- FIG. 2 illustrates a representation of a data graph, with entities as nodes and relationships as edges between nodes.
- FIG. 3 illustrates an example of a flexible method for defining collections, consistent with disclosed implementations.
- FIG. 4 illustrates a flow diagram of a process for generating published collection definitions, consistent with disclosed implementations.
- FIG. 5 illustrates an example of a process for automatically generating candidate collections, consistent with disclosed implementations.
- FIG. 6 illustrates an example of a process for determining a search popularity score for a candidate collection based on search records, consistent with disclosed implementations.
- FIG. 7 illustrates an example process for efficiently determining entity membership in collections, consistent with disclosed implementations.
- FIG. 8 illustrates an example index of collection constraints, consistent with disclosed implementations.
- FIG. 9 illustrates an example process for iterating the neighborhood of a node to determine collection membership in one pass, consistent with disclosed implementations.
- FIGS. 10A and 10B illustrate an example of iterating the neighborhood of a node, using the data graph of FIG. 2, the example collections 320 of FIG. 3, and the example indices of FIG. 8.
- FIG. 1 1 shows an example of a computer device that can be used to implement the described techniques.
- FIG. 12 shows an example of a distributed computer device that can be used to implement the described techniques.
- FIG. 1 is a block diagram of a system 100 in accordance with an example implementation.
- the system 100 may automatically identify and define entity collections and efficiently determine membership of published collections from entities in a large data graph.
- the depiction of system 100 in FIG. 1 is described as a system capable of using search records, Internet sources, or user input to identify a group of potentially related entities, determine candidate collections, score, curate, and reconcile the candidate collections, and to identify collections of sufficient quality for publication.
- the system may include user- interface elements to facilitate user input. For published collections, the system may generate an index for the collections that allows the system to determine a particular node's membership in each published collection in one pass of the node's neighborhood.
- the system may generate collection entities in the data graph that represent the collection and the collection entity may have a special relationship with each node that is a member of the collection. Thus, the system may facilitate queries or analysis that takes advantage of the collection entities.
- the system of FIG. 1 is one example implementation and other configurations and applications may be used.
- the system 100 may include a graph engine 1 10, a collection discovery engine 120, and a collection membership engine 150.
- System 100 may be a computing system that includes a number of different devices, for example a standard server, a group of such servers, or a rack server system.
- graph engine 1 10, collection discovery engine 120, and collection membership engine 150 may each be a separate computing device, or they may share components, such as processors and memories.
- the collection discovery engine 120, the graph engine 1 10, and the collection membership engine 150 may be implemented in a personal computer, a server, or one or more logical partitions of a computer.
- one or more of the collection discovery engine 120, the graph engine 110, and the collection membership engine 150 may be distributed systems implemented in a series of computing devices, such as a group of servers.
- the system 100 may be an example of computer device 1200, as depicted in FIG. 12.
- the system 100 may include a graph-based data store 190.
- a graph- based data store is a data graph that stores information in the form of nodes and edges, with nodes being connected by edges.
- a node in a data graph may represent an entity, such as a person, place, item, idea, topic, abstract concept, concrete element, other suitable thing, or any combination of these.
- nodes may be referred to as entities and vice-versa.
- Entities in the graph may be related to each other by edges, which may represent relationships between entities.
- the data graph may have an entity that corresponds to Abraham Lincoln and the data graph may have a has profession relationship between the Abraham Lincoln entity and a U.S. President entity and a Lawyer entity.
- An indexing engine may maintain the graph-based data store 190 to allow a search engine to search the data graph, for example finding entities related to other entities by one or more relationships or paths in the graph.
- the indexing engine may be included in graph engine 1 10.
- the graph-based data store 1 0 may include an index or some other method for searching for and retrieving data from the data store.
- the graph-based data store 190 may include information from which a graph, such as the graph 200 illustrated in FIG. 2, can be created.
- a graph such as the graph 200 illustrated in FIG. 2
- reference to a data graph may be considered reference to the index for the data graph and vice versa.
- the nodes of the data graph may be referred to as entities and the edges may be referred to as relationships between two entities.
- entity may refer to a physical embodiment of a person, place, or thing or a representation of the physical entity, e.g., text, or other information that refers to an entity.
- an entity may be the physical location of France or an abstract concept that refers to France.
- the graph engine 1 10 may include a user interface that allows users, for example users of client 170, to search, update, and otherwise maintain the information in the graph-based datastore 190.
- the graph engine 1 10 may be a separate computing device with its own processor 1 13 and memory 114, or it may share one or more processors and memories with other components of system 100.
- the system 100 may include crawled documents 137.
- Crawled documents 137 may include an index for searching for terms or phrases within a corpus of documents.
- the corpus may be documents available via the Internet.
- Documents may include any type of file that stores content, such as sound files, video files, text documents, source code, news articles, blogs, web pages, PDF documents, spreadsheets, etc.
- crawled documents 137 may store one-dimensional posting lists that include phrases, terms, or document properties as posting list values and, for each posting list value, identifiers for documents related to the phrase or term. While an index for crawled documents 137 has been described as using posting lists, the index may have some other known or later developed format. Additionally, crawled documents 137 may be any collection of documents, including intranet repositories, documents associated with a particular server, etc.
- the system 100 may also include search records 135.
- Search records 135 may include search logs, aggregated data gathered from queries, or other data regarding the date/time and search terms of previously processed queries.
- the search records 135 may be generated by a search engine (not shown) in the normal process of generating search results for queries executed against crawled documents 137.
- the system 100 may also include candidate collections 130 and published collections 140.
- the candidate collections 130 and the published collections 140 may be the same data, and a flag or other field may determine whether the collection is published or not.
- collections 140 may be a subset of collections 130, and the two may not be distinctly stored collections.
- a candidate collection may be represented as a set of equivalent collections from different sources. Such a candidate collection may be associated with metadata from the different sources regarding the collection.
- a collection is defined as a series of conditions with constraints. The conditions, constraints, and other data, such as an identifier and name and metadata, are collectively a collection definition.
- the conditions and constraints that define a collection may represent conditions an entity in the graph-based data store 190 must satisfy to be a member of the collection.
- the collection definition may have one or more conditions in conjunctive normal form. This means that each condition must evaluate to true for an entity for the entity to be a member of the collection.
- a condition may represent a single constraint or a union or disjunction of two or more constraints.
- a constraint is associated with a path in the graph. The path often has a length of one, but may have a longer length.
- the constraint may be one of several types, and the type determines whether the path from a particular entity must exist, must not exist, must lead to a particular target node, must not lead to a particular target node, etc.
- a constraint may also be defined in terms of another collection. In other words, a constraint may specify that an entity must or must not be a member of some other collection.
- FIG. 3 illustrates an example of a flexible method for defining collections, consistent with disclosed implementations.
- the method includes a collection definition 300 with an identifier and a name that describes the collection. The name may be helpful for determining whether a collection is a good candidate for responding to a search query or in helping human curators arrive at a good name.
- the collection definition 300 may also optionally include a whitelist and/or a blacklist.
- the whitelist is a list of entities that are members of the collection regardless of whether a condition evaluates to false for those entities.
- the blacklist is a list of entities that are never members of the collection regardless of whether the conditions evaluate to true for those entities.
- the collection definition 300 may include one or more conditions 305, such as condition 305a, condition 305b, and condition 305c illustrated in FIG. 3.
- condition 305a, condition 305b, and condition 305c illustrated in FIG. 3.
- the conditions 305a, 305b, and 305c must each evaluate to true for the entity.
- the conditions are in conjunctive normal form,
- Each condition 305 has one or more constraints 310.
- condition 305a has constraint 310a
- condition 305b has constraints 310b and 310c
- condition 305c has constraint 31 Od.
- Each constraint 310 may have an associated constraint type 315.
- the constraint type 315 may be one of five types and may determine the format of the constraint expression for the constraint.
- a constraint expression may be a path in the data graph, a path-value pair, or a collection identifier, depending on the constraint type.
- the path may be a path of any length starting from the subject node.
- the value of a path-value pair may be a target node, e.g., the node that the path terminates at, or may be a template variable, or a value function applied to the target node.
- the constraint expression may be a path.
- the path must exist in the data graph, but the node the path ends at, e.g., the object node or the target node, is irrelevant.
- the system may only look for the has child relationship and may not care who the child is.
- the path must not exist in the data graph. As with Exists, it does not matter what the target node is. Thus, if the has child relationship does exist, this constraint would evaluate to false.
- the Equals and Not Equals types are similar to the Exists and Not Exists types respectively, except that the constraint expression may be a path-value pair or a collection.
- the constraint type is Equals and the constraint expression is a path-value pair
- a path and a target entity are specified.
- a constraint may specify that the path has profession must terminate in a lawyer node.
- the collection may exclude all lawyers using the Not Equals constraint type with the same path and target entity.
- the constraint expression for the Equals and Not Equals constraint types may also include a value function to be applied to the target entity before evaluating the constraint.
- a value function may take the value of a date entity and return the century, decade, year, or month of the date.
- a value function may enable date entities to be grouped in buckets - for example " 19 th century" or "1970s.”
- the value function may work on other types of entities.
- a value function may convert states into countries or continents, another value function may convert zip codes into neighborhoods, another may convert dollars to euros, etc.
- Both the Equals and Not Equals types can specify a collection instead of a path-value pair for the constraint expression.
- the constraint expression may use a keyword, e.g., 'collection', to indicate what follows the equal sign is a collection identifier.
- a constraint can specify membership in the World Leaders collection using the constraint expression "collection-World Leaders". This constraint would evaluate to true for an Equals type if the entity was a member of the World Leaders collection. If the constraint is a Not Equals type, the constraint evaluates to true if the entity is not a member of the World Leaders collection. This property allows the system to take advantage of
- a constraint may also have a Template type.
- the Template type is similar to Equals, but instead of specifying the target node in the constraint expression, the constraint expression includes a template variable.
- the template variable allows the target node to determine which collection the entity belongs to.
- the [prof] represents a variable used to capture the target entity. The constraint identified above will generate a collection for has
- a collection definition may include two constraints, each of a Template type.
- constraints 310b and 3 10c different paths can use the same template variable.
- the Exists, Equals, and Template constraint types may correspond to constraints that represent inclusion because nodes with relationships and target nodes that meet the constraint expression satisfy the constraint.
- the Not Exists and Not Equals constraint types may correspond to constraints that represent exclusion because nodes with relationships and target nodes that meet the constraint expression do not satisfy the constraint.
- Each constraint is associated with a condition. While a condition may have two or more constraints, the constraints associated with the same condition are disjunctive. This means that if any of the constraints are met, the condition is met.
- constraint 3 10a is associated with condition 0 (305a)
- constraint 3 1 Od is associated with condition 2 (305c)
- constraints 310b and 310c are both associated with condition 1 (305b).
- condition 1 evaluates to true.
- conditions may be identified in order beginning with zero, although other condition identifiers may be used.
- Example collections 320 may be published collections 140 or candidate collections 130.
- the length of the path of a constraint may be longer than one.
- a constraint in condition 1 has a path with a length of two.
- a particular node meets the constraint when it has a relationship of has iegree with some intermediate node, and the intermediate node has a relationship of emphasis that leads to a political science node.
- a path for a constraint may have a length greater than one.
- Collection C2 illustrates a collection with a Template constraint type.
- the name of the collection includes the variable that determines collection membership.
- the name of the C2 collection is "Presidents of [CTRY]" where [CTRY] is replaced with the value of the target node from the constraint in condition 1.
- condition 1 of C2 has two constraints.
- Collection C2 can use either a birth _country relationship or a nationality relationship to define the value of the [CTRY] variable.
- Collection C3, which has a name of "Only Children,” illustrates a collection with only one condition and one constraint within the condition.
- Collection C4 illustrates the use of a value function. The constraint in position one extracts the century from the value of the target node prior to comparing it to the value "19 ⁇ 1 ' Century". It is assumed that the function ExtractCentury( ) will return that value if the date entity related to the node by the birth_date relationship is between 1800 and 1 899.
- the system 100 may include collection index 145.
- the collection index 145 may enable the system to traverse the neighborhood of an entity in one pass while still determining the entity's membership in each collection in the published collection 140.
- the index 144 may include an index for each type of constraint.
- the indices for the Exists and Not Exists types may specify the path and the collection/condition pair (or in other words, the collection/position pair) associated with the path.
- the indices may be sorted by path or by a hash of the path.
- the indices for the Equals and Not Equals types may specify for each path/target node pair a collection/condition pair.
- the Equals and Not Equals indices may be generated from Equals and Not Equals condition constraints that are not collection identifier and not templates.
- the indices for the Member and Not Member types e.g. constraint expressions that identify a recursive collection
- the index for the Template type e.g., constraint expressions that include a template variable
- the collection index 145 may also include a mapping from a collection to a list of template variables used in the collection.
- the collection index 145 may also include other mappings needed to efficiently generate entity memberships for a large data graph.
- FIG. 8 illustrates an example of the collection index 145.
- the graph-based data store 190, crawled documents 137, search records 135, candidate collections 130, published collections 140 and collection index 145 are stored on tangible computer-readable storage devices, for instance disk, flash, cache memory, or a combination of these, configured to store data in a semi- permanent or non-transient form.
- the graph-based data store 190, crawled documents 137, search records 135, candidate collections 130, published collections 140 and collection index 145 may be stored in a combination of various memories, and/or may be stored in a distributed manner across multiple physical or logical computing devices.
- the system 100 may include a collection discovery engine 120.
- the collection discovery engine 120 may include one or more processors 123 configured to execute one or more machine executable instructions or pieces of software, firmware, or a combination thereof to automatically define collections and to facilitate user curation of collections and/or collection names.
- the collection discovery engine 120 may have its own processor and memory or it may share one or more processors and memories with other components of system 100.
- the collection discovery engine 120 may analyze search records 135 and/or crawled documents 137, as will be explained in more detail below.
- the collection discovery engine 120 may also allow a user, such as a user of client 170, to select a set of entities from the graph-based data store as a basis for generating collections.
- the collection discovery engine 120 may also permit a user, for example using user interface 126, to directly define collections, to edit automatically generated candidate collections 130, to add entities to the white or blacklists of a collection, and to publish one or more candidate collections 130 to published collections 140. In some implementations, the collection discovery engine 120 may automatically select one or more of the candidate collections 130 for publication to published collections 140. As explained above, publishing a candidate collection 130 may include setting a flag that indicates whether a collection is published or may include actually moving the collection definition from candidate collections 130 to published collections 140. In some
- the collection discovery engine 120 may include a ranking engine that ranks and evaluates candidate collections 130 for publication.
- the collection discovery engine may also include a reconciliation engine that evaluates the candidate collections for duplicates, synonyms, etc., and merges compatible collections.
- the system 100 may include a collection membership engine 150.
- the collection membership engine 150 may include one or more processors 1 3 configured to execute one or more machine executable instructions or pieces of software, firmware, or a combination thereof to generate the collection index 145 from the published collections 140,
- the collection membership engine 150 may have its own processor and memory or it may share one or more processors and memories with other components of system l OO.
- the collection membership engine 150 may generate the collection index 145 periodically, for example once per day.
- the collection membership engine 150 generates the index 145 in an offline mode.
- the collection membership engine 150 may also use the graph-based data store 190 to determine entity membership in the published collections 140.
- the collection membership engine 150 may determine an entity's membership in a single pass of the entity's neighborhood, evaluating each edge one time for all constraints, using the index 145. In some implementations, the collection membership engine 150 may generate a new entity, referred to as a collection entity, in the data graph to represent each published collection and each collection generated from template constraints. The collection entities may be linked in the graph to the entities that are members of the collection by a relationship that indicates membership in a collection. In some implementations, the collection membership engine 150 may determine entity membership and generate the collection entities on a periodic basis, for example once per day.
- the collection membership engine 150 may delete any collection entities and the relationships representing entity membership, generate collection entities for collections in the published collections 140, evaluate the nodes in the data graph for membership, and generate the proper relationships.
- the collection membership engine 150 may generate a collection entity when the collection is published and may generate entity memberships at the time the collection is published and for individual entities as the entity or its relationships are changed, e.g. added, deleted, or otherwise updated.
- the system may generate collection membership in response to a query or other command. The query may identify the entity and, optionally, the neighborhood of the entity to be evaluated.
- the system 100 may also include other components not illustrated for brevity.
- the system 100 may include an indexing engine to create and maintain graph-based data store 190 and/or crawled documents 137, etc.
- the indexing engine may obtain content from, for example, one or more servers, and use the content to maintain graph-based data store 190 and/or crawled documents 137.
- the servers may be web servers, servers on a private network, or other document sources that are accessible by the indexing engine.
- the indexing engine may be one or more separate computing devices, such that graph-based data store 1 0 is maintained by a first set of computing devices and crawled documents 137 is maintained by a second set of computing devices, etc.
- the graph engine 1 10 may include an indexing engine for the graph-based data store 190 and the system 100 may include another indexing engine for crawled documents 137.
- the system 100 may also include a search engine that use the graph-based data store 190 and/or crawled documents 137 to determine search results for queries using conventional or other information retrieval techniques.
- the system 100 may be in communication with the client(s) 170 over network 160.
- Network 160 may be for example, the Internet or the network 160 can be a wired or wireless local area network (LAN), wide area network (WAN), etc., implemented using, for example, gateway devices, bridges, switches, and/or so forth.
- the collection discovery engine 120 or the collection membership engine 150 may communicate with and transmit data to/from clients 170.
- collection discovery engine 120 may provide candidate collections for curation to users of clients 170 and users of clients 170 may define collections, publish collections, or update candidate collections.
- FIG. 4 illustrates a flow diagram 400 of a process for generating published collection definitions, consistent with disclosed implementations.
- the process 400 may be performed by a system, such as system 100 of FIG. 1.
- the system may use process 400 to automatically generate, rank and reconcile candidate collections, and automatically or semi-automatical ly curate the candidate collections.
- the system may also automatically publish candidate collections that meet a quality threshold.
- the quality threshold may be based on several factors, as explained below.
- process 400 may be performed by a collection discovery engine.
- Process 400 may begin with the system generating candidate collections (405).
- the candidate collections may be automatically generated from analysis of search records or collaborative documents, such as wiki pages, or from user-provided entities from a data graph.
- Collaborative documents, such as wiki pages are documents edited by many people and can represent group consensus regarding the description of a topic.
- the system may use heuristics and meta rules to determine which collections are important, as will be explained in further detail with regard to FIG. 5 below.
- Other sources of candidate collections include Web Tables. Web tables are tables found in a document available over the internet and may be generated using the ⁇ table> tag in Hypertext Markup Language (HTML) or other similar markup. In the Web tables example, entities listed together in a table may be considered a set of entities for analysis.
- HTML Hypertext Markup Language
- the system may rank the candidate collections (410). Ranking the candidate collections may include assigning an importance/popularity score to each candidate collection. This score may be used to determine a quality score and/or to prioritize the collection for a manual curation process.
- the system may generate scores based on search record signals, member entity notabilities, or other signals and may aggregate the scores into an overall score. The aggregated score may be a weighed sum of the individual scores.
- FIG. 6 illustrates an example of generating a search score based on search record signals. A member score based on member entity notabilities may represent the number of important or popular entities in the collection.
- the importance of each entity may be based on an importance score kept in the data graph for each entity or the importance score for each entity from an engine that matches entities in the data graph to references of that entity in documents, such as web pages.
- the member score may be an average importance score, or may be a percentage of entities in the collection that have an importance score that meets a threshold.
- the system may also consider a table importance score based on how often the entities of the collection appear in tables or lists in documents available over the Internet or in some other document corpus.
- the system may determine how often the entities appear in the tables/lists, how similar the entities in the collection are to the table/list, and if the collection is very similar to a table/list, the quality the document having the table/list. For example, the system may determine a PageRank of the document, may determine how often the table/list was imported by users, etc. Other types of scores may be considered in determining a rank score for the candidate collection. [00064]
- the system may aggregate the individual scores, e.g., the search popularity score, the member score, and the table importance score, to determine an overall rank score.
- the overall rank score may be a weighted sum of the individual scores. For example, some implementations may weigh the search popularity score higher, while other implementations may weigh the member score higher. Collections with higher overall rank scores may be considered first for manual name curation.
- the system may also use the rank score to determine a quality score for automatic publication.
- the system may also reconcile candidate collections (415). Collections that are compatible may be merged. Collections are compatible when they are equivalent or nearly equivalent. One way collections are compatible is when the constraints are identical for two candidate collections. When constraints are identical, the system may automatically merge the two candidate collections into a new candidate collection.
- Candidate collections may also be compatible when the constraint of one collection is a source constraint for a target constraint of another collection. To identify target-source relationships, the system may include a table or other data that maps a target constraint to one or more source constraints.
- the system may translate each source constraint into the target constraint. Then the system may determine that candidate collections include the same translated constraints and merge the two collections. In some implementations, when the definitions are merged, the system assigns the target-source constraints to the same condition, so that either constraint may be satisfied to satisfy the condition.
- the collections are compatible when the constraints are equivalents.
- the system may translate each constraint that has a synonym into a condition with a series of disjunctive constraints, each constraint representing a synonym in the table. If one candidate collection with translated constraints is then found to be equivalent to another candidate collection with translated constraints, the system may merge the two collections, keeping the condition with the disjunctive constraints.
- the two candidate collections that were used to generate the new candidate collection may be deleted.
- the system may calculate a rank score for the new merged collection based on the rank scores of the two candidate collections.
- the rank score for the new collection may be an average of the rank scores of the two candidate collections, the higher of the rank scores of the two candidate collections, or the system may generate a new rank score as described with regard to step 410 above.
- the system may merge candidate collections before generating a rank score for the candidate collections, rearranging the order of the steps shown in FIG. 4.
- the system may also curate the candidate collections (420). Curation refers to determining a name for the collection.
- the system may automatically generate one or more suggested names for the candidate collection.
- the automatically generated name may be used in a quality score for the candidate collection, may be used to suggest names to a human contributor, etc.
- the system may use heuristics applied to the properties of the relationship-value pairs in the constraints to suggest names. For example, if a constraint includes a relationship and a value, such as profession-Jazz Pianist, the system may use the plural form of a description for the target entity as a name for the collection, e.g. jazz Pianists. Some relationships in the data graph have a schema.
- the plays instrument relationship may have a schema with a description of "musician.”
- the system may use the schema to generate the suggested name "violin musicians.” This may be especially helpful when a predicate has more than one property, such as mediator or compound value type predicates in the Freebase data graph.
- entity type e.g., Movie or Person
- the system may also infer names may also be induced from categories of collaborative web pages, such as wikis, or class names for queries used to generate the collection candidates. More than one suggested name may be generated for an entity.
- the system may choose one of the names as the collection name and the remainder may be aliases.
- the generated name may be used to calculate a name score for the collection. Names with digits may be considered low quality names and be associated with a low name score. Collections with a high number of aliases may also be considered to have a lower quality name, as there are a number of different possibilities and it may be beneficial to have a human curator select a name for the collection. Collections with human-curated names may be considered to have high quality names with a high name score. Thus, it is possible that a collection that does not meet a quality threshold for publication with automatically generated names may meet the threshold after human curation. In some implementations, a candidate collection may never meet the quality threshold before a human curator has approved the collection name.
- the system may determine whether candidate collections meet a quality threshold (425). Each candidate collection may have a quality score that is compared to the quality threshold.
- the quality score may be a combination of the rank score, for example from step 410, a name score from step 420, and/or other factors.
- the system may use natural language techniques to analyze the name of a collection to determine whether it correlates to the entities. For example, if the name of the collection is "Chinese Engineers," for example taken from a category of a wiki, but the entities in the collection are not person entities, the system may not consider the candidate collection to be of high quality.
- the system may also use filters to filter out bad quality candidates regardless of the rank score, name score, or other scores. For example, the system may filter out candidate collections that have a size less than a minimum size, collections with more than a maximum quantity of equivalent collections, candidate collections with less than a minimum quantity of constraints, and/or candidate collections where the fraction of entities in the collection is less than a minimum fraction of entities.
- candidate collections that do not meet the filters may be deleted, or may be assigned a very low quality score.
- the filtering may take place during the generation of candidate collections, as discussed below with regard to FIG. 5.
- Process 400 then ends. It is understood that the steps of process 400 may occur over some period of time for particular candidate collections. For example, some candidate collections may be automatically published without human curation, while others may receive curation before they are published. Such candidate collections may wait in a queue for curation for a period of time. The queue may use the rank score or quality score of a candidate collection, so that more highly scored collections may be curated first. Ranking, reconciling, and curating the candidate collections may be performed independently of each other and may be performed in any order.
- FIG. 5 illustrates a flow diagram 500 of a process for automatically generating candidate collections, consistent with disclosed implementations.
- the process 500 may be performed by a collection discovery engine of a system as part of step 405 of FIG. 4.
- the system may use process 500 to automatically discover common properties shared by entities in a set of entities, and to determine which common properties are important and candidates for defining a collection.
- Process 500 may start using one of a number of inputs. For example, in one implementation process 500 may begin by identifying a popular query from search records (505). In some implementations, a popular query may be a query requested with regularity or a query frequently requested in a given timeframe.
- the system may convert the natural language query into one or more semantic queries that can be executed against a data graph (510). The conversion may be accomplished using natural language analysis, analysis of the semantic graph, or other known or later developed techniques. For example, the natural language query "Tom Hanks Movies" may be converted into a query for "films Tom Hanks acted in” or "movies Tom Hanks produced” or "films Tom Hanks directed," etc.
- the system may execute each of the semantic queries against the data graph to determine a set of entities responsive to the query (515). Each semantic query may result in a corresponding set of entities. While FIG. 5 illustrates examining one set of entities for one semantic query for brevity, it is understood that step 515 and 535 to 550 may be performed for each semantic query and, thus, each semantic query may result in one or more candidate collections.
- process 500 may begin by selecting a category from a collaborative site, such as a wiki site.
- Wiki sites may include a document describing an entity, and may associated the entity with one or more categories.
- the system may use one of the categories and determine which entities in the data graph are associated with the category (535).
- the system may simply receive a set of entities from a user (530).
- the system may include each entity specified by the user in a whitelist for the collection.
- the system may analyze the set of entities received from the user as described below to determine a definition that can be used to group other entities into the collection. In other words, the entities supplied from the user may represent a sample of entities for a collection.
- the system may determine property-value pairs for the entities in the set (535).
- Property- value pairs represent a path and target node shared by a plurality of entities in the set.
- some properties i.e. relationships
- some relationships may model graph meta-data, including data about entity types and properties, some properties may be known to be rare, if the distribution of the values for the property fail to satisfy some criteria, such as an entropy threshold or having literal values such as floating point numbers, dates, integers, etc.
- the system may ignore such properties.
- the system may ignore paths that lead to some types of target entities.
- the system may ignore nodes that are compound value types (CVTs), nodes without natural language names, etc.
- the system may use information technology theory based metrics to measure how strongly correlated the property- value pair is with the set of entities and select a predetermined quantity of the property- value pairs (540). For example, to determine a correlation statistic the system may use information gain and IF-IDF measures, or any other known or later developed correlation statistic.
- the correlation statistic may account for entity popularity, so that property-value pairs that include more popular entities receive an increase to the correlation statistic score. Entity popularity may be tracked in the data graph. Once each value-pair has a correlation statistic, the system may select the top 4-5, or some other predetermined quantity, of the property-value pairs for further evaluation.
- the system may evaluate combinations of the selected property-value pairs to determine which combinations are most correlated to the set of entities and have the highest information gain (545). For example, the system may determine subsets of the set of selected property-value pairs and evaluate each subset with a size less than or equal to a predetermined quantity, for example 3. As an example, if the predetermined quantity is 3 and the system has selected four property-value pairs for further evaluation, PI, P2, P3, and P4, the system may generate subsets of the group ⁇ PI, P2, P3, P4 ⁇ that have between 1 and 3 members.
- the system may generate the subsets: ⁇ PI ⁇ , ⁇ P2 ⁇ , ⁇ P3 ⁇ , ⁇ P4 ⁇ , ⁇ PI, P2 ⁇ , ⁇ PI, P3 ⁇ , ⁇ PI , P4 ⁇ , ⁇ PI, P2, P3 ⁇ , ⁇ PI, P3, P4 ⁇ , ⁇ PI , P2, P4 ⁇ , ⁇ P2, P3 ⁇ , etc.
- Each subset represents a candidate collection.
- the system may calculate an information gain.
- the system may prefer simpler collections, or in other words collections with fewer constraints.
- the system will prefer ⁇ PI , P4 ⁇ over ⁇ PI , P2, P4 ⁇ as P2 does not add value to the collection.
- the information gain may be based on the total number of entities in the data graph, the number of entities in the set of entities, the number of entities in the data graph that meet the constraints of the subset, and the number of entities in the set that meet the constraints of the subset. Table 1 below illustrates example values for the variables described above for a data graph with 1 ,000,000 entities. It is understood that for the sake of brevity, Table 1 does not include values for every subset combination and that the system would calculate the values for the additional subsets to determine information gain for each subset:
- the system may also calculate the distribution of entities satisfying the subset (e.g. Y/T) and not satisfying the subset (e.g. (T-Y)/T). These calculations may be used to calculate the information gain of a subset.
- the information gain for a subset may be represented by the entropy of the subset (described above) minus the fraction of entities satisfying the subset multiplied by H(X, (Y-X)) minus the fraction of entities not satisfying the subset multiplied by H((S-X),(T-Y-S+X)).
- the system may select subsets with an information gain that meets a predetermined threshold. Of the candidate collections that meet the threshold, the system may use other measures to prune the collections (550). For example, candidate collections that do not meet a size threshold may be discarded, or definitions where the fraction of entities satisfying the collection definition is less than a fraction threshold may be discarded. Other similar types of measures may be used.
- the system may store candidate collections that are not pruned and meet the information gain threshold as candidate collections. The property-value pairs may become the constraints of the candidate collection. Thus, at this point, candidate collections have one to three conditions, each condition having one constraint. Process 500 may then end, having generated candidate collections.
- FIG. 6 illustrates an example of a process 600 for determining a search popularity score for a candidate collection based on search records, consistent with disclosed implementations.
- the process 600 may be performed by a collection discovery engine of a system as part of step 410 of FIG. 4.
- the system may use process 600 to calculate a search popularity score used to determine an overall rank score for a candidate collection.
- the search popularity score may one of several scores used to determine the overall rank score.
- the system may begin process 600 by determining a pattern of expression for the relationship in the constraint of a candidate collection (605).
- the pattern of expression may be a learned pattern based on the relationship and the types of entities it connects.
- the system may know that the actor relationship links a movie, play, or TV show to a person.
- the system may determine that the pattern of expression for the actor relationship is " ⁇ person> ⁇ media>" or " ⁇ media> ⁇ person>” or " ⁇ media> of ⁇ person>” or " ⁇ media> ⁇ person> acted in", etc.
- the system may then determine descriptions and synonyms of the description for the relationship, and the target entities or the entity type of the expected subject for the relationship (610).
- films, shows, and pictures may be synonyms of movies, musicals may be a synonym of play, and episode may be a synonym for TV show.
- the actor relationship may expected a media type as the subject entity and a person as the object entity.
- the synonym determination may include synonym determination used in conventional search systems to offer alternative queries for a search.
- the system may use these descriptions and synonyms to generate at least one pseudo query (615).
- the pseudo queries for the example above may be "torn hanks movies" "torn hanks films,” "shows starring torn hanks,” etc.
- the system may perform steps 605 to 615 for each constraint and combine the pseudo queries (625).
- the system may combine the pseudo queries into "pg rated movies by torn hanks".
- the system may match the pseudo queries against search records to determine popularity /importance evidence with which to determine a search popularity score for the candidate collection (630).
- the search records may include an indication of quantity, frequency, and recency of previously submitted search queries. If the pseudo queries match a query in the search records, the system may use a popularity score for the query to determine a search popularity score for the candidate collection. In some implementations, the system may aggregate or average the scores from matching queries. In some implementations, the search records may be annotated with references to entities in the data graph. This may help disambiguate ambiguous strings in the pseudo queries or search records.
- the system may also use other records, such as frequency of a term in a corpus, to determine the search popularity score. For example, some systems may index phrases of one or more words, such as "action movies" and the number of documents that include the phrase may be an indication of popularity as well. Process 600 ends when the system has determined a search popularity score for the candidate collection.
- FIG. 7 illustrates an example process 700 for efficiently determining entity membership in collections, consistent with disclosed implementations.
- the process 700 may be performed by a collection membership engine of a system such as system 100 of FIG. I .
- the system may use process 700 to generate indexes for published collections and use the indexes to determine entity membership in each collection.
- the system may begin process 700 by obtaining defined collections (705).
- the collections may be automatically defined collections, for example using process 400 of FIG. 4, and/or collections entered by a user.
- a user may also edit an automatically generated collection. Defining collections may be an ongoing process, with collections being automatically generated on a periodic basis and entered or updated manually at any time.
- the collections may be kept in a library, such as published collections 140 of FIG. 1.
- the system may generate an index of collection constraints from the collections (710).
- the index may include several indices that the system uses to determine an entity's membership in a single pass of the neighborhood.
- the index generation may be done on a periodic basis, for example nightly, so that new collections and modifications to collections may be captured by the index.
- the index may be updated when a collection is published or modified.
- FIG. 8 illustrates an example index of collection constraints, consistent with disclosed implementations.
- the index may include a plurality of constraint-type based indices. Each constraint in the collection library may be inserted into one of the constraint-type indices.
- the index may include an Exists index 800 for constraints of the type Exists. This index may map the constraint expression from the Exists constraints with a path as the constraint expression to the collection/condition pair associated with the constraint.
- the index may also include a Not Exists index 805. This index may map the constraint expression from the Not Exists constraints to the collection/condition pair associated with the constraint expression.
- FIG. 800 illustrates an example index of collection constraints.
- the relationship parent_of ⁇ s used in a constraint for the second condition (condition 1) of collection C2 the relationship wrote is used in a constraint for the first condition of collection CI 3 and the third condition for the collection CI 1.
- the Not Exists index illustrates that the has_sibling relationship appears in the first condition of the C3 collection. This collection is illustrated in the example collections 320 of FIG. 3.
- the index may also include an Equals index 810 for constraints with an Equals constraint type.
- the Equals index 810 may specify a constraint expression for constraints of the Equals type and the collection condition pairs associated with those constraints.
- index 810 includes separate entries for
- the index may also include a Not Equals index 815 for constraints of the Not Equals constraint type.
- the Not Equals index 815 may function similar to that of the Equals index 810, mapping a constraint expression to collection/condition pairs. However, this index indicates that the path to the target node should not exist in the data graph for the constraint to be met.
- the index may also include a member index 820 and a not member index 825.
- the index 820 and the index 825 represent constraints with a collection identifier as the constraint expression.
- the member indices specify membership in (for index 820) or no membership in (index 825) other collections.
- index 820 and index 825 map a collection to a collection/condition pair.
- the second condition of collection CI has a constraint that specifies membership in collection C3.
- the node being evaluated must be a member of collection C3.
- index 825 illustrates that the first condition of collection C19 specifies that an entity must not be a member of collection C23.
- the Member index 820 and Not Member index 825 represent recursive collection constraints.
- the index may also include Template index 830 and Template Variable index 835.
- the Template index 830 maps a constraint expression to a corresponding collection, condition, and template variable.
- the system can determine which collection/condition pairs that path belongs to. The system may then use the target node at the end of the path to determine which collection the node belongs in, as will be explained in more detail with regard to step 735 below.
- the Template Variable index 835 may map a collection to a list of template variables in the collection. The system may use the index 835 to generate the collections after analyzing the neighborhood of the node, as explained in more detail with regard to step 735 below.
- the system may use the index to determine an entity's membership in the published collections (715-740). This may be done independently of defining collections and generating the index, although the index must be generated prior to determining an entity's membership.
- the system may determine an individual entity's membership as part of a process that determines membership for all entities in the data graph or the system may determine the entity's membership when an entity has been modified, e.g. a relationship added or deleted in the data graph.
- the system may delete all collection nodes and relationships for the collection nodes before determining membership for the entities in the data graph. Determining membership may cause the system to regenerate collection entities and their relationships as explained in more detail below.
- the system may initialize collection data structures for a node.
- the data structures may include a collection conditions data structure that tracks which conditions in which collections the node has satisfied.
- the collection condition data structure may be a bit vector and the node may have a bit vector for each collection.
- the bit vector may contain the collection as key with a flag, e.g. a bit or byte or position in an array, for each condition in the collection.
- the collection CI illustrated in examples 320 of FIG. 3 may have a collection condition data structure of C1 ⁇ 00, with each 0 representing one of the two conditions in collection CI .
- Collection C2 of FIG. 3 may also have a data structure such as C2 ⁇ 00 and collection C3 may have a data structure of C3 ⁇ 0. It is understood that the collection condition data structure may take various forms so long as it includes the collection as the key and flags or bits indicating whether each condition in the collection is met.
- the system may initialize the collection condition data structures so that no conditions are met in any collections. For example, when a bit vector is used, the bits representing the conditions may be initialized to zero.
- the system may also initialize additional data structures. For example, the system may generate a Template Matching Value data structure that maps template variables to target nodes encountered during the walk of the node's neighborhood. Thus, for example, when a nationality path leads to a target node of U.S.A., the system may associate U.S.A. with the template variable [CTRY] from collection C2.
- the system may initialize the Template Matching Value structure to an empty structure. Additionally, the system may have a violation data structure for each constraint that has a Not Exists index or Not Equals constraint type.
- the violation data structure may include an entry for each entry in the Not Exists index 805 and the Not Equals index 815. The system may initialize the violation structure to indicate that no violations were found.
- the system may then populate the data structures by iterating the neighborhood of the node (720). Iterating the neighborhood is completed in one pass as explained in more detail below with regard to FIG. 9.
- the condition collection data structures include an indication of which conditions have been satisfied by Equals, Exists, and Template constraints.
- the system may then update the collection condition data structures with information from the violations data structure. For example, when the violations data structure indicates a condition was not violated, the system may set the corresponding flag or bit in the collection condition data structure to indicate the condition was met. Any violations are not returned, as their corresponding flag or bit in the collection condition data structure was originally set to "not met.”
- the system may also determine membership for recursive constraints (730).
- the system may use the Member index and the Not Member index to further modify the collection condition data structure. For example, the system may determine the collections specified as keys in the Member index, determine whether the node is a member of that collection using the collection condition data structure, and if it is, set bits or flags in the corresponding collections/condition pairs for the collection specified in the key. For example, using the Member index 820 of FIG. 8, the system may determine if a node is a member of collection C3, for example if all condition bits or flags for collection C3 are set to true. If it is, the system may set the bit or the flag for CIO condition 1 to true. Similarly, using the Not Member index 825, the system may determine if the node is a member of collection C23 and if not, the system may set collection C19 condition 0 to true.
- the system may then generate triples in the data graph representing node membership (735). For example, the system may generate a relationship between the node and a collection entity representing a collection that the collection condition data structure for the collection indicates has all conditions met. If an entity representing the collection does not exist, the system may add it.
- the entity representing the collection does not exist, the system may add it.
- FIG. 2 illustrates an example of a collection entity.
- the collection entity may have an identifier assigned by the system and a name, which is the name of the collection.
- the relationship between the collection entity and other entities in the graph may be a special relationship that signifies membership in a collection.
- the system may use the Temporary Matching Value data structure to identify those collections and to generate the correct relationships.
- the Temporary Matching Value data structure maps a collection and template variable to a matching value.
- the Template Variable index such as index 835 of FIG. 8, indicates how many template variables exist in a collection.
- the system may generate a Cartesian product of the values for the variables of a collection. For example, collection C7 of FIG. 8 has two template variables.
- the system may generate the combinations of "French Actor” “French Writer”, “French Tailor”, “German Actor” “German Writer” and “German Tailor”. These combinations each represent a collection.
- the entity that populated the Temporary Matching Value data structure is a member of six collections. Accordingly, the system may generate a relationship between the entity and each of the six collection entities, and generate any of the six collection entities that did not previously exist in the data graph. If there are other nodes with memberships to be determined (740, Yes), the system may repeat steps 715 through 735 for the next node. If no other nodes have memberships that need to be determined (740, No), process 700 may end.
- FIG. 9 illustrates an example process 900 for iterating the
- the process 900 may be performed by a collection membership engine as part of step 720 of FIG. 7.
- the system may begin process 900 by selecting one of the relationships in the neighborhood of the node (905).
- the relationship may be any relationship that directly connects the node with another node.
- the system may compare the relationship to the Exists index (910). If the Exists index includes a path matching the relationship, the system may determine the collection/condition pairs for the path in the Exists index. For each
- the system may mark the corresponding bit in the collection condition data structure (or flag etc.) to condition met.
- the system may also compare the relationship to the Mot Exists index (915). If the relationship matches a path in the Not Exists index, the system may determine the collection/condition pairs associated with the path in the Not Exists index. For the associated collections, the system may set the associated conditions as violated in the violations data structure,
- the system may then get the target node for the relationship (920).
- the target node is the node connected to the original node by the relationship.
- the system may compare the relationship and target node combination to the constraint expressions in the Equals index (925). If the Equals index includes a matching path and target node, the system may determine the collection condition pairs associated with the path and target node in the Equals index. For the associated collections, the system may set the indicated conditions as met in the condition collection data structure.
- the system may also compare the relationship and target node combination to the Not Equals index (930). If a matching path and target node are found, the system may determine the collection/conditions pairs associated with the matched path-value pair.
- the system may set the associated conditions to violation found in the violation data structure.
- the system may also compare the relationship to the Template index (935). If the relationship matches the path from a constraint expression in the Template index, the system may determine the collection, condition, and template variables associated with the matching path.
- the system may mark the associated condition as met in the collection condition data structure.
- the system may also generate an entry in the Temporary Matching Value data structure that maps the associated collection and template variable from the constraint expression with the target node.
- the system may then iterate the neighborhood of the target node, concatenating the relationship with the relationships of the target node (940).
- the system may perform process 900 for the target node, but each relationship from the target node to another node is concatenated with the relationship leading from the original node to the target node.
- the relationship used to match the indices is has_degree.degree rom.
- relationship as used in FIG. 9 may refer to a path length longer than one on a second iteration.
- the system may limit the number of iterations. For example, if the target node would be the fourth iteration, the system may skip step 940. In this example, only paths with a length of three are used in constraints.
- the system may determine whether there is another target node that has the same relationship with the original node (945). If another target node does exist (945, Yes), the system may repeat steps 920 to 945 using the next target node. If there are no other target nodes (945, No), this iteration is complete and process 900 ends.
- FIGS. I OA and 10B illustrate an example of iterating the neighborhood of a node to determine collection membership using the data graph of FIG. 2, the example collections 320 of FIG. 3, and the example indices of FIG. 8. For the sake of brevity only index entries relating to collections CI to C4 of the example collections 320 of FIG. 3 are considered for this example.
- the Barack Obama node of FIG. 2 is the node being evaluated, and may be referred to as the original node.
- the system may generate a collection condition data structure 1000 for each of the collections C I , C2, C3, and C4 of FIG. 3.
- the system may also generate a violation data structure 1001 for the condition of the C3 collection, as it includes a Not Exists constraint.
- the data structures will be referred to as having flags to represent the conditions of the collections, but it is understood that the flags may be bits, numbers, characters, or any other method used to track a condition met/not met state. All flags in the data structures may be set to the not met state, in this example all zeros.
- the system may select a relationship for the Barack Obama node, such as the has profession relationship (1010).
- the system may then compare the has profession relationship to the Exists index 800 and Not Exists index 805 (1012). Neither index includes the has profession relationship, so the data structures remain unchanged.
- Collection CI , condition 0 matches the relationship and target node combination in the Equals index 810, so the system sets the flag corresponding CI condition 0 to condition met, in this example a 1.
- the combination of has does not have a match any other indices, so the system may analyze the next target node of the has profession relationship, the President node ( 1014).
- the system sets the appropriate flags in the collection condition data structure 1000 to condition met.
- the combination does not match any other index entries and no other target nodes exist for the has profession relationship, so the system selects another relationship.
- the system selects the degree from relationship of the BA node next (1034). Because this is a second iteration, this relationship is concatenated with the relationship of the first iteration and the system looks for has degree.degree from in the Exists index 800 and the Not Exists index 805 ( 1036). No matches are found. The system then gets the target node Columbia of the degree from relationship of the BA node (1038). The system compares the has
- the system has explored the neighborhood of the BA node and, thus, returns to the first iteration looking for another target node for the has degree relationship. Another node is found (1040).
- the JD node has a neighborhood to explore, so the system iterates its neighborhood.
- the system concatenates the degree from relationship to the has degree relationship and looks in the Exists index 800 and the Not Exists index 805 for entries matching has degree.degree from (1044). No matches are found.
- the system may select the next relationship has sibling (1048).
- the system may look in the Exists index 800 and the Not Exists index 805 for the has sibling relationship (1050).
- the Not Exists index 805 has a match for collection C3 condition 0. Because the match is with the Not Exists index 805, the system does not set the corresponding flag in the collection condition data structure 1000. Instead, the system sets the corresponding flag in the violations data structure 1001 to condition violated, in this case a 1.
- Tracking Not Exists and Not Equals in this manner ensures that if the constraint with the Not Exists type is part of a disjunction in the condition (e.g., only child or oldest child), the condition can still be met by the other constraint in the condition.
- the system may use the violation data structure 1001 to set additional flags in the collection condition data structure 1000. For example, if the condition for collection C3 was not marked as a violation, the system may set the flag for collection C3 condition 0 to condition met. However, because a violation was found, the system does not change the flag for collection C3 condition 0. Using the collection condition data structure 1000, the system may determine that all conditions for collections C I and C2 are met, because the flags for these collections are all set to condition met. The system may generate a relationship in the data graph between the Barack Obama node and the collection node Political Science Lawyers, If the data graph does not already include a Political Science Lawyers node it may generate one.
- the system may use the Member index 820 and the Not Member index 825 to determine if the CI or C2 collections are in either index. If so, the system may set additional flags in the collection condition data structure 1000, or additional violations, as appropriate.
- the C2 collection includes a constraint with a Template type.
- the system may use the value U.S.A. from the Temporary Matching Value data structure 1002 to generate a relationship in the data graph between the Barack Obama node and the collection node Presidents of U.S.A. As indicated above, if this node does not already exist, the system may create it.
- the examples above refer to nodes and relationships by names or description. It is understood that the system may use other identifiers in the data structures, the indices, the constraints etc. without departing from disclosed implementations. As demonstrated, the system may determine a node's membership in every collection in the indices in one pass of the neighborhood because each path can be matched to constraints from different collections as the path is encountered. Thus, the system may calculate collection membership for a very large data graph efficiently. It is also understood that while the examples have been directed towards a system using conjunctive normal form for conditions, some implementations may use disjunctive normal form, where constraints within a condition are conjunctive, with appropriate modifications to the processes that determine collection membership in one pass.
- FIG. 1 1 shows an example of a generic computer device 1 100, which may be system 100, and/or client 180 of FIG. 1, which may be used with the techniques described here.
- Computing device 1 100 is intended to represent various example forms of computing devices, such as laptops, desktops, workstations, personal digital assistants, cellular telephones, smart phones, tablets, servers, and other computing devices, including wearable devices.
- the components shown here, their connections and relationships, and their functions, are meant to be examples only, and are not meant to limit implementations of the inventions described and/or claimed in this document.
- Computing device 1 100 includes a processor 1 102, memory 1 104, a storage device 1 106, and expansion ports 1 1 10 connected via an interface 1 108.
- computing device 1 100 may include transceiver 1 146, communication interface 1 144, and a GPS (Global Positioning System) receiver module 1 148, among other components, connected via interface 1 108.
- Device 1 100 may communicate wirelessly through communication interface 1 144, which may include digital signal processing circuitry where necessary.
- Each of the components 1 102, 1 104, 1 106, 1 108, 1 1 10, 1 140, 1 144, 1 146, and 1 148 may be mounted on a common motherboard or in other manners as appropriate.
- the processor 1 102 can process instructions for execution within the computing device 1 100, including instructions stored in the memory 1 104 or on the storage device 1 106 to display graphical information for a GUI on an external input/output device, such as display 1 116.
- Display 1 1 16 may be a monitor or a flat touchscreen display.
- multiple processors and/or multiple buses may be used, as appropriate, along with multiple memories and types of memory.
- multiple computing devices 1 100 may be connected, with each device providing portions of the necessary operations (e.g., as a server bank, a group of blade servers, or a multi-processor system).
- the memory 1 104 stores information within the computing device 1 100.
- the memory 1 104 is a volatile memory unit or units.
- the memory 1 104 is a non-volatile memory unit or units.
- the memory 1 104 may also be another form of computer-readable medium, such as a magnetic or optical disk.
- the memory 1 104 may include expansion memory provided through an expansion interface.
- the storage device 1 106 is capable of providing mass storage for the computing device 1 100.
- the storage device 1 106 may be or contain a computer-readable medium, such as a floppy disk device, a hard disk device, an optical disk device, or a tape device, a flash memory or other similar solid state memory device, or an array of devices, including devices in a storage area network or other configurations.
- a computer program product can be tangibly embodied in such a computer-readable medium.
- the computer program product may also contain instructions that, when executed, perform one or more methods, such as those described above.
- the computer- or machine-readable medium is a storage device such as the memory 1 104, the storage device 1 106, or memory on processor 1 102.
- the interface 1 108 may be a high speed controller that manages bandwidth-intensive operations for the computing device 1 100 or a low speed controller that manages lower bandwidth-intensive operations, or a combination of such controllers.
- An external interface 1 140 may be provided so as to enable near area communication of device 1 100 with other devices.
- controller 1 108 may be coupled to storage device 1 106 and expansion port 1 1 14.
- the expansion port which may include various communication ports (e.g., USB, Bluetooth, Ethernet, wireless Ethernet) may be coupled to one or more input/output devices, such as a keyboard, a pointing device, a scanner, or a networking device such as a switch or router, e.g., through a network adapter.
- the computing device 1 100 may be implemented in a number of different forms, as shown in the figure. For example, it may be implemented as a standard server 1 130, or multiple times in a group of such servers. It may also be implemented as part of a rack server system. In addition, it may be implemented in a personal computer such as a laptop computer 1 132, or smart phone 1 136. An entire system may be made up of multiple computing devices 1 100 communicating with each other. Other configurations are possible.
- FIG. 12 shows an example of a generic computer device 1200, which may be system 100 of FIG. 1 , which may be used with the techniques described here.
- Computing device 1200 is intended to represent various example forms of large-scale data processing devices, such as servers, blade servers, datacenters, mainframes, and other large-scale computing devices.
- Computing device 1200 may be a distributed system having multiple processors, possibly including network attached storage nodes, that are interconnected by one or more communication networks.
- the components shown here, their connections and relationships, and their functions, are meant to be examples only, and are not meant to limit implementations of the inventions described and/or claimed in this document.
- Distributed computing system 1200 may include any number of computing devices 3280.
- Computing devices 1280 may include a server or rack servers, mainframes, etc. communicating over a local or wide-area network, dedicated optical links, modems, bridges, routers, switches, wired or wireless networks, etc.
- each computing device may include multiple racks.
- computing device 1280a includes multiple racks 1258a - 1258n.
- Each rack may include one or more processors, such as processors 1252a-1252n and 1262a-1262n.
- the processors may include data processors, network attached storage devices, and other computer controlled devices.
- one processor may operate as a master processor and control the scheduling and data distribution tasks.
- Processors may be interconnected through one or more rack switches 1258, and one or more racks may be connected through switch 1278. Switch 1278 may handle communications between multiple connected computing devices 1200.
- Each rack may include memory, such as memory 1254 and memory 1264, and storage, such as 1256 and 1266.
- Storage 1256 and 1266 may provide mass storage and may include volatile or non-volatile storage, such as network-attached disks, floppy disks, hard disks, optical disks, tapes, flash memory or other similar solid state memory devices, or an array of devices, including devices in a storage area network or other configurations.
- Storage 1256 or 1266 may be shared between multiple processors, multiple racks, or multiple computing devices and may include a computer-readable medium storing instructions executable by one or more of the processors.
- Memory 1254 and 1264 may include, e.g., volatile memory unit or units, a non-volatile memory unit or units, and/or other forms of computer-readable media, such as a magnetic or optical disks, flash memory, cache, Random Access Memory (RAM), Read Only Memory (ROM), and combinations thereof. Memory, such as memory 1254 may also be shared between processors 1252a-1252n. Data structures, such as an index, may be stored, for example, across storage 1256 and memory 1254. Computing device 1200 may include other components not shown, such as controllers, buses, input/output devices, communications modules, etc.
- An entire system such as system 100, may be made up of multiple computing devices 1200 communicating with each other.
- device 1280a may communicate with devices 1280b, 1280c, and 1280d, and these may collectively be known as system 100.
- system 100 of FIG. 1 may include one or more computing devices 1200 as collection membership engine 150.
- some of the computing devices may be located geographically close to each other, and others may be located geographically distant.
- the layout of system 1200 is an example only and the system may take on other layouts or configurations.
- Various implementations can include implementation in one or more computer programs that are executable and/or interpretable on a programmable system including at least one programmable processor, which may be special or general purpose, coupled to receive data and instructions from, and to transmit data and instructions to, a storage system, at least one input device, and at least one output device.
- a programmable processor which may be special or general purpose, coupled to receive data and instructions from, and to transmit data and instructions to, a storage system, at least one input device, and at least one output device.
- the systems and techniques described here can be implemented in a computing system that includes a back end component (e.g., as a data server), or that includes a middleware component (e.g., an application server), or that includes a front end component (e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the systems and techniques described here), or any combination of such back end, middleware, or front end components.
- the components of the system can be interconnected by any form or medium of digital data communication (e.g., a communication network). Examples of communication networks include a local area network ("LAN”), a wide area network (“WAN”), and the Internet.
- LAN local area network
- WAN wide area network
- the Internet the global information network
- the computing system can include clients and servers, A client and server are generally remote from each other and typically interact through a communication network.
- the relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
Abstract
Description
Claims
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
PCT/CN2013/001213 WO2015051480A1 (en) | 2013-10-09 | 2013-10-09 | Automatic definition of entity collections |
Publications (2)
Publication Number | Publication Date |
---|---|
EP3055786A1 true EP3055786A1 (en) | 2016-08-17 |
EP3055786A4 EP3055786A4 (en) | 2017-05-17 |
Family
ID=52777820
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
EP13895222.1A Withdrawn EP3055786A4 (en) | 2013-10-09 | 2013-10-09 | Automatic definition of entity collections |
Country Status (4)
Country | Link |
---|---|
US (1) | US9454599B2 (en) |
EP (1) | EP3055786A4 (en) |
CN (1) | CN105706078B (en) |
WO (1) | WO2015051480A1 (en) |
Families Citing this family (91)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US9318108B2 (en) | 2010-01-18 | 2016-04-19 | Apple Inc. | Intelligent automated assistant |
US8977255B2 (en) | 2007-04-03 | 2015-03-10 | Apple Inc. | Method and system for operating a multi-function portable electronic device using voice-activation |
US8676904B2 (en) | 2008-10-02 | 2014-03-18 | Apple Inc. | Electronic devices with voice command and contextual data processing capabilities |
US10706373B2 (en) | 2011-06-03 | 2020-07-07 | Apple Inc. | Performing actions associated with task items that represent tasks to perform |
US10417037B2 (en) | 2012-05-15 | 2019-09-17 | Apple Inc. | Systems and methods for integrating third party services with a digital assistant |
CN104969289B (en) | 2013-02-07 | 2021-05-28 | 苹果公司 | Voice trigger of digital assistant |
US10652394B2 (en) | 2013-03-14 | 2020-05-12 | Apple Inc. | System and method for processing voicemail |
JP6343337B2 (en) * | 2013-03-15 | 2018-06-13 | ニューラ ラブス コーポレイション | Intelligent internet system with adaptive user interface providing one-step access to knowledge |
US10748529B1 (en) | 2013-03-15 | 2020-08-18 | Apple Inc. | Voice activated device for use with a voice-based digital assistant |
US10176167B2 (en) | 2013-06-09 | 2019-01-08 | Apple Inc. | System and method for inferring user intent from speech inputs |
US20180053114A1 (en) * | 2014-10-23 | 2018-02-22 | Brighterion, Inc. | Artificial intelligence for context classifier |
US9966065B2 (en) | 2014-05-30 | 2018-05-08 | Apple Inc. | Multi-command single utterance input method |
US10170123B2 (en) | 2014-05-30 | 2019-01-01 | Apple Inc. | Intelligent assistant for home automation |
US9715875B2 (en) | 2014-05-30 | 2017-07-25 | Apple Inc. | Reducing the need for manual start/end-pointing and trigger phrases |
US9338493B2 (en) | 2014-06-30 | 2016-05-10 | Apple Inc. | Intelligent automated assistant for TV user interactions |
US20160055427A1 (en) | 2014-10-15 | 2016-02-25 | Brighterion, Inc. | Method for providing data science, artificial intelligence and machine learning as-a-service |
US20150032589A1 (en) | 2014-08-08 | 2015-01-29 | Brighterion, Inc. | Artificial intelligence fraud management solution |
US20150066771A1 (en) | 2014-08-08 | 2015-03-05 | Brighterion, Inc. | Fast access vectors in real-time behavioral profiling |
US10657178B2 (en) * | 2014-08-22 | 2020-05-19 | Hewlett Packard Enterprise Development Lp | Processing of a generate entity type graph component of a graph analysis system |
US10990881B1 (en) * | 2014-08-26 | 2021-04-27 | Progress Software Corporation | Predictive analytics using sentence data model |
US10474680B2 (en) * | 2014-10-09 | 2019-11-12 | Splunk Inc. | Automatic entity definitions |
US20160063502A1 (en) | 2014-10-15 | 2016-03-03 | Brighterion, Inc. | Method for improving operating profits with better automated decision making with artificial intelligence |
US11080709B2 (en) | 2014-10-15 | 2021-08-03 | Brighterion, Inc. | Method of reducing financial losses in multiple payment channels upon a recognition of fraud first appearing in any one payment channel |
US10546099B2 (en) | 2014-10-15 | 2020-01-28 | Brighterion, Inc. | Method of personalizing, individualizing, and automating the management of healthcare fraud-waste-abuse to unique individual healthcare providers |
US9886953B2 (en) | 2015-03-08 | 2018-02-06 | Apple Inc. | Virtual assistant activation |
US20160283523A1 (en) | 2015-03-24 | 2016-09-29 | International Business Machines Corporation | Schema generation using natural language processing |
US20180130006A1 (en) | 2015-03-31 | 2018-05-10 | Brighterion, Inc. | Addrressable smart agent data technology to detect unauthorized transaction activity |
US10037388B2 (en) * | 2015-04-27 | 2018-07-31 | Microsoft Technology Licensing, Llc | Fast querying of social network data |
US10460227B2 (en) | 2015-05-15 | 2019-10-29 | Apple Inc. | Virtual assistant in a communication session |
US10200824B2 (en) | 2015-05-27 | 2019-02-05 | Apple Inc. | Systems and methods for proactively identifying and surfacing relevant content on a touch-sensitive device |
US20160350421A1 (en) * | 2015-06-01 | 2016-12-01 | Boyd Cannon Multerer | Personal searchable document collections with associated user references |
US20160378747A1 (en) | 2015-06-29 | 2016-12-29 | Apple Inc. | Virtual assistant for media playback |
US10769140B2 (en) * | 2015-06-29 | 2020-09-08 | Microsoft Technology Licensing, Llc | Concept expansion using tables |
EP3320457B1 (en) | 2015-07-10 | 2021-04-07 | Whether Or Knot LLC | System and method for electronic data distribution |
US10747498B2 (en) | 2015-09-08 | 2020-08-18 | Apple Inc. | Zero latency digital assistant |
US10671428B2 (en) | 2015-09-08 | 2020-06-02 | Apple Inc. | Distributed personal assistant |
US10740384B2 (en) | 2015-09-08 | 2020-08-11 | Apple Inc. | Intelligent automated assistant for media search and playback |
US10331312B2 (en) | 2015-09-08 | 2019-06-25 | Apple Inc. | Intelligent automated assistant in a media environment |
US9959311B2 (en) * | 2015-09-18 | 2018-05-01 | International Business Machines Corporation | Natural language interface to databases |
US10691473B2 (en) | 2015-11-06 | 2020-06-23 | Apple Inc. | Intelligent automated assistant in a messaging environment |
US10956666B2 (en) | 2015-11-09 | 2021-03-23 | Apple Inc. | Unconventional virtual assistant interactions |
US10223066B2 (en) | 2015-12-23 | 2019-03-05 | Apple Inc. | Proactive assistance based on dialog communication between devices |
US10586535B2 (en) | 2016-06-10 | 2020-03-10 | Apple Inc. | Intelligent digital assistant in a multi-tasking environment |
DK201670540A1 (en) | 2016-06-11 | 2018-01-08 | Apple Inc | Application integration with a digital assistant |
DK179415B1 (en) | 2016-06-11 | 2018-06-14 | Apple Inc | Intelligent device arbitration and control |
US10423652B2 (en) * | 2016-08-08 | 2019-09-24 | Baidu Usa Llc | Knowledge graph entity reconciler |
US20180060417A1 (en) * | 2016-08-08 | 2018-03-01 | Dialectica, Llc | Dialectical information architecture |
US9836183B1 (en) * | 2016-09-14 | 2017-12-05 | Quid, Inc. | Summarized network graph for semantic similarity graphs of large corpora |
JP6310532B1 (en) * | 2016-11-24 | 2018-04-11 | ヤフー株式会社 | Generating device, generating method, and generating program |
US11204787B2 (en) | 2017-01-09 | 2021-12-21 | Apple Inc. | Application integration with a digital assistant |
US10726832B2 (en) | 2017-05-11 | 2020-07-28 | Apple Inc. | Maintaining privacy of personal information |
DK180048B1 (en) | 2017-05-11 | 2020-02-04 | Apple Inc. | MAINTAINING THE DATA PROTECTION OF PERSONAL INFORMATION |
DK179496B1 (en) | 2017-05-12 | 2019-01-15 | Apple Inc. | USER-SPECIFIC Acoustic Models |
DK179745B1 (en) | 2017-05-12 | 2019-05-01 | Apple Inc. | SYNCHRONIZATION AND TASK DELEGATION OF A DIGITAL ASSISTANT |
DK201770427A1 (en) | 2017-05-12 | 2018-12-20 | Apple Inc. | Low-latency intelligent automated assistant |
US10303715B2 (en) | 2017-05-16 | 2019-05-28 | Apple Inc. | Intelligent automated assistant for media exploration |
US20180336892A1 (en) | 2017-05-16 | 2018-11-22 | Apple Inc. | Detecting a trigger of a digital assistant |
US20180349472A1 (en) * | 2017-06-02 | 2018-12-06 | Apple Inc. | Methods and systems for providing query suggestions |
US10789425B2 (en) * | 2017-06-05 | 2020-09-29 | Lenovo (Singapore) Pte. Ltd. | Generating a response to a natural language command based on a concatenated graph |
US10534592B2 (en) * | 2017-08-07 | 2020-01-14 | Sap Se | Template expressions for constraint-based systems |
US10818288B2 (en) | 2018-03-26 | 2020-10-27 | Apple Inc. | Natural assistant interaction |
US11145294B2 (en) | 2018-05-07 | 2021-10-12 | Apple Inc. | Intelligent automated assistant for delivering content from user experiences |
US10928918B2 (en) | 2018-05-07 | 2021-02-23 | Apple Inc. | Raise to speak |
US10892996B2 (en) | 2018-06-01 | 2021-01-12 | Apple Inc. | Variable latency device coordination |
DK180639B1 (en) | 2018-06-01 | 2021-11-04 | Apple Inc | DISABILITY OF ATTENTION-ATTENTIVE VIRTUAL ASSISTANT |
DK179822B1 (en) | 2018-06-01 | 2019-07-12 | Apple Inc. | Voice interaction at a primary device to access call functionality of a companion device |
RU2688250C1 (en) * | 2018-08-14 | 2019-05-21 | Илья Александрович Шарков | Method of displaying content of a personal database on a computer screen |
CN110866389B (en) * | 2018-08-17 | 2021-12-17 | 北大方正集团有限公司 | Information value evaluation method, device, equipment and computer readable storage medium |
US11462215B2 (en) | 2018-09-28 | 2022-10-04 | Apple Inc. | Multi-modal inputs for voice commands |
US11475898B2 (en) | 2018-10-26 | 2022-10-18 | Apple Inc. | Low-latency multi-speaker speech recognition |
US11348573B2 (en) | 2019-03-18 | 2022-05-31 | Apple Inc. | Multimodality in digital assistant systems |
US11307752B2 (en) | 2019-05-06 | 2022-04-19 | Apple Inc. | User configurable task triggers |
US11475884B2 (en) | 2019-05-06 | 2022-10-18 | Apple Inc. | Reducing digital assistant latency when a language is incorrectly determined |
US11423908B2 (en) | 2019-05-06 | 2022-08-23 | Apple Inc. | Interpreting spoken requests |
DK201970509A1 (en) | 2019-05-06 | 2021-01-15 | Apple Inc | Spoken notifications |
US11140099B2 (en) | 2019-05-21 | 2021-10-05 | Apple Inc. | Providing message response suggestions |
US11496600B2 (en) | 2019-05-31 | 2022-11-08 | Apple Inc. | Remote execution of machine-learned models |
US11289073B2 (en) | 2019-05-31 | 2022-03-29 | Apple Inc. | Device text to speech |
DK201970510A1 (en) | 2019-05-31 | 2021-02-11 | Apple Inc | Voice identification in digital assistant systems |
DK180129B1 (en) | 2019-05-31 | 2020-06-02 | Apple Inc. | User activity shortcut suggestions |
US11227599B2 (en) | 2019-06-01 | 2022-01-18 | Apple Inc. | Methods and user interfaces for voice-based control of electronic devices |
US11360641B2 (en) | 2019-06-01 | 2022-06-14 | Apple Inc. | Increasing the relevance of new available information |
US11488406B2 (en) | 2019-09-25 | 2022-11-01 | Apple Inc. | Text detection using global geometry estimators |
CN110781354B (en) * | 2019-10-24 | 2022-06-10 | 北京齐尔布莱特科技有限公司 | Object selection method, device and system and computing equipment |
US11043220B1 (en) | 2020-05-11 | 2021-06-22 | Apple Inc. | Digital assistant hardware abstraction |
US11061543B1 (en) | 2020-05-11 | 2021-07-13 | Apple Inc. | Providing relevant data items based on context |
US11755276B2 (en) | 2020-05-12 | 2023-09-12 | Apple Inc. | Reducing description length based on confidence |
US11490204B2 (en) | 2020-07-20 | 2022-11-01 | Apple Inc. | Multi-device audio adjustment coordination |
US11438683B2 (en) | 2020-07-21 | 2022-09-06 | Apple Inc. | User identification using headphones |
CN114297411B (en) * | 2022-03-08 | 2023-05-02 | 支付宝(杭州)信息技术有限公司 | Configuration method, analysis method and device of entities in knowledge graph |
CN114692644A (en) * | 2022-03-11 | 2022-07-01 | 粤港澳大湾区数字经济研究院(福田) | Text entity labeling method, device, equipment and storage medium |
Family Cites Families (59)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6128613A (en) * | 1997-06-26 | 2000-10-03 | The Chinese University Of Hong Kong | Method and apparatus for establishing topic word classes based on an entropy cost function to retrieve documents represented by the topic words |
US6167370A (en) | 1998-09-09 | 2000-12-26 | Invention Machine Corporation | Document semantic analysis/selection with knowledge creativity capability utilizing subject-action-object (SAO) structures |
US7925610B2 (en) | 1999-09-22 | 2011-04-12 | Google Inc. | Determining a meaning of a knowledge item using document-based information |
US8051104B2 (en) | 1999-09-22 | 2011-11-01 | Google Inc. | Editing a network of interconnected concepts |
US6665863B1 (en) * | 2000-05-31 | 2003-12-16 | Microsoft Corporation | Data referencing within a database graph |
WO2002084590A1 (en) | 2001-04-11 | 2002-10-24 | Applied Minds, Inc. | Knowledge web |
US6946715B2 (en) * | 2003-02-19 | 2005-09-20 | Micron Technology, Inc. | CMOS image sensor and method of fabrication |
WO2004055647A2 (en) | 2002-12-13 | 2004-07-01 | Applied Minds, Inc. | Meta-web |
WO2004090754A1 (en) | 2003-04-04 | 2004-10-21 | Yahoo! Inc. | A system for generating search results including searching by subdomain hints and providing sponsored results by subdomain |
US7769579B2 (en) | 2005-05-31 | 2010-08-03 | Google Inc. | Learning facts from semi-structured text |
CN1645361A (en) * | 2005-01-26 | 2005-07-27 | 上海大学 | Device and method for broad normalization |
US7587387B2 (en) | 2005-03-31 | 2009-09-08 | Google Inc. | User interface for facts query engine with snippets from information sources that include query terms and answer terms |
CN101305366B (en) * | 2005-11-29 | 2013-02-06 | 国际商业机器公司 | Method and system for extracting and visualizing graph-structured relations from unstructured text |
US7774328B2 (en) | 2006-02-17 | 2010-08-10 | Google Inc. | Browseable fact repository |
US7933915B2 (en) * | 2006-02-27 | 2011-04-26 | The Regents Of The University Of California | Graph querying, graph motif mining and the discovery of clusters |
JP5028847B2 (en) | 2006-04-21 | 2012-09-19 | 富士通株式会社 | Gene interaction network analysis support program, recording medium recording the program, gene interaction network analysis support method, and gene interaction network analysis support device |
US8122026B1 (en) | 2006-10-20 | 2012-02-21 | Google Inc. | Finding and disambiguating references to entities on web pages |
US8204856B2 (en) | 2007-03-15 | 2012-06-19 | Google Inc. | Database replication |
US20100121839A1 (en) | 2007-03-15 | 2010-05-13 | Scott Meyer | Query optimization |
US7672937B2 (en) | 2007-04-11 | 2010-03-02 | Yahoo, Inc. | Temporal targeting of advertisements |
US8069127B2 (en) * | 2007-04-26 | 2011-11-29 | 21 Ct, Inc. | Method and system for solving an optimization problem with dynamic constraints |
US7822774B2 (en) | 2007-06-11 | 2010-10-26 | Microsoft Corporation | Using link structure for suggesting related queries |
CN100465888C (en) * | 2007-08-03 | 2009-03-04 | 中国科学院软件研究所 | Method for automatically establishing procedure body |
US20090094211A1 (en) | 2007-10-05 | 2009-04-09 | Fujitsu Limited | Implementing an expanded search and providing expanded search results |
CN100470554C (en) * | 2007-11-09 | 2009-03-18 | 清华大学 | Individual relation finding method based on path grade at large scale community network |
US7792837B1 (en) | 2007-11-14 | 2010-09-07 | Google Inc. | Entity name recognition |
US20090249198A1 (en) * | 2008-04-01 | 2009-10-01 | Yahoo! Inc. | Techniques for input recogniton and completion |
US20110295857A1 (en) * | 2008-06-20 | 2011-12-01 | Ai Ti Aw | System and method for aligning and indexing multilingual documents |
CN101630314B (en) * | 2008-07-16 | 2011-12-07 | 中国科学院自动化研究所 | Semantic query expansion method based on domain knowledge |
US20100185994A1 (en) | 2008-08-14 | 2010-07-22 | Pikus Fedor G | Topological Pattern Matching |
US8370128B2 (en) | 2008-09-30 | 2013-02-05 | Xerox Corporation | Semantically-driven extraction of relations between named entities |
US8145626B2 (en) * | 2008-12-31 | 2012-03-27 | Sap Ag | Method and system for data processing using multidimensional filtering |
WO2010085523A1 (en) | 2009-01-21 | 2010-07-29 | Metaweb Technologies, Inc. | Graph store |
US8458171B2 (en) * | 2009-01-30 | 2013-06-04 | Google Inc. | Identifying query aspects |
US8145636B1 (en) * | 2009-03-13 | 2012-03-27 | Google Inc. | Classifying text into hierarchical categories |
CN101515287B (en) * | 2009-03-24 | 2011-01-12 | 苏州普达新信息技术有限公司 | Automatic generating method of wrapper of complex page |
US9141911B2 (en) * | 2009-05-29 | 2015-09-22 | Aspen Technology, Inc. | Apparatus and method for automated data selection in model identification and adaptation in multivariable process control |
CN101587493B (en) * | 2009-06-29 | 2012-07-04 | 中国科学技术大学 | Text classification method |
CN101996287B (en) | 2009-08-13 | 2012-09-05 | 财团法人资讯工业策进会 | Method and system for removing malicious software |
US8583673B2 (en) | 2009-08-17 | 2013-11-12 | Microsoft Corporation | Progressive filtering of search results |
US9195905B2 (en) | 2010-03-10 | 2015-11-24 | Siemens Aktiengesellschaft | Method and system for graph based interactive detection of curve structures in 2D fluoroscopy |
US8782080B2 (en) * | 2010-04-19 | 2014-07-15 | Facebook, Inc. | Detecting social graph elements for structured search queries |
US8732208B2 (en) * | 2010-04-19 | 2014-05-20 | Facebook, Inc. | Structured search queries based on social-graph information |
US8180804B1 (en) * | 2010-04-19 | 2012-05-15 | Facebook, Inc. | Dynamically generating recommendations based on social graph information |
US8751521B2 (en) * | 2010-04-19 | 2014-06-10 | Facebook, Inc. | Personalized structured search queries for online social networks |
KR101781416B1 (en) * | 2010-06-22 | 2017-09-25 | 아브 이니티오 테크놀로지 엘엘시 | Processing related datasets |
US8533225B2 (en) * | 2010-09-27 | 2013-09-10 | Google Inc. | Representing and processing inter-slot constraints on component selection for dynamic ads |
US8725739B2 (en) * | 2010-11-01 | 2014-05-13 | Evri, Inc. | Category-based content recommendation |
US9116995B2 (en) * | 2011-03-30 | 2015-08-25 | Vcvc Iii Llc | Cluster-based identification of news stories |
US20120317088A1 (en) * | 2011-06-07 | 2012-12-13 | Microsoft Corporation | Associating Search Queries and Entities |
CN102262658B (en) * | 2011-07-13 | 2013-10-16 | 东北大学 | Method for extracting web data from bottom to top based on entity |
CN102332009B (en) * | 2011-09-02 | 2013-09-04 | 北京大学 | Relational query method implemented on large-scale data set |
JP5866922B2 (en) | 2011-09-22 | 2016-02-24 | 富士ゼロックス株式会社 | Search device and program |
US20130212081A1 (en) * | 2012-02-13 | 2013-08-15 | Microsoft Corporation | Identifying additional documents related to an entity in an entity graph |
CN102750316B (en) * | 2012-04-25 | 2015-10-28 | 北京航空航天大学 | Based on the conceptual relation label abstracting method of semantic co-occurrence patterns |
US20140025702A1 (en) * | 2012-07-23 | 2014-01-23 | Michael Curtiss | Filtering Structured Search Queries Based on Privacy Settings |
CN102880687B (en) * | 2012-09-14 | 2015-07-29 | 北京大学 | Based on individual interactive data retrieval method and the system thereof of label technique |
CN102999563A (en) * | 2012-11-01 | 2013-03-27 | 无锡成电科大科技发展有限公司 | Network resource semantic retrieval method and system based on resource description framework |
WO2015051481A1 (en) | 2013-10-09 | 2015-04-16 | Google Inc. | Determining collection membership in a data graph |
-
2013
- 2013-10-09 EP EP13895222.1A patent/EP3055786A4/en not_active Withdrawn
- 2013-10-09 WO PCT/CN2013/001213 patent/WO2015051480A1/en active Application Filing
- 2013-10-09 CN CN201380080179.XA patent/CN105706078B/en active Active
-
2014
- 2014-02-21 US US14/186,320 patent/US9454599B2/en active Active
Also Published As
Publication number | Publication date |
---|---|
US9454599B2 (en) | 2016-09-27 |
CN105706078B (en) | 2021-08-03 |
US20150100568A1 (en) | 2015-04-09 |
EP3055786A4 (en) | 2017-05-17 |
CN105706078A (en) | 2016-06-22 |
WO2015051480A1 (en) | 2015-04-16 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US9454599B2 (en) | Automatic definition of entity collections | |
US11573996B2 (en) | System and method for hierarchically organizing documents based on document portions | |
US20150100605A1 (en) | Determining collection membership in a data graph | |
Nagwani | Summarizing large text collection using topic modeling and clustering based on MapReduce framework | |
Deshpande et al. | Building, maintaining, and using knowledge bases: a report from the trenches | |
US11853334B2 (en) | Systems and methods for generating and using aggregated search indices and non-aggregated value storage | |
Adamu et al. | A survey on big data indexing strategies | |
CN113190687A (en) | Knowledge graph determining method and device, computer equipment and storage medium | |
Sagi et al. | Artificial intelligence for ocean science data integration: current state, gaps, and way forward | |
Franciscus et al. | Precomputing architecture for flexible and efficient big data analytics | |
Kumar | Apache Solr search patterns | |
IL230065A (en) | Preference-guided data exploration and semantic processing | |
Zhao et al. | A citation recommendation method based on context correlation | |
Wang et al. | Deep learning-based open api recommendation for mashup development | |
Paradies et al. | Entity matching for semistructured data in the Cloud | |
Aljarallah | Comparative study of database modeling approaches | |
CN109446440B (en) | Deep network query interface integration method, system, computing device and storage medium | |
Fan et al. | CICHMKG: a large-scale and comprehensive Chinese intangible cultural heritage multimodal knowledge graph | |
Chang et al. | Authorrank: a new scheme for identifying field-specific key researchers | |
Leginus et al. | Graph based techniques for tag cloud generation | |
Dong | Providing best-effort services in dataspace systems | |
Ma et al. | Entity Disambiguation with Markov Logic Network Knowledge Graphs | |
Shao et al. | The Disambiguation Strategy of Knowledge Fusion for Domain Knowledge Graph | |
Yu et al. | Web of Conferences: A Conference Knowledge Graph | |
Jabeen et al. | Core Architecture and Design Issues of Collaborative Tagging Applications’ |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PUAI | Public reference made under article 153(3) epc to a published international application that has entered the european phase |
Free format text: ORIGINAL CODE: 0009012 |
|
17P | Request for examination filed |
Effective date: 20160321 |
|
AK | Designated contracting states |
Kind code of ref document: A1Designated state(s): AL AT BE BG CH CY CZ DE DK EE ES FI FR GB GR HR HU IE IS IT LI LT LU LV MC MK MT NL NO PL PT RO RS SE SI SK SM TR |
|
AX | Request for extension of the european patent |
Extension state: BA ME |
|
DAX | Request for extension of the european patent (deleted) | ||
A4 | Supplementary search report drawn up and despatched |
Effective date: 20170421 |
|
RIC1 | Information provided on ipc code assigned before grant |
Ipc: G06N 5/02 20060101ALI20170413BHEPIpc: G06F 17/30 20060101AFI20170413BHEP |
|
RAP1 | Party data changed (applicant data changed or rights of an application transferred) |
Owner name: GOOGLE LLC |
|
17Q | First examination report despatched |
Effective date: 20190503 |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: EXAMINATION IS IN PROGRESS |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: THE APPLICATION HAS BEEN WITHDRAWN |
|
18W | Application withdrawn |
Effective date: 20210325 |
|
P01 | Opt-out of the competence of the unified patent court (upc) registered |
Effective date: 20230519 |