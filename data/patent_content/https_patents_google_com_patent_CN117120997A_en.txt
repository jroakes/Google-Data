CN117120997A - Supporting extensible databases with robust query performance - Google Patents
Supporting extensible databases with robust query performance Download PDFInfo
- Publication number
- CN117120997A CN117120997A CN202280028408.2A CN202280028408A CN117120997A CN 117120997 A CN117120997 A CN 117120997A CN 202280028408 A CN202280028408 A CN 202280028408A CN 117120997 A CN117120997 A CN 117120997A
- Authority
- CN
- China
- Prior art keywords
- data
- adms
- framework
- query
- tables
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
- 230000037406 food intake Effects 0.000 claims abstract description 40
- 238000013523 data management Methods 0.000 claims abstract description 10
- 238000003860 storage Methods 0.000 claims description 58
- 238000000034 method Methods 0.000 claims description 36
- 238000007906 compression Methods 0.000 claims description 23
- 230000006835 compression Effects 0.000 claims description 23
- 230000015654 memory Effects 0.000 claims description 20
- 238000005457 optimization Methods 0.000 claims description 8
- 230000004931 aggregating effect Effects 0.000 claims description 4
- 230000000670 limiting effect Effects 0.000 claims description 3
- 239000000872 buffer Substances 0.000 claims description 2
- 230000003362 replicative effect Effects 0.000 claims description 2
- 239000012536 storage buffer Substances 0.000 claims 1
- 230000010076 replication Effects 0.000 abstract description 7
- 238000012423 maintenance Methods 0.000 description 26
- 238000012545 processing Methods 0.000 description 24
- 230000008569 process Effects 0.000 description 9
- 238000010586 diagram Methods 0.000 description 8
- 230000002776 aggregation Effects 0.000 description 6
- 238000004220 aggregation Methods 0.000 description 6
- 230000000694 effects Effects 0.000 description 6
- 230000001934 delay Effects 0.000 description 5
- 238000005192 partition Methods 0.000 description 5
- 238000000638 solvent extraction Methods 0.000 description 5
- 230000008901 benefit Effects 0.000 description 4
- 238000004590 computer program Methods 0.000 description 4
- 230000006870 function Effects 0.000 description 4
- 230000007246 mechanism Effects 0.000 description 4
- 230000000737 periodic effect Effects 0.000 description 4
- 230000002829 reductive effect Effects 0.000 description 4
- 238000013459 approach Methods 0.000 description 3
- 230000009286 beneficial effect Effects 0.000 description 3
- 238000004891 communication Methods 0.000 description 3
- 239000000835 fiber Substances 0.000 description 3
- 238000001914 filtration Methods 0.000 description 3
- 238000007726 management method Methods 0.000 description 3
- 230000036961 partial effect Effects 0.000 description 3
- 230000002688 persistence Effects 0.000 description 3
- 230000009467 reduction Effects 0.000 description 3
- 230000001360 synchronised effect Effects 0.000 description 3
- 230000003321 amplification Effects 0.000 description 2
- 238000004458 analytical method Methods 0.000 description 2
- 230000005540 biological transmission Effects 0.000 description 2
- 230000003111 delayed effect Effects 0.000 description 2
- 230000000116 mitigating effect Effects 0.000 description 2
- 238000003199 nucleic acid amplification method Methods 0.000 description 2
- 238000013515 script Methods 0.000 description 2
- 230000001133 acceleration Effects 0.000 description 1
- 230000009471 action Effects 0.000 description 1
- 238000003491 array Methods 0.000 description 1
- 238000013473 artificial intelligence Methods 0.000 description 1
- 230000004888 barrier function Effects 0.000 description 1
- 230000008859 change Effects 0.000 description 1
- 238000006243 chemical reaction Methods 0.000 description 1
- 238000007596 consolidation process Methods 0.000 description 1
- 238000007405 data analysis Methods 0.000 description 1
- 238000013135 deep learning Methods 0.000 description 1
- 230000000593 degrading effect Effects 0.000 description 1
- 230000001419 dependent effect Effects 0.000 description 1
- 238000005516 engineering process Methods 0.000 description 1
- 239000004744 fabric Substances 0.000 description 1
- 238000011010 flushing procedure Methods 0.000 description 1
- 230000002452 interceptive effect Effects 0.000 description 1
- 238000011031 large-scale manufacturing process Methods 0.000 description 1
- 238000010801 machine learning Methods 0.000 description 1
- 230000014759 maintenance of location Effects 0.000 description 1
- 238000013507 mapping Methods 0.000 description 1
- 239000003550 marker Substances 0.000 description 1
- 238000005259 measurement Methods 0.000 description 1
- 230000035772 mutation Effects 0.000 description 1
- 230000006855 networking Effects 0.000 description 1
- 230000003287 optical effect Effects 0.000 description 1
- 238000013439 planning Methods 0.000 description 1
- 229920001690 polydopamine Polymers 0.000 description 1
- 238000012805 post-processing Methods 0.000 description 1
- 238000013138 pruning Methods 0.000 description 1
- 238000000926 separation method Methods 0.000 description 1
- 239000007787 solid Substances 0.000 description 1
- 230000003068 static effect Effects 0.000 description 1
- 230000007704 transition Effects 0.000 description 1
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/24—Querying
- G06F16/245—Query processing
- G06F16/2457—Query processing with adaptation to user needs
- G06F16/24573—Query processing with adaptation to user needs using data annotations, e.g. user-defined metadata
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/23—Updating
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/21—Design, administration or maintenance of databases
- G06F16/217—Database tuning
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/21—Design, administration or maintenance of databases
- G06F16/219—Managing data history or versioning
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/22—Indexing; Data structures therefor; Storage structures
- G06F16/2282—Tablespace storage structures; Management thereof
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/23—Updating
- G06F16/2308—Concurrency control
- G06F16/2315—Optimistic concurrency control
- G06F16/2322—Optimistic concurrency control using timestamps
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/23—Updating
- G06F16/2379—Updates performed during online database operations; commit processing
- G06F16/2386—Bulk updating operations
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/24—Querying
- G06F16/245—Query processing
- G06F16/2455—Query execution
- G06F16/24553—Query execution of query operations
- G06F16/24554—Unary operations; Data partitioning operations
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/24—Querying
- G06F16/245—Query processing
- G06F16/2458—Special types of queries, e.g. statistical queries, fuzzy queries or distributed queries
- G06F16/2471—Distributed queries
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/24—Querying
- G06F16/245—Query processing
- G06F16/2458—Special types of queries, e.g. statistical queries, fuzzy queries or distributed queries
- G06F16/2474—Sequence data queries, e.g. querying versioned data
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/46—Multiprogramming arrangements
- G06F9/466—Transaction processing
Abstract
The present disclosure describes an Analytical Data Management System (ADMS) that serves critical dashboards, applications, and internal users. Such ADMS have high scalability, availability through replication and failover, high user query load, and large data volumes. ADMS provides continuous ingestion and freshness-tunable high performance queries. It further pushes the decentralized idea by decoupling its architectural components (ingest, index and query). Thus, the impact of index speed slowdown on query performance can be minimized by sacrificing data freshness or increasing cost.
Description
Cross Reference to Related Applications
The present application claims the benefit of the filing date of U.S. provisional patent application No. 63/174,692 filed on 4/14 of 2021, the disclosure of which is incorporated herein by reference.
Background
Service providers of internet services may rely on application data to provide better user experience, improve quality of service and billing. Business users interact with this data through complex analysis fronts to gain insight into their business. These front ends issue complex analytical queries on large amounts of data and impose strict time constraints, in some cases service level objectives on the order of milliseconds. There are multiple beats of such data and are continually updated by a large-scale stream of planet-scale updates. Users require consistent, fresh results of queries and continuous availability in the face of data center failures or network partitions.
There are many commercial products for analytical data management. Technological advances in these business systems include column storage, query optimization, and various designs for writing optimization indexes and updating optimization indexes. Traditional data analysis systems have evolved from tightly coupled storage and computation to decentralized models of storage and computation decoupling to take advantage of cloud computing paradigms.
Disclosure of Invention
The present disclosure describes an Analytical Data Management System (ADMS) that serves critical dashboards, applications, and internal users. Such ADMS have high scalability, availability through replication and failover, high user query load, and large data volumes. ADMS provides continuous ingestion and freshness-tunable high performance queries. It further advances the decentralized idea by decoupling its architectural components (ingestion, indexing, and querying). Thus, the impact of slowing down the index speed on query performance can be minimized by sacrificing data freshness or increasing cost.
While current data management storage systems typically rely on scanning by column storage, parallelism, and compression acceleration, the ADMS described herein relies on views to ensure robust query performance. Optimized views are inserted for continuous high bandwidth using a Log Structured Merge (LSM) forest. ADMS provides clients with flexibly configurable parameters of query performance, freshness, and cost. The Queriable Timestamp (QT) provides a real-time marker or indicator of customer database productivity versus the requirements. Because of the configurability of the ADMS, the same system under different configurations can meet cost-conscious customers as well as high performance and freshness requirements.
According to the examples described herein, ADMS is a fully indexed system that is optimized for efficient incremental maintenance of key lookups, range scans, and indexes on tables and views. It can easily support ad hoc queries and highly selective and less diverse queries. It is a multi-tenant, multi-homed, distributed, globally replicated data management system that can be used by mission critical applications. It provides a single database-level queriable timestamp, meaning that a user can refer to and query multiple tables and views in a consistent manner. It also supports views with full SQL commonality; their subsets may be maintained constantly.
B-trees are the primary index structure in many conventional database management systems. According to the examples described herein, ADMS uses a variant of the b+ tree that exploits the fact that the ADMS table has multiple parts of keys. Furthermore, min/max keys, per column min/max are stored with each non-leaf block to achieve efficient pruning. A log-structured merge tree (LSM) employs B-tree indexing to achieve high update rates. ADMS belongs to the class of LSM systems that trade high write throughput for fast reading. The write operations are written to the level files, which are compressed to form a larger level file. The read operation merges these at runtime. The efficiency of an LSM data structure is measured by "write amplification" or the number of times an input row is written to disk (across all levels).
One aspect of the present disclosure provides an Analytical Data Management System (ADMS) comprising an ingestion framework configured to submit updates into one or more data tables stored in memory; a storage framework configured to compress the one or more tables and incrementally apply the updates to the one or more tables; and a query service framework configured to respond to client queries. Compressing the one or more tables may include merging a plurality of delta updates before applying the updates to the one or more tables.
The query service framework may direct queries to pre-computed materialized views. The one or more tables comprising the pre-computed materialized view may be ordered, indexed, and scoped by primary key.
According to some examples, the data plane includes the ingest, storage, and query service frameworks, and the control plane includes a controller, wherein the controller coordinates work between the ingest, storage, and query service frameworks.
According to some examples, the controller schedules compression and view update tasks. The controller may coordinate metadata transactions across multiple data centers.
The ingestion framework may be configured to ingest rows of data, each row of data being assigned a metadata timestamp. Ingest of multiple lines of data may include batching, aggregating, and copying data. The ingestion framework may include a plurality of copies located at different geographic locations, wherein the framework is configured to ingest the data at any of the plurality of copies.
According to some examples, each table has a queriable timestamp indicating the freshness of the data that can be queried. The freshness may be represented by a period of time equal to the current time minus the queriable timestamp. Any data ingested after the queriable timestamp may be hidden from client queries. The queriable time stamp may be updated when the data being ingested is optimized to meet predefined query performance requirements. The parameters of freshness, performance and cost are reconfigurable.
Another aspect of the present disclosure provides a method of managing an Analytical Data Management System (ADMS) that includes using an ingestion framework, submitting updates to one or more data tables stored in memory, using a storage framework, compressing the one or more tables, and incrementally applying the updates to the one or more tables, and responding to client queries using a query service framework. According to some examples, the method may further include coordinating, using a controller in a control plane, work in a data plane containing the ingestion framework, storage framework, and query service framework. The method may further include scheduling compression and view update tasks using the controller, and coordinating metadata transactions across multiple data centers using the controller. According to some examples, the method may further include ingesting a plurality of rows of data using the ingestion framework, each row of data being assigned a metadata timestamp. Each table may have a queriable timestamp indicating the freshness of the data that may be queried and any data ingested after the queriable timestamp is hidden from client queries. The method may further include optimizing the ingested data to meet predefined query performance requirements, and updating the queriable timestamp when the ingested data is optimized.
Drawings
Fig. 1 is a conceptual block diagram illustrating components of an Analytical Data Management System (ADMS) according to aspects of the present disclosure.
Fig. 2 is a block diagram illustrating an architecture of an ADMS according to aspects of the present disclosure.
Fig. 3 is a schematic diagram illustrating ingestion of an ADMS according to aspects of the present disclosure.
Fig. 4 is a timing diagram illustrating queriable timestamps according to aspects of the present disclosure.
Fig. 5A-C illustrate different categories according to aspects of the present disclosure.
Fig. 6 is a flow chart illustrating a method of client query service according to aspects of the present disclosure.
Fig. 7A-B are graphs illustrating delay measurements associated with ADMS according to aspects of the present disclosure.
Fig. 8 is a block diagram illustrating an example system in accordance with aspects of the present disclosure.
Fig. 9 is a flow chart illustrating an example method of ingestion in accordance with aspects of the present disclosure.
Fig. 10 is a flow chart illustrating an example method of querying a service in accordance with aspects of the present disclosure.
Detailed Description
ADMS can serve many applications with different requirements on query performance, data freshness, and cost targets. Query performance and query delay may be used interchangeably herein. Data freshness is measured by the time between the time a row is added to the table and the time the row is available for querying. Freshness requirements range from a few minutes for freshness sensitive customers to a few hours for cost sensitive customers. Costs may include, for example, machine resource costs due to data processing. Examples of such costs include ingestion costs, background maintenance operations, and query execution. In general, intake and maintenance costs are dominant.
Flexibility of
Client requirements may change in the general categories of data freshness, resource cost, and query performance. Some clients require high freshness, while others may wish to optimize original query performance or reduce cost.
Intake and storage may be coupled. Ingest refers to presenting data to the ADMS and beginning to incorporate it into the system. Storage refers to all materialized views of new data and its impact that have been applied to the base table. It may be undesirable to set constraints such that new data cannot be ingested until it is fully processed, or that new data is coupled with the query, thereby degrading query performance. ADMS provides clients with flexibility to adjust the system and meets their goals in terms of data freshness, resource cost, and query performance.
Fig. 1 is a conceptual block diagram illustrating components of an ADMS. ADMS is highly scalable to handle update flows and serve millions of queries simultaneously with good performance. ADMS relies on materialized views for predictable and high query performance.
As shown in FIG. 1, the high-level architecture of the ADMS includes three main components, an ingest framework 110, a storage framework 120, and a query service 130.
The ingestion framework 110 ingests lines of data at a high rate, such as tens of GB/s of compressed data. It is responsible for submitting updates or "deltas" into the table. Such an increment may be, for example, one or more additional rows in a database table, a set of updates to one or more tables, or any of a variety of other types of updates. The delta written by the ingestion framework 110 is used to meet the persistence requirements of the ingestion framework 110 and is write optimized. These increments may be further consolidated before they can be applied to the table and its associated view.
The storage framework 120 incrementally applies updates to the table and its views. ADMS tables and their views can be maintained incrementally as LSM forests, with each table being a collection of updates. The increments may be continually combined during compression to form larger increments. The view maintenance layer converts the table increment into a view increment by applying corresponding SQL conversion. The storage layer is also responsible for regularly compressing tables and views. It maintains materialized views that are indexed and consistent among the data centers.
The query services framework 130 is responsible for answering client queries. The system performs the necessary incremental merging of the tables (or views) at query time. The query delay is a function of the amount of query time merge effort, so the faster the storage subsystem processes updates, the fewer increments that need to be merged at the query time.
The ADMS decouples ingestion from view maintenance and couples view maintenance from query understanding. This decoupling provides ADMS clients with knobs that meet their requirements, allowing trade-offs between freshness, performance, and cost. ADMS requires consistency of base tables and views, so decoupling ensures that ADMS can continue to advance regardless of the performance of individual components. The term "knob" may refer to the availability of configurable options. Ingestion relies only on initial run generation (such as submitting updates) and not on merging or view maintenance. ADMS also provides a high level of selection for clients, can translate into selective index data, and limits the amount of merging at the time of query.
The ADMS client may choose "low workload" to optimize costs, accepting reduced query performance. "Low workload" means no aggressive compression, such that there is a higher merge workload when the query is executed. Low workload may also represent fewer materialized views, or reduced freshness, while still maintaining good query performance on queries matching the views. Similarly, the client may also choose to optimize good query performance by paying "higher workload", such as more aggressive compression, which will result in low fan-in merging at query time, or may choose a more targeted view.
Users can specify their requirements based on expected query performance, data freshness, and cost. These requirements translate into internal database configurations such as view numbers, quota limits for processing tasks, maximum number of increments that can be opened during query processing, etc. At some point in time, these form the configuration of the client database. However, the system is not static, as data is continually ingested into the table, and dynamic, easily understood indicators are required to indicate database state in the configuration context that is required to be generated by the client.
ADMS introduces a Queriable Timestamp (QT) to provide real-time tagging for clients. For example, QT may be a forward timestamp that advances when one or more conditions are met. An example of such a condition may be that the view of the table is consistent until time T, that any query requires less than X in the number of increments to be read, that the data is copied to a quorum data center, and so forth. QT is a direct indication of freshness, and [ Now () -QT ] indicates data delay. The client may query all data before QT timestamp. Since QT can only advance when the required number of views is generated, and is also the upper limit on the maximum number of increments, it ensures that the data for the query meets the conditions that provide the desired query performance. Further, continued advancement and retention of QT within freshness goals indicates that the system is able to update tables and views within cost constraints specified in the database configuration.
In one example, the ADMS may have a cost-conscious client running an organization-wide internal experimental analysis framework. For this client, good query performance and moderate cost are important, even if the system requires lower data freshness. For this client, the QT progression criteria depends on maintaining a moderate number of views and fewer increments to merge as the query is executed. To keep costs low, the ADMS execution framework uses fewer worker tasks and cheaper opportunistic machine resources for view maintenance. As a result, even though the speed of view maintenance is slow, and thus the freshness of the data can be affected, the ADMS provides good query performance for the client at moderate resource costs.
In a second example, the ADMS may have clients that require fresh answers but have low or medium query performance requirements. For such clients, the QT progression criteria depend on fewer views, but the delta that needs to be consolidated at query execution may be relatively more. Query performance is lower because there are more increments per table and view. The query service framework spends more time on I/O and folds more rows that would otherwise occur offline during view maintenance and compression. The ADMS execution framework directs more workers to ingest rather than view maintenance because of the low view maintenance workload. Thus, these clients can trade query performance for better freshness and lower resource costs.
In a third example, an ADMS client supports an external dashboard for a service provider. For such clients, good query performance and data freshness are important, even at higher cost. For such clients, the advance criteria for ADMSQT depends on a large number of views, sometimes hundreds of views for a single table, and the number of increments when merging is very small to ensure shorter query execution times. ADMS uses a large number of worker tasks to ensure that this QT standard is met quickly through faster ingestion and high throughput view maintenance. Such QT advance criteria provide the required query performance and data freshness for the client, but the resource costs are relatively high.
Such different classes of client requirements are part of the system configuration that the ADMS uses as guidelines to provide specified query performance, data freshness, and resource costs.
Data availability
Many services within a service provider may be designed to withstand data center-scale outages that may be caused by catastrophic failure or periodic maintenance. The ADMS can ensure that the system can still operate in the presence of such a shutdown. This level of fault tolerance may be provided by replicating client databases across multiple data centers and ensuring that the database replicas are consistent with each other. One approach is to use a globally consistent transaction system to perform ADMS ingest activities as synchronized transactions. Another approach decouples the execution of data and metadata operations such that the data operations execute asynchronously on each copy of the data center, and the metadata operations are used periodically to ensure that the copies remain synchronized with each other. ADMS coordinates the synchronous and asynchronous modes of the highly distributed machine. QT indicates a state in which all tables and views in the database are globally consistent among all data centers. While compression and view maintenance are performed asynchronously on each copy, the system may transition from one consistent state to another.
System architecture
Fig. 2 shows an example of a high-level architecture of an ADMS, including a data plane 200 and a control plane 250. The architecture may be deployed across multiple data centers to manage copies of each data center. The data plane 250 includes ingest 210, store 220, and query service 230. The control plane is composed of a controller 255, the controller 255 coordinating the operation between the various subsystems. The controller 255 is also responsible for synchronizing and coordinating metadata transactions across multiple data centers. The ADMS client creates databases and tables and their associated schemas. The client may choose to create a materialized view for each table.
ADMS may be built by utilizing existing infrastructure components, such as a file system with a decentralized storage infrastructure. In this regard, the table in the ADMS may be a collection of files in a decentralized file system. For functions that require strict transactional semantics (e.g., metadata management and storage system state), the ADMS may use a distributed database. ADMS may use query processing systems (e.g., SQL compliant systems) for query services and large-scale data processing (e.g., view creation and maintenance). The query processing system may support both streaming and batch processing, and the same system may be used for interactive lookup queries as well as queries that process large amounts of data. According to other examples, a dedicated infrastructure for ADMS may be developed.
ADMS clients can use extract-convert-load (ETL) pipelines to insert data into their tables. The ingestion framework 210 may be subjected to very high loads, such as tens of GB/s of compressed data. Client data is transferred to any ADMS replica and the ADMS ensures that data ingest is done at all data centers.
ADMS is good at handling the workload of clients issuing aggregate queries using complex filters (e.g., dashboard driven filters). As a result, a store and view maintenance framework is used to maintain these aggregations. The storage framework 220 is responsible for compressing the table and incrementally updating the view. Compression requires merging increments, typically with high fan-ins, to create larger increments, which reduces merging during queries. This is similar to post-processing in LSM trees, where the I/O spent by the offline process shifts work from online queries.
The query service 230 handles the necessary caching, prefetching, and delta merging at runtime. The goal of the query service is to provide low latency and low variation queries. Low latency is achieved by directing the query to a pre-computed materialized view (rather than a base table) and executing the query in parallel. Low variation is achieved by controlling the combined fan-in and a range of other I/O reduction and tail tolerance techniques.
ADMS relies on views to obtain good query performance. ADMS tables, including materialized views, are ordered, indexed, and scoped by their primary key(s). The stringent delay and resource requirements of the ADMS workload facilitate utilization of index key lookups. Most ADMS queries can be answered efficiently by the range partition index table. ADMS may rely on merge and sort performance for efficiency, and thus the sort, merge, and group operators may speed up.
The ADMS controller 255 schedules compression and view update tasks to maintain the incremental count of the table at a configurable value. Given a cost tradeoff, these storage tasks may keep the Queriable Timestamp (QT) as fresh as possible. Database QT forms the basis for database freshness and is used by the query system to provide robust query performance as previously described. ADMS supports database freshness in near real-time to several hours; most clients require their databases to maintain freshness on the order of tens of minutes. If the freshness falls outside of the desired range, the system continues to service the client query. However, the data provided in this case will be stale compared to the freshness requirement, and management actions (e.g., adjusting the tradeoff by temporarily allowing higher costs) may be required to bring the freshness back within this range. ADMS has hundreds of databases containing hundreds to thousands of tables and views, each with a steady ingestion rate. However, the system is able to keep all of these databases at the desired freshness, which proves its robustness.
The ingest framework 210 allows ingest pipes to insert large amounts of data into an ADMS without significant overhead. Fig. 3 is a schematic diagram showing ingestion of an ADMS. Ingest server 312 receives the data and may perform batch processing, classification, and materialization. All ingested lines are assigned metadata time stamps 315 for ordering and then marked as committed after other persistence conditions (such as replication, etc.) are met. The ingestion framework provides a knob that limits peak machine costs by allowing the configuration to increase or decrease the number of tasks that accept data and do ingestion work for batch, aggregate, and replication.
The client passes the data to be ingested to any of the ADMS replicas 325. ADMS ensures that data is received on all copies to ensure availability. The ingest framework generates write-optimized deltas because they are small and their physical size is limited by the memory buffer of the server. Because there are many such increments, these cannot be used immediately for a query, which would reduce the speed of the query service because it would have to merge them. These increments may be referred to as non-queriable and may need to be compressed before they can be queried.
Queriable time stamp
Fig. 4 is a timing diagram illustrating queriable time stamps that decouple query performance from storage performance. The Queriable Timestamp (QT) of the table is a timestamp indicating the freshness of queriable data. If QT (table) =x, the client may query all data ingested into the table before time X, while data after time X is not part of the query result. In other words, the freshness of the table is [ Now () -QT ]. QT acts as a barrier so that any data that is ingested after X is hidden from client queries. Once the data in the (Y-X) range is optimized to meet the query performance requirements, the value of QT will be increased from X to Y. In turn, clients can use the configuration options of the ADMS and the metrics visible to the individual clients to adjust freshness, query performance, and cost. For example, if a client desires high query performance and low cost, but may sacrifice freshness, the system may prefer to use less machine resources to maintain the view to reduce cost, and QT may progress slowly, indicating reduced data freshness.
Good query performance can be ensured by optimizing the underlying data for reading and ensuring that the view is available for accelerating the query. As shown in fig. 4, the table in the ADMS is a collection of all its delta files, each delta corresponding to an update received to the table within a time window. The non-queriable delta corresponds to a newly received update written by the ingestion framework in the most recent time window (typically seconds). On the other hand, the largest increment spans a time window of weeks or even months. Each increment is ordered by its key, the range is partitioned, and has an index similar to a local B-tree. These increments are combined as needed at query time.
Most client queries have strict delay constraints, which place a strict limit on the maximum number of increments (x) that should be opened and consolidated during query execution. In particular, the Queriable Timestamp (QT) is the increment that forms the boundary of x (counting from the oldest increment to the newest increment). The limit may be, for example, several tens of increments. According to some examples, the limit may be automatically configured according to query performance requirements for the database. For example, the automation module may dynamically adjust the limit based on the query workload. Tables with high query workload and stringent query performance requirements have lower limits, but those tables with lower query requirements have higher limits. There are some practical limits on how large x-numbers can be supported. As the number gets larger, the query begins to suffer from tail effects. Given that query time consolidation is very expensive, ADMS can provide robust query performance by keeping the number of increments for a given database nearly constant. In this regard, ADMS provides a powerful guarantee that query delay variation is low.
QT may be inherently dependent on the progress of background operations such as compression and incremental view maintenance. QT of a database is the minimum of QT of all tables in the database. QT is also used to provide clients with a consistent view of data across all ADMS replicas. Each copy has a local value of QT that is based on the freshness of the data in the local copy. The global value of QT is calculated from the local QT value based on query service availability requirements. For example, if the local QT values for 5 ADMS replicas are 100, 90, 83, 75, 64, and the query service requires that most replicas are available, then the new QT on all sites is set to 83, since most replicas are the closest, at least 83. The ADMS will answer queries using copies with QT of at least 83, as it ensures that queries to these copies only need to read locally available increments.
Large-scale maintenance view
The storage subsystem of the ADMS is responsible for maintaining views and compressing deltas. It is also responsible for ensuring data integrity and persistence through replication across the data center, and handling downtime from a single machine to the entire data center.
The ADMS storage subsystem efficiently manages thousands of tables and views, for example at the beat-byte level, even in the presence of data skew. Tilting in view maintenance occurs in the process of converting updates on the base table into updates on the view. The mapping of base table key space to view key space may cause an interruption, where most base table updates may map to a narrow view key range, resulting in a tilt. Since the QT of the database is determined by the slowest view or table, the system must automatically adjust to the size changes and the aforementioned data tilt to ensure that QT is not affected by the straggling view or table. The storage subsystem also adjusts the cost budget by changing the view, the number of tasks, and the type of machine resources used. The view maintenance framework may include using the query processing system as a "data pump," re-planning to avoid data tilting, and intelligence in the loop.
With respect to using the query processing system as a "data pump," a relational data pump may be used to compress tables and maintain views. View maintenance using a query optimizer, good choices can be made among alternative plans.
With respect to rescheduling to avoid data tilting, the system may reschedule immediately if a data tilting is detected. For example, the first key of many tables in ADMS is a date column with several different values. Even though the base table may have hundreds of key columns, most key columns are mostly zero or strongly related to another key. Within a large scale, failure to detect a tilt may mean that the view maintenance query may never be completed, resulting in an unbounded refresh delay.
With respect to intelligence in the loop, the database can advance QT only when all tables and views keep up. This means that QT is blocked by the slowest view and requires fairly complex fall-back mitigation. The ADMS controller implements tail-drop intelligence, such as defining the size of the tail by using techniques that select data centers for task execution based on historical loads, progress-based active-drop task termination, and concurrent task execution.
Query optimization in view maintenance
The view maintenance process of the ADMS effectively utilizes the data attributes in the input. View update queries must address unique optimization challenges due to the amount of data processed and due to the particular data attributes (e.g., cardinality sparsity, relevance, etc.) that complicate large-scale query processing. Effectively handling large amounts of data means that care must be taken not to destroy beneficial data attributes, such as ordering and partitioning, which are difficult to recreate.
An example of a data attribute is the order of ordering of the views to be updated relative to the base table. One approach is to reorder the view keys according to the view ordering order, regardless of the ordering order of the base table. In large scale production this would be an expensive treatment scheme. Instead, it is beneficial to keep the input ordering as much as possible; even if the ordering order of the views and the ordering order of the base table only partially overlap, ordering is exploited. Similarly, changing data partition attributes requires moving data across the network, which also typically affects ordering, which should be avoided unless absolutely necessary.
Fig. 5A-C illustrate views of different categories based on commonalities of view and base table key columns. The first type of views are those that share prefixes with the base table, such as the aligned views in FIG. 5A. For example, the base table has keywords (A, B, C), while the views are on (A, B). In this case, the framework completely avoids ordering by clustering the inputs based on common keyword prefixes (a, B) and aggregating in a stream.
The second type of views are those with partial prefixes of the base table but no full prefixes, such as the partially aligned view of FIG. 5B. For example, the base table has (A, B, C, D) with the views on (A, B, D). The input ordering order may be utilized by clustering the input base table on (a, B) and then ordering each unique (a, B) group on D. Clustering on part of the prefix may lead to tilting, which should be detected and remedied.
The third type of views are those where the base table and views do not share any prefixes, such as the misaligned view of FIG. 5C. For example, the base table is (A, B, C, D), and the view is (D, C, A). There are few opportunities for optimization and these views are the most expensive in practice because they require re-partitioning and re-ordering.
Some views have a very high aggregate reduction compared to the base table, e.g. 100-1000 times, so that the view update is small compared to the original table update. Still other views are nearly as large as the base table. For views with high radix reduction, preserving the ordering order is not the most important, as the output is small enough, focusing only on the reduced radix and reordering the output when needed may be feasible. On the other hand, for the case where the view aggregation degree is low, such as the view is similar to the size of the base table, the ordering and merging efficiency becomes important. From the mutation server to the sort operator, the sort library of ADMS can be applied to all ADMS components across the sort data.
Compression
Compression combines multiple input increments into a single output increment. Compression improves query performance and reduces storage consumption by 1) ordering inputs together and 2) aggregating multiple updates into the same row. Asynchronous compression with respect to queries both reduces merging work at the time of the query and exploits the compressed results among multiple queries. However, for high ingestion rate tables, the computational overhead of compression is significant and delays the time that the data becomes queriable, thereby reducing the freshness of the data. As previously mentioned, the configuration of the client controls this tradeoff. For example, configurations optimized for query performance may be compressed frequently such that the maximum number of increments consolidated at the time of the query is less than 10, but such configurations have significant ingestion delays and high compression costs.
Because delta files are individually ordered, compression may be similar to merge ordering. Unlike client queries, in client queries, the fan-in of the merge is kept small and bounded to avoid tail effects, intentionally kept large during compression, so that the height of the merge tree is small, thereby minimizing key comparisons. The fan-in of compressed queries may reach approximately one thousand inputs beyond which the merging performance may be degraded. The merging process divides a fixed memory budget among the various inputs. At about one thousand inputs, the memory of each input stream is small. In addition, the merging process stops when one of the inputs is consumed. This occurs 100 times more frequently than 10-way merging at one thousand-way merging. The combination of these two effects makes large-scale way merging inefficient, which can be compensated for by I/O prefetching.
Robust query service performance
Fig. 6 is a flow chart showing the mechanism of client query service in ADMS. Many ADMS clients may have business situations that require query results to be obtained in milliseconds. The latency requirement applies to tail cases (e.g., 99 th percentile) to range look-up the table of beat-byte sizes, and when the underlying shared infrastructure fluctuates in performance and availability. The query service subsystem may use queriable time stamping (QT), materialized views, and a range of other techniques to achieve robust performance.
As shown in FIG. 6, a query 602 is received at a Query Processing System (QPS) data center 650. The QPS server 652 divides them into sub-queries. For example, the QPS server 652 may divide the query 602 into tens, hundreds, thousands, tens of thousands, or more sub-queries. The partitioning may improve performance based on, for example, filtering decisions, delay budgets, and/or availability of query service resources. Distributed execution of the partition queries may be performed by one or more QPS workers 654. For example, the QPS worker 654 may read data from the delta server 674. Metadata server 672 may process the metadata. According to some examples, the version of the metadata to be processed is QT based. The metadata server 672 may also determine which data must be processed based on the metadata. The delta server 674 may read the delta 684 via the distributed cache 676. Delta 684 can be stored with ADMS index 682 in file system 680 in ADMS data center 670.
ADMS uses a variety of techniques to reduce the amount of data read to answer queries on critical paths. The ADMS uses the view instead of the base table to answer the query whenever possible, as views with aggregation functions may have little data. When the QPS worker 654 reads data from the delta server 674, filters and partial aggregations are pushed down to minimize the amount of bytes transferred to the QPS worker 654 over the network. The QPS worker 654 and ADMS store (e.g., file system 680) are not always located in the same data center. Transmission across a data center network may have a greater delay variation than transmission within the data center. ADMS also relies on parallelism to reduce the amount of data that each sub-query must read. ADMS maintains sparse B-tree indexes on its stored data and uses them to quickly partition the input query into thousands of sub-queries that meet the filtering criteria. This partitioning mechanism also takes into account the delay budget and availability of the query service resources to achieve good performance.
In view of the large-scale data sets and reliance on shared and decentralized storage, high latency may occur if metadata or data must be read from disk or even SSD. Examples of such metadata may include data statistics, view definitions, delta metadata, and the like. When a query 602 is issued, the ADMS uses the QT value to decide the version of the metadata to process. The metadata in turn determines what data must be processed. Thus, metadata reads may be located on the critical path of the query service. ADMS ensures that all metadata can always be provided from memory without contacting permanent storage. This is achieved by a metadata cache with periodic background refreshing, e.g. a distributed metadata cache based on similarity. A particular QT is delayed to wait for the periodic background refresh of the metadata to complete.
All data reads go through the transparent distributed data caching layer 676 through which file I/O operations go. The distributed cache 676 is read-through and shares the work of concurrent read misses to the same data. The sharing work improves the efficiency of the distributed cache. When processing different sub-queries of the same query, multiple delta servers 674 can read overlapping ranges of index files, and the distributed data cache 676 ensures that such reads are processed only once.
The distributed cache layer 676 significantly reduces the amount of I/O. ADMS may perform offline and online prefetching to further reduce the number of sequential I/Os in the critical path. Once the data of frequently queried tables is ingested, offline prefetching may occur before QT advances to make new data available for querying. Online prefetching begins when query 602 arrives and may be performed by a shadow query executor that shares a data access pattern with the primary query executor, but skips all query processing steps. Since the shadow query executor skips processing, it runs before the main query executor, a more accurate prefetch effect is achieved than disk prefetching based on past accesses.
During query service, ADMS actively parallelizes work by dividing queries into fine-grained units, and then parallelizing I/O calls across deltas and across queried columns. This parallelization may lead to tail delays. For example, if each ADMS query issues one thousand parallel I/Os to disk, the latency of the 90 th percentile of ADMS will be affected by the latency of the 99.99 th percentile of the underlying disk storage, which is typically much higher than the latency of its 90 th, 99 th and 99.9 th percentiles. To combat this amplification of tail delay, ADMS uses QT to limit the number of queriable increments. In addition, ADMS may combine as much small I/O as possible, for example, by using a cross-delta lazy merge technique and size-based disk layout.
Regarding lazy merging across deltas, in one simple query plan, the ADMS exposes itself to the query optimizer as a data source with primary keys. When processing sub-queries, each delta server 674 first merges the rows on all deltas 684 based on the full primary key. When there are thousands (N) of sub-queries and tens (M) of increments 684, the number of parallel IOs is on the order of tens of thousands (NxM). However, due to parallelism, each sub-query reads very little data from most of the deltas 684. At the same time, a significant portion of ADMS queries require merging based on a subset of primary keys at a later stage of the query plan. In these cases, the ADMS adjusts the query plan to avoid cross delta merging in delta servers 674 and let each delta server 674 handle only one delta, combining N M parallel IOs into near N parallel IOs.
Regarding size-based disk layout, ADMS uses a custom column storage format to support multiple disk layout options for delta-size-based applications. PAX layouts that can merge all column accesses into one IO for lookup queries can be applied in small increments. For large increments, a column-by-column layout may be used, which is IO efficient for scan queries, but requires one IO per column for lookup queries. This size-based selection ensures that the ADMS gains column storage advantage and reduces IO operations.
ADMS employs the principle of tolerating tail delays. For non-streaming Remote Procedure Calls (RPCs), such as the RPC between metadata server 672 and delta server 674, the ADMS uses an opposite-flushing mechanism to send a second RPC, identical to the original RPC, to a different server after a certain delay and wait for a faster reply.
For a streaming RPC, such as an RPC between a Query Processing Service (QPS) worker and an incremental server, the ADMS estimates its expected progress and requires periodic execution of its server reporting progress and continuation tokens. If the progress of the report is lower than expected or the report is lost, the latest continuation token will be used to restart the new streaming RPC on a different server without losing progress. In progress reporting, push-down operators (e.g., filtering and partial aggregation) need to be handled carefully because they can significantly reduce data size, resulting in low or even missing on the progress report surface. ADMS uses the filtered and partially aggregated previously processed bytes as progress indicators and periodically forces the operators to refresh their internal state to generate a progress report with continuation tokens.
For problems within the data center that affect query service but not ingestion, the tail tolerance mechanism described above will work and automatically reroute queries to servers in neighboring data centers. When ingestion is affected, in the affected data center, the data center local QT is delayed and queries will be routed directly to other data centers based on the local QT value.
FIG. 7A shows the decrease in query latency as the number of views increases, while FIG. 7B shows the number of increments of queries that are allowed to span and the corresponding latency impact. Lower delay effects are generally more beneficial.
By using views more aggressively, ADMS can provide robust query performance by altering storage policies and thus reducing the number of increments and thus tail delays, and by decoupling ingestion, view maintenance, and query execution, thereby mitigating the impact of infrastructure and workload changes on query performance.
FIG. 8 illustrates an example distributed computing environment, in which ADMS may be implemented. Multiple data centers 860, 870, 880 may be communicatively coupled, such as through a network 850. Data centers 860, 870, 880 may further communicate with one or more client devices (e.g., client 810) via network 850. In some examples, data centers 860, 870, 880 may further be in communication with controller 890.
Data centers 860-880 may be located at a substantial distance from each other. For example, data centers may be located in different countries around the world. Each data center 860, 870, 880 may include one or more computing devices, such as processors, servers, slices, and the like. For example, as shown in fig. 8, data center 860 includes a host computing device 862 and a plurality of storage devices 864, data center 870 includes a storage device 874, and data center 880 includes a storage device 884. Although processing devices (e.g., servers, virtual machine hosts, or other processing devices) are not shown in the data centers 870, 880, it should be understood that they may also be included. According to some examples, a computing device may include one or more virtual machines running on a host. Further, it should be understood that the configuration shown in FIG. 8 is merely one example, and that the computing devices in each of the example data centers 860-880 may have various structures and components that are the same or different from one another.
The program may be executed across these computing devices, for example, such that some operations are performed by one or more computing devices of a first data center, while other operations are performed by one or more computing devices of a second data center. In some examples, computing devices in the various data centers may have different capabilities. For example, different computing devices may have different processing speeds, workloads, and the like. Although only some of these computing devices are shown, it should be understood that each data center 860, 870, 880 may include any number of computing devices, and that the number of computing devices in a first data center may be different than the number of computing devices in a second data center. Further, it should be appreciated that the number of computing devices in each data center 860-880 may vary over time, for example, as hardware is removed, replaced, upgraded, or expanded.
The storage devices 864, 874, 884 may include hard disk drives, random access memory, magnetic disks, disk arrays, tape drives, or any other type of storage device. The storage 864, 874, 884 may be provided as a SAN within a data center hosting virtual machines supported by the storage, or within a different data center that does not share a physical location with the virtual machines supported by it. Data centers 860-880 may implement any of a variety of structures and technologies including, but not limited to, direct Attached Storage (DAS), network Attached Storage (NAS), storage Area Network (SAN), fibre Channel (FC), fibre channel over ethernet (FCoE), hybrid fabric networks, and the like. In addition to storage devices, data centers 860-880 may include many other devices, such as cables, routers, and the like. Further, in some examples, data centers 860-880 may be virtualized environments. Furthermore, while only a few data centers 860-880 are shown, many data centers may be coupled by network 850 and/or additional networks.
The storage devices 864, 874, 884 may include data corresponding to replicated disks. For example, a disk may be replicated in a first copy of a first storage device of data center 860, or a second copy of a second storage device of data center 880. According to other examples, disks may be replicated on multiple different storage devices within the same data center. The number of storage devices across which disks are replicated may vary. For example, although in this example the disk is replicated across two storage devices, according to other examples additional replicas may be implemented.
Virtual machine 866 may be attached to one or more copies of a disk. For example, VM866 may be attached to a trusted copy.
In some examples, controller 890 may communicate with computing devices in data centers 860-880 and may facilitate execution of programs. For example, controller 890 may track the capacity, status, workload, or other information of each computing device and use such information to assign tasks.
Controller 890 may contain a processor 898, memory 892, and other components typically found in a general purpose computer. Memory 892 may store information accessible to processor 898 including instructions 896 executable by processor 898. The memory may also include data 894 that may be retrieved, manipulated, or stored by the processor 898. Memory 892 may be a non-transitory computer readable medium such as a hard disk drive, a solid state drive, a tape drive, an optical memory, a memory card, ROM, RAM, DVD, CD-ROM, writable and read-only memory capable of storing information accessible by processor 898. The system may include different combinations of memory whereby different portions of the instructions and data are stored on different types of media. Processor 898 may be a well known processor or other less well known processor type. Alternatively, the processor 898 may be a dedicated controller, such as an ASIC.
The instructions 896 may be a set of instructions (e.g., machine code) that are executed directly by the processor 898, or a set of instructions (e.g., scripts) that are executed indirectly. In this regard, the terms "instruction," "step," and "program" are used interchangeably herein. The instructions 896 may be stored in an object code format for direct processing by the processor 898, or in other types of computer languages, including as-needed interpretation or pre-compiled script or collection of separate source code modules.
Processor 898 may retrieve, store, or modify data 894 according to instructions 896. For example, although the system and method is not limited by a particular data structure, data 894 may be stored in a computer register, in a relational database as a table with a plurality of different fields and records, or in an XML document. The data 894 may also be formatted in a computer readable format such as, but not limited to, binary values, ASCII, or Unicode. In addition, data 894 may include information sufficient to identify relevant information, such as numbers, descriptive text, proprietary codes, pointers, references to data stored in other memory (including other network locations), or information used by a function to calculate relevant data.
Although fig. 8 functionally shows the processor 898 and the memory 892 as being within the same block, the processor 898 and the memory 892 may in fact include multiple processors and memories that may or may not be stored within the same physical housing. For example, some of the instructions 896 and data 894 may be stored on a removable CD-ROM, while others may be stored on a read-only computer chip. Some or all of the instructions and data may be stored in a location that is physically remote from the processor 898 but still accessible to the processor 898. Similarly, processor 898 may actually comprise a collection of processors that may or may not operate in parallel.
Similar to the controller 890 described above, the client 810 may include a processor 820 and memory 830, including data 834 and instructions 832. Each client 810 may be a personal computer intended for use by a person having all of the internal components typically found in personal computers, such as a Central Processing Unit (CPU), CD-ROM, hard disk drive, and a display device (e.g., a monitor with a screen, projector, touch screen, small LCD screen, television, or another device such as an electronic device operable to display information processed by processor 820), speakers, a modem and/or network interface device, user input such as a mouse, keyboard, touch screen, or microphone, and all of the components used to interconnect these elements. Further, computers in accordance with the systems and methods described herein may include devices capable of processing instructions and transmitting data to and from humans and other computers, including general purpose computers, PDAs, tablets, mobile phones, smart watches, network computers lacking local storage capabilities, television set-top boxes, and other networking devices.
The client 810 may include, for example, a computing device located at a client location that utilizes cloud computing services, such as infrastructure as a service (IaaS), platform as a service (PaaS), and/or software as a service (SaaS). For example, if computing device 810 is located at a business enterprise, client 810 may use a cloud system as a service to provide software applications (e.g., accounting, word processing, inventory tracking, etc. applications) to client 810 for use in operating the enterprise system. In addition, client 810 may access the cloud computing system as part of its operation employing machine learning, deep learning, or more general artificial intelligence techniques to train applications supporting its business enterprise.
Clients 810, data centers 860-880, and controller 890 can communicate directly and indirectly, for example, over network 850. For example, using a web socket, client 810 may connect to a service running on a remote server through the internet protocol suite. The server may set up a listening socket that may accept initial connections to send and receive information. The network 850 and intermediate nodes may include various configurations and protocols including the Internet, world Wide Web, intranets, virtual private networks, wide area networks, local area networks, private networks using one or more corporate private communication protocols, ethernet, wiFi (e.g., 702.78, 702.78b, g, n, or other such standards), and HTTP, as well as various combinations of the foregoing. Such communication may be accomplished through devices capable of transmitting data to and from other computers, such as modems (e.g., dial-up, cable or fiber optic) and wireless interfaces.
In addition to the operations described above and shown in the drawings, various operations will now be described. It should be understood that the following operations need not be performed in the exact order described below. Rather, the various steps may be processed in a different order or simultaneously, and steps may also be added or omitted.
Fig. 9 illustrates an example method of ingest data using an ADMS. Such a method may be performed, for example, using an ingestion framework.
At block 910, a plurality of rows of data are ingested using an ingestion framework, such as described above in connection with FIG. 3. For example, tens, thousands, hundreds of thousands or more lines may be ingested.
In block 920, metadata timestamps are assigned to each ingested row. At block 930, ingestion work is performed. For example, such ingestion effort may include batching, sorting, aggregation, replication, materialization, and the like. According to some examples, ingestion work may be done using assigned metadata time stamps. For example, the rows may be ordered based on the assigned metadata time stamps.
At block 940, data from the ingested line is transferred to the ADMS replica as an optimized delta. According to some examples, each line may be marked as committed when replication is satisfied.
Fig. 10 illustrates an example method of querying using an ADMS. This method may be performed as described above in connection with fig. 6, for example using a query service framework.
At block 1010, a query is received. In block 1020, the query may be divided into a plurality of sub-queries. For example, a query may be divided into tens, thousands, or more sub-queries. The partitioning may depend on the available worker resources.
At block 1030, the sub-queries are distributed for execution. For example, the sub-queries may be distributed to multiple workers or servers in a distributed system.
At block 1040, data responsive to the query is read from the delta through the distributed data caching layer.
Aspects of the present disclosure may be implemented in digital electronic circuitry, in computer-readable storage media, as one or more computer programs, or in combinations of one or more of the foregoing. The computer-readable storage medium may be non-transitory, for example, as one or more instructions executable by the cloud computing platform and stored on the tangible storage device.
In this specification, the phrase "configured to" is used in a different context in connection with a computer system, hardware, or a portion of a computer program, engine, or module. When a system is referred to as being configured to perform one or more operations, it means that the system has the appropriate software, firmware, and/or hardware installed on the system that, when in operation, cause the system to perform the one or more operations. When a piece of hardware is referred to as being configured to perform one or more operations, this means that the piece of hardware comprises one or more circuits that, in operation, receive an input and generate an output corresponding to the one or more operations from the input. When a computer program, engine, or module is referred to as being configured to perform one or more operations, it means that the computer program comprises one or more program instructions that, when executed by one or more computers, cause the one or more computers to perform the one or more operations.
Although the operations shown in the figures and described in the claims are illustrated in a particular order, it should be understood that the operations may be performed in a different order than shown, and that some operations may be omitted, performed more than once, and/or performed in parallel with other operations. Furthermore, the separation of different system components configured to perform different operations should not be understood as requiring the components to be separated. The described components, modules, programs, and engines may be integrated together as a single system or as part of multiple systems.
The foregoing alternative examples are not mutually exclusive, unless otherwise specified, but may be implemented in various combinations to achieve unique advantages. As these and other variations and combinations of the above-described features may be utilized without departing from the subject matter defined by the claims, the foregoing description of the examples should be taken by way of illustration rather than by way of limitation of the subject matter defined by the claims. Furthermore, the descriptive examples provided herein, as well as terms such as "include," "comprising," and the like, should not be construed as limiting the claimed subject matter to a particular example; rather, these examples are intended to be illustrative of only one of many possible implementations. Furthermore, the same reference numbers in different drawings may identify the same or similar elements.
Claims (21)
1. An Analytical Data Management System (ADMS), comprising:
an ingestion framework configured to submit updates into one or more data tables stored in memory;
a storage framework configured to compress the one or more tables and incrementally apply the updates to the one or more tables; and
a query service framework configured to respond to client queries.
2. The ADMS of claim 1, wherein compressing the one or more tables comprises merging multiple delta updates before applying the updates to the one or more tables.
3. The ADMS of claim 1, wherein the query service framework directs queries to pre-computed materialized views.
4. The ADMS of claim 3, wherein the one or more tables comprising the pre-computed materialized view are ordered, indexed, and scoped by primary key.
5. An ADMS according to claim 1, further comprising:
a data plane comprising the ingest framework, the storage framework, and the query service framework; and
a control plane comprising a controller, wherein the controller coordinates work between the ingestion framework, the storage framework, and the query service framework.
6. The ADMS of claim 5, wherein the controller schedules compression and view update tasks.
7. The ADMS of claim 5, wherein the controller coordinates metadata transactions across multiple data centers.
8. The ADMS of claim 1, wherein the ingestion framework is configured to ingest rows of data, each row of data being assigned a metadata timestamp.
9. The ADMS of claim 8, wherein ingest the plurality of rows of data further comprises batching, aggregating, and replicating the data.
10. The ADMS of claim 1, wherein the ingestion framework comprises a plurality of copies located in different geographic locations, and wherein the framework is configured to ingest the data at any of the plurality of copies.
11. The ADMS of claim 1, wherein each table has a queriable timestamp indicating freshness of the data that can be queried.
12. The ADMS of claim 11, wherein the freshness is represented by a time period equal to a current time minus the queriable timestamp.
13. The ADMS of claim 11, wherein client queries are hidden from any data that is ingested after the queriable timestamp.
14. The ADMS of claim 13, wherein the queriable timestamp is updated when the data ingested is optimized to meet predefined query performance requirements, wherein such optimization includes limiting at least one of a physical size of an update based on a storage buffer or compression of a server.
15. The ADMS of claim 11 wherein parameters of freshness, performance, and cost are reconfigurable.
16. A method of managing an Analytical Data Management System (ADMS), comprising:
submitting the updates to one or more data tables stored in memory using an ingestion framework;
compressing the one or more tables using a storage framework and incrementally applying the updates to the one or more tables; and
a query service framework is used to respond to client queries.
17. The method as recited in claim 16, further comprising:
using a controller in a control plane, coordinating work in a data plane containing the ingest framework, the storage framework, and the query service framework.
18. The method as recited in claim 17, further comprising:
scheduling compression and view update tasks using the controller; and
metadata transactions across multiple data centers are coordinated using the controller.
19. The method of claim 16, further comprising ingesting a plurality of rows of data using the ingestion framework, each row of data being assigned a metadata timestamp.
20. The method of claim 19, wherein each table has a queriable timestamp indicating the freshness of the data that can be queried, and any data ingested after the queriable timestamp is hidden from client queries.
21. The method as recited in claim 20, further comprising:
optimizing the ingested data to meet predefined query performance requirements, wherein such optimization includes limiting at least one of updated physical size based on storage buffers or compression of the server; and
the queriable timestamp is updated when the data being ingested is optimized.
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US202163174692P | 2021-04-14 | 2021-04-14 | |
US63/174,692 | 2021-04-14 | ||
PCT/US2022/024813 WO2022221533A2 (en) | 2021-04-14 | 2022-04-14 | Powering scalable data warehousing with robust query performance |
Publications (1)
Publication Number | Publication Date |
---|---|
CN117120997A true CN117120997A (en) | 2023-11-24 |
Family
ID=81579744
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN202280028408.2A Pending CN117120997A (en) | 2021-04-14 | 2022-04-14 | Supporting extensible databases with robust query performance |
Country Status (4)
Country | Link |
---|---|
US (1) | US20220335049A1 (en) |
EP (1) | EP4323888A2 (en) |
CN (1) | CN117120997A (en) |
WO (1) | WO2022221533A2 (en) |
Families Citing this family (7)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US11899685B1 (en) * | 2021-12-10 | 2024-02-13 | Amazon Technologies, Inc. | Dividing authorization between a control plane and a data plane for sharing database data |
US11914616B1 (en) | 2022-12-16 | 2024-02-27 | Alchemy Insights, Inc. | Systems and methods for creating a consistent blockchain including block commitment determinations |
US11769143B1 (en) * | 2022-12-22 | 2023-09-26 | Alchemy Insights, Inc. | System and method for high performance providing fresh NFT metadata |
US11750711B1 (en) | 2022-12-22 | 2023-09-05 | Alchemy Insights, Inc. | Systems and methods for adaptively rate limiting client service requests at a blockchain service provider platform |
US11728976B1 (en) | 2022-12-22 | 2023-08-15 | Alchemy Insights, Inc. | Systems and methods for efficiently serving blockchain requests using an optimized cache |
US11816021B1 (en) | 2022-12-22 | 2023-11-14 | Alchemy Insights, Inc. | System and method for intelligent testing of blockchain applications using a shadow system |
US11811955B1 (en) | 2022-12-23 | 2023-11-07 | Alchemy Insights, Inc. | Systems and methods for improving reliability in blockchain networks using sharding |
Family Cites Families (9)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
EP1451714B1 (en) * | 2001-11-01 | 2018-05-02 | Verisign, Inc. | Method and system for updating a remote database |
US6938045B2 (en) * | 2002-01-18 | 2005-08-30 | Seiko Epson Corporation | Image server synchronization |
US7426559B2 (en) * | 2002-05-09 | 2008-09-16 | International Business Machines Corporation | Method for sequential coordination of external database application events with asynchronous internal database events |
US20060224568A1 (en) * | 2005-04-02 | 2006-10-05 | Debrito Daniel N | Automatically displaying fields that were non-displayed when the fields are filter fields |
US9390124B2 (en) * | 2013-03-15 | 2016-07-12 | Microsoft Technology Licensing, Llc. | Version control system using commit manifest database tables |
US11200130B2 (en) * | 2015-09-18 | 2021-12-14 | Splunk Inc. | Automatic entity control in a machine data driven service monitoring system |
US20200167355A1 (en) * | 2018-11-23 | 2020-05-28 | Amazon Technologies, Inc. | Edge processing in a distributed time-series database |
US11782920B1 (en) * | 2021-01-29 | 2023-10-10 | Splunk Inc. | Durable search queries for reliable distributed data retrieval |
US11100111B1 (en) * | 2021-04-09 | 2021-08-24 | Snowflake Inc. | Real-time streaming data ingestion into database tables |
-
2022
- 2022-04-14 US US17/720,862 patent/US20220335049A1/en active Pending
- 2022-04-14 EP EP22720871.7A patent/EP4323888A2/en active Pending
- 2022-04-14 WO PCT/US2022/024813 patent/WO2022221533A2/en active Application Filing
- 2022-04-14 CN CN202280028408.2A patent/CN117120997A/en active Pending
Also Published As
Publication number | Publication date |
---|---|
WO2022221533A3 (en) | 2022-12-29 |
US20220335049A1 (en) | 2022-10-20 |
EP4323888A2 (en) | 2024-02-21 |
WO2022221533A2 (en) | 2022-10-20 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
CN117120997A (en) | Supporting extensible databases with robust query performance | |
US11030189B2 (en) | Maintaining up-to-date materialized views for time-series database analytics | |
CN112534396B (en) | Diary watch in database system | |
US10509785B2 (en) | Policy-driven data manipulation in time-series database systems | |
JP6416194B2 (en) | Scalable analytic platform for semi-structured data | |
US10095732B2 (en) | Scalable analysis platform for semi-structured data | |
CA2700074C (en) | Etl-less zero-redundancy system and method for reporting oltp data | |
CN111630497A (en) | Incremental feature development and workload capture in a database system | |
US11226963B2 (en) | Method and system for executing queries on indexed views | |
Yang et al. | F1 Lightning: HTAP as a Service | |
CN117321583A (en) | Storage engine for hybrid data processing | |
US10558637B2 (en) | Modularized data distribution plan generation | |
US20230066540A1 (en) | Hybrid data processing system and method | |
Wang et al. | High-performance Database Integrating Transaction and Analysis |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
SE01 | Entry into force of request for substantive examination |