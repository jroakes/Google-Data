US20120320992A1 - Enhancing compression quality using alternate reference frame - Google Patents
Enhancing compression quality using alternate reference frame Download PDFInfo
- Publication number
- US20120320992A1 US20120320992A1 US13/599,371 US201213599371A US2012320992A1 US 20120320992 A1 US20120320992 A1 US 20120320992A1 US 201213599371 A US201213599371 A US 201213599371A US 2012320992 A1 US2012320992 A1 US 2012320992A1
- Authority
- US
- United States
- Prior art keywords
- frame
- reference frame
- boost value
- alternate reference
- value
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Abandoned
Links
Classifications
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/102—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or selection affected or controlled by the adaptive coding
- H04N19/117—Filters, e.g. for pre-processing or post-processing
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/50—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding
- H04N19/503—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding involving temporal prediction
- H04N19/51—Motion estimation or motion compensation
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/102—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or selection affected or controlled by the adaptive coding
- H04N19/103—Selection of coding mode or of prediction mode
- H04N19/114—Adapting the group of pictures [GOP] structure, e.g. number of B-frames between two anchor frames
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/102—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or selection affected or controlled by the adaptive coding
- H04N19/129—Scanning of coding units, e.g. zig-zag scan of transform coefficients or flexible macroblock ordering [FMO]
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/102—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or selection affected or controlled by the adaptive coding
- H04N19/13—Adaptive entropy coding, e.g. adaptive variable length coding [AVLC] or context adaptive binary arithmetic coding [CABAC]
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/134—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or criterion affecting or controlling the adaptive coding
- H04N19/136—Incoming video signal characteristics or properties
- H04N19/137—Motion inside a coding unit, e.g. average field, frame or block difference
- H04N19/139—Analysis of motion vectors, e.g. their magnitude, direction, variance or reliability
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/134—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or criterion affecting or controlling the adaptive coding
- H04N19/136—Incoming video signal characteristics or properties
- H04N19/14—Coding unit complexity, e.g. amount of activity or edge presence estimation
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/134—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or criterion affecting or controlling the adaptive coding
- H04N19/146—Data rate or code amount at the encoder output
- H04N19/152—Data rate or code amount at the encoder output by measuring the fullness of the transmission buffer
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/134—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or criterion affecting or controlling the adaptive coding
- H04N19/154—Measured or subjectively estimated visual quality after decoding, e.g. measurement of distortion
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/134—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or criterion affecting or controlling the adaptive coding
- H04N19/156—Availability of hardware or computational resources, e.g. encoding based on power-saving criteria
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/169—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding
- H04N19/17—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding the unit being an image region, e.g. an object
- H04N19/172—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding the unit being an image region, e.g. an object the region being a picture, frame or field
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/169—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding
- H04N19/17—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding the unit being an image region, e.g. an object
- H04N19/176—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding the unit being an image region, e.g. an object the region being a block, e.g. a macroblock
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/169—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding
- H04N19/177—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding the unit being a group of pictures [GOP]
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/50—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding
- H04N19/503—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding involving temporal prediction
- H04N19/51—Motion estimation or motion compensation
- H04N19/513—Processing of motion vectors
- H04N19/517—Processing of motion vectors by encoding
- H04N19/52—Processing of motion vectors by encoding by predictive encoding
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/50—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding
- H04N19/503—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding involving temporal prediction
- H04N19/51—Motion estimation or motion compensation
- H04N19/523—Motion estimation or motion compensation with sub-pixel accuracy
Definitions
- the invention relates to video data and more specifically to methods and systems of coding, decoding, compressing, and transmitting video data in as efficient a manner as possible.
- the transmission of data is usually constrained by bandwidth and throughput limitations. One cannot send or receive an infinite amount of information in an infinitesimal amount of time. In order to maximize the amount and quality of information being transmitted, in some cases the information is compressed or coded for transmission and uncompressed or decoded upon reception.
- video data can include aspects of color, brightness, and often stereo audio information.
- a large amount of data is required to define even short video clips.
- the transmission and coding of such data must be as efficient as possible, i.e., it must require as little information as possible to be transmitted.
- Video compression is a subset of the general technique of data compression, whereby a signal is squeezed or compressed into a smaller set of numbers. These numbers will then take up less space on a hard drive, or take less time to transmit over a network. Before the numbers are used again, a decompression algorithm is applied to expand the series of numbers to its original (or at least a similar) form.
- Video compression utilizes the fact that the signal is known to originate as digitized video, in order to increase the compression ratio, or the amount of squeezing that can be applied to the series of numbers to be stored or transmitted.
- Significant compression of video and audio are considered lossy algorithms because they discard or lose some portion of the original information; the reconstructed number series does not exactly match the original. This is acceptable because the precision with which we view video and audio, compared to the resolution of the digitization process, is not perfect. While the video signal may become slightly distorted, it is still recognizable. The degree to which a compression algorithm faithfully reproduces the original signal with minimum distortion or loss is a measure of the success of the algorithm.
- Video codecs Much work has been done in the field of video data compression. Some of the features of video codecs in existence include Discrete Cosine Transform compression, entropy coding, and differential coding of motion vectors. Prior codecs also utilize reference frames so that if a data packet is lost or corrupted, the data can be retrieved by referring to a reference frame. All of these features and difficulties therewith will be discussed in greater detail below.
- DCT Discrete Cosine Transform
- the higher frequency AC coefficients are smaller in magnitude and hence less likely to be non zero (i.e., more likely to be zero) following quantization. Consequently, prior to tokenization, the coefficients are often arranged in ascending order starting with the lowest frequency coefficient (the DC value) and finishing with the highest frequency AC coefficient.
- This scan order sometimes referred to as “zig-zag order”, tends to group together the non-zero values at the start and the zero values into runs at the end and by so doing facilitates more efficient compression.
- the instant invention's bitstream in common with most other video codecs, can broadly speaking be described as comprising entropy coded tokens that can be divided into two main categories: predictor or P tokens and prediction error or E tokens.
- P tokens are tokens describing the method or mode used to code a block or region of an image and tokens describing motion between one frame and another.
- E tokens are used to code any residual error that results from an imperfect prediction.
- Entropy coding is a process whereby the representation of a specific P or E token in the bitstream is optimized according to the frequency of that token in the bitstream or the likelihood that it will occur at a particular position. For example, a token that occurs very frequently will be represented using a smaller number of bits than a token that occurs infrequently.
- Huffman Coding Two of the most common entropy coding techniques are Huffman Coding and arithmetic coding.
- Huffman coding each token is represented by a variable length pattern of bits (or a code).
- Arithmetic coding is a more computationally complex technique but it removes the restriction of using a whole number of bits for each token.
- Using an arithmetic coder it is perfectly possible to code a very common token at an average cost of 2% of a bit.
- each vector is coded relative to the previous vector. For example, consider two vectors (7,3) and (8,4). In this case the second vector would be encoded as (1,1), that is (7+1, 3+1).
- This scheme works well if most blocks or regions for which a motion vector is coded exhibit motion that is similar to that of their neighbors. This can often be shown to be the case, for example when panning. However, it works less well if the motion field is irregular or where there are frequent transitions between background and foreground regions which have different motion characteristics.
- motion prediction is an important part of the compression process.
- Motion prediction is a process whereby the motion of objects or regions of the image is modelled over one or more frames and one or more ‘motion vectors’ is transmitted in the bitstream to represent this motion.
- motion vectors In most cases it is not possible to perfectly model the motion within an image, so it is necessary to code a residual error signal in addition to the motion information.
- each motion vector points to a region in a previously encoded frame that is similar to the region in the current frame that is to be encoded.
- the residual error signal is obtained by subtracting the predicted value of each pixel from the actual value in the current frame.
- A, B, C, and D are full-pixel aligned data points and x, y, and z are half-pixel aligned points.
- Point x is half-pixel aligned in the X direction and can be calculated using the equation:
- Point y is half-pixel aligned in the Y direction and can be calculated using the equation:
- Point z is half-pixel aligned in both X and Y can be calculated using the equation:
- x is a half-pixel point that lies half way between two full pixel aligned pointes B and C.
- An alternative approach is simply to detect the error at the decoder and report it to the encoder. The encoder can then transmit a recovery frame to the decoder. Note that this approach may not be appropriate if the error rate on the link is very high, e.g., more than one error in every 10-20 frames.
- recovery frame is a key frame (or intra only frame). This is a frame that does not have any dependencies on previous frames or the data therein.
- key frames are usually relatively large.
- One aspect of the disclosed implementations is a method for decoding a video signal having a plurality of frames including a current frame.
- the method includes generating an alternate reference frame having a first quality level; determining a boost value, the boost value indicative of a second quality level higher than the first quality level; determining whether to apply the boost value to the alternate reference frame; and selectively applying the boost value to the alternate reference frame based on the determination whether to apply the boost value to the alternate reference frame.
- the alternate reference frame can occur prior to the current frame in the video signal and other than a frame immediately prior to the current frame.
- Another aspect of the disclosed implementations is a method for encoding a video signal having a plurality of frames including a current frame.
- the method includes generating an alternate reference frame having a first quality level; determining a boost value, the boost value indicative of a second quality level higher than the first quality level; determining whether to apply the boost value to the alternate reference frame; and selectively applying the boost value to the alternate reference frame based on the determination whether to apply the boost value to the alternate reference frame.
- the alternate reference frame can occur prior to the current frame in the video signal and other than a frame immediately prior to the current frame.
- the apparatus comprises a memory and a processor configured to execute instructions stored in the memory to: generate an alternate reference frame having a first quality level, wherein the alternate reference frame occurs prior to the current frame in the video signal and wherein the alternate reference frame is other than a frame immediately prior to the current frame; determine a boost value, the boost value indicative of a second quality level higher than the first quality level; determine whether to apply the boost value to the alternate reference frame; and selectively apply the boost value to the alternate reference frame based on the determination whether to apply the boost value to the alternate reference frame.
- the invention is a method of compressing video data having at least one frame having at least one block and each block having an array of pixels.
- the disclosure includes at least one of the following steps: I) transforming the pixels of each block into coefficients and creating an optimal transmission order of the coefficients; II) optimizing the speed of processing compressed video data by partitioning the data bitstream and coding each partition independently; III) predicting fractional pixel motion by selecting an interpolation method for each given plurality of pixels depending upon at least one metric related to each given block; and IV) enhancing error recovery for a current frame using a frame prior to the frame immediately before the current frame as the only reference frame for lessening quality loss during data transmission.
- the method transforms the pixels of each block into coefficients, each coefficient having a coefficient position and a value and determines a position value related to each coefficient position.
- An optimal transmission order of coefficients is then created based on the position values of each coefficient position, and the coefficients are transmitted in the order so determined.
- the transmission order of coefficients is dynamically re-ordered for each frame of video data.
- the transforming step preferably transforms the pixels into discrete cosine transform coefficients.
- the transmission order of coefficients may be transmitted along with the coefficients.
- each block has the same number of coefficients and coefficient positions, and each corresponding respective coefficient position conveys the same respective information from block to block.
- the transmission of coefficient order data may be limited to changes in the coefficient order from one frame to the next frame.
- the transmission order may be consolidated into bands of coefficients, each band having a plurality of coefficients organized by rank in numbers determined above.
- only band information may be transmitted along with the coefficients.
- only band information will be transmitted where a coefficient changes bands from one frame to the next.
- all band information may always be transmitted.
- Reordering the coefficients can also include the provision of a key frame.
- the inventive method may provide such a key frame which is always completely self-encoded and requires no information from or about a previous frame.
- the encoder determines if a given frame is a key frame. If it is determined that the given frame is a key frame, the entire transmission order of coefficients for the key frame is transmitted. If it is determined that the given frame is not a key frame, only changes in the transmission order of coefficients from the previous frame to the given frame are transmitted.
- the invention contemplates optimizing the speed of processing compressed video data by partitioning the data bitstream and coding each partition independently. Specifically, the invention divides the video data into at least two data partitions and selects an optimal entropy coding method for each data partition. The entropy coding methods thus selected are applied respectively to each data partition.
- the video data is divided into a predictor token data partition and an error token data partition; preferably, each data partition undergoes a different entropy coding method, such as Huffman coding and arithmetic coding.
- the various decoding processes of the different data partitions may be performed asynchronously and/or independently.
- This may be accomplished by providing at least two subprocessors in the hardware, wherein one data partition is decoded by one subprocessor and another data partition is decoded by another subprocessor. Determining which entropy coding method is to be used for a given data partition may be based on the size of the given data partition.
- the predictor token data partition is read and converted into a predictor block.
- the error token data partition is also read and is converted into coefficients and thence an error block.
- the predictor block and the error block are summed to form an image block.
- the steps of reading the error token data partition and converting the error token data partition into coefficients are preferably performed by a fast entropy optimized subprocessor, and the other steps are preferably performed by a general purpose subprocessor.
- the method optimizes decoder performance of the bitstream in a way that avoids data and code cache misses. As many distinct functions of the decoder's code as can fit into the code cache are stored there. The code from this step is run for as many blocks as can fit into the data cache. The next set of distinct functions of the decoder's code and then collected, and the process is repeated until all of the bitstream has been read and each of the blocks of data have been produced.
- Another aspect of optimizing decoder performance of the bitstream optimizes the utilization of the subprocessors by assigning each subtask to a separate processor.
- the portion of the decoder that reads error tokens from the bitstream and translates them into coefficients is run on a fast entropy optimized subprocessor.
- the portion of the decoder that reads the predictor tokens from the bitstream and builds a filtered predictor block from these tokens is run on a subprocessor with fast access to memory.
- the portion of the decoder that translates the transform coefficients from the above step into an error signal is run on a subprocessor that has an optimized implementation of the transform coder, and the portion of the decoder that adds the predictor block to the error signal is run on a subprocessor optimized for motion compensation.
- the video data may be divided into two data partitions, a first data partition representing a first area of the frame and a second data partition representing a second area of the frame (e.g., upper and lower halves or left and right halves).
- the video data may be divided into three data partitions, each respectively representing level, saturation, and hue information of the frame.
- the three data partitions could respectively represent cyan, magenta, and yellow information of the frame.
- the invention includes the aspect of predicting fractional pixel motion by selecting an interpolation method for each given plurality of pixels depending upon at least one metric related to each given block. Specifically, the value of the at least one metric associated with a given plurality of pixels to encode is determined, and an interpolation method of encoding the given plurality of pixels is selected depending upon the value of the at least one metric determined. The interpolation method thus selected is applied to the given plurality of pixels to encode, and the process is repeated steps for each successive plurality of pixels.
- the at least one metric may be at least one of motion vector length and a complexity factor.
- the interpolation methods may include bilinear, bicubic, quadratic, and B-spline interpolation.
- the given plurality of pixels may be an entire frame or a sub-portion thereof. If the motion vector length associated with the given plurality of pixels is determined to be less than the predetermined length value and the complexity factor associated with the given plurality of pixels is determined to be greater than the predetermined complexity value, then bicubic interpolation is selected.
- a predetermined length value and the predetermined complexity value is preferably set one time for a given number of pluralities of pixels, and possibly once per frame.
- the complexity factor is preferably a variance of the given plurality of pixels, calculated as
- the invention includes enhancing error recovery for a current frame using a frame prior to the frame immediately before the current frame as the only reference frame for lessening quality loss during data transmission.
- the invention includes using a frame coded prior to the last frame as the only reference frame for a given frame in order to lessen the quality loss associated with transmission over lines which produce lost or corrupt packets. This step is limited to at least one of periodically (every F frames) and arbitrarily (based on some other criteria).
- each party to a video conference compresses frames of video data and transmits the compressed video data to the other parties with packets that are marked such that the loss or corruption of a packet is detectable. If any party detects that a packet is lost or corrupted, the detecting party signals the sending party to send an update frame that has been encoded using a reference frame that has already been successfully received and decoded by all of the remaining parties.
- the invention may preferably use reference frames in the following manner.
- a fixed interval F of video frames may be selected by the encoder and transmitted to the decoder. Every F′th frame is encoded using only the previous encoded F′th frame for reference. Every non F′th frame is encoded using the prior frame as reference.
- Each frame of video is transmitted to the decoder so that loss and corruption are detectable. All of these steps preferably occur at the encoder.
- the coded video data is received from the encoder and decoded by the decoder. If a packet is lost and the lost packet is associated with a non F′th frame, the decoder waits for the next F′th frame to recover the lost packet.
- the invention encodes a current frame at least one of periodically and arbitrarily at a higher than ambient quality determined by a metric of statistics taken from this and prior coded frames and stores the encoded current frame for usage by subsequent frames as a secondary reference frame.
- DCT Discrete Cosine Transform
- the higher frequency AC coefficients are smaller in magnitude and hence less likely to be non zero following quantization. Consequently, prior to tokenization the coefficients are often arranged into ascending order starting with the lowest frequency coefficient (the DC value) and finishing with the highest frequency AC coefficient.
- This scan order sometimes referred to as “zig-zag order”, tends to group together the non-zero values at the start and the zero values into runs at the end and by so doing facilitates more efficient compression.
- One aspect of the invention is a method whereby a codec can optionally customize the scan order in which coefficients are encoded to more optimally reflect the characteristics of a particular data set.
- the codec maintains a record of the distribution of zero vs. non-zero values for each of the DCT coefficients, in one or more frames of video. This record is used to create a custom scan order where coefficients that are more likely to be non-zero appear earlier in the list.
- the codec may optionally collate additional information such as the average magnitude of the non-zero values for each coefficient and use this to further optimize the scan order.
- the overhead of transmitting a new custom scan order, or updating a previously transmitted scan order, may in some cases negate the benefit gained from improved coefficient coding efficiency. Hence, a cost benefit analysis may be necessary to determine if the update provides a net benefit.
- the main factors affecting the outcome of this analysis are the cost of update, the number of blocks (and hence coefficients) to be encoded and the extent to which the new scan order deviates from either a standard scan order or a previously encoded scan order.
- the situation can be improved still further by considering cost benefit at the level of individual coefficients or pairs of coefficients.
- cost benefit at the level of individual coefficients or pairs of coefficients.
- two coefficients are adjacent to one another in the scan order and where the likelihood of a non-zero value is almost identical for both.
- a small change in the number of non-zero values for one or other of the two coefficients could cause them to swap places in the custom scan order.
- To encode this change would mean updating the scan position for both coefficients at a cost of 14 bits (assuming the update model above).
- the saving achieved might be negligible.
- This problem is particularly relevant in respect of the high order AC coefficients.
- the frequency of non-zero values is typically very low and even a tiny change could cause a coefficients' position in the scan order to change significantly.
- the procedure for creating a custom scan order is broadly as follows:
- the second advantage is that the cost of updating the scan order is greatly reduced because it is only necessary to update a value when it moves from one band to another. Further, only 4 bits are needed to code a change in band.
- a final optimization used in the preferred implementation is based upon the observation that some coefficients change bands much more frequently than others. For example, the high order AC coefficients tend to change bands less often than the low order coefficients.
- This structure gives scan order update probabilities (scaled to the range of 1-255) // for each of the dct coefficients (in traditional zig-zag order). The values are passed // to the function “nDecodeBoolO” and indicate the probability that the result will be 0 // (FALSE).
- the inventive bitstream in common with most other video codecs, can broadly speaking be described as comprising entropy coded tokens that can be divided into two main categories.
- Predictor tokens (hereinafter referred to as P tokens). For example, tokens describing the method or mode used to code a block or region of an image and tokens describing motion between one frame and another.
- E tokens Prediction Error signal tokens (hereinafter referred to as E tokens). These are used to code any residual error that results from an imperfect prediction.
- Entropy coding is a process whereby the representation of a specific P or E token in the bitstream is optimized according to the frequency of that token in the bitstream or the likelihood that it will occur at a particular position. For example, a token that occurs very frequently will be; represented using a smaller number of bits than a token that occurs infrequently.
- Huffman Coding Two of the most common entropy coding techniques are Huffman Coding and arithmetic coding.
- Huffman coding each token is represented by a variable length pattern of bits (or a code).
- Arithmetic coding is a more computationally complex technique but it removes the restriction of using a whole number of bits for each token.
- Using an arithmetic coder it is perfectly possible, for example, to code a very common token at an average cost of 1 ⁇ 2 of a bit.
- This aspect of the invention is a method designed to make it easier to redistribute the computational load of entropy coding, and to facilitate the use of mixed mode entropy coding through structural changes to the bitstream.
- each frame in the bitstream is divided into two or more wholly independent data partitions.
- the partitions may be written to or read from in parallel and are not constrained to use the same entropy encoding mechanism. This makes it easier to optimize the process of encoding or decoding to avoid entropy related bottlenecks at high bit-rates.
- an encoder could be configured to use the less complex Huffman method in one or more of its partitions if the projected size of a frame exceeded a given threshold.
- Partition 1 (block 1) P, P, E, E, E (block2) P, E, E, (block3) P, P, E, E, E,
- Partition 1 Partition 2 (block1) PP EEE (block2) P EE (block3) P EEEE
- the size of the first partition does not tend to vary as much with data rate, and is comparatively small, so this partition is always coded using the arithmetic coder.
- the second partition may be coded using either the arithmetic coder or the Huffman coder.
- the choice of Huffman or arithmetic coding for the second partition can be signalled at the frame level. In the preferred implementation the choice depends upon the performance of the target decoder platform and the projected size in bits of the frame. Specifically, if the frame size rises above a threshold number, where there is a danger that the decoder will have problems decoding the frame in real time, then the Huffman method is used.
- Encoder performance can also be an issue where real time encoding is a requirement, but with the possible exception of key frames (which tend to be larger and have no dependencies on other frames), the cost of the entropy coding is usually a smaller fraction of the total computational cost in the encoder.
- VP6_StartEncode ( bc, (pbi ⁇ >DataOutputInPtr + ((KeyFrame) ? 2 : 1)) ); // Write out the frame header information including size.
- WriteFrameHeader (... ); if( pbi ⁇ >UseHuffman ) PackHufmmanCoeffs (... ); else PackArithmeticCoeffs (... ); // Stop the arithmetic coder instance used for the first data partition VP6_StopEncode ( be ); //Work out the offsets to the data partitions and write them into // the space reserved for this information in the raw header partition. // // If we are using two data partitions....
- Motion prediction is a process whereby the motion of objects or regions of the image is modelled over one or more frames and one or more motion vectors is transmitted in the bitstream to represent this motion. In most cases it is not possible to perfectly model the motion within an image, so it is necessary to code a residual error signal in addition to the motion information,
- each motion vector points to a region in a previously encoded frame that is similar to the region in the current frame that is to be encoded.
- the residual error signal is obtained by subtracting the predicted value of each pixel from the actual value in the current frame.
- modem video codecs extend the process by providing support for prediction of motion to sub pixel accuracy. For example half pixel or quarter pixel motion estimation. To create fractional pixel data points it is necessary to use some form of interpolation function or filter applied to real (i.e. full pixel aligned) data points.
- A, B, C, and D are full pixel aligned data points and x, y, and z are half pixel aligned points.
- x is a half pixel point that lies half way between two full pixel aligned pointes B and C.
- x ( ⁇ A+9B+9C ⁇ D)/16.
- This aspect of the invention is a method where by a codec can use a mixture of filtering techniques to create more optimal fractional pixel predictors and select between these methods at the clip level, the frame level, the block level or even at the level of individual pixels.
- a selection can be made on a per frame basis as to whether to use bilinear filtering only, bicubic filtering only or to allow a choice to be made at the block level.
- Selection at the block or region level could be achieved by means of explicit signalling bits within the bitstream, but in the preferred implementation selection is made using contextual information already available in the bitstream and by means of a complexity metric applied to the full pixel aligned data values that are going to be filtered.
- bilinear filtering is often the best option. Specifically where the prediction is poor the sharpening characteristics of the bicubic filter may lead to an increase in the high frequency content of the residual error signal and make it more difficult to encode.
- Bilinear filtering also tends to be the better option in situations where the choice of vector is unreliable (for example, where there is not very much detail in the image and there are many candidate vectors with similar error scores).
- repeated application of a bicubic filter over many frames, to a region that is relatively flat and featureless, may give rise to unwanted artefacts.
- the filtering method two factors are taken into account when choosing the filtering method.
- the first is the length of the motion vector.
- the second is a complexity metric C calculated by analyzing the set of full pixel aligned data points that are going to be filtered.
- Bicubic filtering is used only if both the following test conditions are satisfied:
- the motion vector is shorter than a threshold value L in both X and Y.
- the complexity C is greater than a threshold value T.
- C is a variance of a set of n data points xi calculated according to the formula:
- the complexity threshold T and the motion vector length threshold L may be set by the encoder on a once per frame basis.
- each vector is coded relative to the previous vector. For example, consider two vectors (7,3) and (8,4). In this case the second vector would be encoded as (1,1), that is (7+1, 3+1).
- This scheme works well if most blocks or regions for which a motion vector is coded exhibit motion that is similar to that of their neighbours. This can often be shown to be the case, for example when panning. However, it works less well if the motion field is irregular or where there are frequent transitions between background and foreground regions which have different motion characteristics.
- This aspect of the invention is an alternative strategy for encoding motion vectors which retains the advantages of differential coding whilst being more tolerant of irregular fields and background foreground transitions.
- the codec maintains two or more reference vectors relative to which motion vectors may be encoded.
- the codec could switch between these reference vectors via explicit signalling bits within the bitstream, but in the preferred implementation the decision is based upon the coding methods and motion vectors used by the blocks' immediate neighbours.
- a block may be coded as and intra block (with no dependency on any previous frames), or an inter block which is dependent upon either the previous frame reconstruction, or an alternative reference frame that is updated only periodically.
- the invention When coding with respect to the previous frame reconstruction or the alternative reference frame, the invention supports the following coding mode choices.
- the codec may use either (0,0) or the nearest vector as the reference vector.
- the nearest vector is used if the block from which it is derived is either the block immediately to the left or immediately above the current block (assuming that blocks are being coded from left to right and from top to bottom). In all other cases new vectors are coded with respect to (0,0).
- An alternative approach is simply to detect the error at the decoder and report it to the encoder. The encoder can then transmit a recovery frame to the decoder. Note that this approach may not be appropriate if the error rate on the link is very high. For example, more than one error in every 10-20 frames.
- recovery frame is a key frame (or intra only frame). This is a frame that does not have any dependencies on previous frames or the data therein.
- key frames are usually relatively large.
- Disclosed herein is a mechanism whereby a codec maintains a one or more additional references frames (other than the reconstruction of the previously coded frame) that can be used as a starting point for more efficiently coding of recovery frames.
- the codec maintains a second reference frame which is updated whenever there is a key frame and optionally at other times, via a flag bit in the frame header.
- the encoder could choose to update the second reference frame once every ‘X’ seconds or whenever an error recovery frame is encoded.
- differential coding with respect to the second reference frame is likely to be much cheaper than coding a key frame.
- one or more alternate reference frames may be used to enhance compression quality or efficiency.
- One obvious usage that is covered in the prior art is in video sequences that oscillate back and forth between two or more different scenes. For example, consider an interview where the video switches back and forth between interviewer and interviewee. By storing separate reference frames as a baseline for each camera angle the cost of switching back and forth between these can be greatly reduced, particularly when the scenes are substantially different.
- the subject of this invention is the use of a periodically updated alternate reference frame to enhance the quality of compressed video is situations where there is a slow progressive change in the video. Good examples of this are slow pans, zooms, or tracking shots.
- the encoder periodically inserts frames which are encoded at a significantly higher quality than the surrounding frames and which cause the second or alternative reference frame to be updated.
- second reference update frames The purpose of these higher quality “second reference update” frames is to re-instate detail that has incrementally been lost since the last key frame, or the last second reference update, and to provide a better basis for inter frame prediction in subsequent frames.
- This strategy of periodically raising the quality (and hence the data rate) and at the same time updating the second reference frame can be shown to provide a much better cost/quality trade off in some situations than simply coding all the frames at a similar quality.
- the quality boost is increased. Conversely in cases where the second reference frame is not used frequently it is decreased.
- the extent of the quality boost also depends to some extent on the ambient quality with a larger boost being used when the ambient quality is low and a smaller boost when the ambient quality is high.
- Multiply Boost by a MotionSpeed correction factor where the factor can vary between 1 for very small values of MotionSpeed to 0 for large values of MotionSpeed.
- Apply a further correction factor to Boost based upon the extent to which the second reference frame has been used in the previous few frames. This can vary from 1/16 in cases where the second reference frame was not used at all in the previous few frames up to 1 in cases where it was used for 15% or more of the coded blocks.
- a series of tests are then applied to determine whether or not to go ahead and update the second reference frame with the calculated % boost.
- MinBoostTreshold, MaxMotionSpeedThreshold and MaxVarianceThreshold are configurable parameters.
- the invention has a number of special “motion re-use” modes that allow the motion vector for a block to be coded more cheaply if it is the same as the motion vector used by one of its near neighbours. Further tests are applied to discount cases where the usage of these modes falls below a threshold level.
- A, B, C, and D are full pixel aligned data points and x,y and z are half pixel aligned points.
- Point x is half pixel aligned in the X direction and would be calculated using the formula (A+B/2).
- Point y is half pixel aligned in the Y direction and would be calculated using the formula (A+C/2).
- Point z is half pixel aligned in both X and Y would be calculated using the formula (A+B+C+D)/2).
- x is a half pixel point that lies half way between two full pixel aligned pointes B and C. It can be calculated using the formula ( ⁇ A+9B+9C ⁇ D)/16.
- This aspect of the invention is a method where by a codec can use a mixture of bilinear and bicubic filtering to calculate more optimal fractional pixel predictors and select between these methods either at a frame level or at the level of the individual blocks or regions to which motion vectors are applied.
- Selection at the block or region level could be achieved by means of signalling bits within the bitstream, but in the preferred implementation selection is made by means of a complexity metric applied to the set of pixels in the previous reconstructed image that are going to be filtered.
- blocks or regions with a complexity score above a threshold value “T” are filtered using the bicubic method whilst those with a lower complexity score are filtered using the bilinear method.
- the complexity metric is the variance of the set of “n” full pixel aligned data points to be filtered, where variance is defined as:
- the threshold value T′ may be updated on a once per frame basis.
Abstract
A system, apparatus, and method for decoding a video signal having a plurality of frames including a current frame. Decoding the video signal can include generating an alternate reference frame having a first quality level, determining a boost value indicative of a second quality level higher than the first quality level, determining whether to apply the boost value to the alternative reference frame, and selectively applying the boost value to the alternative reference frame if it is determined to apply the boost value to the alternative reference frame. The alternate reference frame can occur prior to the current frame in the video signal and other than a frame immediately prior to the current frame.
Description
- This application is a continuation of U.S. patent application Ser. No. 10/713,807, filed on Nov. 14, 2003, which claims priority from U.S. Provisional Application No. 60/469,187, filed on May 12, 2003. U.S. patent application Ser. No. 10/713,807 and U.S. Provisional Application No. 60/469,187 are both incorporated herein by reference in their entirety.
- The invention relates to video data and more specifically to methods and systems of coding, decoding, compressing, and transmitting video data in as efficient a manner as possible.
- The transmission of data is usually constrained by bandwidth and throughput limitations. One cannot send or receive an infinite amount of information in an infinitesimal amount of time. In order to maximize the amount and quality of information being transmitted, in some cases the information is compressed or coded for transmission and uncompressed or decoded upon reception.
- One area in which data compression is essential is in the transmission of video data. Ordinary text, unless voluminous, is easily and quickly transmitted. However, video data can include aspects of color, brightness, and often stereo audio information. A large amount of data is required to define even short video clips. The transmission and coding of such data must be as efficient as possible, i.e., it must require as little information as possible to be transmitted.
- Video compression is a subset of the general technique of data compression, whereby a signal is squeezed or compressed into a smaller set of numbers. These numbers will then take up less space on a hard drive, or take less time to transmit over a network. Before the numbers are used again, a decompression algorithm is applied to expand the series of numbers to its original (or at least a similar) form.
- Video compression utilizes the fact that the signal is known to originate as digitized video, in order to increase the compression ratio, or the amount of squeezing that can be applied to the series of numbers to be stored or transmitted. Significant compression of video and audio are considered lossy algorithms because they discard or lose some portion of the original information; the reconstructed number series does not exactly match the original. This is acceptable because the precision with which we view video and audio, compared to the resolution of the digitization process, is not perfect. While the video signal may become slightly distorted, it is still recognizable. The degree to which a compression algorithm faithfully reproduces the original signal with minimum distortion or loss is a measure of the success of the algorithm.
- There are a number of good reasons to compress video and audio signals, including technical issues and cost of equipment. one overriding issue is the cost of transmitting data. As the Internet matures into the de facto data transport platform for the 21st century, analog media such as videotape, film, and broadcast will be supplanted by a digital media infrastructure built on the Internet and Internet-related technologies. This digital infrastructure will allow data to be transferred between any two computing machines on the planet, if so desired. However, the speed at which this data can be sent will depend on a number of factors. In the limiting case, copper wires laid down over a century ago and intended for analog voice communications are used with modem technology (modem stands for Modulation/DEModulation) to transmit data at speeds as low as 9600 bits per second. Similar speeds are used to carry voice over wireless networks such as cellular. Recently, cable modem, DSL, and satellite technologies have brought six-figure data rates (100,000 to 1 million bits/second) to home users. For high-end applications, optical fiber enables data rates into the gigabit range (billions of bits per second) and beyond.
- Whatever the data rate available for a given application, transmitting data costs money. At the present time, the cost of sending one megabyte (8 million bits) over the Internet usually costs anywhere from 5 cents at low volume, down to as low as one cent at extremely high volume (this figure does not include the cost at the receiving end). Therefore, the cost of transporting a megabyte of data from one place to another is always more than a penny.
- Much work has been done in the field of video data compression. Some of the features of video codecs in existence include Discrete Cosine Transform compression, entropy coding, and differential coding of motion vectors. Prior codecs also utilize reference frames so that if a data packet is lost or corrupted, the data can be retrieved by referring to a reference frame. All of these features and difficulties therewith will be discussed in greater detail below.
- In DCT (Discrete Cosine Transform) based video compression systems, an 8 by 8 block of pixel or prediction error signal data is transformed into a set of 64 frequency coefficients (a DC value and 63 AC values), which are then quantized and converted into a set of tokens.
- Typically the higher frequency AC coefficients are smaller in magnitude and hence less likely to be non zero (i.e., more likely to be zero) following quantization. Consequently, prior to tokenization, the coefficients are often arranged in ascending order starting with the lowest frequency coefficient (the DC value) and finishing with the highest frequency AC coefficient. This scan order, sometimes referred to as “zig-zag order”, tends to group together the non-zero values at the start and the zero values into runs at the end and by so doing facilitates more efficient compression.
- However, this fixed scan order is seldom optimal. For example, when encoding interlaced video material, certain high frequency coefficients are much more prominent. This fact is reflected in the prior art where there are examples of codecs (for example MPEG-2), that mandate an alternative scan order for use when coding interlaced video.
- When optimizing a codec for a specific hardware device, it is important to make sure that full use is made of any facilities that the device may offer for performing multiple tasks in parallel and to limit the extent to which individual parts of the decode process become bottlenecks.
- The instant invention's bitstream, in common with most other video codecs, can broadly speaking be described as comprising entropy coded tokens that can be divided into two main categories: predictor or P tokens and prediction error or E tokens. P tokens are tokens describing the method or mode used to code a block or region of an image and tokens describing motion between one frame and another. E tokens are used to code any residual error that results from an imperfect prediction.
- Entropy coding is a process whereby the representation of a specific P or E token in the bitstream is optimized according to the frequency of that token in the bitstream or the likelihood that it will occur at a particular position. For example, a token that occurs very frequently will be represented using a smaller number of bits than a token that occurs infrequently.
- Two of the most common entropy coding techniques are Huffman Coding and arithmetic coding. In Huffman coding each token is represented by a variable length pattern of bits (or a code). Arithmetic coding is a more computationally complex technique but it removes the restriction of using a whole number of bits for each token. Using an arithmetic coder, it is perfectly possible to code a very common token at an average cost of 2% of a bit.
- Many multimedia devices have a co-processor unit that is well suited to the task of entropy coding and a more versatile main processor. Consequently, for the purpose of parallelization, the process of encoding or decoding a bitstream is often divided into entropy related tasks and non entropy related tasks. However, for a given video clip, as the data rate increases, the number of tokens to encode/decode rises sharply and entropy coding may become a bottleneck.
- With a conventional bitstream it is very difficult to re-distribute the computational load of entropy coding to eliminate this bottleneck. In particular, on the decode side, the tokens must normally be decoded one at a time and in the order in which they were encoded. It is also extremely difficult to mix methods or entropy encoding (for example Huffman and arithmetic coding) other than at the frame level.
- By convention, most modern video codecs code the (x, y) components of a motion vector, using a differential coding scheme. That is, each vector is coded relative to the previous vector. For example, consider two vectors (7,3) and (8,4). In this case the second vector would be encoded as (1,1), that is (7+1, 3+1).
- This scheme works well if most blocks or regions for which a motion vector is coded exhibit motion that is similar to that of their neighbors. This can often be shown to be the case, for example when panning. However, it works less well if the motion field is irregular or where there are frequent transitions between background and foreground regions which have different motion characteristics.
- For most modern video codecs, motion prediction is an important part of the compression process. Motion prediction is a process whereby the motion of objects or regions of the image is modelled over one or more frames and one or more ‘motion vectors’ is transmitted in the bitstream to represent this motion. In most cases it is not possible to perfectly model the motion within an image, so it is necessary to code a residual error signal in addition to the motion information.
- In essence, each motion vector points to a region in a previously encoded frame that is similar to the region in the current frame that is to be encoded. The residual error signal is obtained by subtracting the predicted value of each pixel from the actual value in the current frame.
- Many modern video codecs extend the process by providing support for prediction of motion to sub pixel accuracy, e.g, half-pixel or quarter-pixel motion estimation. To create fractional pixel data points, it is necessary to use some form of interpolation function or filter applied to real (i.e. full pixel aligned) data points.
- Early codecs generally used simple bilinear interpolation as shown in FIG. 1 attached hereto. In this example, A, B, C, and D are full-pixel aligned data points and x, y, and z are half-pixel aligned points. Point x is half-pixel aligned in the X direction and can be calculated using the equation:
-
x=(A+B)/2. (1) - Point y is half-pixel aligned in the Y direction and can be calculated using the equation:
-
y=(A+C)/2. (2) - Point z is half-pixel aligned in both X and Y can be calculated using the equation:
-
z=(A+B+C+D)/2. (3) - Later codecs have tended to move towards the use of more complex interpolation filters, such as bicubic filters, that are less inclined to blur the image. In the example shown in FIG. 2, x is a half-pixel point that lies half way between two full pixel aligned pointes B and C. Using an integer approximation to a bicubic filter it can be calculated using the equation:
-
x=(−A+9B+9C−D)/16. (4) - Though filters such as the one illustrated above tend to produce sharper looking results, their repeated application over several frames can in some situations result in unpleasant artefacts such as false textures or false contouring.
- When transmitting compressed video data over an unreliable or questionable data link, it is important that a mechanism exists for recovering when data is lost or corrupted, as video codecs are often extremely sensitive to errors in the bitstream.
- Various techniques and protocols exist for the reliable transmission of data of such links, and these typically rely upon detection of the errors and either re-transmission or the use of additional data bits that allow certain types of error to be corrected. In many situations the existing techniques are adequate, but in the case of video conferencing over restricted bandwidth links neither of the above mentioned approaches is ideal. Re-transmission of lost data packets may not be practical because it is likely to cause an increased end to end lag, while the use of error correction bits or packets may not be acceptable in situations where bandwidth is already severely restricted.
- An alternative approach is simply to detect the error at the decoder and report it to the encoder. The encoder can then transmit a recovery frame to the decoder. Note that this approach may not be appropriate if the error rate on the link is very high, e.g., more than one error in every 10-20 frames.
- The simplest form of recovery frame is a key frame (or intra only frame). This is a frame that does not have any dependencies on previous frames or the data therein. The problem with key frames is that they are usually relatively large.
- Disclosed herein are aspects of systems, methods, and apparatuses for encoding and decoding video signals.
- One aspect of the disclosed implementations is a method for decoding a video signal having a plurality of frames including a current frame. The method includes generating an alternate reference frame having a first quality level; determining a boost value, the boost value indicative of a second quality level higher than the first quality level; determining whether to apply the boost value to the alternate reference frame; and selectively applying the boost value to the alternate reference frame based on the determination whether to apply the boost value to the alternate reference frame. The alternate reference frame can occur prior to the current frame in the video signal and other than a frame immediately prior to the current frame.
- Another aspect of the disclosed implementations is a method for encoding a video signal having a plurality of frames including a current frame. The method includes generating an alternate reference frame having a first quality level; determining a boost value, the boost value indicative of a second quality level higher than the first quality level; determining whether to apply the boost value to the alternate reference frame; and selectively applying the boost value to the alternate reference frame based on the determination whether to apply the boost value to the alternate reference frame. The alternate reference frame can occur prior to the current frame in the video signal and other than a frame immediately prior to the current frame.
- Another aspect of the disclosed implementations is an apparatus for decoding a video signal having a plurality of frames including a current frame. The apparatus comprises a memory and a processor configured to execute instructions stored in the memory to: generate an alternate reference frame having a first quality level, wherein the alternate reference frame occurs prior to the current frame in the video signal and wherein the alternate reference frame is other than a frame immediately prior to the current frame; determine a boost value, the boost value indicative of a second quality level higher than the first quality level; determine whether to apply the boost value to the alternate reference frame; and selectively apply the boost value to the alternate reference frame based on the determination whether to apply the boost value to the alternate reference frame.
- It is an object of the invention to provide a video compression method and codec that is efficient and reliable.
- It is another object of the invention to provide a video compression method and codec that can perform discrete cosine transforms in an adaptive manner.
- It is another object of the invention to provide a video compression method and codec that performs entropy coding that optimizes the resources of the hardware devices being employed.
- It is another object of the invention to provide a video compression method and codec that enhances motion vector coding.
- It is another object of the invention to provide a video compression method and codec that accurately and efficiently performs fractional pixel motion prediction.
- It is another object of the invention to provide a video compression method and codec that performs error recovery efficiently, even in the environment of a video conference.
- The above and other objects are fulfilled by the invention, which is a method of compressing video data having at least one frame having at least one block and each block having an array of pixels. The disclosure includes at least one of the following steps: I) transforming the pixels of each block into coefficients and creating an optimal transmission order of the coefficients; II) optimizing the speed of processing compressed video data by partitioning the data bitstream and coding each partition independently; III) predicting fractional pixel motion by selecting an interpolation method for each given plurality of pixels depending upon at least one metric related to each given block; and IV) enhancing error recovery for a current frame using a frame prior to the frame immediately before the current frame as the only reference frame for lessening quality loss during data transmission.
- As for the coefficient reordering aspect of the invention, the method transforms the pixels of each block into coefficients, each coefficient having a coefficient position and a value and determines a position value related to each coefficient position. An optimal transmission order of coefficients is then created based on the position values of each coefficient position, and the coefficients are transmitted in the order so determined. Preferably, the transmission order of coefficients is dynamically re-ordered for each frame of video data. The transforming step preferably transforms the pixels into discrete cosine transform coefficients. The transmission order of coefficients may be transmitted along with the coefficients. Preferably, each block has the same number of coefficients and coefficient positions, and each corresponding respective coefficient position conveys the same respective information from block to block.
- In an effort to reduce the amount of data being transmitted, the transmission of coefficient order data may be limited to changes in the coefficient order from one frame to the next frame. Alternatively or in addition, the transmission order may be consolidated into bands of coefficients, each band having a plurality of coefficients organized by rank in numbers determined above. In this case, only band information may be transmitted along with the coefficients. Preferably, only band information will be transmitted where a coefficient changes bands from one frame to the next. As another alternative, all band information may always be transmitted.
- Reordering the coefficients can also include the provision of a key frame. The inventive method may provide such a key frame which is always completely self-encoded and requires no information from or about a previous frame. In such a case, the encoder determines if a given frame is a key frame. If it is determined that the given frame is a key frame, the entire transmission order of coefficients for the key frame is transmitted. If it is determined that the given frame is not a key frame, only changes in the transmission order of coefficients from the previous frame to the given frame are transmitted.
- As mentioned above, the invention contemplates optimizing the speed of processing compressed video data by partitioning the data bitstream and coding each partition independently. Specifically, the invention divides the video data into at least two data partitions and selects an optimal entropy coding method for each data partition. The entropy coding methods thus selected are applied respectively to each data partition. In one embodiment, the video data is divided into a predictor token data partition and an error token data partition; preferably, each data partition undergoes a different entropy coding method, such as Huffman coding and arithmetic coding. The various decoding processes of the different data partitions may be performed asynchronously and/or independently. This may be accomplished by providing at least two subprocessors in the hardware, wherein one data partition is decoded by one subprocessor and another data partition is decoded by another subprocessor. Determining which entropy coding method is to be used for a given data partition may be based on the size of the given data partition.
- In one embodiment of the method and codec, the predictor token data partition is read and converted into a predictor block. The error token data partition is also read and is converted into coefficients and thence an error block. The predictor block and the error block are summed to form an image block. As mentioned above, it is preferable to provide at least two subprocessors, wherein some of these steps are performed on one subprocessor and the rest of the steps are performed on another subprocessor. Specifically, the steps of reading the error token data partition and converting the error token data partition into coefficients are preferably performed by a fast entropy optimized subprocessor, and the other steps are preferably performed by a general purpose subprocessor.
- The method optimizes decoder performance of the bitstream in a way that avoids data and code cache misses. As many distinct functions of the decoder's code as can fit into the code cache are stored there. The code from this step is run for as many blocks as can fit into the data cache. The next set of distinct functions of the decoder's code and then collected, and the process is repeated until all of the bitstream has been read and each of the blocks of data have been produced.
- Another aspect of optimizing decoder performance of the bitstream optimizes the utilization of the subprocessors by assigning each subtask to a separate processor. Preferably, the portion of the decoder that reads error tokens from the bitstream and translates them into coefficients is run on a fast entropy optimized subprocessor. The portion of the decoder that reads the predictor tokens from the bitstream and builds a filtered predictor block from these tokens is run on a subprocessor with fast access to memory. The portion of the decoder that translates the transform coefficients from the above step into an error signal is run on a subprocessor that has an optimized implementation of the transform coder, and the portion of the decoder that adds the predictor block to the error signal is run on a subprocessor optimized for motion compensation.
- The video data may be divided into two data partitions, a first data partition representing a first area of the frame and a second data partition representing a second area of the frame (e.g., upper and lower halves or left and right halves). Alternatively, the video data may be divided into three data partitions, each respectively representing level, saturation, and hue information of the frame. In another version, the three data partitions could respectively represent cyan, magenta, and yellow information of the frame.
- As mentioned before, the invention includes the aspect of predicting fractional pixel motion by selecting an interpolation method for each given plurality of pixels depending upon at least one metric related to each given block. Specifically, the value of the at least one metric associated with a given plurality of pixels to encode is determined, and an interpolation method of encoding the given plurality of pixels is selected depending upon the value of the at least one metric determined. The interpolation method thus selected is applied to the given plurality of pixels to encode, and the process is repeated steps for each successive plurality of pixels. The at least one metric may be at least one of motion vector length and a complexity factor. The interpolation methods may include bilinear, bicubic, quadratic, and B-spline interpolation. The given plurality of pixels may be an entire frame or a sub-portion thereof. If the motion vector length associated with the given plurality of pixels is determined to be less than the predetermined length value and the complexity factor associated with the given plurality of pixels is determined to be greater than the predetermined complexity value, then bicubic interpolation is selected. A predetermined length value and the predetermined complexity value is preferably set one time for a given number of pluralities of pixels, and possibly once per frame.
- The complexity factor is preferably a variance of the given plurality of pixels, calculated as
-
C=(n Ex i 2−(Ex i)2)/n 2 (4) - As mentioned above, the invention includes enhancing error recovery for a current frame using a frame prior to the frame immediately before the current frame as the only reference frame for lessening quality loss during data transmission. Specifically, the invention includes using a frame coded prior to the last frame as the only reference frame for a given frame in order to lessen the quality loss associated with transmission over lines which produce lost or corrupt packets. This step is limited to at least one of periodically (every F frames) and arbitrarily (based on some other criteria).
- This aspect of the invention is particularly well-suited for a video conference. Specifically, each party to a video conference compresses frames of video data and transmits the compressed video data to the other parties with packets that are marked such that the loss or corruption of a packet is detectable. If any party detects that a packet is lost or corrupted, the detecting party signals the sending party to send an update frame that has been encoded using a reference frame that has already been successfully received and decoded by all of the remaining parties.
- The invention may preferably use reference frames in the following manner. A fixed interval F of video frames may be selected by the encoder and transmitted to the decoder. Every F′th frame is encoded using only the previous encoded F′th frame for reference. Every non F′th frame is encoded using the prior frame as reference. Each frame of video is transmitted to the decoder so that loss and corruption are detectable. All of these steps preferably occur at the encoder. On the decoder side, the coded video data is received from the encoder and decoded by the decoder. If a packet is lost and the lost packet is associated with a non F′th frame, the decoder waits for the next F′th frame to recover the lost packet.
- As another alternative, the invention encodes a current frame at least one of periodically and arbitrarily at a higher than ambient quality determined by a metric of statistics taken from this and prior coded frames and stores the encoded current frame for usage by subsequent frames as a secondary reference frame.
- Variations in these and other aspects will be described in additional detail hereafter.
- Several different aspects of the invention will be described hereinafter.
- Dynamic Coefficient Reordering
- In DCT (Discrete Cosine Transform) based video compression systems an 8 by 8 block of pixel or prediction error signal data is transformed into a set of 64 frequency coefficients (a DC value and 63 AC values), which are then quantized and converted into a set of tokens.
- Typically the higher frequency AC coefficients are smaller in magnitude and hence less likely to be non zero following quantization. Consequently, prior to tokenization the coefficients are often arranged into ascending order starting with the lowest frequency coefficient (the DC value) and finishing with the highest frequency AC coefficient. This scan order, sometimes referred to as “zig-zag order”, tends to group together the non-zero values at the start and the zero values into runs at the end and by so doing facilitates more efficient compression.
- However, this fixed scan order is seldom optimal. For example, when encoding interlaced video material, certain high frequency coefficients are much more prominent. This fact is reflected in the prior art where there are examples of cbdecs (for example MPEG-2), that mandate an alternative scan order for use when coding interlaced video.
- One aspect of the invention is a method whereby a codec can optionally customize the scan order in which coefficients are encoded to more optimally reflect the characteristics of a particular data set.
- According to this invention the codec maintains a record of the distribution of zero vs. non-zero values for each of the DCT coefficients, in one or more frames of video. This record is used to create a custom scan order where coefficients that are more likely to be non-zero appear earlier in the list.
- The codec may optionally collate additional information such as the average magnitude of the non-zero values for each coefficient and use this to further optimize the scan order.
- The overhead of transmitting a new custom scan order, or updating a previously transmitted scan order, may in some cases negate the benefit gained from improved coefficient coding efficiency. Hence, a cost benefit analysis may be necessary to determine if the update provides a net benefit.
- The main factors affecting the outcome of this analysis are the cost of update, the number of blocks (and hence coefficients) to be encoded and the extent to which the new scan order deviates from either a standard scan order or a previously encoded scan order.
- For an 8×8 element DCT, coding a “complete” custom scan order (i.e., a new position for every one of the 64 coefficients), would require 384 bits (64 coefficients×6 bits each). This cost is likely to be prohibitive unless the number of blocks (and hence coefficients) to be coded is very large or the optimum scan order differs very significantly from the default scan order (this being either a standard scan order or one previously encoded). The rationale behind this statement is that if the default scan order is similar to the custom scan order, then the average number of bits saved coding each block is likely to be small, hence a large number of blocks must be coded to justify the overhead of updating the scan order. Conversely if the default scan order is dissimilar to the custom scan order, then the average saving per block is likely to be high.
- A simple way to improve this situation would be to only code changes to the scan order. For example, for each coefficient, code a bit to indicate whether it has changed its position in the scan order and then if appropriate its new position. Though this will typically result in a lower update cost, the worst case scenario here is where the new scan order is different for all coefficients, in which case the cost of update would be 448 bits (64×7).
- An attractive aspect of such an approach is that the cost of update is lowest where the custom and default scan order are most similar (and hence the likely cost saving per block is at its lowest), and highest when they are most dissimilar.
- The situation can be improved still further by considering cost benefit at the level of individual coefficients or pairs of coefficients. Consider, for example, a case where two coefficients are adjacent to one another in the scan order and where the likelihood of a non-zero value is almost identical for both. A small change in the number of non-zero values for one or other of the two coefficients could cause them to swap places in the custom scan order. To encode this change would mean updating the scan position for both coefficients at a cost of 14 bits (assuming the update model above). However, the saving achieved might be negligible. This problem is particularly relevant in respect of the high order AC coefficients. Here, the frequency of non-zero values is typically very low and even a tiny change could cause a coefficients' position in the scan order to change significantly.
- While it is certainly feasible to base the calculation of a custom scan order purely upon the distribution of zeros vs. non-zeros for each coefficient, there are other factors that are relevant. As mentioned previously, one of these is the average magnitude of the non-zero values. Another is the fact that in some cases a positive correlation may exist between the values of one or more coefficients. For example, between a low order “pure horizontal” AC coefficient and higher order ‘pure horizontal’ coefficients. In such cases, unless there is a substantial difference in the prevalence of non-zero values, it may be preferable to keep them in their original order (lowest frequency to highest frequency).
- The preferred implementation of this aspect of the invention goes some way to addressing such issues whilst further reducing the cost of updating the scan order. The procedure for creating a custom scan order is broadly as follows:
- (a) The DC coefficient is always coded first (position 0)
- (b) Order the AC coefficients into descending order based upon the proportion of the values that are non-zero for each coefficient.
- (c) Split the ordered list into 16 variable sized bands (see table 1)
- (d) Within each band re-order into zig-zag scan order.
- Note that the subdivision into 16 bands as shown in Table 1 is based upon empirical observations with a range of different test clips and is not necessarily optimal.
-
TABLE 1 Preferred scan order coefficient bands Band First coefficient Last coefficient 0 1 1 1 2 4 2 5 10 3 11 12 4 13 15 5 16 19 6 20 21 7 22 26 8 27 28 9 29 34 10 35 36 11 37 42 12 43 48 13 49 53 14 54 57 15 58 63 - Empirical experiments show that this banding strategy gives results that are usually as good as and often better than those obtained using a scan order based purely upon the proportion of the values that are non zero; even before the cost of update is taken into account.
- The second advantage is that the cost of updating the scan order is greatly reduced because it is only necessary to update a value when it moves from one band to another. Further, only 4 bits are needed to code a change in band.
- A final optimization used in the preferred implementation is based upon the observation that some coefficients change bands much more frequently than others. For example, the high order AC coefficients tend to change bands less often than the low order coefficients.
- If a particular coefficient is only updated 2% of the time, for example, then it is wasteful to use 1 bit to indicate whether or not it is to be updated on a given frame. By using arithmetic coding techniques and assigning empirically determined update probabilities to each coefficient, it is possible to get the average update cost substantially below 1 bit per coefficient.
- The following “C” code segments give supporting detail of the preferred implementation of this aspect of the invention.
-
//Work out a new “preferred” scan order using the zero/ non-zero frequency data //that has been collected. void CalculateScanOrder ( CP_INSTANCE *cpi ) { UINT32i, j, k; UINT32 Sum; UINT32 tmp[2]; UINT32 NzValue [BLOCK_SIZE][2]; UINT32 GroupStartPoint, GroupEndPoint; // For each coefficient, calculate the proportion of the values that 11 were non-zero as a scaled number from 0-255. for ( i=1; i<BLOCK_SIZE; i++ ) { Sum = cpi−>FrameNzCount[i][OJ + cpi−>FrameNzCount[i][1]; if( Sum ) NzValue [i][0] = (cpi−>FrameNzCount[i][I]*255)/Sum; else NzValue [i] [0] = 0; NzValue [i][1] = i; } // Sort into decending order for ( i=1; i<BLOCK SIZE−1; i++ ) { for (j =i+1; j>1; j−− ) { if ( NzValue [j][0] > NzValue [j−l][0] ) { // Swap them over tmp[O] = NzValue [j− MO]; tmp[1] = NzValue [j−l][1]; NzValue [j−I][0] =NzValue [j][0]; NzValue [j−l][1] = NzValue [j][1]; NzValue [j][0] = tmp[O]; NzValue [j][1] = tmp[1]; } } } //Split into bands and then re-sort within each band // into ascending order based upon zig-zag scan position GroupEndPoint = 0; for ( k = 0; k<SCAN_ORDER BANDS; k++ ) { GroupStartPoint = GroupEndPoint + 1; GroupEndPoint EndpointLookup[k]; for ( i=GroupStartPoint; i<GroupEndPoint; i++ ) { for (j =i+1; j>GroupStartPoint; j−− ) { if( NzValue [j][1] < NzValue [j−1][l] ) { // Swap them over tmp[O] = NzValue U−1][0]; tmp[1] =NzValue[j−l][1]; NzValue [j−I][0] = NzValue [j][0]; NzValue [1−1][1] = NzValue NzValue [j][0] = tmp[0]; } } // For each coef index mark its band number for ( i=GroupStartPoint; i<<GroupEndPoint; i++ ) { // Note the new scan band number for each coef. // NzValue [i][1] is the position of the coef in the traditional // zig-zag scan order, i is the position in the new scan order and /I k is the band number, cpi−>NewScanOrderBands[ NzValue [i][1J ] = k; } } } // This structure gives scan order update probabilities (scaled to the range of 1-255) // for each of the dct coefficients (in traditional zig-zag order). The values are passed // to the function “nDecodeBoolO” and indicate the probability that the result will be 0 // (FALSE). // const UINT8 ScanBandUpdateProbs[BLOCK SIZE] — { 255, 132, 132, 159, 153, 151, 161, 170, 164, 162, 136, 110, 103, 114, 129, 118, 124, 125, 132, 136, 114, 110, 142, 135, 134, 123, 143, 126, 153, 183, 166, 161, 171, 180, 179, 164, 203, 218, 225, 217, 215, 206, 203, 2I7, 229, 241, 248, 243, 253, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }; // Reads updates to the scan order if they are available for this frame. void UpdateScanOrder( PB INSTANCE*pbi ) { // Is the scan order being updated this frame? If (nDecodeBool( 128 ) ) { // Read in the those scan bands that have been updated for (i = l; i < BLOCK SIZE; i++ ) for (i = l; i < BLOCK SIZE; i++ ) { U Has the band for this coefficient been updated? if( nDecodeBool( ScanBandUpdateProbs[i] ) ) { pbi−>ScanBands[i] = VP6_bitread( SCAN_BAND UPDATE BITS ); } //Build the new scan order from the scan bands data BuildScanOrder( pbi, pbi−>ScanBands ); } } // Builds a custom scan order from a set of scan band data, void BuildScanOrder( P8 ...INSTANCE *pbi, UINT8 *ScanBands ) { UINT32 i, j; UINT32 ScanOrderIndex =1; // DC is fixed pbi−>ModifedScanOrder[O] = 0; // Create a scan order where within each band the coefs are in ascending order //(in terms of their original “zig-zag” scan order positions). for ( i = 0; i < SCAN_ORDER BANDS; i++ ) { for (j = 1;j < BLOCK SIZE; j++ ) { if( ScanBands[j] == i ) { pbi−>ModifiedScanOrder[ScanOrderindex] = j; ScanOrderindex++; } } } } - Using Independent Bitstream Partitions to Facilitate Encoder and Decoder Optimization, and Using of Mixed Mode Entropy Coding
- When optimizing a codec for a specific hardware device, it is important to make sure that full use is made of any facilities that the device may offer for performing multiple tasks in parallel and to limit the extent to which individual parts of the decode process become bottlenecks.
- The inventive bitstream, in common with most other video codecs, can broadly speaking be described as comprising entropy coded tokens that can be divided into two main categories.
- (a) Predictor tokens (hereinafter referred to as P tokens). For example, tokens describing the method or mode used to code a block or region of an image and tokens describing motion between one frame and another.
- (b) Prediction Error signal tokens (hereinafter referred to as E tokens). These are used to code any residual error that results from an imperfect prediction.
- Entropy coding is a process whereby the representation of a specific P or E token in the bitstream is optimized according to the frequency of that token in the bitstream or the likelihood that it will occur at a particular position. For example, a token that occurs very frequently will be; represented using a smaller number of bits than a token that occurs infrequently.
- Two of the most common entropy coding techniques are Huffman Coding and arithmetic coding. In Huffman coding each token is represented by a variable length pattern of bits (or a code). Arithmetic coding is a more computationally complex technique but it removes the restriction of using a whole number of bits for each token. Using an arithmetic coder it is perfectly possible, for example, to code a very common token at an average cost of ½ of a bit.
- Many multimedia devices have a co-processor unit that is well suited to the task of entropy coding and a more versatile main processor. Consequently, for the purpose of parallelization, the process of encoding or decoding a bitstream is often divided into entropy related tasks and non entropy related tasks.
- However, for a given video clip, as the data rate increases the number of tokens to encode/decode rises sharply and entropy coding may become a bottleneck.
- With a conventional bitstream it is very difficult to re-distribute the computational load of entropy coding to eliminate this bottleneck. In particular, on the decode side, the tokens must normally be decoded one at a time and in the order in which they were encoded. It is also extremely difficult to mix methods or entropy encoding (for example Huffman and arithmetic coding) other than at the frame level.
- This aspect of the invention is a method designed to make it easier to redistribute the computational load of entropy coding, and to facilitate the use of mixed mode entropy coding through structural changes to the bitstream.
- According to this method each frame in the bitstream is divided into two or more wholly independent data partitions. The partitions may be written to or read from in parallel and are not constrained to use the same entropy encoding mechanism. This makes it easier to optimize the process of encoding or decoding to avoid entropy related bottlenecks at high bit-rates.
- The ability to use both Huffman and arithmetic techniques, or a mixture of the two, within a single frame, gives the encoder the ability to better optimize the tradeoff between the amount of compression achieved and computational complexity. For example, an encoder could be configured to use the less complex Huffman method in one or more of its partitions if the projected size of a frame exceeded a given threshold.
- The specific implementation of this aspect of the invention supports the use of either one or two main data partitions. In addition there is a small header partition.
- When using a single data partition the codec behaves in a conventional manner. Both P and E tokens are coded using a proprietary arithmetic coder in a single data partition. This method has slightly lower overheads (a few bits per frame) but is less flexible. For example:
-
Partition 1 (block 1) P, P, E, E, E (block2) P, E, E, (block3) P, P, E, E, E, - In the second case, however, the P and E tokens are written to separate partitions. For example:
-
Partition 1 Partition 2 (block1) PP EEE (block2) P EE (block3) P EEEE - The size of the first partition does not tend to vary as much with data rate, and is comparatively small, so this partition is always coded using the arithmetic coder. The second partition may be coded using either the arithmetic coder or the Huffman coder.
- The choice of Huffman or arithmetic coding for the second partition can be signalled at the frame level. In the preferred implementation the choice depends upon the performance of the target decoder platform and the projected size in bits of the frame. Specifically, if the frame size rises above a threshold number, where there is a danger that the decoder will have problems decoding the frame in real time, then the Huffman method is used.
- Encoder performance can also be an issue where real time encoding is a requirement, but with the possible exception of key frames (which tend to be larger and have no dependencies on other frames), the cost of the entropy coding is usually a smaller fraction of the total computational cost in the encoder.
- The following “C” code segments give supporting detail of the preferred implementation of this aspect of the invention.
-
//This function packs the encoded video data for a frame using either one arithmetically // coded data partition, two arithmetically coded data partitions, or one arithmetically // coded data partition and one Huffman data partition. // //The argument “cpi” is a pointer to the main encoder instance data structure. void PackCodedVideo ( CP_1NSTANCE *cpi ) { UINT32 PartitionTwoOffset; BOOL CODER *bc &cpi−>bc; // Arithmetic coder instance data structure B O O L CODER *bc2 &cpi−>bc2; // 2nd Arithmetic coder instance structure P8 ...INSTANCE *pbi = &cpi−>pb; // Decoder instance data structure // Initialize the raw buffer i/o used for the header partition. InitAddRawBitsToBuffer ( &cpi−>RawBuffer, pbi−>DataOutputPtr ); // Start the arithmetic and or Huffman coders // If we are using two data partitions... if( pbi−>MultiStream I I (pbi−>VpProfile = SIMPLE PROFILE) ) { //Start the first arithmetic coder: Allow for the raw header bytes. VP6_StartEncode ( bc, (pbi−>DataoutputPtr + ((KeyFrame) ? 4 : 3)) ); // Create either a second arithmetic or Huffman partition // This is initially written to a holding buffer “cpi−>OutputBuffer2” if ( pbi−>UseHuffman ) InitAddRawBitsToBuffer ( &pbi−>HufBuffer, cpi−>OutputBuffer2 ); else VP6_StartEncode ( bc2, cpi−>OutputBuffer2 ); // We are only using a single data partition coded using the arithmetic coder. else { // Start the arithmetic coder: Allow for the raw header bytes. VP6_StartEncode( bc, (pbi−>DataOutputInPtr + ((KeyFrame) ? 2 : 1)) ); // Write out the frame header information including size. WriteFrameHeader (... ); if( pbi−>UseHuffman ) PackHufmmanCoeffs (... ); else PackArithmeticCoeffs (... ); // Stop the arithmetic coder instance used for the first data partition VP6_StopEncode ( be ); //Work out the offsets to the data partitions and write them into // the space reserved for this information in the raw header partition. // // If we are using two data partitions.... if( pbi−>MultiStream I I (pbi−>VpProfile = SIMPLE PROFILE) ) { // Offset to first data partition from start of buffer PartitionTwoOffset = 4 + be−>pos; //Write offset to second data partition partition. AddRawBitsToBuffer ( &cpi−>RawBuffer, PartitionTwoOffset ,16 ); // If Huffman was used for the second data partition ... if( pbi−>UseHuffman ) { // Flush the buffer for the Huffman coded output partition EndAddRawBitsToBuffer ( &pbi−>HuffBuffer ); // Copy the Huffman coded data from the holding buffer into the output buffer. memcpy ( &cpi−>RawBuffer.Buffer[ PartitionTwoOffset ], pbi−>HuffBuffer.Buffer, pbi−>HuffBuffer.pos ); // Stop the arithmetic coder instance used by the second data partition. VP6_StopEncode ( bc2 ); //Copy over the contents of the holding buffer used by //the second partition into the output buffer. >DataOutputlnPtr[ PartitionTwoOffset ], bc2.buffer, bc2.pos ); } ) // Stop and flush the raw bits encoder used for the header EndAddRawBitsToBuffer ( &cpi−>RawBuffer ); } //This function is called to select the coding strategy when using two data partitions. void SelectMultiStreamMethod ( CP_INSTANCE *pbi ) { // Calculate an estimated cost (Shannon entropy) for the frame using // the information gathered re, the distribution of tokens in the frame. // Add in the previously calculated cost estimate for coding any mode and 11 motion vector information. EstimatedFrameCost = VP6_ShannonCost( cpi ) + ModeMvCost; // Decide whether to drop using Huffman coding for the second data partition. ) if ( EstimatedFrameCost > HuffmanCodingThreshold ) pbi−>UseHuffman = TRUE; else pbi−>UseHuffman = FALSE; } - Using a Plurality of Filters to Enhance Fractional Pixel Motion Prediction in Video Codecs
- For most modem video codecs motion prediction is an important part of the compression process. Motion prediction is a process whereby the motion of objects or regions of the image is modelled over one or more frames and one or more motion vectors is transmitted in the bitstream to represent this motion. In most cases it is not possible to perfectly model the motion within an image, so it is necessary to code a residual error signal in addition to the motion information,
- In essence, each motion vector points to a region in a previously encoded frame that is similar to the region in the current frame that is to be encoded. The residual error signal is obtained by subtracting the predicted value of each pixel from the actual value in the current frame.
- Many modem video codecs extend the process by providing support for prediction of motion to sub pixel accuracy. For example half pixel or quarter pixel motion estimation. To create fractional pixel data points it is necessary to use some form of interpolation function or filter applied to real (i.e. full pixel aligned) data points.
- Early codecs generally used simple bilinear interpolation
-
- In this example, A, B, C, and D are full pixel aligned data points and x, y, and z are half pixel aligned points. Point x is half pixel aligned in the X direction and can be calculated using the formula: x=(A+B)/2. Point y is half pixel aligned in the Y direction and can be calculated using the formula: y=(A+C)/2. Point z is half pixel aligned in both X and Y can be calculated using the formula: z=(A+B+C+D)/2.
- Later codecs have tended to move towards the use of more complex interpolation filters, such as bicubic filters, that are less inclined to blur the image. In the following example x is a half pixel point that lies half way between two full pixel aligned pointes B and C. Using an integer approximation to a bicubic filter it can be calculated using the formula: x=(−A+9B+9C−D)/16.
-
- A B x C D
- Though filters such as the one illustrated above tend to produce sharper looking results, their repeated application over several frames can in some situations result in unpleasant artefacts such as false textures or false contouring.
- This aspect of the invention is a method where by a codec can use a mixture of filtering techniques to create more optimal fractional pixel predictors and select between these methods at the clip level, the frame level, the block level or even at the level of individual pixels.
- In the preferred implementation a selection can be made on a per frame basis as to whether to use bilinear filtering only, bicubic filtering only or to allow a choice to be made at the block level.
- Selection at the block or region level could be achieved by means of explicit signalling bits within the bitstream, but in the preferred implementation selection is made using contextual information already available in the bitstream and by means of a complexity metric applied to the full pixel aligned data values that are going to be filtered.
- In situations where the quality of the motion predictor is poor (for example if it was not possible to find a good prediction for a block in the previous frame reconstruction), bilinear filtering is often the best option. Specifically where the prediction is poor the sharpening characteristics of the bicubic filter may lead to an increase in the high frequency content of the residual error signal and make it more difficult to encode.
- In the absence of explicit signalling bits in the bitstream various contextually available values that can be shown to be correlated to a greater or lesser extent with poor prediction quality. One of the simplest of these is motion vector length. Specifically the quality of the prediction tends to degrade with increasing motion vector length. The smoothness of the motion field in is another possible indicator (i.e. how similar are the motion vectors of neighbouring blocks).
- Bilinear filtering also tends to be the better option in situations where the choice of vector is unreliable (for example, where there is not very much detail in the image and there are many candidate vectors with similar error scores). In particular, repeated application of a bicubic filter over many frames, to a region that is relatively flat and featureless, may give rise to unwanted artefacts.
- In the preferred implementation two factors are taken into account when choosing the filtering method. The first is the length of the motion vector. The second is a complexity metric C calculated by analyzing the set of full pixel aligned data points that are going to be filtered.
- Bicubic filtering is used only if both the following test conditions are satisfied:
- 1. The motion vector is shorter than a threshold value L in both X and Y.
- 2. The complexity C is greater than a threshold value T.
- In the preferred implementation C is a variance of a set of n data points xi calculated according to the formula:
-
C=(nExi 2−(Exi) 2)/n 2 (4) - In the preferred implementation the complexity threshold T and the motion vector length threshold L may be set by the encoder on a once per frame basis.
- The following “C” code segments give supporting detail the preferred implementation of this aspect of the invention.
-
PredictBlockFunction(... ) { if ( pbi−>PredictionFilterMode = AUTO_SBLECT PM ) { // Use bilinear if vectors are above a threshold length in X or Y if( (( abs(pbi−>mbi.Mv[bp].x ) > BicMvSizeLimit) II (( abs(pbi−>mbi.Mv[bp].y ) > BicMvSizeLimit) ) { FilterBlockBilinear(.., ); } else { //Calculate a complexity metric (variance). //Note: for performance reasons the variance function only // examines 16 data points (every other point in X and Y // for an 8x8 block). Var = Varl6Point( DataPtr, Stride ); //If the complexity is above the given threshold use bicubic else use bilinear if( Var >= pbi−>PredictionFilterVarThresh) FilterBlockBilcubic(... ); else FilterBlockBilinear( ); } }} UINT32 Varl6Point ( UINT8 *DataPtr,1NT32 Stride ) { UINT32 i, j; UINT32 XSum=O, XXSum=O; UINT8 *Dif f tr = DataPtr; //Use every other point in X and Y for ( i = 0; i < BLOCK HEIGHT WIDTH; I += 2 ) for (j = 0; j < BLOCK_HEIGHT WIDTH; j += 2 ) { XSum += DiffPtr[j]; XXSum += DiffPtr[j] * DiffPtr[j]; } //Step to next row of block. DiffPtr += (SourceStride << 1) //Compute population variance as mis-match metric, return (( (XXSum* 16) − (XSum*XSum) ) 1256 ); } - Enhanced Motion Vector Coding
- By convention, most modern video codecs code the (x,y) components of a motion vector, using a differential coding scheme. That is, each vector is coded relative to the previous vector. For example, consider two vectors (7,3) and (8,4). In this case the second vector would be encoded as (1,1), that is (7+1, 3+1).
- This scheme works well if most blocks or regions for which a motion vector is coded exhibit motion that is similar to that of their neighbours. This can often be shown to be the case, for example when panning. However, it works less well if the motion field is irregular or where there are frequent transitions between background and foreground regions which have different motion characteristics.
- This aspect of the invention is an alternative strategy for encoding motion vectors which retains the advantages of differential coding whilst being more tolerant of irregular fields and background foreground transitions.
- According to this invention, the codec maintains two or more reference vectors relative to which motion vectors may be encoded. The codec could switch between these reference vectors via explicit signalling bits within the bitstream, but in the preferred implementation the decision is based upon the coding methods and motion vectors used by the blocks' immediate neighbours.
- In the preferred implementation, a block may be coded as and intra block (with no dependency on any previous frames), or an inter block which is dependent upon either the previous frame reconstruction, or an alternative reference frame that is updated only periodically.
- When coding with respect to the previous frame reconstruction or the alternative reference frame, the invention supports the following coding mode choices.
- (a) Code with no motion vector (that is to say an implicit (0,0) vector)
- (b) Code using the same vector as the ‘nearest’ neighbouring.
- (c) Code using the same vector as the ‘next nearest’ neighbour.
- (d) Code using a new motion vector.
- When defining the nearest or next nearest neighbour, only blocks that are coded with respect to the same reference frame as the current block and those that are coded with a non-zero motion vector are considered. All other blocks are ignored.
- When defining the next nearest neighbour, blocks that are coded with the same vector as the nearest neighbour are also ignored.
- When coding a new motion vector the codec may use either (0,0) or the nearest vector as the reference vector. In the preferred implementation the nearest vector is used if the block from which it is derived is either the block immediately to the left or immediately above the current block (assuming that blocks are being coded from left to right and from top to bottom). In all other cases new vectors are coded with respect to (0,0).
- Several extensions to the basic method are possible. If the nearest and next nearest neighbours are the blocks immediately to the left and immediately above the current block respectively, then some sort of compound vector derived from the two could be used as a reference for coding the new vector. Alternatively ‘nearest’ could be used to predict the x component and ‘next nearest’ the y component.
- Another possible extension, still assuming that nearest and next nearest are the blocks immediately to the left and above the current block, would be to take special account of the case where the nearest and next nearest vectors are not similar, and in such a case revert to 0 as the reference value for x, y or both x and y.
- This method retains the benefits of simple differential coding in cases where there is a regular or slowly changing motion field. However, the use of special ‘no vector’, ‘nearest’ and ‘next nearest’ modes makes for more efficient coding of transitions between foreground and background and the ability to switch automatically between multiple coding origins makes the method more tolerant of irregular motion fields.
- The following “C” code segments give supporting detail of the preferred implementation of this aspect of the invention.
-
// This function determines whether or not there is a qualifying nearest and next // nearest neighbour for the current block, what the motion vectors are for those // and how close the nearest neighbour is. // void VP6_FindNearestandNextNearest( PB_INSTANCE *pbi, UINT32 MBrow, UINT32 MBcoI, UINT8 ReferenceFrame INT32 * Type ) { int i; UINT32 OffsetMB; UINT32 BaseMB = MBOffset(MBrow,MBcol); MOTION VECTOR ThisMv; //Set default outcome *Type = NONEAREST_MACROBLOCK; // Search for a qualifying “nearest” block for ( i=0; i<12; i++ ) { OffsetMB = pbi−>mvNearOffset[i] + BaseMB; // Was the block coded with respect to the same reference frame? if ( VP6_Mode2Frame[pbi−>predictionMode[OffsetMB]] 1= ReferenceFrame) continue; // What if any motion vector did it use ThisMv.x = pbi−>MBMotionVector[OffsetMB].x; ThisMv.y = pbi−>MBMotionVector[OffsetMB].y; //If it was non-zero then we have a qualifying neighbour if ( ThisMv.x 11 ThisMv.y ) Nearest.x = ThisMv.x; Nearest.y = ThisMv.y; *Type = NONEAR_MACROBLOCK; break; } pbi−>mbi.NearestMvIndex = i; // Search for a qualifying “next nearest” block for ( i=i+1; i<12; i++ ) { OffsetMB = pbi−>mvNearOffset[i] + BaseMB; //Was the block coded with respect to the same reference frame? if ( VP6_Mode2Frame[pbi−>predictionMode[OffsetMB]] != ReferenceFrame) continue; // What if any motion vector did it use ThisMv.x = pbi−>MBMotionVector[OffsetMB].x; ThisMv.y = pbi−>MBMotionVector[OffsetMB).y; // If this vector is the same as the “nearest” vector then ignore it. if( (ThisMv.x == Nearest.x) && (ThisMv.y Nearest,y) ) continue; // If it was non-zero then we have a qualifying neighbour if( ThisMv.x 1I ThisMv.y ) { NextNearest.x ThisMv.x; NextNearest.y ThisMv.y; *Type = MACROBLOCK; break; } - Using An Alternate Reference Frame in Error Recover
- When transmitting compressed video data over an unreliable data link it is important that a mechanism exists for recovering when data is lost or corrupted, as video codecs are often extremely sensitive to errors in the bitstream.
- Various techniques and protocols exist for the reliable transmission of data of such links and these typically rely upon detection of the errors and either re-transmission or the use of additional data bits that allow certain types of error to be corrected.
- In many situations the existing techniques are adequate but in the case of video conferencing over restricted bandwidth links neither of the above mentioned approaches is ideal. Re-transmission of lost data packets may not be practical because it is likely to cause an increased end to end lag, whilst the use of error correction bits or packets may not be acceptable in situations where bandwidth is already severely restricted.
- An alternative approach is simply to detect the error at the decoder and report it to the encoder. The encoder can then transmit a recovery frame to the decoder. Note that this approach may not be appropriate if the error rate on the link is very high. For example, more than one error in every 10-20 frames.
- The simplest form of recovery frame is a key frame (or intra only frame). This is a frame that does not have any dependencies on previous frames or the data therein. The problem with key frames is that they are usually relatively large.
- Disclosed herein is a mechanism whereby a codec maintains a one or more additional references frames (other than the reconstruction of the previously coded frame) that can be used as a starting point for more efficiently coding of recovery frames.
- In the preferred implementation of the invention the codec maintains a second reference frame which is updated whenever there is a key frame and optionally at other times, via a flag bit in the frame header. For example the encoder could choose to update the second reference frame once every ‘X’ seconds or whenever an error recovery frame is encoded.
- Provided that the content of the second reference frame is at least in some respects similar to the content of the current frame, differential coding with respect to the second reference frame is likely to be much cheaper than coding a key frame.
- There are several ways in which one or more alternate reference frames may be used to enhance compression quality or efficiency. One obvious usage that is covered in the prior art is in video sequences that oscillate back and forth between two or more different scenes. For example, consider an interview where the video switches back and forth between interviewer and interviewee. By storing separate reference frames as a baseline for each camera angle the cost of switching back and forth between these can be greatly reduced, particularly when the scenes are substantially different.
- Whilst the invention has the option of using an alternate reference frame in this way, the subject of this invention is the use of a periodically updated alternate reference frame to enhance the quality of compressed video is situations where there is a slow progressive change in the video. Good examples of this are slow pans, zooms, or tracking shots.
- According this aspect of the invention, during slow pans or other such slow progressive changes the encoder periodically inserts frames which are encoded at a significantly higher quality than the surrounding frames and which cause the second or alternative reference frame to be updated.
- The purpose of these higher quality “second reference update” frames is to re-instate detail that has incrementally been lost since the last key frame, or the last second reference update, and to provide a better basis for inter frame prediction in subsequent frames. This strategy of periodically raising the quality (and hence the data rate) and at the same time updating the second reference frame can be shown to provide a much better cost/quality trade off in some situations than simply coding all the frames at a similar quality.
- Central to an effective implementation is the method for determining an appropriate interval for the second reference updates and the amount by which the quality or data rate should be boosted.
- In the preferred implementation of this aspect of the invention, several factors are taken into account. These include:
- (a) The average amplitude of motion vectors in the preceding few frames as an indicator of the speed of motion.
- (b) The extent to which the motion field is correlated. For example are the motion vectors all fairly similar.
- (c) The extent to which the second reference frame has been used as a predictor in preference to the previous frame reconstruction in the previous few frames.
- (d) The ambient quality or quantizer setting.
- In cases where the average amplitude of the motion vectors used is high (indicating faster motion), the interval between second reference updates and the quality boost are both decreased. Conversely, where the motion is slow a larger quality boost and longer interval are used.
- In cases where the motion field is highly correlated, that is to say that there are a lot of similar motion vectors, the quality boost for second reference frame updates is increased. Conversely, when the motion field is poorly correlated the extent of the boost is decreased.
- In cases where the second reference frame is frequently being used as a predictor in preference to the previous frame reconstruction, the quality boost is increased. Conversely in cases where the second reference frame is not used frequently it is decreased.
- The extent of the quality boost also depends to some extent on the ambient quality with a larger boost being used when the ambient quality is low and a smaller boost when the ambient quality is high.
- The following pseudo code gives more detail of the preferred implementation of this aspect of the invention.
-
For each frame Calculate of the average amplitude of the X and Y motion vector components (AvX and AvY) specified in pixel units. MotionSpeed = the larger of AvX and AvY Calculate a variance number for the X and Y motion vector components (VarianceX and VarianceY). Max Variance = the larger of VarianceX and VarianceY MotionComplexity = MotionSpeed + (VarianceX 14) + (VarianceY 1 4) If a second reference frame update is due this frame Calculate a data rate % boost number (Boost) based upon the predicted quality index (actually a quantizer setting) for the frame, This can range between +0% at highest quality to +1250% when the quality level is very low. Multiply Boost by a MotionSpeed correction factor where the factor can vary between 1 for very small values of MotionSpeed to 0 for large values of MotionSpeed. Apply a further correction factor to Boost based upon the extent to which the second reference frame has been used in the previous few frames. This can vary from 1/16 in cases where the second reference frame was not used at all in the previous few frames up to 1 in cases where it was used for 15% or more of the coded blocks. A series of tests are then applied to determine whether or not to go ahead and update the second reference frame with the calculated % boost. - The principal tests are:
- (Boost>MinBoostTreshold) and
- (MotionSpeed<MaxMotionSpeedThreshold) and
- (MaxVariance<MaxVarianceThreshold) where MinBoostTreshold, MaxMotionSpeedThreshold and MaxVarianceThreshold are configurable parameters.
- The invention has a number of special “motion re-use” modes that allow the motion vector for a block to be coded more cheaply if it is the same as the motion vector used by one of its near neighbours. Further tests are applied to discount cases where the usage of these modes falls below a threshold level.
- If the decision is made to apply the boost and update the second reference frame then set the frame data rate target to the baseline value+Boost % and calculate and the interval until the next update based upon MotionSpeed.
- If the decision is made not to apply the boost and not to update the second reference frame, then update the frame as normal with a 0% data rate boost.
- Else if a second reference frame update is not due, calculate a reduced frame data rate target (negative boost) that takes into account the level of boost applied when the second reference frame was last updated and the current update interval.
- Using a Reconstruction Error Metric to Select Between Alternative Methods for Creating Fractional Pixel Predictions
- Many modern video codecs support prediction of motion to sub pixel accuracy. For example half pixel or quarter pixel motion estimation. To create fractional pixel data points it is necessary to use some form of interpolation function or filter applied to real (i.e., full pixel aligned) data points.
- Early codecs generally used simple bilinear interpolation.
-
- In this example A, B, C, and D are full pixel aligned data points and x,y and z are half pixel aligned points.
- Point x is half pixel aligned in the X direction and would be calculated using the formula (A+B/2).
- Point y is half pixel aligned in the Y direction and would be calculated using the formula (A+C/2).
- Point z is half pixel aligned in both X and Y would be calculated using the formula (A+B+C+D)/2).
- Later codecs have tended to move towards the use of more complex interpolation filters such as bicubic filters, that are less inclined to blur the image. In the following example ‘x’ is a half pixel point that lies half way between two full pixel aligned pointes B and C. It can be calculated using the formula (−A+9B+9C−D)/16.
-
- A B x C D
- Though filters such as the one illustrated above tend to produce sharper results, repeated application over several frames can sometimes result in unpleasant artefacts such as exaggeration of textures or false contouring.
- This aspect of the invention is a method where by a codec can use a mixture of bilinear and bicubic filtering to calculate more optimal fractional pixel predictors and select between these methods either at a frame level or at the level of the individual blocks or regions to which motion vectors are applied.
- Selection at the block or region level could be achieved by means of signalling bits within the bitstream, but in the preferred implementation selection is made by means of a complexity metric applied to the set of pixels in the previous reconstructed image that are going to be filtered.
- According to this method, blocks or regions with a complexity score above a threshold value “T” are filtered using the bicubic method whilst those with a lower complexity score are filtered using the bilinear method.
- In the preferred implementation the complexity metric is the variance of the set of “n” full pixel aligned data points to be filtered, where variance is defined as:
-
(nEx2−(Ex)2)/n2. (5) - In the preferred implementation the threshold value T′ may be updated on a once per frame basis.
Claims (20)
1. A method for decoding a video signal having a plurality of frames including a current frame, comprising:
generating an alternate reference frame having a first quality level, wherein the alternate reference frame occurs prior to the current frame in the video signal and wherein the alternate reference frame is other than a frame immediately prior to the current frame;
determining a boost value, the boost value indicative of a second quality level higher than the first quality level;
determining whether to apply the boost value to the alternate reference frame; and
selectively applying the boost value to the alternate reference frame based on the determination whether to apply the boost value to the alternative reference frame.
2. The method of claim 1 , wherein determining whether to apply the boost value comprises:
calculating an interval for applying the boost value to the alternate reference frame, wherein the calculated interval is based on one or more factors.
3. The method of claim 2 , wherein selectively applying the boost value comprises:
applying the boost value to the alternate reference frame if the current frame meets the calculated interval.
4. The method of claim 2 , wherein the one or more factors is at least one of: an average amplitude of motion vectors, a number of similar motion vectors, a number of uses of the alternate reference frame or a quantizer setting.
5. The method of claim 4 , wherein the one or more factors is the average amplitude of motion vectors and wherein calculating the interval comprises:
increasing the interval if the average amplitude of motion vectors in at least one frame prior to the current frame is greater than a predetermined threshold; and
decreasing the interval if the average amplitude of motion vectors in at least one frame prior to the current frame is less than or equal to the predetermined threshold.
6. The method of claim 1 , wherein determining the boost value comprises:
calculating a data rate boost number based upon a predicted quality index, the predicted quality index indicative of a quantizer setting for the current frame; and
multiplying the data rate boost number by a correction factor to determine the boost value.
7. The method of claim 6 , wherein the correction factor is at least one of a motion speed correction factor or an alternate reference frame use correction factor.
8. The method of claim 1 , wherein selectively applying the boost value comprises:
if the boost value is greater than a predetermined boost threshold value, applying the boost value to the alternate reference frame.
9. The method of claim 1 , wherein the current frame has a plurality of motion vectors and wherein selectively applying the boost value to the alternate reference frame comprises:
calculating a motion speed value for at least some of the plurality of motion vectors; and
if the motion speed value is greater than a predetermined motion speed threshold value, applying the boost value to the alternate reference frame.
10. The method of claim 1 , wherein the current frame has a plurality of motion vectors and wherein selectively applying the boost value to the alternative reference frame comprises:
calculating a maximum variance value for at least some of the plurality of motion vectors; and
if the maximum variance value is greater than a predetermined maximum variance threshold value, applying the boost value to the alternate reference frame.
11. The method of claim 1 , wherein the boost value is added to a baseline value.
12. The method of claim 1 , wherein the boost value is a zero value indicative of maintaining the alternate reference frame at the first quality level.
13. The method of claim 1 , wherein the boost value is a negative value indicative of reducing the quality of the alternate reference frame from the second quality level to the first quality level.
14. A method for encoding a video signal having a plurality of frames including a current frame, comprising:
generating an alternate reference frame having a first quality level, wherein the alternate reference frame occurs prior to the current frame in the video signal and wherein the alternate reference frame is other than a frame immediately prior to the current frame;
determining a boost value, the boost value indicative of a second quality level higher than the first quality level;
determining whether to apply the boost value to the alternate reference frame; and
selectively applying the boost value to the alternate reference frame based on the determination whether to apply the boost value to the alternative reference frame.
15. The method of claim 14 , further comprising:
inserting at least one high quality frame in the video signal having a quality level higher than a quality level of at least some frames surrounding the at least one high quality frame, the alternate reference frame generated based on the at least one high quality frame.
16. The method of claim 15 , wherein the at least one high quality frame includes a plurality of high quality frames and wherein inserting the at least one high quality frame comprises:
periodically inserting each of at least some of the plurality of high quality frames in the video signal.
17. The method of claim 14 , wherein determining whether to apply the boost value comprises:
calculating an interval for applying the boost value to the alternate reference frame, wherein the calculated interval is based on one or more factors.
18. The method of claim 17 , wherein selectively applying the boost value comprises:
if the current frame meets the calculated interval, applying the boost value to the alternate reference frame.
19. An apparatus for decoding a video signal having a plurality of frames including a current frame, comprising:
means for generating an alternate reference frame having a first quality level, wherein the alternate reference frame occurs prior to the current frame in the video signal and wherein the alternate reference frame is other than a frame immediately prior to the current frame;
means for determining a boost value, the boost value indicative of a second quality level higher than the first quality level;
means for determining whether to apply the boost value to the alternate reference frame; and
means for selectively applying the boost value to the alternate reference frame based on the determination whether to apply the boost value to the alternate reference frame.
20. The apparatus of claim 19 , wherein the means for determining whether to apply the boost value comprises means for calculating an interval for applying the boost value to the alternate reference frame based on one or more factors, wherein the one or more factors is at least one of: an average amplitude of motion vectors, a number of correlated motion vectors, a number of uses of the alternate reference frame or a quantizer setting.
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/599,371 US20120320992A1 (en) | 2003-05-12 | 2012-08-30 | Enhancing compression quality using alternate reference frame |
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US46918703P | 2003-05-12 | 2003-05-12 | |
US10/713,807 US8824553B2 (en) | 2003-05-12 | 2003-11-14 | Video compression method |
US13/599,371 US20120320992A1 (en) | 2003-05-12 | 2012-08-30 | Enhancing compression quality using alternate reference frame |
Related Parent Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US10/713,807 Continuation US8824553B2 (en) | 2003-05-12 | 2003-11-14 | Video compression method |
Publications (1)
Publication Number | Publication Date |
---|---|
US20120320992A1 true US20120320992A1 (en) | 2012-12-20 |
Family
ID=33423828
Family Applications (8)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US10/713,807 Active 2027-02-25 US8824553B2 (en) | 2003-05-12 | 2003-11-14 | Video compression method |
US13/599,333 Abandoned US20120320978A1 (en) | 2003-05-12 | 2012-08-30 | Coder optimization using independent bitstream partitions and mixed mode entropy coding |
US13/599,371 Abandoned US20120320992A1 (en) | 2003-05-12 | 2012-08-30 | Enhancing compression quality using alternate reference frame |
US13/599,345 Abandoned US20120320987A1 (en) | 2003-05-12 | 2012-08-30 | Enhancing fractional pixel motion prediction using a plurality of filters |
US13/599,315 Expired - Lifetime US8942290B2 (en) | 2003-05-12 | 2012-08-30 | Dynamic coefficient reordering |
US13/599,360 Expired - Lifetime US10616576B2 (en) | 2003-05-12 | 2012-08-30 | Error recovery using alternate reference frame |
US16/827,864 Expired - Lifetime US11240498B2 (en) | 2003-05-12 | 2020-03-24 | Independently coding frame areas |
US17/570,533 Abandoned US20220132116A1 (en) | 2003-05-12 | 2022-01-07 | Independently coding frame areas |
Family Applications Before (2)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US10/713,807 Active 2027-02-25 US8824553B2 (en) | 2003-05-12 | 2003-11-14 | Video compression method |
US13/599,333 Abandoned US20120320978A1 (en) | 2003-05-12 | 2012-08-30 | Coder optimization using independent bitstream partitions and mixed mode entropy coding |
Family Applications After (5)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US13/599,345 Abandoned US20120320987A1 (en) | 2003-05-12 | 2012-08-30 | Enhancing fractional pixel motion prediction using a plurality of filters |
US13/599,315 Expired - Lifetime US8942290B2 (en) | 2003-05-12 | 2012-08-30 | Dynamic coefficient reordering |
US13/599,360 Expired - Lifetime US10616576B2 (en) | 2003-05-12 | 2012-08-30 | Error recovery using alternate reference frame |
US16/827,864 Expired - Lifetime US11240498B2 (en) | 2003-05-12 | 2020-03-24 | Independently coding frame areas |
US17/570,533 Abandoned US20220132116A1 (en) | 2003-05-12 | 2022-01-07 | Independently coding frame areas |
Country Status (7)
Country | Link |
---|---|
US (8) | US8824553B2 (en) |
EP (1) | EP1656791A2 (en) |
JP (5) | JP4568887B2 (en) |
KR (6) | KR101118438B1 (en) |
CN (2) | CN101454990B (en) |
CA (1) | CA2525390C (en) |
WO (1) | WO2004102946A2 (en) |
Cited By (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN110582022A (en) * | 2019-09-27 | 2019-12-17 | 腾讯科技（深圳）有限公司 | Video encoding and decoding method and device and storage medium |
Families Citing this family (92)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6499060B1 (en) | 1999-03-12 | 2002-12-24 | Microsoft Corporation | Media coding for loss recovery with remotely predicted data units |
US7471724B2 (en) * | 2003-06-23 | 2008-12-30 | Vichip Corp. Limited | Method and apparatus for adaptive multiple-dimensional signal sequences encoding/decoding |
JP2006086964A (en) * | 2004-09-17 | 2006-03-30 | Toshiba Corp | Bit rate conversion apparatus and bit rate conversion method |
US7817723B2 (en) * | 2004-12-14 | 2010-10-19 | Fraunhofer-Gesellschaft Zur Foerderung Der Angewandten Forschung E. V. | Apparatus and method of optimizing motion estimation parameters for encoding a video signal |
US7324708B2 (en) * | 2004-12-23 | 2008-01-29 | Primax Electronics Ltd. | Interpolation method for digital pictures |
US8634413B2 (en) | 2004-12-30 | 2014-01-21 | Microsoft Corporation | Use of frame caching to improve packet loss recovery |
KR100727969B1 (en) * | 2005-08-27 | 2007-06-14 | 삼성전자주식회사 | Apparatus for encoding and decoding image, and method theroff, and a recording medium storing program to implement the method |
KR100727970B1 (en) * | 2005-08-30 | 2007-06-13 | 삼성전자주식회사 | Apparatus for encoding and decoding image, and method theroff, and a recording medium storing program to implement the method |
KR100667815B1 (en) * | 2005-09-22 | 2007-01-12 | 삼성전자주식회사 | Apparatus for encoding and decoding image, and method theroff, and a recording medium storing program to implement the method |
JP2007189518A (en) * | 2006-01-13 | 2007-07-26 | Matsushita Electric Ind Co Ltd | Signal processing apparatus, imaging device, network camera system, and video system |
KR100834757B1 (en) | 2006-03-28 | 2008-06-05 | 삼성전자주식회사 | Method for enhancing entropy coding efficiency, video encoder and video decoder thereof |
JP5248802B2 (en) * | 2006-06-16 | 2013-07-31 | カシオ計算機株式会社 | Moving picture encoding apparatus, moving picture encoding method, moving picture decoding apparatus, moving picture decoding method, and moving picture recording apparatus |
KR101086435B1 (en) * | 2007-03-29 | 2011-11-25 | 삼성전자주식회사 | Method for detecting errors from image data stream and apparatus thereof |
US20100325255A1 (en) * | 2007-04-05 | 2010-12-23 | Gene Cheung | Data transmission system and method |
US8605786B2 (en) * | 2007-09-04 | 2013-12-10 | The Regents Of The University Of California | Hierarchical motion vector processing method, software and devices |
US8542748B2 (en) * | 2008-03-28 | 2013-09-24 | Sharp Laboratories Of America, Inc. | Methods and systems for parallel video encoding and decoding |
KR20100011628A (en) * | 2008-07-25 | 2010-02-03 | 삼성전자주식회사 | Method of coding and apparatus for coding |
US8385404B2 (en) * | 2008-09-11 | 2013-02-26 | Google Inc. | System and method for video encoding using constructed reference frame |
US8311111B2 (en) * | 2008-09-11 | 2012-11-13 | Google Inc. | System and method for decoding using parallel processing |
US8325796B2 (en) | 2008-09-11 | 2012-12-04 | Google Inc. | System and method for video coding using adaptive segmentation |
US8326075B2 (en) * | 2008-09-11 | 2012-12-04 | Google Inc. | System and method for video encoding using adaptive loop filter |
US20100074336A1 (en) * | 2008-09-25 | 2010-03-25 | Mina Goor | Fractional motion estimation engine |
CN102158678A (en) * | 2010-05-20 | 2011-08-17 | 王洪剑 | Motion vector field interpolation method |
HUE055116T2 (en) * | 2010-09-02 | 2021-10-28 | Lg Electronics Inc | Method for encoding and decoding video |
US8503528B2 (en) | 2010-09-15 | 2013-08-06 | Google Inc. | System and method for encoding video using temporal filter |
US8344917B2 (en) | 2010-09-30 | 2013-01-01 | Sharp Laboratories Of America, Inc. | Methods and systems for context initialization in video coding and decoding |
US9313514B2 (en) | 2010-10-01 | 2016-04-12 | Sharp Kabushiki Kaisha | Methods and systems for entropy coder initialization |
MX2013003557A (en) | 2010-10-05 | 2013-05-01 | Gen Instrument Corp | Coding and decoding utilizing adaptive context model selection with zigzag scan. |
US8611415B1 (en) | 2010-11-15 | 2013-12-17 | Google Inc. | System and method for coding using improved motion estimation |
US9532066B2 (en) * | 2011-01-21 | 2016-12-27 | Qualcomm Incorporated | Motion vector prediction |
KR101760333B1 (en) * | 2011-03-02 | 2017-07-21 | 삼성전자주식회사 | Communication method of target terminal and access point for group id management in mu-mimo transmission |
FR2972588A1 (en) | 2011-03-07 | 2012-09-14 | France Telecom | METHOD FOR ENCODING AND DECODING IMAGES, CORRESPONDING ENCODING AND DECODING DEVICE AND COMPUTER PROGRAMS |
AU2011362447B2 (en) * | 2011-03-14 | 2015-09-24 | Hfi Innovation Inc. | Method and apparatus for deriving temporal motion vector prediction |
US8638854B1 (en) | 2011-04-07 | 2014-01-28 | Google Inc. | Apparatus and method for creating an alternate reference frame for video compression using maximal differences |
US8781004B1 (en) | 2011-04-07 | 2014-07-15 | Google Inc. | System and method for encoding video using variable loop filter |
US8780971B1 (en) | 2011-04-07 | 2014-07-15 | Google, Inc. | System and method of encoding using selectable loop filters |
US9154799B2 (en) | 2011-04-07 | 2015-10-06 | Google Inc. | Encoding and decoding motion via image segmentation |
US8780996B2 (en) | 2011-04-07 | 2014-07-15 | Google, Inc. | System and method for encoding and decoding video data |
CN102811346B (en) * | 2011-05-31 | 2015-09-02 | 富士通株式会社 | coding mode selection method and system |
CN103609116A (en) * | 2011-06-17 | 2014-02-26 | 松下电器产业株式会社 | Video decoding device and video decoding method |
FR2977111A1 (en) | 2011-06-24 | 2012-12-28 | France Telecom | METHOD FOR ENCODING AND DECODING IMAGES, CORRESPONDING ENCODING AND DECODING DEVICE AND COMPUTER PROGRAMS |
CN102956027B (en) * | 2011-08-30 | 2016-08-03 | 安凯(广州)微电子技术有限公司 | Image Enhancement Processing System and the processing method of chip is processed based on camera image |
US8885706B2 (en) | 2011-09-16 | 2014-11-11 | Google Inc. | Apparatus and methodology for a video codec system with noise reduction capability |
TWI505696B (en) * | 2011-11-08 | 2015-10-21 | Samsung Electronics Co Ltd | Method for decoding image |
US9247257B1 (en) | 2011-11-30 | 2016-01-26 | Google Inc. | Segmentation based entropy encoding and decoding |
US9100657B1 (en) | 2011-12-07 | 2015-08-04 | Google Inc. | Encoding time management in parallel real-time video encoding |
US9262670B2 (en) | 2012-02-10 | 2016-02-16 | Google Inc. | Adaptive region of interest |
US9131073B1 (en) | 2012-03-02 | 2015-09-08 | Google Inc. | Motion estimation aided noise reduction |
US9609341B1 (en) | 2012-04-23 | 2017-03-28 | Google Inc. | Video data encoding and decoding using reference picture lists |
WO2013162980A2 (en) | 2012-04-23 | 2013-10-31 | Google Inc. | Managing multi-reference picture buffers for video data coding |
GB2501535A (en) * | 2012-04-26 | 2013-10-30 | Sony Corp | Chrominance Processing in High Efficiency Video Codecs |
US9014266B1 (en) | 2012-06-05 | 2015-04-21 | Google Inc. | Decimated sliding windows for multi-reference prediction in video coding |
US9774856B1 (en) | 2012-07-02 | 2017-09-26 | Google Inc. | Adaptive stochastic entropy coding |
US9344729B1 (en) | 2012-07-11 | 2016-05-17 | Google Inc. | Selective prediction signal filtering |
US9509998B1 (en) | 2013-04-04 | 2016-11-29 | Google Inc. | Conditional predictive multi-symbol run-length coding |
US9756331B1 (en) | 2013-06-17 | 2017-09-05 | Google Inc. | Advance coded reference prediction |
GB2516426B (en) * | 2013-07-17 | 2015-10-07 | Gurulogic Microsystems Oy | Encoder, decoder and method of operation using interpolation |
KR102304687B1 (en) * | 2013-07-22 | 2021-09-27 | 소니그룹주식회사 | Image processing device and method |
US11425395B2 (en) | 2013-08-20 | 2022-08-23 | Google Llc | Encoding and decoding using tiling |
US9392288B2 (en) | 2013-10-17 | 2016-07-12 | Google Inc. | Video coding using scatter-based scan tables |
US9179151B2 (en) | 2013-10-18 | 2015-11-03 | Google Inc. | Spatial proximity context entropy coding |
US10236906B2 (en) * | 2013-10-22 | 2019-03-19 | Schlumberger Technology Corporation | Compression and timely delivery of well-test data |
US9749642B2 (en) | 2014-01-08 | 2017-08-29 | Microsoft Technology Licensing, Llc | Selection of motion vector precision |
US9942560B2 (en) | 2014-01-08 | 2018-04-10 | Microsoft Technology Licensing, Llc | Encoding screen capture data |
US9774881B2 (en) | 2014-01-08 | 2017-09-26 | Microsoft Technology Licensing, Llc | Representing motion vectors in an encoded bitstream |
US9392272B1 (en) | 2014-06-02 | 2016-07-12 | Google Inc. | Video coding using adaptive source variance based partitioning |
US9578324B1 (en) | 2014-06-27 | 2017-02-21 | Google Inc. | Video coding using statistical-based spatially differentiated partitioning |
US10102613B2 (en) | 2014-09-25 | 2018-10-16 | Google Llc | Frequency-domain denoising |
US10462480B2 (en) * | 2014-12-31 | 2019-10-29 | Microsoft Technology Licensing, Llc | Computationally efficient motion estimation |
US9787332B2 (en) * | 2015-09-15 | 2017-10-10 | Intel Corporation | Error-checking compressed streams in heterogeneous compression accelerators |
TWI546779B (en) | 2015-11-06 | 2016-08-21 | 財團法人工業技術研究院 | Method, apparatus and computer readable medium for encoding of streaming data |
US10334276B2 (en) * | 2015-12-28 | 2019-06-25 | Ati Technologies Ulc | Method and apparatus for determining the severity of corruption in a picture |
US9794574B2 (en) | 2016-01-11 | 2017-10-17 | Google Inc. | Adaptive tile data size coding for video and image compression |
US10542258B2 (en) | 2016-01-25 | 2020-01-21 | Google Llc | Tile copying for video compression |
KR101742258B1 (en) | 2016-02-29 | 2017-05-31 | 경희대학교 산학협력단 | Apparatus and method for providing contents using web-based virtual desktop protocol |
KR101895294B1 (en) * | 2017-03-03 | 2018-09-05 | 주식회사 칩스앤미디어 | A decoding method using prescaning and an appratus using it |
US10326994B2 (en) * | 2017-08-15 | 2019-06-18 | Google Llc | Modifying a scan order to limit scan distance |
CN107846263B (en) * | 2017-11-01 | 2020-07-14 | 南京莱斯电子设备有限公司 | Information source binary arithmetic coding method and coding system based on segmented calculation |
CN109756739B (en) * | 2017-11-07 | 2022-09-02 | 华为技术有限公司 | Image prediction method and device |
CN108230487A (en) * | 2017-12-21 | 2018-06-29 | 上海新案数字科技有限公司 | The method and apparatus of shared camera resource |
US11665365B2 (en) * | 2018-09-14 | 2023-05-30 | Google Llc | Motion prediction coding with coframe motion vectors |
US11212520B2 (en) * | 2018-12-04 | 2021-12-28 | Ati Technologies Ulc | Region-based reference frame management |
EP3700210A1 (en) * | 2019-02-21 | 2020-08-26 | Ateme | Method and apparatus for image encoding |
EP3713235B1 (en) * | 2019-03-19 | 2023-08-02 | Axis AB | Methods and devices for encoding a video stream using a first and a second encoder |
WO2020223858A1 (en) * | 2019-05-05 | 2020-11-12 | 浙江宇视科技有限公司 | Privacy protection method for transmitting end and receiving end, electronic device and computer readable storage medium |
KR102153661B1 (en) * | 2019-11-29 | 2020-09-08 | 국방과학연구소 | Spaceborne sar and telemetry data reduction method for spaceborne sar |
KR20210136476A (en) | 2020-05-07 | 2021-11-17 | 삼성전자주식회사 | Compressing device and method using parameters of a quad-tree method |
EP3962091A1 (en) * | 2020-08-26 | 2022-03-02 | Tata Consultancy Services Limited | Methods and systems for maintaining quality of experience in real-time live video streaming |
CN115881140A (en) * | 2021-09-29 | 2023-03-31 | 华为技术有限公司 | Encoding and decoding method, device, equipment, storage medium and computer program product |
US20230179764A1 (en) * | 2021-12-06 | 2023-06-08 | Tencent America LLC | Arrangement of adaptive loop filter coefficients for fast vectorized transpositions |
CN114640853B (en) * | 2022-05-18 | 2022-07-29 | 滨州市人防工程与指挥保障中心 | Unmanned aerial vehicle image processing system that cruises |
CN115865099B (en) * | 2022-12-01 | 2024-04-16 | 河南大学 | Huffman coding-based multi-type data segment compression method and system |
Citations (9)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5912707A (en) * | 1995-12-23 | 1999-06-15 | Daewoo Electronics., Ltd. | Method and apparatus for compensating errors in a transmitted video signal |
US6201896B1 (en) * | 1997-12-10 | 2001-03-13 | Nec Corporation | Picture encoding apparatus |
US6389072B1 (en) * | 1998-12-23 | 2002-05-14 | U.S. Philips Corp. | Motion analysis based buffer regulation scheme |
US20020141501A1 (en) * | 1998-11-20 | 2002-10-03 | Philips Electronics North America Corporation | System for performing resolution upscaling on frames of digital video |
US20030142753A1 (en) * | 1997-01-31 | 2003-07-31 | Acmi Corporation | Correction of image signals characteristic of non-uniform images in an endoscopic imaging system |
US20030161398A1 (en) * | 2002-02-21 | 2003-08-28 | Meir Feder | Improving static picture quality in compressed video |
US20030161401A1 (en) * | 2002-02-27 | 2003-08-28 | Bo Shen | Reducing the resolution of media data |
US7010036B1 (en) * | 1999-02-01 | 2006-03-07 | Koninklijke Philips Electronics N.V. | Descriptor for a video sequence and image retrieval system using said descriptor |
US20060098738A1 (en) * | 2003-01-09 | 2006-05-11 | Pamela Cosman | Video encoding methods and devices |
Family Cites Families (158)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
JPS60186179A (en) | 1984-03-06 | 1985-09-21 | Nec Corp | System and device for predictive coding of picture signal |
JPS6192073A (en) | 1984-10-12 | 1986-05-10 | Hitachi Ltd | Picture data compression system |
DE3629472A1 (en) | 1986-08-29 | 1988-03-03 | Licentia Gmbh | METHOD FOR MOTION-COMPENSATED PICTURE-TO-PICTURE PREDICTION CODING |
ATE74219T1 (en) | 1987-06-02 | 1992-04-15 | Siemens Ag | METHOD FOR DETERMINING MOTION VECTOR FIELDS FROM DIGITAL IMAGE SEQUENCES. |
US6563875B2 (en) | 1987-12-30 | 2003-05-13 | Thomson Licensing S.A. | Adaptive method of encoding and decoding a series of pictures by transformation, and devices for implementing this method |
JP2743434B2 (en) | 1989-02-17 | 1998-04-22 | 日本ビクター株式会社 | Motion compensated interframe predictive coding circuit |
JPH02272970A (en) | 1989-04-14 | 1990-11-07 | Sony Corp | Data processing circuit |
US5091782A (en) | 1990-04-09 | 1992-02-25 | General Instrument Corporation | Apparatus and method for adaptively compressing successive blocks of digital video |
EP0466981B1 (en) | 1990-07-20 | 1997-02-26 | Koninklijke Philips Electronics N.V. | Motion vector processing device |
SE469866B (en) | 1991-04-12 | 1993-09-27 | Dv Sweden Ab | Method for estimating motion content in video signals |
EP0533195A2 (en) | 1991-09-20 | 1993-03-24 | Sony Corporation | Picture signal encoding and/or decoding apparatus |
JP3263960B2 (en) | 1991-10-22 | 2002-03-11 | ソニー株式会社 | Motion vector encoder and decoder |
US5442458A (en) | 1991-12-18 | 1995-08-15 | Eastman Kodak Company | Method and associated apparatus for encoding bitplanes for improved coding efficiency |
US5461423A (en) | 1992-05-29 | 1995-10-24 | Sony Corporation | Apparatus for generating a motion vector with half-pixel precision for use in compressing a digital motion picture signal |
US5289276A (en) | 1992-06-19 | 1994-02-22 | General Electric Company | Method and apparatus for conveying compressed video data over a noisy communication channel |
US5377018A (en) | 1992-06-22 | 1994-12-27 | Media Vision | Video compression and decompression using block selection and subdivision |
US5365280A (en) | 1992-06-26 | 1994-11-15 | U.S. Philips Corporation | Method and apparatus for discriminating between movie film and non-movie film and generating a picture signal processing mode control signal |
US5371841A (en) | 1992-07-31 | 1994-12-06 | Eastman Kodak Company | Progressive bit plane reconstruction method |
US5717394A (en) | 1993-02-10 | 1998-02-10 | Ricoh Company Ltd. | Method and apparatus for encoding and decoding data |
US5586285A (en) | 1993-02-19 | 1996-12-17 | Intel Corporation | Method and circuitry for increasing reserve memory in a solid state memory disk |
US6327304B1 (en) | 1993-05-12 | 2001-12-04 | The Duck Corporation | Apparatus and method to digitally compress video signals |
US6181822B1 (en) | 1993-05-12 | 2001-01-30 | The Duck Corporation | Data compression apparatus and method |
FI94306C (en) | 1993-07-15 | 1995-08-10 | Nokia Technology Gmbh | Method for determining motion vectors of small TV image segments |
US5398068A (en) | 1993-09-02 | 1995-03-14 | Trustees Of Princeton University | Method and apparatus for determining motion vectors for image sequences |
JPH07135660A (en) | 1993-11-12 | 1995-05-23 | Matsushita Electric Ind Co Ltd | Movement vector coder |
US5999641A (en) | 1993-11-18 | 1999-12-07 | The Duck Corporation | System for manipulating digitized image objects in three dimensions |
KR100213018B1 (en) | 1994-07-30 | 1999-08-02 | 윤종용 | Apparatus for encoding moving picture |
US5706059A (en) * | 1994-11-30 | 1998-01-06 | National Semiconductor Corp. | Motion estimation using a hierarchical search |
EP0721287A1 (en) | 1995-01-09 | 1996-07-10 | Daewoo Electronics Co., Ltd | Method and apparatus for encoding a video signal |
DE69619002T2 (en) | 1995-03-10 | 2002-11-21 | Toshiba Kawasaki Kk | Image coding - / - decoding device |
JPH08275160A (en) | 1995-03-27 | 1996-10-18 | Internatl Business Mach Corp <Ibm> | Discrete cosine conversion method |
KR0178198B1 (en) | 1995-03-28 | 1999-05-01 | 배순훈 | Apparatus for encoding an image signal |
WO1996033558A1 (en) | 1995-04-18 | 1996-10-24 | Advanced Micro Devices, Inc. | Method and apparatus for hybrid vlc bitstream decoding |
US5812197A (en) | 1995-05-08 | 1998-09-22 | Thomson Consumer Electronics, Inc. | System using data correlation for predictive encoding of video image data subject to luminance gradients and motion |
US5936673A (en) | 1995-05-26 | 1999-08-10 | Intel Corporation | Temporal tile staggering for block based video compression |
JP3364074B2 (en) | 1995-06-05 | 2003-01-08 | 株式会社リコー | Bit plane coding device |
US5568200A (en) | 1995-06-07 | 1996-10-22 | Hitachi America, Ltd. | Method and apparatus for improved video display of progressively refreshed coded video |
JP3618833B2 (en) | 1995-07-14 | 2005-02-09 | キヤノン株式会社 | Image processing apparatus and method |
KR0153671B1 (en) | 1995-06-30 | 1998-11-16 | 배순훈 | Rate controller of hdtv encoder |
MY121607A (en) | 1995-07-10 | 2006-02-28 | Hyundai Curitel Inc | Grid moving method of object image and apparatus using the same and compaction/motion estimation method using the same and apparatus thereof |
AU6376296A (en) | 1995-07-11 | 1997-02-10 | Telefonaktiebolaget Lm Ericsson (Publ) | Video coding |
EP1274253A3 (en) | 1995-08-29 | 2005-10-12 | Sharp Kabushiki Kaisha | Video coding device and video decoding device with a motion compensated interframe prediction |
US5835138A (en) | 1995-08-30 | 1998-11-10 | Sony Corporation | Image signal processing apparatus and recording/reproducing apparatus |
JP3068002B2 (en) | 1995-09-18 | 2000-07-24 | 沖電気工業株式会社 | Image encoding device, image decoding device, and image transmission system |
GB9519923D0 (en) | 1995-09-29 | 1995-11-29 | Philips Electronics Nv | Motion estimation for predictive image coding |
JPH09102954A (en) | 1995-10-04 | 1997-04-15 | Matsushita Electric Ind Co Ltd | Method for calculating picture element value of block from one or two predictive blocks |
KR0181069B1 (en) | 1995-11-08 | 1999-05-01 | 배순훈 | Motion estimation apparatus |
GB2308262B (en) | 1995-12-16 | 1999-08-04 | Paul Gordon Wilkins | Method for analysing the content of a video signal |
JP3157101B2 (en) | 1996-03-08 | 2001-04-16 | 沖電気工業株式会社 | Image encoding method and image encoding device |
US5912676A (en) | 1996-06-14 | 1999-06-15 | Lsi Logic Corporation | MPEG decoder frame memory interface which is reconfigurable for different frame store architectures |
CA2208950A1 (en) * | 1996-07-03 | 1998-01-03 | Xuemin Chen | Rate control for stereoscopic digital video encoding |
US5926226A (en) | 1996-08-09 | 1999-07-20 | U.S. Robotics Access Corp. | Method for adjusting the quality of a video coder |
US6075875A (en) | 1996-09-30 | 2000-06-13 | Microsoft Corporation | Segmentation of image features using hierarchical analysis of multi-valued image data and weighted averaging of segmentation results |
JP3967405B2 (en) | 1996-10-09 | 2007-08-29 | テキサス インスツルメンツ インコーポレイテツド | Image signal encoding method |
US6005980A (en) | 1997-03-07 | 1999-12-21 | General Instrument Corporation | Motion estimation and compensation of video object planes for interlaced digital video |
US5991447A (en) | 1997-03-07 | 1999-11-23 | General Instrument Corporation | Prediction and coding of bi-directionally predicted video object planes for interlaced digital video |
US6385341B1 (en) | 1997-04-17 | 2002-05-07 | Microsoft Corporation | Technique for decoding variable length data codes |
JP3351705B2 (en) | 1997-04-25 | 2002-12-03 | 日本ビクター株式会社 | Motion compensation coding apparatus, motion compensation coding method, and recording method on recording medium |
DE19721728C2 (en) | 1997-05-24 | 2001-07-12 | Byk Chemie Gmbh | Dispersants for pigments or fillers based on acrylic acid alkyl ester polymers, use and process for producing them |
JP3381827B2 (en) | 1997-06-04 | 2003-03-04 | 富士ゼロックス株式会社 | Color image encoding device and color image decoding device |
US6359929B1 (en) | 1997-07-04 | 2002-03-19 | Matsushita Electric Industrial Co., Ltd. | Image predictive decoding method, image predictive decoding apparatus, image predictive coding apparatus, and data storage medium |
DE19730305A1 (en) | 1997-07-15 | 1999-01-21 | Bosch Gmbh Robert | Method for generating an improved image signal in the motion estimation of image sequences, in particular a prediction signal for moving images with motion-compensating prediction |
KR100244291B1 (en) | 1997-07-30 | 2000-02-01 | 구본준 | Method for motion vector coding of moving picture |
US5956431A (en) | 1997-10-02 | 1999-09-21 | S3 Incorporated | System and method for fixed-rate block-based image compression with inferred pixel values |
DE69834902T2 (en) | 1997-11-17 | 2007-02-01 | Koninklijke Philips Electronics N.V. | MOTION COMPENSATED PREDICTIVE PICTURE CODING AND DECODING |
KR100523908B1 (en) | 1997-12-12 | 2006-01-27 | 주식회사 팬택앤큐리텔 | Apparatus and method for encoding video signal for progressive scan image |
US5903382A (en) | 1997-12-19 | 1999-05-11 | Rockwell International Corporation | Electrodeposition cell with high light transmission |
US6501860B1 (en) | 1998-01-19 | 2002-12-31 | Canon Kabushiki Kaisha | Digital signal coding and decoding based on subbands |
EP0940774A3 (en) | 1998-03-05 | 2000-07-05 | Matsushita Electric Industrial Co., Ltd. | Motion vector coding and decoding apparatus and method |
JP3856262B2 (en) | 1998-03-09 | 2006-12-13 | 日本ビクター株式会社 | Motion compensation encoding apparatus, motion compensation encoding method, and motion compensation code recording medium |
JPH11289544A (en) | 1998-04-02 | 1999-10-19 | Sony Corp | Motion detector and its method |
JP3553363B2 (en) | 1998-04-03 | 2004-08-11 | 京セラミタ株式会社 | Digital image reader |
JPH11341496A (en) | 1998-05-28 | 1999-12-10 | Matsushita Electric Ind Co Ltd | Image processing method, image processing unit and data storage medium |
US6411651B1 (en) | 1998-06-26 | 2002-06-25 | Compaq Information Technologies Group, L.P. | Method and system for distributed video compression in personal computer architecture |
JP3808241B2 (en) * | 1998-07-17 | 2006-08-09 | 富士写真フイルム株式会社 | Data compression method and apparatus, and recording medium |
JP3606306B2 (en) * | 1998-10-08 | 2005-01-05 | 沖電気工業株式会社 | Image coding apparatus, image decoding apparatus, and image transmission system |
US6570924B1 (en) | 1998-11-20 | 2003-05-27 | Interval Research Corp | Low cost video compression using fast, modified Z-coding of wavelet pyramids |
US6418166B1 (en) * | 1998-11-30 | 2002-07-09 | Microsoft Corporation | Motion estimation and block matching pattern |
JP3660513B2 (en) | 1998-12-25 | 2005-06-15 | 沖電気工業株式会社 | Image communication apparatus and local decoding processing method |
US6400763B1 (en) | 1999-02-18 | 2002-06-04 | Hewlett-Packard Company | Compression system which re-uses prior motion vectors |
US6222174B1 (en) | 1999-03-05 | 2001-04-24 | Hewlett-Packard Company | Method of correlating immediately acquired and previously stored feature information for motion sensing |
US6499060B1 (en) | 1999-03-12 | 2002-12-24 | Microsoft Corporation | Media coding for loss recovery with remotely predicted data units |
JP3302939B2 (en) | 1999-03-12 | 2002-07-15 | アールシーエー トムソン ライセンシング コーポレイシヨン | Video signal decompressor for independently compressed even and odd field data |
EP1035735A3 (en) | 1999-03-12 | 2007-09-05 | Kabushiki Kaisha Toshiba | Moving image coding and decoding apparatus optimised for the application of the Real Time Protocol (RTP) |
US6381371B1 (en) | 1999-03-17 | 2002-04-30 | Hewlett-Packard Company | Method and apparatus for processing image files |
JP3591712B2 (en) | 1999-04-02 | 2004-11-24 | 松下電器産業株式会社 | Video transmitting device and video receiving device |
EP1120976A4 (en) * | 1999-07-29 | 2006-03-29 | Mitsubishi Electric Corp | Moving vector detecting method |
US6735249B1 (en) * | 1999-08-11 | 2004-05-11 | Nokia Corporation | Apparatus, and associated method, for forming a compressed motion vector field utilizing predictive motion coding |
KR20020064888A (en) | 1999-10-22 | 2002-08-10 | 액티브스카이 인코포레이티드 | An object oriented video system |
US6671319B1 (en) | 1999-12-28 | 2003-12-30 | Sony Corporation | Methods and apparatus for motion estimation using neighboring macroblocks |
JP2001203897A (en) * | 2000-01-18 | 2001-07-27 | Nec Corp | Pattern-matching encoding device and its method |
JP2001251627A (en) * | 2000-03-03 | 2001-09-14 | Matsushita Electric Ind Co Ltd | Coder, coding method and recording medium recorded with program |
JP3960451B2 (en) * | 2000-03-06 | 2007-08-15 | Ｋｄｄｉ株式会社 | Scene characteristic detection type moving picture coding apparatus |
US6661925B1 (en) | 2000-03-22 | 2003-12-09 | Board Of Supervisors Of Louisiana State University & Agricultural & Mechanical College | Functional set compression |
US6522784B1 (en) | 2000-04-11 | 2003-02-18 | International Business Machines Corporation | Enhanced compression of gray-level images |
JP3677192B2 (en) * | 2000-04-19 | 2005-07-27 | シャープ株式会社 | Image processing device |
US6711211B1 (en) | 2000-05-08 | 2004-03-23 | Nokia Mobile Phones Ltd. | Method for encoding and decoding video information, a motion compensated video encoder and a corresponding decoder |
GB2403618A (en) | 2000-05-10 | 2005-01-05 | Picturetel Corp | Video coding using multiple buffers |
KR100708091B1 (en) | 2000-06-13 | 2007-04-16 | 삼성전자주식회사 | Frame rate converter using bidirectional motion vector and method thereof |
JP2002010265A (en) | 2000-06-20 | 2002-01-11 | Sony Corp | Transmitting device and its method and receiving device and it method |
US6661842B1 (en) * | 2000-09-22 | 2003-12-09 | General Dynamics Decision Systems, Inc. | Methods and apparatus for error-resilient video coding |
JP4607305B2 (en) * | 2000-09-27 | 2011-01-05 | 株式会社東芝 | Video encoding apparatus and video encoding method |
US9143546B2 (en) | 2000-10-03 | 2015-09-22 | Realtime Data Llc | System and method for data feed acceleration and encryption |
US7224840B2 (en) | 2000-10-26 | 2007-05-29 | International Business Machines Corporation | Method, system, and program for error recovery while decoding compressed data |
JP2002141806A (en) | 2000-10-31 | 2002-05-17 | Hitachi Ltd | Variable length code decoding device |
JP3699910B2 (en) * | 2000-10-31 | 2005-09-28 | 株式会社東芝 | Data transmission apparatus, data transmission method and program |
KR20030005222A (en) * | 2001-01-10 | 2003-01-17 | 코닌클리케 필립스 일렉트로닉스 엔.브이. | Coding |
CN1156168C (en) * | 2001-01-12 | 2004-06-30 | 北京航空航天大学 | Quick video motion estimating method |
WO2002063883A1 (en) | 2001-02-06 | 2002-08-15 | Koninklijke Philips Electronics N.V. | Preprocessing method applied to textures of arbitrarily shaped objects |
US7110452B2 (en) | 2001-03-05 | 2006-09-19 | Intervideo, Inc. | Systems and methods for detecting scene changes in a video data stream |
AU2002250278A1 (en) * | 2001-03-07 | 2002-09-19 | Pts Corporation | Local constraints for motion estimation |
JP2002271788A (en) | 2001-03-08 | 2002-09-20 | Monolith Co Ltd | Image coding method and device and image decoding method and device |
JP2002290743A (en) | 2001-03-23 | 2002-10-04 | Ricoh Co Ltd | Image information coding method, coding apparatus, digital copying machine, digital facsimile machine, and digital filing apparatus |
US6819803B2 (en) | 2001-07-02 | 2004-11-16 | International Business Machines Corporation | Faster lossless rotation of JPEG images |
JP2003046944A (en) | 2001-08-02 | 2003-02-14 | Sony Corp | Signal processing equipment and method therefor, recording equipment and method therefor, regenerating equipment and method therefor, video camera, and image monitor |
FR2828614A1 (en) * | 2001-08-07 | 2003-02-14 | Koninkl Philips Electronics Nv | Video telephone image sequence coding has field identifier header, image sequence with step filling field identifier values reflecting coded image characteristics and decoding where header identifier lost |
EP1294194B8 (en) | 2001-09-10 | 2010-08-04 | Texas Instruments Incorporated | Apparatus and method for motion vector estimation |
US6856701B2 (en) | 2001-09-14 | 2005-02-15 | Nokia Corporation | Method and system for context-based adaptive binary arithmetic coding |
US7643559B2 (en) | 2001-09-14 | 2010-01-05 | Ntt Docomo, Inc. | Coding method, decoding method, coding apparatus, decoding apparatus, image processing system, coding program, and decoding program |
FI112424B (en) | 2001-10-30 | 2003-11-28 | Oplayo Oy | Coding procedure and arrangement |
CA2574127A1 (en) | 2002-01-18 | 2003-07-31 | Kabushiki Kaisha Toshiba | Video encoding method and apparatus and video decoding method and apparatus |
JP3864098B2 (en) | 2002-02-08 | 2006-12-27 | 日本電信電話株式会社 | Moving picture encoding method, moving picture decoding method, execution program of these methods, and recording medium recording these execution programs |
KR101108661B1 (en) | 2002-03-15 | 2012-01-25 | 노키아 코포레이션 | Method for coding motion in a video sequence |
WO2003084235A1 (en) | 2002-03-28 | 2003-10-09 | British Telecommunications Public Limited Company | Video pre-processing |
US7116831B2 (en) * | 2002-04-10 | 2006-10-03 | Microsoft Corporation | Chrominance motion vector rounding |
US7110459B2 (en) | 2002-04-10 | 2006-09-19 | Microsoft Corporation | Approximate bicubic filter |
JP4355156B2 (en) | 2002-04-16 | 2009-10-28 | パナソニック株式会社 | Image decoding method and image decoding apparatus |
JP4102973B2 (en) * | 2002-04-24 | 2008-06-18 | 日本電気株式会社 | Encoding method and decoding method of moving image, apparatus and program using the same |
DE50305419D1 (en) | 2002-05-02 | 2006-11-30 | Fraunhofer Ges Forschung | Encoding and decoding of transform coefficients in image or video encoders |
AU2003246987A1 (en) * | 2002-07-09 | 2004-01-23 | Nokia Corporation | Method and system for selecting interpolation filter type in video coding |
AU2003281127B2 (en) | 2002-07-15 | 2009-04-02 | Nokia Technologies Oy | Method for error concealment in video sequences |
KR100865034B1 (en) * | 2002-07-18 | 2008-10-23 | 엘지전자 주식회사 | Method for predicting motion vector |
US7068722B2 (en) | 2002-09-25 | 2006-06-27 | Lsi Logic Corporation | Content adaptive video processor using motion compensation |
US20040120398A1 (en) | 2002-12-19 | 2004-06-24 | Ximin Zhang | System and method for adaptive field and frame video encoding using rate-distortion characteristics |
US20040131117A1 (en) | 2003-01-07 | 2004-07-08 | Sheraizin Vitaly S. | Method and apparatus for improving MPEG picture compression |
JP4419458B2 (en) * | 2003-07-14 | 2010-02-24 | リコープリンティングシステムズ株式会社 | Inkjet head manufacturing method |
JP4198608B2 (en) | 2004-01-15 | 2008-12-17 | 株式会社東芝 | Interpolated image generation method and apparatus |
US20050271186A1 (en) | 2004-06-02 | 2005-12-08 | Audiopoint, Inc. | System, method and computer program product for interactive voice notification |
JP4852868B2 (en) | 2005-04-04 | 2012-01-11 | トヨタ自動車株式会社 | Precision machining method |
JP4662171B2 (en) | 2005-10-20 | 2011-03-30 | ソニー株式会社 | Encoding apparatus and method, decoding apparatus and method, program, and recording medium |
CA2633819C (en) | 2005-12-08 | 2016-12-06 | Vidyo, Inc. | Systems and methods for error resilience and random access in video communication systems |
US7924925B2 (en) | 2006-02-24 | 2011-04-12 | Freescale Semiconductor, Inc. | Flexible macroblock ordering with reduced data traffic and power consumption |
KR101378079B1 (en) | 2006-04-20 | 2014-03-28 | 톰슨 라이센싱 | Method and apparatus for redundant video coding |
WO2007130389A2 (en) | 2006-05-01 | 2007-11-15 | Georgia Tech Research Corporation | Automatic video quality measurement system and method based on spatial-temporal coherence metrics |
US20080170793A1 (en) | 2007-01-12 | 2008-07-17 | Mitsubishi Electric Corporation | Image encoding device and image encoding method |
US20090103635A1 (en) | 2007-10-17 | 2009-04-23 | Peshala Vishvajith Pahalawatta | System and method of unequal error protection with hybrid arq/fec for video streaming over wireless local area networks |
CN101414348A (en) | 2007-10-19 | 2009-04-22 | 三星电子株式会社 | Method and system for identifying human face in multiple angles |
US8130823B2 (en) | 2007-12-19 | 2012-03-06 | Broadcom Corporation | Channel adaptive video transmission system for use with layered video coding and methods for use therewith |
AU2008259744B2 (en) | 2008-12-18 | 2012-02-09 | Canon Kabushiki Kaisha | Iterative DVC decoder based on adaptively weighting of motion side information |
EP2481217A4 (en) | 2009-09-26 | 2014-02-19 | Disternet Technology Inc | System and method for micro-cloud computing |
US8879632B2 (en) | 2010-02-18 | 2014-11-04 | Qualcomm Incorporated | Fixed point implementation for geometric motion partitioning |
US8249361B1 (en) | 2010-04-22 | 2012-08-21 | Google Inc. | Interdependent learning of template map and similarity metric for object identification |
RU2010140334A (en) | 2010-10-01 | 2012-04-10 | ЭлЭсАй Корпорейшн (US) | IN-FRAME MODE PREDICTION FOR VIDEO TRANSCODER |
US20120082225A1 (en) | 2010-10-01 | 2012-04-05 | Qualcomm Incorporated | Selective indication of transform sizes |
US8749565B2 (en) | 2010-11-19 | 2014-06-10 | Apple Inc. | Error check-only mode |
US8630341B2 (en) | 2011-01-14 | 2014-01-14 | Mitsubishi Electric Research Laboratories, Inc. | Method for training and utilizing separable transforms for video coding |
CN106898307B (en) | 2011-05-28 | 2021-04-27 | 伊格尼斯创新公司 | Method for displaying images on a display implemented in an interlaced mode |
US8775672B2 (en) | 2012-06-13 | 2014-07-08 | Hulu, LLC | Architecture for simulation of network conditions for video delivery |
-
2003
- 2003-11-14 US US10/713,807 patent/US8824553B2/en active Active
-
2004
- 2004-05-12 CA CA2525390A patent/CA2525390C/en not_active Expired - Lifetime
- 2004-05-12 WO PCT/US2004/015025 patent/WO2004102946A2/en active Application Filing
- 2004-05-12 KR KR1020117005253A patent/KR101118438B1/en active IP Right Grant
- 2004-05-12 KR KR1020117005251A patent/KR101131689B1/en active IP Right Grant
- 2004-05-12 KR KR1020117005252A patent/KR101118456B1/en active IP Right Grant
- 2004-05-12 KR KR1020117005250A patent/KR101133321B1/en active IP Right Grant
- 2004-05-12 JP JP2006533037A patent/JP4568887B2/en not_active Expired - Fee Related
- 2004-05-12 EP EP04752128A patent/EP1656791A2/en not_active Withdrawn
- 2004-05-12 KR KR1020117005249A patent/KR101167006B1/en active IP Right Grant
- 2004-05-12 CN CN2004800200197A patent/CN101454990B/en not_active Expired - Lifetime
- 2004-05-12 KR KR1020057021588A patent/KR101140947B1/en active IP Right Grant
- 2004-05-12 CN CN2012101402633A patent/CN103037214A/en active Pending
-
2010
- 2010-05-26 JP JP2010121008A patent/JP5341024B2/en not_active Expired - Fee Related
- 2010-10-25 JP JP2010239018A patent/JP5480775B2/en not_active Expired - Lifetime
-
2012
- 2012-08-30 US US13/599,333 patent/US20120320978A1/en not_active Abandoned
- 2012-08-30 US US13/599,371 patent/US20120320992A1/en not_active Abandoned
- 2012-08-30 US US13/599,345 patent/US20120320987A1/en not_active Abandoned
- 2012-08-30 US US13/599,315 patent/US8942290B2/en not_active Expired - Lifetime
- 2012-08-30 US US13/599,360 patent/US10616576B2/en not_active Expired - Lifetime
-
2013
- 2013-06-04 JP JP2013117983A patent/JP5606591B2/en not_active Expired - Fee Related
-
2014
- 2014-01-21 JP JP2014008689A patent/JP2014099905A/en active Pending
-
2020
- 2020-03-24 US US16/827,864 patent/US11240498B2/en not_active Expired - Lifetime
-
2022
- 2022-01-07 US US17/570,533 patent/US20220132116A1/en not_active Abandoned
Patent Citations (9)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5912707A (en) * | 1995-12-23 | 1999-06-15 | Daewoo Electronics., Ltd. | Method and apparatus for compensating errors in a transmitted video signal |
US20030142753A1 (en) * | 1997-01-31 | 2003-07-31 | Acmi Corporation | Correction of image signals characteristic of non-uniform images in an endoscopic imaging system |
US6201896B1 (en) * | 1997-12-10 | 2001-03-13 | Nec Corporation | Picture encoding apparatus |
US20020141501A1 (en) * | 1998-11-20 | 2002-10-03 | Philips Electronics North America Corporation | System for performing resolution upscaling on frames of digital video |
US6389072B1 (en) * | 1998-12-23 | 2002-05-14 | U.S. Philips Corp. | Motion analysis based buffer regulation scheme |
US7010036B1 (en) * | 1999-02-01 | 2006-03-07 | Koninklijke Philips Electronics N.V. | Descriptor for a video sequence and image retrieval system using said descriptor |
US20030161398A1 (en) * | 2002-02-21 | 2003-08-28 | Meir Feder | Improving static picture quality in compressed video |
US20030161401A1 (en) * | 2002-02-27 | 2003-08-28 | Bo Shen | Reducing the resolution of media data |
US20060098738A1 (en) * | 2003-01-09 | 2006-05-11 | Pamela Cosman | Video encoding methods and devices |
Cited By (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN110582022A (en) * | 2019-09-27 | 2019-12-17 | 腾讯科技（深圳）有限公司 | Video encoding and decoding method and device and storage medium |
Also Published As
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US11240498B2 (en) | Independently coding frame areas | |
US8086052B2 (en) | Hybrid video compression method | |
US6438168B2 (en) | Bandwidth scaling of a compressed video stream | |
KR100295006B1 (en) | Real-time encoding of video sequence employing two encoders and statistical analysis | |
US20110206132A1 (en) | Data Compression for Video | |
US20110206119A1 (en) | Data Compression for Video | |
WO2000045602A1 (en) | Optimal encoding scheme for motion compensated video | |
US6252905B1 (en) | Real-time evaluation of compressed picture quality within a digital video encoder | |
US7203369B2 (en) | Method for estimating motion by referring to discrete cosine transform coefficients and apparatus therefor |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:ON2 TECHNOLOGIES, LLC;REEL/FRAME:028925/0778Effective date: 20100416 |
|
STCB | Information on status: application discontinuation |
Free format text: ABANDONED -- AFTER EXAMINER'S ANSWER OR BOARD OF APPEALS DECISION |