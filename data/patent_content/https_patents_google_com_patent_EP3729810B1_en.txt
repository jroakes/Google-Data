EP3729810B1 - Motion vector coding using residual block energy distribution - Google Patents
Motion vector coding using residual block energy distribution Download PDFInfo
- Publication number
- EP3729810B1 EP3729810B1 EP18782604.5A EP18782604A EP3729810B1 EP 3729810 B1 EP3729810 B1 EP 3729810B1 EP 18782604 A EP18782604 A EP 18782604A EP 3729810 B1 EP3729810 B1 EP 3729810B1
- Authority
- EP
- European Patent Office
- Prior art keywords
- category
- transform block
- block
- transform
- motion vector
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active
Links
- 239000013598 vector Substances 0.000 title claims description 126
- 238000009826 distribution Methods 0.000 title claims description 55
- 208000037170 Delayed Emergence from Anesthesia Diseases 0.000 title claims description 39
- 238000000034 method Methods 0.000 claims description 76
- 230000015654 memory Effects 0.000 claims description 27
- 230000008569 process Effects 0.000 description 38
- 238000010586 diagram Methods 0.000 description 18
- 230000004044 response Effects 0.000 description 12
- 230000000875 corresponding effect Effects 0.000 description 11
- 238000004891 communication Methods 0.000 description 10
- 238000001914 filtration Methods 0.000 description 10
- 238000012545 processing Methods 0.000 description 10
- 230000006835 compression Effects 0.000 description 9
- 238000007906 compression Methods 0.000 description 9
- 230000006870 function Effects 0.000 description 6
- 238000013139 quantization Methods 0.000 description 5
- 230000002123 temporal effect Effects 0.000 description 4
- 230000005540 biological transmission Effects 0.000 description 3
- 230000000903 blocking effect Effects 0.000 description 3
- 230000003287 optical effect Effects 0.000 description 3
- 238000004590 computer program Methods 0.000 description 2
- 230000003750 conditioning effect Effects 0.000 description 2
- 238000013461 design Methods 0.000 description 2
- 238000006073 displacement reaction Methods 0.000 description 2
- 230000009467 reduction Effects 0.000 description 2
- 230000003044 adaptive effect Effects 0.000 description 1
- 238000013459 approach Methods 0.000 description 1
- 238000003491 array Methods 0.000 description 1
- 230000015556 catabolic process Effects 0.000 description 1
- 230000001413 cellular effect Effects 0.000 description 1
- 230000008859 change Effects 0.000 description 1
- 239000003086 colorant Substances 0.000 description 1
- 230000008867 communication pathway Effects 0.000 description 1
- 150000001875 compounds Chemical class 0.000 description 1
- 230000002596 correlated effect Effects 0.000 description 1
- 230000006837 decompression Effects 0.000 description 1
- 238000006731 degradation reaction Methods 0.000 description 1
- 238000010790 dilution Methods 0.000 description 1
- 239000012895 dilution Substances 0.000 description 1
- 230000000694 effects Effects 0.000 description 1
- 239000004973 liquid crystal related substance Substances 0.000 description 1
- 238000005192 partition Methods 0.000 description 1
- 230000002250 progressing effect Effects 0.000 description 1
- 239000004065 semiconductor Substances 0.000 description 1
- 239000007787 solid Substances 0.000 description 1
- 238000012546 transfer Methods 0.000 description 1
- 230000009466 transformation Effects 0.000 description 1
- 230000001131 transforming effect Effects 0.000 description 1
- 238000013519 translation Methods 0.000 description 1
- 230000014616 translation Effects 0.000 description 1
Images
Classifications
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/50—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding
- H04N19/503—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding involving temporal prediction
- H04N19/51—Motion estimation or motion compensation
- H04N19/513—Processing of motion vectors
- H04N19/517—Processing of motion vectors by encoding
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/102—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or selection affected or controlled by the adaptive coding
- H04N19/13—Adaptive entropy coding, e.g. adaptive variable length coding [AVLC] or context adaptive binary arithmetic coding [CABAC]
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/134—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or criterion affecting or controlling the adaptive coding
- H04N19/157—Assigned coding mode, i.e. the coding mode being predefined or preselected to be further used for selection of another element or parameter
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/60—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using transform coding
- H04N19/61—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using transform coding in combination with predictive coding
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/90—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using coding techniques not provided for in groups H04N19/10-H04N19/85, e.g. fractals
- H04N19/91—Entropy coding, e.g. variable length coding [VLC] or arithmetic coding
Definitions
- Digital video streams may represent video using a sequence of frames or still images.
- Digital video can be used for various applications including, for example, video conferencing, high definition video entertainment, video advertisements, or sharing of user-generated videos.
- a digital video stream can contain a large amount of data and consume a significant amount of computing or communication resources of a computing device for processing, transmission or storage of the video data.
- Various approaches have been proposed to reduce the amount of data in video streams, including compression and other encoding techniques.
- One technique for compression uses a reference frame and a motion vector to generate a prediction block corresponding to a current block to be encoded. Differences between the prediction block and the current block can be encoded, instead of the values of the current block themselves, to reduce the amount of data encoded.
- EP2661088A1 describes an encoding device.
- WO2013103863A1 describes techniques related to identifying when motion vector difference (MVD) is skipped for one or both reference picture lists.
- MARPE D ET AL "Further Results for CABAC Entropy Coding Scheme", 13.
- VCEG MEETING; 02-04-2001 - 04-04-2001 presents experimental results relating to context-based adaptive binary arithmetic coding (CABAC).
- CABAC context-based adaptive binary arithmetic coding
- This disclosure relates generally to encoding and decoding video data and more particularly relates to improved coding of motion vectors.
- a method for encoding described herein includes determining a motion vector for inter predicting a current block, inter predicting the current block using the motion vector to determine a residual block, determining, using the residual block, a transform block of transform coefficients for the current block, determining a category of the transform block that correlates to an energy distribution in the residual block, determining, using the category, a context for coding the motion vector, and encoding the motion vector using the context.
- the category can be determined using positions of non-zero coefficients of the transform coefficients, and the category is one of a plurality of categories, each category of the plurality of categories defined by a different energy distribution.
- the context includes a probability distribution used for entropy coding the motion vector.
- An apparatus for encoding includes a non-transitory storage medium or memory and a processor.
- the memory includes instructions executable by the processor to determine a motion vector for inter predicting a current block, inter predict the current block using the motion vector to determine a residual block, determine, using the residual block, a transform block for the current block, determine, using positions of non-zero coefficients of the transform block and a size of the transform block, a category of the transform block that correlates to an energy distribution in the residual block, the category being one of a plurality of categories, and each category of the plurality of categories defined by a different energy distribution, determine, using the category, a context for encoding the motion vector, and encode, in a compressed bitstream, the motion vector using the context.
- the context may include a probability distribution used for entropy coding the motion vector.
- An aspect of an apparatus for decoding described herein includes a non-transitory storage medium or memory and a processor.
- the memory includes instructions executable by the processor decode, from an encoded bitstream, a transform block for a current block, the transform block corresponding to a residual block for the current block, determine, using positions of non-zero coefficients of the transform block, a category of the transform block that correlates to an energy distribution in the residual block, the category being one of a plurality of categories, and each category of the plurality of categories defined by a different energy distribution, determine, using the category, a context for decoding a motion vector used for encoding the current block, and decode, from the encoded bitstream, the motion vector using the context.
- a method for decoding includes decoding, from an encoded bitstream, a transform block for a current block, the transform block corresponding to a residual block for the current block, determining, using positions of non-zero coefficients of the transform block, a category of the transform block that correlates to an energy distribution in the residual block, the category being one of a plurality of categories, and each category of the plurality of categories defined by a different energy distribution, determining, using the category, a context for decoding a motion vector used for encoding the current block, decoding, from the encoded bitstream, the motion vector using the context, and reconstructing the current block using the motion vector.
- a video stream can be compressed by a variety of techniques to reduce the bandwidth required to transmit or store the video stream.
- a video stream can be encoded into a bitstream (i.e., a compressed bitstream), which involves compression.
- the compressed bitstream can then be transmitted to a decoder that can decode or decompress the compressed bitstream to prepare it for viewing or further processing.
- Compression of the video stream often exploits spatial and temporal correlation of video signals through spatial and/or motion-compensated prediction.
- Motion-compensated prediction may also be referred to as inter prediction.
- Inter prediction uses one or more motion vectors to generate a block (also called a prediction block) that resembles a current block to be encoded using previously encoded and decoded pixels.
- a decoder receiving the encoded signal can re-create the current block.
- the difference between the two blocks is referred to herein as the residual or the residual block.
- Coding the residual block can include generating one or more transform blocks for the residual block.
- a transform block can include zero and non-zero transform coefficients. The transform coefficients are then encoded into the compressed bitstream.
- the residual block is typically in the pixel domain.
- a transform block is typically in the frequency domain.
- Each motion vector used to generate a prediction block in the inter-prediction process refers to a frame (i.e., a reference frame) other than a current frame.
- Reference frames can be located before or after the current frame in the sequence (i.e., the display order) of the video stream, and may be frames that are reconstructed before being used as reference frames.
- a forward reference frame is a frame used for forward prediction relative to the sequence
- a backward reference frame is a frame used for backward prediction relative to the sequence.
- One or more forward and/or backward reference frames can be used to encode or decode a block.
- the efficacy of a reference frame when used to encode or decode a block (i.e., a current block) within a current frame can be measured based on a resulting signal-to-noise ratio or other measure of rate-distortion.
- the motion vector(s) for a current block in motion-compensated prediction may be encoded into, and decoded from, the encoded bitstream.
- a motion vector for a current block i.e., a block being encoded
- the motion vector describes an offset (i.e., a displacement) in the horizontal direction (i.e., mv_x) and a displacement in the vertical direction (i.e., mv_y) from the co-located block in the reference frame.
- a motion vector can be characterized as a 3-tuple (f, mv_x, mv_y) where f is indicative of (e.g., is an index of) a reference frame, mv_x is the offset in the horizontal direction, and mv_y is the offset in the vertical direction.
- f is indicative of (e.g., is an index of) a reference frame
- mv_x is the offset in the horizontal direction
- mv_y is the offset in the vertical direction.
- a motion vector may be encoded differentially. Namely, a motion vector is selected as a reference motion vector, and only a difference between the motion vector and the reference motion vector (also called the motion vector difference) is encoded into the bitstream.
- the reference motion vector may be a motion vector of one of the neighboring blocks, for example.
- the neighboring blocks can include spatial neighboring blocks (i.e., blocks in the same current frame as the current block).
- the neighboring blocks can include temporal neighboring blocks (i.e., blocks in frames other than the current frame).
- the prediction block that results in the best residual may not correspond with pixels in the reference frame. That is, the best motion vector may point to a location that is between pixels of blocks in the reference frame.
- motion compensated prediction at the sub-pixel level is useful.
- Motion compensated prediction may involve the use of a sub-pixel interpolation filter that generates filtered sub-pixel values at defined locations between the full pixels (also called integer pixels) along rows, columns, or both.
- the interpolation filter may be one of a number of interpolation filters available for use in motion compensated prediction. Sub-pixel interpolation is further described below with respect to FIGS. 6-8 .
- Different interpolation filters may be available. Each of the interpolation filters may be designed to provide a different frequency response.
- the available interpolation filters may include a smooth filter, a normal filter, a sharp filter, and a bilinear filter.
- the interpolation filter to be used by a decoder to generate a prediction block may be signaled in the header of the frame containing the block to be predicted. As such, the same interpolation filter is used to generate sub-pixel prediction blocks for all blocks of the frame.
- the interpolation filter may also be signaled at a coding unit level. As such, the same interpolation filter is used for every block (e.g., every prediction block) of the coding unit to generate sub-pixel prediction blocks for the blocks of the coding unit.
- An encoder may generate a prediction block based on each of the available interpolation filters. The encoder then selects (i.e., to signal to the decoder) the filter that results in, e.g., the best rate-distortion ratio.
- a rate-distortion ratio refers to a ratio that balances an amount of distortion (i.e., loss in video quality) with rate (i.e., the number of bits) required for encoding.
- Coding a motion vector refers to the coding of the motion vector and to the differential coding of a motion vector. In either case, coding a motion vector includes coding the horizontal offset (i.e., mv_x) and coding the vertical offset (i.e., mv_y) of the motion vector.
- coding means encoding in an encoded bitstream.
- coding means decoding from an encoded bitstream.
- Coding the motion vector can include entropy coding the horizontal offset and the vertical offsets of the motion vector. As such, a context is determined for the motion vector and a probability model, corresponding to the context, is used for the coding the motion vector.
- Entropy coding is a technique for "lossless" coding that relies upon probability models that model the distribution of values occurring in an encoded video bitstream.
- probability models based on a measured or estimated distribution of values
- entropy coding can reduce the number of bits required to represent video data close to a theoretical minimum.
- the actual reduction in the number of bits required to represent video data can be a function of the accuracy of the probability model, the number of bits over which the coding is performed, and the computational accuracy of fixed-point arithmetic used to perform the coding.
- a purpose of context modeling is to obtain probability distributions for a subsequent entropy coding engine, such as arithmetic coding, Huffman coding, and other variable-length-to-variable-length coding engines.
- a subsequent entropy coding engine such as arithmetic coding, Huffman coding, and other variable-length-to-variable-length coding engines.
- contexts may be required. For example, some video coding systems can include hundreds or even thousands of contexts for transform coefficient coding alone. Each context can correspond to a probability distribution.
- a probability distribution can be learnt by a decoder and/or included in the header of a frame to be decoded.
- Learnt can mean that an entropy coding engine of a decoder can adapt the probability distributions (i.e., probability models) of a context model based on decoded frames and/or decoded blocks.
- the decoder can have available an initial probability distribution that the decoder (e.g., the entropy coding engine of the decoder) can continuously update as the decoder decodes additional frames.
- the updating of the probability models can insure that the initial probability distribution is updated to reflect the actual distributions in the decoded frames.
- Including a probability distribution in the header can instruct the decoder to use the included probability distribution for decoding the next frame, given the corresponding context.
- a cost (in bits) is associated with including each probability distribution in the header. For example, in a coding system that includes 3000 contexts and that encodes a probability distribution (coded as an integer value between 1 and 255) using 8 bits, 24,000 bits are added to the encoded bitstream. These bits are overhead bits. Some techniques can be used to reduce the number of overhead bits. For example, the probability distributions for some, but not all, of the contexts can be included. For example, prediction schemes can also be used to reduce the overhead bits. Even with these overhead reduction techniques, the overhead is non-zero.
- a model as used herein, can be, or can be a parameter in, a lossless (entropy) coding.
- a model can be any parameter or method that affects probability estimation for entropy coding.
- codecs may limit the information used (i.e., as context) to code motion vectors.
- the information can be limited to readily available information. For example, as reconstructed pixel values (further described below) are not readily available, they are not used as contextual information for selecting a probability model for coding motion vectors.
- conditioning the entropy decoder on reconstructed pixels may result in significant performance degradation of the entropy decoder.
- the previously decoded blocks can be blocks in the spatial neighborhood and/or the temporal neighborhood of the current block being encoded.
- the spatial neighborhood can include the top (i.e., above) and left neighboring blocks of the current block in the current frame.
- the temporal neighborhood can include co-located blocks in previously coded frames (i.e., reference frames).
- inter-prediction modes may be available. For example, one available inter-prediction mode represents that the motion vector of a block is 0. This may be referred to as a ZEROMV mode. Another inter-prediction mode may represent that the motion vector of the block is the reference motion vector. This may be referred to as a REFMV mode. When the motion vector for the block is not zero, and is different from the reference motion vector, the motion vector may be encoded using the reference motion vector. This mode may be referred to as a NEWMV mode herein. Other inter-prediction modes may be available.
- the readily available information used for coding a motion vector can also include whether the current block is a luminance or chrominance block and the block size.
- references blocks at different sub-pixel positions may have different characteristics in the transform domain. For example, a reference block at a sub-pixel position generated by a low-pass filter is likely to have lower energy in a high frequency band than a reference block at a full-pixel position. Since a residual block is the difference between a source block and a reference block, the energy distribution in the residual block is thus correlated with that of a reference block.
- the efficiency of entropy coding can be directly related to the probability model, which is in turn selected based on the context model.
- the entropy H(X) can be a measure of the number of bits required to code the variable X; and the conditional entropy H(X
- Y) can be a measure of the number of bits required to code the variable X given that the quantity Y is known.
- Y) are related by the well-known property H(X
- coding of the motion vector may be improved by using the energy distribution information (i.e., Y).
- the energy distribution information contained in the transform block can be used as additional context information for coding the motion vector.
- Implementations according to this disclosure use the energy distribution information available in a transform block to code motion vectors associated with the residual block. Using the energy distribution information available in the transform block can improve compression performance. Details of improved coding of motion vectors are described herein with initial reference to a system in which the teachings herein can be implemented.
- FIG. 1 is a schematic of a video encoding and decoding system 100.
- a transmitting station 102 can be, for example, a computer having an internal configuration of hardware such as that described in FIG. 2 .
- the processing of the transmitting station 102 can be distributed among multiple devices.
- a network 104 can connect the transmitting station 102 and a receiving station 106 for encoding and decoding of the video stream.
- the video stream can be encoded in the transmitting station 102 and the encoded video stream can be decoded in the receiving station 106.
- the network 104 can be, for example, the Internet.
- the network 104 can also be a local area network (LAN), wide area network (WAN), virtual private network (VPN), cellular telephone network or any other means of transferring the video stream from the transmitting station 102 to, in this example, the receiving station 106.
- the receiving station 106 in one example, can be a computer having an internal configuration of hardware such as that described in FIG. 2 . However, other suitable implementations of the receiving station 106 are possible. For example, the processing of the receiving station 106 can be distributed among multiple devices.
- an implementation can omit the network 104.
- a video stream can be encoded and then stored for transmission at a later time to the receiving station 106 or any other device having a non-transitory storage medium or memory.
- the receiving station 106 receives (e.g., via the network 104, a computer bus, and/or some communication pathway) the encoded video stream and stores the video stream for later decoding.
- a real-time transport protocol RTP
- a transport protocol other than RTP may be used, e.g., a Hypertext Transfer Protocol (HTTP) based video streaming protocol.
- HTTP Hypertext Transfer Protocol
- the transmitting station 102 and/or the receiving station 106 may include the ability to both encode and decode a video stream as described below.
- the receiving station 106 could be a video conference participant who receives an encoded video bitstream from a video conference server (e.g., the transmitting station 102) to decode and view and further encodes and transmits its own video bitstream to the video conference server for decoding and viewing by other participants.
- FIG. 2 is a block diagram of an example of a computing device 200 that can implement a transmitting station or a receiving station.
- the computing device 200 can implement one or both of the transmitting station 102 and the receiving station 106 of FIG. 1 .
- the computing device 200 can be in the form of a computing system including multiple computing devices, or in the form of one computing device, for example, a mobile phone, a tablet computer, a laptop computer, a notebook computer, a desktop computer, and the like.
- a CPU 202 in the computing device 200 can be a central processing unit.
- the CPU 202 can be any other type of device, or multiple devices, capable of manipulating or processing information now-existing or hereafter developed.
- the disclosed implementations can be practiced with one processor as shown, e.g., the CPU 202, advantages in speed and efficiency can be achieved using more than one processor.
- a memory 204 in computing device 200 can be a read only memory (ROM) device or a random access memory (RAM) device in an implementation. Any other suitable type of storage device or non-transitory storage medium can be used as the memory 204.
- the memory 204 can include code and data 206 that is accessed by the CPU 202 using a bus 212.
- the memory 204 can further include an operating system 208 and application programs 210, the application programs 210 including at least one program that permits the CPU 202 to perform the methods described here.
- the application programs 210 can include applications 1 through N, which further include a video coding application that performs the methods described here.
- Computing device 200 can also include a secondary storage 214, which can, for example, be a memory card used with a mobile computing device. Because the video communication sessions may contain a significant amount of information, they can be stored in whole or in part in the secondary storage 214 and loaded into the memory 204 as needed for processing.
- the computing device 200 can also include one or more output devices, such as a display 218.
- the display 218 may be, in one example, a touch sensitive display that combines a display with a touch sensitive element that is operable to sense touch inputs.
- the display 218 can be coupled to the CPU 202 via the bus 212.
- Other output devices that permit a user to program or otherwise use the computing device 200 can be provided in addition to or as an alternative to the display 218.
- the output device is or includes a display
- the display can be implemented in various ways, including by a liquid crystal display (LCD), a cathode-ray tube (CRT) display or light emitting diode (LED) display, such as an organic LED (OLED) display.
- LCD liquid crystal display
- CRT cathode-ray tube
- LED light emitting diode
- OLED organic LED
- the computing device 200 can also include or be in communication with an image-sensing device 220, for example a camera, or any other image-sensing device 220 now existing or hereafter developed that can sense an image such as the image of a user operating the computing device 200.
- the image-sensing device 220 can be positioned such that it is directed toward the user operating the computing device 200.
- the position and optical axis of the image-sensing device 220 can be configured such that the field of vision includes an area that is directly adjacent to the display 218 and from which the display 218 is visible.
- the computing device 200 can also include or be in communication with a sound-sensing device 222, for example a microphone, or any other sound-sensing device now existing or hereafter developed that can sense sounds near the computing device 200.
- the sound-sensing device 222 can be positioned such that it is directed toward the user operating the computing device 200 and can be configured to receive sounds, for example, speech or other utterances, made by the user while the user operates the computing device 200.
- FIG. 2 depicts the CPU 202 and the memory 204 of the computing device 200 as being integrated into one unit, other configurations can be utilized.
- the operations of the CPU 202 can be distributed across multiple machines (wherein individual machines can have one or more of processors) that can be coupled directly or across a local area or other network.
- the memory 204 can be distributed across multiple machines such as a network-based memory or memory in multiple machines performing the operations of the computing device 200.
- the bus 212 of the computing device 200 can be composed of multiple buses.
- the secondary storage 214 can be directly coupled to the other components of the computing device 200 or can be accessed via a network and can comprise an integrated unit such as a memory card or multiple units such as multiple memory cards.
- the computing device 200 can thus be implemented in a wide variety of configurations.
- FIG. 3 is a diagram of an example of a video stream 300 to be encoded and subsequently decoded.
- the video stream 300 includes a video sequence 302.
- the video sequence 302 includes a number of adjacent frames 304. While three frames are depicted as the adjacent frames 304, the video sequence 302 can include any number of adjacent frames 304.
- the adjacent frames 304 can then be further subdivided into individual frames, e.g., a frame 306.
- the frame 306 can be divided into a series of planes or segments 308.
- the segments 308 can be subsets of frames that permit parallel processing, for example.
- the segments 308 can also be subsets of frames that can separate the video data into separate colors.
- a frame 306 of color video data can include a luminance plane and two chrominance planes.
- the segments 308 may be sampled at different resolutions.
- the frame 306 may be further subdivided into blocks 310, which can contain data corresponding to, for example, 16 ⁇ 16 pixels in the frame 306.
- the blocks 310 can also be arranged to include data from one or more segments 308 of pixel data.
- the blocks 310 can also be of any other suitable size such as 4x4 pixels, 8x8 pixels, 16x8 pixels, 8x16 pixels, 16x16 pixels, or larger. Unless otherwise noted, the terms block and macroblock are used interchangeably herein.
- FIG. 4 is a block diagram of an encoder 400 according to implementations of this disclosure.
- the encoder 400 can be implemented, as described above, in the transmitting station 102 such as by providing a computer software program stored in memory, for example, the memory 204.
- the computer software program can include machine instructions that, when executed by a processor such as the CPU 202, cause the transmitting station 102 to encode video data in the manner described in FIG. 4 .
- the encoder 400 can also be implemented as specialized hardware included in, for example, the transmitting station 102.
- the encoder 400 may be a hardware encoder.
- the encoder 400 has the following stages to perform the various functions in a forward path (shown by the solid connection lines) to produce an encoded or compressed bitstream 420 using the video stream 300 as input: an intra/inter prediction stage 402, a transform stage 404, a quantization stage 406, and an entropy encoding stage 408.
- the encoder 400 may also include a reconstruction path (shown by the dotted connection lines) to reconstruct a frame for encoding of future blocks.
- the encoder 400 has the following stages to perform the various functions in the reconstruction path: a dequantization stage 410, an inverse transform stage 412, a reconstruction stage 414, and a loop filtering stage 416.
- Other structural variations of the encoder 400 can be used to encode the video stream 300.
- respective frames 304 can be processed in units of blocks.
- respective blocks can be encoded using intra-frame prediction (also called intra-prediction) or inter-frame prediction (also called inter-prediction).
- intra-frame prediction also called intra-prediction
- inter-frame prediction also called inter-prediction
- a prediction block can be formed.
- intra-prediction a prediction block may be formed from samples in the current frame that have been previously encoded and reconstructed.
- inter-prediction a prediction block may be formed from samples in one or more previously constructed reference frames.
- the prediction block can be subtracted from the current block at the intra/inter prediction stage 402 to produce a residual block (also called a residual).
- the transform stage 404 transforms the residual into transform coefficients in, for example, the frequency domain using block-based transforms.
- the quantization stage 406 converts the transform coefficients into discrete quantum values, which are referred to as quantized transform coefficients, using a quantizer value or a quantization level. For example, the transform coefficients may be divided by the quantizer value and truncated.
- the quantized transform coefficients are then entropy encoded by the entropy encoding stage 408.
- the entropy-encoded coefficients, together with other information used to decode the block, which may include for example the type of prediction used, transform type, motion vectors and quantizer value, are then output to the compressed bitstream 420.
- the compressed bitstream 420 can be formatted using various techniques, such as variable length coding (VLC) or arithmetic coding.
- VLC variable length coding
- the compressed bitstream 420 can also be referred to as an encoded video stream or encoded video bitstream, and the terms will be used interchangeably herein.
- the reconstruction path in FIG. 4 can be used to ensure that the encoder 400 and a decoder 500 (described below) use the same reference frames to decode the compressed bitstream 420.
- the reconstruction path performs functions that are similar to functions that take place during the decoding process that are discussed in more detail below, including dequantizing the quantized transform coefficients at the dequantization stage 410 and inverse transforming the dequantized transform coefficients at the inverse transform stage 412 to produce a derivative residual block (also called a derivative residual).
- the prediction block that was predicted at the intra/inter prediction stage 402 can be added to the derivative residual to create a reconstructed block.
- the loop filtering stage 416 can be applied to the reconstructed block to reduce distortion such as blocking artifacts.
- encoder 400 can be used to encode the compressed bitstream 420.
- a non-transform based encoder can quantize the residual signal directly without the transform stage 404 for certain blocks or frames.
- an encoder can have the quantization stage 406 and the dequantization stage 410 combined in a common stage.
- FIG. 5 is a block diagram of a decoder 500 according to implementations of this disclosure.
- the decoder 500 can be implemented in the receiving station 106, for example, by providing a computer software program stored in the memory 204.
- the computer software program can include machine instructions that, when executed by a processor such as the CPU 202, cause the receiving station 106 to decode video data in the manner described herein.
- the decoder 500 can also be implemented in hardware included in, for example, the transmitting station 102 or the receiving station 106.
- the decoder 500 may be a hardware decoder.
- the decoder 500 similar to the reconstruction path of the encoder 400 discussed above, includes in one example the following stages to perform various functions to produce an output video stream 516 from the compressed bitstream 420: an entropy decoding stage 502, a dequantization stage 504, an inverse transform stage 506, an intra/inter prediction stage 508, a reconstruction stage 510, a loop filtering stage 512 and a post filtering stage 514.
- stages to perform various functions to produce an output video stream 516 from the compressed bitstream 420 includes in one example the following stages to perform various functions to produce an output video stream 516 from the compressed bitstream 420: an entropy decoding stage 502, a dequantization stage 504, an inverse transform stage 506, an intra/inter prediction stage 508, a reconstruction stage 510, a loop filtering stage 512 and a post filtering stage 514.
- Other structural variations of the decoder 500 can be used to decode the compressed bitstream 420.
- the data elements within the compressed bitstream 420 can be decoded by the entropy decoding stage 502 to produce a set of quantized transform coefficients.
- the dequantization stage 504 dequantizes the quantized transform coefficients (e.g., by multiplying the quantized transform coefficients by the quantizer value), and the inverse transform stage 506 inverse transforms the dequantized transform coefficients to produce a derivative residual that can be identical to that created by the inverse transform stage 412 in the encoder 400.
- the decoder 500 can use the intra/inter prediction stage 508 to create the same prediction block as was created in the encoder 400, e.g., at the intra/inter prediction stage 402.
- the prediction block can be added to the derivative residual to create a reconstructed block.
- the loop filtering stage 512 can be applied to the reconstructed block to reduce blocking artifacts.
- the post filtering stage 514 can be a deblocking filter that is applied to the reconstructed block to reduce blocking distortion, and the result is output as the output video stream 516.
- the output video stream 516 can also be referred to as a decoded video stream, and the terms will be used interchangeably herein.
- Other variations of the decoder 500 can be used to decode the compressed bitstream 420.
- the decoder 500 can produce the output video stream 516 without the post filtering stage 514.
- FIG. 6 is a diagram of motion vectors representing full and sub-pixel motion according to implementations of this disclosure.
- several blocks 602, 604, 606, 608 of a current frame 600 are inter predicted using pixels from a reference frame 630.
- the reference frame 630 is a reference frame, also called the temporally adjacent frame, in a video sequence including the current frame 600, such as the video stream 300.
- the reference frame 630 is a reconstructed frame (i.e., one that has been encoded and decoded such as by the reconstruction path of FIG. 4 ) that has been stored in a so-called last reference frame buffer and is available for coding blocks of the current frame 600.
- Other (e.g., reconstructed) frames, or portions of such frames may also be available for inter prediction.
- Other available reference frames may include a golden frame, which is another frame of the video sequence that may be selected (e.g., periodically) according to any number of techniques, and a constructed reference frame, which is a frame that is constructed from one or more other frames of the video sequence but is not shown as part of the decoded output, such as the output video stream 516 of FIG. 5 .
- a prediction block 632 for encoding the block 602 corresponds to a motion vector 612.
- a prediction block 634 for encoding the block 604 corresponds to a motion vector 614.
- a prediction block 636 for encoding the block 606 corresponds to a motion vector 616.
- a prediction block 638 for encoding the block 608 corresponds to a motion vector 618.
- Each of the blocks 602, 604, 606, 608 is inter predicted using a single motion vector and hence a single reference frame in this example, but the teachings herein also apply to inter prediction using more than one motion vector (such as bi-prediction and/or compound prediction using two different reference frames), where pixels from each prediction are combined in some manner to form a prediction block.
- FIG. 7 is a diagram of a sub-pixel prediction block according to implementations of this disclosure.
- FIG. 7 includes the prediction block 632 and neighboring pixels of the prediction block 632 of the reference frame 630 of FIG. 6 .
- Integer pixels within the reference frame 630 are shown as unfilled circles.
- the integer pixels, in this example, represent reconstructed pixel values of the reference frame 630.
- the integer pixels are arranged in an array along x- and y-axes. Pixels forming the prediction block 632 are shown as filled circles.
- the prediction block 632 results from sub-pixel motion along two axes.
- Generating the prediction block 632 can require two interpolation operations. In some cases, generating a prediction block can require only one interpolation operation along one of x and y axes.
- the first and the second interpolation operations can be along the horizontal direction (i.e., along the x axis) and the vertical direction (i.e., along the y axis), respectively.
- the first and the second interpolation operations can be along the vertical direction (i.e., along the y axis) and the horizontal direction (i.e., along the x axis), respectively.
- the first and second interpolation operations can use a same interpolation filter type. Alternatively, the first and second interpolation operations can use different interpolation filter types.
- an interpolation process may be used.
- the interpolation process is performed using interpolation filters such as finite impulse response (FIR) filters.
- An interpolation filter may comprise a 6-tap filter, an 8-tap filter, or other size filters.
- the taps of an interpolation filter weight spatially neighboring pixels (integer or sub-pel pixels) with coefficient values to generate a sub-pixel value.
- the interpolation filters used to generate each sub-pixel value at different sub-pixel positions e.g., 1/2, 1/4, 1/8, or other sub-pixel positions
- between two pixels are different (i.e., have different coefficient values).
- FIG. 8 is a diagram of full and sub-pixel positions according to implementations of this disclosure.
- a 6-tap filter is used. This means that values for the sub-pixels or pixel positions 820, 822, 824 can be interpolated by applying an interpolation filter to the pixels 800-810. Only sub-pixel positions between the two pixels 804 and 806 are shown in FIG. 8 . However, sub-pixel values between the other full pixels of the line of pixels can be determined in a like manner. For example, a sub-pixel value between the two pixels 806 and 808 may be determined or generated by applying an interpolation filter to the pixels 802, 804, 806, 808, 810, and an integer pixel adjacent to the pixel 810, if available.
- the set of interpolation filters may be designed for 1/16-pixel precision and include at least two of a Bi-linear filter, an 8-tap filter (EIGHTTAP), a sharp 8-tap filter (EIGHTTAP_SHARP), or a smooth 8-tap filter (EIGHTTAP_SMOOTH).
- Each interpolation filter has a different frequency response.
- FIG. 9 is a flowchart diagram of a method or process 900 for encoding a current block of a video frame using inter prediction.
- the process 900 can be implemented, for example, as a software program that may be executed by computing devices such as transmitting station 102 or receiving station 106.
- the software program can include machine-readable instructions that may be stored in a memory such as the memory 204 or the secondary storage 214, and that, when executed by a processor, such as CPU 202, may cause the computing device to perform the process 900.
- the process 900 may be implemented in whole or in part in the entropy encoding stage 408 of the encoder 400.
- the process 900 can be implemented using specialized hardware or firmware. Multiple processors, memories, or both, may be used.
- the process 900 determines a motion vector for the current block.
- “determine” means to create, form, produce, select, construct, identify, specify, generate, receive, or other determine in any manner whatsoever.
- the process 900 can receive the motion vector for the current block as described with respect to the intra/inter prediction stage 402 of FIG. 4 .
- the process 900 can determine the reference frame at operation 902. Determining the reference frame for the current block may include selecting one reference frame of multiple available reference frames for predicting the current block.
- a reference frame buffer may store up to a defined number of available reference frames, such as four or eight reference frames.
- the reference frame buffer may store a LAST reference frame, corresponding to the last frame before the current frame in a video sequence, a GOLDEN reference frame, corresponding to an intra-predicted frame located before the current frame in the video sequence, and an alternate or alternative reference frame designated as ALTREF_FRAME.
- An alternative reference frame may be a frame of a video sequence that is distant from a current frame in a display order, but is encoded or decoded earlier than it is displayed.
- the alternative reference frame may be ten, twelve, or more (or fewer) frames after the current frame in a display order of the video sequence. Further alternative reference frames can be frames located nearer to the current frame in the display order.
- An alternative reference frame may not correspond directly to a frame in the sequence. Instead, the alternative reference frame may be generated using one or more frames having filtering applied, being combined together, or being both combined together and filtered. An alternative reference frame may not be displayed. Instead, the alternative frame can be a frame or portion of a frame generated and transmitted for use only for prediction (i.e., it is omitted when the decoded sequence is displayed).
- a reference frame buffer may be able to store additional or fewer reference frames.
- the available spaces may store a second last frame (i.e., the first frame before the last frame) and/or a third last frame (i.e., a frame two frames before the last frame) as additional forward prediction reference frames (e.g., in addition to the LAST and GOLDEN reference frames).
- a backward frame may be stored as an additional backward prediction reference frame (e.g., in addition to the ALTREF_FRAME reference frame).
- the terms LAST, GOLDEN, ALTREF_FRAME, etc. may be referred to as reference frame identifiers herein.
- the motion vector can be determined using a method of motion estimation, such as a motion search.
- a portion of a reference frame can be translated to a succession of locations to form respective prediction blocks that can be subtracted from the current block to form respective residuals.
- the horizontal and/or vertical translations corresponding to the location having, e.g., the smallest, residual can be selected as the motion vector.
- the prediction block that results in the best residual may not correspond with pixels (i.e., integer pixels) in the reference frame. That is, the best motion vector may point to a location that is between pixels of blocks in the reference frame.
- motion compensated prediction at the sub-pixel level is useful.
- Motion compensated prediction may involve the use of a sub-pixel interpolation filter that generates filtered sub-pixel values at defined locations between the full pixels (also called integer pixels) along rows, columns, or both.
- the interpolation filter may be one of a number of interpolation filters available for use in motion compensated prediction, where each of the interpolation filters has a different frequency profile (i.e., a different frequency response).
- the process 900 generates a transform block for the current block.
- the transform block refers to a quantized transform block. For example, as described with respect to the intra/inter prediction stage 402 of FIG. 4 , a prediction block corresponding to the motion vector and the reference frame is generated. The prediction block can then be transformed and quantized as described, respectively, with respect to the transform stage 404 and the quantization stage 406 of FIG. 4 .
- the process 900 determines a category of the transform block that correlates to an energy distribution in the residual block (as represented in the transform block).
- the energy distribution is information that can be used to determine or select a context for coding the motion vector that was used to generate the residual block. Using the energy distribution in this determination can result in a more accurate probability distribution for entropy coding the motion vector used to generate the residual block, improving compression performance. This accuracy is improved by combining the information for energy distribution with other information that can be used to determine or select a context.
- the transform block can be organized as a two-dimensional block.
- (x, y) denote a transform block position in the transform domain
- c(x, y) denote a transform coefficient at position (x, y).
- c(x, y) denotes a decoded transform coefficient at location (x, y).
- the transform coefficient at location (0, 0) may be referred to as the DC coefficient; a coefficient at any other location may be referred to as an AC coefficient.
- Different transform modes may result in different arrangements.
- a transform coefficient that has a positive or a negative value i.e., a value that is not zero
- a non-zero transform coefficient or more simply as a non-zero coefficient.
- Energy distribution in the residual block can be represented by the distribution of non-zero coefficients within the transform block (e.g., a quantized transform block). Accordingly, determining the category of the transform block that correlates to the energy distribution in the residual block can include determining the category of the transform block using locations of the non-zero coefficients within the transform block. Any number of categories may be available. For example, each category may represent a different energy distribution. Categories may be represented by the number of non-zero coefficients located in different partitions of the transform block. A transform block may be partitioned in any way to determine the categories. A transform block may be partitioned differently to determine the categories depending upon the transform type used to generate the transform block.
- Conditions may be attached to each of the categories so as to compare the positions of the non-zero coefficients of the current block to the conditions to determine a category for the current block.
- a transform block that has its largest number of non-zero coefficients located in a top-left quadrant has a different energy distribution than one that has is largest number of non-zero coefficients in a left-half of the transform block, or one that has its non-zero coefficients spread more evenly throughout the transform block.
- Determining a category of a transform block can include determining the block is in a first category where all non-zero coefficients of the block are located in the top-left quadrant of the block.
- Determining a category of a transform block can include determining the block is in a fourth category where a difference between the numbers of non-zero coefficients in adjacent halves of the block is below a threshold.
- categories, additional categories, or different categories may be available that define different energy distributions as reflected by different arrangements of the locations of non-zero coefficients to which locations of non-zero coefficients of the current block can be compared.
- the category is selected from a set that includes the categories DC_ONLY, AC_LOW, AC_HIGH_X, AC_HIGH_Y, and AC_HIGH.
- To "select from a set” means to select one of the possible values DC_ONLY, AC_LOW, AC_HIGH_X, AC_HIGH_Y, and AC_HIGH.
- the category can be used as contextual information to code the motion vector associated with the residual block. Specifically, coding of horizontal offset mv_x and/or the vertical offset mv_y may depend upon the category.
- the category can be used in combination with other readily available information (as described above) as contextual information to code the motion vector.
- Example semantics of the categories DC_ONLY, AC_LOW, AC_HIGH_X, AC_HIGH_Y, and AC_HIGH are described below. However, other semantics are also possible.
- the category AC_LOW can indicate that the transform block does not have non-zero coefficients at high frequency positions.
- an AC_LOW transform block there are no non-zero transform coefficients in columns that are greater than a horizontal threshold (i.e., T_x) and there are no non-zero transform coefficients in rows that are greater than a vertical threshold (i.e., T_y).
- T_x horizontal threshold
- T_y vertical threshold
- c(x, y) 0 if x > T_x or Y > T_y.
- the AC_LOW category can be roughly interpreted as there are non-zero coefficients only in the upper left portion of the transform block.
- the thresholds T_x and T_y are further described below.
- the AC_HIGH_X category can be roughly interpreted as there are non-zero coefficients in the top-right portion of the transform block but there are no non-zero transform coefficients in the lower half of the transform block.
- the AC_HIGH_Y category can be roughly interpreted as there are non-zero coefficients in the bottom-left portion of the transform block but there are no non-zero transform coefficients in the right half of the transform block.
- the AC_HIGH category can indicate that the transform block has a non-zero coefficient at some (x, y) where x > T_x and y > T_y.
- the AC_HIGH category can be roughly interpreted as there are non-zero coefficients in the bottom-right portion of the transform block.
- the horizontal threshold (i.e., T_x) and/or the vertical threshold (i.e., T_y) can be based on the size of the transform block.
- the category can be further based on a size of the transform block.
- the horizontal threshold, T_x can be related to the width of the transform block and the vertical threshold, T_y, can be related to the height of the transform block.
- the relationship can be a linear relationship.
- the horizontal threshold, T_x can be selected as half the width of the transform block.
- the vertical threshold, T_y can be selected as half the height of the transform block. Other linear relationships are possible.
- the horizontal threshold, T_x, and the vertical threshold, T_y can be based on the filter that is selected for sub-pixel interpolation. As the frequency response of the selected filter has a bearing on the distribution of the non-zero coefficients, the horizontal threshold, T_x, and the vertical threshold, T_y can be set based on the frequency response. That is, the threshold values can be designed (e.g., set, selected, etc.) to correspond to the statistics of the selected filter used to generate the sub-pixel reference block. For example, if the selected filter is a low-pass filter whose frequency response has a falling cliff at half of the full frequency band, then the horizontal threshold, T_x, can be set to half the width of the transform block. For example, if the filter has a narrower frequency response band that is closer to the DC position, then the horizontal and the vertical thresholds can have values that are closer to the DC position.
- the horizontal and vertical thresholds can be based on a linear relationship to the width and height of the transform block, respectively, as described above; and in a case of sub-pixel interpolation, the thresholds can be selected based on the selected interpolation filter (i.e., based on the response characteristics of the selected filter).
- the process 900 determines, using the category, a context for coding the motion vector.
- the context comprises a probability distribution used for entropy coding.
- the same context can be used to encode the horizontal offset (i.e., mv-x) and the vertical offset (i.e., mv_y) of the motion vector.
- Determining the context for coding the motion vector using the category may include using the category as an index (or to identify an index) for a table of probability distributions used for entropy coding. The index can then determine the context (and hence the probability distribution) for coding the motion vector.
- full-pixel and sub-pixel motion vectors can have different response characteristics in the frequency domain.
- the response characteristics can be reflected in the residual block and, equivalently, in the transform block.
- the correlation between the motion vector and the frequency domain characteristics can be used to encode the motion vector.
- the correlation can similarly be used in other direction. That is in some situations, the motion vector information can be used to encode the transform coefficients of the transform block.
- the category can be used alone or in combination with other information for determining the context.
- one or more of inter-prediction modes of neighboring blocks, motion vectors of motion blocks, the current block type (e.g., chrominance or luminance), and/or the current block size can be used in combination with the category as contextual information for determining the context.
- This contextual information can be combined with the category to determine the context. For example, determining the context for coding the motion vector using the category may include using the category and other values related to the current block (and optionally adjacent blocks) to identify an entry in one or more tables whose entries are probability distributions used for entropy coding.
- determining a context can include determining a context index.
- the context index can be used to retrieve a context model (e.g., a probability distribution) from a list of available context models.
- the combination of the values of the contextual information can map to an index value.
- One or more combination of values can map to the same index value. That is, one or more contextual information combinations can map to the same context model.
- the process 900 encodes the motion vector using the context.
- the motion vector can be encoded in a compressed bitstream, such as the compressed bitstream 420 of FIG. 4 .
- the same context can be used for encoding the horizontal offset (i.e., mv_x) and the vertical offset (mv_y) of the motion vector.
- a residual block (and, equivalently, a transform block) can be separately categorized according to its energy distribution in each of the horizontal dimension and the vertical dimension.
- determining the category at operation 906 can include determining a horizontal (or first) category of the transform block and determining a vertical category (or second) for the transform block.
- determining the context at operation 908 can include determining, using the horizontal category, a horizontal context for coding the horizontal offset of the motion vector; and determining, using the vertical category, a vertical context for coding the vertical offset of the motion vector.
- encoding the motion vector at operation 910 can include using the horizontal context for coding the horizontal offset of the motion vector and using the vertical context for coding the vertical offset of the motion vector.
- the horizontal category can be selected from a set that includes the categories DC_ONLY, AC_LOW_X, and AC_HIGH_X; and the vertical category can be selected from a set that includes the categories DC_ONLY, AC_LOW_Y, and AC_HIGH_Y.
- the horizontal category can be selected from a set that includes the categories AC_LOW_X and AC_HIGH_X; and the vertical category can be selected from a set that includes the categories AC_LOW_Y and AC_HIGH_Y.
- Using a smaller number of categories can reduce the number of contexts. Reducing the number of contexts can avoid the so-called context dilution problem.
- the contexts mentioned above can have the following semantics.
- the category AC_LOW_X can indicate that the transform block does not have non-zero coefficients at high frequency positions.
- an AC_LOW_X transform block there are no non-zero coefficients in columns that are greater than a horizontal threshold (i.e., T_x).
- T_x a horizontal threshold
- c(x, y) 0 if x > T_x.
- the AC_LOW_X category can be roughly interpreted as there are no non-zero coefficients in the right portion of the transform block.
- the category AC_HIGH_X can indicate that the transform block has at least one non-zero coefficient in column with large column numbers.
- an AC_HIGH_X transform block there is at least one non-zero coefficients in columns that are greater than a horizontal threshold (i.e., T_x).
- T_x a horizontal threshold
- c(x, y) ! 0 at some (x, y) where x > T_x.
- the AC_HIGH_X category can be roughly interpreted as there is at least one non-zero coefficient in the right portion of the transform block.
- the category AC_LOW_Y can indicate that the transform block does not have non-zero coefficients at high frequency positions.
- an AC_LOW_Y transform block there are no non-zero coefficients in rows that are greater than a vertical threshold (i.e., T_y).
- T_y a vertical threshold
- c(x, y) 0 if y > T_y.
- the AC_LOW_Y category can be roughly interpreted as there are no non-zero coefficients in the lower portion of the transform block.
- the category AC_HIGH_Y can indicate that the transform block has at least one non-zero coefficient in rows with large row numbers.
- an AC_HIGH_Y transform block there is at least one non-zero coefficients in rows that are greater than a vertical threshold (i.e., T_y).
- T_y a vertical threshold
- c(x, y) ! 0 at some (x, y) where y > T_y.
- the AC_HIGH_Y category can be roughly interpreted as there is at least one non-zero coefficient in the bottom portion of the transform block.
- the horizontal threshold (i.e., T_x) and the vertical threshold (i.e., T_y) can be as described above.
- more than one transform block may be associated with the current block. That is, the current block may be consumed by multiple transform blocks.
- a transform operation such as performed by the transform stage 404 of FIG. 4 , may perform a set of transforms of different sizes such that the current block is divided into (i.e., corresponds to) smaller transform blocks than the current block or such that the transform block is of the same size as the current block.
- a current block of size 8x8 may be consumed by four 4x4 transform blocks.
- Other current block sizes and transform block sizes are possible.
- a current block being consumed by multiple transform blocks indicates that the frequency component in the current block is high. When the frequency component is high, it is preferable to use smaller transform sizes (i.e., smaller in size than the current block).
- determining a transform block for the current block at operation 904 can mean selecting one of the transform blocks associated with the current block.
- any one of the transform blocks may be selected.
- the transform block with the highest AC component is selected.
- the transform block with the highest number of non-zero coefficients can be selected.
- a respective category is determined (such as described with respect to the operation 906) for each of the transform blocks. It is noted that the categories (as described above) may form a progression with respect to locations of non-zero coefficients in the transform block. For example, in the set of ⁇ DC_ONLY, AC_LOW_X, AC_HIGH_X ⁇ , an AC_LOW_X transform block includes more positions than a DC_ONLY transform block where non-zero coefficients may appear, and an AC_HIGH_X includes more positions than an AC_LOW_X block where non-zero coefficients may appear. As such, the transform block having the highest category (i.e., the highest number of non-zero transform coefficients) is selected.
- the progression can be given by DC_ONLY, AC_LOW, AC_HIGH_X, AC_HIGH_Y, and AC_HIGH such that the AC_HIGH is the highest category and DC_ONLY is the lowest category.
- the categories AC_HIGH_X and AC_HIGH_Y can be equal categories.
- a respective category may be determined for each of the transform blocks, and the category to be used in motion vector coding may be selected by using a voting process.
- An example voting process is as follows: each transform block casts one vote for its category; and the category that receives the most votes is selected.
- the vote casted by each transform block is weighted by a factor in proportion to the transform block size, and the category receives the most weighted votes is selected.
- the transform coefficients are used to encode the motion vector.
- the process 900 can encode (i.e., add, write, etc.) the transform coefficients into the compressed bitstream before the motion vector information.
- a decoder can decode the transform coefficients first in order to determine the category for the transform block. The decoder can use the category to decode the motion vector.
- the process 900 can encode the category in the compressed bitstream.
- the category can be encoded for all blocks or for some blocks. While, as described above, a correlation (e.g., a statistical correlation) exists between the residual block (and, equivalently, the transform block) and the motion vector, the correlation may not be exact (i.e., nondeterministic). In such situations, it can be useful to encode the category in order to improve the coding efficiency.
- a correlation e.g., a statistical correlation
- the residual block and, equivalently, the transform block
- the motion vector the correlation may not be exact (i.e., nondeterministic). In such situations, it can be useful to encode the category in order to improve the coding efficiency.
- the encoding of the category can depend on the transform coefficients. For example, the number of non-zero coefficients in the transform block can be used to determine a context for coding the category. For example, the transform type can be used to determine the context for coding the category. Conditioning the encoding of the category on the transform coefficients can limit the cost (i.e., in bits) associated with the encoding of the category.
- a codec can use multiple transform types.
- a transform type can be the transform type used by the transform stage 404 of FIG. 4 to generate the transform block.
- the transform type i.e., an inverse transform type
- Available transform types can include a one-dimensional (1D) Discrete Cosine Transform (DCT) or its approximation, ID Discrete Sine Transform (DST) or its approximation, a two-dimensional (2D) DCT or its approximation, 2D DST or its approximation, and an identity transform.
- DCT Discrete Cosine Transform
- DST Discrete Sine Transform
- 2D DCT two-dimensional
- 2D DST two-dimensional
- an identity transform can be available.
- Other transform types can be available.
- a one-dimensional transform (1D DCT or 1D DST) can be applied in one dimension (e.g., row or column) and the identity transform applied in the other dimension.
- FIG. 10 is a flowchart diagram of a method or process 1000 for decoding a current block of a video frame using inter prediction.
- the process 1000 can be used to decode a motion vector used for inter predicting the current block.
- the motion vector includes a horizontal offset (i.e., mv_x) and a vertical offset (i.e., mv_y).
- the process 1000 can be implemented, for example, as a software program that may be executed by computing devices such as transmitting station 102 or receiving station 106.
- the software program can include machine-readable instructions that may be stored in a memory such as the memory 204 or the secondary storage 214, and that, when executed by a processor, such as CPU 202, may cause the computing device to perform the process 900.
- the process 1000 may be implemented in whole or in part in the entropy decoding stage 502 of the decoder 500.
- the process 1000 can be implemented using specialized hardware or firmware. Multiple processors, memories, or both, may be used.
- the process 1000 decodes a transform block for the current block. For example, using a scan order, the process 1000 can decode transform coefficients from an encoded bitstream, such as the compressed bitstream 420 of FIG. 5 . As used herein, the transform coefficients can be quantized transform coefficients. The process 1000 can decode transform coefficients until an end-of-block syntax element is decoded or until all the transform coefficients of the transform block have been decoded, whichever comes first. In the case that the end-of-block syntax element is decoded, then the process 1000 can set all remaining transform coefficients of the transform block to zero.
- any number of methods can be used to decode the transform coefficients so long as the encoder that generated the compressed bitstream and the decoder use the same method.
- a binary token tree can be used to code the transform coefficients.
- an alphabet of non-binary symbols can be used to code the transform blocks.
- one or more syntax elements can be coded for a transform coefficient based on the magnitude of the transform coefficient.
- the process 1000 determines a category for the transform block.
- the category can be determined as described with respect to operation 906 of FIG. 9 .
- the category can be determined based on positions of non-zero coefficients in the transform block.
- the category can be based on the size of the transform block.
- the category can be based on the positions of non-zero coefficients in the transform block and the size of the transform block.
- determining the category can mean decoding the category from the compressed bitstream.
- the transform coefficients decoded at operation 902 can be used to decode the category.
- the category can be selected from a set that includes the categories DC_ONLY, AC_LOW, AC_HIGH_X, AC_HIGH_Y, and AC_HIGH.
- the process 1000 determines a context for decoding the motion vector using the category.
- the context can be determined as similarly described with respect to 908 of FIG. 9 .
- the process 1000 decodes the motion vector using the context.
- the context can be used to decode the horizontal offset (i.e., mv_x) and the vertical offset (i.e., mv_y) of the motion vector.
- the process 1000 can inter-predict the current block as described, for example, with respect to the intra/inter prediction stage 508 of FIG. 5 .
- a residual block (and, equivalently, a transform block) can be separately categorized according to its energy distribution in each of the horizontal dimension and the vertical dimension.
- determining the category at operation 1004 can include determining a horizontal category of the transform block and determining a vertical category for the transform block.
- determining the context at operation 1006 can include determining, using the horizontal category, a horizontal context for coding the horizontal offset of the motion vector; and determining, using the vertical category, a vertical context for coding the vertical offset of the motion vector.
- decoding the motion vector at operation 1008 can include using the horizontal context for coding the horizontal offset of the motion vector and using the vertical context for coding the vertical offset of the motion vector.
- the horizontal category is selected from a set that includes the categories DC_ONLY, AC_LOW_X, and AC_HIGH_X
- the vertical category is selected from a set that includes the categories DC_ONLY, AC_LOW_Y, and AC_HIGH_Y.
- the horizontal category is selected from a set that includes the categories AC_LOW_X and AC_HIGH_X
- the vertical category is selected from a set that includes the categories AC_LOW_Y and AC_HIGH_Y.
- determining the category of the transform block includes determining a first category for a first transform block for the current block, determining a second category for a second transform block for the current block, and selecting the one of the first category and the second category corresponding to a higher category relative to the progression described above. That is, the categories may have a progression or ranking that is based on the number of positions where a non-zero transform coefficient can appear in a transform block. The ranking may start with the category associated with the lowest number of positions and progressing to the category associated with the highest number of positions.
- a category may be determined for each of the transform blocks, and only one of the determined categories is the category for the current block.
- the selection is whichever of the first category or the second category is associated with the higher number of positions available for non-zero coefficients. In effect, this can be a selection of the category for whichever of the transform blocks has a higher number of non-zero transform coefficients.
- encoding and decoding illustrate some examples of encoding and decoding techniques. However, it is to be understood that encoding and decoding, as those terms are used in the claims, could mean compression, decompression, transformation, or any other processing or change of data.
- example is used herein to mean serving as an example, instance, or illustration. Any aspect or design described herein as “example” is not necessarily to be construed as preferred or advantageous over other aspects or designs. Rather, use of the word “example” is intended to present concepts in a concrete fashion.
- the term “or” is intended to mean an inclusive “or” rather than an exclusive “or”. That is, unless specified otherwise, or clear from context, "X includes A or B” is intended to mean any of the natural inclusive permutations. That is, if X includes A; X includes B; or X includes both A and B, then "X includes A or B" is satisfied under any of the foregoing instances.
- Implementations of the transmitting station 102 and/or the receiving station 106 can be realized in hardware, software, or any combination thereof.
- the hardware can include, for example, computers, intellectual property (IP) cores, application-specific integrated circuits (ASICs), programmable logic arrays, optical processors, programmable logic controllers, microcode, microcontrollers, servers, microprocessors, digital signal processors or any other suitable circuit.
- IP intellectual property
- ASICs application-specific integrated circuits
- programmable logic arrays optical processors
- programmable logic controllers programmable logic controllers
- microcode microcontrollers
- servers microprocessors, digital signal processors or any other suitable circuit.
- signal processors digital signal processors or any other suitable circuit.
- the transmitting station 102 or the receiving station 106 can be implemented using a general purpose computer or general purpose processor with a computer program that, when executed, carries out any of the respective methods, algorithms and/or instructions described herein.
- a special purpose computer/processor can be utilized that contains other hardware for carrying out any of the methods, algorithms, or instructions described herein.
- the transmitting station 102 and the receiving station 106 can, for example, be implemented on computers in a video conferencing system.
- the transmitting station 102 can be implemented on a server and the receiving station 106 can be implemented on a device separate from the server, such as a hand-held communications device.
- the transmitting station 102 can encode content using an encoder 400 into an encoded video signal and transmit the encoded video signal to the communications device.
- the communications device can then decode the encoded video signal using a decoder 500.
- the communications device can decode content stored locally on the communications device, for example, content that was not transmitted by the transmitting station 102.
- the receiving station 106 can be a generally stationary personal computer rather than a portable communications device and/or a device including an encoder 400 may also include a decoder 500.
- implementations of the present disclosure can take the form of a computer program product accessible from, for example, a computer-usable or computer-readable medium.
- a computer-usable or computer-readable medium can be any device that can, for example, tangibly contain, store, communicate, or transport the program for use by or in connection with any processor.
- the medium can be, for example, an electronic, magnetic, optical, electromagnetic, or a semiconductor device. Other suitable mediums are also available.
Description
- Digital video streams may represent video using a sequence of frames or still images. Digital video can be used for various applications including, for example, video conferencing, high definition video entertainment, video advertisements, or sharing of user-generated videos. A digital video stream can contain a large amount of data and consume a significant amount of computing or communication resources of a computing device for processing, transmission or storage of the video data. Various approaches have been proposed to reduce the amount of data in video streams, including compression and other encoding techniques.
- One technique for compression uses a reference frame and a motion vector to generate a prediction block corresponding to a current block to be encoded. Differences between the prediction block and the current block can be encoded, instead of the values of the current block themselves, to reduce the amount of data encoded.
EP2661088A1 describes an encoding device.WO2013103863A1 describes techniques related to identifying when motion vector difference (MVD) is skipped for one or both reference picture lists. MARPE D ET AL, "Further Results for CABAC Entropy Coding Scheme", 13. VCEG MEETING; 02-04-2001 - 04-04-2001 presents experimental results relating to context-based adaptive binary arithmetic coding (CABAC). - This disclosure relates generally to encoding and decoding video data and more particularly relates to improved coding of motion vectors.
- A method for encoding described herein includes determining a motion vector for inter predicting a current block, inter predicting the current block using the motion vector to determine a residual block, determining, using the residual block, a transform block of transform coefficients for the current block, determining a category of the transform block that correlates to an energy distribution in the residual block, determining, using the category, a context for coding the motion vector, and encoding the motion vector using the context. The category can be determined using positions of non-zero coefficients of the transform coefficients, and the category is one of a plurality of categories, each category of the plurality of categories defined by a different energy distribution. The context includes a probability distribution used for entropy coding the motion vector.
- An apparatus for encoding includes a non-transitory storage medium or memory and a processor. According to an aspect described herein, the memory includes instructions executable by the processor to determine a motion vector for inter predicting a current block, inter predict the current block using the motion vector to determine a residual block, determine, using the residual block, a transform block for the current block, determine, using positions of non-zero coefficients of the transform block and a size of the transform block, a category of the transform block that correlates to an energy distribution in the residual block, the category being one of a plurality of categories, and each category of the plurality of categories defined by a different energy distribution, determine, using the category, a context for encoding the motion vector, and encode, in a compressed bitstream, the motion vector using the context. The context may include a probability distribution used for entropy coding the motion vector.
- An aspect of an apparatus for decoding described herein includes a non-transitory storage medium or memory and a processor. The memory includes instructions executable by the processor decode, from an encoded bitstream, a transform block for a current block, the transform block corresponding to a residual block for the current block, determine, using positions of non-zero coefficients of the transform block, a category of the transform block that correlates to an energy distribution in the residual block, the category being one of a plurality of categories, and each category of the plurality of categories defined by a different energy distribution, determine, using the category, a context for decoding a motion vector used for encoding the current block, and decode, from the encoded bitstream, the motion vector using the context.
- A method for decoding according to an aspect of the teachings herein includes decoding, from an encoded bitstream, a transform block for a current block, the transform block corresponding to a residual block for the current block, determining, using positions of non-zero coefficients of the transform block, a category of the transform block that correlates to an energy distribution in the residual block, the category being one of a plurality of categories, and each category of the plurality of categories defined by a different energy distribution, determining, using the category, a context for decoding a motion vector used for encoding the current block, decoding, from the encoded bitstream, the motion vector using the context, and reconstructing the current block using the motion vector.
- These and other aspects of the present disclosure are disclosed in the following detailed description of the embodiments, the appended claims and the accompanying figures.
- The description herein makes reference to the accompanying drawings described below wherein like reference numerals refer to like parts throughout the several views unless otherwise noted.
-
FIG. 1 is a schematic of a video encoding and decoding system. -
FIG. 2 is a block diagram of an example of a computing device that can implement a transmitting station or a receiving station. -
FIG. 3 is a diagram of an example of a video stream to be encoded and subsequently decoded. -
FIG. 4 is a block diagram of an encoder according to implementations of this disclosure. -
FIG. 5 is a block diagram of a decoder according to implementations of this disclosure. -
FIG. 6 is a diagram of motion vectors representing full and sub-pixel motion according to implementations of this disclosure. -
FIG. 7 is a diagram of a sub-pixel prediction block according to implementations of this disclosure. -
FIG. 8 is a diagram of full and sub-pixel positions according to implementations of this disclosure. -
FIG. 9 is a flowchart diagram of a process for encoding a current block of a video frame using inter prediction according to an implementation of this disclosure. -
FIG. 10 is a flowchart diagram of a process for decoding a current block of a video frame using inter prediction according to an implementation of this disclosure. - A video stream can be compressed by a variety of techniques to reduce the bandwidth required to transmit or store the video stream. A video stream can be encoded into a bitstream (i.e., a compressed bitstream), which involves compression. The compressed bitstream can then be transmitted to a decoder that can decode or decompress the compressed bitstream to prepare it for viewing or further processing. Compression of the video stream often exploits spatial and temporal correlation of video signals through spatial and/or motion-compensated prediction. Motion-compensated prediction may also be referred to as inter prediction. Inter prediction uses one or more motion vectors to generate a block (also called a prediction block) that resembles a current block to be encoded using previously encoded and decoded pixels. By encoding the motion vector(s), and the difference between the two blocks (i.e., the current block and the prediction block), a decoder receiving the encoded signal can re-create the current block. The difference between the two blocks is referred to herein as the residual or the residual block.
- Coding the residual block, as further described below, can include generating one or more transform blocks for the residual block. A transform block can include zero and non-zero transform coefficients. The transform coefficients are then encoded into the compressed bitstream. The residual block is typically in the pixel domain. A transform block is typically in the frequency domain.
- Each motion vector used to generate a prediction block in the inter-prediction process refers to a frame (i.e., a reference frame) other than a current frame. Reference frames can be located before or after the current frame in the sequence (i.e., the display order) of the video stream, and may be frames that are reconstructed before being used as reference frames. A forward reference frame is a frame used for forward prediction relative to the sequence, while a backward reference frame is a frame used for backward prediction relative to the sequence. One or more forward and/or backward reference frames can be used to encode or decode a block. The efficacy of a reference frame when used to encode or decode a block (i.e., a current block) within a current frame can be measured based on a resulting signal-to-noise ratio or other measure of rate-distortion.
- The motion vector(s) for a current block in motion-compensated prediction may be encoded into, and decoded from, the encoded bitstream. A motion vector for a current block (i.e., a block being encoded) is described with respect to a co-located block in a reference frame. The motion vector describes an offset (i.e., a displacement) in the horizontal direction (i.e., mv_x) and a displacement in the vertical direction (i.e., mv_y) from the co-located block in the reference frame. As such, a motion vector can be characterized as a 3-tuple (f, mv_x, mv_y) where f is indicative of (e.g., is an index of) a reference frame, mv_x is the offset in the horizontal direction, and mv_y is the offset in the vertical direction. As such, at least the offsets mv_x and mv_y are written (i.e., encoded) into the encoded bitstream and read (i.e., decoded) from the encoded bitstream.
- To lower the rate cost of encoding the motion vectors, a motion vector may be encoded differentially. Namely, a motion vector is selected as a reference motion vector, and only a difference between the motion vector and the reference motion vector (also called the motion vector difference) is encoded into the bitstream. The reference motion vector may be a motion vector of one of the neighboring blocks, for example. The neighboring blocks can include spatial neighboring blocks (i.e., blocks in the same current frame as the current block). The neighboring blocks can include temporal neighboring blocks (i.e., blocks in frames other than the current frame).
- In some situations, the prediction block that results in the best residual may not correspond with pixels in the reference frame. That is, the best motion vector may point to a location that is between pixels of blocks in the reference frame. In this case, motion compensated prediction at the sub-pixel level is useful. Motion compensated prediction may involve the use of a sub-pixel interpolation filter that generates filtered sub-pixel values at defined locations between the full pixels (also called integer pixels) along rows, columns, or both. The interpolation filter may be one of a number of interpolation filters available for use in motion compensated prediction. Sub-pixel interpolation is further described below with respect to
FIGS. 6-8 . - Different interpolation filters may be available. Each of the interpolation filters may be designed to provide a different frequency response. In an example, the available interpolation filters may include a smooth filter, a normal filter, a sharp filter, and a bilinear filter. The interpolation filter to be used by a decoder to generate a prediction block may be signaled in the header of the frame containing the block to be predicted. As such, the same interpolation filter is used to generate sub-pixel prediction blocks for all blocks of the frame. The interpolation filter may also be signaled at a coding unit level. As such, the same interpolation filter is used for every block (e.g., every prediction block) of the coding unit to generate sub-pixel prediction blocks for the blocks of the coding unit. An encoder may generate a prediction block based on each of the available interpolation filters. The encoder then selects (i.e., to signal to the decoder) the filter that results in, e.g., the best rate-distortion ratio. A rate-distortion ratio refers to a ratio that balances an amount of distortion (i.e., loss in video quality) with rate (i.e., the number of bits) required for encoding.
- Coding a motion vector as used herein refers to the coding of the motion vector and to the differential coding of a motion vector. In either case, coding a motion vector includes coding the horizontal offset (i.e., mv_x) and coding the vertical offset (i.e., mv_y) of the motion vector. When implemented by an encoder, "coding" means encoding in an encoded bitstream. When implemented by a decoder, "coding" means decoding from an encoded bitstream.
- Coding the motion vector can include entropy coding the horizontal offset and the vertical offsets of the motion vector. As such, a context is determined for the motion vector and a probability model, corresponding to the context, is used for the coding the motion vector.
- Entropy coding is a technique for "lossless" coding that relies upon probability models that model the distribution of values occurring in an encoded video bitstream. By using probability models based on a measured or estimated distribution of values, entropy coding can reduce the number of bits required to represent video data close to a theoretical minimum. In practice, the actual reduction in the number of bits required to represent video data can be a function of the accuracy of the probability model, the number of bits over which the coding is performed, and the computational accuracy of fixed-point arithmetic used to perform the coding.
- A purpose of context modeling is to obtain probability distributions for a subsequent entropy coding engine, such as arithmetic coding, Huffman coding, and other variable-length-to-variable-length coding engines. To achieve good compression performance, a large number of contexts may be required. For example, some video coding systems can include hundreds or even thousands of contexts for transform coefficient coding alone. Each context can correspond to a probability distribution.
- A probability distribution can be learnt by a decoder and/or included in the header of a frame to be decoded.
- Learnt can mean that an entropy coding engine of a decoder can adapt the probability distributions (i.e., probability models) of a context model based on decoded frames and/or decoded blocks. For example, the decoder can have available an initial probability distribution that the decoder (e.g., the entropy coding engine of the decoder) can continuously update as the decoder decodes additional frames. The updating of the probability models can insure that the initial probability distribution is updated to reflect the actual distributions in the decoded frames.
- Including a probability distribution in the header can instruct the decoder to use the included probability distribution for decoding the next frame, given the corresponding context. A cost (in bits) is associated with including each probability distribution in the header. For example, in a coding system that includes 3000 contexts and that encodes a probability distribution (coded as an integer value between 1 and 255) using 8 bits, 24,000 bits are added to the encoded bitstream. These bits are overhead bits. Some techniques can be used to reduce the number of overhead bits. For example, the probability distributions for some, but not all, of the contexts can be included. For example, prediction schemes can also be used to reduce the overhead bits. Even with these overhead reduction techniques, the overhead is non-zero.
- The efficiency of entropy coding can be directly related to the probability model. A model, as used herein, can be, or can be a parameter in, a lossless (entropy) coding. A model can be any parameter or method that affects probability estimation for entropy coding.
- To avoid dependencies and complexities in the decoding of motion vectors, codecs may limit the information used (i.e., as context) to code motion vectors. The information can be limited to readily available information. For example, as reconstructed pixel values (further described below) are not readily available, they are not used as contextual information for selecting a probability model for coding motion vectors. Additionally, as the entropy decoder is typically much faster than any other processing in a video decoder, conditioning the entropy decoder on reconstructed pixels may result in significant performance degradation of the entropy decoder.
- As such, it is typically desirable to condition the decoding (and, thus, encoding) a motion vector on, for example, the readily available inter-prediction modes and motion vectors of previously decoded blocks. The previously decoded blocks can be blocks in the spatial neighborhood and/or the temporal neighborhood of the current block being encoded. For example, in the case where blocks of a current frame are coded in raster scan order, the spatial neighborhood can include the top (i.e., above) and left neighboring blocks of the current block in the current frame. For example, the temporal neighborhood can include co-located blocks in previously coded frames (i.e., reference frames).
- Several inter-prediction modes may be available. For example, one available inter-prediction mode represents that the motion vector of a block is 0. This may be referred to as a ZEROMV mode. Another inter-prediction mode may represent that the motion vector of the block is the reference motion vector. This may be referred to as a REFMV mode. When the motion vector for the block is not zero, and is different from the reference motion vector, the motion vector may be encoded using the reference motion vector. This mode may be referred to as a NEWMV mode herein. Other inter-prediction modes may be available.
- The readily available information used for coding a motion vector can also include whether the current block is a luminance or chrominance block and the block size.
- As mentioned above, filters having different frequency responses can be used to generate a motion vector at sub-pixel positions. Accordingly, and due to the use of these filters, reference blocks at different sub-pixel positions may have different characteristics in the transform domain. For example, a reference block at a sub-pixel position generated by a low-pass filter is likely to have lower energy in a high frequency band than a reference block at a full-pixel position. Since a residual block is the difference between a source block and a reference block, the energy distribution in the residual block is thus correlated with that of a reference block.
- The efficiency of entropy coding can be directly related to the probability model, which is in turn selected based on the context model. From information theory, the entropy H(X) can be a measure of the number of bits required to code the variable X; and the conditional entropy H(X|Y) can be a measure of the number of bits required to code the variable X given that the quantity Y is known. H(X) and H(X|Y) are related by the well-known property H(X|Y) ≤ H(X). That is, the conditional entropy H(X|Y) can never exceed H(X). If X represents the motion vector and Y represents the energy distribution information contained in a transform block (e.g., or, equivalently, the residual), it follows that coding of the motion vector (i.e., X) may be improved by using the energy distribution information (i.e., Y). For example, the energy distribution information contained in the transform block can be used as additional context information for coding the motion vector.
- Implementations according to this disclosure use the energy distribution information available in a transform block to code motion vectors associated with the residual block. Using the energy distribution information available in the transform block can improve compression performance. Details of improved coding of motion vectors are described herein with initial reference to a system in which the teachings herein can be implemented.
-
FIG. 1 is a schematic of a video encoding anddecoding system 100. A transmittingstation 102 can be, for example, a computer having an internal configuration of hardware such as that described inFIG. 2 . However, other suitable implementations of the transmittingstation 102 are possible. For example, the processing of the transmittingstation 102 can be distributed among multiple devices. - A
network 104 can connect the transmittingstation 102 and a receivingstation 106 for encoding and decoding of the video stream. Specifically, the video stream can be encoded in the transmittingstation 102 and the encoded video stream can be decoded in the receivingstation 106. Thenetwork 104 can be, for example, the Internet. Thenetwork 104 can also be a local area network (LAN), wide area network (WAN), virtual private network (VPN), cellular telephone network or any other means of transferring the video stream from the transmittingstation 102 to, in this example, the receivingstation 106. - The receiving
station 106, in one example, can be a computer having an internal configuration of hardware such as that described inFIG. 2 . However, other suitable implementations of the receivingstation 106 are possible. For example, the processing of the receivingstation 106 can be distributed among multiple devices. - Other implementations of the video encoding and
decoding system 100 are possible. For example, an implementation can omit thenetwork 104. In another implementation, a video stream can be encoded and then stored for transmission at a later time to the receivingstation 106 or any other device having a non-transitory storage medium or memory. In one implementation, the receivingstation 106 receives (e.g., via thenetwork 104, a computer bus, and/or some communication pathway) the encoded video stream and stores the video stream for later decoding. In an example implementation, a real-time transport protocol (RTP) is used for transmission of the encoded video over thenetwork 104. In another implementation, a transport protocol other than RTP may be used, e.g., a Hypertext Transfer Protocol (HTTP) based video streaming protocol. - When used in a video conferencing system, for example, the transmitting
station 102 and/or the receivingstation 106 may include the ability to both encode and decode a video stream as described below. For example, the receivingstation 106 could be a video conference participant who receives an encoded video bitstream from a video conference server (e.g., the transmitting station 102) to decode and view and further encodes and transmits its own video bitstream to the video conference server for decoding and viewing by other participants. -
FIG. 2 is a block diagram of an example of acomputing device 200 that can implement a transmitting station or a receiving station. For example, thecomputing device 200 can implement one or both of the transmittingstation 102 and the receivingstation 106 ofFIG. 1 . Thecomputing device 200 can be in the form of a computing system including multiple computing devices, or in the form of one computing device, for example, a mobile phone, a tablet computer, a laptop computer, a notebook computer, a desktop computer, and the like. - A
CPU 202 in thecomputing device 200 can be a central processing unit. Alternatively, theCPU 202 can be any other type of device, or multiple devices, capable of manipulating or processing information now-existing or hereafter developed. Although the disclosed implementations can be practiced with one processor as shown, e.g., theCPU 202, advantages in speed and efficiency can be achieved using more than one processor. - A
memory 204 incomputing device 200 can be a read only memory (ROM) device or a random access memory (RAM) device in an implementation. Any other suitable type of storage device or non-transitory storage medium can be used as thememory 204. Thememory 204 can include code anddata 206 that is accessed by theCPU 202 using abus 212. Thememory 204 can further include anoperating system 208 andapplication programs 210, theapplication programs 210 including at least one program that permits theCPU 202 to perform the methods described here. For example, theapplication programs 210 can includeapplications 1 through N, which further include a video coding application that performs the methods described here.Computing device 200 can also include asecondary storage 214, which can, for example, be a memory card used with a mobile computing device. Because the video communication sessions may contain a significant amount of information, they can be stored in whole or in part in thesecondary storage 214 and loaded into thememory 204 as needed for processing. - The
computing device 200 can also include one or more output devices, such as adisplay 218. Thedisplay 218 may be, in one example, a touch sensitive display that combines a display with a touch sensitive element that is operable to sense touch inputs. Thedisplay 218 can be coupled to theCPU 202 via thebus 212. Other output devices that permit a user to program or otherwise use thecomputing device 200 can be provided in addition to or as an alternative to thedisplay 218. When the output device is or includes a display, the display can be implemented in various ways, including by a liquid crystal display (LCD), a cathode-ray tube (CRT) display or light emitting diode (LED) display, such as an organic LED (OLED) display. - The
computing device 200 can also include or be in communication with an image-sensingdevice 220, for example a camera, or any other image-sensingdevice 220 now existing or hereafter developed that can sense an image such as the image of a user operating thecomputing device 200. The image-sensingdevice 220 can be positioned such that it is directed toward the user operating thecomputing device 200. In an example, the position and optical axis of the image-sensingdevice 220 can be configured such that the field of vision includes an area that is directly adjacent to thedisplay 218 and from which thedisplay 218 is visible. - The
computing device 200 can also include or be in communication with a sound-sensing device 222, for example a microphone, or any other sound-sensing device now existing or hereafter developed that can sense sounds near thecomputing device 200. The sound-sensing device 222 can be positioned such that it is directed toward the user operating thecomputing device 200 and can be configured to receive sounds, for example, speech or other utterances, made by the user while the user operates thecomputing device 200. - Although
FIG. 2 depicts theCPU 202 and thememory 204 of thecomputing device 200 as being integrated into one unit, other configurations can be utilized. The operations of theCPU 202 can be distributed across multiple machines (wherein individual machines can have one or more of processors) that can be coupled directly or across a local area or other network. Thememory 204 can be distributed across multiple machines such as a network-based memory or memory in multiple machines performing the operations of thecomputing device 200. Although depicted here as one bus, thebus 212 of thecomputing device 200 can be composed of multiple buses. Further, thesecondary storage 214 can be directly coupled to the other components of thecomputing device 200 or can be accessed via a network and can comprise an integrated unit such as a memory card or multiple units such as multiple memory cards. Thecomputing device 200 can thus be implemented in a wide variety of configurations. -
FIG. 3 is a diagram of an example of avideo stream 300 to be encoded and subsequently decoded. Thevideo stream 300 includes avideo sequence 302. At the next level, thevideo sequence 302 includes a number ofadjacent frames 304. While three frames are depicted as theadjacent frames 304, thevideo sequence 302 can include any number ofadjacent frames 304. Theadjacent frames 304 can then be further subdivided into individual frames, e.g., aframe 306. At the next level, theframe 306 can be divided into a series of planes orsegments 308. Thesegments 308 can be subsets of frames that permit parallel processing, for example. Thesegments 308 can also be subsets of frames that can separate the video data into separate colors. For example, aframe 306 of color video data can include a luminance plane and two chrominance planes. Thesegments 308 may be sampled at different resolutions. - Whether or not the
frame 306 is divided intosegments 308, theframe 306 may be further subdivided intoblocks 310, which can contain data corresponding to, for example, 16×16 pixels in theframe 306. Theblocks 310 can also be arranged to include data from one ormore segments 308 of pixel data. Theblocks 310 can also be of any other suitable size such as 4x4 pixels, 8x8 pixels, 16x8 pixels, 8x16 pixels, 16x16 pixels, or larger. Unless otherwise noted, the terms block and macroblock are used interchangeably herein. -
FIG. 4 is a block diagram of anencoder 400 according to implementations of this disclosure. Theencoder 400 can be implemented, as described above, in the transmittingstation 102 such as by providing a computer software program stored in memory, for example, thememory 204. The computer software program can include machine instructions that, when executed by a processor such as theCPU 202, cause the transmittingstation 102 to encode video data in the manner described inFIG. 4 . Theencoder 400 can also be implemented as specialized hardware included in, for example, the transmittingstation 102. Theencoder 400 may be a hardware encoder. - The
encoder 400 has the following stages to perform the various functions in a forward path (shown by the solid connection lines) to produce an encoded orcompressed bitstream 420 using thevideo stream 300 as input: an intra/inter prediction stage 402, atransform stage 404, aquantization stage 406, and anentropy encoding stage 408. Theencoder 400 may also include a reconstruction path (shown by the dotted connection lines) to reconstruct a frame for encoding of future blocks. InFIG. 4 , theencoder 400 has the following stages to perform the various functions in the reconstruction path: adequantization stage 410, aninverse transform stage 412, areconstruction stage 414, and aloop filtering stage 416. Other structural variations of theencoder 400 can be used to encode thevideo stream 300. - When the
video stream 300 is presented for encoding,respective frames 304, such as theframe 306, can be processed in units of blocks. At the intra/inter prediction stage 402, respective blocks can be encoded using intra-frame prediction (also called intra-prediction) or inter-frame prediction (also called inter-prediction). In any case, a prediction block can be formed. In the case of intra-prediction, a prediction block may be formed from samples in the current frame that have been previously encoded and reconstructed. In the case of inter-prediction, a prediction block may be formed from samples in one or more previously constructed reference frames. - Next, still referring to
FIG. 4 , the prediction block can be subtracted from the current block at the intra/inter prediction stage 402 to produce a residual block (also called a residual). Thetransform stage 404 transforms the residual into transform coefficients in, for example, the frequency domain using block-based transforms. Thequantization stage 406 converts the transform coefficients into discrete quantum values, which are referred to as quantized transform coefficients, using a quantizer value or a quantization level. For example, the transform coefficients may be divided by the quantizer value and truncated. The quantized transform coefficients are then entropy encoded by theentropy encoding stage 408. The entropy-encoded coefficients, together with other information used to decode the block, which may include for example the type of prediction used, transform type, motion vectors and quantizer value, are then output to thecompressed bitstream 420. Thecompressed bitstream 420 can be formatted using various techniques, such as variable length coding (VLC) or arithmetic coding. Thecompressed bitstream 420 can also be referred to as an encoded video stream or encoded video bitstream, and the terms will be used interchangeably herein. - The reconstruction path in
FIG. 4 (shown by the dotted connection lines) can be used to ensure that theencoder 400 and a decoder 500 (described below) use the same reference frames to decode thecompressed bitstream 420. The reconstruction path performs functions that are similar to functions that take place during the decoding process that are discussed in more detail below, including dequantizing the quantized transform coefficients at thedequantization stage 410 and inverse transforming the dequantized transform coefficients at theinverse transform stage 412 to produce a derivative residual block (also called a derivative residual). At thereconstruction stage 414, the prediction block that was predicted at the intra/inter prediction stage 402 can be added to the derivative residual to create a reconstructed block. Theloop filtering stage 416 can be applied to the reconstructed block to reduce distortion such as blocking artifacts. - Other variations of the
encoder 400 can be used to encode thecompressed bitstream 420. For example, a non-transform based encoder can quantize the residual signal directly without thetransform stage 404 for certain blocks or frames. In another implementation, an encoder can have thequantization stage 406 and thedequantization stage 410 combined in a common stage. -
FIG. 5 is a block diagram of adecoder 500 according to implementations of this disclosure. Thedecoder 500 can be implemented in the receivingstation 106, for example, by providing a computer software program stored in thememory 204. The computer software program can include machine instructions that, when executed by a processor such as theCPU 202, cause the receivingstation 106 to decode video data in the manner described herein. Thedecoder 500 can also be implemented in hardware included in, for example, the transmittingstation 102 or the receivingstation 106. Thedecoder 500 may be a hardware decoder. - The
decoder 500, similar to the reconstruction path of theencoder 400 discussed above, includes in one example the following stages to perform various functions to produce anoutput video stream 516 from the compressed bitstream 420: anentropy decoding stage 502, adequantization stage 504, aninverse transform stage 506, an intra/inter prediction stage 508, areconstruction stage 510, aloop filtering stage 512 and apost filtering stage 514. Other structural variations of thedecoder 500 can be used to decode thecompressed bitstream 420. - When the
compressed bitstream 420 is presented for decoding, the data elements within thecompressed bitstream 420 can be decoded by theentropy decoding stage 502 to produce a set of quantized transform coefficients. Thedequantization stage 504 dequantizes the quantized transform coefficients (e.g., by multiplying the quantized transform coefficients by the quantizer value), and theinverse transform stage 506 inverse transforms the dequantized transform coefficients to produce a derivative residual that can be identical to that created by theinverse transform stage 412 in theencoder 400. Using header information decoded from thecompressed bitstream 420, thedecoder 500 can use the intra/inter prediction stage 508 to create the same prediction block as was created in theencoder 400, e.g., at the intra/inter prediction stage 402. At thereconstruction stage 510, the prediction block can be added to the derivative residual to create a reconstructed block. Theloop filtering stage 512 can be applied to the reconstructed block to reduce blocking artifacts. - Other filtering can be applied to the reconstructed block. In this example, the
post filtering stage 514 can be a deblocking filter that is applied to the reconstructed block to reduce blocking distortion, and the result is output as theoutput video stream 516. Theoutput video stream 516 can also be referred to as a decoded video stream, and the terms will be used interchangeably herein. Other variations of thedecoder 500 can be used to decode thecompressed bitstream 420. For example, thedecoder 500 can produce theoutput video stream 516 without thepost filtering stage 514. -
FIG. 6 is a diagram of motion vectors representing full and sub-pixel motion according to implementations of this disclosure. InFIG. 6 ,several blocks current frame 600 are inter predicted using pixels from areference frame 630. In this example, thereference frame 630 is a reference frame, also called the temporally adjacent frame, in a video sequence including thecurrent frame 600, such as thevideo stream 300. Thereference frame 630 is a reconstructed frame (i.e., one that has been encoded and decoded such as by the reconstruction path ofFIG. 4 ) that has been stored in a so-called last reference frame buffer and is available for coding blocks of thecurrent frame 600. Other (e.g., reconstructed) frames, or portions of such frames may also be available for inter prediction. Other available reference frames may include a golden frame, which is another frame of the video sequence that may be selected (e.g., periodically) according to any number of techniques, and a constructed reference frame, which is a frame that is constructed from one or more other frames of the video sequence but is not shown as part of the decoded output, such as theoutput video stream 516 ofFIG. 5 . - A
prediction block 632 for encoding theblock 602 corresponds to amotion vector 612. Aprediction block 634 for encoding theblock 604 corresponds to amotion vector 614. Aprediction block 636 for encoding theblock 606 corresponds to amotion vector 616. Finally, aprediction block 638 for encoding theblock 608 corresponds to amotion vector 618. Each of theblocks -
FIG. 7 is a diagram of a sub-pixel prediction block according to implementations of this disclosure.FIG. 7 includes theprediction block 632 and neighboring pixels of theprediction block 632 of thereference frame 630 ofFIG. 6 . Integer pixels within thereference frame 630 are shown as unfilled circles. The integer pixels, in this example, represent reconstructed pixel values of thereference frame 630. The integer pixels are arranged in an array along x- and y-axes. Pixels forming theprediction block 632 are shown as filled circles. Theprediction block 632 results from sub-pixel motion along two axes. - Generating the
prediction block 632 can require two interpolation operations. In some cases, generating a prediction block can require only one interpolation operation along one of x and y axes. A first interpolation operation to generate intermediate pixels followed by a second interpolation operation to generate the pixels of the prediction block from the intermediate pixels. The first and the second interpolation operations can be along the horizontal direction (i.e., along the x axis) and the vertical direction (i.e., along the y axis), respectively. Alternatively, the first and the second interpolation operations can be along the vertical direction (i.e., along the y axis) and the horizontal direction (i.e., along the x axis), respectively. The first and second interpolation operations can use a same interpolation filter type. Alternatively, the first and second interpolation operations can use different interpolation filter types. - In order to produce pixel values for the sub-pixels of the
prediction block 632, an interpolation process may be used. In one example, the interpolation process is performed using interpolation filters such as finite impulse response (FIR) filters. An interpolation filter may comprise a 6-tap filter, an 8-tap filter, or other size filters. The taps of an interpolation filter weight spatially neighboring pixels (integer or sub-pel pixels) with coefficient values to generate a sub-pixel value. In general, the interpolation filters used to generate each sub-pixel value at different sub-pixel positions (e.g., 1/2, 1/4, 1/8, or other sub-pixel positions) between two pixels are different (i.e., have different coefficient values). -
FIG. 8 is a diagram of full and sub-pixel positions according to implementations of this disclosure. In the example ofFIG. 8 , a 6-tap filter is used. This means that values for the sub-pixels orpixel positions pixels FIG. 8 . However, sub-pixel values between the other full pixels of the line of pixels can be determined in a like manner. For example, a sub-pixel value between the twopixels pixels pixel 810, if available. - Using different coefficient values in an interpolation filter, regardless of its size, results in different characteristics of filtering and hence different compression performance. In some implementations, the set of interpolation filters may be designed for 1/16-pixel precision and include at least two of a Bi-linear filter, an 8-tap filter (EIGHTTAP), a sharp 8-tap filter (EIGHTTAP_SHARP), or a smooth 8-tap filter (EIGHTTAP_SMOOTH). Each interpolation filter has a different frequency response.
-
FIG. 9 is a flowchart diagram of a method orprocess 900 for encoding a current block of a video frame using inter prediction. Theprocess 900 can be implemented, for example, as a software program that may be executed by computing devices such as transmittingstation 102 or receivingstation 106. The software program can include machine-readable instructions that may be stored in a memory such as thememory 204 or thesecondary storage 214, and that, when executed by a processor, such asCPU 202, may cause the computing device to perform theprocess 900. Theprocess 900 may be implemented in whole or in part in theentropy encoding stage 408 of theencoder 400. Theprocess 900 can be implemented using specialized hardware or firmware. Multiple processors, memories, or both, may be used. - At
operation 902, theprocess 900 determines a motion vector for the current block. As used in this disclosure, "determine" means to create, form, produce, select, construct, identify, specify, generate, receive, or other determine in any manner whatsoever. For example, theprocess 900 can receive the motion vector for the current block as described with respect to the intra/inter prediction stage 402 ofFIG. 4 . - The
process 900 can determine the reference frame atoperation 902. Determining the reference frame for the current block may include selecting one reference frame of multiple available reference frames for predicting the current block. In some implementations, a reference frame buffer may store up to a defined number of available reference frames, such as four or eight reference frames. As one example, the reference frame buffer may store a LAST reference frame, corresponding to the last frame before the current frame in a video sequence, a GOLDEN reference frame, corresponding to an intra-predicted frame located before the current frame in the video sequence, and an alternate or alternative reference frame designated as ALTREF_FRAME. An alternative reference frame may be a frame of a video sequence that is distant from a current frame in a display order, but is encoded or decoded earlier than it is displayed. For example, the alternative reference frame may be ten, twelve, or more (or fewer) frames after the current frame in a display order of the video sequence. Further alternative reference frames can be frames located nearer to the current frame in the display order. - An alternative reference frame may not correspond directly to a frame in the sequence. Instead, the alternative reference frame may be generated using one or more frames having filtering applied, being combined together, or being both combined together and filtered. An alternative reference frame may not be displayed. Instead, the alternative frame can be a frame or portion of a frame generated and transmitted for use only for prediction (i.e., it is omitted when the decoded sequence is displayed).
- A reference frame buffer may be able to store additional or fewer reference frames. For example, the available spaces may store a second last frame (i.e., the first frame before the last frame) and/or a third last frame (i.e., a frame two frames before the last frame) as additional forward prediction reference frames (e.g., in addition to the LAST and GOLDEN reference frames). In some examples, a backward frame may be stored as an additional backward prediction reference frame (e.g., in addition to the ALTREF_FRAME reference frame). The terms LAST, GOLDEN, ALTREF_FRAME, etc., may be referred to as reference frame identifiers herein.
- The motion vector can be determined using a method of motion estimation, such as a motion search. In the motion search, a portion of a reference frame can be translated to a succession of locations to form respective prediction blocks that can be subtracted from the current block to form respective residuals. The horizontal and/or vertical translations corresponding to the location having, e.g., the smallest, residual can be selected as the motion vector.
- As indicated above, the prediction block that results in the best residual may not correspond with pixels (i.e., integer pixels) in the reference frame. That is, the best motion vector may point to a location that is between pixels of blocks in the reference frame. In this case, motion compensated prediction at the sub-pixel level is useful. Motion compensated prediction may involve the use of a sub-pixel interpolation filter that generates filtered sub-pixel values at defined locations between the full pixels (also called integer pixels) along rows, columns, or both. The interpolation filter may be one of a number of interpolation filters available for use in motion compensated prediction, where each of the interpolation filters has a different frequency profile (i.e., a different frequency response).
- At
operation 904, theprocess 900 generates a transform block for the current block. The transform block, as used herein, refers to a quantized transform block. For example, as described with respect to the intra/inter prediction stage 402 ofFIG. 4 , a prediction block corresponding to the motion vector and the reference frame is generated. The prediction block can then be transformed and quantized as described, respectively, with respect to thetransform stage 404 and thequantization stage 406 ofFIG. 4 . - At
operation 906, theprocess 900 determines a category of the transform block that correlates to an energy distribution in the residual block (as represented in the transform block). As described previously, the energy distribution is information that can be used to determine or select a context for coding the motion vector that was used to generate the residual block. Using the energy distribution in this determination can result in a more accurate probability distribution for entropy coding the motion vector used to generate the residual block, improving compression performance. This accuracy is improved by combining the information for energy distribution with other information that can be used to determine or select a context. - The transform block can be organized as a two-dimensional block. Let (x, y) denote a transform block position in the transform domain, and let c(x, y) denote a transform coefficient at position (x, y). It is noted that in the case of a decoder (such as described with respect to
FIG. 10 ), c(x, y) denotes a decoded transform coefficient at location (x, y). By example, the transform coefficient at location (0, 0) may be referred to as the DC coefficient; a coefficient at any other location may be referred to as an AC coefficient. Different transform modes may result in different arrangements. In any event, a transform coefficient that has a positive or a negative value (i.e., a value that is not zero) is referred to as a non-zero transform coefficient, or more simply as a non-zero coefficient. - Energy distribution in the residual block can be represented by the distribution of non-zero coefficients within the transform block (e.g., a quantized transform block). Accordingly, determining the category of the transform block that correlates to the energy distribution in the residual block can include determining the category of the transform block using locations of the non-zero coefficients within the transform block. Any number of categories may be available. For example, each category may represent a different energy distribution. Categories may be represented by the number of non-zero coefficients located in different partitions of the transform block. A transform block may be partitioned in any way to determine the categories. A transform block may be partitioned differently to determine the categories depending upon the transform type used to generate the transform block.
- Conditions may be attached to each of the categories so as to compare the positions of the non-zero coefficients of the current block to the conditions to determine a category for the current block. For example, a transform block that has its largest number of non-zero coefficients located in a top-left quadrant has a different energy distribution than one that has is largest number of non-zero coefficients in a left-half of the transform block, or one that has its non-zero coefficients spread more evenly throughout the transform block. Determining a category of a transform block can include determining the block is in a first category where all non-zero coefficients of the block are located in the top-left quadrant of the block. Determining a category of a transform block can include determining the block is in a second category where the majority of the non-zero coefficients of the block are in the top-left quadrant of the block and a majority of the remaining non-zero coefficients of the block are in the top-right quadrant. Determining a category of a transform block can include determining the block is in a third category where the majority of the non-zero coefficients of the block are in the top-left quadrant of the block and a majority of the remaining non-zero coefficients of the block are in the bottom-left quadrant. Determining a category of a transform block can include determining the block is in a fourth category where a difference between the numbers of non-zero coefficients in adjacent halves of the block is below a threshold. These categories, additional categories, or different categories may be available that define different energy distributions as reflected by different arrangements of the locations of non-zero coefficients to which locations of non-zero coefficients of the current block can be compared.
- In an example, the category is selected from a set that includes the categories DC_ONLY, AC_LOW, AC_HIGH_X, AC_HIGH_Y, and AC_HIGH. To "select from a set" means to select one of the possible values DC_ONLY, AC_LOW, AC_HIGH_X, AC_HIGH_Y, and AC_HIGH. The category can be used as contextual information to code the motion vector associated with the residual block. Specifically, coding of horizontal offset mv_x and/or the vertical offset mv_y may depend upon the category. For example, the category can be used in combination with other readily available information (as described above) as contextual information to code the motion vector. Example semantics of the categories DC_ONLY, AC_LOW, AC_HIGH_X, AC_HIGH_Y, and AC_HIGH are described below. However, other semantics are also possible.
- The category DC_ONLY can indicate that the transform block does not have non-zero AC coefficients. That is, the only non-zero coefficient of the transform is the DC coefficient (i.e., the coefficient at location (0, 0)). As such, in a DC_ONLY transform block, c(x, y) = 0 if x ≠ 0 or y ≠ 0.
- The category AC_LOW can indicate that the transform block does not have non-zero coefficients at high frequency positions. In an AC_LOW transform block, there are no non-zero transform coefficients in columns that are greater than a horizontal threshold (i.e., T_x) and there are no non-zero transform coefficients in rows that are greater than a vertical threshold (i.e., T_y). As such, in an AC_LOW transform block, c(x, y) = 0 if x > T_x or Y > T_y. The AC_LOW category can be roughly interpreted as there are non-zero coefficients only in the upper left portion of the transform block. The thresholds T_x and T_y are further described below.
- The category AC_HIGH_X can indicate that the residual block does not have non-zero coefficients in row numbers that are greater than a threshold (i.e., T_y) and has at least one non-zero coefficient in at least one column that is larger than a threshold (i.e., T_x). That is, c(x, y) = 0 if y > T_y, and c(x, y) != 0 at some (x, y) where x > T_x. The AC_HIGH_X category can be roughly interpreted as there are non-zero coefficients in the top-right portion of the transform block but there are no non-zero transform coefficients in the lower half of the transform block.
- The category AC_HIGH_Y can indicate that the residual block does not have non-zero coefficients in column numbers that are greater than a threshold (i.e., T_x) and has at least one non-zero coefficient in at least one row that is larger than a threshold (i.e., T_y). That is, c(x, y) = 0 if x > T_x, and c(x, y) != 0 at some (x, y) where y > T_y. The AC_HIGH_Y category can be roughly interpreted as there are non-zero coefficients in the bottom-left portion of the transform block but there are no non-zero transform coefficients in the right half of the transform block.
- The AC_HIGH category can indicate that the transform block has a non-zero coefficient at some (x, y) where x > T_x and y > T_y. The AC_HIGH category can be roughly interpreted as there are non-zero coefficients in the bottom-right portion of the transform block.
- In an example, the horizontal threshold (i.e., T_x) and/or the vertical threshold (i.e., T_y) can be based on the size of the transform block. As such, the category can be further based on a size of the transform block. For example, the horizontal threshold, T_x, can be related to the width of the transform block and the vertical threshold, T_y, can be related to the height of the transform block. The relationship can be a linear relationship. For example, the horizontal threshold, T_x, can be selected as half the width of the transform block. For example, the vertical threshold, T_y, can be selected as half the height of the transform block. Other linear relationships are possible.
- The horizontal threshold, T_x, and the vertical threshold, T_y, can be based on the filter that is selected for sub-pixel interpolation. As the frequency response of the selected filter has a bearing on the distribution of the non-zero coefficients, the horizontal threshold, T_x, and the vertical threshold, T_y can be set based on the frequency response. That is, the threshold values can be designed (e.g., set, selected, etc.) to correspond to the statistics of the selected filter used to generate the sub-pixel reference block. For example, if the selected filter is a low-pass filter whose frequency response has a falling cliff at half of the full frequency band, then the horizontal threshold, T_x, can be set to half the width of the transform block. For example, if the filter has a narrower frequency response band that is closer to the DC position, then the horizontal and the vertical thresholds can have values that are closer to the DC position.
- In an example, in a case where the prediction block is based on full pixel positions, the horizontal and vertical thresholds can be based on a linear relationship to the width and height of the transform block, respectively, as described above; and in a case of sub-pixel interpolation, the thresholds can be selected based on the selected interpolation filter (i.e., based on the response characteristics of the selected filter).
- At
operation 908, theprocess 900 determines, using the category, a context for coding the motion vector. The context comprises a probability distribution used for entropy coding. In an implementation, the same context can be used to encode the horizontal offset (i.e., mv-x) and the vertical offset (i.e., mv_y) of the motion vector. Determining the context for coding the motion vector using the category may include using the category as an index (or to identify an index) for a table of probability distributions used for entropy coding. The index can then determine the context (and hence the probability distribution) for coding the motion vector. - As mentioned above, full-pixel and sub-pixel motion vectors can have different response characteristics in the frequency domain. The response characteristics can be reflected in the residual block and, equivalently, in the transform block. As such, the correlation between the motion vector and the frequency domain characteristics can be used to encode the motion vector. The correlation can similarly be used in other direction. That is in some situations, the motion vector information can be used to encode the transform coefficients of the transform block.
- The category can be used alone or in combination with other information for determining the context. As described above, one or more of inter-prediction modes of neighboring blocks, motion vectors of motion blocks, the current block type (e.g., chrominance or luminance), and/or the current block size can be used in combination with the category as contextual information for determining the context. This contextual information can be combined with the category to determine the context. For example, determining the context for coding the motion vector using the category may include using the category and other values related to the current block (and optionally adjacent blocks) to identify an entry in one or more tables whose entries are probability distributions used for entropy coding.
- In an implementation, determining a context can include determining a context index. The context index can be used to retrieve a context model (e.g., a probability distribution) from a list of available context models. The combination of the values of the contextual information can map to an index value. One or more combination of values can map to the same index value. That is, one or more contextual information combinations can map to the same context model.
- At
operation 910, theprocess 900 encodes the motion vector using the context. The motion vector can be encoded in a compressed bitstream, such as thecompressed bitstream 420 ofFIG. 4 . In an implementation, the same context can be used for encoding the horizontal offset (i.e., mv_x) and the vertical offset (mv_y) of the motion vector. - In an implementation, a residual block (and, equivalently, a transform block) can be separately categorized according to its energy distribution in each of the horizontal dimension and the vertical dimension. As such, determining the category at
operation 906 can include determining a horizontal (or first) category of the transform block and determining a vertical category (or second) for the transform block. Accordingly, determining the context atoperation 908 can include determining, using the horizontal category, a horizontal context for coding the horizontal offset of the motion vector; and determining, using the vertical category, a vertical context for coding the vertical offset of the motion vector. Accordingly, encoding the motion vector atoperation 910 can include using the horizontal context for coding the horizontal offset of the motion vector and using the vertical context for coding the vertical offset of the motion vector. - In an implementation, the horizontal category can be selected from a set that includes the categories DC_ONLY, AC_LOW_X, and AC_HIGH_X; and the vertical category can be selected from a set that includes the categories DC_ONLY, AC_LOW_Y, and AC_HIGH_Y.
- In another implementation, the horizontal category can be selected from a set that includes the categories AC_LOW_X and AC_HIGH_X; and the vertical category can be selected from a set that includes the categories AC_LOW_Y and AC_HIGH_Y. Using a smaller number of categories can reduce the number of contexts. Reducing the number of contexts can avoid the so-called context dilution problem. The contexts mentioned above can have the following semantics.
- The category DC_ONLY can indicate, as described above, that the transform block does not have non-zero AC coefficients. That is, the only non-zero coefficient of the transform is the DC coefficient (i.e., the coefficient at location (0, 0)). As such, in a DC_ONLY transform block, c(x, y) = 0 if x != 0 or y != 0.
- The category AC_LOW_X can indicate that the transform block does not have non-zero coefficients at high frequency positions. In an AC_LOW_X transform block, there are no non-zero coefficients in columns that are greater than a horizontal threshold (i.e., T_x). As such, in an AC_LOW_X transform block, c(x, y) = 0 if x > T_x. The AC_LOW_X category can be roughly interpreted as there are no non-zero coefficients in the right portion of the transform block.
- The category AC_HIGH_X can indicate that the transform block has at least one non-zero coefficient in column with large column numbers. In an AC_HIGH_X transform block, there is at least one non-zero coefficients in columns that are greater than a horizontal threshold (i.e., T_x). As such, in an AC_HIGH_X transform block, c(x, y) != 0 at some (x, y) where x > T_x. The AC_HIGH_X category can be roughly interpreted as there is at least one non-zero coefficient in the right portion of the transform block.
- The category AC_LOW_Y can indicate that the transform block does not have non-zero coefficients at high frequency positions. In an AC_LOW_Y transform block, there are no non-zero coefficients in rows that are greater than a vertical threshold (i.e., T_y). As such, in an AC_LOW_Y transform block, c(x, y) = 0 if y > T_y. The AC_LOW_Y category can be roughly interpreted as there are no non-zero coefficients in the lower portion of the transform block.
- The category AC_HIGH_Y can indicate that the transform block has at least one non-zero coefficient in rows with large row numbers. In an AC_HIGH_Y transform block, there is at least one non-zero coefficients in rows that are greater than a vertical threshold (i.e., T_y). As such, in an AC_HIGH_Y transform block, c(x, y) != 0 at some (x, y) where y > T_y. The AC_HIGH_Y category can be roughly interpreted as there is at least one non-zero coefficient in the bottom portion of the transform block.
- The horizontal threshold (i.e., T_x) and the vertical threshold (i.e., T_y) can be as described above.
- Referring again to the
operation 904. In some situations, more than one transform block may be associated with the current block. That is, the current block may be consumed by multiple transform blocks. For example, a transform operation, such as performed by thetransform stage 404 ofFIG. 4 , may perform a set of transforms of different sizes such that the current block is divided into (i.e., corresponds to) smaller transform blocks than the current block or such that the transform block is of the same size as the current block. For example, a current block of size 8x8 may be consumed by four 4x4 transform blocks. Other current block sizes and transform block sizes are possible. A current block being consumed by multiple transform blocks indicates that the frequency component in the current block is high. When the frequency component is high, it is preferable to use smaller transform sizes (i.e., smaller in size than the current block). - In the case where multiple transform blocks correspond to the current block, determining a transform block for the current block at
operation 904, can mean selecting one of the transform blocks associated with the current block. - In an implementation, any one of the transform blocks may be selected. In another implementation, the transform block with the highest AC component is selected. For example, the transform block with the highest number of non-zero coefficients can be selected.
- In yet another implementation, a respective category is determined (such as described with respect to the operation 906) for each of the transform blocks. It is noted that the categories (as described above) may form a progression with respect to locations of non-zero coefficients in the transform block. For example, in the set of {DC_ONLY, AC_LOW_X, AC_HIGH_X}, an AC_LOW_X transform block includes more positions than a DC_ONLY transform block where non-zero coefficients may appear, and an AC_HIGH_X includes more positions than an AC_LOW_X block where non-zero coefficients may appear. As such, the transform block having the highest category (i.e., the highest number of non-zero transform coefficients) is selected. In the set of categories {DC_ONLY, AC_LOW, AC_HIGH_X, AC_HIGH_Y, AC_HIGH}, the progression can be given by DC_ONLY, AC_LOW, AC_HIGH_X, AC_HIGH_Y, and AC_HIGH such that the AC_HIGH is the highest category and DC_ONLY is the lowest category. The categories AC_HIGH_X and AC_HIGH_Y can be equal categories.
- A respective category may be determined for each of the transform blocks, and the category to be used in motion vector coding may be selected by using a voting process. An example voting process is as follows: each transform block casts one vote for its category; and the category that receives the most votes is selected. In another example, the vote casted by each transform block is weighted by a factor in proportion to the transform block size, and the category receives the most weighted votes is selected.
- As described above, the transform coefficients (i.e., information in the transform block) are used to encode the motion vector. As such, the
process 900 can encode (i.e., add, write, etc.) the transform coefficients into the compressed bitstream before the motion vector information. In this way, a decoder can decode the transform coefficients first in order to determine the category for the transform block. The decoder can use the category to decode the motion vector. - The
process 900 can encode the category in the compressed bitstream. The category can be encoded for all blocks or for some blocks. While, as described above, a correlation (e.g., a statistical correlation) exists between the residual block (and, equivalently, the transform block) and the motion vector, the correlation may not be exact (i.e., nondeterministic). In such situations, it can be useful to encode the category in order to improve the coding efficiency. - The encoding of the category can depend on the transform coefficients. For example, the number of non-zero coefficients in the transform block can be used to determine a context for coding the category. For example, the transform type can be used to determine the context for coding the category. Conditioning the encoding of the category on the transform coefficients can limit the cost (i.e., in bits) associated with the encoding of the category.
- A codec can use multiple transform types. A transform type can be the transform type used by the
transform stage 404 ofFIG. 4 to generate the transform block. For example, the transform type (i.e., an inverse transform type) can be the transform type to be used by thedequantization stage 504 ofFIG. 5 . Available transform types can include a one-dimensional (1D) Discrete Cosine Transform (DCT) or its approximation, ID Discrete Sine Transform (DST) or its approximation, a two-dimensional (2D) DCT or its approximation, 2D DST or its approximation, and an identity transform. Other transform types can be available. In an example, a one-dimensional transform (1D DCT or 1D DST) can be applied in one dimension (e.g., row or column) and the identity transform applied in the other dimension. -
FIG. 10 is a flowchart diagram of a method orprocess 1000 for decoding a current block of a video frame using inter prediction. Theprocess 1000 can be used to decode a motion vector used for inter predicting the current block. The motion vector includes a horizontal offset (i.e., mv_x) and a vertical offset (i.e., mv_y). Theprocess 1000 can be implemented, for example, as a software program that may be executed by computing devices such as transmittingstation 102 or receivingstation 106. The software program can include machine-readable instructions that may be stored in a memory such as thememory 204 or thesecondary storage 214, and that, when executed by a processor, such asCPU 202, may cause the computing device to perform theprocess 900. Theprocess 1000 may be implemented in whole or in part in theentropy decoding stage 502 of thedecoder 500. Theprocess 1000 can be implemented using specialized hardware or firmware. Multiple processors, memories, or both, may be used. - At
operation 1002, theprocess 1000 decodes a transform block for the current block. For example, using a scan order, theprocess 1000 can decode transform coefficients from an encoded bitstream, such as thecompressed bitstream 420 ofFIG. 5 . As used herein, the transform coefficients can be quantized transform coefficients. Theprocess 1000 can decode transform coefficients until an end-of-block syntax element is decoded or until all the transform coefficients of the transform block have been decoded, whichever comes first. In the case that the end-of-block syntax element is decoded, then theprocess 1000 can set all remaining transform coefficients of the transform block to zero. - Any number of methods can be used to decode the transform coefficients so long as the encoder that generated the compressed bitstream and the decoder use the same method. For example, a binary token tree can be used to code the transform coefficients. For example, an alphabet of non-binary symbols can be used to code the transform blocks. For example, one or more syntax elements can be coded for a transform coefficient based on the magnitude of the transform coefficient.
- At
operation 1004, theprocess 1000 determines a category for the transform block. In an implementation, the category can be determined as described with respect tooperation 906 ofFIG. 9 . In an example, the category can be determined based on positions of non-zero coefficients in the transform block. In an example, the category can be based on the size of the transform block. In an example, the category can be based on the positions of non-zero coefficients in the transform block and the size of the transform block. - In an implementation, and as similarly described with respect to the
process 900, determining the category can mean decoding the category from the compressed bitstream. The transform coefficients decoded atoperation 902 can be used to decode the category. - As described with respect to
FIG. 9 , the category can be selected from a set that includes the categories DC_ONLY, AC_LOW, AC_HIGH_X, AC_HIGH_Y, and AC_HIGH. - At
operation 1006, theprocess 1000 determines a context for decoding the motion vector using the category. The context can be determined as similarly described with respect to 908 ofFIG. 9 . - At
operation 1008, theprocess 1000 decodes the motion vector using the context. In an implementation, the context can be used to decode the horizontal offset (i.e., mv_x) and the vertical offset (i.e., mv_y) of the motion vector. Atoperation 1010, theprocess 1000 can inter-predict the current block as described, for example, with respect to the intra/inter prediction stage 508 ofFIG. 5 . - In an implementation, a residual block (and, equivalently, a transform block) can be separately categorized according to its energy distribution in each of the horizontal dimension and the vertical dimension. As such, determining the category at
operation 1004 can include determining a horizontal category of the transform block and determining a vertical category for the transform block. Accordingly, determining the context atoperation 1006 can include determining, using the horizontal category, a horizontal context for coding the horizontal offset of the motion vector; and determining, using the vertical category, a vertical context for coding the vertical offset of the motion vector. Accordingly, decoding the motion vector atoperation 1008 can include using the horizontal context for coding the horizontal offset of the motion vector and using the vertical context for coding the vertical offset of the motion vector. - In an implementation, the horizontal category is selected from a set that includes the categories DC_ONLY, AC_LOW_X, and AC_HIGH_X, and the vertical category is selected from a set that includes the categories DC_ONLY, AC_LOW_Y, and AC_HIGH_Y.
- In an implementation, the horizontal category is selected from a set that includes the categories AC_LOW_X and AC_HIGH_X, and the vertical category is selected from a set that includes the categories AC_LOW_Y and AC_HIGH_Y.
- As described above, in some situations, a current block may be consumed by multiple transform blocks. As such, in an implementation, determining the category of the transform block includes determining a first category for a first transform block for the current block, determining a second category for a second transform block for the current block, and selecting the one of the first category and the second category corresponding to a higher category relative to the progression described above. That is, the categories may have a progression or ranking that is based on the number of positions where a non-zero transform coefficient can appear in a transform block. The ranking may start with the category associated with the lowest number of positions and progressing to the category associated with the highest number of positions. Where more than one transform block is used to code a current prediction block, a category may be determined for each of the transform blocks, and only one of the determined categories is the category for the current block. In this example, the selection is whichever of the first category or the second category is associated with the higher number of positions available for non-zero coefficients. In effect, this can be a selection of the category for whichever of the transform blocks has a higher number of non-zero transform coefficients.
- For simplicity of explanation, the
processes - The aspects of encoding and decoding described above illustrate some examples of encoding and decoding techniques. However, it is to be understood that encoding and decoding, as those terms are used in the claims, could mean compression, decompression, transformation, or any other processing or change of data.
- The word "example" is used herein to mean serving as an example, instance, or illustration. Any aspect or design described herein as "example" is not necessarily to be construed as preferred or advantageous over other aspects or designs. Rather, use of the word "example" is intended to present concepts in a concrete fashion. As used in this application, the term "or" is intended to mean an inclusive "or" rather than an exclusive "or". That is, unless specified otherwise, or clear from context, "X includes A or B" is intended to mean any of the natural inclusive permutations. That is, if X includes A; X includes B; or X includes both A and B, then "X includes A or B" is satisfied under any of the foregoing instances. In addition, the articles "a" and "an" as used in this application and the appended claims should generally be construed to mean "one or more" unless specified otherwise or clear from context to be directed to a singular form. Moreover, use of the term "an implementation" or "one implementation" throughout is not intended to mean the same embodiment or implementation unless described as such.
- Implementations of the transmitting
station 102 and/or the receiving station 106 (and the algorithms, methods, instructions, etc., stored thereon and/or executed thereby, including by theencoder 400 and the decoder 500) can be realized in hardware, software, or any combination thereof. The hardware can include, for example, computers, intellectual property (IP) cores, application-specific integrated circuits (ASICs), programmable logic arrays, optical processors, programmable logic controllers, microcode, microcontrollers, servers, microprocessors, digital signal processors or any other suitable circuit. In the claims, the term "processor" should be understood as encompassing any of the foregoing hardware, either singly or in combination. The terms "signal" and "data" are used interchangeably. Further, portions of the transmittingstation 102 and the receivingstation 106 do not necessarily have to be implemented in the same manner. - Further, in one aspect, for example, the transmitting
station 102 or the receivingstation 106 can be implemented using a general purpose computer or general purpose processor with a computer program that, when executed, carries out any of the respective methods, algorithms and/or instructions described herein. In addition, or alternatively, for example, a special purpose computer/processor can be utilized that contains other hardware for carrying out any of the methods, algorithms, or instructions described herein. - The transmitting
station 102 and the receivingstation 106 can, for example, be implemented on computers in a video conferencing system. Alternatively, the transmittingstation 102 can be implemented on a server and the receivingstation 106 can be implemented on a device separate from the server, such as a hand-held communications device. In this instance, the transmittingstation 102 can encode content using anencoder 400 into an encoded video signal and transmit the encoded video signal to the communications device. In turn, the communications device can then decode the encoded video signal using adecoder 500. Alternatively, the communications device can decode content stored locally on the communications device, for example, content that was not transmitted by the transmittingstation 102. Other suitable transmitting and receiving implementation schemes are available. For example, the receivingstation 106 can be a generally stationary personal computer rather than a portable communications device and/or a device including anencoder 400 may also include adecoder 500. - Further, all or a portion of implementations of the present disclosure can take the form of a computer program product accessible from, for example, a computer-usable or computer-readable medium. A computer-usable or computer-readable medium can be any device that can, for example, tangibly contain, store, communicate, or transport the program for use by or in connection with any processor. The medium can be, for example, an electronic, magnetic, optical, electromagnetic, or a semiconductor device. Other suitable mediums are also available.
- The above-described embodiments, implementations and aspects have been described in order to allow easy understanding of the present invention and do not limit the present invention.
Claims (14)
- A method for encoding, comprising:determining a motion vector for inter predicting a current block;inter predicting the current block using the motion vector to determine a residual block;determining, using the residual block, a transform block of transform coefficients for the current block;determining, using positions of non-zero coefficients of the transform coefficients, a category of the transform block that correlates to an energy distribution in the residual block, the category being one of a plurality of categories, and each category of the plurality of categories defined by a different energy distribution;determining, using the category, a context for coding the motion vector, the context comprising a probability distribution used for entropy coding the motion vector; andencoding the motion vector using the context.
- The method of claim 1, wherein the category is further determined based on a size of the transform block.
- The method of claim 1 or 2, wherein the category is selected from a set consisting of DC_ONLY, AC_LOW, AC_HIGH_X, AC_HIGH_Y, and AC_HIGH, and wherein:a DC_ONLY category transform block is a transform block in which the only non-zero coefficient is at location (0, 0),an AC_LOW category transform block is a transform block in which there are no non-zero coefficients in columns that are greater than a horizontal threshold and there are no non-zero coefficients in rows that are greater than a vertical threshold,an AC_HIGH_X category transform block is a transform block that does not have non-zero coefficients in row numbers that are greater than a vertical threshold and has at least one non-zero coefficient in at least one column that is larger than a horizontal threshold,an AC_HIGH_Y category transform block is a transform block that does not have non-zero coefficients in column numbers that are greater than a horizontal threshold and has at least one non-zero coefficient in at least one row that is larger than a vertical threshold, andan AC_HIGH category transform block is a transform block that has a non-zero coefficient at a position (x, y) where x is greater than a horizontal threshold and y is greater than a vertical threshold.
- The method of any of claims 1 to 3, wherein:the motion vector comprises a horizontal offset and a vertical offset, anddetermining the category of the transform block comprises:determining a first category of the transform block, the first category used for determining a horizontal context for coding the horizontal offset; anddetermining a second category of the transform block, the second category used for determining a vertical context for coding the vertical offset.
- The method of claim 1, further comprising:determining a first category for a first transform block for the current block;determining a second category for a second transform block for the current block;selecting the first category when the first transform block has a higher number of non-zero coefficients than the second transform block; andselecting the second category when the second transform block has a higher number of non-zero coefficients than the first transform block.
- An method for decoding, comprising:decoding, from an encoded bitstream, a transform block for a current block, the transform block corresponding to a residual block for the current block;determining, using positions of non-zero coefficients of the transform block, a category of the transform block that correlates to an energy distribution in the residual block, the category being one of a plurality of categories, and each category of the plurality of categories defined by a different energy distribution;determining, using the category, a context for decoding a motion vector used for encoding the current block; anddecoding, from the encoded bitstream, the motion vector using the context.
- The method of claim 6, further comprising:inter predicting the current block using the motion vector to generate a prediction block;determining the residual block using the transform block; andreconstructing the current block by combining the residual block with the prediction block.
- The method of claim 6 or 7, wherein determining the category of the transform block comprises:determining a first category for a first transform block for the current block;determining a second category for a second transform block for the current block; andselecting, as the category of the transform block, one of the first category and the second category based on which of the first transform block and the second transform block has a higher number of non-zero coefficients.
- The method of any of claims 6 to 8, wherein the category is further determined based on a size of the transform block.
- The method of any of claims 6 to 9, wherein the category is selected from a set consisting of DC_ONLY, AC_LOW, AC_HIGH_X, AC_HIGH_Y, and AC_HIGH, and wherein:a DC_ONLY category transform block is a transform block in which the only non-zero coefficient is at location (0, 0),an AC_LOW category transform block is a transform block in which there are no non-zero coefficients in columns that are greater than a horizontal threshold and there are no non-zero coefficients in rows that are greater than a vertical threshold,an AC_HIGH_X category transform block is a transform block that does not have non-zero coefficients in row numbers that are greater than a vertical threshold and has at least one non-zero coefficient in at least one column that is larger than a horizontal threshold,an AC_HIGH_Y category transform block is a transform block that does not have non-zero coefficients in column numbers that are greater than a horizontal threshold and has at least one non-zero coefficient in at least one row that is larger than a vertical threshold, andan AC_HIGH category transform block is a transform block that has a non-zero coefficient at a position (x, y) where x is greater than a horizontal threshold and y is greater than a vertical threshold.
- The method of claim 6 or 7, wherein:the motion vector comprises a horizontal offset and a vertical offset, anddetermining the category of the transform block comprises:determining a first category of the transform block, the first category used to determine a horizontal context for coding the horizontal offset; anddetermining a second category of the transform block, the second category used to determine a vertical context for coding the vertical offset.
- The method of claim 4 or 11, wherein:the first category is selected from a set consisting of DC_ONLY, AC_LOW_X, and AC_HIGH_X,the second category is selected from a set consisting of DC_ONLY, AC_LOW_Y, and AC_HIGH_Y,a DC_ONLY category transform block is a transform block in which the only non-zero coefficient is at location (0, 0),an AC_HIGH_X category transform block is a transform block that does not have non-zero coefficients in row numbers that are greater than a vertical threshold and has at least one non-zero coefficient in at least one column that is larger than a horizontal threshold,an AC_HIGH_Y category transform block is a transform block that does not have non-zero coefficients in column numbers that are greater than a horizontal threshold and has at least one non-zero coefficient in at least one row that is larger than a vertical threshold,an AC_LOW_X category transform block is a transform block in which there are no non-zero coefficients in columns that are greater than a horizontal threshold, andan AC_LOW_Y transform block is a transform block in which there are no non-zero coefficients in rows that are greater than a vertical threshold.
- The method of claim 4 or 11, wherein:the first category is selected from a set consisting of AC_LOW_X and AC_HIGH_X, the second category is selected from a set consisting of AC_LOW_Y and AC_HIGH_Y,an AC_HIGH_X category transform block is a transform block that does not have non-zero coefficients in row numbers that are greater than a vertical threshold and has at least one non-zero coefficient in at least one column that is larger than a horizontal threshold,an AC_HIGH_Y category transform block is a transform block that does not have non-zero coefficients in column numbers that are greater than a horizontal threshold and has at least one non-zero coefficient in at least one row that is larger than a vertical threshold,an AC_LOW_X category transform block is a transform block in which there are no non-zero coefficients in columns that are greater than a horizontal threshold, andan AC_LOW_Y transform block is a transform block in which there are no non-zero coefficients in rows that are greater than a vertical threshold.
- An apparatus , comprising:a memory;a processor, the memory includes instructions executable by the processor to perform the method of any preceding claim.
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US15/845,307 US10694205B2 (en) | 2017-12-18 | 2017-12-18 | Entropy coding of motion vectors using categories of transform blocks |
PCT/US2018/051264 WO2019125553A1 (en) | 2017-12-18 | 2018-09-16 | Motion vector coding using residual block energy distribution |
Publications (2)
Publication Number | Publication Date |
---|---|
EP3729810A1 EP3729810A1 (en) | 2020-10-28 |
EP3729810B1 true EP3729810B1 (en) | 2022-03-09 |
Family
ID=63763011
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
EP18782604.5A Active EP3729810B1 (en) | 2017-12-18 | 2018-09-16 | Motion vector coding using residual block energy distribution |
Country Status (4)
Country | Link |
---|---|
US (1) | US10694205B2 (en) |
EP (1) | EP3729810B1 (en) |
CN (1) | CN110741638B (en) |
WO (1) | WO2019125553A1 (en) |
Families Citing this family (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US10462486B1 (en) * | 2018-05-07 | 2019-10-29 | Tencent America, Llc | Fast method for implementing discrete sine transform type VII (DST 7) |
US11736720B2 (en) * | 2019-09-03 | 2023-08-22 | Tencent America LLC | Motion vector refinement methods for video encoding |
CN112565789B (en) * | 2019-11-13 | 2021-09-17 | 腾讯科技（深圳）有限公司 | Video decoding and encoding method, device, computer readable medium and electronic equipment |
US11310504B2 (en) * | 2020-07-30 | 2022-04-19 | Tencent America LLC | Complexity reduction for 32-p and 64-p LGT |
US11924467B2 (en) * | 2021-11-16 | 2024-03-05 | Google Llc | Mapping-aware coding tools for 360 degree videos |
Family Cites Families (25)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5111292A (en) * | 1991-02-27 | 1992-05-05 | General Electric Company | Priority selection apparatus as for a video signal processor |
DE19521992A1 (en) * | 1995-06-20 | 1997-01-02 | Bosch Gmbh Robert | Method for generating a stream of image data for the transmission of an image and method for evaluating a stream of image data |
US6438168B2 (en) * | 2000-06-27 | 2002-08-20 | Bamboo Media Casting, Inc. | Bandwidth scaling of a compressed video stream |
EP1520431B1 (en) * | 2002-07-01 | 2018-12-26 | E G Technology Inc. | Efficient compression and transport of video over a network |
FR2879878B1 (en) * | 2004-12-22 | 2007-05-25 | Thales Sa | COMPATIBLE SELECTIVE ENCRYPTION METHOD FOR VIDEO STREAM |
US7995649B2 (en) * | 2006-04-07 | 2011-08-09 | Microsoft Corporation | Quantization adjustment based on texture level |
KR100721022B1 (en) * | 2006-11-07 | 2007-05-25 | 엘지전자 주식회사 | Mehtod for filtering block boundary region |
US8422803B2 (en) | 2007-06-28 | 2013-04-16 | Mitsubishi Electric Corporation | Image encoding device, image decoding device, image encoding method and image decoding method |
US8265144B2 (en) * | 2007-06-30 | 2012-09-11 | Microsoft Corporation | Innovations in video decoder implementations |
KR101247923B1 (en) * | 2008-10-03 | 2013-03-26 | 퀄컴 인코포레이티드 | Video coding using transforms bigger than 4×4 and 8×8 |
EP2472872A1 (en) * | 2009-08-26 | 2012-07-04 | Sharp Kabushiki Kaisha | Image encoding device and image decoding device |
KR101791242B1 (en) * | 2010-04-16 | 2017-10-30 | 에스케이텔레콤 주식회사 | Video Coding and Decoding Method and Apparatus |
US20120057629A1 (en) * | 2010-09-02 | 2012-03-08 | Fang Shi | Rho-domain Metrics |
US9106913B2 (en) * | 2011-03-08 | 2015-08-11 | Qualcomm Incorporated | Coding of transform coefficients for video coding |
CA2839560C (en) * | 2011-06-16 | 2016-10-04 | Fraunhofer-Gesellschaft Zur Forderung Der Angewandten Forschung E.V. | Entropy coding of motion vector differences |
KR101830352B1 (en) * | 2011-11-09 | 2018-02-21 | 에스케이 텔레콤주식회사 | Method and Apparatus Video Encoding and Decoding using Skip Mode |
US9247257B1 (en) * | 2011-11-30 | 2016-01-26 | Google Inc. | Segmentation based entropy encoding and decoding |
US20130170553A1 (en) | 2012-01-04 | 2013-07-04 | Qualcomm Incorporated | Coding motion vector difference |
US9681128B1 (en) * | 2013-01-31 | 2017-06-13 | Google Inc. | Adaptive pre-transform scanning patterns for video and image compression |
US20140348240A1 (en) * | 2013-05-22 | 2014-11-27 | Qualcomm Incorporated | Video coding using sample prediction among color components |
US9392288B2 (en) * | 2013-10-17 | 2016-07-12 | Google Inc. | Video coding using scatter-based scan tables |
WO2015100514A1 (en) * | 2013-12-30 | 2015-07-09 | Qualcomm Incorporated | Simplification of delta dc residual coding in 3d video coding |
KR102358276B1 (en) * | 2014-09-30 | 2022-02-04 | 마이크로소프트 테크놀로지 라이센싱, 엘엘씨 | Hash-based encoder decisions for video coding |
US9807423B1 (en) * | 2015-11-24 | 2017-10-31 | Google Inc. | Hybrid transform scheme for video coding |
US10244261B2 (en) * | 2017-01-26 | 2019-03-26 | Google Llc | Transform coefficient coding using level maps |
-
2017
- 2017-12-18 US US15/845,307 patent/US10694205B2/en active Active
-
2018
- 2018-09-16 WO PCT/US2018/051264 patent/WO2019125553A1/en unknown
- 2018-09-16 EP EP18782604.5A patent/EP3729810B1/en active Active
- 2018-09-16 CN CN201880036832.5A patent/CN110741638B/en active Active
Also Published As
Publication number | Publication date |
---|---|
WO2019125553A1 (en) | 2019-06-27 |
EP3729810A1 (en) | 2020-10-28 |
US10694205B2 (en) | 2020-06-23 |
US20190191177A1 (en) | 2019-06-20 |
CN110741638A (en) | 2020-01-31 |
CN110741638B (en) | 2023-10-13 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US20220377364A1 (en) | Constrained motion field estimation for hardware efficiency | |
US11405645B2 (en) | Transform kernel selection and entropy coding | |
US10116957B2 (en) | Dual filter type for motion compensated prediction in video coding | |
EP3729810B1 (en) | Motion vector coding using residual block energy distribution | |
US9210432B2 (en) | Lossless inter-frame video coding | |
WO2017131908A1 (en) | Dynamic reference motion vector coding mode | |
US20210021859A1 (en) | Same frame motion estimation and compensation | |
US10271062B2 (en) | Motion vector prediction through scaling | |
US10582212B2 (en) | Warped reference motion vectors for video compression | |
WO2018169571A1 (en) | Segmentation-based parameterized motion models | |
US10225578B2 (en) | Intra-prediction edge filtering | |
EP3714601A1 (en) | Motion field-based reference frame rendering for motion compensated prediction in video coding | |
US20140098854A1 (en) | Lossless intra-prediction video coding | |
US10951894B2 (en) | Transform block-level scan order selection for video coding | |
WO2019036080A1 (en) | Constrained motion field estimation for inter prediction | |
US10419777B2 (en) | Non-causal overlapped block prediction in variable block size video coding | |
US11197004B1 (en) | Inter-prediction mode-dependent transforms for video coding | |
US10455253B1 (en) | Single direction long interpolation filter | |
US20190174137A1 (en) | Embedding information about eob positions | |
US10499078B1 (en) | Implicit motion compensation filter selection | |
GB2547754A (en) | Dynamic reference motion vector coding mode | |
WO2024081012A1 (en) | Inter-prediction with filtering |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: UNKNOWN |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: THE INTERNATIONAL PUBLICATION HAS BEEN MADE |
|
PUAI | Public reference made under article 153(3) epc to a published international application that has entered the european phase |
Free format text: ORIGINAL CODE: 0009012 |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: REQUEST FOR EXAMINATION WAS MADE |
|
17P | Request for examination filed |
Effective date: 20191213 |
|
AK | Designated contracting states |
Kind code of ref document: A1Designated state(s): AL AT BE BG CH CY CZ DE DK EE ES FI FR GB GR HR HU IE IS IT LI LT LU LV MC MK MT NL NO PL PT RO RS SE SI SK SM TR |
|
AX | Request for extension of the european patent |
Extension state: BA ME |
|
DAV | Request for validation of the european patent (deleted) | ||
DAX | Request for extension of the european patent (deleted) | ||
GRAP | Despatch of communication of intention to grant a patent |
Free format text: ORIGINAL CODE: EPIDOSNIGR1 |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: GRANT OF PATENT IS INTENDED |
|
INTG | Intention to grant announced |
Effective date: 20210924 |
|
GRAS | Grant fee paid |
Free format text: ORIGINAL CODE: EPIDOSNIGR3 |
|
GRAA | (expected) grant |
Free format text: ORIGINAL CODE: 0009210 |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: THE PATENT HAS BEEN GRANTED |
|
AK | Designated contracting states |
Kind code of ref document: B1Designated state(s): AL AT BE BG CH CY CZ DE DK EE ES FI FR GB GR HR HU IE IS IT LI LT LU LV MC MK MT NL NO PL PT RO RS SE SI SK SM TR |
|
REG | Reference to a national code |
Ref country code: CHRef legal event code: EPRef country code: ATRef legal event code: REFRef document number: 1475117Country of ref document: ATKind code of ref document: TEffective date: 20220315 |
|
REG | Reference to a national code |
Ref country code: DERef legal event code: R096Ref document number: 602018032048Country of ref document: DE |
|
REG | Reference to a national code |
Ref country code: IERef legal event code: FG4D |
|
REG | Reference to a national code |
Ref country code: LTRef legal event code: MG9D |
|
REG | Reference to a national code |
Ref country code: NLRef legal event code: MPEffective date: 20220309 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: SEFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220309Ref country code: RSFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220309Ref country code: NOFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220609Ref country code: LTFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220309Ref country code: HRFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220309Ref country code: BGFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220609 |
|
REG | Reference to a national code |
Ref country code: ATRef legal event code: MK05Ref document number: 1475117Country of ref document: ATKind code of ref document: TEffective date: 20220309 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: LVFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220309Ref country code: GRFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220610Ref country code: FIFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220309 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: NLFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220309 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: SMFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220309Ref country code: SKFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220309Ref country code: ROFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220309Ref country code: PTFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220711Ref country code: ESFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220309Ref country code: EEFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220309Ref country code: CZFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220309Ref country code: ATFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220309 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: PLFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220309Ref country code: ISFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220709Ref country code: ALFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220309 |
|
REG | Reference to a national code |
Ref country code: DERef legal event code: R097Ref document number: 602018032048Country of ref document: DE |
|
PLBE | No opposition filed within time limit |
Free format text: ORIGINAL CODE: 0009261 |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: NO OPPOSITION FILED WITHIN TIME LIMIT |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: DKFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220309 |
|
26N | No opposition filed |
Effective date: 20221212 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: SIFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220309 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: MCFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220309 |
|
REG | Reference to a national code |
Ref country code: CHRef legal event code: PL |
|
REG | Reference to a national code |
Ref country code: BERef legal event code: MMEffective date: 20220930 |
|
P01 | Opt-out of the competence of the unified patent court (upc) registered |
Effective date: 20230508 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: LUFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20220916 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: LIFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20220930Ref country code: ITFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220309Ref country code: IEFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20220916Ref country code: CHFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20220930 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: BEFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20220930 |
|
PGFP | Annual fee paid to national office [announced via postgrant information from national office to epo] |
Ref country code: GBPayment date: 20230927Year of fee payment: 6 |
|
PGFP | Annual fee paid to national office [announced via postgrant information from national office to epo] |
Ref country code: FRPayment date: 20230925Year of fee payment: 6Ref country code: DEPayment date: 20230927Year of fee payment: 6 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: CYFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20220309 |